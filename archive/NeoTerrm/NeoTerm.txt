Project Path: arc_NeoTerrm_NeoTerm_fo08xqr3

Source Tree:

```txt
arc_NeoTerrm_NeoTerm_fo08xqr3
├── CODE_OF_CONDUCT.md
├── CONTRIBUTING.md
├── LICENSE
├── NeoLang
│   ├── build.gradle
│   ├── example
│   │   ├── color-scheme.nl
│   │   ├── extra-key.nl
│   │   └── profile.nl
│   └── src
│       └── main
│           └── java
│               └── io
│                   └── neolang
│                       ├── frontend
│                       │   ├── abstract-visitors.kt
│                       │   ├── frontend.kt
│                       │   ├── nodes.kt
│                       │   ├── tokens.kt
│                       │   └── visitors.kt
│                       └── runtime
│                           ├── context.kt
│                           └── types.kt
├── NeoTermBridge
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── AndroidManifest.xml
│       │   ├── aidl
│       │   │   └── io
│       │   │       └── neoterm
│       │   │           └── bridge
│       │   │               └── ISessionConnection.aidl
│       │   ├── java
│       │   │   └── io
│       │   │       └── neoterm
│       │   │           └── bridge
│       │   │               ├── Bridge.java
│       │   │               └── SessionId.java
│       │   └── res
│       │       └── values
│       │           └── strings.xml
│       └── test
│           └── java
│               └── io
│                   └── neoterm
│                       └── bridge
│                           └── ExampleUnitTest.java
├── README.md
├── Xorg
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── AndroidManifest.xml
│       │   ├── java
│       │   │   └── io
│       │   │       └── neoterm
│       │   │           ├── Accelerometer.java
│       │   │           ├── Audio.java
│       │   │           ├── Clipboard.java
│       │   │           ├── GLSurfaceView_SDL.java
│       │   │           ├── Globals.java
│       │   │           ├── Keycodes.java
│       │   │           ├── MainActivity.java
│       │   │           ├── NeoAccelerometerReader.java
│       │   │           ├── NeoAudioThread.java
│       │   │           ├── NeoGLView.java
│       │   │           ├── NeoRenderer.java
│       │   │           ├── NeoTextInput.java
│       │   │           ├── NeoXorgSettings.java
│       │   │           ├── Settings.java
│       │   │           ├── SettingsMenu.java
│       │   │           ├── SettingsMenuKeyboard.java
│       │   │           ├── SettingsMenuMisc.java
│       │   │           ├── SettingsMenuMouse.java
│       │   │           ├── Video.java
│       │   │           ├── XZInputStream.java
│       │   │           └── xorg
│       │   │               └── NeoXorgViewClient.java
│       │   └── res
│       │       ├── drawable
│       │       │   ├── b1.png
│       │       │   ├── b2.png
│       │       │   ├── b3.png
│       │       │   ├── b4.png
│       │       │   ├── b5.png
│       │       │   ├── b6.png
│       │       │   ├── calibrate.png
│       │       │   ├── dpad.png
│       │       │   ├── keyboard.png
│       │       │   ├── publisherlogo.png
│       │       │   ├── rectangle.png
│       │       │   ├── sun_b1.png
│       │       │   ├── sun_b2.png
│       │       │   ├── sun_b3.png
│       │       │   ├── sun_b4.png
│       │       │   ├── sun_b5.png
│       │       │   ├── sun_b6.png
│       │       │   ├── sun_dpad.png
│       │       │   ├── sun_keyboard.png
│       │       │   ├── tv_border_left.jpg
│       │       │   └── tv_border_top.jpg
│       │       ├── raw
│       │       │   ├── dualshock.raw
│       │       │   ├── gba.raw
│       │       │   ├── keen.raw
│       │       │   ├── n64.raw
│       │       │   ├── psx.raw
│       │       │   ├── retro.raw
│       │       │   ├── simpletheme.raw
│       │       │   ├── snes.raw
│       │       │   ├── sun.raw
│       │       │   └── ultimatedroid.raw
│       │       ├── values
│       │       │   ├── dimen.xml
│       │       │   ├── ids.xml
│       │       │   └── strings.xml
│       │       ├── values-zh
│       │       │   └── strings.xml
│       │       └── xml
│       │           ├── amiga.xml
│       │           ├── amiga_alt.xml
│       │           ├── amiga_alt_shift.xml
│       │           ├── amiga_old.xml
│       │           ├── amiga_shift.xml
│       │           ├── atari800.xml
│       │           ├── c64.xml
│       │           ├── qwerty.xml
│       │           ├── qwerty_alt.xml
│       │           ├── qwerty_alt_shift.xml
│       │           └── qwerty_shift.xml
│       └── test
│           └── java
│               └── io
│                   └── neoterm
│                       └── ExampleUnitTest.java
├── app
│   ├── CMakeLists.txt
│   ├── build.gradle
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── assets
│           │   ├── colors
│           │   │   ├── Default.nl
│           │   │   ├── Dracula.nl
│           │   │   ├── Material.nl
│           │   │   ├── SolarizedDark.nl
│           │   │   └── SolarizedLight.nl
│           │   ├── eks
│           │   │   ├── default.nl
│           │   │   └── vim.nl
│           │   ├── eks_font.ttf
│           │   ├── fonts
│           │   │   ├── SourceCodePro.ttf
│           │   │   └── UbuntuMono.ttf
│           │   └── scripts
│           │       ├── extract-archive
│           │       └── open-in-vim
│           ├── cpp
│           │   ├── exec.c
│           │   └── neoterm.cpp
│           ├── java
│           │   └── io
│           │       └── neoterm
│           │           ├── App.kt
│           │           ├── backend
│           │           │   ├── ByteQueue.java
│           │           │   ├── EmulatorDebug.java
│           │           │   ├── JNI.java
│           │           │   ├── KeyHandler.java
│           │           │   ├── TerminalBuffer.java
│           │           │   ├── TerminalColorScheme.java
│           │           │   ├── TerminalColors.java
│           │           │   ├── TerminalEmulator.java
│           │           │   ├── TerminalOutput.java
│           │           │   ├── TerminalRow.java
│           │           │   ├── TerminalSession.java
│           │           │   ├── TextStyle.java
│           │           │   └── WcWidth.java
│           │           ├── component
│           │           │   ├── codegen
│           │           │   │   ├── comp.kt
│           │           │   │   ├── generators.kt
│           │           │   │   └── interfaces.kt
│           │           │   ├── colorscheme
│           │           │   │   ├── comp.kt
│           │           │   │   └── data.kt
│           │           │   ├── comp.kt
│           │           │   ├── completion
│           │           │   │   ├── comp.kt
│           │           │   │   ├── data.kt
│           │           │   │   ├── listeners.kt
│           │           │   │   └── providers.kt
│           │           │   ├── config
│           │           │   │   ├── comp.kt
│           │           │   │   ├── defaults.kt
│           │           │   │   └── loaders.kt
│           │           │   ├── data.kt
│           │           │   ├── extrakey
│           │           │   │   ├── comp.kt
│           │           │   │   └── data.kt
│           │           │   ├── font
│           │           │   │   ├── comp.kt
│           │           │   │   └── data.kt
│           │           │   ├── pm
│           │           │   │   ├── NeoPackageParser.java
│           │           │   │   ├── PackageComponent.java
│           │           │   │   ├── Source.java
│           │           │   │   ├── data.kt
│           │           │   │   └── helper.kt
│           │           │   ├── profile
│           │           │   │   ├── comp.kt
│           │           │   │   └── data.kt
│           │           │   ├── session
│           │           │   │   ├── comp.kt
│           │           │   │   ├── shell.kt
│           │           │   │   └── x.kt
│           │           │   └── userscript
│           │           │       └── comp.kt
│           │           ├── framework
│           │           │   ├── NeoTermDatabase.java
│           │           │   ├── database
│           │           │   │   ├── DatabaseDataType.java
│           │           │   │   ├── NeoTermSQLiteConfig.java
│           │           │   │   ├── OnDatabaseUpgradedListener.java
│           │           │   │   ├── SQLStatementHelper.java
│           │           │   │   ├── SQLTypeParser.java
│           │           │   │   ├── TableHelper.java
│           │           │   │   ├── ValueHelper.java
│           │           │   │   ├── annotation
│           │           │   │   │   ├── ID.java
│           │           │   │   │   ├── Ignore.java
│           │           │   │   │   ├── NotNull.java
│           │           │   │   │   └── Table.java
│           │           │   │   └── bean
│           │           │   │       └── TableInfo.java
│           │           │   └── reflection
│           │           │       ├── NullPointer.java
│           │           │       ├── Reflect.java
│           │           │       └── ReflectionException.java
│           │           ├── frontend
│           │           │   ├── completion
│           │           │   │   ├── CandidatePopupWindow.kt
│           │           │   │   └── MaxHeightView.kt
│           │           │   ├── floating
│           │           │   │   └── dialog.kt
│           │           │   └── session
│           │           │       ├── terminal
│           │           │       │   ├── data.kt
│           │           │       │   ├── events.kt
│           │           │       │   ├── term-basic.kt
│           │           │       │   └── term-standard.kt
│           │           │       └── view
│           │           │           ├── GestureAndScaleRecognizer.kt
│           │           │           ├── TerminalRenderer.java
│           │           │           ├── TerminalView.java
│           │           │           ├── TerminalViewClient.java
│           │           │           └── extrakey
│           │           │               ├── CombinedSequence.kt
│           │           │               ├── ExtraKeysView.kt
│           │           │               └── buttons.kt
│           │           ├── services
│           │           │   └── NeoTermService.kt
│           │           ├── setup
│           │           │   ├── SetupThread.java
│           │           │   ├── SourceConnection.java
│           │           │   ├── connections.kt
│           │           │   └── setup.kt
│           │           ├── ui
│           │           │   ├── customize
│           │           │   │   ├── BaseCustomizeActivity.kt
│           │           │   │   ├── ColorSchemeActivity.kt
│           │           │   │   ├── CustomizeActivity.kt
│           │           │   │   └── model.kt
│           │           │   ├── other
│           │           │   │   ├── AboutActivity.kt
│           │           │   │   ├── BonusActivity.kt
│           │           │   │   ├── CrashActivity.kt
│           │           │   │   └── SetupActivity.kt
│           │           │   ├── pm
│           │           │   │   ├── PackageManagerActivity.kt
│           │           │   │   ├── model.kt
│           │           │   │   └── view
│           │           │   │       └── RecyclerTabLayout.java
│           │           │   ├── settings
│           │           │   │   ├── BasePreferenceActivity.kt
│           │           │   │   ├── GeneralSettingsActivity.kt
│           │           │   │   ├── SettingActivity.kt
│           │           │   │   └── UISettingsActivity.kt
│           │           │   └── term
│           │           │       ├── NeoTermActivity.kt
│           │           │       ├── NeoTermRemoteInterface.kt
│           │           │       ├── SessionRemover.kt
│           │           │       └── tabs.kt
│           │           └── utils
│           │               ├── CrashHandler.kt
│           │               ├── FullScreenHelper.kt
│           │               ├── NLog.kt
│           │               ├── NeoPermission.kt
│           │               ├── StringDistance.java
│           │               ├── Terminals.kt
│           │               └── utils.kt
│           ├── jniLibs
│           │   └── arm64-v8a
│           │       └── libnexec.so
│           └── res
│               ├── drawable
│               │   ├── banner.png
│               │   ├── ic_description.xml
│               │   ├── ic_donate.xml
│               │   ├── ic_github.xml
│               │   ├── ic_info.xml
│               │   ├── ic_neoterm.xml
│               │   ├── ic_new_session.xml
│               │   ├── ic_person.xml
│               │   ├── ic_tab_icon.png
│               │   ├── ic_terminal_running.xml
│               │   ├── plat_logo.png
│               │   ├── text_select_handle_left_material.xml
│               │   └── text_select_handle_right_material.xml
│               ├── drawable-hdpi
│               │   ├── ic_add_box_white_24dp.png
│               │   ├── ic_apps_white_36dp.png
│               │   ├── ic_backup_restore_white_36dp.png
│               │   ├── ic_customization_white_36dp.png
│               │   ├── ic_done.png
│               │   ├── ic_general_white_36dp.png
│               │   ├── ic_guide_white_36dp.png
│               │   ├── ic_info_white_36dp.png
│               │   ├── ic_install_white_36.png
│               │   ├── ic_search.png
│               │   └── ic_ui_white_36dp.png
│               ├── drawable-mdpi
│               │   ├── ic_add_box_white_24dp.png
│               │   └── ic_search.png
│               ├── drawable-xhdpi
│               │   ├── ic_add_box_white_24dp.png
│               │   └── ic_search.png
│               ├── drawable-xxhdpi
│               │   ├── ic_add_box_white_24dp.png
│               │   ├── ic_search.png
│               │   ├── text_select_handle_left_mtrl_alpha.png
│               │   └── text_select_handle_right_mtrl_alpha.png
│               ├── drawable-xxxhdpi
│               │   └── ic_add_box_white_24dp.png
│               ├── layout
│               │   ├── dialog_edit_text.xml
│               │   ├── dialog_edit_two_text.xml
│               │   ├── item_color.xml
│               │   ├── item_complete_candidate.xml
│               │   ├── item_package.xml
│               │   ├── layout_pm_package_list.xml
│               │   ├── popup_auto_complete.xml
│               │   ├── ui_about.xml
│               │   ├── ui_color_scheme.xml
│               │   ├── ui_command_shortcut.xml
│               │   ├── ui_crash.xml
│               │   ├── ui_customize.xml
│               │   ├── ui_faq.xml
│               │   ├── ui_main.xml
│               │   ├── ui_pm.xml
│               │   ├── ui_pm_single_tab.xml
│               │   ├── ui_setup.xml
│               │   ├── ui_term.xml
│               │   ├── ui_term_dialog.xml
│               │   ├── ui_term_embedded.xml
│               │   ├── ui_user_script_list.xml
│               │   └── ui_xorg.xml
│               ├── menu
│               │   ├── menu_color_editor.xml
│               │   ├── menu_main.xml
│               │   └── menu_pm.xml
│               ├── mipmap-hdpi
│               │   ├── about_logo.png
│               │   └── ic_danger.png
│               ├── mipmap-xhdpi
│               │   ├── about_logo.png
│               │   └── ic_danger.png
│               ├── mipmap-xxhdpi
│               │   ├── about_logo.png
│               │   └── ic_danger.png
│               ├── mipmap-xxxhdpi
│               │   ├── about_logo.png
│               │   ├── ic_danger.png
│               │   └── ic_launcher_neoterm_round.png
│               ├── raw
│               │   └── bell.ogg
│               ├── values
│               │   ├── attrs.xml
│               │   ├── colors.xml
│               │   ├── dimens.xml
│               │   ├── preference_keys.xml
│               │   ├── shortcut_configs.xml
│               │   ├── strings.xml
│               │   └── styles.xml
│               ├── values-zh-rCN
│               │   └── strings.xml
│               ├── values-zh-rTW
│               │   └── strings.xml
│               └── xml
│                   ├── app_shortcuts.xml
│                   ├── backup_config.xml
│                   ├── setting_general.xml
│                   ├── settings_main.xml
│                   └── settings_ui.xml
├── artwork
│   ├── NeoTerm_round.psd
│   ├── NeoTerm_round_border.psd
│   ├── neoterm.psd
│   └── old
│       ├── icon-512-old.png
│       ├── icon-512.png
│       └── neoterm.psd
├── build.gradle
├── chrome-tabs
│   ├── build.gradle
│   ├── gradle.properties
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── java
│           │   └── de
│           │       └── mrapp
│           │           └── android
│           │               └── tabswitcher
│           │                   ├── Animation.java
│           │                   ├── Layout.java
│           │                   ├── LayoutPolicy.java
│           │                   ├── PeekAnimation.java
│           │                   ├── RevealAnimation.java
│           │                   ├── SwipeAnimation.java
│           │                   ├── Tab.java
│           │                   ├── TabCloseListener.java
│           │                   ├── TabPreviewListener.java
│           │                   ├── TabSwitcher.java
│           │                   ├── TabSwitcherDecorator.java
│           │                   ├── TabSwitcherListener.java
│           │                   ├── drawable
│           │                   │   └── TabSwitcherDrawable.java
│           │                   ├── iterator
│           │                   │   ├── AbstractTabItemIterator.java
│           │                   │   ├── ArrayTabItemIterator.java
│           │                   │   └── TabItemIterator.java
│           │                   ├── layout
│           │                   │   ├── AbstractDragHandler.java
│           │                   │   ├── AbstractTabSwitcherLayout.java
│           │                   │   ├── AbstractTabViewHolder.java
│           │                   │   ├── Arithmetics.java
│           │                   │   ├── ChildRecyclerAdapter.java
│           │                   │   ├── TabSwitcherLayout.java
│           │                   │   └── phone
│           │                   │       ├── PhoneArithmetics.java
│           │                   │       ├── PhoneDragHandler.java
│           │                   │       ├── PhoneRecyclerAdapter.java
│           │                   │       ├── PhoneTabSwitcherLayout.java
│           │                   │       ├── PhoneTabViewHolder.java
│           │                   │       └── PreviewDataBinder.java
│           │                   ├── model
│           │                   │   ├── Model.java
│           │                   │   ├── Restorable.java
│           │                   │   ├── State.java
│           │                   │   ├── TabItem.java
│           │                   │   ├── TabSwitcherModel.java
│           │                   │   └── Tag.java
│           │                   └── view
│           │                       └── TabSwitcherButton.java
│           └── res
│               ├── drawable-hdpi
│               │   ├── phone_close_tab_icon.png
│               │   ├── phone_tab_background.9.png
│               │   ├── phone_tab_border.9.png
│               │   └── tab_switcher_drawable_background.png
│               ├── drawable-mdpi
│               │   ├── ic_close_tab_18dp.png
│               │   ├── phone_tab_background.9.png
│               │   ├── phone_tab_border.9.png
│               │   └── tab_switcher_drawable_background.png
│               ├── drawable-xhdpi
│               │   ├── ic_close_tab_18dp.png
│               │   ├── phone_tab_background.9.png
│               │   ├── phone_tab_border.9.png
│               │   └── tab_switcher_drawable_background.png
│               ├── drawable-xxhdpi
│               │   ├── ic_close_tab_18dp.png
│               │   ├── phone_tab_background.9.png
│               │   ├── phone_tab_border.9.png
│               │   └── tab_switcher_drawable_background.png
│               ├── drawable-xxxhdpi
│               │   ├── ic_close_tab_18dp.png
│               │   ├── phone_tab_background.9.png
│               │   ├── phone_tab_border.9.png
│               │   └── tab_switcher_drawable_background.png
│               ├── layout
│               │   ├── phone_tab.xml
│               │   ├── phone_toolbar.xml
│               │   └── tab_switcher_menu_item.xml
│               ├── layout-land
│               │   └── phone_tab.xml
│               ├── values
│               │   ├── attrs.xml
│               │   ├── colors.xml
│               │   ├── dimens.xml
│               │   ├── ids.xml
│               │   ├── integers.xml
│               │   └── styles.xml
│               └── values-v21
│                   └── styles.xml
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

```

`CODE_OF_CONDUCT.md`:

```md
# Contributor Covenant Code of Conduct

## Our Pledge

Originally, NeoTerm was designed as the front end of [Termux](https://github.com/termux/termux-app) to provide some
functions that Termux didn't have, but we found it very convenient. In continuous development, we discovered our goal:
to be the best terminal for Android. In the interest of fostering an open and welcoming environment, we as contributors
and maintainers pledge to making participation in our project and our community a harassment-free experience for
everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience,
nationality, personal appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members
* Free for forever

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take
appropriate and fair corrective action in response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits,
issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any
contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the
project or its community. Examples of representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed representative at an online or offline
event. Representation of a project may be further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at
kiva515@foxmail.com. The project team will review and investigate all complaints, and will respond in a way that it
deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the
reporter of an incident. Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent
repercussions as determined by other members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4, available
at [http://contributor-covenant.org/version/1/4][version]

[homepage]: http://contributor-covenant.org

[version]: http://contributor-covenant.org/version/1/4/

```

`CONTRIBUTING.md`:

```md
# Contributing

# How to

NeoTerm is a free software, so any contributions and any contribution types are welcomed!


```

`LICENSE`:

```
GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. [http://fsf.org/]
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {fullname}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see [http://www.gnu.org/licenses/].

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    NeoTerm  Copyright (C) 2017  NeoTerm Developers
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
[http://www.gnu.org/licenses/].

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
[http://www.gnu.org/philosophy/why-not-lgpl.html].

```

`NeoLang/build.gradle`:

```gradle
apply plugin: 'java-library'
apply plugin: 'kotlin'

dependencies {
  implementation fileTree(dir: 'libs', include: ['*.jar'])
  compile rootProject.ext.deps["kotlin-stdlib"]
}

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath rootProject.ext.deps["kotlin-gradle-plugin"]
  }
}
repositories {
  mavenCentral()
}
compileKotlin {
  kotlinOptions {
    jvmTarget = "1.8"
  }
}
compileTestKotlin {
  kotlinOptions {
    jvmTarget = "1.8"
  }
}
dependencies {
  testImplementation rootProject.ext.deps["junit"]
}

```

`NeoLang/example/color-scheme.nl`:

```nl
color-scheme: {
    name: "NeoTerm Default Color Scheme"
    version: 1.1

    colors: {
        background: #777721
        foreground: #111233
        color1: #color1
        color2: #color2
    }
}

```

`NeoLang/example/extra-key.nl`:

```nl
extra-key: {
    version: 10
    with-default: true

    program: [ "vim", "vi" ]

    key: [
        {
           display: "Ctrl"
           code: "<CTRL>"
           with-enter: true
        },
        {
            display: "Esc"
            code: "<ESC>"
        }
    ]
}

```

`NeoLang/example/profile.nl`:

```nl
profile-shell: {
    name: "Simple Profile"
    bell: true
}

```

`NeoLang/src/main/java/io/neolang/frontend/abstract-visitors.kt`:

```kt
package io.neolang.frontend

import io.neolang.runtime.NeoLangContext
import io.neolang.runtime.NeoLangValue

/**
 * @author kiva
 */
class AstVisitor(private val ast: NeoLangAst, private val visitorCallback: IVisitorCallback) {
  fun start() {
    AstVisitorImpl.visitStartAst(ast, visitorCallback)
  }

  @Suppress("UNCHECKED_CAST")
  fun <T : IVisitorCallback> getCallback(): T {
    return visitorCallback as T
  }
}

/**
 * @author kiva
 */
internal object AstVisitorImpl {
  fun visitProgram(ast: NeoLangProgramNode, visitorCallback: IVisitorCallback) {
    visitorCallback.onStart()
    ast.groups.forEach { visitGroup(it, visitorCallback) }
    visitorCallback.onFinish()
  }

  fun visitGroup(ast: NeoLangGroupNode, visitorCallback: IVisitorCallback) {
    ast.attributes.forEach {
      visitAttribute(it, visitorCallback)
    }
  }

  fun visitAttribute(ast: NeoLangAttributeNode, visitorCallback: IVisitorCallback) {
    visitBlock(ast.blockNode, ast.stringNode.eval().asString(), visitorCallback)
  }

  fun visitArray(ast: NeoLangArrayNode, visitorCallback: IVisitorCallback) {
    val arrayName = ast.arrayNameNode.eval().asString()

    visitorCallback.onEnterContext(arrayName)
    ast.elements.forEach {
      AstVisitorImpl.visitArrayElementBlock(it.block, it.index, visitorCallback)
//            AstVisitorImpl.visitBlock(it.block, it.index.toString(), visitorCallback)
    }
    visitorCallback.onExitContext()
  }

  fun visitArrayElementBlock(ast: NeoLangBlockNode, index: Int, visitorCallback: IVisitorCallback) {
    val visitingNode = ast.ast
    when (visitingNode) {
      is NeoLangGroupNode -> {
        // is a sub block, e.g.
        // block: { $blockName: {} }
        visitorCallback.onEnterContext(index.toString())
        AstVisitorImpl.visitGroup(visitingNode, visitorCallback)
        visitorCallback.onExitContext()
      }
      is NeoLangStringNode -> {
        definePrimaryData(index.toString(), visitingNode.eval(), visitorCallback)
      }
      is NeoLangNumberNode -> {
        definePrimaryData(index.toString(), visitingNode.eval(), visitorCallback)
      }
    }
  }

  fun visitBlock(ast: NeoLangBlockNode, blockName: String, visitorCallback: IVisitorCallback) {
    val visitingNode = ast.ast
    when (visitingNode) {
      is NeoLangGroupNode -> {
        // is a sub block, e.g.
        // block: { $blockName: {} }

        visitorCallback.onEnterContext(blockName)
        AstVisitorImpl.visitGroup(visitingNode, visitorCallback)
        visitorCallback.onExitContext()
      }
      is NeoLangArrayNode -> {
        // array: [ "a", "b", "c", 1, 2, 3 ]
        AstVisitorImpl.visitArray(visitingNode, visitorCallback)
      }
      is NeoLangStringNode -> {
        // block: { $blockName: "hello" }
        definePrimaryData(blockName, visitingNode.eval(), visitorCallback)
      }
      is NeoLangNumberNode -> {
        // block: { $blockName: 123.456 }
        definePrimaryData(blockName, visitingNode.eval(), visitorCallback)
      }
    }
  }

  private fun definePrimaryData(name: String, value: NeoLangValue, visitorCallback: IVisitorCallback) {
    visitorCallback.getCurrentContext().defineAttribute(name, value)
  }

  fun visitStartAst(ast: NeoLangAst, visitorCallback: IVisitorCallback) {
    when (ast) {
      is NeoLangProgramNode -> AstVisitorImpl.visitProgram(ast, visitorCallback)
      is NeoLangGroupNode -> AstVisitorImpl.visitGroup(ast, visitorCallback)
      is NeoLangArrayNode -> AstVisitorImpl.visitArray(ast, visitorCallback)
    }
  }
}

/**
 * @author kiva
 */
interface IVisitorCallback {
  fun onStart()

  fun onFinish()

  fun onEnterContext(contextName: String)

  fun onExitContext()

  fun getCurrentContext(): NeoLangContext
}

/**
 * @author kiva
 */
open class IVisitorCallbackAdapter : IVisitorCallback {
  override fun onStart() {
  }

  override fun onFinish() {
  }

  override fun onEnterContext(contextName: String) {
  }

  override fun onExitContext() {
  }

  override fun getCurrentContext(): NeoLangContext {
    throw RuntimeException("getCurrentContext() not supported in this IVisitorCallback!")
  }
}

/**
 * @author kiva
 */

class VisitorFactory(private val ast: NeoLangAst) {

  fun getVisitor(callbackInterface: Class<out IVisitorCallback>): AstVisitor? {
    try {
      return AstVisitor(ast, callbackInterface.newInstance())
    } catch (e: Exception) {
      return null
    }
  }
}

```

`NeoLang/src/main/java/io/neolang/frontend/frontend.kt`:

```kt
package io.neolang.frontend

/**
 * @author kiva
 */
class NeoLangLexer {
  private var programCode: String? = null
  private var currentPosition: Int = 0
  private var currentChar: Char = ' '
  private var lineNumber = 0

  internal fun setInputSource(programCode: String?) {
    this.programCode = programCode
  }

  internal fun lex(): List<NeoLangToken> {
    val programCode = this.programCode ?: return listOf()
    val tokens = ArrayList<NeoLangToken>()
    currentPosition = 0
    lineNumber = 1

    if (programCode.isNotEmpty()) {
      currentChar = programCode[currentPosition]

      while (currentPosition < programCode.length) {
        val token = nextToken
        if (token is NeoLangEOFToken) {
          break
        }
        tokens.add(token)
      }
    }
    return tokens
  }

  private fun moveToNextChar(eofThrow: Boolean = false): Boolean {
    val programCode = this.programCode ?: return false
    currentPosition++
    if (currentPosition >= programCode.length) {
      if (eofThrow) {
        throw InvalidTokenException("Unexpected EOF near `$currentChar' in line $lineNumber")
      }
      return false
    } else {
      currentChar = programCode[currentPosition]
      return true
    }
  }

  private val nextToken: NeoLangToken
    get() {
      val programCode = this.programCode ?: return NeoLangEOFToken()

      while (currentChar == ' '
        || currentChar == '\t'
        || currentChar == '\n'
        || currentChar == '\r'
      ) {
        if (currentChar == '\n') {
          ++lineNumber
        }
        // Skip white chars
        if (!moveToNextChar()) {
          return NeoLangEOFToken()
        }
      }

      if (currentPosition >= programCode.length) {
        return NeoLangEOFToken()
      }

      val currentToken = NeoLangTokenValue.wrap(currentChar.toString())
      val token: NeoLangToken = when (currentToken) {
        NeoLangTokenValue.COLON -> {
          moveToNextChar(eofThrow = true)
          NeoLangToken(NeoLangTokenType.COLON, currentToken)
        }
        NeoLangTokenValue.BRACKET_START -> {
          moveToNextChar(eofThrow = true)
          NeoLangToken(NeoLangTokenType.BRACKET_START, currentToken)
        }
        NeoLangTokenValue.BRACKET_END -> {
          moveToNextChar()
          NeoLangToken(NeoLangTokenType.BRACKET_END, currentToken)
        }
        NeoLangTokenValue.ARRAY_START -> {
          moveToNextChar()
          NeoLangToken(NeoLangTokenType.ARRAY_START, currentToken)
        }
        NeoLangTokenValue.ARRAY_END -> {
          moveToNextChar()
          NeoLangToken(NeoLangTokenType.ARRAY_END, currentToken)
        }
        NeoLangTokenValue.COMMA -> {
          moveToNextChar(eofThrow = true)
          NeoLangToken(NeoLangTokenType.COMMA, currentToken)
        }
        NeoLangTokenValue.QUOTE -> {
          NeoLangToken(NeoLangTokenType.STRING, NeoLangTokenValue.wrap(getNextTokenAsString()))
        }
        else -> {
          if (currentChar.isNumber()) {
            NeoLangToken(NeoLangTokenType.NUMBER, NeoLangTokenValue.wrap(getNextTokenAsNumber()))
          } else if (isIdentifier(currentChar, true)) {
            NeoLangToken(NeoLangTokenType.ID, NeoLangTokenValue.wrap(getNextTokenAsId()))
          } else {
            throw InvalidTokenException("Unexpected character near line $lineNumber: $currentChar")
          }
        }
      }

      token.lineNumber = lineNumber
      return token
    }

  private fun getNextTokenAsString(): String {
    // Skip start quote
    // and a single quote is now allowed
    moveToNextChar(eofThrow = true)
    val builder = StringBuilder()

    var loop = true
    while (loop && currentChar != NeoLangTokenValue.QUOTE.value.asString()[0]) {
      // NeoLang does not support escaped char
//            if (currentChar == '\\') {
//                builder.append('\\')
//                moveToNextChar(eofThrow = true)
//            }
      builder.append(currentChar)
      loop = moveToNextChar()
    }

    // Skip end quote
    moveToNextChar()
    return builder.toString()
  }

  private fun getNextTokenAsNumber(): String {
    var numberValue: Double = (currentChar.toInt() - '0'.toInt()).toDouble()

    // Four types of numbers are supported:
    // Dec(123) Hex(0x123) Oct(017) Bin(0b11)

    // Dec
    if (numberValue > 0) {
      numberValue = getNextDecimalNumber(numberValue)
    } else {
      // is 0
      if (!moveToNextChar()) {
        return numberValue.toString()
      }

      // Hex
      if (currentChar == 'x' || currentChar == 'X') {
        numberValue = getNextHexNumber(numberValue)
      } else if (currentChar == 'b' || currentChar == 'B') {
        numberValue = getNextBinaryNumber(numberValue)
      } else {
        numberValue = getNextOctalNumber(numberValue)
      }
    }

    return numberValue.toString()
  }

  private fun getNextOctalNumber(numberValue: Double): Double {
    var value: Double = numberValue
    var loop = true
    while (loop && currentChar in ('0'..'7')) {
      value = value * 8 + currentChar.toNumber()
      loop = moveToNextChar()
    }
    return value
  }

  private fun getNextBinaryNumber(numberValue: Double): Double {
    var value = numberValue
    var loop = moveToNextChar() // skip 'b' or 'B'
    while (loop && currentChar in ('0'..'1')) {
      value += value * 2 + currentChar.toNumber()
      loop = moveToNextChar()
    }
    return value
  }

  private fun getNextHexNumber(numberValue: Double): Double {
    var value = numberValue
    var loop = moveToNextChar() // skip 'x' or 'X'
    while (loop && (currentChar.isHexNumber())) {
      value *= 16 + (currentChar.toInt().and(15)) + if (currentChar >= 'A') 9 else 0
      loop = moveToNextChar()
    }
    return value
  }

  private fun getNextDecimalNumber(numberValue: Double): Double {
    var floatPointMeet = false
    var floatPart: Double = 0.0
    var floatNumberCounter = 1
    var value = numberValue

    var loop = moveToNextChar()
    while (loop) {
      if (currentChar.isNumber()) {
        if (floatPointMeet) {
          floatPart = floatPart * 10 + currentChar.toNumber()
          floatNumberCounter *= 10
        } else {
          value = value * 10 + currentChar.toNumber()
        }
        loop = moveToNextChar()

      } else if (currentChar == '.') {
        floatPointMeet = true
        loop = moveToNextChar()
      } else {
        break
      }
    }
    return value + floatPart / floatNumberCounter
  }

  private fun getNextTokenAsId(): String {
    return buildString {
      while (isIdentifier(currentChar, false)) {
        append(currentChar)
        if (!moveToNextChar()) {
          break
        }
      }
    }
  }

  private fun isIdentifier(tokenChar: Char, isFirstChar: Boolean): Boolean {
    val isId = (tokenChar in 'a'..'z')
      || (tokenChar in 'A'..'Z')
      || ("_-#$".contains(tokenChar))
    return if (isFirstChar) isId else (isId || (tokenChar in '0'..'9'))
  }

  private fun Char.toNumber(): Int {
    return if (isNumber()) {
      this.toInt() - '0'.toInt()
    } else 0
  }

  private fun Char.isNumber(): Boolean {
    return this in ('0'..'9')
  }

  private fun Char.isHexNumber(): Boolean {
    return this.isNumber()
      || this in ('a'..'f')
      || this in ('A'..'F')
  }
}

/**
 * @author kiva
 */
class NeoLangParser {
  private val lexer = NeoLangLexer()
  private var tokens = mutableListOf<NeoLangToken>()
  private var currentPosition: Int = 0
  private var currentToken: NeoLangToken? = null

  fun setInputSource(programCode: String?) {
    lexer.setInputSource(programCode)
  }

  fun parse(): NeoLangAst {
    return updateParserStatus(lexer.lex()) ?: throw ParseException("AST is null")
  }

  private fun updateParserStatus(tokens: List<NeoLangToken>): NeoLangAst? {
    if (tokens.isEmpty()) {
      // Allow empty program
      return NeoLangProgramNode.emptyNode()
    }

    this.tokens.clear()
    this.tokens.addAll(tokens)
    currentPosition = 0
    currentToken = tokens[currentPosition]
    return program()
  }

  private fun match(tokenType: NeoLangTokenType, errorThrow: Boolean = false): Boolean {
    val currentToken = this.currentToken ?: throw InvalidTokenException("Unexpected token: null")

    if (currentToken.tokenType === tokenType) {
      currentPosition++
      if (currentPosition >= tokens.size) {
        this.currentToken = NeoLangToken(NeoLangTokenType.EOF, NeoLangTokenValue.EOF)
      } else {
        this.currentToken = tokens[currentPosition]
      }
      return true

    } else if (errorThrow) {
      throw InvalidTokenException(
        "Unexpected token `${currentToken.tokenValue}' typed " +
          "`${currentToken.tokenType}' near line ${currentToken.lineNumber}, " +
          "expected $tokenType",
      )
    }

    return false
  }

  private fun program(): NeoLangProgramNode {
    val token = currentToken

    var group = group()
    if (group != null) {
      val groups = mutableListOf(group)
      while (token?.tokenType !== NeoLangTokenType.EOF) {
        group = group()
        if (group == null) {
          break
        }
        groups.add(group)
      }
      return NeoLangProgramNode(groups)
    }

    return NeoLangProgramNode.emptyNode()
  }

  /**
   * @param attrName Only available when group is a attribute value
   */
  private fun group(): NeoLangGroupNode? {
    val token = currentToken ?: throw InvalidTokenException("Unexpected token: null")

    var attr = attribute()
    if (attr != null) {
      val attributes = mutableListOf(attr)

      while (token.tokenType !== NeoLangTokenType.EOF
        && token.tokenType !== NeoLangTokenType.BRACKET_END
        && token.tokenType !== NeoLangTokenType.ARRAY_END
      ) {
        attr = attribute()
        if (attr == null) {
          break
        }
        attributes.add(attr)
      }
      return NeoLangGroupNode(attributes.toTypedArray())
    }

    return null
  }

  private fun attribute(): NeoLangAttributeNode? {
    val token = currentToken ?: throw InvalidTokenException("Unexpected token: null")
    if (match(NeoLangTokenType.ID)) {
      match(NeoLangTokenType.COLON, errorThrow = true)

      val attrName = NeoLangStringNode(token)

      val block = block(attrName) ?: NeoLangBlockNode.emptyNode()
      return NeoLangAttributeNode(attrName, block)
    }
    return null
  }

  private fun array(arrayName: NeoLangStringNode): NeoLangArrayNode? {
    val token = currentToken ?: throw InvalidTokenException("Unexpected token: null")

    // TODO: Multiple Array
    var block = blockNonArrayElement(arrayName)
    var index = 0

    if (block != null) {
      val elements = mutableListOf(NeoLangArrayNode.Companion.ArrayElement(index++, block))

      if (match(NeoLangTokenType.COMMA)) {
        // More than one elements
        while (token.tokenType !== NeoLangTokenType.EOF
          && token.tokenType !== NeoLangTokenType.ARRAY_END
        ) {
          block = blockNonArrayElement(arrayName)
          if (block == null) {
            break
          }
          elements.add(NeoLangArrayNode.Companion.ArrayElement(index++, block))

          // Meet the last element
          if (!match(NeoLangTokenType.COMMA)) {
            break
          }
        }
      }

      return NeoLangArrayNode(arrayName, elements.toTypedArray())
    }

    return null
  }


  /**
   * @param attrName The block holder's name
   */
  private fun block(attrName: NeoLangStringNode): NeoLangBlockNode? {
    val block = blockNonArrayElement(attrName)
    if (block != null) {
      return block
    }

    val token = currentToken ?: throw InvalidTokenException("Unexpected token: null")
    when (token.tokenType) {
      NeoLangTokenType.ARRAY_START -> {
        match(NeoLangTokenType.ARRAY_START, errorThrow = true)
        val array = array(attrName)
        match(NeoLangTokenType.ARRAY_END, errorThrow = true)

        // Allow empty arrays
        return if (array != null) NeoLangBlockNode(array) else NeoLangBlockNode.emptyNode()
      }

      else -> throw InvalidTokenException("Unexpected token `${token.tokenValue}' typed `${token.tokenType}' for block")
    }
  }

  /**
   * @param attrName Only available when group is a attribute value
   */
  private fun blockNonArrayElement(attrName: NeoLangStringNode?): NeoLangBlockNode? {
    val token = currentToken ?: throw InvalidTokenException("Unexpected token: null")

    return when (token.tokenType) {
      NeoLangTokenType.NUMBER -> {
        match(NeoLangTokenType.NUMBER, errorThrow = true)
        return NeoLangBlockNode(NeoLangNumberNode(token))
      }
      NeoLangTokenType.ID -> {
        match(NeoLangTokenType.ID, errorThrow = true)
        return NeoLangBlockNode(NeoLangStringNode(token))
      }
      NeoLangTokenType.STRING -> {
        match(NeoLangTokenType.STRING, errorThrow = true)
        return NeoLangBlockNode(NeoLangStringNode(token))
      }
      NeoLangTokenType.BRACKET_START -> {
        match(NeoLangTokenType.BRACKET_START, errorThrow = true)
        val group = group()
        match(NeoLangTokenType.BRACKET_END, errorThrow = true)

        // Allow empty blocks
        return if (group != null) NeoLangBlockNode(group) else NeoLangBlockNode.emptyNode()
      }
      else -> null
    }
  }
}

open class InvalidTokenException(message: String) : ParseException(message)
open class ParseException(message: String) : RuntimeException(message)

```

`NeoLang/src/main/java/io/neolang/frontend/nodes.kt`:

```kt
package io.neolang.frontend

import io.neolang.runtime.NeoLangValue

/**
 * @author kiva
 */
open class NeoLangAst {
  fun visit(): VisitorFactory {
    return VisitorFactory(this)
  }
}

open class NeoLangBaseNode : NeoLangAst()

/**
 * @author kiva
 */
class NeoLangArrayNode(val arrayNameNode: NeoLangStringNode, val elements: Array<ArrayElement>) : NeoLangBaseNode() {
  companion object {
    class ArrayElement(val index: Int, val block: NeoLangBlockNode)
  }
}

/**
 * @author kiva
 */
open class NeoLangAstBasedNode(val ast: NeoLangBaseNode) : NeoLangBaseNode() {
  override fun toString(): String {
    return "${javaClass.simpleName} { ast: $ast }"
  }
}

/**
 * @author kiva
 */
class NeoLangAttributeNode(val stringNode: NeoLangStringNode, val blockNode: NeoLangBlockNode) : NeoLangBaseNode() {

  override fun toString(): String {
    return "NeoLangAttributeNode { stringNode: $stringNode, block: $blockNode }"
  }
}

/**
 * @author kiva
 */
class NeoLangBlockNode(blockElement: NeoLangBaseNode) : NeoLangAstBasedNode(blockElement) {
  companion object {
    fun emptyNode(): NeoLangBlockNode {
      return NeoLangBlockNode(NeoLangDummyNode())
    }
  }
}

/**
 * @author kiva
 */
class NeoLangDummyNode : NeoLangBaseNode()

/**
 * @author kiva
 */
class NeoLangGroupNode(val attributes: Array<NeoLangAttributeNode>) : NeoLangBaseNode() {

  override fun toString(): String {
    return "NeoLangGroupNode { attrs: $attributes }"
  }

  companion object {
    fun emptyNode(): NeoLangGroupNode {
      return NeoLangGroupNode(arrayOf())
    }
  }
}

/**
 * @author kiva
 */
class NeoLangNumberNode(token: NeoLangToken) : NeoLangTokenBasedNode(token)

/**
 * @author kiva
 */

class NeoLangProgramNode(val groups: List<NeoLangGroupNode>) : NeoLangBaseNode() {

  override fun toString(): String {
    return "NeoLangProgramNode { groups: $groups }"
  }

  companion object {
    fun emptyNode(): NeoLangProgramNode {
      return NeoLangProgramNode(listOf())
    }
  }
}

/**
 * @author kiva
 */
class NeoLangStringNode(token: NeoLangToken) : NeoLangTokenBasedNode(token)

/**
 * @author kiva
 */
open class NeoLangTokenBasedNode(val token: NeoLangToken) : NeoLangBaseNode() {
  override fun toString(): String {
    return "${javaClass.simpleName} { token: $token }"
  }

  fun eval(): NeoLangValue {
    return token.tokenValue.value
  }
}

```

`NeoLang/src/main/java/io/neolang/frontend/tokens.kt`:

```kt
package io.neolang.frontend

import io.neolang.runtime.NeoLangValue

/**
 * @author kiva
 */
class NeoLangEOFToken : NeoLangToken(NeoLangTokenType.EOF, NeoLangTokenValue.EOF)

/**
 * @author kiva
 */

open class NeoLangToken(val tokenType: NeoLangTokenType, val tokenValue: NeoLangTokenValue) {
  var lineNumber = 0

  override fun toString(): String {
    return "Token { tokenType: $tokenType, tokenValue: $tokenValue };"
  }
}

/**
 * @author kiva
 */

enum class NeoLangTokenType {
  NUMBER,
  ID,
  STRING,
  BRACKET_START,
  BRACKET_END,
  ARRAY_START,
  ARRAY_END,
  COLON,
  COMMA,
  EOL,
  EOF,
}

/**
 * @author kiva
 */
class NeoLangTokenValue(val value: NeoLangValue) {

  override fun toString(): String {
    return value.asString()
  }

  companion object {
    val COLON = NeoLangTokenValue(NeoLangValue(":"))
    val COMMA = NeoLangTokenValue(NeoLangValue(","))
    val QUOTE = NeoLangTokenValue(NeoLangValue("\""))
    val EOF = NeoLangTokenValue(NeoLangValue("<EOF>"))

    val BRACKET_START = NeoLangTokenValue(NeoLangValue("{"))
    val BRACKET_END = NeoLangTokenValue(NeoLangValue("}"))
    val ARRAY_START = NeoLangTokenValue(NeoLangValue("["))
    val ARRAY_END = NeoLangTokenValue(NeoLangValue("]"))

    fun wrap(tokenText: String): NeoLangTokenValue {
      return when (tokenText) {
        COLON.value.asString() -> COLON
        COMMA.value.asString() -> COMMA
        QUOTE.value.asString() -> QUOTE
        BRACKET_START.value.asString() -> BRACKET_START
        BRACKET_END.value.asString() -> BRACKET_END
        ARRAY_START.value.asString() -> ARRAY_START
        ARRAY_END.value.asString() -> ARRAY_END
        else -> NeoLangTokenValue(NeoLangValue(tokenText))
      }
    }
  }
}

```

`NeoLang/src/main/java/io/neolang/frontend/visitors.kt`:

```kt
package io.neolang.frontend

import io.neolang.runtime.NeoLangArray
import io.neolang.runtime.NeoLangContext
import io.neolang.runtime.NeoLangValue
import java.util.*

class ConfigVisitor : IVisitorCallback {
  private var rootContext: NeoLangContext? = null
  private var currentContext: NeoLangContext? = null

  fun getRootContext(): NeoLangContext {
    return rootContext!!
  }

  fun getContext(contextPath: Array<String>): NeoLangContext {
    var context = getCurrentContext()
    contextPath.forEach {
      context = context.getChild(it)
    }
    return context
  }

  fun getAttribute(contextPath: Array<String>, attrName: String): NeoLangValue {
    return getContext(contextPath).getAttribute(attrName)
  }

  fun getArray(contextPath: Array<String>, arrayName: String): NeoLangArray {
    // We use NeoLangContext as arrays and array elements now
    return NeoLangArray.createFromContext(getContext(contextPath).getChild(arrayName))
  }

  fun getStringValue(path: Array<String>, name: String): String? {
    val value = this.getAttribute(path, name)
    return if (value.isValid()) value.asString() else null
  }

  fun getBooleanValue(path: Array<String>, name: String): Boolean? {
    val value = this.getAttribute(path, name)
    return if (value.isValid()) value.asString() == "true" else null
  }

  override fun onStart() {
    currentContext = NeoLangContext("global")
    rootContext = currentContext
  }

  override fun onFinish() {
    var context = currentContext
    while (context != null && context.parent != null) {
      context = context.parent
    }
    this.currentContext = context
  }

  override fun onEnterContext(contextName: String) {
    val newContext = NeoLangContext(contextName)
    newContext.parent = currentContext
    currentContext!!.children.add(newContext)
    currentContext = newContext
  }

  override fun onExitContext() {
    val context = currentContext
    if (context?.parent != null) {
      this.currentContext = context.parent
    }
  }

  override fun getCurrentContext(): NeoLangContext {
    return currentContext!!
  }
}

/**
 * @author kiva
 */
class DisplayProcessVisitor : IVisitorCallbackAdapter() {
  private val contextStack = Stack<NeoLangContext>()

  override fun onStart() {
    println(">>> Start")
    onEnterContext("global")
  }

  override fun onFinish() {
    while (contextStack.isNotEmpty()) {
      onExitContext()
    }
    println(">>> Finish")
  }

  override fun onEnterContext(contextName: String) {
    val context = NeoLangContext(contextName)
    contextStack.push(context)
    println(">>> Entering Context `$contextName'")
  }

  override fun onExitContext() {
    val context = contextStack.pop()
    println(">>> Exiting & Dumping Context ${context.contextName}")
    context.getAttributes().entries.forEach {
      println("     > [${it.key}]: ${it.value.asString()}")
    }
  }

  override fun getCurrentContext(): NeoLangContext {
    return contextStack.peek()
  }
}

```

`NeoLang/src/main/java/io/neolang/runtime/context.kt`:

```kt
package io.neolang.runtime

/**
 * @author kiva
 */
class NeoLangContext(val contextName: String) {
  companion object {
    private val emptyContext = NeoLangContext("<Context-Empty>")
  }

  private val attributes = mutableMapOf<String, NeoLangValue>()
  val children = mutableListOf<NeoLangContext>()
  var parent: NeoLangContext? = null

  fun defineAttribute(attributeName: String, attributeValue: NeoLangValue): NeoLangContext {
    attributes[attributeName] = attributeValue
    return this
  }

  fun getAttribute(attributeName: String): NeoLangValue {
    return attributes[attributeName] ?: parent?.getAttribute(attributeName) ?: NeoLangValue.UNDEFINED
  }

  fun getChild(contextName: String): NeoLangContext {
    var found: NeoLangContext? = null
    children.forEach {
      if (it.contextName == contextName) {
        found = it
      }
    }
    return found ?: emptyContext
  }

  fun getAttributes(): Map<String, NeoLangValue> {
    return attributes
  }
}

```

`NeoLang/src/main/java/io/neolang/runtime/types.kt`:

```kt
package io.neolang.runtime

/**
 * @author kiva
 */
class NeoLangArray private constructor(
  val elements: List<NeoLangArrayElement>,
  override val size: Int = elements.size
) : Collection<NeoLangArrayElement> {
  companion object {
    internal class PrimaryElement(val primaryValue: NeoLangValue) : NeoLangArrayElement() {
      override fun eval(): NeoLangValue {
        return primaryValue
      }
    }

    internal class BlockElement(val blockContext: NeoLangContext) : NeoLangArrayElement() {
      override fun eval(key: String): NeoLangValue {
        return blockContext.getAttribute(key)
      }

      override fun isBlock(): Boolean {
        return true
      }
    }

    fun createFromContext(context: NeoLangContext): NeoLangArray {
      val elements = mutableListOf<NeoLangArrayElement>()
      context.getAttributes().entries.forEach {
        val index = it.key.toInt()
        elements.add(index, PrimaryElement(it.value))
      }
      context.children.forEach {
        val index = it.contextName.toInt()
        elements.add(index, BlockElement(it))
      }
      return NeoLangArray(elements)
    }
  }

  operator fun get(index: Int): NeoLangArrayElement {
    return elements[index]
  }

  override fun contains(element: NeoLangArrayElement): Boolean {
    return elements.contains(element)
  }

  override fun containsAll(elements: Collection<NeoLangArrayElement>): Boolean {
    return this.elements.containsAll(elements)
  }

  override fun isEmpty(): Boolean {
    return size == 0
  }

  override fun iterator(): Iterator<NeoLangArrayElement> {
    return elements.iterator()
  }
}

/**
 * @author kiva
 */
open class NeoLangArrayElement {
  open fun eval(): NeoLangValue {
    return NeoLangValue.UNDEFINED
  }

  open fun eval(key: String): NeoLangValue {
    return NeoLangValue.UNDEFINED
  }

  open fun isBlock(): Boolean {
    return false
  }
}

/**
 * @author kiva
 */
class NeoLangValue(private val rawValue: Any) {
  fun asString(): String {
    return rawValue.toString()
  }

  fun asNumber(): Double {
    if (rawValue is Array<*>) {
      return 0.0
    }

    try {
      return rawValue.toString().toDouble()
    } catch (e: Throwable) {
      return 0.0
    }
  }

  fun isValid(): Boolean {
    return this != UNDEFINED
  }

  companion object {
    val UNDEFINED = NeoLangValue("<undefined>")
  }
}

```

`NeoTermBridge/build.gradle`:

```gradle
apply plugin: 'com.android.library'

def libraryVersionCode = 1
def libraryVersionName = "1.0"

android {
  compileSdkVersion rootProject.ext.android.COMPILE_SDK_VERSION

  defaultConfig {
    minSdkVersion rootProject.ext.android.MIN_SDK_VERSION
    targetSdkVersion rootProject.ext.android.TARGET_SDK_VERSION
    versionCode libraryVersionCode
    versionName libraryVersionName
    testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
  }

  buildTypes {
    release {
      minifyEnabled false
    }
  }
}

dependencies {
  implementation fileTree(dir: 'libs', include: ['*.jar'])
  implementation 'androidx.appcompat:appcompat:1.2.0'
  androidTestImplementation('androidx.test.espresso:espresso-core:3.1.0', {
    exclude group: 'com.android.support', module: 'support-annotations'
  })
  testImplementation rootProject.ext.deps["junit"]
}

```

`NeoTermBridge/src/main/AndroidManifest.xml`:

```xml
<manifest
  package="io.neoterm.bridge"/>

```

`NeoTermBridge/src/main/aidl/io/neoterm/bridge/ISessionConnection.aidl`:

```aidl
// ISessionConnection.aidl
package io.neoterm.bridge;

// Declare any non-default types here with import statements

interface ISessionConnection {
}

```

`NeoTermBridge/src/main/java/io/neoterm/bridge/Bridge.java`:

```java
package io.neoterm.bridge;

import android.content.ComponentName;
import android.content.Intent;

import java.util.Objects;

/**
 * @author kiva
 */
public class Bridge {
  public static final String ACTION_EXECUTE = "neoterm.action.remote.execute";
  public static final String ACTION_SILENT_RUN = "neoterm.action.remote.silent-run";
  public static final String EXTRA_COMMAND = "neoterm.extra.remote.execute.command";
  public static final String EXTRA_SESSION_ID = "neoterm.extra.remote.execute.session";
  public static final String EXTRA_FOREGROUND = "neoterm.extra.remote.execute.foreground";
  private static final String NEOTERM_PACKAGE = "io.neoterm";
  private static final String NEOTERM_REMOTE_INTERFACE = "io.neoterm.ui.term.NeoTermRemoteInterface";
  private static final ComponentName NEOTERM_COMPONENT = new ComponentName(NEOTERM_PACKAGE, NEOTERM_REMOTE_INTERFACE);

  private Bridge() throws IllegalAccessException {
    throw new IllegalAccessException();
  }

  public static Intent createExecuteIntent(SessionId sessionId,
                                           String command,
                                           boolean foreground) {
    Objects.requireNonNull(command, "command");
    Objects.requireNonNull(sessionId, "session id");

    Intent intent = new Intent(ACTION_EXECUTE);
    intent.setComponent(NEOTERM_COMPONENT);
    intent.putExtra(EXTRA_COMMAND, command);
    intent.putExtra(EXTRA_SESSION_ID, sessionId.getSessionId());
    intent.putExtra(EXTRA_FOREGROUND, foreground);
    return intent;
  }

  public static Intent createExecuteIntent(SessionId sessionId, String command) {
    return createExecuteIntent(sessionId, command, true);
  }

  public static Intent createExecuteIntent(String command) {
    return createExecuteIntent(SessionId.NEW_SESSION, command);
  }

  public static Intent createExecuteIntent(String command, boolean foreground) {
    return createExecuteIntent(SessionId.NEW_SESSION, command, foreground);
  }

  public static SessionId parseResult(Intent data) {
    Objects.requireNonNull(data, "data");

    if (data.hasExtra(EXTRA_SESSION_ID)) {
      String handle = data.getStringExtra(EXTRA_SESSION_ID);
      return SessionId.of(handle);
    }
    return null;
  }
}

```

`NeoTermBridge/src/main/java/io/neoterm/bridge/SessionId.java`:

```java
package io.neoterm.bridge;

import java.util.Objects;

/**
 * @author kiva
 */
public class SessionId {
  /**
   * Created a new session.
   */
  public static final SessionId NEW_SESSION = SessionId.of("new");

  /**
   * Presents current session in NeoTerm.
   */
  public static final SessionId CURRENT_SESSION = SessionId.of("current");

  private final String sessionId;

  SessionId(String sessionId) {
    this.sessionId = sessionId;
  }

  public String getSessionId() {
    return sessionId;
  }

  @Override
  public String toString() {
    return "TerminalSession { id = " + sessionId + " }";
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    SessionId sessionId1 = (SessionId) o;
    return Objects.equals(sessionId, sessionId1.sessionId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(sessionId);
  }

  public static SessionId of(String sessionId) {
    return new SessionId(sessionId);
  }
}

```

`NeoTermBridge/src/main/res/values/strings.xml`:

```xml
<resources>
  <string name="app_name">NeoTermBridge</string>
</resources>

```

`NeoTermBridge/src/test/java/io/neoterm/bridge/ExampleUnitTest.java`:

```java
package io.neoterm.bridge;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
  @Test
  public void addition_isCorrect() {
    assertEquals(4, 2 + 2);
  }
}
```

`README.md`:

```md
NeoTerm
=======
[![Travis build status](https://travis-ci.org/NeoTerm/NeoTerm.svg?branch=master)](https://travis-ci.org/NeoTerm/NeoTerm)
![](https://img.shields.io/badge/language-Kotlin-green.svg)
![](https://img.shields.io/badge/license-GPLv3-000000.svg)

A modern-designed android terminal emulator for the 21st century.

### Our Pledge

Originally, NeoTerm was designed as the front end of Termux to provide some functions that Termux didn't have, but we
found it very convenient. In continuous development, we discovered our goal: to be the best terminal for Android.

### Help & Documentation

View on [GitBook](https://neoterm.gitbooks.io/neoterm-wiki/content)

View on [GitHub](https://github.com/NeoTerm/NeoTerm-Wiki)

### Download

[GitHub Release Page](https://github.com/NeoTerm/NeoTerm/releases)

[lzzySoft's F-Droid repo](https://apt.izzysoft.de/fdroid/index/apk/io.neoterm) (thanks to @lzzySoft)

```

`Xorg/build.gradle`:

```gradle
apply plugin: 'com.android.library'

android {
  compileSdkVersion rootProject.ext.android.COMPILE_SDK_VERSION

  defaultConfig {
    minSdkVersion rootProject.ext.android.MIN_SDK_VERSION
    targetSdkVersion rootProject.ext.android.TARGET_SDK_VERSION
    versionCode 1
    versionName "1.0"
    testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
  }

  buildTypes {
    release {
      minifyEnabled false
    }
  }

  sourceSets {
    main {
      jniLibs.srcDirs = ['src/main/jniLibs']
    }
  }
}

dependencies {
  implementation fileTree(dir: 'libs', include: ['*.jar'])

  implementation rootProject.ext.deps["appcompat-v7"]
  testImplementation rootProject.ext.deps["junit"]

  androidTestImplementation('androidx.test.espresso:espresso-core:3.1.0', {
    exclude group: 'com.android.support', module: 'support-annotations'
  })
}

```

`Xorg/src/main/AndroidManifest.xml`:

```xml
<manifest
  package="io.neoterm.xorg"/>

```

`Xorg/src/main/java/io/neoterm/Accelerometer.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.Context;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.util.Log;
import androidx.appcompat.app.AppCompatActivity;

import java.util.Arrays;


@SuppressWarnings("JniMissingFunction")
class AccelerometerReader implements SensorEventListener {

  private SensorManager _manager = null;
  public boolean openedBySDL = false;
  public static final GyroscopeListener gyro = new GyroscopeListener();
  public static final OrientationListener orientation = new OrientationListener();

  public AccelerometerReader(Context context) {
    _manager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
  }

  public synchronized void stop() {
    if (_manager != null) {
      Log.i("SDL", "libSDL: stopping accelerometer/gyroscope/orientation");
      _manager.unregisterListener(this);
      _manager.unregisterListener(gyro);
      _manager.unregisterListener(orientation);
    }
  }

  public synchronized void start() {
    if ((Globals.UseAccelerometerAsArrowKeys || Globals.AppUsesAccelerometer) &&
      _manager != null && _manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER) != null) {
      Log.i("SDL", "libSDL: starting accelerometer");
      _manager.registerListener(this, _manager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_GAME);
    }
    if ((Globals.AppUsesGyroscope || Globals.MoveMouseWithGyroscope) &&
      _manager != null && _manager.getDefaultSensor(Sensor.TYPE_GYROSCOPE) != null) {
      Log.i("SDL", "libSDL: starting gyroscope");
      _manager.registerListener(gyro, _manager.getDefaultSensor(Sensor.TYPE_GYROSCOPE), SensorManager.SENSOR_DELAY_GAME);
    }
    if ((Globals.AppUsesOrientationSensor) && _manager != null &&
      _manager.getDefaultSensor(Sensor.TYPE_GAME_ROTATION_VECTOR) != null) {
      Log.i("SDL", "libSDL: starting orientation sensor");
      _manager.registerListener(orientation, _manager.getDefaultSensor(
        Sensor.TYPE_GAME_ROTATION_VECTOR),
        SensorManager.SENSOR_DELAY_GAME);
    }
  }

  public void onSensorChanged(SensorEvent event) {
    if (Globals.HorizontalOrientation) {
      if (gyro.invertedOrientation)
        nativeAccelerometer(-event.values[1], event.values[0], event.values[2]);
      else
        nativeAccelerometer(event.values[1], -event.values[0], event.values[2]);
    } else
      nativeAccelerometer(event.values[0], event.values[1], event.values[2]); // TODO: not tested!
  }

  public void onAccuracyChanged(Sensor s, int a) {
  }

  static class GyroscopeListener implements SensorEventListener {
    public boolean invertedOrientation = false;

    // Noise filter with sane initial values, so user will be able
    // to move gyroscope during the first 10 seconds, while the noise is measured.
    // After that the values are replaced by noiseMin/noiseMax.
    final float filterMin[] = new float[]{-0.05f, -0.05f, -0.05f};
    final float filterMax[] = new float[]{0.05f, 0.05f, 0.05f};

    // The noise levels we're measuring.
    // Large initial values, they will decrease, but never increase.
    float noiseMin[] = new float[]{-1.0f, -1.0f, -1.0f};
    float noiseMax[] = new float[]{1.0f, 1.0f, 1.0f};

    // The gyro data buffer, from which we care calculating min/max noise values.
    // The bigger it is, the more precise the calclations, and the longer it takes to converge.
    float noiseData[][] = new float[200][noiseMin.length];
    int noiseDataIdx = 0;

    // When we detect movement, we remove last few values of the measured data.
    // The movement is detected by comparing values to noiseMin/noiseMax of the previous iteration.
    int movementBackoff = 0;

    // Difference between min/max in the previous measurement iteration,
    // used to determine when we should stop measuring, when the change becomes negligilbe.
    float measuredNoiseRange[] = null;

    // How long the algorithm is running, to stop it if it does not converge.
    int measurementIteration = 0;

    public GyroscopeListener() {
    }

    void collectNoiseData(final float[] data) {
      for (int i = 0; i < noiseMin.length; i++) {
        if (data[i] < noiseMin[i] || data[i] > noiseMax[i]) {
          // Movement detected, this can converge our min/max too early, so we're discarding last few values
          if (movementBackoff < 0) {
            int discard = 10;
            if (-movementBackoff < discard)
              discard = -movementBackoff;
            noiseDataIdx -= discard;
            if (noiseDataIdx < 0)
              noiseDataIdx = 0;
          }
          movementBackoff = 10;
          return;
        }
        noiseData[noiseDataIdx][i] = data[i];
      }
      movementBackoff--;
      if (movementBackoff >= 0)
        return; // Also discard several values after the movement stopped
      noiseDataIdx++;

      if (noiseDataIdx < noiseData.length)
        return;

      measurementIteration++;
      Log.d("SDL", "GYRO_NOISE: Measuring in progress... " + measurementIteration);
      if (measurementIteration > 5) {
        // We've collected enough data to use our noise min/max values as a new filter
        System.arraycopy(noiseMin, 0, filterMin, 0, filterMin.length);
        System.arraycopy(noiseMax, 0, filterMax, 0, filterMax.length);
      }
      if (measurementIteration > 15) {
        Log.d("SDL", "GYRO_NOISE: Measuring done! Maximum number of iterations reached: " + measurementIteration);
        noiseData = null;
        measuredNoiseRange = null;
        return;
      }

      noiseDataIdx = 0;
      boolean changed = false;
      for (int i = 0; i < noiseMin.length; i++) {
        float min = 1.0f;
        float max = -1.0f;
        for (int ii = 0; ii < noiseData.length; ii++) {
          if (min > noiseData[ii][i])
            min = noiseData[ii][i];
          if (max < noiseData[ii][i])
            max = noiseData[ii][i];
        }
        // Increase the range a bit, for safe conservative filtering
        float middle = (min + max) / 2.0f;
        min += (min - middle) * 0.2f;
        max += (max - middle) * 0.2f;
        // Check if range between min/max is less then the current range, as a safety measure,
        // and min/max range is not jumping outside of previously measured range
        if (max - min < noiseMax[i] - noiseMin[i] && min >= noiseMin[i] && max <= noiseMax[i]) {
          // Move old min/max closer to the measured min/max, but do not replace the values altogether
          noiseMin[i] = (noiseMin[i] + min * 4.0f) / 5.0f;
          noiseMax[i] = (noiseMax[i] + max * 4.0f) / 5.0f;
          changed = true;
        }
      }

      Log.d("SDL", "GYRO_NOISE: MIN MAX: " + Arrays.toString(noiseMin) + " " + Arrays.toString(noiseMax));

      if (!changed)
        return;

      // Determine when to stop measuring - check that the previous min/max range is close enough to the current one

      float range[] = new float[noiseMin.length];
      for (int i = 0; i < noiseMin.length; i++)
        range[i] = noiseMax[i] - noiseMin[i];

      Log.d("SDL", "GYRO_NOISE: RANGE:   " + Arrays.toString(range) + " " + Arrays.toString(measuredNoiseRange));

      if (measuredNoiseRange == null) {
        measuredNoiseRange = range;
        return; // First iteration, skip further checks
      }

      for (int i = 0; i < range.length; i++) {
        if (measuredNoiseRange[i] / range[i] > 1.2f) {
          measuredNoiseRange = range;
          return;
        }
      }

      // We converged to the final min/max filter values, stop measuring
      System.arraycopy(noiseMin, 0, filterMin, 0, filterMin.length);
      System.arraycopy(noiseMax, 0, filterMax, 0, filterMax.length);
      noiseData = null;
      measuredNoiseRange = null;
      Log.d("SDL", "GYRO_NOISE: Measuring done! Range converged on iteration " + measurementIteration);
    }

    public void onSensorChanged(final SensorEvent event) {
      boolean filtered = true;
      final float[] data = event.values;

      if (noiseData != null)
        collectNoiseData(data);

      for (int i = 0; i < 3; i++) {
        if (data[i] < filterMin[i]) {
          filtered = false;
          data[i] -= filterMin[i];
        } else if (data[i] > filterMax[i]) {
          filtered = false;
          data[i] -= filterMax[i];
        }
      }

      if (filtered)
        return;

      if (Globals.HorizontalOrientation) {
        if (invertedOrientation)
          nativeGyroscope(-data[0], -data[1], data[2]);
        else
          nativeGyroscope(data[0], data[1], data[2]);
      } else {
        if (invertedOrientation)
          nativeGyroscope(-data[1], data[0], data[2]);
        else
          nativeGyroscope(data[1], -data[0], data[2]);
      }
    }

    public void onAccuracyChanged(Sensor s, int a) {
    }

    public boolean available(AppCompatActivity context) {
      SensorManager manager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
      return (manager != null && manager.getDefaultSensor(Sensor.TYPE_GYROSCOPE) != null);
    }

    public void registerListener(AppCompatActivity context, SensorEventListener l) {
      SensorManager manager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
      if (manager == null && manager.getDefaultSensor(Sensor.TYPE_GYROSCOPE) == null)
        return;
      manager.registerListener(gyro, manager.getDefaultSensor(
        Globals.AppUsesOrientationSensor ? Sensor.TYPE_GAME_ROTATION_VECTOR : Sensor.TYPE_GYROSCOPE),
        SensorManager.SENSOR_DELAY_GAME);
    }

    public void unregisterListener(AppCompatActivity context, SensorEventListener l) {
      SensorManager manager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
      if (manager == null)
        return;
      manager.unregisterListener(l);
    }
  }

  static class OrientationListener implements SensorEventListener {
    public OrientationListener() {
    }

    public void onSensorChanged(SensorEvent event) {
      nativeOrientation(event.values[0], event.values[1], event.values[2]);
    }

    public void onAccuracyChanged(Sensor s, int a) {
    }
  }

  private static native void nativeAccelerometer(float accX, float accY, float accZ);

  private static native void nativeGyroscope(float X, float Y, float Z);

  private static native void nativeOrientation(float X, float Y, float Z);
}

```

`Xorg/src/main/java/io/neoterm/Audio.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;


import android.media.AudioFormat;
import android.media.AudioManager;
import android.media.AudioRecord;
import android.media.AudioTrack;
import android.media.MediaRecorder.AudioSource;
import android.util.Log;
import io.neoterm.xorg.NeoXorgViewClient;

import java.util.concurrent.Semaphore;

@SuppressWarnings("JniMissingFunction")
class AudioThread {
  private NeoXorgViewClient mClient;
  private AudioTrack mAudio;
  private byte[] mAudioBuffer;
  private int mVirtualBufSize;

  public AudioThread(NeoXorgViewClient client) {
    this.mClient = client;
    mAudio = null;
    mAudioBuffer = null;
    nativeAudioInitJavaCallbacks();
  }

  public int fillBuffer() {
    if (mClient.isPaused()) {
      try {
        Thread.sleep(500);
      } catch (InterruptedException e) {
      }
    } else {
      //if( Globals.AudioBufferConfig == 0 ) // Gives too much spam to logcat, makes things worse
      //	mAudio.flush();

      mAudio.write(mAudioBuffer, 0, mVirtualBufSize);
    }

    return 1;
  }

  public int initAudio(int rate, int channels, int encoding, int bufSize) {
    if (mAudio == null) {
      channels = (channels == 1) ? AudioFormat.CHANNEL_CONFIGURATION_MONO :
        AudioFormat.CHANNEL_CONFIGURATION_STEREO;
      encoding = (encoding == 1) ? AudioFormat.ENCODING_PCM_16BIT :
        AudioFormat.ENCODING_PCM_8BIT;

      mVirtualBufSize = bufSize;

      if (AudioTrack.getMinBufferSize(rate, channels, encoding) > bufSize)
        bufSize = AudioTrack.getMinBufferSize(rate, channels, encoding);

      if (Globals.AudioBufferConfig != 0) {    // application's choice - use minimal buffer
        bufSize = (int) ((float) bufSize * (((float) (Globals.AudioBufferConfig - 1) * 2.5f) + 1.0f));
        mVirtualBufSize = bufSize;
      }
      mAudioBuffer = new byte[bufSize];

      mAudio = new AudioTrack(AudioManager.STREAM_MUSIC,
        rate,
        channels,
        encoding,
        bufSize,
        AudioTrack.MODE_STREAM);
      mAudio.play();
    }
    return mVirtualBufSize;
  }

  public byte[] getBuffer() {
    return mAudioBuffer;
  }

  public int deinitAudio() {
    if (mAudio != null) {
      mAudio.stop();
      mAudio.release();
      mAudio = null;
    }
    mAudioBuffer = null;
    return 1;
  }

  public int initAudioThread() {
    // Make audio thread priority higher so audio thread won't get underrun
    Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
    return 1;
  }

  public int pauseAudioPlayback() {
    if (mAudio != null) {
      mAudio.pause();
    }
    if (mRecordThread != null) {
      mRecordThread.pauseRecording();
    }
    return 1;
  }

  public int resumeAudioPlayback() {
    if (mAudio != null) {
      mAudio.play();
    }
    if (mRecordThread != null) {
      mRecordThread.resumeRecording();
    }
    return 1;
  }

  private native int nativeAudioInitJavaCallbacks();

  // ----- Audio recording -----

  private RecordingThread mRecordThread = null;
  private AudioRecord mRecorder = null;
  private int mRecorderBufferSize = 0;

  private byte[] startRecording(int rate, int channels, int encoding, int bufsize) {
    if (mRecordThread == null) {
      mRecordThread = new RecordingThread();
      mRecordThread.start();
    }
    if (!mRecordThread.isStopped()) {
      Log.i("SDL", "SDL: error: application already opened audio recording device");
      return null;
    }

    mRecordThread.init(bufsize);

    int channelConfig = (channels == 1) ? AudioFormat.CHANNEL_IN_MONO :
      AudioFormat.CHANNEL_IN_STEREO;
    int encodingConfig = (encoding == 1) ? AudioFormat.ENCODING_PCM_16BIT :
      AudioFormat.ENCODING_PCM_8BIT;

    int minBufDevice = AudioRecord.getMinBufferSize(rate, channelConfig, encodingConfig);
    int minBufferSize = Math.max(bufsize * 8, minBufDevice + (bufsize - (minBufDevice % bufsize)));
    Log.i("SDL", "SDL: app opened recording device, rate " + rate + " channels " + channels + " sample size " + (encoding + 1) + " bufsize " + bufsize + " internal bufsize " + minBufferSize);
    if (mRecorder == null || mRecorder.getSampleRate() != rate ||
      mRecorder.getChannelCount() != channels ||
      mRecorder.getAudioFormat() != encodingConfig ||
      mRecorderBufferSize != minBufferSize) {
      if (mRecorder != null)
        mRecorder.release();
      mRecorder = null;
      try {
        mRecorder = new AudioRecord(AudioSource.MIC, rate, channelConfig, encodingConfig, minBufferSize);
        mRecorderBufferSize = minBufferSize;
      } catch (IllegalArgumentException e) {
        Log.i("SDL", "SDL: error: failed to open MIC recording device!");
        try {
          mRecorder = new AudioRecord(AudioSource.VOICE_RECOGNITION, rate, channelConfig, encodingConfig, minBufferSize);
          mRecorderBufferSize = minBufferSize;
        } catch (IllegalArgumentException eee) {
          Log.i("SDL", "SDL: error: failed to open VOICE_RECOGNITION recording device!");
          try {
            mRecorder = new AudioRecord(AudioSource.DEFAULT, rate, channelConfig, encodingConfig, minBufferSize);
            mRecorderBufferSize = minBufferSize;
          } catch (IllegalArgumentException eeee) {
            Log.i("SDL", "SDL: error: failed to open DEFAULT recording device!");
            return null;
          }
        }
      }
    } else {
      Log.i("SDL", "SDL: reusing old recording device");
    }
    mRecordThread.startRecording();
    return mRecordThread.mRecordBuffer;
  }

  private void stopRecording() {
    if (mRecordThread == null || mRecordThread.isStopped()) {
      Log.i("SDL", "SDL: error: application already closed audio recording device");
      return;
    }
    mRecordThread.stopRecording();
    Log.i("SDL", "SDL: app closed recording device");
  }

  private class RecordingThread extends Thread {
    private boolean stopped = true;
    byte[] mRecordBuffer;
    private Semaphore waitStarted = new Semaphore(0);
    private boolean sleep = false;

    RecordingThread() {
      super();
    }

    void init(int bufsize) {
      if (mRecordBuffer == null || mRecordBuffer.length != bufsize)
        mRecordBuffer = new byte[bufsize];
    }

    public void run() {
      while (true) {
        waitStarted.acquireUninterruptibly();
        waitStarted.drainPermits();
        stopped = false;
        sleep = false;

        while (!sleep) {
          int got = mRecorder.read(mRecordBuffer, 0, mRecordBuffer.length);
          if (got != mRecordBuffer.length) {
            // Audio is stopped here, sleep a bit.
            try {
              Thread.sleep(1000);
            } catch (InterruptedException e) {
            }
          } else {
            //Log.i("SDL", "SDL: nativeAudioRecordCallback with len " + mRecordBuffer.length);
            nativeAudioRecordCallback();
            //Log.i("SDL", "SDL: nativeAudioRecordCallback returned");
          }
        }

        stopped = true;
        mRecorder.stop();
      }
    }

    public void startRecording() {
      mRecorder.startRecording();
      waitStarted.release();
    }

    public void stopRecording() {
      sleep = true;
      while (!stopped) {
        try {
          Thread.sleep(100);
        } catch (InterruptedException e) {
        }
      }
    }

    public void pauseRecording() {
      if (!stopped)
        mRecorder.stop();
    }

    public void resumeRecording() {
      if (!stopped)
        mRecorder.startRecording();
    }

    public boolean isStopped() {
      return stopped;
    }
  }

  private native void nativeAudioRecordCallback();
}

```

`Xorg/src/main/java/io/neoterm/Clipboard.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.ClipboardManager;
import android.content.ClipboardManager.OnPrimaryClipChangedListener;
import android.content.Context;
import android.os.Build;
import android.util.Log;


public abstract class Clipboard {
  public static Clipboard get() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB)
      return NewerClipboard.Holder.Instance;
    return OlderClipboard.Holder.Instance;
  }

  public abstract void set(final Context context, final String text);

  public abstract String get(final Context context);

  public abstract void setListener(final Context context, final Runnable listener);

  private static class NewerClipboard extends Clipboard {
    private static class Holder {
      private static final NewerClipboard Instance = new NewerClipboard();
    }

    public void set(final Context context, final String text) {
      try {
        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(context.CLIPBOARD_SERVICE);
        if (clipboard != null)
          clipboard.setText(text);
      } catch (Exception e) {
        Log.i("SDL", "setClipboardText() exception: " + e.toString());
      }
    }

    public String get(final Context context) {
      String ret = "";
      try {
        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(context.CLIPBOARD_SERVICE);
        if (clipboard != null && clipboard.getText() != null)
          ret = clipboard.getText().toString();
      } catch (Exception e) {
        Log.i("SDL", "getClipboardText() exception: " + e.toString());
      }
      return ret;
    }

    public void setListener(final Context context, final Runnable listener) {
      ClipboardManager clipboard = (ClipboardManager) context.getSystemService(context.CLIPBOARD_SERVICE);
      clipboard.addPrimaryClipChangedListener(new OnPrimaryClipChangedListener() {
        public void onPrimaryClipChanged() {
          listener.run();
        }
      });
    }
  }

  private static class OlderClipboard extends Clipboard {
    private static class Holder {
      private static final OlderClipboard Instance = new OlderClipboard();
    }

    public void set(final Context context, final String text) {
      try {
        android.text.ClipboardManager clipboard = (android.text.ClipboardManager) context.getSystemService(context.CLIPBOARD_SERVICE);
        if (clipboard != null)
          clipboard.setText(text);
      } catch (Exception e) {
        Log.i("SDL", "setClipboardText() exception: " + e.toString());
      }
    }

    public String get(final Context context) {
      String ret = "";
      try {
        android.text.ClipboardManager clipboard = (android.text.ClipboardManager) context.getSystemService(context.CLIPBOARD_SERVICE);
        if (clipboard != null && clipboard.getText() != null)
          ret = clipboard.getText().toString();
      } catch (Exception e) {
        Log.i("SDL", "getClipboardText() exception: " + e.toString());
      }
      return ret;
    }

    public void setListener(final Context context, final Runnable listener) {
      Log.i("SDL", "Cannot set clipboard listener on Android 2.3 or older");
    }
  }
}



```

`Xorg/src/main/java/io/neoterm/GLSurfaceView_SDL.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *		http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* This is GLSurfaceView class ripped out of Android 2.1 sources,
   fixed with a hammer to work with libSDL port */

package io.neoterm;

import android.app.KeyguardManager;
import android.content.Context;
import android.util.AttributeSet;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

import javax.microedition.khronos.egl.*;
import javax.microedition.khronos.opengles.GL;
import javax.microedition.khronos.opengles.GL10;
import java.io.Writer;
import java.util.ArrayList;
import java.util.concurrent.Semaphore;

/**
 * An implementation of SurfaceView that uses the dedicated surface for
 * displaying OpenGL rendering.
 * <p>
 * A GLSurfaceView provides the following features:
 * <p>
 * <ul>
 * <li>Manages a surface, which is a special piece of memory that can be
 * composited into the Android view system.
 * <li>Manages an EGL display, which enables OpenGL to render into a surface.
 * <li>Accepts a user-provided Renderer object that does the actual rendering.
 * <li>Renders on a dedicated thread to decouple rendering performance from the
 * UI thread.
 * <li>Supports both on-demand and continuous rendering.
 * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
 * </ul>
 *
 * <h3>Using GLSurfaceView</h3>
 * <p>
 * Typically you use GLSurfaceView by subclassing it and overriding one or more of the
 * View system input event methods. If your application does not need to override event
 * methods then GLSurfaceView can be used as-is. For the most part
 * GLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
 * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
 * is registered with the GLSurfaceView
 * using the {@link #setRenderer(Renderer)} call.
 * <p>
 * <h3>Initializing GLSurfaceView</h3>
 * All you have to do to initialize a GLSurfaceView is call {@link #setRenderer(Renderer)}.
 * However, if desired, you can modify the default behavior of GLSurfaceView by calling one or
 * more of these methods before calling setRenderer:
 * <ul>
 * <li>{@link #setDebugFlags(int)}
 * <li>{@link #setEGLConfigChooser(boolean)}
 * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
 * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
 * <li>{@link #setGLWrapper(GLWrapper)}
 * </ul>
 * <p>
 * <h4>Choosing an EGL Configuration</h4>
 * A given Android device may support multiple possible types of drawing surfaces.
 * The available surfaces may differ in how may channels of data are present, as
 * well as how many bits are allocated to each channel. Therefore, the first thing
 * GLSurfaceView has to do when starting to render is choose what type of surface to use.
 * <p>
 * By default GLSurfaceView chooses an available surface that's closest to a 16-bit R5G6B5 surface
 * with a 16-bit depth buffer and no stencil. If you would prefer a different surface (for example,
 * if you do not need a depth buffer) you can override the default behavior by calling one of the
 * setEGLConfigChooser methods.
 * <p>
 * <h4>Debug Behavior</h4>
 * You can optionally modify the behavior of GLSurfaceView by calling
 * one or more of the debugging methods {@link #setDebugFlags(int)},
 * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
 * typically they are called before setRenderer so that they take effect immediately.
 * <p>
 * <h4>Setting a Renderer</h4>
 * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
 * The renderer is
 * responsible for doing the actual OpenGL rendering.
 * <p>
 * <h3>Rendering Mode</h3>
 * Once the renderer is set, you can control whether the renderer draws
 * continuously or on-demand by calling
 * {@link #setRenderMode}. The default is continuous rendering.
 * <p>
 * <h3>Activity Life-cycle</h3>
 * A GLSurfaceView must be notified when the activity is paused and resumed. GLSurfaceView clients
 * are required to call {@link #onPause()} when the activity pauses and
 * {@link #onResume()} when the activity resumes. These calls allow GLSurfaceView to
 * pause and resume the rendering thread, and also allow GLSurfaceView to release and recreate
 * the OpenGL display.
 * <p>
 * <h3>Handling events</h3>
 * <p>
 * To handle an event you will typically subclass GLSurfaceView and override the
 * appropriate method, just as you would with any other View. However, when handling
 * the event, you may need to communicate with the Renderer object
 * that's running in the rendering thread. You can do this using any
 * standard Java cross-thread communication mechanism. In addition,
 * one relatively easy way to communicate with your renderer is
 * to call
 * {@link #queueEvent(Runnable)}. For example:
 * <pre class="prettyprint">
 * class MyGLSurfaceView extends GLSurfaceView {
 *
 * 	   private MyRenderer mMyRenderer;
 *
 * 	   public void start() {
 * 		   mMyRenderer = ...;
 * 		   setRenderer(mMyRenderer);
 *     }
 *
 * 	   public boolean onKeyDown(int keyCode, KeyEvent event) {
 * 		   if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
 * 			   queueEvent(new Runnable() {
 * 				   // This method will be called on the rendering
 * 				   // thread:
 * 				   public void run() {
 * 					   mMyRenderer.handleDpadCenter();
 *           }});
 * 			   return true;
 *       }
 * 		   return super.onKeyDown(keyCode, event);
 *     }
 * }
 * </pre>
 */
@SuppressWarnings("ALL")
public class GLSurfaceView_SDL extends SurfaceView implements SurfaceHolder.Callback {
  /**
   * The renderer only renders
   * when the surface is created, or when {@link #requestRender} is called.
   *
   * @see #getRenderMode()
   * @see #setRenderMode(int)
   */
  public final static int RENDERMODE_WHEN_DIRTY = 0;
  /**
   * The renderer is called
   * continuously to re-render the scene.
   *
   * @see #getRenderMode()
   * @see #setRenderMode(int)
   * @see #requestRender()
   */
  public final static int RENDERMODE_CONTINUOUSLY = 1;

  /**
   * Check glError() after every GL call and throw an exception if glError indicates
   * that an error has occurred. This can be used to help track down which OpenGL ES call
   * is causing an error.
   *
   * @see #getDebugFlags
   * @see #setDebugFlags
   */
  public final static int DEBUG_CHECK_GL_ERROR = 1;

  /**
   * Log GL calls to the system log at "verbose" level with tag "GLSurfaceView".
   *
   * @see #getDebugFlags
   * @see #setDebugFlags
   */
  public final static int DEBUG_LOG_GL_CALLS = 2;

  /**
   * Standard View constructor. In order to render something, you
   * must call {@link #setRenderer} to register a renderer.
   */
  public GLSurfaceView_SDL(Context context) {
    super(context);
    init();
  }

  /**
   * Standard View constructor. In order to render something, you
   * must call {@link #setRenderer} to register a renderer.
   */
  public GLSurfaceView_SDL(Context context, AttributeSet attrs) {
    super(context, attrs);
    init();
  }

  private void init() {
    // Install a SurfaceHolder.Callback so we get notified when the
    // underlying surface is created and destroyed
    SurfaceHolder holder = getHolder();
    holder.addCallback(this);
    holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
    mKeyguardManager = ((KeyguardManager) getContext().getSystemService(Context.KEYGUARD_SERVICE));
  }

  /**
   * Set the glWrapper. If the glWrapper is not null, its
   * {@link GLWrapper#wrap(GL)} method is called
   * whenever a surface is created. A GLWrapper can be used to wrap
   * the GL object that's passed to the renderer. Wrapping a GL
   * object enables examining and modifying the behavior of the
   * GL calls made by the renderer.
   * <p>
   * Wrapping is typically used for debugging purposes.
   * <p>
   * The default value is null.
   *
   * @param glWrapper the new GLWrapper
   */
  public void setGLWrapper(GLWrapper glWrapper) {
    mGLWrapper = glWrapper;
  }

  /**
   * Set the debug flags to a new value. The value is
   * constructed by OR-together zero or more
   * of the DEBUG_CHECK_* constants. The debug flags take effect
   * whenever a surface is created. The default value is zero.
   *
   * @param debugFlags the new debug flags
   * @see #DEBUG_CHECK_GL_ERROR
   * @see #DEBUG_LOG_GL_CALLS
   */
  public void setDebugFlags(int debugFlags) {
    mDebugFlags = debugFlags;
  }

  /**
   * Get the current value of the debug flags.
   *
   * @return the current value of the debug flags.
   */
  public int getDebugFlags() {
    return mDebugFlags;
  }

  /**
   * Set the renderer associated with this view. Also starts the thread that
   * will call the renderer, which in turn causes the rendering to start.
   * <p>This method should be called once and only once in the life-cycle of
   * a GLSurfaceView.
   * <p>The following GLSurfaceView methods can only be called <em>before</em>
   * setRenderer is called:
   * <ul>
   * <li>{@link #setEGLConfigChooser(boolean)}
   * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
   * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
   * </ul>
   * <p>
   * The following GLSurfaceView methods can only be called <em>after</em>
   * setRenderer is called:
   * <ul>
   * <li>{@link #getRenderMode()}
   * <li>{@link #onPause()}
   * <li>{@link #onResume()}
   * <li>{@link #queueEvent(Runnable)}
   * <li>{@link #requestRender()}
   * <li>{@link #setRenderMode(int)}
   * </ul>
   *
   * @param renderer the renderer to use to perform OpenGL drawing.
   */
  public void setRenderer(Renderer renderer) {
    if (mGLThread != null) {
      throw new IllegalStateException(
        "setRenderer has already been called for this instance.");
    }
    if (mEGLConfigChooser == null) {
      mEGLConfigChooser = getEglConfigChooser(16, false, false, false, false);
    }
    mGLThread = new GLThread(renderer);
    mGLThread.start();
  }

  /**
   * Install a custom EGLConfigChooser.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If no setEGLConfigChooser method is called, then by default the
   * view will choose a config as close to 16-bit RGB as possible, with
   * a depth buffer as close to 16 bits as possible.
   *
   * @param configChooser
   */
  public void setEGLConfigChooser(EGLConfigChooser configChooser) {
    if (mGLThread != null) {
      throw new IllegalStateException(
        "setRenderer has already been called for this instance.");
    }
    mEGLConfigChooser = configChooser;
  }

  /**
   * Install a config chooser which will choose a config
   * as close to 16-bit RGB as possible, with or without an optional depth
   * buffer as close to 16-bits as possible.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If no setEGLConfigChooser method is called, then by default the
   * view will choose a config as close to 16-bit RGB as possible, with
   * a depth buffer as close to 16 bits as possible.
   *
   * @param needDepth
   */
  public void setEGLConfigChooser(int bpp, boolean needDepth, boolean stencil, boolean gles2, boolean gles3) {
    setEGLConfigChooser(getEglConfigChooser(bpp, needDepth, stencil, gles2, gles3));
  }

  /**
   * Install a config chooser which will choose a config
   * with at least the specified component sizes, and as close
   * to the specified component sizes as possible.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If no setEGLConfigChooser method is called, then by default the
   * view will choose a config as close to 16-bit RGB as possible, with
   * a depth buffer as close to 16 bits as possible.
   */
  public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
                                  int alphaSize, int depthSize, int stencilSize, boolean gles2, boolean gles3) {
    setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
      blueSize, alphaSize, depthSize, stencilSize, gles2, gles3));
  }

  /**
   * Set the rendering mode. When renderMode is
   * RENDERMODE_CONTINUOUSLY, the renderer is called
   * repeatedly to re-render the scene. When renderMode
   * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
   * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
   * <p>
   * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
   * by allowing the GPU and CPU to idle when the view does not need to be updated.
   * <p>
   * This method can only be called after {@link #setRenderer(Renderer)}
   *
   * @param renderMode one of the RENDERMODE_X constants
   * @see #RENDERMODE_CONTINUOUSLY
   * @see #RENDERMODE_WHEN_DIRTY
   */
  public void setRenderMode(int renderMode) {
    mGLThread.setRenderMode(renderMode);
  }

  /**
   * Get the current rendering mode. May be called
   * from any thread. Must not be called before a renderer has been set.
   *
   * @return the current rendering mode.
   * @see #RENDERMODE_CONTINUOUSLY
   * @see #RENDERMODE_WHEN_DIRTY
   */
  public int getRenderMode() {
    return mGLThread.getRenderMode();
  }

  /**
   * Request that the renderer render a frame.
   * This method is typically used when the render mode has been set to
   * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
   * May be called
   * from any thread. Must not be called before a renderer has been set.
   */
  public void requestRender() {
    mGLThread.requestRender();
  }

  /**
   * This method is part of the SurfaceHolder.Callback interface, and is
   * not normally called or subclassed by clients of GLSurfaceView.
   */
  public void surfaceCreated(SurfaceHolder holder) {
    mGLThread.surfaceCreated();
  }

  /**
   * This method is part of the SurfaceHolder.Callback interface, and is
   * not normally called or subclassed by clients of GLSurfaceView.
   */
  public void surfaceDestroyed(SurfaceHolder holder) {
    // Surface will be destroyed when we return
    mGLThread.surfaceDestroyed();
  }

  /**
   * This method is part of the SurfaceHolder.Callback interface, and is
   * not normally called or subclassed by clients of GLSurfaceView.
   */
  public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    mGLThread.onWindowResize(w, h);
  }

  /**
   * Inform the view that the activity is paused. The owner of this view must
   * call this method when the activity is paused. Calling this method will
   * pause the rendering thread.
   * Must not be called before a renderer has been set.
   */
  public void onPause() {
    mGLThread.onPause();
  }

  /**
   * Inform the view that the activity is resumed. The owner of this view must
   * call this method when the activity is resumed. Calling this method will
   * recreate the OpenGL display and resume the rendering
   * thread.
   * Must not be called before a renderer has been set.
   */
  public void onResume() {
    mGLThread.onResume();
  }

  /**
   * Queue a runnable to be run on the GL rendering thread. This can be used
   * to communicate with the Renderer on the rendering thread.
   * Must not be called before a renderer has been set.
   *
   * @param r the runnable to be run on the GL rendering thread.
   */
  public void queueEvent(Runnable r) {
    mGLThread.queueEvent(r);
  }

  /**
   * This method is used as part of the View class and is not normally
   * called or subclassed by clients of GLSurfaceView.
   * Must not be called before a renderer has been set.
   */
  @Override
  protected void onDetachedFromWindow() {
    super.onDetachedFromWindow();
    mGLThread.requestExitAndWait();
  }

  // ----------------------------------------------------------------------

  /**
   * An interface used to wrap a GL interface.
   * <p>Typically
   * used for implementing debugging and tracing on top of the default
   * GL interface. You would typically use this by creating your own class
   * that implemented all the GL methods by delegating to another GL instance.
   * Then you could add your own behavior before or after calling the
   * delegate. All the GLWrapper would do was instantiate and return the
   * wrapper GL instance:
   * <pre class="prettyprint">
   * class MyGLWrapper implements GLWrapper {
   * 	   GL wrap(GL gl) {
   * 		   return new MyGLImplementation(gl);
   *     }
   * 	   static class MyGLImplementation implements GL,GL10,GL11,... {
   * 		   ...
   *     }
   * }
   * </pre>
   *
   * @see #setGLWrapper(GLWrapper)
   */
  public interface GLWrapper {
    /**
     * Wraps a gl interface in another gl interface.
     *
     * @param gl a GL interface that is to be wrapped.
     * @return either the input argument or another GL object that wraps the input argument.
     */
    GL wrap(GL gl);
  }

  /**
   * A generic renderer interface.
   * <p>
   * The renderer is responsible for making OpenGL calls to render a frame.
   * <p>
   * GLSurfaceView clients typically create their own classes that implement
   * this interface, and then call {@link GLSurfaceView#setRenderer} to
   * register the renderer with the GLSurfaceView.
   * <p>
   * <h3>Threading</h3>
   * The renderer will be called on a separate thread, so that rendering
   * performance is decoupled from the UI thread. Clients typically need to
   * communicate with the renderer from the UI thread, because that's where
   * input events are received. Clients can communicate using any of the
   * standard Java techniques for cross-thread communication, or they can
   * use the {@link GLSurfaceView#queueEvent(Runnable)} convenience method.
   * <p>
   * <h3>EGL Context Lost</h3>
   * There are situations where the EGL rendering context will be lost. This
   * typically happens when device wakes up after going to sleep. When
   * the EGL context is lost, all OpenGL resources (such as textures) that are
   * associated with that context will be automatically deleted. In order to
   * keep rendering correctly, a renderer must recreate any lost resources
   * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
   * is a convenient place to do this.
   *
   * @see #setRenderer(Renderer)
   */
  public static interface SwapBuffersCallback {
    public boolean SwapBuffers();

    public void ResetVideoSurface();

    public void onWindowResize(int width, int height);
  }

  public static abstract class Renderer {
    /**
     * Called when the surface is created or recreated.
     * <p>
     * Called when the rendering thread
     * starts and whenever the EGL context is lost. The context will typically
     * be lost when the Android device awakes after going to sleep.
     * <p>
     * Since this method is called at the beginning of rendering, as well as
     * every time the EGL context is lost, this method is a convenient place to put
     * code to create resources that need to be created when the rendering
     * starts, and that need to be recreated when the EGL context is lost.
     * Textures are an example of a resource that you might want to create
     * here.
     * <p>
     * Note that when the EGL context is lost, all OpenGL resources associated
     * with that context will be automatically deleted. You do not need to call
     * the corresponding "glDelete" methods such as glDeleteTextures to
     * manually delete these lost resources.
     * <p>
     *
     * @param gl     the GL interface. Use <code>instanceof</code> to
     *               test if the interface supports GL11 or higher interfaces.
     * @param config the EGLConfig of the created surface. Can be used
     *               to create matching pbuffers.
     */
    public abstract void onSurfaceCreated(GL10 gl, EGLConfig config);

    public abstract void onSurfaceDestroyed();

    /**
     * Called when the surface changed size.
     * <p>
     * Called after the surface is created and whenever
     * the OpenGL ES surface size changes.
     * <p>
     * Typically you will set your viewport here. If your camera
     * is fixed then you could also set your projection matrix here:
     * <pre class="prettyprint">
     * void onSurfaceChanged(GL10 gl, int width, int height) {
     * 	   gl.glViewport(0, 0, width, height);
     * 	   // for a fixed camera, set the projection too
     * 	   float ratio = (float) width / height;
     * 	   gl.glMatrixMode(GL10.GL_PROJECTION);
     * 	   gl.glLoadIdentity();
     * 	   gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
     * }
     * </pre>
     *
     * @param gl     the GL interface. Use <code>instanceof</code> to
     *               test if the interface supports GL11 or higher interfaces.
     * @param width
     * @param height
     */
    public abstract void onSurfaceChanged(GL10 gl, int width, int height);

    /**
     * Called when screen size changes
     */
    public void onWindowResize(int width, int height) {
      if (mSwapBuffersCallback != null)
        mSwapBuffersCallback.onWindowResize(width, height);
    }

    /**
     * Called to draw the current frame.
     * <p>
     * This method is responsible for drawing the current frame.
     * <p>
     * The implementation of this method typically looks like this:
     * <pre class="prettyprint">
     * void onDrawFrame(GL10 gl) {
     * 	   gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
     * 	   //... other gl calls to render the scene ...
     * }
     * </pre>
     *
     * @param gl the GL interface. Use <code>instanceof</code> to
     *           test if the interface supports GL11 or higher interfaces.
     */
    public abstract void onDrawFrame(GL10 gl);

    public boolean SwapBuffers() {
      if (mSwapBuffersCallback != null)
        return mSwapBuffersCallback.SwapBuffers();
      return false;
    }

    public void ResetVideoSurface() {
      if (mSwapBuffersCallback != null)
        mSwapBuffersCallback.ResetVideoSurface();
    }

    public void setSwapBuffersCallback(SwapBuffersCallback c) {
      mSwapBuffersCallback = c;
    }

    private SwapBuffersCallback mSwapBuffersCallback = null;
  }

  /**
   * An interface for choosing an EGLConfig configuration from a list of
   * potential configurations.
   * <p>
   * This interface must be implemented by clients wishing to call
   * {@link GLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
   */
  public interface EGLConfigChooser {
    /**
     * Choose a configuration from the list. Implementors typically
     * implement this method by calling
     * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
     * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
     *
     * @param egl     the EGL10 for the current display.
     * @param display the current display.
     * @return the chosen configuration.
     */
    EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);

    public boolean isGles2Required();

    public boolean isGles3Required();
  }

  private static abstract class BaseConfigChooser
    implements EGLConfigChooser {
    public BaseConfigChooser(int[] configSpec) {
      mConfigSpec = configSpec;
    }

    public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
      int[] num_config = new int[1];
      egl.eglChooseConfig(display, mConfigSpec, null, 0, num_config);

      int numConfigs = num_config[0];

      if (numConfigs <= 0) {
        throw new IllegalArgumentException(
          "No configs match configSpec");
      }

      EGLConfig[] configs = new EGLConfig[numConfigs];
      egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
        num_config);
      EGLConfig config = chooseConfig(egl, display, configs);
      if (config == null) {
        throw new IllegalArgumentException("No config chosen");
      }
      return config;
    }

    abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
                                    EGLConfig[] configs);

    protected int[] mConfigSpec;
  }

  private static class ComponentSizeChooser extends BaseConfigChooser {
    public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
                                int alphaSize, int depthSize, int stencilSize, boolean isGles2, boolean isGles3) {
      super(new int[]{EGL10.EGL_NONE}); // Get all possible configs
      mValue = new int[1];
      mRedSize = redSize;
      mGreenSize = greenSize;
      mBlueSize = blueSize;
      mAlphaSize = alphaSize;
      mDepthSize = depthSize;
      mStencilSize = stencilSize;
      mIsGles2 = isGles2;
      mIsGles3 = isGles3;
    }

    @Override
    public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
                                  EGLConfig[] configs) {
      EGLConfig closestConfig = null;
      int closestDistance = 1000;
      String cfglog = "";
      int idx = 0;
      int selectidx = -1;

      Log.v("SDL", "Desired GL config: " + "R" + mRedSize + "G" + mGreenSize + "B" + mBlueSize + "A" + mAlphaSize + " depth " + mDepthSize + " stencil " + mStencilSize + " type " + (mIsGles3 ? "GLES3" : mIsGles2 ? "GLES2" : "GLES"));
      for (EGLConfig config : configs) {
        if (config == null)
          continue;
        int r = findConfigAttrib(egl, display, config,
          EGL10.EGL_RED_SIZE, 0);
        int g = findConfigAttrib(egl, display, config,
          EGL10.EGL_GREEN_SIZE, 0);
        int b = findConfigAttrib(egl, display, config,
          EGL10.EGL_BLUE_SIZE, 0);
        int a = findConfigAttrib(egl, display, config,
          EGL10.EGL_ALPHA_SIZE, 0);
        int d = findConfigAttrib(egl, display, config,
          EGL10.EGL_DEPTH_SIZE, 0);
        int s = findConfigAttrib(egl, display, config,
          EGL10.EGL_STENCIL_SIZE, 0);
        int rendertype = findConfigAttrib(egl, display, config,
          EGL10.EGL_RENDERABLE_TYPE, 0);
        int desiredtype = mIsGles3 ? EGL_OPENGL_ES3_BIT : mIsGles2 ? EGL_OPENGL_ES2_BIT : EGL_OPENGL_ES_BIT;
        int nativeRender = findConfigAttrib(egl, display, config,
          EGL10.EGL_NATIVE_RENDERABLE, 0);
        int caveat = findConfigAttrib(egl, display, config,
          EGL10.EGL_CONFIG_CAVEAT, EGL10.EGL_NONE);
        int distance = Math.abs(r - mRedSize) + Math.abs(g - mGreenSize) + Math.abs(b - mBlueSize);
        int dist1 = distance;
        if (mAlphaSize - a > 0)
          distance += mAlphaSize - a;
        else if (mAlphaSize - a < 0)
          distance += 1; // Small penalty if we don't need alpha channel but it is present
        int dist2 = distance;
        if ((d > 0) != (mDepthSize > 0))
          distance += (mDepthSize > 0) ? 5 : 1; // Small penalty if we don't need zbuffer but it is present
        int dist3 = distance;
        if ((s > 0) != (mStencilSize > 0))
          distance += (mStencilSize > 0) ? 5 : 1; // Small penalty if we don't need stencil buffer but it is present
        int dist4 = distance;
        if ((rendertype & desiredtype) == 0)
          distance += 5;
        int dist5 = distance;
        if (caveat == EGL10.EGL_SLOW_CONFIG)
          distance += 4;
        if (caveat == EGL10.EGL_NON_CONFORMANT_CONFIG) // dunno what that means, probably R and B channels swapped
          distance += 1;

        String cfgcur = "R" + r + "G" + g + "B" + b + "A" + a + " depth " + d + " stencil " + s +
          " type " + rendertype + " (";
        if ((rendertype & EGL_OPENGL_ES_BIT) != 0)
          cfgcur += "GLES";
        if ((rendertype & EGL_OPENGL_ES2_BIT) != 0)
          cfgcur += " GLES2";
        if ((rendertype & EGL_OPENGL_ES3_BIT) != 0)
          cfgcur += " GLES3";
        if ((rendertype & EGL_OPENGL_BIT) != 0)
          cfgcur += " OPENGL";
        if ((rendertype & EGL_OPENVG_BIT) != 0)
          cfgcur += " OPENVG";
        cfgcur += ")";
        cfgcur += " caveat " + (caveat == EGL10.EGL_NONE ? "none" :
          (caveat == EGL10.EGL_SLOW_CONFIG ? "SLOW" :
            caveat == EGL10.EGL_NON_CONFORMANT_CONFIG ? "non-conformant" :
              String.valueOf(caveat)));
        cfgcur += " nr " + nativeRender;
        cfgcur += " pos " + distance + " (" + dist1 + "," + dist2 + "," + dist3 + "," + dist4 + "," + dist5 + ")";
        Log.v("SDL", "GL config " + idx + ": " + cfgcur);
        if (distance < closestDistance) {
          closestDistance = distance;
          closestConfig = config;
          cfglog = new String(cfgcur);
          selectidx = idx;
        }
        idx += 1;
      }
      Log.v("SDL", "GLSurfaceView_SDL::EGLConfigChooser::chooseConfig(): selected " + selectidx + ": " + cfglog);
      return closestConfig;
    }

    private int findConfigAttrib(EGL10 egl, EGLDisplay display,
                                 EGLConfig config, int attribute, int defaultValue) {
      mValue[0] = -1;
      if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
        return mValue[0];
      }
      Log.w("SDL", "GLSurfaceView_SDL::EGLConfigChooser::findConfigAttrib(): attribute doesn't exist: " + attribute);
      return defaultValue;
    }

    public boolean isGles2Required() {
      return mIsGles2;
    }

    public boolean isGles3Required() {
      return mIsGles3;
    }

    private int[] mValue;
    // Subclasses can adjust these values:
    protected int mRedSize;
    protected int mGreenSize;
    protected int mBlueSize;
    protected int mAlphaSize;
    protected int mDepthSize;
    protected int mStencilSize;
    protected boolean mIsGles2 = false;
    protected boolean mIsGles3 = false;

    public static final int EGL_OPENGL_ES_BIT = 1;
    public static final int EGL_OPENVG_BIT = 2;
    public static final int EGL_OPENGL_ES2_BIT = 4;
    public static final int EGL_OPENGL_BIT = 8;
    public static final int EGL_OPENGL_ES3_BIT = 16;
  }

  /**
   * This class will choose a supported surface as close to
   * RGB565 as possible, with or without a depth buffer.
   */
  private static class SimpleEGLConfigChooser16 extends ComponentSizeChooser {
    public SimpleEGLConfigChooser16(boolean withDepthBuffer, boolean stencil, boolean gles2, boolean gles3) {
      super(4, 4, 4, 0, withDepthBuffer ? 16 : 0, stencil ? 8 : 0, gles2, gles3);
      // Adjust target values. This way we'll accept a 4444 or
      // 555 buffer if there's no 565 buffer available.
      mRedSize = 5;
      mGreenSize = 6;
      mBlueSize = 5;
    }
  }

  private static class SimpleEGLConfigChooser24 extends ComponentSizeChooser {
    public SimpleEGLConfigChooser24(boolean withDepthBuffer, boolean stencil, boolean gles2, boolean gles3) {
      super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, stencil ? 8 : 0, gles2, gles3);
      mRedSize = 8;
      mGreenSize = 8;
      mBlueSize = 8;
    }
  }

  private static class SimpleEGLConfigChooser32 extends ComponentSizeChooser {
    public SimpleEGLConfigChooser32(boolean withDepthBuffer, boolean stencil, boolean gles2, boolean gles3) {
      super(8, 8, 8, 8, withDepthBuffer ? 16 : 0, stencil ? 8 : 0, gles2, gles3);
      mRedSize = 8;
      mGreenSize = 8;
      mBlueSize = 8;
      mAlphaSize = 8;
    }
  }

  private static ComponentSizeChooser getEglConfigChooser(int videoDepthBpp, boolean withDepthBuffer, boolean stencil, boolean gles2, boolean gles3) {
    if (videoDepthBpp == 16)
      return new SimpleEGLConfigChooser16(withDepthBuffer, stencil, gles2, gles3);
    if (videoDepthBpp == 24)
      return new SimpleEGLConfigChooser24(withDepthBuffer, stencil, gles2, gles3);
    if (videoDepthBpp == 32)
      return new SimpleEGLConfigChooser32(withDepthBuffer, stencil, gles2, gles3);
    return null;
  }

  ;

  /**
   * An EGL helper class.
   */

  private class EglHelper {
    public EglHelper() {

    }

    /**
     * Initialize EGL for a given configuration spec.
     *
     * @param configSpec
     */
    public void start() {

      Log.v("SDL", "GLSurfaceView_SDL::EglHelper::start(): creating GL context");
      /*
       * Get an EGL instance
       */
      mEgl = (EGL10) EGLContext.getEGL();

      /*
       * Get to the default display.
       */
      mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);

      /*
       * We can now initialize EGL for that display
       */
      int[] version = new int[2];
      mEgl.eglInitialize(mEglDisplay, version);
      mEglConfig = mEGLConfigChooser.chooseConfig(mEgl, mEglDisplay);
      if (mEglConfig == null)
        Log.e("SDL", "GLSurfaceView_SDL::EglHelper::start(): mEglConfig is NULL");

      /*
       * Create an OpenGL ES context. This must be done only once, an
       * OpenGL context is a somewhat heavy object.
       */
      final int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
      final int[] gles2_attrib_list = {EGL_CONTEXT_CLIENT_VERSION, 2, EGL10.EGL_NONE};
      final int[] gles3_attrib_list = {EGL_CONTEXT_CLIENT_VERSION, 3, EGL10.EGL_NONE};

      mEglContext = mEgl.eglCreateContext(mEglDisplay, mEglConfig,
        EGL10.EGL_NO_CONTEXT,
        mEGLConfigChooser.isGles3Required() ? gles3_attrib_list :
          mEGLConfigChooser.isGles2Required() ? gles2_attrib_list : null);

      if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT)
        Log.e("SDL", "GLSurfaceView_SDL::EglHelper::start(): mEglContext is EGL_NO_CONTEXT, error: " + mEgl.eglGetError());

      mEglSurface = null;
    }

    /*
     * React to the creation of a new surface by creating and returning an
     * OpenGL interface that renders to that surface.
     */
    public GL createSurface(SurfaceHolder holder) {
      Log.v("SDL", "GLSurfaceView_SDL::EglHelper::createSurface(): creating GL context");
      /*
       *	The window size has changed, so we need to create a new
       *	surface.
       */
      if (mEglSurface != null) {

        /*
         * Unbind and destroy the old EGL surface, if
         * there is one.
         */
        mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
          EGL10.EGL_NO_SURFACE, EGL10.EGL_NO_CONTEXT);
        mEgl.eglDestroySurface(mEglDisplay, mEglSurface);
      }

      /*
       * Create an EGL surface we can render into.
       */
			/*
			// This does not have any effect on Galaxy Note
			int [] attribList = new int[4];
			attribList[0] = mEgl.EGL_RENDER_BUFFER;
			attribList[1] = mEgl.EGL_SINGLE_BUFFER;
			attribList[2] = mEgl.EGL_NONE;
			attribList[3] = mEgl.EGL_NONE;
			*/
      mEglSurface = mEgl.eglCreateWindowSurface(mEglDisplay,
        mEglConfig, holder, null);

      /*
       * Before we can issue GL commands, we need to make sure
       * the context is current and bound to a surface.
       */
      mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface,
        mEglContext);

      GL gl = mEglContext.getGL();
      if (mGLWrapper != null) {
        gl = mGLWrapper.wrap(gl);
      }

      return gl;
    }

    /**
     * Display the current render surface.
     *
     * @return false if the context has been lost.
     */
    public boolean swap() {
      mEgl.eglSwapBuffers(mEglDisplay, mEglSurface);

      /*
       * Always check for EGL_CONTEXT_LOST, which means the context
       * and all associated data were lost (For instance because
       * the device went to sleep). We need to sleep until we
       * get a new surface.
       */
      return mEgl.eglGetError() != EGL11.EGL_CONTEXT_LOST;
    }

    public void finish() {
      Log.v("SDL", "GLSurfaceView_SDL::EglHelper::finish(): destroying GL context");
      if (mEglSurface != null) {
        mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
          EGL10.EGL_NO_SURFACE,
          EGL10.EGL_NO_CONTEXT);
        mEgl.eglDestroySurface(mEglDisplay, mEglSurface);
        mEglSurface = null;
      }
      if (mEglContext != null) {
        mEgl.eglDestroyContext(mEglDisplay, mEglContext);
        mEglContext = null;
      }
      if (mEglDisplay != null) {
        mEgl.eglTerminate(mEglDisplay);
        mEglDisplay = null;
      }
    }

    EGL10 mEgl;
    EGLDisplay mEglDisplay;
    EGLSurface mEglSurface;
    EGLConfig mEglConfig;
    EGLContext mEglContext;
  }

  /**
   * A generic GL Thread. Takes care of initializing EGL and GL. Delegates
   * to a Renderer instance to do the actual drawing. Can be configured to
   * render continuously or on request.
   */
  class GLThread extends Thread implements SwapBuffersCallback {
    GLThread(Renderer renderer) {
      super();
      mDone = false;
      mWidth = 0;
      mHeight = 0;
      mRequestRender = true;
      mRenderMode = RENDERMODE_CONTINUOUSLY;
      mRenderer = renderer;
      mRenderer.setSwapBuffersCallback(this);
      setName("GLThread");
    }

    @Override
    public void run() {
      /*
       * When the android framework launches a second instance of
       * an activity, the new instance's onCreate() method may be
       * called before the first instance returns from onDestroy().
       *
       * This semaphore ensures that only one instance at a time
       * accesses EGL.
       */
      try {
        sEglSemaphore.acquire();
      } catch (InterruptedException e) {
        return;
      }

      mEglHelper = new EglHelper();
      // mEglHelper.start();
      mNeedStart = true;
      mSizeChanged = true;
      SwapBuffers();

      mRenderer.onDrawFrame(mGL);

      mEglHelper.finish();

				/*
				synchronized (sGLThreadManager) {
					stopEglLocked();
				 }
				sGLThreadManager.threadExiting(this);
				*/

      sEglSemaphore.release();
    }

    /* You need to call SwapBuffers() after this function */
    public void ResetVideoSurface() {
      mResetVideoSurface = true;
    }

    public boolean SwapBuffers() {

      boolean tellRendererSurfaceCreated = false;
      boolean tellRendererSurfaceChanged = false;

      while (true) { // Loop until we're re-created GL context and successfully called swap()

        int w, h;
        boolean changed = false;
        synchronized (this) {
          if (mPaused) {
            mRenderer.onSurfaceDestroyed();
            mEglHelper.finish();
            mNeedStart = true;
            if (Globals.NonBlockingSwapBuffers)
              return false;
          }
        }
        while (needToWait()) {
          //Log.v("SDL", "GLSurfaceView_SDL::run(): paused");
          synchronized (this) {
            try {
              wait(500);
            } catch (InterruptedException e) {
              Log.v("SDL", "GLSurfaceView_SDL::GLThread::SwapBuffers(): Who dared to interrupt my slumber?");
              Thread.interrupted(); // Clear the flag
            }
          }
        }
        synchronized (this) {
          if (mDone)
            return false;
          // changed = mSizeChanged;
          w = mWidth;
          h = mHeight;
          mSizeChanged = false;
          mRequestRender = false;
        }
        if (mNeedStart) {
          mEglHelper.start();
          tellRendererSurfaceCreated = true;
          changed = true;
          mNeedStart = false;
        }
        if (changed) {
          mGL = (GL10) mEglHelper.createSurface(getHolder());
          tellRendererSurfaceChanged = true;
        }
        if (tellRendererSurfaceCreated) {
          mRenderer.onSurfaceCreated(mGL, mEglHelper.mEglConfig);
          tellRendererSurfaceCreated = false;
        }
        if (tellRendererSurfaceChanged) {
          mRenderer.onSurfaceChanged(mGL, w, h);
          tellRendererSurfaceChanged = false;
        }
        /*
         * Once we're done with GL, we need to call swapBuffers()
         * to instruct the system to display the rendered frame
         */
        if (!mResetVideoSurface && mEglHelper.swap())
          return true;
        // We've lost GL context - recreate it
        mResetVideoSurface = false;
        mRenderer.onSurfaceDestroyed();
        mEglHelper.finish();
        mNeedStart = true;
        if (Globals.NonBlockingSwapBuffers)
          return false;
      }
    }

    private boolean needToWait() {
      if (mKeyguardManager.inKeyguardRestrictedInputMode()) {
        return true; // We're in lockscreen - sleep until user unlocks the device
      }

      synchronized (this) {
        if (mDone) {
          return false;
        }

        if (Globals.HorizontalOrientation != (mWidth > mHeight))
          return true; // Wait until screen orientation changes

        if (mPaused || (!mHasSurface)) {
          return true;
        }

        if ((mWidth > 0) && (mHeight > 0) && (mRequestRender || (mRenderMode == RENDERMODE_CONTINUOUSLY))) {
          return false;
        }
      }

      return true;
    }

    public void setRenderMode(int renderMode) {
      if (!((RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= RENDERMODE_CONTINUOUSLY))) {
        throw new IllegalArgumentException("renderMode");
      }
      synchronized (this) {
        mRenderMode = renderMode;
        if (renderMode == RENDERMODE_CONTINUOUSLY) {
          notify();
        }
      }
    }

    public int getRenderMode() {
      synchronized (this) {
        return mRenderMode;
      }
    }

    public void requestRender() {
      synchronized (this) {
        mRequestRender = true;
        notify();
      }
    }

    public void surfaceCreated() {
      synchronized (this) {
        mHasSurface = true;
        notify();
      }
    }

    public void surfaceDestroyed() {
      synchronized (this) {
        mHasSurface = false;
        notify();
      }
    }

    public void onPause() {
      Log.v("SDL", "GLSurfaceView_SDL::onPause()");
      synchronized (this) {
        mPaused = true;
      }
    }

    public void onResume() {
      Log.v("SDL", "GLSurfaceView_SDL::onResume()");
      synchronized (this) {
        mPaused = false;
        notify();
      }
    }

    public void onWindowResize(int w, int h) {
      Log.v("SDL", "GLSurfaceView_SDL::onWindowResize(): " + w + "x" + h);
      synchronized (this) {
        mWidth = w;
        mHeight = h;
        mSizeChanged = true;
        mRenderer.onWindowResize(w, h);
        notify();
      }
    }

    public void requestExitAndWait() {
      // don't call this from GLThread thread or it is a guaranteed
      // deadlock!
      Log.v("SDL", "GLSurfaceView_SDL::requestExitAndWait()");
      synchronized (this) {
        mDone = true;
        notify();
      }
      try {
        join();
      } catch (InterruptedException ex) {
        //Thread.currentThread().interrupt();
      }
    }

    /**
     * Queue an "event" to be run on the GL rendering thread.
     *
     * @param r the runnable to be run on the GL rendering thread.
     */
    public void queueEvent(Runnable r) {
      synchronized (this) {
        mEventQueue.add(r);
      }
    }

    private Runnable getEvent() {
      synchronized (this) {
        if (mEventQueue.size() > 0) {
          return mEventQueue.remove(0);
        }

      }
      return null;
    }

    private boolean mDone;
    private boolean mPaused;
    private boolean mHasSurface;
    private int mWidth;
    private int mHeight;
    private int mRenderMode;
    private boolean mRequestRender;
    private Renderer mRenderer;
    private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
    private EglHelper mEglHelper;
    private GL10 mGL = null;
    private boolean mNeedStart = false;
    private boolean mResetVideoSurface = false;
  }

  static class LogWriter extends Writer {

    @Override public void close() {
      flushBuilder();
    }

    @Override public void flush() {
      flushBuilder();
    }

    @Override public void write(char[] buf, int offset, int count) {
      for (int i = 0; i < count; i++) {
        char c = buf[offset + i];
        if (c == '\n') {
          flushBuilder();
        } else {
          mBuilder.append(c);
        }
      }
    }

    private void flushBuilder() {
      if (mBuilder.length() > 0) {
        Log.v("GLSurfaceView", mBuilder.toString());
        mBuilder.delete(0, mBuilder.length());
      }
    }

    private StringBuilder mBuilder = new StringBuilder();
  }

  private static final Semaphore sEglSemaphore = new Semaphore(1);
  private boolean mSizeChanged = true;

  private GLThread mGLThread;
  private EGLConfigChooser mEGLConfigChooser;
  private GLWrapper mGLWrapper;
  private int mDebugFlags;
  private KeyguardManager mKeyguardManager;
}

```

`Xorg/src/main/java/io/neoterm/Globals.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.view.KeyEvent;

public class Globals {
  public static String XLIB_DIR = "/data/data/io.neoterm/files/usr/lib/xorg-neoterm";
  public static String XLIBS[] = {
    "x11_sdl_native_helpers",
    "x11_sdl-1.2",
    "x11_sdl_ttf",
    "x11_crypto",
  };
  public static String XAPP_LIBS[] = {
    "x11_application",
    "x11_sdl_main",
  };

  // These config options are modified by ChangeAppsettings.sh script - see the detailed descriptions there
  public static String AppLibraries[] = {"sdl_native_helpers", "sdl-1.2", "sdl_ttf", "crypto"};
  public static final boolean Using_SDL_1_3 = false;
  public static final boolean Using_SDL_2_0 = false;
  public static String[] DataDownloadUrl = {"!!Data files|:data.tar.gz:data-1.tgz", "!!Data files|:DroidSansMono.ttf:DroidSansMono.ttf", "Additional fonts (90Mb)|:xfonts.tar.gz:http://sourceforge.net/projects/libsdl-android/files/apk/XServer-XSDL/xfonts.tgz/download",};
  public static boolean SwVideoMode = true;
  public static boolean NeedDepthBuffer = false;
  public static boolean NeedStencilBuffer = false;
  public static boolean NeedGles2 = false;
  public static boolean NeedGles3 = false;
  public static boolean CompatibilityHacksVideo = false;
  public static boolean CompatibilityHacksForceScreenUpdateMouseClick = true;
  public static boolean CompatibilityHacksStaticInit = false;
  public static boolean CompatibilityHacksTextInputEmulatesHwKeyboard = true;
  public static int TextInputKeyboard = 0;
  public static boolean KeepAspectRatioDefaultSetting = false;
  public static boolean InhibitSuspend = true;
  public static boolean CreateService = true;
  public static String ReadmeText = "";
  public static String CommandLine = "XSDL";
  public static boolean AppUsesMouse = true;
  public static boolean AppNeedsTwoButtonMouse = true;
  public static boolean RightMouseButtonLongPress = false;
  public static boolean ForceRelativeMouseMode = true; // If both on-screen keyboard and mouse are needed, this will only set the default setting, user may override it later
  public static boolean ShowMouseCursor = false; // Draw system mouse cursor, if the app does not do it
  public static boolean ScreenFollowsMouse = true; // Move app screen make mouse cursor always visible, when soft keyboard is shown
  public static boolean AppNeedsArrowKeys = false;
  public static boolean AppNeedsTextInput = false;
  public static boolean AppUsesJoystick = false;
  public static boolean AppUsesSecondJoystick = false;
  public static boolean AppUsesThirdJoystick = false;
  public static boolean AppUsesAccelerometer = false;
  public static boolean AppUsesGyroscope = false;
  public static boolean AppUsesOrientationSensor = false;
  public static boolean AppUsesMultitouch = true;
  public static boolean NonBlockingSwapBuffers = false;
  public static boolean ResetSdlConfigForThisVersion = false;
  public static String DeleteFilesOnUpgrade = "%";
  public static int AppTouchscreenKeyboardKeysAmount = 3;
  public static String[] AppTouchscreenKeyboardKeysNames = "LCTRL LALT LSHIFT RETURN SPACE DELETE KP_PLUS KP_MINUS 1 2".split(" ");
  public static int StartupMenuButtonTimeout = 3000;
  public static int AppMinimumRAM = 0;
  public static SettingsMenu.Menu HiddenMenuOptions[] = {}; // If you see error here - update HiddenMenuOptions in your AndroidAppSettings.cfg: change OptionalDownloadConfig to SettingsMenuMisc.OptionalDownloadConfig etc.
  public static SettingsMenu.Menu FirstStartMenuOptions[] = {new SettingsMenuMisc.GyroscopeCalibration(), new SettingsMenuMisc.OptionalDownloadConfig(),};

  // Phone-specific config, modified by user in "Change phone config" startup dialog
  public static int VideoDepthBpp = 16;
  public static boolean HorizontalOrientation = true;
  public static boolean AutoDetectOrientation = false;
  public static boolean ImmersiveMode = true;
  public static boolean HideSystemMousePointer = false;
  public static boolean DownloadToSdcard = true;
  public static boolean PhoneHasArrowKeys = false;
  public static boolean UseAccelerometerAsArrowKeys = false;
  public static boolean UseTouchscreenKeyboard = true;
  public static int TouchscreenKeyboardSize = 1;
  public static final int TOUCHSCREEN_KEYBOARD_CUSTOM = 4;
  public static int TouchscreenKeyboardDrawSize = 2;
  public static int TouchscreenKeyboardTheme = 0;
  public static int TouchscreenKeyboardTransparency = 2;
  public static boolean FloatingScreenJoystick = false;
  public static int AccelerometerSensitivity = 2;
  public static int AccelerometerCenterPos = 2;
  public static int AudioBufferConfig = 0;
  public static boolean OptionalDataDownload[] = null;
  public static int LeftClickMethod = ForceRelativeMouseMode ? Mouse.LEFT_CLICK_WITH_TAP_OR_TIMEOUT : Mouse.LEFT_CLICK_NORMAL;
  public static int LeftClickKey = KeyEvent.KEYCODE_DPAD_CENTER;
  public static int LeftClickTimeout = 3;
  public static int RightClickTimeout = 4;
  public static int RightClickMethod = AppNeedsTwoButtonMouse ? Mouse.RIGHT_CLICK_WITH_MULTITOUCH : Mouse.RIGHT_CLICK_NONE;
  public static int RightClickKey = KeyEvent.KEYCODE_MENU;
  public static boolean MoveMouseWithJoystick = false;
  public static int MoveMouseWithJoystickSpeed = 1;
  public static int MoveMouseWithJoystickAccel = 0;
  public static boolean MoveMouseWithGyroscope = true;
  public static int MoveMouseWithGyroscopeSpeed = 2;
  public static boolean ClickMouseWithDpad = false;
  public static boolean RelativeMouseMovement = ForceRelativeMouseMode; // Laptop touchpad mode
  public static boolean ForceHardwareMouse = false;
  public static int RelativeMouseMovementSpeed = 2;
  public static int RelativeMouseMovementAccel = 0;
  public static int ShowScreenUnderFinger = Mouse.ZOOM_NONE;
  public static int ClickScreenPressure = 0;
  public static int ClickScreenTouchspotSize = 0;
  public static boolean FingerHover = true;
  public static boolean HoverJitterFilter = true;
  public static boolean GenerateSubframeTouchEvents = false;
  public static boolean KeepAspectRatio = KeepAspectRatioDefaultSetting;
  public static boolean TvBorders = true;
  public static int RemapHwKeycode[] = new int[SDL_Keys.JAVA_KEYCODE_LAST];
  public static int RemapScreenKbKeycode[] = new int[6];
  public static int ScreenKbControlsLayout[][] = AppUsesThirdJoystick ? // Values for 800x480 resolution
    new int[][]{{0, 303, 177, 480}, {0, 0, 48, 48}, {400, 392, 488, 480}, {312, 392, 400, 480}, {400, 304, 488, 392}, {312, 304, 400, 392}, {400, 216, 488, 304}, {312, 216, 400, 304}, {623, 303, 800, 480}, {623, 126, 800, 303}} :
    AppUsesSecondJoystick ?
      new int[][]{{0, 303, 177, 480}, {0, 0, 48, 48}, {400, 392, 488, 480}, {312, 392, 400, 480}, {400, 304, 488, 392}, {312, 304, 400, 392}, {400, 216, 488, 304}, {312, 216, 400, 304}, {623, 303, 800, 480}} :
      new int[][]{{0, 303, 177, 480}, {0, 0, 48, 48}, {712, 392, 800, 480}, {624, 392, 712, 480}, {712, 304, 800, 392}, {624, 304, 712, 392}, {712, 216, 800, 304}, {624, 216, 712, 304}};
  public static boolean ScreenKbControlsShown[] = new boolean[ScreenKbControlsLayout.length]; /* Also joystick and text input button added */
  public static int RemapMultitouchGestureKeycode[] = new int[4];
  public static boolean MultitouchGesturesUsed[] = new boolean[4];
  public static int MultitouchGestureSensitivity = 1;
  public static int TouchscreenCalibration[] = new int[4];
  public static String DataDir = "/data/data/io.neoterm/files/usr/share/xorg-neoterm";
  public static String UnSecureDataDir = "/data/data/io.neoterm/files/usr/share/xorg-neoterm";
  public static String HomeDir = "/data/data/io.neoterm/files/home";
  public static boolean VideoLinearFilter = true;
  public static boolean MultiThreadedVideo = false;

  public static boolean OuyaEmulation = false; // For debugging
}

```

`Xorg/src/main/java/io/neoterm/Keycodes.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Arrays;


// Autogenerated by hand with a command:
// grep 'SDLK_' SDL_keysym.h | sed 's/SDLK_\([a-zA-Z0-9_]\+\).*[=] \([0-9]\+\).*/public static final int SDLK_\1 = \2;/' >> Keycodes.java
class SDL_1_2_Keycodes {
  public static final int SDLK_UNKNOWN = 0;
  public static final int SDLK_BACKSPACE = 8;
  public static final int SDLK_TAB = 9;
  public static final int SDLK_CLEAR = 12;
  public static final int SDLK_RETURN = 13;
  public static final int SDLK_PAUSE = 19;
  public static final int SDLK_ESCAPE = 27;
  public static final int SDLK_SPACE = 32;
  public static final int SDLK_EXCLAIM = 33;
  public static final int SDLK_QUOTEDBL = 34;
  public static final int SDLK_HASH = 35;
  public static final int SDLK_DOLLAR = 36;
  public static final int SDLK_AMPERSAND = 38;
  public static final int SDLK_QUOTE = 39;
  public static final int SDLK_LEFTPAREN = 40;
  public static final int SDLK_RIGHTPAREN = 41;
  public static final int SDLK_ASTERISK = 42;
  public static final int SDLK_PLUS = 43;
  public static final int SDLK_COMMA = 44;
  public static final int SDLK_MINUS = 45;
  public static final int SDLK_PERIOD = 46;
  public static final int SDLK_SLASH = 47;
  public static final int SDLK_0 = 48;
  public static final int SDLK_1 = 49;
  public static final int SDLK_2 = 50;
  public static final int SDLK_3 = 51;
  public static final int SDLK_4 = 52;
  public static final int SDLK_5 = 53;
  public static final int SDLK_6 = 54;
  public static final int SDLK_7 = 55;
  public static final int SDLK_8 = 56;
  public static final int SDLK_9 = 57;
  public static final int SDLK_COLON = 58;
  public static final int SDLK_SEMICOLON = 59;
  public static final int SDLK_LESS = 60;
  public static final int SDLK_EQUALS = 61;
  public static final int SDLK_GREATER = 62;
  public static final int SDLK_QUESTION = 63;
  public static final int SDLK_AT = 64;
  public static final int SDLK_LEFTBRACKET = 91;
  public static final int SDLK_BACKSLASH = 92;
  public static final int SDLK_RIGHTBRACKET = 93;
  public static final int SDLK_CARET = 94;
  public static final int SDLK_UNDERSCORE = 95;
  public static final int SDLK_BACKQUOTE = 96;
  public static final int SDLK_a = 97;
  public static final int SDLK_b = 98;
  public static final int SDLK_c = 99;
  public static final int SDLK_d = 100;
  public static final int SDLK_e = 101;
  public static final int SDLK_f = 102;
  public static final int SDLK_g = 103;
  public static final int SDLK_h = 104;
  public static final int SDLK_i = 105;
  public static final int SDLK_j = 106;
  public static final int SDLK_k = 107;
  public static final int SDLK_l = 108;
  public static final int SDLK_m = 109;
  public static final int SDLK_n = 110;
  public static final int SDLK_o = 111;
  public static final int SDLK_p = 112;
  public static final int SDLK_q = 113;
  public static final int SDLK_r = 114;
  public static final int SDLK_s = 115;
  public static final int SDLK_t = 116;
  public static final int SDLK_u = 117;
  public static final int SDLK_v = 118;
  public static final int SDLK_w = 119;
  public static final int SDLK_x = 120;
  public static final int SDLK_y = 121;
  public static final int SDLK_z = 122;
  public static final int SDLK_DELETE = 127;
  public static final int SDLK_WORLD_0 = 160;
  public static final int SDLK_WORLD_1 = 161;
  public static final int SDLK_WORLD_2 = 162;
  public static final int SDLK_WORLD_3 = 163;
  public static final int SDLK_WORLD_4 = 164;
  public static final int SDLK_WORLD_5 = 165;
  public static final int SDLK_WORLD_6 = 166;
  public static final int SDLK_WORLD_7 = 167;
  public static final int SDLK_WORLD_8 = 168;
  public static final int SDLK_WORLD_9 = 169;
  public static final int SDLK_WORLD_10 = 170;
  public static final int SDLK_WORLD_11 = 171;
  public static final int SDLK_WORLD_12 = 172;
  public static final int SDLK_WORLD_13 = 173;
  public static final int SDLK_WORLD_14 = 174;
  public static final int SDLK_WORLD_15 = 175;
  public static final int SDLK_WORLD_16 = 176;
  public static final int SDLK_WORLD_17 = 177;
  public static final int SDLK_WORLD_18 = 178;
  public static final int SDLK_WORLD_19 = 179;
  public static final int SDLK_WORLD_20 = 180;
  public static final int SDLK_WORLD_21 = 181;
  public static final int SDLK_WORLD_22 = 182;
  public static final int SDLK_WORLD_23 = 183;
  public static final int SDLK_WORLD_24 = 184;
  public static final int SDLK_WORLD_25 = 185;
  public static final int SDLK_WORLD_26 = 186;
  public static final int SDLK_WORLD_27 = 187;
  public static final int SDLK_WORLD_28 = 188;
  public static final int SDLK_WORLD_29 = 189;
  public static final int SDLK_WORLD_30 = 190;
  public static final int SDLK_WORLD_31 = 191;
  public static final int SDLK_WORLD_32 = 192;
  public static final int SDLK_WORLD_33 = 193;
  public static final int SDLK_WORLD_34 = 194;
  public static final int SDLK_WORLD_35 = 195;
  public static final int SDLK_WORLD_36 = 196;
  public static final int SDLK_WORLD_37 = 197;
  public static final int SDLK_WORLD_38 = 198;
  public static final int SDLK_WORLD_39 = 199;
  public static final int SDLK_WORLD_40 = 200;
  public static final int SDLK_WORLD_41 = 201;
  public static final int SDLK_WORLD_42 = 202;
  public static final int SDLK_WORLD_43 = 203;
  public static final int SDLK_WORLD_44 = 204;
  public static final int SDLK_WORLD_45 = 205;
  public static final int SDLK_WORLD_46 = 206;
  public static final int SDLK_WORLD_47 = 207;
  public static final int SDLK_WORLD_48 = 208;
  public static final int SDLK_WORLD_49 = 209;
  public static final int SDLK_WORLD_50 = 210;
  public static final int SDLK_WORLD_51 = 211;
  public static final int SDLK_WORLD_52 = 212;
  public static final int SDLK_WORLD_53 = 213;
  public static final int SDLK_WORLD_54 = 214;
  public static final int SDLK_WORLD_55 = 215;
  public static final int SDLK_WORLD_56 = 216;
  public static final int SDLK_WORLD_57 = 217;
  public static final int SDLK_WORLD_58 = 218;
  public static final int SDLK_WORLD_59 = 219;
  public static final int SDLK_WORLD_60 = 220;
  public static final int SDLK_WORLD_61 = 221;
  public static final int SDLK_WORLD_62 = 222;
  public static final int SDLK_WORLD_63 = 223;
  public static final int SDLK_WORLD_64 = 224;
  public static final int SDLK_WORLD_65 = 225;
  public static final int SDLK_WORLD_66 = 226;
  public static final int SDLK_WORLD_67 = 227;
  public static final int SDLK_WORLD_68 = 228;
  public static final int SDLK_WORLD_69 = 229;
  public static final int SDLK_WORLD_70 = 230;
  public static final int SDLK_WORLD_71 = 231;
  public static final int SDLK_WORLD_72 = 232;
  public static final int SDLK_WORLD_73 = 233;
  public static final int SDLK_WORLD_74 = 234;
  public static final int SDLK_WORLD_75 = 235;
  public static final int SDLK_WORLD_76 = 236;
  public static final int SDLK_WORLD_77 = 237;
  public static final int SDLK_WORLD_78 = 238;
  public static final int SDLK_WORLD_79 = 239;
  public static final int SDLK_WORLD_80 = 240;
  public static final int SDLK_WORLD_81 = 241;
  public static final int SDLK_WORLD_82 = 242;
  public static final int SDLK_WORLD_83 = 243;
  public static final int SDLK_WORLD_84 = 244;
  public static final int SDLK_WORLD_85 = 245;
  public static final int SDLK_WORLD_86 = 246;
  public static final int SDLK_WORLD_87 = 247;
  public static final int SDLK_WORLD_88 = 248;
  public static final int SDLK_WORLD_89 = 249;
  public static final int SDLK_WORLD_90 = 250;
  public static final int SDLK_WORLD_91 = 251;
  public static final int SDLK_WORLD_92 = 252;
  public static final int SDLK_WORLD_93 = 253;
  public static final int SDLK_WORLD_94 = 254;
  public static final int SDLK_WORLD_95 = 255;
  public static final int SDLK_KP0 = 256;
  public static final int SDLK_KP1 = 257;
  public static final int SDLK_KP2 = 258;
  public static final int SDLK_KP3 = 259;
  public static final int SDLK_KP4 = 260;
  public static final int SDLK_KP5 = 261;
  public static final int SDLK_KP6 = 262;
  public static final int SDLK_KP7 = 263;
  public static final int SDLK_KP8 = 264;
  public static final int SDLK_KP9 = 265;
  public static final int SDLK_KP_PERIOD = 266;
  public static final int SDLK_KP_DIVIDE = 267;
  public static final int SDLK_KP_MULTIPLY = 268;
  public static final int SDLK_KP_MINUS = 269;
  public static final int SDLK_KP_PLUS = 270;
  public static final int SDLK_KP_ENTER = 271;
  public static final int SDLK_KP_EQUALS = 272;
  public static final int SDLK_UP = 273;
  public static final int SDLK_DOWN = 274;
  public static final int SDLK_RIGHT = 275;
  public static final int SDLK_LEFT = 276;
  public static final int SDLK_INSERT = 277;
  public static final int SDLK_HOME = 278;
  public static final int SDLK_END = 279;
  public static final int SDLK_PAGEUP = 280;
  public static final int SDLK_PAGEDOWN = 281;
  public static final int SDLK_F1 = 282;
  public static final int SDLK_F2 = 283;
  public static final int SDLK_F3 = 284;
  public static final int SDLK_F4 = 285;
  public static final int SDLK_F5 = 286;
  public static final int SDLK_F6 = 287;
  public static final int SDLK_F7 = 288;
  public static final int SDLK_F8 = 289;
  public static final int SDLK_F9 = 290;
  public static final int SDLK_F10 = 291;
  public static final int SDLK_F11 = 292;
  public static final int SDLK_F12 = 293;
  public static final int SDLK_F13 = 294;
  public static final int SDLK_F14 = 295;
  public static final int SDLK_F15 = 296;
  public static final int SDLK_NUMLOCK = 300;
  public static final int SDLK_CAPSLOCK = 301;
  public static final int SDLK_SCROLLOCK = 302;
  public static final int SDLK_RSHIFT = 303;
  public static final int SDLK_LSHIFT = 304;
  public static final int SDLK_RCTRL = 305;
  public static final int SDLK_LCTRL = 306;
  public static final int SDLK_RALT = 307;
  public static final int SDLK_LALT = 308;
  public static final int SDLK_RMETA = 309;
  public static final int SDLK_LMETA = 310;
  public static final int SDLK_LSUPER = 311;
  public static final int SDLK_RSUPER = 312;
  public static final int SDLK_MODE = 313;
  public static final int SDLK_COMPOSE = 314;
  public static final int SDLK_HELP = 315;
  public static final int SDLK_PRINT = 316;
  public static final int SDLK_SYSREQ = 317;
  public static final int SDLK_BREAK = 318;
  public static final int SDLK_MENU = 319;
  public static final int SDLK_POWER = 320;
  public static final int SDLK_EURO = 321;
  public static final int SDLK_UNDO = 322;

  // Mouse buttons can be mapped to on-screen keys
  public static final int SDLK_MOUSE_LEFT = 500;
  public static final int SDLK_MOUSE_MIDDLE = 501;
  public static final int SDLK_MOUSE_RIGHT = 502;
  public static final int SDLK_MOUSE_WHEEL_UP = 503;
  public static final int SDLK_MOUSE_WHEEL_DOWN = 504;
  public static final int SDLK_MOUSE_X1 = 505;
  public static final int SDLK_MOUSE_X2 = 506;

  public static final int SDLK_NO_REMAP = 512;
}

// Autogenerated by hand with a command:
// grep 'SDL_SCANCODE_' SDL_scancode.h | sed 's/SDL_SCANCODE_\([a-zA-Z0-9_]\+\).*[=] \([0-9]\+\).*/public static final int SDLK_\1 = \2;/' >> Keycodes.java
class SDL_1_3_Keycodes {
  public static final int SDLK_UNKNOWN = 0;
  public static final int SDLK_A = 4;
  public static final int SDLK_B = 5;
  public static final int SDLK_C = 6;
  public static final int SDLK_D = 7;
  public static final int SDLK_E = 8;
  public static final int SDLK_F = 9;
  public static final int SDLK_G = 10;
  public static final int SDLK_H = 11;
  public static final int SDLK_I = 12;
  public static final int SDLK_J = 13;
  public static final int SDLK_K = 14;
  public static final int SDLK_L = 15;
  public static final int SDLK_M = 16;
  public static final int SDLK_N = 17;
  public static final int SDLK_O = 18;
  public static final int SDLK_P = 19;
  public static final int SDLK_Q = 20;
  public static final int SDLK_R = 21;
  public static final int SDLK_S = 22;
  public static final int SDLK_T = 23;
  public static final int SDLK_U = 24;
  public static final int SDLK_V = 25;
  public static final int SDLK_W = 26;
  public static final int SDLK_X = 27;
  public static final int SDLK_Y = 28;
  public static final int SDLK_Z = 29;
  public static final int SDLK_1 = 30;
  public static final int SDLK_2 = 31;
  public static final int SDLK_3 = 32;
  public static final int SDLK_4 = 33;
  public static final int SDLK_5 = 34;
  public static final int SDLK_6 = 35;
  public static final int SDLK_7 = 36;
  public static final int SDLK_8 = 37;
  public static final int SDLK_9 = 38;
  public static final int SDLK_0 = 39;
  public static final int SDLK_RETURN = 40;
  public static final int SDLK_ESCAPE = 41;
  public static final int SDLK_BACKSPACE = 42;
  public static final int SDLK_TAB = 43;
  public static final int SDLK_SPACE = 44;
  public static final int SDLK_MINUS = 45;
  public static final int SDLK_EQUALS = 46;
  public static final int SDLK_LEFTBRACKET = 47;
  public static final int SDLK_RIGHTBRACKET = 48;
  public static final int SDLK_BACKSLASH = 49;
  public static final int SDLK_NONUSHASH = 50;
  public static final int SDLK_SEMICOLON = 51;
  public static final int SDLK_APOSTROPHE = 52;
  public static final int SDLK_GRAVE = 53;
  public static final int SDLK_COMMA = 54;
  public static final int SDLK_PERIOD = 55;
  public static final int SDLK_SLASH = 56;
  public static final int SDLK_CAPSLOCK = 57;
  public static final int SDLK_F1 = 58;
  public static final int SDLK_F2 = 59;
  public static final int SDLK_F3 = 60;
  public static final int SDLK_F4 = 61;
  public static final int SDLK_F5 = 62;
  public static final int SDLK_F6 = 63;
  public static final int SDLK_F7 = 64;
  public static final int SDLK_F8 = 65;
  public static final int SDLK_F9 = 66;
  public static final int SDLK_F10 = 67;
  public static final int SDLK_F11 = 68;
  public static final int SDLK_F12 = 69;
  public static final int SDLK_PRINTSCREEN = 70;
  public static final int SDLK_SCROLLLOCK = 71;
  public static final int SDLK_PAUSE = 72;
  public static final int SDLK_INSERT = 73;
  public static final int SDLK_HOME = 74;
  public static final int SDLK_PAGEUP = 75;
  public static final int SDLK_DELETE = 76;
  public static final int SDLK_END = 77;
  public static final int SDLK_PAGEDOWN = 78;
  public static final int SDLK_RIGHT = 79;
  public static final int SDLK_LEFT = 80;
  public static final int SDLK_DOWN = 81;
  public static final int SDLK_UP = 82;
  public static final int SDLK_NUMLOCKCLEAR = 83;
  public static final int SDLK_KP_DIVIDE = 84;
  public static final int SDLK_KP_MULTIPLY = 85;
  public static final int SDLK_KP_MINUS = 86;
  public static final int SDLK_KP_PLUS = 87;
  public static final int SDLK_KP_ENTER = 88;
  public static final int SDLK_KP_1 = 89;
  public static final int SDLK_KP_2 = 90;
  public static final int SDLK_KP_3 = 91;
  public static final int SDLK_KP_4 = 92;
  public static final int SDLK_KP_5 = 93;
  public static final int SDLK_KP_6 = 94;
  public static final int SDLK_KP_7 = 95;
  public static final int SDLK_KP_8 = 96;
  public static final int SDLK_KP_9 = 97;
  public static final int SDLK_KP_0 = 98;
  public static final int SDLK_KP_PERIOD = 99;
  public static final int SDLK_NONUSBACKSLASH = 100;
  public static final int SDLK_APPLICATION = 101;
  public static final int SDLK_POWER = 102;
  public static final int SDLK_KP_EQUALS = 103;
  public static final int SDLK_F13 = 104;
  public static final int SDLK_F14 = 105;
  public static final int SDLK_F15 = 106;
  public static final int SDLK_F16 = 107;
  public static final int SDLK_F17 = 108;
  public static final int SDLK_F18 = 109;
  public static final int SDLK_F19 = 110;
  public static final int SDLK_F20 = 111;
  public static final int SDLK_F21 = 112;
  public static final int SDLK_F22 = 113;
  public static final int SDLK_F23 = 114;
  public static final int SDLK_F24 = 115;
  public static final int SDLK_EXECUTE = 116;
  public static final int SDLK_HELP = 117;
  public static final int SDLK_MENU = 118;
  public static final int SDLK_SELECT = 119;
  public static final int SDLK_STOP = 120;
  public static final int SDLK_AGAIN = 121;
  public static final int SDLK_UNDO = 122;
  public static final int SDLK_CUT = 123;
  public static final int SDLK_COPY = 124;
  public static final int SDLK_PASTE = 125;
  public static final int SDLK_FIND = 126;
  public static final int SDLK_MUTE = 127;
  public static final int SDLK_VOLUMEUP = 128;
  public static final int SDLK_VOLUMEDOWN = 129;
  public static final int SDLK_KP_COMMA = 133;
  public static final int SDLK_KP_EQUALSAS400 = 134;
  public static final int SDLK_INTERNATIONAL1 = 135;
  public static final int SDLK_INTERNATIONAL2 = 136;
  public static final int SDLK_INTERNATIONAL3 = 137;
  public static final int SDLK_INTERNATIONAL4 = 138;
  public static final int SDLK_INTERNATIONAL5 = 139;
  public static final int SDLK_INTERNATIONAL6 = 140;
  public static final int SDLK_INTERNATIONAL7 = 141;
  public static final int SDLK_INTERNATIONAL8 = 142;
  public static final int SDLK_INTERNATIONAL9 = 143;
  public static final int SDLK_LANG1 = 144;
  public static final int SDLK_LANG2 = 145;
  public static final int SDLK_LANG3 = 146;
  public static final int SDLK_LANG4 = 147;
  public static final int SDLK_LANG5 = 148;
  public static final int SDLK_LANG6 = 149;
  public static final int SDLK_LANG7 = 150;
  public static final int SDLK_LANG8 = 151;
  public static final int SDLK_LANG9 = 152;
  public static final int SDLK_ALTERASE = 153;
  public static final int SDLK_SYSREQ = 154;
  public static final int SDLK_CANCEL = 155;
  public static final int SDLK_CLEAR = 156;
  public static final int SDLK_PRIOR = 157;
  public static final int SDLK_RETURN2 = 158;
  public static final int SDLK_SEPARATOR = 159;
  public static final int SDLK_OUT = 160;
  public static final int SDLK_OPER = 161;
  public static final int SDLK_CLEARAGAIN = 162;
  public static final int SDLK_CRSEL = 163;
  public static final int SDLK_EXSEL = 164;
  public static final int SDLK_KP_00 = 176;
  public static final int SDLK_KP_000 = 177;
  public static final int SDLK_THOUSANDSSEPARATOR = 178;
  public static final int SDLK_DECIMALSEPARATOR = 179;
  public static final int SDLK_CURRENCYUNIT = 180;
  public static final int SDLK_CURRENCYSUBUNIT = 181;
  public static final int SDLK_KP_LEFTPAREN = 182;
  public static final int SDLK_KP_RIGHTPAREN = 183;
  public static final int SDLK_KP_LEFTBRACE = 184;
  public static final int SDLK_KP_RIGHTBRACE = 185;
  public static final int SDLK_KP_TAB = 186;
  public static final int SDLK_KP_BACKSPACE = 187;
  public static final int SDLK_KP_A = 188;
  public static final int SDLK_KP_B = 189;
  public static final int SDLK_KP_C = 190;
  public static final int SDLK_KP_D = 191;
  public static final int SDLK_KP_E = 192;
  public static final int SDLK_KP_F = 193;
  public static final int SDLK_KP_XOR = 194;
  public static final int SDLK_KP_POWER = 195;
  public static final int SDLK_KP_PERCENT = 196;
  public static final int SDLK_KP_LESS = 197;
  public static final int SDLK_KP_GREATER = 198;
  public static final int SDLK_KP_AMPERSAND = 199;
  public static final int SDLK_KP_DBLAMPERSAND = 200;
  public static final int SDLK_KP_VERTICALBAR = 201;
  public static final int SDLK_KP_DBLVERTICALBAR = 202;
  public static final int SDLK_KP_COLON = 203;
  public static final int SDLK_KP_HASH = 204;
  public static final int SDLK_KP_SPACE = 205;
  public static final int SDLK_KP_AT = 206;
  public static final int SDLK_KP_EXCLAM = 207;
  public static final int SDLK_KP_MEMSTORE = 208;
  public static final int SDLK_KP_MEMRECALL = 209;
  public static final int SDLK_KP_MEMCLEAR = 210;
  public static final int SDLK_KP_MEMADD = 211;
  public static final int SDLK_KP_MEMSUBTRACT = 212;
  public static final int SDLK_KP_MEMMULTIPLY = 213;
  public static final int SDLK_KP_MEMDIVIDE = 214;
  public static final int SDLK_KP_PLUSMINUS = 215;
  public static final int SDLK_KP_CLEAR = 216;
  public static final int SDLK_KP_CLEARENTRY = 217;
  public static final int SDLK_KP_BINARY = 218;
  public static final int SDLK_KP_OCTAL = 219;
  public static final int SDLK_KP_DECIMAL = 220;
  public static final int SDLK_KP_HEXADECIMAL = 221;
  public static final int SDLK_LCTRL = 224;
  public static final int SDLK_LSHIFT = 225;
  public static final int SDLK_LALT = 226;
  public static final int SDLK_LGUI = 227;
  public static final int SDLK_RCTRL = 228;
  public static final int SDLK_RSHIFT = 229;
  public static final int SDLK_RALT = 230;
  public static final int SDLK_RGUI = 231;
  public static final int SDLK_MODE = 257;
  public static final int SDLK_AUDIONEXT = 258;
  public static final int SDLK_AUDIOPREV = 259;
  public static final int SDLK_AUDIOSTOP = 260;
  public static final int SDLK_AUDIOPLAY = 261;
  public static final int SDLK_AUDIOMUTE = 262;
  public static final int SDLK_MEDIASELECT = 263;
  public static final int SDLK_WWW = 264;
  public static final int SDLK_MAIL = 265;
  public static final int SDLK_CALCULATOR = 266;
  public static final int SDLK_COMPUTER = 267;
  public static final int SDLK_AC_SEARCH = 268;
  public static final int SDLK_AC_HOME = 269;
  public static final int SDLK_AC_BACK = 270;
  public static final int SDLK_AC_FORWARD = 271;
  public static final int SDLK_AC_STOP = 272;
  public static final int SDLK_AC_REFRESH = 273;
  public static final int SDLK_AC_BOOKMARKS = 274;
  public static final int SDLK_BRIGHTNESSDOWN = 275;
  public static final int SDLK_BRIGHTNESSUP = 276;
  public static final int SDLK_DISPLAYSWITCH = 277;
  public static final int SDLK_KBDILLUMTOGGLE = 278;
  public static final int SDLK_KBDILLUMDOWN = 279;
  public static final int SDLK_KBDILLUMUP = 280;
  public static final int SDLK_EJECT = 281;
  public static final int SDLK_SLEEP = 282;

  // Mouse buttons can be mapped to on-screen keys
  public static final int SDLK_MOUSE_LEFT = 500;
  public static final int SDLK_MOUSE_MIDDLE = 501;
  public static final int SDLK_MOUSE_RIGHT = 502;
  public static final int SDLK_MOUSE_WHEEL_UP = 503;
  public static final int SDLK_MOUSE_WHEEL_DOWN = 504;
  public static final int SDLK_MOUSE_X1 = 505;
  public static final int SDLK_MOUSE_X2 = 506;

  public static final int SDLK_NO_REMAP = 512;
}

class SDL_Keys {
  public static String[] names = null;
  public static Integer[] values = null;

  public static String[] namesSorted = null;
  public static Integer[] namesSortedIdx = null;
  public static Integer[] namesSortedBackIdx = null;

  static final int JAVA_KEYCODE_LAST = 255; // Android 2.3 added several new gaming keys, Android 3.1 added even more - keep in sync with javakeycodes.h

  static String getName(int v) {
    for (int f = 0; f < values.length; f++) {
      if (values[f] == v)
        return names[f];
    }
    return names[0];
  }

  static {
    ArrayList<String> Names = new ArrayList<String>();
    ArrayList<Integer> Values = new ArrayList<Integer>();
    Field[] fields = SDL_1_2_Keycodes.class.getDeclaredFields();
    if (Globals.Using_SDL_1_3) {
      fields = SDL_1_3_Keycodes.class.getDeclaredFields();
    }

    try {
      for (Field f : fields) {
        if (!f.getName().startsWith("SDLK_")) {
          continue;
        }
        Values.add(f.getInt(null));
        Names.add(f.getName().substring(5).toUpperCase());
      }
    } catch (IllegalAccessException e) {
    }
    ;

    // Sort by value
    for (int i = 0; i < Values.size(); i++) {
      for (int j = i; j < Values.size(); j++) {
        if (Values.get(i) > Values.get(j)) {
          int x = Values.get(i);
          Values.set(i, Values.get(j));
          Values.set(j, x);
          String s = Names.get(i);
          Names.set(i, Names.get(j));
          Names.set(j, s);
        }
      }
    }

    names = Names.toArray(new String[0]);
    values = Values.toArray(new Integer[0]);
    namesSorted = Names.toArray(new String[0]);
    namesSortedIdx = new Integer[values.length];
    namesSortedBackIdx = new Integer[values.length];
    Arrays.sort(namesSorted);
    for (int i = 0; i < namesSorted.length; i++) {
      for (int j = 0; j < namesSorted.length; j++) {
        if (namesSorted[i].equals(names[j])) {
          namesSortedIdx[i] = j;
          namesSortedBackIdx[j] = i;
          break;
        }
      }
    }
  }
}

```

`Xorg/src/main/java/io/neoterm/MainActivity.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.Manifest;
import android.annotation.SuppressLint;
import android.app.KeyguardManager;
import android.app.ProgressDialog;
import android.app.UiModeManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Rect;
import android.graphics.drawable.Drawable;
import android.inputmethodservice.Keyboard;
import android.inputmethodservice.KeyboardView;
import android.os.Bundle;
import android.os.SystemClock;
import android.text.InputType;
import android.text.SpannedString;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.*;
import android.view.View.OnKeyListener;
import android.view.inputmethod.InputMethodManager;
import android.widget.*;
import androidx.appcompat.app.AppCompatActivity;
import io.neoterm.xorg.NeoXorgViewClient;
import io.neoterm.xorg.R;

import java.util.LinkedList;
import java.util.TreeSet;
import java.util.concurrent.Semaphore;


public class MainActivity extends AppCompatActivity implements NeoXorgViewClient {
  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    instance = this;
    // fullscreen mode
    requestWindowFeature(Window.FEATURE_NO_TITLE);
    getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
      WindowManager.LayoutParams.FLAG_FULLSCREEN);
    if (Globals.InhibitSuspend)
      getWindow().setFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,
        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);

    Log.i("SDL", "libSDL: Creating startup screen");
    _layout = new LinearLayout(this);
    _layout.setOrientation(LinearLayout.VERTICAL);
    _layout.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
    _layout2 = new LinearLayout(this);
    _layout2.setLayoutParams(new LinearLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
    loadingDialog = new ProgressDialog(this);
    loadingDialog.setMessage(getString(R.string.accessing_network));

    final Semaphore loadedLibraries = new Semaphore(0);

    if (Globals.StartupMenuButtonTimeout > 0) {
      _btn = new Button(this);
      _btn.setEnabled(false);
      _btn.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT));
      _btn.setText(getResources().getString(R.string.device_change_cfg));
      class onClickListener implements View.OnClickListener {
        public MainActivity p;

        onClickListener(MainActivity _p) {
          p = _p;
        }

        public void onClick(View v) {
          setUpStatusLabel();
          Log.i("SDL", "libSDL: User clicked change phone config button");
          loadedLibraries.acquireUninterruptibly();
          setScreenOrientation();
          SettingsMenu.showConfig(p, false);
        }
      }
      ;
      _btn.setOnClickListener(new onClickListener(this));

      _layout2.addView(_btn);
    }

    _layout.addView(_layout2);

    ImageView img = new ImageView(this);

    img.setScaleType(ImageView.ScaleType.FIT_CENTER /* FIT_XY */);
    try {
      img.setImageDrawable(Drawable.createFromStream(getAssets().open("logo.png"), "logo.png"));
    } catch (Exception e) {
      img.setImageResource(R.drawable.publisherlogo);
    }
    img.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
    _layout.addView(img);

    _videoLayout = new FrameLayout(this);
    _videoLayout.addView(_layout);

    setContentView(_videoLayout);
    _videoLayout.setFocusable(true);
    _videoLayout.setFocusableInTouchMode(true);
    _videoLayout.requestFocus();

    class Callback implements Runnable {
      MainActivity p;

      Callback(MainActivity _p) {
        p = _p;
      }

      public void run() {
        try {
          Thread.sleep(200);
        } catch (InterruptedException e) {
        }
        ;

        if (p.mAudioThread == null) {
          Log.i("SDL", "libSDL: Loading libraries");
          p.LoadLibraries();
          p.mAudioThread = new AudioThread(p);
          Log.i("SDL", "libSDL: Loading settings");
          final Semaphore loaded = new Semaphore(0);
          class Callback2 implements Runnable {
            public MainActivity Parent;

            public void run() {
              Settings.Load(Parent);
              setScreenOrientation();
              loaded.release();
              loadedLibraries.release();
              if (_btn != null) {
                _btn.setEnabled(true);
                _btn.setFocusable(true);
                _btn.setFocusableInTouchMode(true);
                _btn.requestFocus();
              }
            }
          }
          Callback2 cb = new Callback2();
          cb.Parent = p;
          p.runOnUiThread(cb);
          loaded.acquireUninterruptibly();
          if (!Globals.CompatibilityHacksStaticInit)
            p.LoadApplicationLibrary(p);
        }

        if (!Settings.settingsChanged) {
          if (Globals.StartupMenuButtonTimeout > 0) {
            Log.i("SDL", "libSDL: " + String.valueOf(Globals.StartupMenuButtonTimeout) + "-msec timeout in startup screen");
            try {
              Thread.sleep(Globals.StartupMenuButtonTimeout);
            } catch (InterruptedException e) {
            }
            ;
          }
          if (Settings.settingsChanged)
            return;
        }
      }
    }
    ;
    (new Thread(new Callback(this))).start();
    // Request SD card permission right during start, because game devs don't care about runtime permissions and stuff
  }

  public void setUpStatusLabel() {
    MainActivity Parent = this; // Too lazy to rename
    if (Parent._btn != null) {
      Parent._layout2.removeView(Parent._btn);
      Parent._btn = null;
    }
    if (Parent._tv == null) {
      //Get the display so we can know the screen size
      Display display = getWindowManager().getDefaultDisplay();
      int width = display.getWidth();
      int height = display.getHeight();
      Parent._tv = new TextView(Parent);
      Parent._tv.setMaxLines(2); // To show some long texts on smaller devices
      Parent._tv.setMinLines(2); // Otherwise the background picture is getting resized at random, which does not look good
      Parent._tv.setText(R.string.init);
      // Padding is a good idea because if the display device is a TV the edges might be cut off
      Parent._tv.setPadding((int) (width * 0.1), (int) (height * 0.1), (int) (width * 0.1), 0);
      Parent._layout2.addView(Parent._tv);
    }
  }

  public void initSDL() {
    setScreenOrientation();
    updateScreenOrientation();
    DimSystemStatusBar.get().dim(_videoLayout);
    (new Thread(new Runnable() {
      public void run() {
        if (Globals.AutoDetectOrientation)
          Globals.HorizontalOrientation = isCurrentOrientationHorizontal();
        while (isCurrentOrientationHorizontal() != Globals.HorizontalOrientation ||
          ((KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE)).inKeyguardRestrictedInputMode()) {
          Log.d("SDL", "libSDL: Waiting for screen orientation to change to " + (Globals.HorizontalOrientation ? "landscape" : "portrait") + ", and for disabling lockscreen mode");
          try {
            Thread.sleep(500);
          } catch (Exception e) {
          }
          if (_isPaused) {
            Log.i("SDL", "libSDL: Application paused, cancelling SDL initialization until it will be brought to foreground");
            return;
          }
          DimSystemStatusBar.get().dim(_videoLayout);
        }
        runOnUiThread(new Runnable() {
          public void run() {
            // Hide navigation buttons, and sleep a bit so OS will process the event.
            // Do not check the display size in a loop - we may have several displays of different sizes,
            // so app may stuck in infinite loop
            DisplayMetrics dm = new DisplayMetrics();
            getWindowManager().getDefaultDisplay().getMetrics(dm);
            if (Globals.ImmersiveMode && (_videoLayout.getHeight() != dm.widthPixels || _videoLayout.getWidth() != dm.heightPixels)) {
              DimSystemStatusBar.get().dim(_videoLayout);
              try {
                Thread.sleep(300);
              } catch (Exception e) {
              }
            }
            initSDLInternal();
          }
        });
      }
    })).start();
  }

  private void initSDLInternal() {
    if (sdlInited)
      return;
    Log.i("SDL", "libSDL: Initializing video and SDL application");

    sdlInited = true;
    DimSystemStatusBar.get().dim(_videoLayout);
    _videoLayout.removeView(_layout);
    _layout = null;
    _layout2 = null;
    _btn = null;
    _tv = null;
    _inputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
    _videoLayout = new FrameLayout(this);
    SetLayerType.get().setLayerType(_videoLayout);
    setContentView(_videoLayout);
    mGLView = new NeoGLView(this);
    SetLayerType.get().setLayerType(mGLView);
    // Add TV screen borders, if needed
    if (isRunningOnOUYA() && Globals.TvBorders) {
      RelativeLayout view = new RelativeLayout(this);
      RelativeLayout.LayoutParams layout;

			/*
            layout = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);
			layout.addRule(RelativeLayout.ALIGN_PARENT_LEFT, RelativeLayout.TRUE);
			layout.addRule(RelativeLayout.ALIGN_PARENT_TOP, RelativeLayout.TRUE);
			mGLView.setLayoutParams(layout);
			view.addView(mGLView);
			*/

      layout = new RelativeLayout.LayoutParams(getResources().getDimensionPixelOffset(R.dimen.screen_border_horizontal), RelativeLayout.LayoutParams.MATCH_PARENT);
      layout.addRule(RelativeLayout.ALIGN_PARENT_LEFT, RelativeLayout.TRUE);
      layout.addRule(RelativeLayout.ALIGN_PARENT_TOP, RelativeLayout.TRUE);
      ImageView borderLeft = new ImageView(this);
      borderLeft.setId(R.id.left); // Any random ID
      borderLeft.setImageResource(R.drawable.tv_border_left);
      borderLeft.setScaleType(ImageView.ScaleType.FIT_XY);
      view.addView(borderLeft, layout);

      layout = new RelativeLayout.LayoutParams(getResources().getDimensionPixelOffset(R.dimen.screen_border_horizontal), RelativeLayout.LayoutParams.MATCH_PARENT);
      layout.addRule(RelativeLayout.ALIGN_PARENT_RIGHT, RelativeLayout.TRUE);
      layout.addRule(RelativeLayout.ALIGN_PARENT_TOP, RelativeLayout.TRUE);
      ImageView borderRight = new ImageView(this);
      borderRight.setId(R.id.right);
      borderRight.setImageResource(R.drawable.tv_border_left);
      borderRight.setScaleType(ImageView.ScaleType.FIT_XY);
      borderRight.setScaleX(-1f);
      view.addView(borderRight, layout);

      layout = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, getResources().getDimensionPixelOffset(R.dimen.screen_border_vertical));
      layout.addRule(RelativeLayout.ALIGN_PARENT_TOP, RelativeLayout.TRUE);
      layout.addRule(RelativeLayout.RIGHT_OF, borderLeft.getId());
      layout.addRule(RelativeLayout.LEFT_OF, borderRight.getId());
      ImageView borderTop = new ImageView(this);
      borderTop.setId(R.id.top);
      borderTop.setImageResource(R.drawable.tv_border_top);
      borderTop.setScaleType(ImageView.ScaleType.FIT_XY);
      view.addView(borderTop, layout);

      layout = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, getResources().getDimensionPixelOffset(R.dimen.screen_border_vertical));
      layout.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM, RelativeLayout.TRUE);
      layout.addRule(RelativeLayout.RIGHT_OF, borderLeft.getId());
      layout.addRule(RelativeLayout.LEFT_OF, borderRight.getId());
      ImageView borderBottom = new ImageView(this);
      borderBottom.setId(R.id.bottom);
      borderBottom.setImageResource(R.drawable.tv_border_top);
      borderBottom.setScaleType(ImageView.ScaleType.FIT_XY);
      borderBottom.setScaleY(-1f);
      view.addView(borderBottom, layout);

      layout = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);
      layout.addRule(RelativeLayout.RIGHT_OF, borderLeft.getId());
      layout.addRule(RelativeLayout.LEFT_OF, borderRight.getId());
      layout.addRule(RelativeLayout.BELOW, borderTop.getId());
      layout.addRule(RelativeLayout.ABOVE, borderBottom.getId());
      mGLView.setLayoutParams(layout);

      view.addView(mGLView);

      _videoLayout.addView(view, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));
    } else {
      _videoLayout.addView(mGLView, new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));
    }
    mGLView.setFocusableInTouchMode(true);
    mGLView.setFocusable(true);
    mGLView.requestFocus();
    if (Globals.HideSystemMousePointer && android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
      mGLView.setPointerIcon(android.view.PointerIcon.getSystemIcon(this, android.view.PointerIcon.TYPE_NULL));
    }

    DimSystemStatusBar.get().dim(_videoLayout);
    //DimSystemStatusBar.get().dim(mGLView);

    Rect r = new Rect();
    _videoLayout.getWindowVisibleDisplayFrame(r);
    mGLView.nativeScreenVisibleRect(r.left, r.top, r.right, r.bottom);
    _videoLayout.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
      public void onGlobalLayout() {
        final Rect r = new Rect();
        _videoLayout.getWindowVisibleDisplayFrame(r);
        final int heightDiff = _videoLayout.getRootView().getHeight() - _videoLayout.getHeight(); // Take system bar into consideration
        final int widthDiff = _videoLayout.getRootView().getWidth() - _videoLayout.getWidth(); // Nexus 5 has system bar at the right side
        Log.v("SDL", "Main window visible region changed: " + r.left + ":" + r.top + ":" + r.width() + ":" + r.height());
        _videoLayout.postDelayed(new Runnable() {
          public void run() {
            DimSystemStatusBar.get().dim(_videoLayout);
            mGLView.nativeScreenVisibleRect(r.left + widthDiff, r.top + heightDiff, r.width(), r.height());
          }
        }, 300);
        _videoLayout.postDelayed(new Runnable() {
          public void run() {
            DimSystemStatusBar.get().dim(_videoLayout);
            mGLView.nativeScreenVisibleRect(r.left + widthDiff, r.top + heightDiff, r.width(), r.height());
          }
        }, 600);
      }
    });
  }

  @Override
  protected void onPause() {
    _isPaused = true;
    if (mGLView != null)
      mGLView.onPause();
    //if( _ad.getView() != null )
    //	_ad.getView().onPause();
    super.onPause();
  }

  @Override
  protected void onResume() {
    super.onResume();
    if (mGLView != null) {
      DimSystemStatusBar.get().dim(_videoLayout);
      //DimSystemStatusBar.get().dim(mGLView);
      mGLView.onResume();
    }
    //if( _ad.getView() != null )
    //	_ad.getView().onResume();
    _isPaused = false;
    // Nvidia is too smart to use Samsung's stylus API, obviously they need their own method to enable hover events
    Intent i = new Intent("com.nvidia.intent.action.ENABLE_STYLUS");
    i.putExtra("package", getPackageName());
    sendBroadcast(i);
  }

  @Override
  public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    Log.i("SDL", "libSDL: onWindowFocusChanged: " + hasFocus + " - sending onPause/onResume");
    if (!hasFocus)
      onPause();
    else
      onResume();
  }

  public boolean isPaused() {
    return _isPaused;
  }

  @Override
  protected void onDestroy() {
    if (mGLView != null)
      mGLView.exitApp();
    super.onDestroy();
    try {
      Thread.sleep(2000); // The event is sent asynchronously, allow app to save it's state, and call exit() itself.
    } catch (InterruptedException e) {
    }
    System.exit(0);
  }

  @Override
  protected void onStart() {
    super.onStart();
  }

  @Override
  protected void onStop() {
    super.onStop();
  }

  @Override
  public void onActivityResult(int request, int response, Intent data) {
    super.onActivityResult(request, response, data);
  }

  private int TextInputKeyboardList[][] =
    {
      {0, R.xml.qwerty, R.xml.c64, R.xml.amiga, R.xml.atari800},
      {0, R.xml.qwerty_shift, R.xml.c64, R.xml.amiga_shift, R.xml.atari800},
      {0, R.xml.qwerty_alt, R.xml.c64, R.xml.amiga_alt, R.xml.atari800},
      {0, R.xml.qwerty_alt_shift, R.xml.c64, R.xml.amiga_alt_shift, R.xml.atari800}
    };

  @Override
  public Context getContext() {
    return this;
  }

  @Override
  public boolean isKeyboardWithoutTextInputShown() {
    return keyboardWithoutTextInputShown;
  }

  public void showScreenKeyboardWithoutTextInputField(final int keyboard) {
    if (!isKeyboardWithoutTextInputShown()) {
      keyboardWithoutTextInputShown = true;
      runOnUiThread(new Runnable() {
        public void run() {
          if (keyboard == 0) {
            _inputManager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);
            _inputManager.showSoftInput(mGLView, InputMethodManager.SHOW_FORCED);
            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
          } else {
            if (_screenKeyboard != null)
              return;
            class BuiltInKeyboardView extends KeyboardView {
              public boolean shift = false;
              public boolean alt = false;
              public TreeSet<Integer> stickyKeys = new TreeSet<Integer>();

              public BuiltInKeyboardView(Context context, android.util.AttributeSet attrs) {
                super(context, attrs);
              }

              public boolean dispatchTouchEvent(final MotionEvent ev) {
                if (ev.getY() < getTop())
                  return false;
                if (ev.getAction() == MotionEvent.ACTION_DOWN || ev.getAction() == MotionEvent.ACTION_UP || ev.getAction() == MotionEvent.ACTION_MOVE) {
                  // Convert pointer coords, this will lose multitiouch data, however KeyboardView does not support multitouch anyway
                  MotionEvent converted = MotionEvent.obtain(ev.getDownTime(), ev.getEventTime(), ev.getAction(), ev.getX(), ev.getY() - (float) getTop(), ev.getMetaState());
                  return super.dispatchTouchEvent(converted);
                }
                return false;
              }

              public boolean onKeyDown(int key, final KeyEvent event) {
                return false;
              }

              public boolean onKeyUp(int key, final KeyEvent event) {
                return false;
              }

              public void ChangeKeyboard() {
                int idx = (shift ? 1 : 0) + (alt ? 2 : 0);
                setKeyboard(new Keyboard(MainActivity.this, TextInputKeyboardList[idx][keyboard]));
                setPreviewEnabled(false);
                setProximityCorrectionEnabled(false);
                for (Keyboard.Key k : getKeyboard().getKeys()) {
                  if (stickyKeys.contains(k.codes[0])) {
                    k.on = true;
                    invalidateAllKeys();
                  }
                }
              }
            }
            final BuiltInKeyboardView builtinKeyboard = new BuiltInKeyboardView(MainActivity.this, null);
            builtinKeyboard.setAlpha(0.7f);
            builtinKeyboard.ChangeKeyboard();
            builtinKeyboard.setOnKeyboardActionListener(new KeyboardView.OnKeyboardActionListener() {
              public void onPress(int key) {
                if (key == KeyEvent.KEYCODE_BACK)
                  return;
                if (key < 0)
                  return;
                for (Keyboard.Key k : builtinKeyboard.getKeyboard().getKeys()) {
                  if (k.sticky && key == k.codes[0])
                    return;
                }
                if (key > 100000) {
                  key -= 100000;
                  MainActivity.this.onKeyDown(KeyEvent.KEYCODE_SHIFT_LEFT, new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT));
                }
                MainActivity.this.onKeyDown(key, new KeyEvent(KeyEvent.ACTION_DOWN, key));
              }

              public void onRelease(int key) {
                if (key == KeyEvent.KEYCODE_BACK) {
                  builtinKeyboard.setOnKeyboardActionListener(null);
                  showScreenKeyboardWithoutTextInputField(0); // Hide keyboard
                  return;
                }
                if (key == Keyboard.KEYCODE_SHIFT) {
                  builtinKeyboard.shift = !builtinKeyboard.shift;
                  if (builtinKeyboard.shift && !builtinKeyboard.alt)
                    MainActivity.this.onKeyDown(KeyEvent.KEYCODE_SHIFT_LEFT, new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT));
                  else
                    MainActivity.this.onKeyUp(KeyEvent.KEYCODE_SHIFT_LEFT, new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT));
                  builtinKeyboard.ChangeKeyboard();
                  return;
                }
                if (key == Keyboard.KEYCODE_ALT) {
                  builtinKeyboard.alt = !builtinKeyboard.alt;
                  if (builtinKeyboard.alt)
                    MainActivity.this.onKeyUp(KeyEvent.KEYCODE_SHIFT_LEFT, new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT));
                  else
                    builtinKeyboard.shift = false;
                  builtinKeyboard.ChangeKeyboard();
                  return;
                }
                if (key < 0)
                  return;
                for (Keyboard.Key k : builtinKeyboard.getKeyboard().getKeys()) {
                  if (k.sticky && key == k.codes[0]) {
                    if (k.on) {
                      builtinKeyboard.stickyKeys.add(key);
                      MainActivity.this.onKeyDown(key, new KeyEvent(KeyEvent.ACTION_DOWN, key));
                    } else {
                      builtinKeyboard.stickyKeys.remove(key);
                      MainActivity.this.onKeyUp(key, new KeyEvent(KeyEvent.ACTION_UP, key));
                    }
                    return;
                  }
                }

                boolean shifted = false;
                if (key > 100000) {
                  key -= 100000;
                  shifted = true;
                }

                MainActivity.this.onKeyUp(key, new KeyEvent(KeyEvent.ACTION_UP, key));

                if (shifted) {
                  MainActivity.this.onKeyUp(KeyEvent.KEYCODE_SHIFT_LEFT, new KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT));
                  builtinKeyboard.stickyKeys.remove(KeyEvent.KEYCODE_SHIFT_LEFT);
                  for (Keyboard.Key k : builtinKeyboard.getKeyboard().getKeys()) {
                    if (k.sticky && k.codes[0] == KeyEvent.KEYCODE_SHIFT_LEFT && k.on) {
                      k.on = false;
                      builtinKeyboard.invalidateAllKeys();
                    }
                  }
                }
              }

              public void onText(CharSequence p1) {
              }

              public void swipeLeft() {
              }

              public void swipeRight() {
              }

              public void swipeDown() {
              }

              public void swipeUp() {
              }

              public void onKey(int p1, int[] p2) {
              }
            });
            _screenKeyboard = builtinKeyboard;
            FrameLayout.LayoutParams layout = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.BOTTOM);
            _videoLayout.addView(_screenKeyboard, layout);
          }
        }
      });
    } else {
      keyboardWithoutTextInputShown = false;
      runOnUiThread(new Runnable() {
        public void run() {
          if (_screenKeyboard != null) {
            _videoLayout.removeView(_screenKeyboard);
            _screenKeyboard = null;
          }
          getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
          _inputManager.hideSoftInputFromWindow(mGLView.getWindowToken(), 0);
          DimSystemStatusBar.get().dim(_videoLayout);
          //DimSystemStatusBar.get().dim(mGLView);
        }
      });
    }
    mGLView.nativeScreenKeyboardShown(keyboardWithoutTextInputShown ? 1 : 0);
  }

  public void showScreenKeyboard(final String oldText) {
    if (Globals.CompatibilityHacksTextInputEmulatesHwKeyboard) {
      showScreenKeyboardWithoutTextInputField(Globals.TextInputKeyboard);
      return;
    }
    if (_screenKeyboard != null)
      return;
    class simpleKeyListener implements OnKeyListener {
      MainActivity _parent;

      simpleKeyListener(MainActivity parent) {
        _parent = parent;
      }

      ;

      public boolean onKey(View v, int keyCode, KeyEvent event) {
        if ((event.getAction() == KeyEvent.ACTION_UP) && (
          keyCode == KeyEvent.KEYCODE_ENTER ||
            keyCode == KeyEvent.KEYCODE_BACK ||
            keyCode == KeyEvent.KEYCODE_MENU ||
            keyCode == KeyEvent.KEYCODE_BUTTON_A ||
            keyCode == KeyEvent.KEYCODE_BUTTON_B ||
            keyCode == KeyEvent.KEYCODE_BUTTON_X ||
            keyCode == KeyEvent.KEYCODE_BUTTON_Y ||
            keyCode == KeyEvent.KEYCODE_BUTTON_1 ||
            keyCode == KeyEvent.KEYCODE_BUTTON_2 ||
            keyCode == KeyEvent.KEYCODE_BUTTON_3 ||
            keyCode == KeyEvent.KEYCODE_BUTTON_4)) {
          _parent.hideScreenKeyboard();
          return true;
        }
                /*
                if (keyCode == KeyEvent.KEYCODE_DEL || keyCode == KeyEvent.KEYCODE_CLEAR)
				{
					// EditText deletes two characters at a time, here's a hacky fix
					if (event.getAction() == KeyEvent.ACTION_DOWN && (event.getFlags() | KeyEvent.FLAG_SOFT_KEYBOARD) != 0)
					{
						EditText t = (EditText) v;
						int start = t.getSelectionStart();  //get cursor starting position
						int end = t.getSelectionEnd();      //get cursor ending position
						if ( start < 0 )
							return false;
						if ( end < 0 || end == start )
						{
							start --;
							if ( start < 0 )
								return false;
							end = start + 1;
						}
						t.setText(t.getText().toString().substring(0, start) + t.getText().toString().substring(end));
						t.setSelection(start);
						return true;
					}
				}
				*/
        //Log.i("SDL", "Key " + keyCode + " flags " + event.getFlags() + " action " + event.getAction());
        return false;
      }
    }
    ;
    EditText screenKeyboard = new EditText(this, null,
      android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.LOLLIPOP ? android.R.style.TextAppearance_Material_Widget_EditText : android.R.style.TextAppearance_Widget_EditText);
    String hint = _screenKeyboardHintMessage;
    screenKeyboard.setHint(hint != null ? hint : getString(R.string.text_edit_click_here));
    screenKeyboard.setText(oldText);
    screenKeyboard.setSelection(screenKeyboard.getText().length());
    screenKeyboard.setOnKeyListener(new simpleKeyListener(this));
    screenKeyboard.setBackgroundColor(this.getResources().getColor(android.R.color.primary_text_light));
    screenKeyboard.setTextColor(this.getResources().getColor(android.R.color.background_light));
    if (isRunningOnOUYA() && Globals.TvBorders)
      screenKeyboard.setPadding(100, 100, 100, 100); // Bad bad HDMI TVs all have cropped borders
    _screenKeyboard = screenKeyboard;
    _videoLayout.addView(_screenKeyboard);
    //_screenKeyboard.setKeyListener(new TextKeyListener(TextKeyListener.Capitalize.NONE, false));
    screenKeyboard.setInputType(InputType.TYPE_CLASS_TEXT);
    screenKeyboard.setFocusableInTouchMode(true);
    screenKeyboard.setFocusable(true);
    //_inputManager.showSoftInput(screenKeyboard, InputMethodManager.SHOW_IMPLICIT);
    //getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE);
    // Hack to try to force on-screen keyboard
    final EditText keyboard = screenKeyboard;
    keyboard.postDelayed(new Runnable() {
      public void run() {
        keyboard.requestFocus();
        //_inputManager.showSoftInput(keyboard, InputMethodManager.SHOW_FORCED);
        // Hack from Stackoverflow, to force text input on Ouya
        keyboard.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, 0, 0, 0));
        keyboard.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(), SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, 0, 0, 0));
        keyboard.postDelayed(new Runnable() {
          public void run() {
            keyboard.requestFocus();
            keyboard.setSelection(keyboard.getText().length());
          }
        }, 100);
      }
    }, 300);
  }

  ;

  public void hideScreenKeyboard() {
    if (keyboardWithoutTextInputShown)
      showScreenKeyboardWithoutTextInputField(Globals.TextInputKeyboard);

    if (_screenKeyboard == null || !(_screenKeyboard instanceof EditText))
      return;

    synchronized (textInput) {
      String text = ((EditText) _screenKeyboard).getText().toString();
      for (int i = 0; i < text.length(); i++) {
        DemoRenderer.nativeTextInput((int) text.charAt(i), (int) text.codePointAt(i));
      }
    }
    DemoRenderer.nativeTextInputFinished();
    _inputManager.hideSoftInputFromWindow(_screenKeyboard.getWindowToken(), 0);
    _videoLayout.removeView(_screenKeyboard);
    _screenKeyboard = null;
    mGLView.setFocusableInTouchMode(true);
    mGLView.setFocusable(true);
    mGLView.requestFocus();
    DimSystemStatusBar.get().dim(_videoLayout);

    _videoLayout.postDelayed(new Runnable() {
      public void run() {
        DimSystemStatusBar.get().dim(_videoLayout);
      }
    }, 500);
  }

  ;

  public boolean isScreenKeyboardShown() {
    return _screenKeyboard != null;
  }

  ;

  public void setScreenKeyboardHintMessage(String s) {
    _screenKeyboardHintMessage = s;
    //Log.i("SDL", "setScreenKeyboardHintMessage: " + (_screenKeyboardHintMessage != null ? _screenKeyboardHintMessage : getString(R.string.text_edit_click_here)));
    runOnUiThread(new Runnable() {
      public void run() {
        if (_screenKeyboard != null && _screenKeyboard instanceof EditText) {
          String hint = _screenKeyboardHintMessage;
          ((EditText) _screenKeyboard).setHint(hint != null ? hint : getString(R.string.text_edit_click_here));
        }
      }
    });
  }

  final static int ADVERTISEMENT_POSITION_RIGHT = -1;
  final static int ADVERTISEMENT_POSITION_BOTTOM = -1;
  final static int ADVERTISEMENT_POSITION_CENTER = -2;

	/*
	@Override
	public boolean onKeyDown(int keyCode, final KeyEvent event)
	{
		if( keyCode == KeyEvent.KEYCODE_BACK )
		{
			if( (event.getSource() & InputDevice.SOURCE_MOUSE) == InputDevice.SOURCE_MOUSE )
			{
				// Stupid Samsung and stupid Acer remaps right mouse button to BACK key
				DemoGLSurfaceView.nativeMouseButtonsPressed(2, 1);
				return true;
			}
			else if( keyboardWithoutTextInputShown )
			{
				return true;
			}
		}
		if( _screenKeyboard != null && _screenKeyboard.onKeyDown(keyCode, event) )
			return true;

		if( mGLView != null )
		{
			if( mGLView.nativeKey( keyCode, 1, event.getUnicodeChar() ) == 0 )
				return super.onKeyDown(keyCode, event);
		}
		else
		if( keyListener != null )
		{
			keyListener.onKeyEvent(keyCode);
		}
		else
		if( _btn != null )
			return _btn.onKeyDown(keyCode, event);
		return true;
	}
	
	@Override
	public boolean onKeyUp(int keyCode, final KeyEvent event)
	{
		if( keyCode == KeyEvent.KEYCODE_BACK )
		{
			if( (event.getSource() & InputDevice.SOURCE_MOUSE) == InputDevice.SOURCE_MOUSE )
			{
				// Stupid Samsung and stupid Acer remaps right mouse button to BACK key
				DemoGLSurfaceView.nativeMouseButtonsPressed(2, 0);
				return true;
			}
			else if( keyboardWithoutTextInputShown )
			{
				showScreenKeyboardWithoutTextInputField(0); // Hide keyboard
				return true;
			}
		}
		if( _screenKeyboard != null && _screenKeyboard.onKeyUp(keyCode, event) )
			return true;

		if( mGLView != null )
		{
			if( mGLView.nativeKey( keyCode, 0, event.getUnicodeChar() ) == 0 )
				return super.onKeyUp(keyCode, event);
			if( keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU )
			{
				DimSystemStatusBar.get().dim(_videoLayout);
				//DimSystemStatusBar.get().dim(mGLView);
			}
		}
		else
		if( _btn != null )
			return _btn.onKeyUp(keyCode, event);
		return true;
	}
	*/

  //private Configuration oldConfig = null;
  @Override
  public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);
    updateScreenOrientation();
  }

  public void updateScreenOrientation() {
    int rotation = Surface.ROTATION_0;
    rotation = getWindowManager().getDefaultDisplay().getRotation();
    AccelerometerReader.gyro.invertedOrientation = (rotation == Surface.ROTATION_180 || rotation == Surface.ROTATION_270);
    //Log.d("SDL", "updateScreenOrientation(): screen orientation: " + rotation + " inverted " + AccelerometerReader.gyro.invertedOrientation);
  }

  @Override
  public void initScreenOrientation() {
    setScreenOrientation();
  }

  public void setText(final String t) {
    class Callback implements Runnable {
      MainActivity Parent;
      public SpannedString text;

      public void run() {
        Parent.setUpStatusLabel();
        if (Parent._tv != null)
          Parent._tv.setText(text);
      }
    }
    Callback cb = new Callback();
    cb.text = new SpannedString(t);
    cb.Parent = this;
    this.runOnUiThread(cb);
  }

  @Override
  public void onNewIntent(Intent i) {
    Log.i("SDL", "onNewIntent(): " + i.toString());
    super.onNewIntent(i);
    setIntent(i);
  }

  @SuppressLint("UnsafeDynamicallyLoadedCode")
  public void LoadLibraries() {
    try {
      if (Globals.NeedGles3) {
        System.loadLibrary("GLESv3");
        Log.i("SDL", "libSDL: loaded GLESv3 lib");
      } else if (Globals.NeedGles2) {
        System.loadLibrary("GLESv2");
        Log.i("SDL", "libSDL: loaded GLESv2 lib");
      }
    } catch (UnsatisfiedLinkError e) {
      Log.i("SDL", "libSDL: Cannot load GLESv3 or GLESv2 lib");
    }

    // Load all libraries
    try {
      for (String libname : Globals.XLIBS) {
        String soPath = Globals.XLIB_DIR + libname;
        Log.i("SDL", "libSDL: loading lib " + soPath);
        try {
          System.load(soPath);
        } catch (UnsatisfiedLinkError error) {
          Log.i("SDL", "libSDL: error loading lib " + soPath
            + ", reason: " + error.getLocalizedMessage());
        }
      }
    } catch (UnsatisfiedLinkError ignore) {
    }
  }

  @SuppressLint("UnsafeDynamicallyLoadedCode")
  public static void LoadApplicationLibrary(final Context context) {
    Settings.nativeChdir(Globals.DataDir);
    try {
      for (String libname : Globals.XAPP_LIBS) {
        String soPath = Globals.XLIB_DIR + libname;
        Log.i("SDL", "libSDL: loading lib " + soPath);
        try {
          System.load(soPath);
        } catch (UnsatisfiedLinkError error) {
          Log.i("SDL", "libSDL: error loading lib " + soPath
            + ", reason: " + error.getLocalizedMessage());
        }
      }
    } catch (UnsatisfiedLinkError ignore) {
    }
    Log.v("SDL", "libSDL: loaded all libraries");
    ApplicationLibraryLoaded = true;
  }

  public int getApplicationVersion() {
    try {
      PackageInfo packageInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
      return packageInfo.versionCode;
    } catch (PackageManager.NameNotFoundException e) {
      Log.i("SDL", "libSDL: Cannot get the version of our own package: " + e);
    }
    return 0;
  }

  public boolean isRunningOnOUYA() {
    try {
      PackageInfo packageInfo = getPackageManager().getPackageInfo("tv.ouya", 0);
      return true;
    } catch (PackageManager.NameNotFoundException e) {
    }
    UiModeManager uiModeManager = (UiModeManager) getSystemService(UI_MODE_SERVICE);
    return (uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION) || Globals.OuyaEmulation;
  }

  @Override
  public NeoGLView getGLView() {
    return mGLView;
  }

  public boolean isCurrentOrientationHorizontal() {
    if (Globals.AutoDetectOrientation) {
      // Less reliable way to detect orientation, but works with multiwindow
      View topView = getWindow().peekDecorView();
      if (topView != null) {
        //Log.d("SDL", "isCurrentOrientationHorizontal(): decorview: " + topView.getWidth() + "x" + topView.getHeight());
        return topView.getWidth() >= topView.getHeight();
      }
    }
    Display getOrient = getWindowManager().getDefaultDisplay();
    return getOrient.getWidth() >= getOrient.getHeight();
  }

  void setScreenOrientation() {
    Globals.AutoDetectOrientation = true;
    if (Globals.AutoDetectOrientation) {
      setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_FULL_USER);
      return;
    }
    setRequestedOrientation(Globals.HorizontalOrientation ? ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE : ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT);
  }

  @Override
  public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
    if (permissions.length == 0 || grantResults.length == 0) {
      Log.i("SDL", "libSDL: Permission request dialog was aborted");
      return;
    }
    if (Manifest.permission.RECORD_AUDIO.equals(permissions[0])) {
      Log.i("SDL", "libSDL: Record audio permission: " + (grantResults[0] == PackageManager.PERMISSION_GRANTED ? "GRANTED" : "DENIED"));
    }
    if (Manifest.permission.WRITE_EXTERNAL_STORAGE.equals(permissions[0])) {
      Log.i("SDL", "libSDL: Write external storage permission: " + (grantResults[0] == PackageManager.PERMISSION_GRANTED ? "GRANTED" : "DENIED"));
      writeExternalStoragePermissionDialogAnswered = true;
    }
  }

  public void setSystemMousePointerVisible(int visible) {
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
      mGLView.setPointerIcon(android.view.PointerIcon.getSystemIcon(this, (visible == 0) ? android.view.PointerIcon.TYPE_NULL : android.view.PointerIcon.TYPE_DEFAULT));
    }
  }

  public FrameLayout getVideoLayout() {
    return _videoLayout;
  }

  NeoGLView mGLView = null;
  private static AudioThread mAudioThread = null;

  private TextView _tv = null;
  private Button _btn = null;
  private LinearLayout _layout = null;
  private LinearLayout _layout2 = null;
  public ProgressDialog loadingDialog = null;

  FrameLayout _videoLayout = null;
  private View _screenKeyboard = null;
  private String _screenKeyboardHintMessage = null;
  static boolean keyboardWithoutTextInputShown = false;
  private boolean sdlInited = false;
  public static boolean ApplicationLibraryLoaded = false;

  boolean _isPaused = false;
  private InputMethodManager _inputManager = null;

  public LinkedList<Integer> textInput = new LinkedList<Integer>();
  public static MainActivity instance = null;
  public boolean writeExternalStoragePermissionDialogAnswered = false;
}

// *** HONEYCOMB / ICS FIX FOR FULLSCREEN MODE, by lmak ***
abstract class DimSystemStatusBar {
  public static DimSystemStatusBar get() {
    return DimSystemStatusBarHoneycomb.Holder.sInstance;
  }

  public abstract void dim(final View view);

  private static class DimSystemStatusBarHoneycomb extends DimSystemStatusBar {
    private static class Holder {
      private static final DimSystemStatusBarHoneycomb sInstance = new DimSystemStatusBarHoneycomb();
    }

    public void dim(final View view) {
      if (Globals.ImmersiveMode)
        // Immersive mode, I already hear curses when system bar reappears mid-game from the slightest swipe at the bottom of the screen
        view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION | View.SYSTEM_UI_FLAG_FULLSCREEN);
      else
        view.setSystemUiVisibility(View.SYSTEM_UI_FLAG_LOW_PROFILE);
    }
  }
}

abstract class SetLayerType {
  public static SetLayerType get() {
    return SetLayerTypeHoneycomb.Holder.sInstance;
  }

  public abstract void setLayerType(final View view);

  private static class SetLayerTypeHoneycomb extends SetLayerType {
    private static class Holder {
      private static final SetLayerTypeHoneycomb sInstance = new SetLayerTypeHoneycomb();
    }

    public void setLayerType(final View view) {
      view.setLayerType(View.LAYER_TYPE_NONE, null);
      //view.setLayerType(android.view.View.LAYER_TYPE_HARDWARE, null);
    }
  }
}

```

`Xorg/src/main/java/io/neoterm/NeoAccelerometerReader.java`:

```java
package io.neoterm;

import android.content.Context;

/**
 * @author kiva
 */

public class NeoAccelerometerReader extends AccelerometerReader {
  public NeoAccelerometerReader(Context context) {
    super(context);
  }

  public static void setGyroInvertedOrientation(boolean invertedOrientation) {
    gyro.invertedOrientation = invertedOrientation;
  }
}

```

`Xorg/src/main/java/io/neoterm/NeoAudioThread.java`:

```java
package io.neoterm;

import io.neoterm.xorg.NeoXorgViewClient;

/**
 * @author kiva
 */

public class NeoAudioThread extends AudioThread {
  public NeoAudioThread(NeoXorgViewClient client) {
    super(client);
  }
}

```

`Xorg/src/main/java/io/neoterm/NeoGLView.java`:

```java
package io.neoterm;

import io.neoterm.xorg.NeoXorgViewClient;

/**
 * @author kiva
 */

public class NeoGLView extends DemoGLSurfaceView {
  public NeoGLView(NeoXorgViewClient client) {
    super(client);
  }

  public void callNativeScreenKeyboardShown(int shown) {
    nativeScreenKeyboardShown(shown);
  }

  public void callNativeScreenVisibleRect(int x, int y, int w, int h) {
    nativeScreenVisibleRect(x, y, w, h);
  }
}

```

`Xorg/src/main/java/io/neoterm/NeoRenderer.java`:

```java
package io.neoterm;

/**
 * @author kiva
 */

public class NeoRenderer {
  public static void callNativeTextInputFinished() {
    DemoRenderer.nativeTextInputFinished();
  }

  public static void callNativeTextInput(int ascii, int unicode) {
    DemoRenderer.nativeTextInput(ascii, unicode);
  }
}

```

`Xorg/src/main/java/io/neoterm/NeoTextInput.java`:

```java
package io.neoterm;

import io.neoterm.xorg.R;

/**
 * @author kiva
 */

public class NeoTextInput {
  public static int TextInputKeyboardList[][] =
    {
      {0, R.xml.qwerty, R.xml.c64, R.xml.amiga, R.xml.atari800},
      {0, R.xml.qwerty_shift, R.xml.c64, R.xml.amiga_shift, R.xml.atari800},
      {0, R.xml.qwerty_alt, R.xml.c64, R.xml.amiga_alt, R.xml.atari800},
      {0, R.xml.qwerty_alt_shift, R.xml.c64, R.xml.amiga_alt_shift, R.xml.atari800}
    };
}

```

`Xorg/src/main/java/io/neoterm/NeoXorgSettings.java`:

```java
package io.neoterm;

import io.neoterm.xorg.NeoXorgViewClient;

/**
 * @author kiva
 */

public class NeoXorgSettings {
  public static void init(NeoXorgViewClient client) {
    Settings.Load(client);
  }
}

```

`Xorg/src/main/java/io/neoterm/Settings.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.Context;
import android.os.Build;
import android.os.Environment;
import android.os.StatFs;
import android.util.DisplayMetrics;
import android.util.Log;
import io.neoterm.xorg.NeoXorgViewClient;
import io.neoterm.xorg.R;

import java.io.*;
import java.util.ArrayList;
import java.util.Locale;
import java.util.zip.GZIPInputStream;


// TODO: too much code here, split into multiple files, possibly auto-generated menus?
@SuppressWarnings("JniMissingFunction")
public class Settings {
  static String SettingsFileName = "libsdl-settings.cfg";

  static boolean settingsLoaded = false;
  static boolean settingsChanged = false;
  static final int SETTINGS_FILE_VERSION = 5;
  static boolean convertButtonSizeFromOldSdlVersion = false;

  static void Save(final NeoXorgViewClient p) {
    try {
      ObjectOutputStream out = new ObjectOutputStream(p.getContext().openFileOutput(SettingsFileName, Context.MODE_PRIVATE));
      out.writeInt(SETTINGS_FILE_VERSION);
      out.writeBoolean(Globals.DownloadToSdcard);
      out.writeBoolean(Globals.PhoneHasArrowKeys);
      out.writeBoolean(false);
      out.writeBoolean(Globals.UseAccelerometerAsArrowKeys);
      out.writeBoolean(Globals.UseTouchscreenKeyboard);
      out.writeInt(Globals.TouchscreenKeyboardSize);
      out.writeInt(Globals.AccelerometerSensitivity);
      out.writeInt(Globals.AccelerometerCenterPos);
      out.writeInt(0);
      out.writeInt(Globals.AudioBufferConfig);
      out.writeInt(Globals.TouchscreenKeyboardTheme);
      out.writeInt(Globals.RightClickMethod);
      out.writeInt(Globals.ShowScreenUnderFinger);
      out.writeInt(Globals.LeftClickMethod);
      out.writeBoolean(Globals.MoveMouseWithJoystick);
      out.writeBoolean(Globals.ClickMouseWithDpad);
      out.writeInt(Globals.ClickScreenPressure);
      out.writeInt(Globals.ClickScreenTouchspotSize);
      out.writeBoolean(Globals.KeepAspectRatio);
      out.writeInt(Globals.MoveMouseWithJoystickSpeed);
      out.writeInt(Globals.MoveMouseWithJoystickAccel);
      out.writeInt(SDL_Keys.JAVA_KEYCODE_LAST);
      for (int i = 0; i < SDL_Keys.JAVA_KEYCODE_LAST; i++) {
        out.writeInt(Globals.RemapHwKeycode[i]);
      }
      out.writeInt(Globals.RemapScreenKbKeycode.length);
      for (int i = 0; i < Globals.RemapScreenKbKeycode.length; i++) {
        out.writeInt(Globals.RemapScreenKbKeycode[i]);
      }
      out.writeInt(Globals.ScreenKbControlsShown.length);
      for (int i = 0; i < Globals.ScreenKbControlsShown.length; i++) {
        out.writeBoolean(Globals.ScreenKbControlsShown[i]);
      }
      out.writeInt(Globals.TouchscreenKeyboardTransparency);
      out.writeInt(Globals.RemapMultitouchGestureKeycode.length);
      for (int i = 0; i < Globals.RemapMultitouchGestureKeycode.length; i++) {
        out.writeInt(Globals.RemapMultitouchGestureKeycode[i]);
        out.writeBoolean(Globals.MultitouchGesturesUsed[i]);
      }
      out.writeInt(Globals.MultitouchGestureSensitivity);
      for (int i = 0; i < Globals.TouchscreenCalibration.length; i++)
        out.writeInt(Globals.TouchscreenCalibration[i]);
      out.writeInt(Globals.DataDir.length());
      for (int i = 0; i < Globals.DataDir.length(); i++)
        out.writeChar(Globals.DataDir.charAt(i));
      out.writeInt(Globals.CommandLine.length());
      for (int i = 0; i < Globals.CommandLine.length(); i++)
        out.writeChar(Globals.CommandLine.charAt(i));
      out.writeInt(Globals.ScreenKbControlsLayout.length);
      for (int i = 0; i < Globals.ScreenKbControlsLayout.length; i++)
        for (int ii = 0; ii < 4; ii++)
          out.writeInt(Globals.ScreenKbControlsLayout[i][ii]);
      out.writeInt(Globals.LeftClickKey);
      out.writeInt(Globals.RightClickKey);
      out.writeBoolean(Globals.VideoLinearFilter);
      out.writeInt(Globals.LeftClickTimeout);
      out.writeInt(Globals.RightClickTimeout);
      out.writeBoolean(Globals.RelativeMouseMovement);
      out.writeInt(Globals.RelativeMouseMovementSpeed);
      out.writeInt(Globals.RelativeMouseMovementAccel);
      out.writeBoolean(Globals.MultiThreadedVideo);

      out.writeInt(Globals.OptionalDataDownload.length);
      for (int i = 0; i < Globals.OptionalDataDownload.length; i++)
        out.writeBoolean(Globals.OptionalDataDownload[i]);
      out.writeBoolean(false); // Unused
      out.writeInt(Globals.TouchscreenKeyboardDrawSize);
      // Gyroscope calibration data, now unused
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);
      out.writeFloat(0.0f);

      out.writeBoolean(Globals.OuyaEmulation);
      out.writeBoolean(Globals.HoverJitterFilter);
      out.writeBoolean(Globals.MoveMouseWithGyroscope);
      out.writeInt(Globals.MoveMouseWithGyroscopeSpeed);
      out.writeBoolean(Globals.FingerHover);
      out.writeBoolean(Globals.FloatingScreenJoystick);
      out.writeBoolean(Globals.GenerateSubframeTouchEvents);
      out.writeInt(Globals.VideoDepthBpp);
      out.writeBoolean(Globals.HorizontalOrientation);
      out.writeBoolean(Globals.ImmersiveMode);
      out.writeBoolean(Globals.AutoDetectOrientation);
      out.writeBoolean(Globals.TvBorders);
      out.writeBoolean(Globals.ForceHardwareMouse);

      out.close();
      settingsLoaded = true;

    } catch (FileNotFoundException e) {
    } catch (SecurityException e) {
    } catch (IOException e) {
    }
    ;
  }

  static void Load(final NeoXorgViewClient p) {
    if (settingsLoaded) // Prevent starting twice
    {
      return;
    }
    Log.i("SDL", "libSDL: Settings.Load(): enter");
    nativeInitKeymap();
    for (int i = 0; i < SDL_Keys.JAVA_KEYCODE_LAST; i++) {
      int sdlKey = nativeGetKeymapKey(i);
      int idx = 0;
      for (int ii = 0; ii < SDL_Keys.values.length; ii++)
        if (SDL_Keys.values[ii] == sdlKey)
          idx = ii;
      Globals.RemapHwKeycode[i] = idx;
    }
    for (int i = 0; i < Globals.RemapScreenKbKeycode.length; i++) {
      int sdlKey = nativeGetKeymapKeyScreenKb(i);
      int idx = 0;
      for (int ii = 0; ii < SDL_Keys.values.length; ii++)
        if (SDL_Keys.values[ii] == sdlKey)
          idx = ii;
      Globals.RemapScreenKbKeycode[i] = idx;
    }
    Globals.ScreenKbControlsShown[0] = (Globals.AppNeedsArrowKeys || Globals.AppUsesJoystick);
    Globals.ScreenKbControlsShown[1] = Globals.AppNeedsTextInput;
    for (int i = 2; i < Globals.ScreenKbControlsShown.length; i++)
      Globals.ScreenKbControlsShown[i] = (i - 2 < Globals.AppTouchscreenKeyboardKeysAmount);
    if (Globals.AppUsesSecondJoystick)
      Globals.ScreenKbControlsShown[8] = true;
    if (Globals.AppUsesThirdJoystick)
      Globals.ScreenKbControlsShown[9] = true;
    for (int i = 0; i < Globals.RemapMultitouchGestureKeycode.length; i++) {
      int sdlKey = nativeGetKeymapKeyMultitouchGesture(i);
      int idx = 0;
      for (int ii = 0; ii < SDL_Keys.values.length; ii++)
        if (SDL_Keys.values[ii] == sdlKey)
          idx = ii;
      Globals.RemapMultitouchGestureKeycode[i] = idx;
    }
    for (int i = 0; i < Globals.MultitouchGesturesUsed.length; i++)
      Globals.MultitouchGesturesUsed[i] = true;
    // Adjust coordinates of on-screen buttons from 800x480
    int displayX = 800;
    int displayY = 480;
    try {
      DisplayMetrics dm = new DisplayMetrics();
      p.getWindowManager().getDefaultDisplay().getMetrics(dm);
      displayX = dm.widthPixels;
      displayY = dm.heightPixels;
    } catch (Exception eeeee) {
    }
    for (int i = 0; i < Globals.ScreenKbControlsLayout.length; i++) {
      Globals.ScreenKbControlsLayout[i][0] *= (float) displayX / 800.0f;
      Globals.ScreenKbControlsLayout[i][2] *= (float) displayX / 800.0f;
      Globals.ScreenKbControlsLayout[i][1] *= (float) displayY / 480.0f;
      Globals.ScreenKbControlsLayout[i][3] *= (float) displayY / 480.0f;
      // Make them square
      int wh = Math.min(Globals.ScreenKbControlsLayout[i][2] - Globals.ScreenKbControlsLayout[i][0], Globals.ScreenKbControlsLayout[i][3] - Globals.ScreenKbControlsLayout[i][1]);
      Globals.ScreenKbControlsLayout[i][2] = Globals.ScreenKbControlsLayout[i][0] + wh;
      Globals.ScreenKbControlsLayout[i][3] = Globals.ScreenKbControlsLayout[i][1] + wh;
    }

    Log.i("SDL", "android.os.Build.MODEL: " + Build.MODEL);
    convertButtonSizeFromOldSdlVersion = false;

    try {
      ObjectInputStream settingsFile = new ObjectInputStream(new FileInputStream(p.getContext().getFilesDir().getAbsolutePath() + "/" + SettingsFileName));
      if (settingsFile.readInt() != SETTINGS_FILE_VERSION)
        throw new IOException();
      Globals.DownloadToSdcard = settingsFile.readBoolean();
      Globals.PhoneHasArrowKeys = settingsFile.readBoolean();
      settingsFile.readBoolean();
      Globals.UseAccelerometerAsArrowKeys = settingsFile.readBoolean();
      Globals.UseTouchscreenKeyboard = settingsFile.readBoolean();
      Globals.TouchscreenKeyboardSize = settingsFile.readInt();
      convertButtonSizeFromOldSdlVersion = true; // Will be changed to false if we read the remainder of the config file
      Globals.AccelerometerSensitivity = settingsFile.readInt();
      Globals.AccelerometerCenterPos = settingsFile.readInt();
      settingsFile.readInt();
      Globals.AudioBufferConfig = settingsFile.readInt();
      Globals.TouchscreenKeyboardTheme = settingsFile.readInt();
      Globals.RightClickMethod = settingsFile.readInt();
      Globals.ShowScreenUnderFinger = settingsFile.readInt();
      Globals.LeftClickMethod = settingsFile.readInt();
      Globals.MoveMouseWithJoystick = settingsFile.readBoolean();
      Globals.ClickMouseWithDpad = settingsFile.readBoolean();
      Globals.ClickScreenPressure = settingsFile.readInt();
      Globals.ClickScreenTouchspotSize = settingsFile.readInt();
      Globals.KeepAspectRatio = settingsFile.readBoolean();
      Globals.MoveMouseWithJoystickSpeed = settingsFile.readInt();
      Globals.MoveMouseWithJoystickAccel = settingsFile.readInt();
      int readKeys = settingsFile.readInt();
      for (int i = 0; i < readKeys; i++) {
        Globals.RemapHwKeycode[i] = settingsFile.readInt();
      }
      if (settingsFile.readInt() != Globals.RemapScreenKbKeycode.length)
        throw new IOException();
      for (int i = 0; i < Globals.RemapScreenKbKeycode.length; i++) {
        Globals.RemapScreenKbKeycode[i] = settingsFile.readInt();
      }
      if (settingsFile.readInt() != Globals.ScreenKbControlsShown.length)
        throw new IOException();
      for (int i = 0; i < Globals.ScreenKbControlsShown.length; i++) {
        Globals.ScreenKbControlsShown[i] = settingsFile.readBoolean();
      }
      Globals.TouchscreenKeyboardTransparency = settingsFile.readInt();
      if (settingsFile.readInt() != Globals.RemapMultitouchGestureKeycode.length)
        throw new IOException();
      for (int i = 0; i < Globals.RemapMultitouchGestureKeycode.length; i++) {
        Globals.RemapMultitouchGestureKeycode[i] = settingsFile.readInt();
        Globals.MultitouchGesturesUsed[i] = settingsFile.readBoolean();
      }
      Globals.MultitouchGestureSensitivity = settingsFile.readInt();
      for (int i = 0; i < Globals.TouchscreenCalibration.length; i++)
        Globals.TouchscreenCalibration[i] = settingsFile.readInt();
      StringBuilder b = new StringBuilder();
      int len = settingsFile.readInt();
      for (int i = 0; i < len; i++)
        b.append(settingsFile.readChar());
      Globals.DataDir = b.toString();

      b = new StringBuilder();
      len = settingsFile.readInt();
      for (int i = 0; i < len; i++)
        b.append(settingsFile.readChar());
      Globals.CommandLine = b.toString();

      if (settingsFile.readInt() != Globals.ScreenKbControlsLayout.length)
        throw new IOException();
      for (int i = 0; i < Globals.ScreenKbControlsLayout.length; i++)
        for (int ii = 0; ii < 4; ii++)
          Globals.ScreenKbControlsLayout[i][ii] = settingsFile.readInt();
      Globals.LeftClickKey = settingsFile.readInt();
      Globals.RightClickKey = settingsFile.readInt();
      Globals.VideoLinearFilter = settingsFile.readBoolean();
      Globals.LeftClickTimeout = settingsFile.readInt();
      Globals.RightClickTimeout = settingsFile.readInt();
      Globals.RelativeMouseMovement = settingsFile.readBoolean();
      Globals.RelativeMouseMovementSpeed = settingsFile.readInt();
      Globals.RelativeMouseMovementAccel = settingsFile.readInt();
      Globals.MultiThreadedVideo = settingsFile.readBoolean();

      Globals.OptionalDataDownload = new boolean[settingsFile.readInt()];
      for (int i = 0; i < Globals.OptionalDataDownload.length; i++)
        Globals.OptionalDataDownload[i] = settingsFile.readBoolean();
      settingsFile.readBoolean(); // Unused
      Globals.TouchscreenKeyboardDrawSize = settingsFile.readInt();
      // Gyroscope calibration data, now unused
      settingsFile.readFloat();
      settingsFile.readFloat();
      settingsFile.readFloat();
      settingsFile.readFloat();
      settingsFile.readFloat();
      settingsFile.readFloat();
      settingsFile.readFloat();
      settingsFile.readFloat();
      settingsFile.readFloat();

      Globals.OuyaEmulation = settingsFile.readBoolean();
      Globals.HoverJitterFilter = settingsFile.readBoolean();
      Globals.MoveMouseWithGyroscope = settingsFile.readBoolean();
      Globals.MoveMouseWithGyroscopeSpeed = settingsFile.readInt();
      Globals.FingerHover = settingsFile.readBoolean();
      Globals.FloatingScreenJoystick = settingsFile.readBoolean();
      Globals.GenerateSubframeTouchEvents = settingsFile.readBoolean();
      Globals.VideoDepthBpp = settingsFile.readInt();
      Globals.HorizontalOrientation = settingsFile.readBoolean();
      Globals.ImmersiveMode = settingsFile.readBoolean();
      Globals.AutoDetectOrientation = settingsFile.readBoolean();
      Globals.TvBorders = settingsFile.readBoolean();
      Globals.ForceHardwareMouse = settingsFile.readBoolean();

      settingsLoaded = true;

      Log.i("SDL", "libSDL: Settings.Load(): loaded settings successfully");
      settingsFile.close();

      return;

    } catch (FileNotFoundException e) {
      Log.i("SDL", "libSDL: settings file not found: " + e);
    } catch (SecurityException e) {
      Log.i("SDL", "libSDL: settings file cannot be opened: " + e);
    } catch (IOException e) {
      Log.i("SDL", "libSDL: settings file cannot be read: " + e);
      DeleteFilesOnUpgrade(p);
      if (convertButtonSizeFromOldSdlVersion && Globals.TouchscreenKeyboardSize + 1 < Globals.TOUCHSCREEN_KEYBOARD_CUSTOM) {
        Globals.TouchscreenKeyboardSize++; // New default button size is bigger, but we are keeping old button size for existing installations
        //if (Globals.AppTouchscreenKeyboardKeysAmount <= 4 && Globals.TouchscreenKeyboardSize + 1 < Globals.TOUCHSCREEN_KEYBOARD_CUSTOM)
        //	Globals.TouchscreenKeyboardSize ++; // If there are only 4 buttons they are even bigger
      }
    }
    ;

    if (Globals.DataDir.length() == 0) {
      if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {
        Log.i("SDL", "libSDL: SD card or external storage is not mounted (state " + Environment.getExternalStorageState() + "), switching to the internal storage.");
        Globals.DownloadToSdcard = false;
      }
      Globals.DataDir = Globals.DownloadToSdcard ?
        SdcardAppPath.get().bestPath(p.getContext()) :
        p.getContext().getFilesDir().getAbsolutePath();
    }

    Log.i("SDL", "libSDL: Settings.Load(): loading settings failed, running config dialog");
    p.initScreenOrientation();
  }

  // ===============================================================================================

  public static boolean deleteRecursively(File dir) {
    boolean success = true;
    if (dir.isDirectory()) {
      String[] children = dir.list();
      for (int i = 0; i < children.length; i++) {
        if (!deleteRecursively(new File(dir, children[i])))
          success = false;
      }
    }
    if (!dir.delete())
      success = false;
    return success;
  }

  public static boolean deleteRecursivelyAndLog(File dir) {
    boolean success = true;
    Log.v("SDL", "Deleting old file: " + dir.getAbsolutePath() + " exists " + dir.exists());
    if (dir.isDirectory()) {
      String[] children = dir.list();
      for (int i = 0; i < children.length; i++) {
        if (!deleteRecursively(new File(dir, children[i])))
          success = false;
      }
    }
    if (!dir.delete())
      success = false;
    return success;
  }

  public static void DeleteFilesOnUpgrade(final NeoXorgViewClient p) {
    String[] files = Globals.DeleteFilesOnUpgrade.split(" ");
    for (String path : files) {
      if (path.equals(""))
        continue;
      deleteRecursivelyAndLog(new File(p.getContext().getFilesDir().getAbsolutePath() + "/" + path));
      for (String sdpath : SdcardAppPath.get().allPaths(p.getContext()))
        deleteRecursivelyAndLog(new File(sdpath + "/" + path));
    }
  }

  public static void DeleteSdlConfigOnUpgradeAndRestart(final NeoXorgViewClient p) {
    try {
      ObjectOutputStream out = new ObjectOutputStream(p.getContext().openFileOutput(SettingsFileName, Context.MODE_PRIVATE));
      out.writeInt(-1);
      out.close();
    } catch (FileNotFoundException e) {
    } catch (IOException e) {
    }
    new File(p.getContext().getFilesDir() + "/" + SettingsFileName).delete();
  }

  // ===============================================================================================

  static void applyMouseEmulationOptions() {
    if (Globals.AppUsesMouse)
      nativeSetMouseUsed(Globals.RightClickMethod,
        Globals.ShowScreenUnderFinger,
        Globals.LeftClickMethod,
        Globals.MoveMouseWithJoystick ? 1 : 0,
        Globals.ClickMouseWithDpad ? 1 : 0,
        Globals.ClickScreenPressure,
        Globals.ClickScreenTouchspotSize,
        Globals.MoveMouseWithJoystickSpeed,
        Globals.MoveMouseWithJoystickAccel,
        Globals.LeftClickKey,
        Globals.RightClickKey,
        Globals.LeftClickTimeout,
        Globals.RightClickTimeout,
        Globals.RelativeMouseMovement ? 1 : 0,
        Globals.RelativeMouseMovementSpeed,
        Globals.RelativeMouseMovementAccel,
        Globals.ShowMouseCursor ? 1 : 0,
        Globals.HoverJitterFilter ? 1 : 0,
        Globals.RightMouseButtonLongPress ? 1 : 0,
        Globals.MoveMouseWithGyroscope ? 1 : 0,
        Globals.MoveMouseWithGyroscopeSpeed,
        Globals.CompatibilityHacksForceScreenUpdateMouseClick ? 1 : 0,
        Globals.ScreenFollowsMouse ? 1 : 0);
  }

  static void Apply(NeoXorgViewClient p) {
    setEnvVars(p);
    nativeSetVideoDepth(Globals.VideoDepthBpp, Globals.NeedGles2 ? 1 : 0, Globals.NeedGles3 ? 1 : 0);
    if (Globals.VideoLinearFilter)
      nativeSetVideoLinearFilter();
    if (Globals.CompatibilityHacksVideo) {
      Globals.MultiThreadedVideo = true;
      Globals.SwVideoMode = true;
      nativeSetCompatibilityHacks();
    }
    if (Globals.SwVideoMode)
      nativeSetVideoForceSoftwareMode();
    if (Globals.SwVideoMode && Globals.MultiThreadedVideo)
      nativeSetVideoMultithreaded();
    applyMouseEmulationOptions();
    nativeSetJoystickUsed(Globals.AppUsesThirdJoystick ? 3 : (Globals.AppUsesSecondJoystick ? 2 : (Globals.AppUsesJoystick ? 1 : 0)));
    if (Globals.AppUsesAccelerometer)
      nativeSetAccelerometerUsed();
    if (Globals.AppUsesMultitouch)
      nativeSetMultitouchUsed();
    nativeSetAccelerometerSettings(Globals.AccelerometerSensitivity, Globals.AccelerometerCenterPos);
    if (Globals.UseTouchscreenKeyboard) {
      boolean screenKbReallyUsed = false;
      for (int i = 0; i < Globals.ScreenKbControlsShown.length; i++)
        if (Globals.ScreenKbControlsShown[i])
          screenKbReallyUsed = true;
      if (p.isRunningOnOUYA())
        screenKbReallyUsed = false;
      if (screenKbReallyUsed) {
        nativeSetTouchscreenKeyboardUsed();
        nativeSetupScreenKeyboard(Globals.TouchscreenKeyboardSize,
          Globals.TouchscreenKeyboardDrawSize,
          Globals.TouchscreenKeyboardTheme,
          Globals.TouchscreenKeyboardTransparency,
          Globals.FloatingScreenJoystick ? 1 : 0,
          Globals.AppTouchscreenKeyboardKeysAmount);
        SetupTouchscreenKeyboardGraphics(p.getContext());
        for (int i = 0; i < Globals.RemapScreenKbKeycode.length; i++)
          nativeSetKeymapKeyScreenKb(i, SDL_Keys.values[Globals.RemapScreenKbKeycode[i]]);
        if (Globals.TouchscreenKeyboardSize == Globals.TOUCHSCREEN_KEYBOARD_CUSTOM) {
          for (int i = 0; i < Globals.ScreenKbControlsLayout.length; i++)
            if (Globals.ScreenKbControlsLayout[i][0] < Globals.ScreenKbControlsLayout[i][2])
              nativeSetScreenKbKeyLayout(i, Globals.ScreenKbControlsLayout[i][0], Globals.ScreenKbControlsLayout[i][1],
                Globals.ScreenKbControlsLayout[i][2], Globals.ScreenKbControlsLayout[i][3]);
        }
        for (int i = 0; i < Globals.ScreenKbControlsShown.length; i++)
          nativeSetScreenKbKeyUsed(i, Globals.ScreenKbControlsShown[i] ? 1 : 0);
      } else
        Globals.UseTouchscreenKeyboard = false;
    }

    for (int i = 0; i < SDL_Keys.JAVA_KEYCODE_LAST; i++)
      nativeSetKeymapKey(i, SDL_Keys.values[Globals.RemapHwKeycode[i]]);
    for (int i = 0; i < Globals.RemapMultitouchGestureKeycode.length; i++)
      nativeSetKeymapKeyMultitouchGesture(i, Globals.MultitouchGesturesUsed[i] ? SDL_Keys.values[Globals.RemapMultitouchGestureKeycode[i]] : 0);
    nativeSetMultitouchGestureSensitivity(Globals.MultitouchGestureSensitivity);
    if (Globals.TouchscreenCalibration[2] > Globals.TouchscreenCalibration[0])
      nativeSetTouchscreenCalibration(Globals.TouchscreenCalibration[0], Globals.TouchscreenCalibration[1],
        Globals.TouchscreenCalibration[2], Globals.TouchscreenCalibration[3]);
  }

  static void setEnvVars(NeoXorgViewClient p) {
    String lang = Locale.getDefault().getLanguage();
    if (Locale.getDefault().getCountry().length() > 0)
      lang = lang + "_" + Locale.getDefault().getCountry();
    Log.i("SDL", "libSDL: setting env LANGUAGE to '" + lang + "'");
    nativeSetEnv("LANG", lang);
    nativeSetEnv("LANGUAGE", lang);
    // TODO: get current user name and set envvar USER, the API is not availalbe on Android 1.6 so I don't bother with this
    nativeSetEnv("APPDIR", p.getContext().getFilesDir().getAbsolutePath());
    nativeSetEnv("SECURE_STORAGE_DIR", p.getContext().getFilesDir().getAbsolutePath());
    nativeSetEnv("DATADIR", Globals.DataDir);
    nativeSetEnv("UNSECURE_STORAGE_DIR", Globals.UnSecureDataDir);
    SdcardAppPath.get().setEnv(p.getContext());
    nativeSetEnv("HOME", Globals.HomeDir);
    nativeSetEnv("SDCARD", Environment.getExternalStorageDirectory().getAbsolutePath());
    nativeSetEnv("SDCARD_DOWNLOADS", Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS).getAbsolutePath());
    nativeSetEnv("SDCARD_PICTURES", Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES).getAbsolutePath());
    nativeSetEnv("SDCARD_MOVIES", Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MOVIES).getAbsolutePath());
    nativeSetEnv("SDCARD_DCIM", Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM).getAbsolutePath());
    nativeSetEnv("SDCARD_MUSIC", Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_MUSIC).getAbsolutePath());
    nativeSetEnv("ANDROID_VERSION", String.valueOf(Build.VERSION.SDK_INT));
    nativeSetEnv("ANDROID_PACKAGE_NAME", p.getContext().getPackageName());
    nativeSetEnv("ANDROID_PACKAGE_PATH", p.getContext().getPackageCodePath());
    nativeSetEnv("ANDROID_MY_OWN_APP_FILE", p.getContext().getPackageResourcePath()); // This may be different from p.getPackageCodePath() on multi-user systems, but should still be the same .apk file
    try {
      nativeSetEnv("ANDROID_APP_NAME", p.getContext().getString(p.getContext().getApplicationInfo().labelRes));
    } catch (Exception eeeeee) {
    }
    Log.d("SDL", "libSDL: Is running on OUYA: " + p.isRunningOnOUYA());
    if (p.isRunningOnOUYA()) {
      nativeSetEnv("OUYA", "1");
      nativeSetEnv("TV", "1");
      nativeSetEnv("ANDROID_TV", "1");
    }
    // TODO: Implement this
//		if (p.getIntent().getCategories() != null && p.getIntent().getCategories().contains("com.google.intent.category.CARDBOARD")) {
//			nativeSetEnv( "CARDBOARD", "1" );
//			nativeSetEnv( "VR", "1" );
//			nativeSetEnv( "CARDBOARD_VR", "1" );
//		}
//		if (p.getIntent().getStringExtra(RestartMainActivity.SDL_RESTART_PARAMS) != null)
//			nativeSetEnv( RestartMainActivity.SDL_RESTART_PARAMS, p.getIntent().getStringExtra(RestartMainActivity.SDL_RESTART_PARAMS) );
    try {
      DisplayMetrics dm = new DisplayMetrics();
      p.getWindowManager().getDefaultDisplay().getMetrics(dm);
      float xx = dm.widthPixels / dm.xdpi;
      float yy = dm.heightPixels / dm.ydpi;
      float x = Math.max(xx, yy);
      float y = Math.min(xx, yy);
      float displayInches = (float) Math.sqrt(x * x + y * y);
      nativeSetEnv("DISPLAY_SIZE", String.valueOf(displayInches));
      nativeSetEnv("DISPLAY_SIZE_MM", String.valueOf((int) (displayInches * 25.4f)));
      nativeSetEnv("DISPLAY_WIDTH", String.valueOf(x));
      nativeSetEnv("DISPLAY_HEIGHT", String.valueOf(y));
      nativeSetEnv("DISPLAY_WIDTH_MM", String.valueOf((int) (x * 25.4f)));
      nativeSetEnv("DISPLAY_HEIGHT_MM", String.valueOf((int) (y * 25.4f)));
      nativeSetEnv("DISPLAY_RESOLUTION_WIDTH", String.valueOf(Math.max(dm.widthPixels, dm.heightPixels)));
      nativeSetEnv("DISPLAY_RESOLUTION_HEIGHT", String.valueOf(Math.min(dm.widthPixels, dm.heightPixels)));
    } catch (Exception eeeee) {
    }
  }

  static byte[] loadRaw(Context p, int res) {
    byte[] buf = new byte[65536 * 2];
    byte[] a = new byte[1048576 * 5]; // We need 5Mb buffer for Keen theme, and this Java code is inefficient
    int written = 0;
    try {
      InputStream is = new GZIPInputStream(p.getResources().openRawResource(res));
      int readed = 0;
      while ((readed = is.read(buf)) >= 0) {
        if (written + readed > a.length) {
          byte[] b = new byte[written + readed];
          System.arraycopy(a, 0, b, 0, written);
          a = b;
        }
        System.arraycopy(buf, 0, a, written, readed);
        written += readed;
      }
    } catch (Exception e) {
    }
    ;
    byte[] b = new byte[written];
    System.arraycopy(a, 0, b, 0, written);
    return b;
  }

  static void SetupTouchscreenKeyboardGraphics(Context p) {
    if (Globals.UseTouchscreenKeyboard) {
      if (Globals.TouchscreenKeyboardTheme < 0)
        Globals.TouchscreenKeyboardTheme = 0;
      if (Globals.TouchscreenKeyboardTheme > 9)
        Globals.TouchscreenKeyboardTheme = 9;

      if (Globals.TouchscreenKeyboardTheme == 0)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.ultimatedroid));
      if (Globals.TouchscreenKeyboardTheme == 1)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.simpletheme));
      if (Globals.TouchscreenKeyboardTheme == 2)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.sun));
      if (Globals.TouchscreenKeyboardTheme == 3)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.keen));
      if (Globals.TouchscreenKeyboardTheme == 4)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.retro));
      if (Globals.TouchscreenKeyboardTheme == 5)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.gba));
      if (Globals.TouchscreenKeyboardTheme == 6)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.psx));
      if (Globals.TouchscreenKeyboardTheme == 7)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.snes));
      if (Globals.TouchscreenKeyboardTheme == 8)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.dualshock));
      if (Globals.TouchscreenKeyboardTheme == 9)
        nativeSetupScreenKeyboardButtons(loadRaw(p, R.raw.n64));
    }
  }

  abstract static class SdcardAppPath {
    public static SdcardAppPath get() {
      return Kitkat.Holder.sInstance;
    }

    public String path(final Context p) {
      return get().path(p);
    }

    public void setEnv(final Context p) {
      get().setEnv(p);
    }

    public String bestPath(final Context p) {
      return get().bestPath(p);
    }

    ;

    public String[] allPaths(final Context p) {
      return get().allPaths(p);
    }

    ;

    private static class Froyo extends SdcardAppPath {
      @Override
      public String path(final Context p) {
        if (p.getExternalFilesDir(null) == null) {
          if (Environment.getExternalStorageDirectory() == null)
            return "/sdcard/Android/data/" + p.getPackageName() + "/files";
          return Environment.getExternalStorageDirectory().getAbsolutePath() + "/Android/data/" + p.getPackageName() + "/files";
        }
        return p.getExternalFilesDir(null).getAbsolutePath();
      }

      @Override
      public void setEnv(final Context p) {
        nativeSetEnv("UNSECURE_STORAGE_DIR_0", Globals.DataDir);
      }

      @Override
      public String bestPath(final Context p) {
        return path(p);
      }

      @Override
      public String[] allPaths(final Context p) {
        return new String[]{path(p)};
      }
    }

    private static class Kitkat extends Froyo {
      private static class Holder {
        private static final Kitkat sInstance = new Kitkat();
      }

      @Override
      public String bestPath(final Context p) {
        File[] paths = p.getExternalFilesDirs(null);
        String ret = path(p);
        long maxSize = -1;
        for (File path : paths) {
          if (path == null)
            continue;
          long size = -1;
          try {
            StatFs stat = new StatFs(path.getPath());
            size = (long) stat.getAvailableBlocks() * stat.getBlockSize() / 1024 / 1024;
          } catch (Exception ee) {
          } // Can throw an exception if we cannot read from SD card

          try {
            path.mkdirs();
            new FileOutputStream(new File(path, ".nomedia")).close();
          } catch (Exception e) {
            size = -1; // Not writable
          }

          if (size > maxSize) {
            maxSize = size;
            ret = path.getAbsolutePath();
          }
        }
        return ret;
      }

      ;

      @Override
      public void setEnv(final Context p) {
        File[] paths = p.getExternalFilesDirs(null);
        int index = 0;
        for (File path : paths) {
          if (path == null)
            continue;
          if (!path.exists())
            path.mkdirs();
          nativeSetEnv("UNSECURE_STORAGE_DIR_" + index, path.getAbsolutePath());
          index++;
        }
      }

      @Override
      public String[] allPaths(final Context p) {
        ArrayList<String> ret = new ArrayList<String>();
        for (File path : p.getExternalFilesDirs(null)) {
          if (path == null)
            continue;
          try {
            path.mkdirs();
            new FileOutputStream(new File(path, ".nomedia")).close();
          } catch (Exception e) {
            continue;
          }
          ret.add(path.getAbsolutePath());
        }
        return ret.toArray(new String[0]);
      }
    }
  }

  static final int SDL_ANDROID_CONFIG_VIDEO_DEPTH_BPP = 0;

  public static void setConfigOptionFromSDL(int option, int value) {
    switch (option) {
      case SDL_ANDROID_CONFIG_VIDEO_DEPTH_BPP:
        Globals.VideoDepthBpp = value;
        break;
      default:
        Log.e("SDL", "setConfigOptionFromSDL: cannot find option with ID " + option + ", value " + value);
        break;
    }
    Save(MainActivity.instance);
  }

  private static native void nativeSetAccelerometerSettings(int sensitivity, int centerPos);

  private static native void nativeSetMouseUsed(int RightClickMethod, int ShowScreenUnderFinger, int LeftClickMethod,
                                                int MoveMouseWithJoystick, int ClickMouseWithDpad, int MaxForce, int MaxRadius,
                                                int MoveMouseWithJoystickSpeed, int MoveMouseWithJoystickAccel,
                                                int leftClickKeycode, int rightClickKeycode,
                                                int leftClickTimeout, int rightClickTimeout,
                                                int relativeMovement, int relativeMovementSpeed,
                                                int relativeMovementAccel, int showMouseCursor,
                                                int HoverJitterFilter, int RightMouseButtonLongPress,
                                                int MoveMouseWithGyroscope, int MoveMouseWithGyroscopeSpeed,
                                                int ForceScreenUpdateMouseClick, int ScreenFollowsMouse);

  private static native void nativeSetJoystickUsed(int amount);

  private static native void nativeSetAccelerometerUsed();

  private static native void nativeSetMultitouchUsed();

  private static native void nativeSetTouchscreenKeyboardUsed();

  private static native void nativeSetVideoLinearFilter();

  private static native void nativeSetVideoDepth(int bpp, int gles2, int gles3);

  private static native void nativeSetCompatibilityHacks();

  private static native void nativeSetVideoMultithreaded();

  private static native void nativeSetVideoForceSoftwareMode();

  private static native void nativeSetupScreenKeyboard(int size, int drawsize, int theme, int transparency, int floatingScreenJoystick, int buttonAmount);

  private static native void nativeSetupScreenKeyboardButtons(byte[] img);

  private static native void nativeInitKeymap();

  private static native int nativeGetKeymapKey(int key);

  private static native void nativeSetKeymapKey(int javakey, int key);

  private static native int nativeGetKeymapKeyScreenKb(int keynum);

  private static native void nativeSetKeymapKeyScreenKb(int keynum, int key);

  private static native void nativeSetScreenKbKeyUsed(int keynum, int used);

  private static native void nativeSetScreenKbKeyLayout(int keynum, int x1, int y1, int x2, int y2);

  private static native int nativeGetKeymapKeyMultitouchGesture(int keynum);

  private static native void nativeSetKeymapKeyMultitouchGesture(int keynum, int key);

  private static native void nativeSetMultitouchGestureSensitivity(int sensitivity);

  private static native void nativeSetTouchscreenCalibration(int x1, int y1, int x2, int y2);

  public static native void nativeSetEnv(final String name, final String value);

  public static native int nativeChmod(final String name, int mode);

  public static native void nativeChdir(final String dir);
}

```

`Xorg/src/main/java/io/neoterm/SettingsMenu.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.DialogInterface;
import androidx.appcompat.app.AlertDialog;
import io.neoterm.xorg.R;

import java.util.ArrayList;


class SettingsMenu {
  public static abstract class Menu {
    // Should be overridden by children
    abstract void run(final MainActivity p);

    abstract String title(final MainActivity p);

    boolean enabled() {
      return true;
    }

    // Should not be overridden
    boolean enabledOrHidden() {
      for (Menu m : Globals.HiddenMenuOptions) {
        if (m.getClass().getName().equals(this.getClass().getName()))
          return false;
      }
      return enabled();
    }

    void showMenuOptionsList(final MainActivity p, final Menu[] list) {
      menuStack.add(this);
      ArrayList<CharSequence> items = new ArrayList<CharSequence>();
      for (Menu m : list) {
        if (m.enabledOrHidden())
          items.add(m.title(p));
      }
      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(title(p));
      builder.setItems(items.toArray(new CharSequence[0]), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          int selected = 0;

          for (Menu m : list) {
            if (m.enabledOrHidden()) {
              if (selected == item) {
                m.run(p);
                return;
              }
              selected++;
            }
          }
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBackOuterMenu(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static ArrayList<Menu> menuStack = new ArrayList<Menu>();

  public static void showConfig(final MainActivity p, final boolean firstStart) {
    Settings.settingsChanged = true;
    if (Globals.OptionalDataDownload == null) {
      String downloads[] = Globals.DataDownloadUrl;
      Globals.OptionalDataDownload = new boolean[downloads.length];
      boolean oldFormat = true;
      for (int i = 0; i < downloads.length; i++) {
        if (downloads[i].indexOf("!") == 0) {
          Globals.OptionalDataDownload[i] = true;
          oldFormat = false;
        }
      }
      if (oldFormat)
        Globals.OptionalDataDownload[0] = true;
    }

    if (!firstStart)
      new MainMenu().run(p);
    else {
      if (Globals.StartupMenuButtonTimeout > 0) // If we did not disable startup menu altogether
      {
        for (Menu m : Globals.FirstStartMenuOptions) {
          boolean hidden = false;
          for (Menu m1 : Globals.HiddenMenuOptions) {
            if (m1.getClass().getName().equals(m.getClass().getName()))
              hidden = true;
          }
          if (!hidden)
            menuStack.add(0, m);
        }
      }
      goBack(p);
    }
  }

  static void goBack(final MainActivity p) {
    if (menuStack.isEmpty()) {
      Settings.Save(p);
    } else {
      Menu c = menuStack.remove(menuStack.size() - 1);
      c.run(p);
    }
  }

  static void goBackOuterMenu(final MainActivity p) {
    if (!menuStack.isEmpty())
      menuStack.remove(menuStack.size() - 1);
    goBack(p);
  }

  static class OkButton extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.ok);
    }

    void run(final MainActivity p) {
      goBackOuterMenu(p);
    }
  }

  static class DummyMenu extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.ok);
    }

    void run(final MainActivity p) {
      goBack(p);
    }
  }

  static class MainMenu extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.device_config);
    }

    void run(final MainActivity p) {
      Menu options[] =
        {
          new SettingsMenuMisc.DownloadConfig(),
          new SettingsMenuMisc.OptionalDownloadConfig(false),
          new SettingsMenuKeyboard.KeyboardConfigMainMenu(),
          new SettingsMenuMouse.MouseConfigMainMenu(),
          new SettingsMenuMisc.AudioConfig(),
          new SettingsMenuKeyboard.RemapHwKeysConfig(),
          new SettingsMenuKeyboard.ScreenGesturesConfig(),
          new SettingsMenuMisc.VideoSettingsConfig(),
          new SettingsMenuMisc.CommandlineConfig(),
          new SettingsMenuMisc.ResetToDefaultsConfig(),
          new OkButton(),
        };
      showMenuOptionsList(p, options);
    }
  }
}

```

`Xorg/src/main/java/io/neoterm/SettingsMenuKeyboard.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.DialogInterface;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.graphics.RectF;
import android.util.DisplayMetrics;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.FrameLayout;
import android.widget.ImageView;
import androidx.appcompat.app.AlertDialog;
import io.neoterm.xorg.R;

import java.util.Arrays;


class SettingsMenuKeyboard extends SettingsMenu {
  static class KeyboardConfigMainMenu extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.controls_screenkb);
    }

    boolean enabled() {
      return Globals.UseTouchscreenKeyboard;
    }

    void run(final MainActivity p) {
      Menu options[] =
        {
          new ScreenKeyboardThemeConfig(),
          new ScreenKeyboardSizeConfig(),
          new ScreenKeyboardDrawSizeConfig(),
          new ScreenKeyboardTransparencyConfig(),
          new RemapScreenKbConfig(),
          new CustomizeScreenKbLayout(),
          new ScreenKeyboardAdvanced(),
          new OkButton(),
        };
      showMenuOptionsList(p, options);
    }
  }

  static class ScreenKeyboardSizeConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.controls_screenkb_size);
    }

    void run(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.controls_screenkb_large),
        p.getResources().getString(R.string.controls_screenkb_medium),
        p.getResources().getString(R.string.controls_screenkb_small),
        p.getResources().getString(R.string.controls_screenkb_tiny),
        p.getResources().getString(R.string.controls_screenkb_custom)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.controls_screenkb_size));
      builder.setSingleChoiceItems(items, Globals.TouchscreenKeyboardSize, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.TouchscreenKeyboardSize = item;
          dialog.dismiss();
          if (Globals.TouchscreenKeyboardSize == Globals.TOUCHSCREEN_KEYBOARD_CUSTOM)
            new CustomizeScreenKbLayout().run(p);
          else
            goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class ScreenKeyboardDrawSizeConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.controls_screenkb_drawsize);
    }

    void run(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.controls_screenkb_large),
        p.getResources().getString(R.string.controls_screenkb_medium),
        p.getResources().getString(R.string.controls_screenkb_small),
        p.getResources().getString(R.string.controls_screenkb_tiny)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.controls_screenkb_drawsize));
      builder.setSingleChoiceItems(items, Globals.TouchscreenKeyboardDrawSize, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.TouchscreenKeyboardDrawSize = item;

          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class ScreenKeyboardThemeConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.controls_screenkb_theme);
    }

    void run(final MainActivity p) {
      final CharSequence[] items = {
        p.getResources().getString(R.string.controls_screenkb_by, "Ultimate Droid", "Sean Stieber"),
        p.getResources().getString(R.string.controls_screenkb_by, "Simple Theme", "Beholder"),
        p.getResources().getString(R.string.controls_screenkb_by, "Sun", "Sirea"),
        p.getResources().getString(R.string.controls_screenkb_by, "Keen", "Gerstrong"),
        p.getResources().getString(R.string.controls_screenkb_by, "Retro", "Santiago Radeff"),
        p.getResources().getString(R.string.controls_screenkb_by, "Gba", "from RetroArch"),
        p.getResources().getString(R.string.controls_screenkb_by, "Psx", "from RetroArch"),
        p.getResources().getString(R.string.controls_screenkb_by, "Snes", "from RetroArch"),
        p.getResources().getString(R.string.controls_screenkb_by, "DualShock", "from RetroArch"),
        p.getResources().getString(R.string.controls_screenkb_by, "N64", "from RetroArch")
      };

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.controls_screenkb_theme));
      builder.setSingleChoiceItems(items, Globals.TouchscreenKeyboardTheme, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.TouchscreenKeyboardTheme = item;

          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class ScreenKeyboardTransparencyConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.controls_screenkb_transparency);
    }

    void run(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.controls_screenkb_trans_0),
        p.getResources().getString(R.string.controls_screenkb_trans_1),
        p.getResources().getString(R.string.controls_screenkb_trans_2),
        p.getResources().getString(R.string.controls_screenkb_trans_3),
        p.getResources().getString(R.string.controls_screenkb_trans_4)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.controls_screenkb_transparency));
      builder.setSingleChoiceItems(items, Globals.TouchscreenKeyboardTransparency, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.TouchscreenKeyboardTransparency = item;

          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class RemapHwKeysConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.remap_hwkeys);
    }

    void run(final MainActivity p) {
      p.setText(p.getResources().getString(R.string.remap_hwkeys_press));
      p.getVideoLayout().setOnKeyListener(new KeyRemapTool(p));
    }

    public static class KeyRemapTool implements View.OnKeyListener {
      MainActivity p;

      public KeyRemapTool(MainActivity _p) {
        p = _p;
      }

      @Override
      public boolean onKey(View v, int keyCode, KeyEvent event) {
        p.getVideoLayout().setOnKeyListener(null);
        int keyIndex = keyCode;
        if (keyIndex < 0)
          keyIndex = 0;
        if (keyIndex > SDL_Keys.JAVA_KEYCODE_LAST)
          keyIndex = 0;

        final int KeyIndexFinal = keyIndex;
        CharSequence[] items = {
          SDL_Keys.names[Globals.RemapScreenKbKeycode[0]],
          SDL_Keys.names[Globals.RemapScreenKbKeycode[1]],
          SDL_Keys.names[Globals.RemapScreenKbKeycode[2]],
          SDL_Keys.names[Globals.RemapScreenKbKeycode[3]],
          SDL_Keys.names[Globals.RemapScreenKbKeycode[4]],
          SDL_Keys.names[Globals.RemapScreenKbKeycode[5]],
          p.getResources().getString(R.string.remap_hwkeys_select_more_keys),
        };

        for (int i = 0; i < Math.min(6, Globals.AppTouchscreenKeyboardKeysNames.length); i++)
          items[i] = Globals.AppTouchscreenKeyboardKeysNames[i].replace("_", " ");

        AlertDialog.Builder builder = new AlertDialog.Builder(p);
        builder.setTitle(R.string.remap_hwkeys_select_simple);
        builder.setItems(items, new DialogInterface.OnClickListener() {
          public void onClick(DialogInterface dialog, int item) {
            dialog.dismiss();
            if (item >= 6)
              ShowAllKeys(KeyIndexFinal);
            else {
              Globals.RemapHwKeycode[KeyIndexFinal] = Globals.RemapScreenKbKeycode[item];
              goBack(p);
            }
          }
        });
        builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
          public void onCancel(DialogInterface dialog) {
            goBack(p);
          }
        });
        AlertDialog alert = builder.create();
        alert.setOwnerActivity(p);
        alert.show();
        return true;
      }

      public void ShowAllKeys(final int KeyIndex) {
        AlertDialog.Builder builder = new AlertDialog.Builder(p);
        builder.setTitle(R.string.remap_hwkeys_select);
        builder.setSingleChoiceItems(SDL_Keys.namesSorted, SDL_Keys.namesSortedBackIdx[Globals.RemapHwKeycode[KeyIndex]], new DialogInterface.OnClickListener() {
          public void onClick(DialogInterface dialog, int item) {
            Globals.RemapHwKeycode[KeyIndex] = SDL_Keys.namesSortedIdx[item];

            dialog.dismiss();
            goBack(p);
          }
        });
        builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
          public void onCancel(DialogInterface dialog) {
            goBack(p);
          }
        });
        AlertDialog alert = builder.create();
        alert.setOwnerActivity(p);
        alert.show();
      }
    }
  }

  static class RemapScreenKbConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.remap_screenkb);
    }

    //boolean enabled() { return true; };
    void run(final MainActivity p) {
      CharSequence[] items = {
        p.getResources().getString(R.string.remap_screenkb_joystick),
        p.getResources().getString(R.string.remap_screenkb_button_text),
        p.getResources().getString(R.string.remap_screenkb_button) + " 1",
        p.getResources().getString(R.string.remap_screenkb_button) + " 2",
        p.getResources().getString(R.string.remap_screenkb_button) + " 3",
        p.getResources().getString(R.string.remap_screenkb_button) + " 4",
        p.getResources().getString(R.string.remap_screenkb_button) + " 5",
        p.getResources().getString(R.string.remap_screenkb_button) + " 6",
      };

      boolean defaults[] = Arrays.copyOf(Globals.ScreenKbControlsShown, Globals.ScreenKbControlsShown.length);
      if (Globals.AppUsesSecondJoystick) {
        items = Arrays.copyOf(items, items.length + 1);
        items[items.length - 1] = p.getResources().getString(R.string.remap_screenkb_joystick) + " 2";
        defaults = Arrays.copyOf(defaults, defaults.length + 1);
        defaults[defaults.length - 1] = true;
      }
      if (Globals.AppUsesThirdJoystick) {
        items = Arrays.copyOf(items, items.length + 1);
        items[items.length - 1] = p.getResources().getString(R.string.remap_screenkb_joystick) + " 3";
        defaults = Arrays.copyOf(defaults, defaults.length + 1);
        defaults[defaults.length - 1] = true;
      }

      for (int i = 0; i < Math.min(6, Globals.AppTouchscreenKeyboardKeysNames.length); i++)
        items[i + 2] = items[i + 2] + " - " + Globals.AppTouchscreenKeyboardKeysNames[i].replace("_", " ");

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.remap_screenkb));
      builder.setMultiChoiceItems(items, defaults, new DialogInterface.OnMultiChoiceClickListener() {
        public void onClick(DialogInterface dialog, int item, boolean isChecked) {
          Globals.ScreenKbControlsShown[item] = isChecked;
        }
      });
      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          showRemapScreenKbConfig2(p, 0);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showRemapScreenKbConfig2(final MainActivity p, final int currentButton) {
      CharSequence[] items = {
        p.getResources().getString(R.string.remap_screenkb_button) + " 1",
        p.getResources().getString(R.string.remap_screenkb_button) + " 2",
        p.getResources().getString(R.string.remap_screenkb_button) + " 3",
        p.getResources().getString(R.string.remap_screenkb_button) + " 4",
        p.getResources().getString(R.string.remap_screenkb_button) + " 5",
        p.getResources().getString(R.string.remap_screenkb_button) + " 6",
      };

      for (int i = 0; i < Math.min(6, Globals.AppTouchscreenKeyboardKeysNames.length); i++)
        items[i] = items[i] + " - " + Globals.AppTouchscreenKeyboardKeysNames[i].replace("_", " ");

      if (currentButton >= Globals.RemapScreenKbKeycode.length) {
        goBack(p);
        return;
      }
      if (!Globals.ScreenKbControlsShown[currentButton + 2]) {
        showRemapScreenKbConfig2(p, currentButton + 1);
        return;
      }

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(items[currentButton]);
      builder.setSingleChoiceItems(SDL_Keys.namesSorted, SDL_Keys.namesSortedBackIdx[Globals.RemapScreenKbKeycode[currentButton]], new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.RemapScreenKbKeycode[currentButton] = SDL_Keys.namesSortedIdx[item];

          dialog.dismiss();
          showRemapScreenKbConfig2(p, currentButton + 1);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class ScreenGesturesConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.remap_screenkb_button_gestures);
    }

    //boolean enabled() { return true; };
    void run(final MainActivity p) {
      CharSequence[] items = {
        p.getResources().getString(R.string.remap_screenkb_button_zoomin),
        p.getResources().getString(R.string.remap_screenkb_button_zoomout),
        p.getResources().getString(R.string.remap_screenkb_button_rotateleft),
        p.getResources().getString(R.string.remap_screenkb_button_rotateright),
      };

      boolean defaults[] = {
        Globals.MultitouchGesturesUsed[0],
        Globals.MultitouchGesturesUsed[1],
        Globals.MultitouchGesturesUsed[2],
        Globals.MultitouchGesturesUsed[3],
      };

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.remap_screenkb_button_gestures));
      builder.setMultiChoiceItems(items, defaults, new DialogInterface.OnMultiChoiceClickListener() {
        public void onClick(DialogInterface dialog, int item, boolean isChecked) {
          Globals.MultitouchGesturesUsed[item] = isChecked;
        }
      });
      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          showScreenGesturesConfig2(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showScreenGesturesConfig2(final MainActivity p) {
      final CharSequence[] items = {
        p.getResources().getString(R.string.accel_slow),
        p.getResources().getString(R.string.accel_medium),
        p.getResources().getString(R.string.accel_fast),
        p.getResources().getString(R.string.accel_veryfast)
      };

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.remap_screenkb_button_gestures_sensitivity);
      builder.setSingleChoiceItems(items, Globals.MultitouchGestureSensitivity, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.MultitouchGestureSensitivity = item;

          dialog.dismiss();
          showScreenGesturesConfig3(p, 0);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showScreenGesturesConfig3(final MainActivity p, final int currentButton) {
      CharSequence[] items = {
        p.getResources().getString(R.string.remap_screenkb_button_zoomin),
        p.getResources().getString(R.string.remap_screenkb_button_zoomout),
        p.getResources().getString(R.string.remap_screenkb_button_rotateleft),
        p.getResources().getString(R.string.remap_screenkb_button_rotateright),
      };

      if (currentButton >= Globals.RemapMultitouchGestureKeycode.length) {
        goBack(p);
        return;
      }
      if (!Globals.MultitouchGesturesUsed[currentButton]) {
        showScreenGesturesConfig3(p, currentButton + 1);
        return;
      }

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(items[currentButton]);
      builder.setSingleChoiceItems(SDL_Keys.namesSorted, SDL_Keys.namesSortedBackIdx[Globals.RemapMultitouchGestureKeycode[currentButton]], new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.RemapMultitouchGestureKeycode[currentButton] = SDL_Keys.namesSortedIdx[item];

          dialog.dismiss();
          showScreenGesturesConfig3(p, currentButton + 1);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class CustomizeScreenKbLayout extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.screenkb_custom_layout);
    }

    //boolean enabled() { return true; };
    void run(final MainActivity p) {
      p.setText(p.getResources().getString(R.string.screenkb_custom_layout_help));
      CustomizeScreenKbLayoutTool tool = new CustomizeScreenKbLayoutTool(p);
      Globals.TouchscreenKeyboardSize = Globals.TOUCHSCREEN_KEYBOARD_CUSTOM;
    }

    static class CustomizeScreenKbLayoutTool implements View.OnTouchListener, View.OnKeyListener {
      MainActivity p;
      FrameLayout layout = null;
      ImageView imgs[] = new ImageView[Globals.ScreenKbControlsLayout.length];
      Bitmap bmps[] = new Bitmap[Globals.ScreenKbControlsLayout.length];
      ImageView boundary = null;
      Bitmap boundaryBmp = null;
      int currentButton = 0;
      int buttons[] = {
        R.drawable.dpad,
        R.drawable.keyboard,
        R.drawable.b1,
        R.drawable.b2,
        R.drawable.b3,
        R.drawable.b4,
        R.drawable.b5,
        R.drawable.b6,
        R.drawable.dpad,
        R.drawable.dpad
      };
      int oldX = 0, oldY = 0;
      boolean resizing = false;

      public CustomizeScreenKbLayoutTool(MainActivity _p) {
        p = _p;
        layout = new FrameLayout(p);
        p.getVideoLayout().addView(layout);
        layout.setFocusable(true);
        layout.setFocusableInTouchMode(true);
        layout.requestFocus();
        layout.setOnTouchListener(this);
        layout.setOnKeyListener(this);
        boundary = new ImageView(p);
        boundary.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
        boundary.setScaleType(ImageView.ScaleType.MATRIX);
        boundaryBmp = BitmapFactory.decodeResource(p.getResources(), R.drawable.rectangle);
        boundary.setImageBitmap(boundaryBmp);
        layout.addView(boundary);
        currentButton = -1;
        if (Globals.TouchscreenKeyboardTheme == 2) {
          buttons = new int[]{
            R.drawable.sun_dpad,
            R.drawable.sun_keyboard,
            R.drawable.sun_b1,
            R.drawable.sun_b2,
            R.drawable.sun_b3,
            R.drawable.sun_b4,
            R.drawable.sun_b5,
            R.drawable.sun_b6,
            R.drawable.sun_dpad,
            R.drawable.sun_dpad
          };
        }

        int displayX = 800;
        int displayY = 480;
        try {
          DisplayMetrics dm = new DisplayMetrics();
          p.getWindowManager().getDefaultDisplay().getMetrics(dm);
          displayX = dm.widthPixels;
          displayY = dm.heightPixels;
        } catch (Exception eeeee) {
        }

        for (int i = 0; i < Globals.ScreenKbControlsLayout.length; i++) {
          if (!Globals.ScreenKbControlsShown[i])
            continue;
          if (currentButton == -1)
            currentButton = i;
          //Log.i("SDL", "Screen kb button " + i + " coords " + Globals.ScreenKbControlsLayout[i][0] + ":" + Globals.ScreenKbControlsLayout[i][1] + ":" + Globals.ScreenKbControlsLayout[i][2] + ":" + Globals.ScreenKbControlsLayout[i][3] );
          // Check if the button is off screen edge or shrunk to zero
          if (Globals.ScreenKbControlsLayout[i][0] > Globals.ScreenKbControlsLayout[i][2] - displayY / 12)
            Globals.ScreenKbControlsLayout[i][0] = Globals.ScreenKbControlsLayout[i][2] - displayY / 12;
          if (Globals.ScreenKbControlsLayout[i][1] > Globals.ScreenKbControlsLayout[i][3] - displayY / 12)
            Globals.ScreenKbControlsLayout[i][1] = Globals.ScreenKbControlsLayout[i][3] - displayY / 12;
          if (Globals.ScreenKbControlsLayout[i][0] < Globals.ScreenKbControlsLayout[i][2] - displayY * 2 / 3)
            Globals.ScreenKbControlsLayout[i][0] = Globals.ScreenKbControlsLayout[i][2] - displayY * 2 / 3;
          if (Globals.ScreenKbControlsLayout[i][1] < Globals.ScreenKbControlsLayout[i][3] - displayY * 2 / 3)
            Globals.ScreenKbControlsLayout[i][1] = Globals.ScreenKbControlsLayout[i][3] - displayY * 2 / 3;
          if (Globals.ScreenKbControlsLayout[i][0] < 0) {
            Globals.ScreenKbControlsLayout[i][2] += -Globals.ScreenKbControlsLayout[i][0];
            Globals.ScreenKbControlsLayout[i][0] = 0;
          }
          if (Globals.ScreenKbControlsLayout[i][2] > displayX) {
            Globals.ScreenKbControlsLayout[i][0] -= Globals.ScreenKbControlsLayout[i][2] - displayX;
            Globals.ScreenKbControlsLayout[i][2] = displayX;
          }
          if (Globals.ScreenKbControlsLayout[i][1] < 0) {
            Globals.ScreenKbControlsLayout[i][3] += -Globals.ScreenKbControlsLayout[i][1];
            Globals.ScreenKbControlsLayout[i][1] = 0;
          }
          if (Globals.ScreenKbControlsLayout[i][3] > displayY) {
            Globals.ScreenKbControlsLayout[i][1] -= Globals.ScreenKbControlsLayout[i][3] - displayY;
            Globals.ScreenKbControlsLayout[i][3] = displayY;
          }
          //Log.i("SDL", "After bounds check coords " + Globals.ScreenKbControlsLayout[i][0] + ":" + Globals.ScreenKbControlsLayout[i][1] + ":" + Globals.ScreenKbControlsLayout[i][2] + ":" + Globals.ScreenKbControlsLayout[i][3] );

          imgs[i] = new ImageView(p);
          imgs[i].setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
          imgs[i].setScaleType(ImageView.ScaleType.MATRIX);
          bmps[i] = BitmapFactory.decodeResource(p.getResources(), buttons[i]);
          imgs[i].setImageBitmap(bmps[i]);
          imgs[i].setAlpha(128);
          layout.addView(imgs[i]);
          Matrix m = new Matrix();
          RectF src = new RectF(0, 0, bmps[i].getWidth(), bmps[i].getHeight());
          RectF dst = new RectF(Globals.ScreenKbControlsLayout[i][0], Globals.ScreenKbControlsLayout[i][1],
            Globals.ScreenKbControlsLayout[i][2], Globals.ScreenKbControlsLayout[i][3]);
          m.setRectToRect(src, dst, Matrix.ScaleToFit.FILL);
          imgs[i].setImageMatrix(m);
        }
        boundary.bringToFront();
        if (currentButton == -1)
          onKey(null, KeyEvent.KEYCODE_BACK, null); // All buttons disabled - do not show anything
        else
          setupButton(currentButton);
      }

      void setupButton(int i) {
        Matrix m = new Matrix();
        RectF src = new RectF(0, 0, bmps[i].getWidth(), bmps[i].getHeight());
        RectF dst = new RectF(Globals.ScreenKbControlsLayout[i][0], Globals.ScreenKbControlsLayout[i][1],
          Globals.ScreenKbControlsLayout[i][2], Globals.ScreenKbControlsLayout[i][3]);
        m.setRectToRect(src, dst, Matrix.ScaleToFit.FILL);
        imgs[i].setImageMatrix(m);
        m = new Matrix();
        src = new RectF(0, 0, boundaryBmp.getWidth(), boundaryBmp.getHeight());
        m.setRectToRect(src, dst, Matrix.ScaleToFit.FILL);
        boundary.setImageMatrix(m);
        String buttonText = "";
        if (i >= 2 && i <= 7)
          buttonText = p.getResources().getString(R.string.remap_screenkb_button) + (i - 2);
        if (i >= 2 && i - 2 < Globals.AppTouchscreenKeyboardKeysNames.length)
          buttonText = Globals.AppTouchscreenKeyboardKeysNames[i - 2].replace("_", " ");
        if (i == 0)
          buttonText = "Joystick";
        if (i == 1)
          buttonText = "Text input";
        if (i == 8)
          buttonText = "Joystick 2";
        if (i == 9)
          buttonText = "Joystick 3";
        p.setText(p.getResources().getString(R.string.screenkb_custom_layout_help) + "\n" + buttonText);
      }

      @Override
      public boolean onTouch(View v, MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
          oldX = (int) ev.getX();
          oldY = (int) ev.getY();
          resizing = true;
          for (int i = 0; i < Globals.ScreenKbControlsLayout.length; i++) {
            if (!Globals.ScreenKbControlsShown[i])
              continue;
            if (Globals.ScreenKbControlsLayout[i][0] <= oldX &&
              Globals.ScreenKbControlsLayout[i][2] >= oldX &&
              Globals.ScreenKbControlsLayout[i][1] <= oldY &&
              Globals.ScreenKbControlsLayout[i][3] >= oldY) {
              currentButton = i;
              setupButton(currentButton);
              resizing = false;
              break;
            }
          }
        }
        if (ev.getAction() == MotionEvent.ACTION_MOVE) {
          int dx = (int) ev.getX() - oldX;
          int dy = (int) ev.getY() - oldY;
          if (resizing) {
            // Resize slowly, with 1/3 of movement speed
            dx /= 6;
            dy /= 6;
            if (Globals.ScreenKbControlsLayout[currentButton][0] <= Globals.ScreenKbControlsLayout[currentButton][2] + dx * 2) {
              Globals.ScreenKbControlsLayout[currentButton][0] -= dx;
              Globals.ScreenKbControlsLayout[currentButton][2] += dx;
            }
            if (Globals.ScreenKbControlsLayout[currentButton][1] <= Globals.ScreenKbControlsLayout[currentButton][3] + dy * 2) {
              Globals.ScreenKbControlsLayout[currentButton][1] += dy;
              Globals.ScreenKbControlsLayout[currentButton][3] -= dy;
            }
            dx *= 6;
            dy *= 6;
          } else {
            Globals.ScreenKbControlsLayout[currentButton][0] += dx;
            Globals.ScreenKbControlsLayout[currentButton][2] += dx;
            Globals.ScreenKbControlsLayout[currentButton][1] += dy;
            Globals.ScreenKbControlsLayout[currentButton][3] += dy;
          }
          oldX += dx;
          oldY += dy;
          Matrix m = new Matrix();
          RectF src = new RectF(0, 0, bmps[currentButton].getWidth(), bmps[currentButton].getHeight());
          RectF dst = new RectF(Globals.ScreenKbControlsLayout[currentButton][0], Globals.ScreenKbControlsLayout[currentButton][1],
            Globals.ScreenKbControlsLayout[currentButton][2], Globals.ScreenKbControlsLayout[currentButton][3]);
          m.setRectToRect(src, dst, Matrix.ScaleToFit.FILL);
          imgs[currentButton].setImageMatrix(m);
          m = new Matrix();
          src = new RectF(0, 0, boundaryBmp.getWidth(), boundaryBmp.getHeight());
          m.setRectToRect(src, dst, Matrix.ScaleToFit.FILL);
          boundary.setImageMatrix(m);
        }
        return true;
      }

      @Override
      public boolean onKey(View v, int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
          p.getVideoLayout().removeView(layout);
          layout = null;
          goBack(p);
        }
        return true;
      }
    }
  }

  static class ScreenKeyboardAdvanced extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.advanced);
    }

    //boolean enabled() { return true; };
    void run(final MainActivity p) {
      CharSequence[] items = {
        p.getResources().getString(R.string.screenkb_floating_joystick),
      };

      boolean defaults[] = {
        Globals.FloatingScreenJoystick,
      };

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.advanced));
      builder.setMultiChoiceItems(items, defaults, new DialogInterface.OnMultiChoiceClickListener() {
        public void onClick(DialogInterface dialog, int item, boolean isChecked) {
          if (item == 0)
            Globals.FloatingScreenJoystick = isChecked;
        }
      });
      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }
}


```

`Xorg/src/main/java/io/neoterm/SettingsMenuMisc.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.DialogInterface;
import android.content.Intent;
import android.net.Uri;
import android.os.StatFs;
import android.text.InputType;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.*;
import androidx.appcompat.app.AlertDialog;
import io.neoterm.xorg.R;

import java.util.ArrayList;
import java.util.Locale;


class SettingsMenuMisc extends SettingsMenu {
  static class DownloadConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.storage_question);
    }

    void run(final MainActivity p) {
      long freeSdcard = 0;
      long freePhone = 0;
      try {
        StatFs phone = new StatFs(p.getFilesDir().getAbsolutePath());
        freePhone = (long) phone.getAvailableBlocks() * phone.getBlockSize() / 1024 / 1024;
        StatFs sdcard = new StatFs(Settings.SdcardAppPath.get().bestPath(p));
        freeSdcard = (long) sdcard.getAvailableBlocks() * sdcard.getBlockSize() / 1024 / 1024;
      } catch (Exception e) {
      }

      final CharSequence[] items = {p.getResources().getString(R.string.storage_phone, freePhone),
        p.getResources().getString(R.string.storage_sd, freeSdcard),
        p.getResources().getString(R.string.storage_custom)};
      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.storage_question));
      builder.setSingleChoiceItems(items, Globals.DownloadToSdcard ? 1 : 0, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();

          if (item == 2)
            showCustomDownloadDirConfig(p);
          else {
            Globals.DownloadToSdcard = (item != 0);
            Globals.DataDir = Globals.DownloadToSdcard ?
              Settings.SdcardAppPath.get().bestPath(p) :
              p.getFilesDir().getAbsolutePath();
            goBack(p);
          }
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showCustomDownloadDirConfig(final MainActivity p) {
      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.storage_custom));

      final EditText edit = new EditText(p);
      edit.setFocusableInTouchMode(true);
      edit.setFocusable(true);
      edit.setText(Globals.DataDir);
      builder.setView(edit);

      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.DataDir = edit.getText().toString();
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class OptionalDownloadConfig extends Menu {
    boolean firstStart = false;

    OptionalDownloadConfig() {
      firstStart = true;
    }

    OptionalDownloadConfig(boolean firstStart) {
      this.firstStart = firstStart;
    }

    String title(final MainActivity p) {
      return p.getResources().getString(R.string.downloads);
    }

    void run(final MainActivity p) {
      String[] downloadFiles = Globals.DataDownloadUrl;

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.downloads));

      final int itemsIdx[] = new int[downloadFiles.length];
      ArrayList<CharSequence> items = new ArrayList<CharSequence>();
      ArrayList<Boolean> enabledItems = new ArrayList<Boolean>();
      for (int i = 0; i < downloadFiles.length; i++) {
        String item = new String(downloadFiles[i].split("[|]")[0]);
        boolean enabled = false;
        if (item.toString().indexOf("!") == 0) {
          item = item.toString().substring(1);
          enabled = true;
        }
        if (item.toString().indexOf("!") == 0) // Download is mandatory
          continue;
        itemsIdx[items.size()] = i;
        items.add(item);
        enabledItems.add(enabled);
      }

      if (Globals.OptionalDataDownload == null || Globals.OptionalDataDownload.length != downloadFiles.length) {
        Globals.OptionalDataDownload = new boolean[downloadFiles.length];
        boolean oldFormat = true;
        for (int i = 0; i < downloadFiles.length; i++) {
          if (downloadFiles[i].indexOf("!") == 0) {
            Globals.OptionalDataDownload[i] = true;
            oldFormat = false;
          }
        }
        if (oldFormat)
          Globals.OptionalDataDownload[0] = true;
      }
      if (enabledItems.size() <= 0) {
        goBack(p);
        return;
      }

      // Convert Boolean[] to boolean[], meh
      boolean[] enabledItems2 = new boolean[enabledItems.size()];
      for (int i = 0; i < enabledItems.size(); i++)
        enabledItems2[i] = enabledItems.get(i);

      builder.setMultiChoiceItems(items.toArray(new CharSequence[0]), enabledItems2, new DialogInterface.OnMultiChoiceClickListener() {
        public void onClick(DialogInterface dialog, int item, boolean isChecked) {
          Globals.OptionalDataDownload[itemsIdx[item]] = isChecked;
        }
      });
      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          goBack(p);
        }
      });
      if (firstStart) {
        builder.setNegativeButton(p.getResources().getString(R.string.show_more_options), new DialogInterface.OnClickListener() {
          public void onClick(DialogInterface dialog, int item) {
            dialog.dismiss();
            menuStack.clear();
            new MainMenu().run(p);
          }
        });
      }
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class AudioConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.audiobuf_question);
    }

    void run(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.audiobuf_verysmall),
        p.getResources().getString(R.string.audiobuf_small),
        p.getResources().getString(R.string.audiobuf_medium),
        p.getResources().getString(R.string.audiobuf_large)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.audiobuf_question);
      builder.setSingleChoiceItems(items, Globals.AudioBufferConfig, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.AudioBufferConfig = item;
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class VideoSettingsConfig extends Menu {
    static int debugMenuShowCount = 0;

    String title(final MainActivity p) {
      return p.getResources().getString(R.string.video);
    }

    //boolean enabled() { return true; };
    void run(final MainActivity p) {
      debugMenuShowCount++;
      CharSequence[] items = {
        p.getResources().getString(R.string.mouse_keepaspectratio),
        p.getResources().getString(R.string.video_smooth),
        p.getResources().getString(R.string.video_immersive),
        p.getResources().getString(R.string.video_orientation_autodetect),
        p.getResources().getString(R.string.video_orientation_vertical),
        p.getResources().getString(R.string.video_bpp_24),
        p.getResources().getString(R.string.tv_borders),
      };
      boolean defaults[] = {
        Globals.KeepAspectRatio,
        Globals.VideoLinearFilter,
        Globals.ImmersiveMode,
        Globals.AutoDetectOrientation,
        !Globals.HorizontalOrientation,
        Globals.VideoDepthBpp == 24,
        Globals.TvBorders,
      };

      if (Globals.SwVideoMode && !Globals.CompatibilityHacksVideo) {
        CharSequence[] items2 = {
          p.getResources().getString(R.string.mouse_keepaspectratio),
          p.getResources().getString(R.string.video_smooth),
          p.getResources().getString(R.string.video_immersive),
          p.getResources().getString(R.string.video_orientation_autodetect),
          p.getResources().getString(R.string.video_orientation_vertical),
          p.getResources().getString(R.string.video_bpp_24),
          p.getResources().getString(R.string.tv_borders),
          p.getResources().getString(R.string.video_separatethread),
        };
        boolean defaults2[] = {
          Globals.KeepAspectRatio,
          Globals.VideoLinearFilter,
          Globals.ImmersiveMode,
          Globals.AutoDetectOrientation,
          !Globals.HorizontalOrientation,
          Globals.VideoDepthBpp == 24,
          Globals.TvBorders,
          Globals.MultiThreadedVideo,
        };
        items = items2;
        defaults = defaults2;
      }

      if (Globals.Using_SDL_1_3) {
        CharSequence[] items2 = {
          p.getResources().getString(R.string.mouse_keepaspectratio),
        };
        boolean defaults2[] = {
          Globals.KeepAspectRatio,
        };
        items = items2;
        defaults = defaults2;
      }

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.video));
      builder.setMultiChoiceItems(items, defaults, new DialogInterface.OnMultiChoiceClickListener() {
        public void onClick(DialogInterface dialog, int item, boolean isChecked) {
          if (item == 0)
            Globals.KeepAspectRatio = isChecked;
          if (item == 1)
            Globals.VideoLinearFilter = isChecked;
          if (item == 2)
            Globals.ImmersiveMode = isChecked;
          if (item == 3)
            Globals.AutoDetectOrientation = isChecked;
          if (item == 4)
            Globals.HorizontalOrientation = !isChecked;
          if (item == 5)
            Globals.VideoDepthBpp = (isChecked ? 24 : 16);
          if (item == 6)
            Globals.TvBorders = isChecked;
          if (item == 7)
            Globals.MultiThreadedVideo = isChecked;
        }
      });
      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class ShowReadme extends Menu {
    String title(final MainActivity p) {
      return "Readme";
    }

    boolean enabled() {
      return true;
    }

    void run(final MainActivity p) {
      String readmes[] = Globals.ReadmeText.split("\\^");
      String lang = new String(Locale.getDefault().getLanguage()) + ":";
      if (p.isRunningOnOUYA())
        lang = "tv:";
      String readme = readmes[0];
      String buttonName = "", buttonUrl = "";
      for (String r : readmes) {
        if (r.startsWith(lang))
          readme = r.substring(lang.length());
        if (r.startsWith("button:")) {
          buttonName = r.substring("button:".length());
          if (buttonName.indexOf(":") != -1) {
            buttonUrl = buttonName.substring(buttonName.indexOf(":") + 1);
            buttonName = buttonName.substring(0, buttonName.indexOf(":"));
          }
        }
      }
      readme = readme.trim();
      if (readme.length() <= 2) {
        goBack(p);
        return;
      }
      TextView text = new TextView(p);
      text.setMaxLines(100);
      //text.setScroller(new Scroller(p));
      //text.setVerticalScrollBarEnabled(true);
      text.setText(readme);
      text.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
      text.setPadding(0, 5, 0, 20);
      text.setTextSize(20.0f);
      text.setGravity(Gravity.CENTER);
      text.setFocusable(false);
      text.setFocusableInTouchMode(false);
      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      ScrollView scroll = new ScrollView(p);
      scroll.setFocusable(false);
      scroll.setFocusableInTouchMode(false);
      scroll.addView(text, new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT));
      final Button ok = new Button(p);
      final AlertDialog alertDismiss[] = new AlertDialog[1];
      ok.setOnClickListener(new View.OnClickListener() {
        public void onClick(View v) {
          alertDismiss[0].cancel();
        }
      });
      ok.setText(R.string.ok);
      LinearLayout layout = new LinearLayout(p);
      layout.setOrientation(LinearLayout.VERTICAL);
      layout.addView(scroll);
      layout.addView(ok);
      if (buttonName.length() > 0) {
        Button cancel = new Button(p);
        cancel.setText(buttonName);
        final String url = buttonUrl;
        cancel.setOnClickListener(new View.OnClickListener() {
          public void onClick(View v) {
            if (url.length() > 0) {
              Intent i = new Intent(Intent.ACTION_VIEW);
              i.setData(Uri.parse(url));
              p.startActivity(i);
            }
            alertDismiss[0].cancel();
            System.exit(0);
          }
        });
        layout.addView(cancel);
      }
      builder.setView(layout);
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alertDismiss[0] = alert;
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class GyroscopeCalibration extends Menu {
    String title(final MainActivity p) {
      return "";
    }

    boolean enabled() {
      return false;
    }

    void run(final MainActivity p) {
      goBack(p);
    }
  }

  static class CommandlineConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.storage_commandline);
    }

    void run(final MainActivity p) {
      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.storage_commandline));

      final EditText edit = new EditText(p);
      edit.setFocusableInTouchMode(true);
      edit.setFocusable(true);
      if (Globals.CommandLine.length() == 0)
        Globals.CommandLine = "SDL_app";
      if (Globals.CommandLine.indexOf(" ") == -1)
        Globals.CommandLine += " ";
      edit.setText(Globals.CommandLine.substring(Globals.CommandLine.indexOf(" ")).replace(" ", "\n").replace("	", " "));
      edit.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE | InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
      edit.setMinLines(2);
      //edit.setMaxLines(100);
      builder.setView(edit);

      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.CommandLine = "SDL_app";
          String args[] = edit.getText().toString().split("\n");
          boolean firstArg = true;
          for (String arg : args) {
            Globals.CommandLine += " ";
            if (firstArg)
              Globals.CommandLine += arg;
            else
              Globals.CommandLine += arg.replace(" ", "	");
            firstArg = false;
          }
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class ResetToDefaultsConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.reset_config);
    }

    boolean enabled() {
      return true;
    }

    void run(final MainActivity p) {
      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.reset_config_ask));
      builder.setMessage(p.getResources().getString(R.string.reset_config_ask));

      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Settings.DeleteSdlConfigOnUpgradeAndRestart(p); // Never returns
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setNegativeButton(p.getResources().getString(R.string.cancel), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }
}

```

`Xorg/src/main/java/io/neoterm/SettingsMenuMouse.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.DialogInterface;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.graphics.RectF;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import androidx.appcompat.app.AlertDialog;
import io.neoterm.xorg.R;

import java.util.ArrayList;


class SettingsMenuMouse extends SettingsMenu {
  static class MouseConfigMainMenu extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.mouse_emulation);
    }

    boolean enabled() {
      return Globals.AppUsesMouse;
    }

    void run(final MainActivity p) {
      Menu options[] =
        {
          new DisplaySizeConfig(false),
          new LeftClickConfig(),
          new RightClickConfig(),
          new AdditionalMouseConfig(),
          new JoystickMouseConfig(),
          new TouchPressureMeasurementTool(),
          new CalibrateTouchscreenMenu(),
          new OkButton(),
        };
      showMenuOptionsList(p, options);
    }
  }

  static class DisplaySizeConfig extends Menu {
    boolean firstStart = false;

    DisplaySizeConfig() {
      this.firstStart = true;
    }

    DisplaySizeConfig(boolean firstStart) {
      this.firstStart = firstStart;
    }

    String title(final MainActivity p) {
      return p.getResources().getString(R.string.display_size_mouse);
    }

    void run(final MainActivity p) {
      CharSequence[] items = {
        p.getResources().getString(R.string.display_size_small),
        p.getResources().getString(R.string.display_size_small_touchpad),
        p.getResources().getString(R.string.display_size_large),
        p.getResources().getString(R.string.display_size_desktop),
      };
      int _size_small = 0;
      int _size_small_touchpad = 1;
      int _size_large = 2;
      int _size_desktop = 3;
      int _more_options = 4;

      if (!Globals.SwVideoMode) {
        CharSequence[] items2 = {
          p.getResources().getString(R.string.display_size_small_touchpad),
          p.getResources().getString(R.string.display_size_large),
          p.getResources().getString(R.string.display_size_desktop),
        };
        items = items2;
        _size_small_touchpad = 0;
        _size_large = 1;
        _size_desktop = 2;
        _size_small = 1000;
      }
      if (firstStart) {
        CharSequence[] items2 = {
          p.getResources().getString(R.string.display_size_small),
          p.getResources().getString(R.string.display_size_small_touchpad),
          p.getResources().getString(R.string.display_size_large),
          p.getResources().getString(R.string.display_size_desktop),
          p.getResources().getString(R.string.show_more_options),
        };
        items = items2;
        if (!Globals.SwVideoMode) {
          CharSequence[] items3 = {
            p.getResources().getString(R.string.display_size_small_touchpad),
            p.getResources().getString(R.string.display_size_large),
            p.getResources().getString(R.string.display_size_desktop),
            p.getResources().getString(R.string.show_more_options),
          };
          items = items3;
          _more_options = 3;
        }
      }
      // Java is so damn worse than C++11
      final int size_small = _size_small;
      final int size_small_touchpad = _size_small_touchpad;
      final int size_large = _size_large;
      final int size_desktop = _size_desktop;
      final int more_options = _more_options;

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.display_size);
      class ClickListener implements DialogInterface.OnClickListener {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          if (item == size_desktop) {
            Globals.LeftClickMethod = Mouse.LEFT_CLICK_NORMAL;
            Globals.RelativeMouseMovement = false;
            Globals.ShowScreenUnderFinger = Mouse.ZOOM_NONE;
            Globals.ForceHardwareMouse = true;
          }
          if (item == size_large) {
            Globals.LeftClickMethod = Mouse.LEFT_CLICK_NORMAL;
            Globals.RelativeMouseMovement = false;
            Globals.ShowScreenUnderFinger = Mouse.ZOOM_NONE;
            Globals.ForceHardwareMouse = false;
          }
          if (item == size_small) {
            Globals.LeftClickMethod = Mouse.LEFT_CLICK_NEAR_CURSOR;
            Globals.RelativeMouseMovement = false;
            Globals.ShowScreenUnderFinger = Mouse.ZOOM_MAGNIFIER;
            Globals.ForceHardwareMouse = false;
          }
          if (item == size_small_touchpad) {
            Globals.LeftClickMethod = Mouse.LEFT_CLICK_WITH_TAP_OR_TIMEOUT;
            Globals.RelativeMouseMovement = true;
            Globals.ShowScreenUnderFinger = Mouse.ZOOM_NONE;
            Globals.ForceHardwareMouse = false;
          }
          if (item == more_options) {
            menuStack.clear();
            new MainMenu().run(p);
            return;
          }
          goBack(p);
        }
      }
      builder.setItems(items, new ClickListener());
			/*
			else
				builder.setSingleChoiceItems(items,
					Globals.ShowScreenUnderFinger == Mouse.ZOOM_NONE ?
					( Globals.RelativeMouseMovement ? Globals.SwVideoMode ? 2 : 1 : 0 ) :
					( Globals.ShowScreenUnderFinger == Mouse.ZOOM_MAGNIFIER && Globals.SwVideoMode ) ? 1 :
					Globals.ShowScreenUnderFinger + 1,
					new ClickListener());
			*/
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class LeftClickConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.leftclick_question);
    }

    void run(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.leftclick_normal),
        p.getResources().getString(R.string.leftclick_near_cursor),
        p.getResources().getString(R.string.leftclick_multitouch),
        p.getResources().getString(R.string.leftclick_pressure),
        p.getResources().getString(R.string.rightclick_key),
        p.getResources().getString(R.string.leftclick_timeout),
        p.getResources().getString(R.string.leftclick_tap),
        p.getResources().getString(R.string.leftclick_tap_or_timeout)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.leftclick_question);
      builder.setSingleChoiceItems(items, Globals.LeftClickMethod, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          Globals.LeftClickMethod = item;
          if (item == Mouse.LEFT_CLICK_WITH_KEY)
            p.getVideoLayout().setOnKeyListener(new KeyRemapToolMouseClick(p, true));
          else if (item == Mouse.LEFT_CLICK_WITH_TIMEOUT || item == Mouse.LEFT_CLICK_WITH_TAP_OR_TIMEOUT)
            showLeftClickTimeoutConfig(p);
          else
            goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showLeftClickTimeoutConfig(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.leftclick_timeout_time_0),
        p.getResources().getString(R.string.leftclick_timeout_time_1),
        p.getResources().getString(R.string.leftclick_timeout_time_2),
        p.getResources().getString(R.string.leftclick_timeout_time_3),
        p.getResources().getString(R.string.leftclick_timeout_time_4)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.leftclick_timeout_time);
      builder.setSingleChoiceItems(items, Globals.LeftClickTimeout, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.LeftClickTimeout = item;
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class RightClickConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.rightclick_question);
    }

    boolean enabled() {
      return Globals.AppNeedsTwoButtonMouse;
    }

    void run(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.rightclick_none),
        p.getResources().getString(R.string.rightclick_multitouch),
        p.getResources().getString(R.string.rightclick_pressure),
        p.getResources().getString(R.string.rightclick_key),
        p.getResources().getString(R.string.leftclick_timeout)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.rightclick_question);
      builder.setSingleChoiceItems(items, Globals.RightClickMethod, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.RightClickMethod = item;
          dialog.dismiss();
          if (item == Mouse.RIGHT_CLICK_WITH_KEY)
            p.getVideoLayout().setOnKeyListener(new KeyRemapToolMouseClick(p, false));
          else if (item == Mouse.RIGHT_CLICK_WITH_TIMEOUT)
            showRightClickTimeoutConfig(p);
          else
            goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showRightClickTimeoutConfig(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.leftclick_timeout_time_0),
        p.getResources().getString(R.string.leftclick_timeout_time_1),
        p.getResources().getString(R.string.leftclick_timeout_time_2),
        p.getResources().getString(R.string.leftclick_timeout_time_3),
        p.getResources().getString(R.string.leftclick_timeout_time_4)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.leftclick_timeout_time);
      builder.setSingleChoiceItems(items, Globals.RightClickTimeout, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.RightClickTimeout = item;
          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  public static class KeyRemapToolMouseClick implements View.OnKeyListener {
    MainActivity p;
    boolean leftClick;

    public KeyRemapToolMouseClick(MainActivity _p, boolean leftClick) {
      p = _p;
      p.setText(p.getResources().getString(R.string.remap_hwkeys_press));
      this.leftClick = leftClick;
    }

    @Override
    public boolean onKey(View v, int keyCode, KeyEvent event) {
      p.getVideoLayout().setOnKeyListener(null);
      int keyIndex = keyCode;
      if (keyIndex < 0)
        keyIndex = 0;
      if (keyIndex > SDL_Keys.JAVA_KEYCODE_LAST)
        keyIndex = 0;

      if (leftClick)
        Globals.LeftClickKey = keyIndex;
      else
        Globals.RightClickKey = keyIndex;

      goBack(p);
      return true;
    }
  }

  static class AdditionalMouseConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.advanced);
    }

    void run(final MainActivity p) {
      CharSequence[] items = {
        p.getResources().getString(R.string.mouse_hover_jitter_filter),
        p.getResources().getString(R.string.mouse_joystickmouse),
        p.getResources().getString(R.string.click_with_dpadcenter),
        p.getResources().getString(R.string.mouse_relative),
        p.getResources().getString(R.string.mouse_gyroscope_mouse),
        p.getResources().getString(R.string.mouse_finger_hover),
        p.getResources().getString(R.string.mouse_subframe_touch_events),
      };

      boolean defaults[] = {
        Globals.HoverJitterFilter,
        Globals.MoveMouseWithJoystick,
        Globals.ClickMouseWithDpad,
        Globals.RelativeMouseMovement,
        Globals.MoveMouseWithGyroscope,
        Globals.FingerHover,
        Globals.GenerateSubframeTouchEvents,
      };

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(p.getResources().getString(R.string.advanced));
      builder.setMultiChoiceItems(items, defaults, new DialogInterface.OnMultiChoiceClickListener() {
        public void onClick(DialogInterface dialog, int item, boolean isChecked) {
          if (item == 0)
            Globals.HoverJitterFilter = isChecked;
          if (item == 1)
            Globals.MoveMouseWithJoystick = isChecked;
          if (item == 2)
            Globals.ClickMouseWithDpad = isChecked;
          if (item == 3)
            Globals.RelativeMouseMovement = isChecked;
          if (item == 4)
            Globals.MoveMouseWithGyroscope = isChecked;
          if (item == 5)
            Globals.FingerHover = isChecked;
          if (item == 6)
            Globals.GenerateSubframeTouchEvents = isChecked;
        }
      });
      builder.setPositiveButton(p.getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          dialog.dismiss();
          showGyroscopeMouseMovementConfig(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showGyroscopeMouseMovementConfig(final MainActivity p) {
      if (!Globals.MoveMouseWithGyroscope) {
        showRelativeMouseMovementConfig(p);
        return;
      }

      final CharSequence[] items = {p.getResources().getString(R.string.accel_veryslow),
        p.getResources().getString(R.string.accel_slow),
        p.getResources().getString(R.string.accel_medium),
        p.getResources().getString(R.string.accel_fast),
        p.getResources().getString(R.string.accel_veryfast)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.mouse_gyroscope_mouse_sensitivity);
      builder.setSingleChoiceItems(items, Globals.MoveMouseWithGyroscopeSpeed, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.MoveMouseWithGyroscopeSpeed = item;

          dialog.dismiss();
          showRelativeMouseMovementConfig(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showRelativeMouseMovementConfig(final MainActivity p) {
      if (!Globals.RelativeMouseMovement) {
        goBack(p);
        return;
      }

      final CharSequence[] items = {p.getResources().getString(R.string.accel_veryslow),
        p.getResources().getString(R.string.accel_slow),
        p.getResources().getString(R.string.accel_medium),
        p.getResources().getString(R.string.accel_fast),
        p.getResources().getString(R.string.accel_veryfast)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.mouse_relative_speed);
      builder.setSingleChoiceItems(items, Globals.RelativeMouseMovementSpeed, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.RelativeMouseMovementSpeed = item;

          dialog.dismiss();
          showRelativeMouseMovementConfig1(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showRelativeMouseMovementConfig1(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.none),
        p.getResources().getString(R.string.accel_slow),
        p.getResources().getString(R.string.accel_medium),
        p.getResources().getString(R.string.accel_fast)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.mouse_relative_accel);
      builder.setSingleChoiceItems(items, Globals.RelativeMouseMovementAccel, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.RelativeMouseMovementAccel = item;

          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class JoystickMouseConfig extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.mouse_joystickmousespeed);
    }

    boolean enabled() {
      return Globals.MoveMouseWithJoystick;
    }

    ;

    void run(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.accel_slow),
        p.getResources().getString(R.string.accel_medium),
        p.getResources().getString(R.string.accel_fast)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.mouse_joystickmousespeed);
      builder.setSingleChoiceItems(items, Globals.MoveMouseWithJoystickSpeed, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.MoveMouseWithJoystickSpeed = item;

          dialog.dismiss();
          showJoystickMouseAccelConfig(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }

    static void showJoystickMouseAccelConfig(final MainActivity p) {
      final CharSequence[] items = {p.getResources().getString(R.string.none),
        p.getResources().getString(R.string.accel_slow),
        p.getResources().getString(R.string.accel_medium),
        p.getResources().getString(R.string.accel_fast)};

      AlertDialog.Builder builder = new AlertDialog.Builder(p);
      builder.setTitle(R.string.mouse_joystickmouseaccel);
      builder.setSingleChoiceItems(items, Globals.MoveMouseWithJoystickAccel, new DialogInterface.OnClickListener() {
        public void onClick(DialogInterface dialog, int item) {
          Globals.MoveMouseWithJoystickAccel = item;

          dialog.dismiss();
          goBack(p);
        }
      });
      builder.setOnCancelListener(new DialogInterface.OnCancelListener() {
        public void onCancel(DialogInterface dialog) {
          goBack(p);
        }
      });
      AlertDialog alert = builder.create();
      alert.setOwnerActivity(p);
      alert.show();
    }
  }

  static class TouchPressureMeasurementTool extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.measurepressure);
    }

    boolean enabled() {
      return Globals.RightClickMethod == Mouse.RIGHT_CLICK_WITH_PRESSURE ||
        Globals.LeftClickMethod == Mouse.LEFT_CLICK_WITH_PRESSURE;
    }

    ;

    void run(final MainActivity p) {
      p.setText(p.getResources().getString(R.string.measurepressure_touchplease));
      p.getVideoLayout().setOnTouchListener(new TouchMeasurementTool(p));
    }

    public static class TouchMeasurementTool implements View.OnTouchListener {
      MainActivity p;
      ArrayList<Integer> force = new ArrayList<Integer>();
      ArrayList<Integer> radius = new ArrayList<Integer>();
      static final int maxEventAmount = 100;

      public TouchMeasurementTool(MainActivity _p) {
        p = _p;
      }

      @Override
      public boolean onTouch(View v, MotionEvent ev) {
        force.add(new Integer((int) (ev.getPressure() * 1000.0)));
        radius.add(new Integer((int) (ev.getSize() * 1000.0)));
        p.setText(p.getResources().getString(R.string.measurepressure_response, force.get(force.size() - 1), radius.get(radius.size() - 1)));
        try {
          Thread.sleep(10L);
        } catch (InterruptedException e) {
        }

        if (force.size() >= maxEventAmount) {
          p.getVideoLayout().setOnTouchListener(null);
          Globals.ClickScreenPressure = getAverageForce();
          Globals.ClickScreenTouchspotSize = getAverageRadius();
          Log.i("SDL", "SDL: measured average force " + Globals.ClickScreenPressure + " radius " + Globals.ClickScreenTouchspotSize);
          goBack(p);
        }
        return true;
      }

      int getAverageForce() {
        int avg = 0;
        for (Integer f : force) {
          avg += f;
        }
        return avg / force.size();
      }

      int getAverageRadius() {
        int avg = 0;
        for (Integer r : radius) {
          avg += r;
        }
        return avg / radius.size();
      }
    }
  }

  static class CalibrateTouchscreenMenu extends Menu {
    String title(final MainActivity p) {
      return p.getResources().getString(R.string.calibrate_touchscreen);
    }

    //boolean enabled() { return true; };
    void run(final MainActivity p) {
      p.setText(p.getResources().getString(R.string.calibrate_touchscreen_touch));
      Globals.TouchscreenCalibration[0] = 0;
      Globals.TouchscreenCalibration[1] = 0;
      Globals.TouchscreenCalibration[2] = 0;
      Globals.TouchscreenCalibration[3] = 0;
      ScreenEdgesCalibrationTool tool = new ScreenEdgesCalibrationTool(p);
      p.getVideoLayout().setOnTouchListener(tool);
      p.getVideoLayout().setOnKeyListener(tool);
    }

    static class ScreenEdgesCalibrationTool implements View.OnTouchListener, View.OnKeyListener {
      MainActivity p;
      ImageView img;
      Bitmap bmp;

      public ScreenEdgesCalibrationTool(MainActivity _p) {
        p = _p;
        img = new ImageView(p);
        img.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.FILL_PARENT));
        img.setScaleType(ImageView.ScaleType.MATRIX);
        bmp = BitmapFactory.decodeResource(p.getResources(), R.drawable.calibrate);
        img.setImageBitmap(bmp);
        Matrix m = new Matrix();
        RectF src = new RectF(0, 0, bmp.getWidth(), bmp.getHeight());
        RectF dst = new RectF(Globals.TouchscreenCalibration[0], Globals.TouchscreenCalibration[1],
          Globals.TouchscreenCalibration[2], Globals.TouchscreenCalibration[3]);
        m.setRectToRect(src, dst, Matrix.ScaleToFit.FILL);
        img.setImageMatrix(m);
        p.getVideoLayout().addView(img);
      }

      @Override
      public boolean onTouch(View v, MotionEvent ev) {
        if (Globals.TouchscreenCalibration[0] == Globals.TouchscreenCalibration[1] &&
          Globals.TouchscreenCalibration[1] == Globals.TouchscreenCalibration[2] &&
          Globals.TouchscreenCalibration[2] == Globals.TouchscreenCalibration[3]) {
          Globals.TouchscreenCalibration[0] = (int) ev.getX();
          Globals.TouchscreenCalibration[1] = (int) ev.getY();
          Globals.TouchscreenCalibration[2] = (int) ev.getX();
          Globals.TouchscreenCalibration[3] = (int) ev.getY();
        }
        if (ev.getX() < Globals.TouchscreenCalibration[0])
          Globals.TouchscreenCalibration[0] = (int) ev.getX();
        if (ev.getY() < Globals.TouchscreenCalibration[1])
          Globals.TouchscreenCalibration[1] = (int) ev.getY();
        if (ev.getX() > Globals.TouchscreenCalibration[2])
          Globals.TouchscreenCalibration[2] = (int) ev.getX();
        if (ev.getY() > Globals.TouchscreenCalibration[3])
          Globals.TouchscreenCalibration[3] = (int) ev.getY();
        Matrix m = new Matrix();
        RectF src = new RectF(0, 0, bmp.getWidth(), bmp.getHeight());
        RectF dst = new RectF(Globals.TouchscreenCalibration[0], Globals.TouchscreenCalibration[1],
          Globals.TouchscreenCalibration[2], Globals.TouchscreenCalibration[3]);
        m.setRectToRect(src, dst, Matrix.ScaleToFit.FILL);
        img.setImageMatrix(m);
        return true;
      }

      @Override
      public boolean onKey(View v, int keyCode, KeyEvent event) {
        p.getVideoLayout().setOnTouchListener(null);
        p.getVideoLayout().setOnKeyListener(null);
        p.getVideoLayout().removeView(img);
        goBack(p);
        return true;
      }
    }
  }
}


```

`Xorg/src/main/java/io/neoterm/Video.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import android.content.Context;
import android.content.Intent;
import android.hardware.input.InputManager;
import android.net.Uri;
import android.os.Build;
import android.util.DisplayMetrics;
import android.util.Log;
import android.view.*;
import android.widget.Toast;
import io.neoterm.xorg.NeoXorgViewClient;

import javax.microedition.khronos.egl.*;
import javax.microedition.khronos.opengles.GL10;
import java.lang.reflect.Method;


class Mouse {
  public static final int LEFT_CLICK_NORMAL = 0;
  public static final int LEFT_CLICK_NEAR_CURSOR = 1;
  public static final int LEFT_CLICK_WITH_MULTITOUCH = 2;
  public static final int LEFT_CLICK_WITH_PRESSURE = 3;
  public static final int LEFT_CLICK_WITH_KEY = 4;
  public static final int LEFT_CLICK_WITH_TIMEOUT = 5;
  public static final int LEFT_CLICK_WITH_TAP = 6;
  public static final int LEFT_CLICK_WITH_TAP_OR_TIMEOUT = 7;

  public static final int RIGHT_CLICK_NONE = 0;
  public static final int RIGHT_CLICK_WITH_MULTITOUCH = 1;
  public static final int RIGHT_CLICK_WITH_PRESSURE = 2;
  public static final int RIGHT_CLICK_WITH_KEY = 3;
  public static final int RIGHT_CLICK_WITH_TIMEOUT = 4;

  public static final int SDL_FINGER_DOWN = 0;
  public static final int SDL_FINGER_UP = 1;
  public static final int SDL_FINGER_MOVE = 2;
  public static final int SDL_FINGER_HOVER = 3;

  public static final int ZOOM_NONE = 0;
  public static final int ZOOM_MAGNIFIER = 1;

  public static final int MOUSE_HW_INPUT_FINGER = 0;
  public static final int MOUSE_HW_INPUT_STYLUS = 1;
  public static final int MOUSE_HW_INPUT_MOUSE = 2;

  public static final int MAX_HOVER_DISTANCE = 1024;
  public static final int HOVER_REDRAW_SCREEN = 1024 * 10;
  public static final float MAX_PRESSURE = 1024.0f;
}

abstract class DifferentTouchInput {
  public abstract void process(final MotionEvent event);

  public abstract void processGenericEvent(final MotionEvent event);

  public static int ExternalMouseDetected = Mouse.MOUSE_HW_INPUT_FINGER;

  public static DifferentTouchInput touchInput = getInstance();

  public static DifferentTouchInput getInstance() {
    boolean multiTouchAvailable1 = false;
    boolean multiTouchAvailable2 = false;
    // Not checking for getX(int), getY(int) etc 'cause I'm lazy
    Method methods[] = MotionEvent.class.getDeclaredMethods();
    for (Method m : methods) {
      if (m.getName().equals("getPointerCount"))
        multiTouchAvailable1 = true;
      if (m.getName().equals("getPointerId"))
        multiTouchAvailable2 = true;
    }
    try {
      Log.i("SDL", "Device: " + Build.DEVICE);
      Log.i("SDL", "Device name: " + Build.DISPLAY);
      Log.i("SDL", "Device model: " + Build.MODEL);
      Log.i("SDL", "Device board: " + Build.BOARD);
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
        //return IcsTouchInput.Holder.sInstance;
        return AutoDetectTouchInput.Holder.sInstance;
      }
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD)
        return GingerbreadTouchInput.Holder.sInstance;
      if (multiTouchAvailable1 && multiTouchAvailable2)
        return MultiTouchInput.Holder.sInstance;
      else
        return SingleTouchInput.Holder.sInstance;
    } catch (Exception e) {
      try {
        if (multiTouchAvailable1 && multiTouchAvailable2)
          return MultiTouchInput.Holder.sInstance;
        else
          return SingleTouchInput.Holder.sInstance;
      } catch (Exception ee) {
        return SingleTouchInput.Holder.sInstance;
      }
    }
  }

  private static class SingleTouchInput extends DifferentTouchInput {
    private static class Holder {
      private static final SingleTouchInput sInstance = new SingleTouchInput();
    }

    @Override
    public void processGenericEvent(final MotionEvent event) {
      process(event);
    }

    public void process(final MotionEvent event) {
      int action = -1;
      if (event.getAction() == MotionEvent.ACTION_DOWN)
        action = Mouse.SDL_FINGER_DOWN;
      if (event.getAction() == MotionEvent.ACTION_UP)
        action = Mouse.SDL_FINGER_UP;
      if (event.getAction() == MotionEvent.ACTION_MOVE)
        action = Mouse.SDL_FINGER_MOVE;
      if (action >= 0)
        DemoGLSurfaceView.nativeMotionEvent((int) event.getX(), (int) event.getY(), action, 0,
          (int) (event.getPressure() * Mouse.MAX_PRESSURE),
          (int) (event.getSize() * Mouse.MAX_PRESSURE));
    }
  }

  private static class MultiTouchInput extends DifferentTouchInput {
    public static final int TOUCH_EVENTS_MAX = 16; // Max multitouch pointers

    private class touchEvent {
      public boolean down = false;
      public int x = 0;
      public int y = 0;
      public int pressure = 0;
      public int size = 0;
    }

    protected touchEvent touchEvents[];

    MultiTouchInput() {
      touchEvents = new touchEvent[TOUCH_EVENTS_MAX];
      for (int i = 0; i < TOUCH_EVENTS_MAX; i++)
        touchEvents[i] = new touchEvent();
    }

    private static class Holder {
      private static final MultiTouchInput sInstance = new MultiTouchInput();
    }

    public void processGenericEvent(final MotionEvent event) {
      process(event);
    }

    public void process(final MotionEvent event) {
      int action = -1;

      //Log.i("SDL", "Got motion event, type " + (int)(event.getAction()) + " X " + (int)event.getX() + " Y " + (int)event.getY());
      if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP ||
        (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_CANCEL) {
        action = Mouse.SDL_FINGER_UP;
        for (int i = 0; i < TOUCH_EVENTS_MAX; i++) {
          if (touchEvents[i].down) {
            touchEvents[i].down = false;
            DemoGLSurfaceView.nativeMotionEvent(touchEvents[i].x, touchEvents[i].y, action, i, touchEvents[i].pressure, touchEvents[i].size);
          }
        }
      }
      if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
        action = Mouse.SDL_FINGER_DOWN;
        for (int i = 0; i < event.getPointerCount(); i++) {
          int id = event.getPointerId(i);
          if (id >= TOUCH_EVENTS_MAX)
            id = TOUCH_EVENTS_MAX - 1;
          touchEvents[id].down = true;
          touchEvents[id].x = (int) event.getX(i);
          touchEvents[id].y = (int) event.getY(i);
          touchEvents[id].pressure = (int) (event.getPressure(i) * Mouse.MAX_PRESSURE);
          touchEvents[id].size = (int) (event.getSize(i) * Mouse.MAX_PRESSURE);
          DemoGLSurfaceView.nativeMotionEvent(touchEvents[id].x, touchEvents[id].y, action, id, touchEvents[id].pressure, touchEvents[id].size);
        }
      }
      if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_MOVE ||
        (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_DOWN ||
        (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP) {
				/*
				String s = "MOVE: ptrs " + event.getPointerCount();
				for( int i = 0 ; i < event.getPointerCount(); i++ )
				{
					s += " p" + event.getPointerId(i) + "=" + (int)event.getX(i) + ":" + (int)event.getY(i);
				}
				Log.i("SDL", s);
				*/
        int pointerReleased = -1;
        if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_POINTER_UP)
          pointerReleased = (event.getAction() & MotionEvent.ACTION_POINTER_INDEX_MASK) >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;

        for (int id = 0; id < TOUCH_EVENTS_MAX; id++) {
          int ii;
          for (ii = 0; ii < event.getPointerCount(); ii++) {
            if (id == event.getPointerId(ii))
              break;
          }
          if (ii >= event.getPointerCount()) {
            // Up event
            if (touchEvents[id].down) {
              action = Mouse.SDL_FINGER_UP;
              touchEvents[id].down = false;
              DemoGLSurfaceView.nativeMotionEvent(touchEvents[id].x, touchEvents[id].y, action, id, touchEvents[id].pressure, touchEvents[id].size);
            }
          } else {
            if (pointerReleased == id && touchEvents[pointerReleased].down) {
              action = Mouse.SDL_FINGER_UP;
              touchEvents[id].down = false;
            } else if (touchEvents[id].down) {
              action = Mouse.SDL_FINGER_MOVE;
            } else {
              action = Mouse.SDL_FINGER_DOWN;
              touchEvents[id].down = true;
            }
            touchEvents[id].x = (int) event.getX(ii);
            touchEvents[id].y = (int) event.getY(ii);
            touchEvents[id].pressure = (int) (event.getPressure(ii) * Mouse.MAX_PRESSURE);
            touchEvents[id].size = (int) (event.getSize(ii) * Mouse.MAX_PRESSURE);
            DemoGLSurfaceView.nativeMotionEvent(touchEvents[id].x, touchEvents[id].y, action, id, touchEvents[id].pressure, touchEvents[id].size);
          }
        }
      }
    }
  }

  private static class GingerbreadTouchInput extends MultiTouchInput {
    private static class Holder {
      private static final GingerbreadTouchInput sInstance = new GingerbreadTouchInput();
    }

    GingerbreadTouchInput() {
      super();
    }

    public void process(final MotionEvent event) {
      int hwMouseEvent = ((event.getSource() & InputDevice.SOURCE_MOUSE) == InputDevice.SOURCE_MOUSE || Globals.ForceHardwareMouse) ? Mouse.MOUSE_HW_INPUT_MOUSE :
        ((event.getSource() & InputDevice.SOURCE_STYLUS) == InputDevice.SOURCE_STYLUS) ? Mouse.MOUSE_HW_INPUT_STYLUS :
          Mouse.MOUSE_HW_INPUT_FINGER;
      if (ExternalMouseDetected != hwMouseEvent) {
        ExternalMouseDetected = hwMouseEvent;
        DemoGLSurfaceView.nativeHardwareMouseDetected(hwMouseEvent);
      }
      super.process(event);
      if (!Globals.FingerHover && ExternalMouseDetected == Mouse.MOUSE_HW_INPUT_FINGER)
        return; // Finger hover disabled in settings
      if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_HOVER_MOVE) // Support bluetooth/USB mouse - available since Android 3.1
      {
        int action;
        // TODO: it is possible that multiple pointers return that event, but we're handling only pointer #0
        if (touchEvents[0].down)
          action = Mouse.SDL_FINGER_UP;
        else
          action = Mouse.SDL_FINGER_HOVER;
        touchEvents[0].down = false;
        touchEvents[0].x = (int) event.getX();
        touchEvents[0].y = (int) event.getY();
        touchEvents[0].pressure = Mouse.MAX_HOVER_DISTANCE;
        touchEvents[0].size = 0;
        //if( event.getAxisValue(MotionEvent.AXIS_DISTANCE) != 0.0f )
        InputDevice device = InputDevice.getDevice(event.getDeviceId());
        if (device != null && device.getMotionRange(MotionEvent.AXIS_DISTANCE) != null &&
          device.getMotionRange(MotionEvent.AXIS_DISTANCE).getRange() > 0.0f)
          touchEvents[0].pressure = (int) ((event.getAxisValue(MotionEvent.AXIS_DISTANCE) -
            device.getMotionRange(MotionEvent.AXIS_DISTANCE).getMin()) * Mouse.MAX_PRESSURE / device.getMotionRange(MotionEvent.AXIS_DISTANCE).getRange());
        DemoGLSurfaceView.nativeMotionEvent(touchEvents[0].x, touchEvents[0].y, action, 0, touchEvents[0].pressure, touchEvents[0].size);
      }
      if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_HOVER_EXIT) // Update screen for finger hover
      {
        touchEvents[0].pressure = Mouse.HOVER_REDRAW_SCREEN;
        touchEvents[0].size = 0;
        DemoGLSurfaceView.nativeMotionEvent(touchEvents[0].x, touchEvents[0].y, Mouse.SDL_FINGER_HOVER, 0, touchEvents[0].pressure, touchEvents[0].size);
      }
    }

    public void processGenericEvent(final MotionEvent event) {
      process(event);
    }
  }

  private static class IcsTouchInput extends GingerbreadTouchInput {
    private static class Holder {
      private static final IcsTouchInput sInstance = new IcsTouchInput();
    }

    private int buttonState = 0;

    public void process(final MotionEvent event) {
      //Log.i("SDL", "Got motion event, type " + (int)(event.getAction()) + " X " + (int)event.getX() + " Y " + (int)event.getY() + " buttons " + buttonState + " source " + event.getSource());
      int buttonStateNew = event.getButtonState();
      if (buttonStateNew != buttonState) {
        for (int i = 1; i <= MotionEvent.BUTTON_FORWARD; i *= 2) {
          if ((buttonStateNew & i) != (buttonState & i))
            DemoGLSurfaceView.nativeMouseButtonsPressed(i, ((buttonStateNew & i) == 0) ? 0 : 1);
        }
        if ((buttonStateNew & MotionEvent.BUTTON_STYLUS_PRIMARY) != (buttonState & MotionEvent.BUTTON_STYLUS_PRIMARY))
          DemoGLSurfaceView.nativeMouseButtonsPressed(2, ((buttonStateNew & MotionEvent.BUTTON_STYLUS_PRIMARY) == 0) ? 0 : 1);
        if ((buttonStateNew & MotionEvent.BUTTON_STYLUS_SECONDARY) != (buttonState & MotionEvent.BUTTON_STYLUS_SECONDARY))
          DemoGLSurfaceView.nativeMouseButtonsPressed(4, ((buttonStateNew & MotionEvent.BUTTON_STYLUS_SECONDARY) == 0) ? 0 : 1);
        buttonState = buttonStateNew;
      }
      super.process(event);
    }

    public void processGenericEvent(final MotionEvent event) {
      // Joysticks are supported since Honeycomb, but I don't care about it, because very few devices have it
      if ((event.getSource() & InputDevice.SOURCE_CLASS_JOYSTICK) == InputDevice.SOURCE_CLASS_JOYSTICK) {
        // event.getAxisValue(AXIS_HAT_X) and event.getAxisValue(AXIS_HAT_Y) are joystick arrow keys, on Nvidia Shield and some other joysticks
        DemoGLSurfaceView.nativeGamepadAnalogJoystickInput(
          event.getAxisValue(MotionEvent.AXIS_X), event.getAxisValue(MotionEvent.AXIS_Y),
          event.getAxisValue(MotionEvent.AXIS_Z), event.getAxisValue(MotionEvent.AXIS_RZ),
          event.getAxisValue(MotionEvent.AXIS_LTRIGGER), event.getAxisValue(MotionEvent.AXIS_RTRIGGER),
          event.getAxisValue(MotionEvent.AXIS_HAT_X), event.getAxisValue(MotionEvent.AXIS_HAT_Y),
          processGamepadDeviceId(event.getDevice()));
        return;
      }
      // Process mousewheel
      if (event.getAction() == MotionEvent.ACTION_SCROLL) {
        int scrollX = Math.round(event.getAxisValue(MotionEvent.AXIS_HSCROLL));
        int scrollY = Math.round(event.getAxisValue(MotionEvent.AXIS_VSCROLL));
        DemoGLSurfaceView.nativeMouseWheel(scrollX, scrollY);
        return;
      }
      super.processGenericEvent(event);
    }
  }

  private static class IcsTouchInputWithHistory extends IcsTouchInput {
    private static class Holder {
      private static final IcsTouchInputWithHistory sInstance = new IcsTouchInputWithHistory();
    }

    public void process(final MotionEvent event) {
      int ptr = 0; // Process only one touch event, because that's typically a pen/mouse
      for (ptr = 0; ptr < TOUCH_EVENTS_MAX; ptr++) {
        if (touchEvents[ptr].down)
          break;
      }
      if (ptr >= TOUCH_EVENTS_MAX)
        ptr = 0;
      //Log.i("SDL", "Got motion event, getHistorySize " + (int)(event.getHistorySize()) + " ptr " + ptr);

      for (int i = 0; i < event.getHistorySize(); i++) {
        DemoGLSurfaceView.nativeMotionEvent((int) event.getHistoricalX(i), (int) event.getHistoricalY(i),
          Mouse.SDL_FINGER_MOVE, ptr, (int) (event.getHistoricalPressure(i) * Mouse.MAX_PRESSURE), (int) (event.getHistoricalSize(i) * Mouse.MAX_PRESSURE));
      }
      super.process(event);
    }
  }

  private static class CrappyMtkTabletWithBrokenTouchDrivers extends IcsTouchInput {
    private static class Holder {
      private static final CrappyMtkTabletWithBrokenTouchDrivers sInstance = new CrappyMtkTabletWithBrokenTouchDrivers();
    }

    public void process(final MotionEvent event) {
      if ((event.getAction() & MotionEvent.ACTION_MASK) != MotionEvent.ACTION_HOVER_MOVE &&
        (event.getAction() & MotionEvent.ACTION_MASK) != MotionEvent.ACTION_HOVER_EXIT) // Ignore hover events, they are broken
        super.process(event);
    }

    public void processGenericEvent(final MotionEvent event) {
      if ((event.getAction() & MotionEvent.ACTION_MASK) != MotionEvent.ACTION_HOVER_MOVE &&
        (event.getAction() & MotionEvent.ACTION_MASK) != MotionEvent.ACTION_HOVER_EXIT) // Ignore hover events, they are broken
        super.processGenericEvent(event);
    }
  }

  private static class AutoDetectTouchInput extends IcsTouchInput {
    int tapCount = 0;
    boolean hover = false, fingerHover = false, tap = false;
    float hoverX = 0.0f, hoverY = 0.0f;
    long hoverTime = 0;
    float tapX = 0.0f, tapY = 0.0f;
    long tapTime = 0;
    float hoverTouchDistance = 0.0f;

    private static class Holder {
      private static final AutoDetectTouchInput sInstance = new AutoDetectTouchInput();
    }

    public void process(final MotionEvent event) {
      if (((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP ||
        (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN)) {
        tapCount++;
        if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) {
          tap = true;
          tapX = event.getX();
          tapY = event.getY();
          tapTime = System.currentTimeMillis();
          if (hover)
            Log.i("SDL", "Tap tapX " + event.getX() + " tapY " + event.getX());
        } else if (hover && System.currentTimeMillis() < hoverTime + 1000) {
          hoverTouchDistance += Math.abs(hoverX - event.getX()) + Math.abs(hoverY - event.getY());
          Log.i("SDL", "Finger down event.getX() " + event.getX() + " hoverX " + hoverX + " event.getY() " + event.getY() + " hoverY " + hoverY + " hoverTouchDistance " + hoverTouchDistance);
        }
      }
      if (tapCount >= 4) {
        int displayHeight = 800;
        try {
          DisplayMetrics dm = new DisplayMetrics();
          MainActivity.instance.getWindowManager().getDefaultDisplay().getMetrics(dm);
          displayHeight = Math.min(dm.widthPixels, dm.heightPixels);
        } catch (Exception eeeee) {
        }
        Log.i("SDL", "AutoDetectTouchInput: hoverTouchDistance " + hoverTouchDistance + " threshold " + displayHeight / 2 + " hover " + hover + " fingerHover " + fingerHover);
        if (hoverTouchDistance > displayHeight / 2) {
          if (Globals.AppUsesMouse)
            Toast.makeText(MainActivity.instance, "Detected buggy touch panel, enabling workarounds", Toast.LENGTH_SHORT).show();
          touchInput = CrappyMtkTabletWithBrokenTouchDrivers.Holder.sInstance;
        } else {
          if (fingerHover) {
            if (Globals.AppUsesMouse)
              Toast.makeText(MainActivity.instance, "Finger hover capability detected", Toast.LENGTH_SHORT).show();
            // Switch away from relative mouse input
            if (Globals.FingerHover && (Globals.RelativeMouseMovement || Globals.LeftClickMethod != Mouse.LEFT_CLICK_NORMAL)) {
              if (Globals.RelativeMouseMovement)
                Globals.ShowScreenUnderFinger = Mouse.ZOOM_MAGNIFIER;
              Globals.RelativeMouseMovement = false;
              Globals.LeftClickMethod = Mouse.LEFT_CLICK_NORMAL;
            }
            Settings.applyMouseEmulationOptions();
          }
          if (Globals.GenerateSubframeTouchEvents)
            touchInput = IcsTouchInputWithHistory.Holder.sInstance;
          else
            touchInput = IcsTouchInput.Holder.sInstance;
        }
      }
      super.process(event);
    }

    public void processGenericEvent(final MotionEvent event) {
      super.processGenericEvent(event);
      if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_HOVER_MOVE ||
        (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_HOVER_ENTER ||
        (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_HOVER_EXIT) {
        hover = true;
        hoverX = event.getX();
        hoverY = event.getY();
        hoverTime = System.currentTimeMillis();
        if (ExternalMouseDetected == 0 && (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_HOVER_MOVE)
          fingerHover = true;
        if (tap && System.currentTimeMillis() < tapTime + 1000) {
          tap = false;
          hoverTouchDistance += Math.abs(tapX - hoverX) + Math.abs(tapY - hoverY);
          Log.i("SDL", "Hover hoverX " + hoverX + " tapX " + tapX + " hoverY " + hoverX + " tapY " + tapY + " hoverTouchDistance " + hoverTouchDistance);
        }
      }
    }
  }

  private static int gamepadIds[] = new int[4]; // Maximum 4 gamepads at the moment

  public static int processGamepadDeviceId(InputDevice device) {
    if (device == null)
      return 0;
    int source = device.getSources();
    if ((source & InputDevice.SOURCE_CLASS_JOYSTICK) != InputDevice.SOURCE_CLASS_JOYSTICK &&
      (source & InputDevice.SOURCE_GAMEPAD) != InputDevice.SOURCE_GAMEPAD) {
      return 0;
    }
    int deviceId = device.getId();
    for (int i = 0; i < gamepadIds.length; i++) {
      if (gamepadIds[i] == deviceId)
        return i + 1;
    }
    for (int i = 0; i < gamepadIds.length; i++) {
      if (gamepadIds[i] == 0) {
        Log.i("SDL", "libSDL: gamepad added: deviceId " + deviceId + " gamepadId " + (i + 1));
        gamepadIds[i] = deviceId;
        return i + 1;
      }
    }
    return 0;
  }

  public static void registerInputManagerCallbacks(Context context) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
      JellyBeanInputManager.Holder.sInstance.register(context);
    }
  }

  private static class JellyBeanInputManager {
    private static class Holder {
      private static final JellyBeanInputManager sInstance = new JellyBeanInputManager();
    }

    private static class Listener implements InputManager.InputDeviceListener {
      public void onInputDeviceAdded(int deviceId) {
      }

      public void onInputDeviceChanged(int deviceId) {
        onInputDeviceRemoved(deviceId);
      }

      public void onInputDeviceRemoved(int deviceId) {
        for (int i = 0; i < gamepadIds.length; i++) {
          if (gamepadIds[i] == deviceId) {
            Log.i("SDL", "libSDL: gamepad removed: deviceId " + deviceId + " gamepadId " + (i + 1));
            gamepadIds[i] = 0;
          }
        }
      }
    }

    public void register(Context context) {
      InputManager manager = (InputManager) context.getSystemService(Context.INPUT_SERVICE);
      manager.registerInputDeviceListener(new Listener(), null);
    }
  }
}

@SuppressWarnings("JniMissingFunction")
class DemoRenderer extends GLSurfaceView_SDL.Renderer {
  public DemoRenderer(NeoXorgViewClient client) {
    mClient = client;
    Clipboard.get().setListener(mClient.getContext(), new Runnable() {
      public void run() {
        nativeClipboardChanged();
      }
    });
  }

  public void onSurfaceCreated(GL10 gl, EGLConfig config) {
    Log.i("SDL", "libSDL: DemoRenderer.onSurfaceCreated(): paused " + mPaused + " mFirstTimeStart " + mFirstTimeStart);
    mGlSurfaceCreated = true;
    mGl = gl;
    if (!mPaused && !mFirstTimeStart)
      nativeGlContextRecreated();
    mFirstTimeStart = false;
  }

  public void onSurfaceChanged(GL10 gl, int w, int h) {
    Log.i("SDL", "libSDL: DemoRenderer.onSurfaceChanged(): paused " + mPaused + " mFirstTimeStart " + mFirstTimeStart + " w " + w + " h " + h);
    if (w < h && Globals.HorizontalOrientation) {
      // Sometimes when Android awakes from lockscreen, portrait orientation is kept
      int x = w;
      w = h;
      h = x;
    }
    mWidth = w - w % 2;
    mHeight = h - h % 2;
    mGl = gl;
    nativeResize(mWidth, mHeight, Globals.KeepAspectRatio ? 1 : 0);
  }

  int mLastPendingResize = 0;

  public void onWindowResize(final int w, final int h) {
    if (mClient.isRunningOnOUYA())
      return; // TV screen is never resized, and this event will mess up TV borders
    Log.d("SDL", "libSDL: DemoRenderer.onWindowResize(): " + w + "x" + h);
    mLastPendingResize++;
    final int resizeThreadIndex = mLastPendingResize;
    mClient.getGLView().postDelayed(new Runnable() {
      public void run() {
        // Samsung multiwindow will swap screen dimensions when unlocking the lockscreen, sleep a while so we won't use these temporary values
        if (resizeThreadIndex != mLastPendingResize)
          return; // Avoid running this function multiple times in a row
        int ww = w - w % 2;
        int hh = h - h % 2;
        View topView = mClient.getWindow().peekDecorView();
        if (topView != null && Globals.ImmersiveMode) {
          ww = topView.getWidth() - topView.getWidth() % 2;
          hh = topView.getHeight() - topView.getHeight() % 2;
        }

        Display display = mClient.getWindowManager().getDefaultDisplay();

        if (mWidth != 0 && mHeight != 0 && (mWidth != ww || mHeight != hh)) {
          Log.i("SDL", "libSDL: DemoRenderer.onWindowResize(): screen size changed from " + mWidth + "x" + mHeight + " to " + ww + "x" + hh);
          if (Globals.SwVideoMode &&
            (Math.abs(display.getWidth() - ww) > display.getWidth() / 10 ||
              Math.abs(display.getHeight() - hh) > display.getHeight() / 10)) {
            Log.i("SDL", "Multiwindow detected - enabling screen orientation autodetection");
            Globals.AutoDetectOrientation = true;
            mClient.initScreenOrientation();
            DemoRenderer.super.ResetVideoSurface();
            DemoRenderer.super.onWindowResize(ww, hh);
          } else {
            Log.i("SDL", "System button bar hidden - re-init video to avoid black bar at the top");
            DemoRenderer.super.ResetVideoSurface();
            DemoRenderer.super.onWindowResize(ww, hh);
          }
        }
        if (mWidth == 0 && mHeight == 0) {
          if ((ww > hh) != (display.getWidth() > display.getHeight())) {
            Log.i("SDL", "Multiwindow detected - app window size " + ww + "x" + hh + " but display dimensions are " + display.getWidth() + "x" + display.getHeight());
            Globals.AutoDetectOrientation = true;
          }
        }
        if (Globals.AutoDetectOrientation && (ww > hh) != (mWidth > mHeight))
          Globals.HorizontalOrientation = (ww > hh);
      }
    }, 2000);
  }

  public void onSurfaceDestroyed() {
    Log.i("SDL", "libSDL: DemoRenderer.onSurfaceDestroyed(): paused " + mPaused + " mFirstTimeStart " + mFirstTimeStart);
    mGlSurfaceCreated = false;
    mGlContextLost = true;
    nativeGlContextLost();
  }

  ;

  public void onDrawFrame(GL10 gl) {
    mGl = gl;
    SwapBuffers();

    nativeInitJavaCallbacks();

    // Make main thread priority lower so audio thread won't get underrun
    // Thread.currentThread().setPriority((Thread.currentThread().getPriority() + Thread.MIN_PRIORITY)/2);

    mGlContextLost = false;

    Settings.Apply(mClient);
    Settings.nativeSetEnv("DISPLAY_RESOLUTION_WIDTH", String.valueOf(Math.max(mWidth, mHeight)));
    Settings.nativeSetEnv("DISPLAY_RESOLUTION_HEIGHT", String.valueOf(Math.min(mWidth, mHeight))); // In Kitkat with immersive mode, getWindowManager().getDefaultDisplay().getMetrics() return inaccurate height

    accelerometer = new NeoAccelerometerReader(mClient.getContext());
    if (Globals.MoveMouseWithGyroscope)
      startAccelerometerGyroscope(1);
    // Tweak video thread priority, if user selected big audio buffer
    if (Globals.AudioBufferConfig >= 2)
      Thread.currentThread().setPriority((Thread.NORM_PRIORITY + Thread.MIN_PRIORITY) / 2); // Lower than normal
    // Calls main() and never returns, hehe - we'll call eglSwapBuffers() from native code
    String commandline = Globals.CommandLine;
//		if( mClient.getIntent() != null && mClient.getIntent().getScheme() != null &&
//			mClient.getIntent().getScheme().compareTo(android.content.ContentResolver.SCHEME_FILE) == 0 &&
//			mClient.getIntent().getData() != null && mClient.getIntent().getData().getPath() != null )
//		{
//			commandline += " " + mClient.getIntent().getData().getPath();
//		}
    nativeInit(Globals.DataDir,
      commandline,
      ((Globals.SwVideoMode && Globals.MultiThreadedVideo) || Globals.CompatibilityHacksVideo) ? 1 : 0,
      0);
    System.exit(0); // The main() returns here - I don't bother with deinit stuff, just terminate process
  }

  public int swapBuffers() // Called from native code
  {
    if (!super.SwapBuffers() && Globals.NonBlockingSwapBuffers) {
      if (mRatelimitTouchEvents) {
        synchronized (this) {
          this.notify();
        }
      }
      return 0;
    }

    if (mGlContextLost) {
      mGlContextLost = false;
      Settings.SetupTouchscreenKeyboardGraphics(mClient.getContext()); // Reload on-screen buttons graphics
      super.SwapBuffers();
    }

    // Unblock event processing thread only after we've finished rendering
    if (mRatelimitTouchEvents) {
      synchronized (this) {
        this.notify();
      }
    }
    if (mClient.isScreenKeyboardShown() && !mClient.isKeyboardWithoutTextInputShown()) {
      try {
        Thread.sleep(50); // Give some time to the keyboard input thread
      } catch (Exception e) {
      }
      ;
    }

    // We will not receive onConfigurationChanged() inside MainActivity with SCREEN_ORIENTATION_SENSOR_LANDSCAPE
    // so we need to create a hacky frame counter to update screen orientation, because this call takes up some time
    mOrientationFrameHackyCounter++;
    if (mOrientationFrameHackyCounter > 100) {
      mOrientationFrameHackyCounter = 0;
      mClient.updateScreenOrientation();
    }

    return 1;
  }

  public void showScreenKeyboardWithoutTextInputField() // Called from native code
  {
    mClient.showScreenKeyboardWithoutTextInputField(Globals.TextInputKeyboard);
  }

  public void showInternalScreenKeyboard(int keyboard) // Called from native code
  {
    mClient.showScreenKeyboardWithoutTextInputField(keyboard);
  }

  public void showScreenKeyboard(final String oldText, int unused) // Called from native code
  {
    class Callback implements Runnable {
      public NeoXorgViewClient client;
      public String oldText;

      public void run() {
        client.showScreenKeyboard(oldText);
      }
    }
    Callback cb = new Callback();
    cb.client = mClient;
    cb.oldText = oldText;
    mClient.runOnUiThread(cb);
  }

  public void hideScreenKeyboard() // Called from native code
  {
    class Callback implements Runnable {
      public NeoXorgViewClient client;

      public void run() {
        client.hideScreenKeyboard();
      }
    }
    Callback cb = new Callback();
    cb.client = mClient;
    mClient.runOnUiThread(cb);
  }

  public int isScreenKeyboardShown() // Called from native code
  {
    return mClient.isScreenKeyboardShown() ? 1 : 0;
  }

  public void setScreenKeyboardHintMessage(String s) // Called from native code
  {
    mClient.setScreenKeyboardHintMessage(s);
  }

  public void startAccelerometerGyroscope(int started) // Called from native code
  {
    accelerometer.openedBySDL = (started != 0);
    if (accelerometer.openedBySDL && !mPaused)
      accelerometer.start();
    else
      accelerometer.stop();
  }

  public String getClipboardText() // Called from native code
  {
    return Clipboard.get().get(mClient.getContext());
  }

  public void setClipboardText(final String s) // Called from native code
  {
    Clipboard.get().set(mClient.getContext(), s);
  }

  public void exitApp() {
    nativeDone();
  }

  public void getAdvertisementParams(int params[]) {
  }

  public void setAdvertisementVisible(int visible) {

  }

  public void setAdvertisementPosition(int left, int top) {
  }

  public void requestNewAdvertisement() {
  }

  public boolean cloudSave(final String filename, final String saveId, final String dialogTitle, final String description, final String imageFile, final long playedTimeMs) {
    return false;
  }

  public boolean cloudLoad(String filename, String saveId, String dialogTitle) {
    return false;
  }

  public void openExternalApp(String pkgName, String activity, String url) {
    try {
      Intent i = new Intent();
      if (url != null && url.length() > 0) {
        i.setAction(Intent.ACTION_VIEW);
        i.setData(Uri.parse(url));
      }
      if (pkgName != null && activity != null && pkgName.length() > 0 && activity.length() > 0) {
        i.setClassName(pkgName, activity);
      }
      mClient.getContext().startActivity(i);
    } catch (Exception e) {
      Log.i("SDL", "libSDL: cannot start external app: " + e.toString());
    }
  }

  public void setSystemMousePointerVisible(int visible) {
    mClient.setSystemMousePointerVisible(visible);
  }

  public void restartMyself(String restartParams) {
  }

  public void setConfigOptionFromSDL(int option, int value) {
    Settings.setConfigOptionFromSDL(option, value);
  }

  private int PowerOf2(int i) {
    int value = 1;
    while (value < i)
      value <<= 1;
    return value;
  }

  private native void nativeInitJavaCallbacks();

  private native void nativeInit(String CurrentPath, String CommandLine, int multiThreadedVideo, int unused);

  private native void nativeResize(int w, int h, int keepAspectRatio);

  private native void nativeDone();

  private native void nativeGlContextLost();

  public native void nativeGlContextRecreated();

  public native void nativeGlContextLostAsyncEvent();

  public static native void nativeTextInput(int ascii, int unicode);

  public static native void nativeTextInputFinished();

  public static native void nativeClipboardChanged();

  private NeoXorgViewClient mClient = null;
  public AccelerometerReader accelerometer = null;

  private GL10 mGl = null;
  private EGL10 mEgl = null;
  private EGLDisplay mEglDisplay = null;
  private EGLSurface mEglSurface = null;
  private EGLContext mEglContext = null;
  private boolean mGlContextLost = false;
  public boolean mGlSurfaceCreated = false;
  public boolean mPaused = false;
  private boolean mFirstTimeStart = true;
  public int mWidth = 0;
  public int mHeight = 0;
  int mOrientationFrameHackyCounter = 0;

  public static final boolean mRatelimitTouchEvents = true; //(Build.VERSION.SDK_INT >= Build.VERSION_CODES.FROYO);
}

@SuppressWarnings("JniMissingFunction")
class DemoGLSurfaceView extends GLSurfaceView_SDL {

  public DemoGLSurfaceView(NeoXorgViewClient client) {
    super(client.getContext());
    mClient = client;
    setEGLConfigChooser(Globals.VideoDepthBpp, Globals.NeedDepthBuffer, Globals.NeedStencilBuffer, Globals.NeedGles2, Globals.NeedGles3);
    mRenderer = new DemoRenderer(client);
    setRenderer(mRenderer);
    DifferentTouchInput.registerInputManagerCallbacks(client.getContext());
  }

  @Override
  public boolean onKeyDown(int keyCode, final KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
      if ((event.getSource() & InputDevice.SOURCE_MOUSE) == InputDevice.SOURCE_MOUSE) {
        // Stupid Samsung and stupid Acer remaps right mouse button to BACK key
        nativeMouseButtonsPressed(2, 1);
        return true;
      } else if (mClient.isKeyboardWithoutTextInputShown()) {
        return true;
      }
    }

    if (nativeKey(keyCode, 1, event.getUnicodeChar(), DifferentTouchInput.processGamepadDeviceId(event.getDevice())) == 0)
      return super.onKeyDown(keyCode, event);

    return true;
  }

  @Override
  public boolean onKeyUp(int keyCode, final KeyEvent event) {
    if (keyCode == KeyEvent.KEYCODE_BACK) {
      if ((event.getSource() & InputDevice.SOURCE_MOUSE) == InputDevice.SOURCE_MOUSE) {
        // Stupid Samsung and stupid Acer remaps right mouse button to BACK key
        nativeMouseButtonsPressed(2, 0);
        return true;
      } else if (mClient.isKeyboardWithoutTextInputShown()) {
        mClient.showScreenKeyboardWithoutTextInputField(0); // Hide keyboard
        return true;
      }
    }

    if (nativeKey(keyCode, 0, event.getUnicodeChar(), DifferentTouchInput.processGamepadDeviceId(event.getDevice())) == 0)
      return super.onKeyUp(keyCode, event);

    //if( keyCode == KeyEvent.KEYCODE_BACK || keyCode == KeyEvent.KEYCODE_MENU )
    //	DimSystemStatusBar.get().dim(mClient._videoLayout);

    return true;
  }

  @Override
  public boolean onKeyMultiple(int keyCode, int repeatCount, final KeyEvent event) {
    if (event.getCharacters() != null) {
      // International text input
      for (int i = 0; i < event.getCharacters().length(); i++) {
        nativeKey(event.getKeyCode(), 1, event.getCharacters().codePointAt(i), 0);
        nativeKey(event.getKeyCode(), 0, event.getCharacters().codePointAt(i), 0);
      }
    }
    return true;
  }

  @Override
  public boolean onTouchEvent(final MotionEvent event) {
    if (getX() != 0)
      event.offsetLocation(-getX(), -getY());
    DifferentTouchInput.touchInput.process(event);
    if (DemoRenderer.mRatelimitTouchEvents) {
      limitEventRate(event);
    }
    return true;
  }

  ;

  @Override
  public boolean onGenericMotionEvent(final MotionEvent event) {
    DifferentTouchInput.touchInput.processGenericEvent(event);
    if (DemoRenderer.mRatelimitTouchEvents) {
      limitEventRate(event);
    }
    return true;
  }

  public void limitEventRate(final MotionEvent event) {
    // Wait a bit, and try to synchronize to app framerate, or event thread will eat all CPU and we'll lose FPS
    // With Froyo the rate of touch events seems to be limited by OS, but they are arriving faster then we're redrawing anyway
    if ((event.getAction() == MotionEvent.ACTION_MOVE ||
      event.getAction() == MotionEvent.ACTION_HOVER_MOVE)) {
      synchronized (mRenderer) {
        try {
          mRenderer.wait(300L); // And sometimes the app decides not to render at all, so this timeout should not be big.
        } catch (InterruptedException e) {
          Log.v("SDL", "DemoGLSurfaceView::limitEventRate(): Who dared to interrupt my slumber?");
          Thread.interrupted();
        }
      }
    }
  }

  public void exitApp() {
    mRenderer.exitApp();
  }

  ;

  @Override
  public void onPause() {
    Log.i("SDL", "libSDL: DemoGLSurfaceView.onPause(): mRenderer.mGlSurfaceCreated " + mRenderer.mGlSurfaceCreated + " mRenderer.mPaused " + mRenderer.mPaused + (mRenderer.mPaused ? " - not doing anything" : ""));
    if (mRenderer.mPaused)
      return;
    mRenderer.mPaused = true;
    super.onPause();
    mRenderer.nativeGlContextLostAsyncEvent();
    if (mRenderer.accelerometer != null) // For some reason it crashes here often - are we getting this event before initialization?
      mRenderer.accelerometer.stop();
  }

  ;

  public boolean isPaused() {
    return mRenderer.mPaused;
  }

  @Override
  public void onResume() {
    Log.i("SDL", "libSDL: DemoGLSurfaceView.onResume(): mRenderer.mGlSurfaceCreated " + mRenderer.mGlSurfaceCreated + " mRenderer.mPaused " + mRenderer.mPaused + (!mRenderer.mPaused ? " - not doing anything" : ""));
    if (!mRenderer.mPaused)
      return;
    mRenderer.mPaused = false;
    super.onResume();
    if (mRenderer.mGlSurfaceCreated && !mRenderer.mPaused || Globals.NonBlockingSwapBuffers)
      mRenderer.nativeGlContextRecreated();
    if (mRenderer.accelerometer != null && mRenderer.accelerometer.openedBySDL) // For some reason it crashes here often - are we getting this event before initialization?
      mRenderer.accelerometer.start();
  }

  ;

  DemoRenderer mRenderer;
  NeoXorgViewClient mClient;

  public static native void nativeMotionEvent(int x, int y, int action, int pointerId, int pressure, int radius);

  public static native int nativeKey(int keyCode, int down, int unicode, int gamepadId);

  public static native void nativeHardwareMouseDetected(int detected);

  public static native void nativeMouseButtonsPressed(int buttonId, int pressedState);

  public static native void nativeMouseWheel(int scrollX, int scrollY);

  public static native void nativeGamepadAnalogJoystickInput(float stick1x, float stick1y, float stick2x, float stick2y, float ltrigger, float rtrigger, float dpadx, float dpady, int gamepadId);

  public static native void nativeScreenVisibleRect(int x, int y, int w, int h);

  public static native void nativeScreenKeyboardShown(int shown);
}

```

`Xorg/src/main/java/io/neoterm/XZInputStream.java`:

```java
// DO NOT EDIT THIS FILE - it is automatically generated, ALL YOUR CHANGES WILL BE OVERWRITTEN, edit the file under $JAVA_SRC_PATH dir
/*
Simple DirectMedia Layer
Java source code (C) 2009-2014 Sergii Pylypenko

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
   claim that you wrote the original software. If you use this software
   in a product, an acknowledgment in the product documentation would be
   appreciated but is not required. 
2. Altered source versions must be plainly marked as such, and must not be
   misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/

package io.neoterm;

import java.io.IOException;
import java.io.InputStream;

/**
 * Decompresses a .xz file in streamed mode (no seeking).
 * This is a copy of code from http://git.tukaani.org/xz-java.git
 * but using liblzma and JNI instead of Java, because Java heap
 * is very limited, and we're hitting memory limit on emulator.
 */
public class XZInputStream extends InputStream {
  private long nativeData = 0;
  private InputStream in = null;
  private final byte[] inBuf = new byte[8192];
  private int inOffset = 0;
  private int inAvailable = 0;
  private boolean outBufEof = false;
  private int offsets[] = new int[2];

  private final byte[] tempBuf = new byte[1];

  public XZInputStream(InputStream in) throws IOException {
    this.in = in;
    if (in == null) {
      throw new NullPointerException("InputStream == null");
    }
    nativeData = nativeInit();
    if (nativeData == 0) {
      throw new OutOfMemoryError("Cannot initialize JNI liblzma object");
    }
  }

  @Override
  public int available() throws IOException {
    return 0; // Don't care
  }

  @Override
  public void close() throws IOException {
    synchronized (this) {
      if (nativeData != 0)
        nativeClose(nativeData);
      nativeData = 0;
      if (in != null) {
        try {
          in.close();
        } finally {
          in = null;
        }
      }
    }
  }

  @Override
  protected void finalize() throws IOException {
    try {
      close();
    } finally {
      try {
        super.finalize();
      } catch (Throwable t) {
        throw new AssertionError(t);
      }
    }
  }

  @Override
  public int read() throws IOException {
    return read(tempBuf, 0, 1) == -1 ? -1 : (tempBuf[0] & 0xFF);
  }

  @Override
  public int read(byte[] outBuf, int outOffset, int outCount) throws IOException {
    //Log.i("SDL", "XZInputStream.read: outOffset " + outOffset + " outCount " + outCount + " outBufEof " + outBufEof +
    //			" inOffset " + inOffset + " inAvailable " + inAvailable);
    if (outBufEof)
      return -1;
    if (outCount <= 0)
      return 0;

    int oldOutOffset = outOffset;

    if (inOffset >= inAvailable && inAvailable != -1) {
      inAvailable = in.read(inBuf, 0, inBuf.length);
      inOffset = 0;
      //Log.i("SDL", "XZInputStream.read: in.read: inOffset " + inOffset + " inAvailable " + inAvailable);
    }

    offsets[0] = inOffset;
    offsets[1] = outOffset;
    int ret = nativeRead(nativeData, inBuf, inAvailable, outBuf, outCount, offsets);
    inOffset = offsets[0];
    outOffset = offsets[1];
    //Log.i("SDL", "XZInputStream.read: nativeRead: outOffset " + outOffset + " outCount " + outCount + " outBufEof " + outBufEof +
    //			" inOffset " + inOffset + " inAvailable " + inAvailable + " ret " + ret);

    if (ret != 0) {
      if (ret == 1) {
        if (inOffset < inAvailable)
          throw new IOException("Garbage at the end of LZMA stream");
        if (inAvailable != -1)
          inAvailable = in.read(inBuf, 0, inBuf.length);
        if (inAvailable != -1)
          throw new IOException("Garbage at the end of LZMA stream");
        outBufEof = true;
      } else {
        throw new IOException("LZMA error " + ret);
      }
    }

    //Log.i("SDL", "XZInputStream.read: returning " + (outOffset - oldOutOffset));
    return outOffset - oldOutOffset;
  }

  private native long nativeInit();

  private native void nativeClose(long nativeData);

  private native int nativeRead(long nativeData, byte[] inBuf, int inAvailable, byte[] outBuf, int outCount, int[] offsets);
}


```

`Xorg/src/main/java/io/neoterm/xorg/NeoXorgViewClient.java`:

```java
package io.neoterm.xorg;

import android.content.Context;
import android.view.Window;
import android.view.WindowManager;
import io.neoterm.NeoGLView;

/**
 * @author kiva
 */

public interface NeoXorgViewClient {
  Context getContext();

  boolean isKeyboardWithoutTextInputShown();

  void showScreenKeyboardWithoutTextInputField(int flags);

  void setScreenKeyboardHintMessage(String hideMessage);

  boolean isScreenKeyboardShown();

  void showScreenKeyboard(String message);

  void hideScreenKeyboard();

  void runOnUiThread(Runnable runnable);

  void updateScreenOrientation();

  void initScreenOrientation();

  boolean isRunningOnOUYA();

  NeoGLView getGLView();

  Window getWindow();

  WindowManager getWindowManager();

  void setSystemMousePointerVisible(int visible);

  boolean isPaused();
}

```

`Xorg/src/main/res/values-zh/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="init">初始化中</string>
  <string name="please_wait">正在下载数据,请稍候</string>

  <string name="device_config">设备配置</string>
  <string name="device_change_cfg">更改设备配置</string>

  <string name="download_unneeded">没有需要下载的内容</string>
  <string name="connecting_to">正在连接到 %s</string>
  <string name="failed_connecting_to">连接到 %s 失败</string>
  <string name="error_connecting_to">%s 连接出错</string>
  <string name="dl_from">正在从 %s 下载数据</string>
  <string name="error_dl_from">从 %s 下载数据时出错</string>
  <string name="error_write">写入到 %s 时出错</string>
  <string name="dl_progress">%1$.0f%% 已完成: 文件 %2$s</string>
  <string name="dl_finished">已完成</string>

  <string name="storage_phone">内部储存 - %d MB 空闲</string>
  <string name="storage_sd">SD卡储存 - %d MB 空闲</string>
  <string name="storage_custom">自定义目录</string>
  <string name="storage_commandline">命令行参数，每行一个参数</string>
  <string name="storage_question">数据文件安装位置</string>
  <string name="optional_downloads">下载</string>
  <string name="downloads">下载</string>
  <string name="ok">完成</string>
  <string name="cancel">取消</string>

  <string name="controls_arrows">箭头 / 操纵杆 / 方向键</string>
  <string name="controls_trackball">轨迹球</string>
  <string name="controls_accel">加速度计</string>
  <string name="controls_touch">只使用触屏</string>
  <string name="controls_question">您的设备有哪些导航键？</string>

  <string name="controls_additional">附加控制</string>
  <string name="controls_screenkb">屏幕键盘</string>
  <string name="controls_accelnav">加速度计</string>

  <string name="controls_screenkb_size">屏幕键盘大小</string>
  <string name="controls_screenkb_drawsize">按钮大小</string>
  <string name="controls_screenkb_large">大</string>
  <string name="controls_screenkb_medium">中</string>
  <string name="controls_screenkb_small">小</string>
  <string name="controls_screenkb_tiny">微小</string>
  <string name="controls_screenkb_custom">自定义</string>
  <string name="controls_screenkb_theme">屏幕键盘主题</string>
  <string name="controls_screenkb_by">%1$s by %2$s</string>
  <string name="controls_screenkb_transparency">屏幕键盘透明度</string>
  <string name="controls_screenkb_trans_0">隐形</string>
  <string name="controls_screenkb_trans_1">半隐形</string>
  <string name="controls_screenkb_trans_2">透明</string>
  <string name="controls_screenkb_trans_3">半透明</string>
  <string name="controls_screenkb_trans_4">不透明</string>

  <string name="trackball_no_dampening">无阻碍</string>
  <string name="trackball_fast">快</string>
  <string name="trackball_medium">中</string>
  <string name="trackball_slow">慢</string>
  <string name="trackball_question">轨迹球阻碍</string>

  <string name="accel_veryfast">非常快</string>
  <string name="accel_fast">快</string>
  <string name="accel_medium">中</string>
  <string name="accel_slow">慢</string>
  <string name="accel_veryslow">非常慢</string>
  <string name="accel_question">加速度计灵敏度</string>

  <string name="accel_floating">Floating</string>
  <string name="accel_fixed_start">在应用程序启动时修复</string>
  <string name="accel_fixed_horiz">Fixed to table desk orientation</string>
  <string name="accel_question_center">加速度计中心位置</string>

  <string name="mouse_emulation">鼠标模拟</string>
  <string name="rightclick_question">单击鼠标右键</string>
  <string name="rightclick_menu">菜单键</string>
  <string name="rightclick_key">物理按键</string>
  <string name="rightclick_multitouch">双指触摸</string>
  <string name="rightclick_pressure">使用按压力度</string>
  <string name="rightclick_none">禁用鼠标右键</string>

  <string name="leftclick_question">鼠标左键单击</string>
  <string name="leftclick_normal">正常</string>
  <string name="leftclick_near_cursor">触摸靠近鼠标光标</string>
  <string name="leftclick_multitouch">双指触摸</string>
  <string name="leftclick_pressure">使用按压力度</string>
  <string name="leftclick_dpadcenter">轨迹球点击 / 操纵杆中心</string>
  <string name="leftclick_timeout">长按一个点</string>
  <string name="leftclick_tap">点击</string>
  <string name="leftclick_tap_or_timeout">点击或长按</string>
  <string name="leftclick_timeout_time">长按超时</string>
  <string name="leftclick_timeout_time_0">0.3 秒</string>
  <string name="leftclick_timeout_time_1">0.5 秒</string>
  <string name="leftclick_timeout_time_2">0.7 秒</string>
  <string name="leftclick_timeout_time_3">1 秒</string>
  <string name="leftclick_timeout_time_4">1.5 秒</string>
  <string name="click_with_dpadcenter">左键点击和轨迹球点击 / 操纵杆中心</string>

  <string name="advanced">高级功能</string>
  <string name="mouse_keepaspectratio">保持4:3的屏幕宽高比</string>
  <string name="mouse_showcreenunderfinger">在单独的窗口中显示屏幕</string>
  <string name="mouse_showcreenunderfinger2">屏幕放大镜</string>
  <string name="mouse_joystickmouse">使用操纵杆或轨迹球移动鼠标</string>
  <string name="mouse_joystickmousespeed">使用操纵杆移动鼠标时的速度</string>
  <string name="mouse_joystickmouseaccel">使用操纵杆加速移动鼠标</string>
  <string name="mouse_relative">鼠标相对移动（笔记本模式）</string>
  <string name="mouse_relative_speed">鼠标相对移动速度</string>
  <string name="mouse_relative_accel">鼠标相对移动加速</string>
  <string name="mouse_hover_jitter_filter">过滤指针/手指的抖动</string>
  <string name="mouse_gyroscope_mouse">用陀螺仪控制鼠标移动</string>
  <string name="mouse_gyroscope_mouse_sensitivity">陀螺仪灵敏度</string>
  <string name="mouse_finger_hover">手指抖动</string>
  <string name="mouse_subframe_touch_events">每一帧的多点触摸事件</string>

  <string name="none">无</string>

  <string name="measurepressure">校准触摸屏压力</string>
  <string name="measurepressure_touchplease">请将手指滑过屏幕两秒钟</string>
  <string name="measurepressure_response">压力 %1$03d 半径 %2$03d</string>

  <string name="audiobuf_verysmall">非常小（较新的设备，延迟低）</string>
  <string name="audiobuf_small">小</string>
  <string name="audiobuf_medium">中等</string>
  <string name="audiobuf_large">大（较老的设备，如果声音不稳定请选此项）</string>
  <string name="audiobuf_question">音频缓冲大小</string>

  <string name="remap_hwkeys">映射物理按键</string>
  <string name="remap_hwkeys_press">按下任意按键 除了HOME键和POWER键，如音量键</string>
  <string name="remap_hwkeys_select">选择SDL按键</string>
  <string name="remap_hwkeys_select_simple">选择动作</string>
  <string name="remap_hwkeys_select_more_keys">显示所有按键</string>

  <string name="remap_screenkb">映射屏幕控件</string>
  <string name="remap_screenkb_joystick">手柄</string>
  <string name="remap_screenkb_button">按钮</string>
  <string name="remap_screenkb_button_text">文本输入按钮</string>
  <string name="remap_screenkb_button_gestures">双指手势</string>
  <string name="remap_screenkb_button_gestures_sensitivity">双指手势灵敏度</string>
  <string name="remap_screenkb_button_zoomin">双指放大</string>
  <string name="remap_screenkb_button_zoomout">双指缩小</string>
  <string name="remap_screenkb_button_rotateleft">双指向左旋转</string>
  <string name="remap_screenkb_button_rotateright">双指向右旋转</string>

  <string name="screenkb_custom_layout">自定义屏幕键盘布局</string>
  <string name="screenkb_custom_layout_help">按返回键结束，在空白区域滑动调整按钮大小</string>
  <string name="screenkb_floating_joystick">浮动操纵杆</string>

  <string name="calibrate_touchscreen">校准触摸屏</string>
  <string name="calibrate_touchscreen_touch">触摸屏幕的所有边缘，按返回键结束</string>

  <string name="video">视频选项</string>
  <string name="video_smooth">线性过滤</string>
  <string name="video_separatethread">用单线程处理视频，可能会提高FPS，也可能使程序崩溃</string>
  <string name="video_orientation_vertical">切换横屏/竖屏</string>
  <string name="video_orientation_autodetect">自动检测屏幕方向</string>
  <string name="video_bpp_24">24 bpp颜色深度</string>
  <string name="video_immersive">隐藏系统导航按钮/沉浸模式</string>
  <string name="tv_borders">电视边框</string>

  <string name="text_edit_click_here">点击开始输入，按返回键结束</string>

  <string name="display_size_mouse">鼠标仿真模式</string>
  <string name="display_size">显示仿真鼠标的大小</string>
  <string name="display_size_desktop">桌面版，无仿真</string>
  <string name="display_size_large">大（适用于平板电脑）</string>
  <string name="display_size_small">小，放大镜</string>
  <string name="display_size_small_touchpad">小，触摸模式</string>
  <string name="display_size_tiny">很小</string>
  <string name="display_size_tiny_touchpad">很小，触摸模式</string>

  <string name="show_more_options">显示更多选项</string>

  <string name="hardware_mouse_detected">检测到鼠标硬件，禁用鼠标仿真</string>

  <string name="not_enough_ram">没有足够的 RAM</string>
  <string name="not_enough_ram_size">本程序需要 %1$d Mb 的RAM，您的设备有 %2$d Mb</string>
  <string name="ignore">忽略</string>

  <string name="calibrate_gyroscope">校准陀螺仪</string>
  <string name="calibrate_gyroscope_text">将您的设备放在水平表面上</string>
  <string name="calibrate_gyroscope_not_supported">您的设备没有陀螺仪</string>

  <string name="reset_config">将所有配置重置为默认值</string>
  <string name="reset_config_ask">是否将所有选项重置为默认值？</string>

  <string name="cancel_download">是否取消数据下载？</string>
  <string name="cancel_download_resume">您可以稍后恢复它，数据不会被下载两次。</string>
  <string name="yes">是</string>
  <string name="no">否</string>

  <!-- Play Game Services strings -->
  <string name="gamehelper_sign_in_failed">无法登录，请检查您的网络连接，然后重试。</string>
  <string name="gamehelper_app_misconfigured">
    应用程序配置不正确。请检查包名和签名证书是否与开发者控制台中创建的客户端ID一致。此外，如果应用程序尚未发布，请检查您的帐户是否为测试人员帐户。详细信息，请参阅日志。
  </string>
  <string name="gamehelper_license_failed">许可证检查失败。</string>
  <string name="gamehelper_unknown_error">未知错误。</string>
  <string name="accessing_network">正在访问网络，请稍候</string>

  <string name="restarting_please_wait">重新启动中，请稍候。</string>

  <string name="notification_app_is_running">%s 正在运行中</string>
  <string name="notification_stop">停止</string>

</resources>

```

`Xorg/src/main/res/values/dimen.xml`:

```xml
<resources>
  <dimen name="screen_border_horizontal">0dp</dimen>
  <dimen name="screen_border_vertical">0dp</dimen>
</resources>

```

`Xorg/src/main/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <item name="left" type="id"/>
  <item name="right" type="id"/>
  <item name="top" type="id"/>
  <item name="bottom" type="id"/>
</resources>

```

`Xorg/src/main/res/values/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources
  xmlns:tools="http://schemas.android.com/tools"
  tools:ignore="MissingTranslation">
  <string name="init">Initializing</string>
  <string name="please_wait">Please wait while data is being downloaded</string>

  <string name="device_config">Device configuration</string>
  <string name="device_change_cfg">Change device configuration</string>

  <string name="download_unneeded">No need to download</string>
  <string name="connecting_to">Connecting to %s</string>
  <string name="failed_connecting_to">Failed connecting to %s</string>
  <string name="error_connecting_to">Error connecting to %s</string>
  <string name="dl_from">Downloading data from %s</string>
  <string name="error_dl_from">Error downloading data from %s</string>
  <string name="error_write">Error writing to %s</string>
  <string name="dl_progress">%1$.0f%% done: file %2$s</string>
  <string name="dl_finished">Finished</string>

  <string name="storage_phone">Internal storage - %d MB free</string>
  <string name="storage_sd">SD card storage - %d MB free</string>
  <string name="storage_custom">Specify directory</string>
  <string name="storage_commandline">Command line parameters, one argument per line</string>
  <string name="storage_question">Data installation location</string>
  <string name="optional_downloads">Downloads</string>
  <string name="downloads">Downloads</string>
  <string name="ok">OK</string>
  <string name="cancel">Cancel</string>

  <string name="controls_arrows">Arrows / joystick / dpad</string>
  <string name="controls_trackball">Trackball</string>
  <string name="controls_accel">Accelerometer</string>
  <string name="controls_touch">Touchscreen only</string>
  <string name="controls_question">What kind of navigation keys does your device have?</string>

  <string name="controls_additional">Additional controls</string>
  <string name="controls_screenkb">On-screen screenKeyboard</string>
  <string name="controls_accelnav">Accelerometer</string>

  <string name="controls_screenkb_size">On-screen screenKeyboard size</string>
  <string name="controls_screenkb_drawsize">Size of button images</string>
  <string name="controls_screenkb_large">Large</string>
  <string name="controls_screenkb_medium">Medium</string>
  <string name="controls_screenkb_small">Small</string>
  <string name="controls_screenkb_tiny">Tiny</string>
  <string name="controls_screenkb_custom">Custom</string>
  <string name="controls_screenkb_theme">On-screen screenKeyboard theme</string>
  <string name="controls_screenkb_by">%1$s by %2$s</string>
  <string name="controls_screenkb_transparency">On-screen screenKeyboard transparency</string>
  <string name="controls_screenkb_trans_0">Invisible</string>
  <string name="controls_screenkb_trans_1">Almost invisible</string>
  <string name="controls_screenkb_trans_2">Transparent</string>
  <string name="controls_screenkb_trans_3">Semi-transparent</string>
  <string name="controls_screenkb_trans_4">Non-transparent</string>

  <string name="trackball_no_dampening">No dampening</string>
  <string name="trackball_fast">Fast</string>
  <string name="trackball_medium">Medium</string>
  <string name="trackball_slow">Slow</string>
  <string name="trackball_question">Trackball dampening</string>

  <string name="accel_veryfast">Very fast</string>
  <string name="accel_fast">Fast</string>
  <string name="accel_medium">Medium</string>
  <string name="accel_slow">Slow</string>
  <string name="accel_veryslow">Very slow</string>
  <string name="accel_question">Accelerometer sensitivity</string>

  <string name="accel_floating">Floating</string>
  <string name="accel_fixed_start">Fixed when application starts</string>
  <string name="accel_fixed_horiz">Fixed to table desk orientation</string>
  <string name="accel_question_center">Accelerometer center position</string>

  <string name="mouse_emulation">Mouse emulation</string>
  <string name="rightclick_question">Right mouse click</string>
  <string name="rightclick_menu">Menu key</string>
  <string name="rightclick_key">Physical key</string>
  <string name="rightclick_multitouch">Touch screen with second finger</string>
  <string name="rightclick_pressure">Touch screen with force</string>
  <string name="rightclick_none">Disable right mouse click</string>

  <string name="leftclick_question">Left mouse click</string>
  <string name="leftclick_normal">Normal</string>
  <string name="leftclick_near_cursor">Touch near mouse cursor</string>
  <string name="leftclick_multitouch">Touch screen with second finger</string>
  <string name="leftclick_pressure">Touch screen with force</string>
  <string name="leftclick_dpadcenter">Trackball click / joystick center</string>
  <string name="leftclick_timeout">Hold at the same spot</string>
  <string name="leftclick_tap">Tap</string>
  <string name="leftclick_tap_or_timeout">Tap or hold</string>
  <string name="leftclick_timeout_time">Holding timeout</string>
  <string name="leftclick_timeout_time_0">0.3 sec</string>
  <string name="leftclick_timeout_time_1">0.5 sec</string>
  <string name="leftclick_timeout_time_2">0.7 sec</string>
  <string name="leftclick_timeout_time_3">1 sec</string>
  <string name="leftclick_timeout_time_4">1.5 sec</string>
  <string name="click_with_dpadcenter">Left mouse click with trackball / joystick center</string>

  <string name="advanced">Advanced features</string>
  <string name="mouse_keepaspectratio">Keep 4:3 screen aspect ratio</string>
  <string name="mouse_showcreenunderfinger">Show screen under finger in separate window</string>
  <string name="mouse_showcreenunderfinger2">On-screen magnifying glass</string>
  <string name="mouse_joystickmouse">Move mouse with joystick or trackball</string>
  <string name="mouse_joystickmousespeed">Move mouse with joystick speed</string>
  <string name="mouse_joystickmouseaccel">Move mouse with joystick acceleration</string>
  <string name="mouse_relative">Relative mouse movement (laptop mode)</string>
  <string name="mouse_relative_speed">Relative mouse movement speed</string>
  <string name="mouse_relative_accel">Relative mouse movement acceleration</string>
  <string name="mouse_hover_jitter_filter">Filter jitter for stylus/finger hover</string>
  <string name="mouse_gyroscope_mouse">Control mouse with gyroscope</string>
  <string name="mouse_gyroscope_mouse_sensitivity">Gyroscope sensitivity</string>
  <string name="mouse_finger_hover">Finger hover</string>
  <string name="mouse_subframe_touch_events">Multiple touch events per video frame</string>

  <string name="none">None</string>

  <string name="measurepressure">Calibrate touchscreen pressure</string>
  <string name="measurepressure_touchplease">Please slide finger across the screen for two seconds</string>
  <string name="measurepressure_response">Pressure %1$03d radius %2$03d</string>

  <string name="audiobuf_verysmall">Very small (fast devices, less lag)</string>
  <string name="audiobuf_small">Small</string>
  <string name="audiobuf_medium">Medium</string>
  <string name="audiobuf_large">Large (older devices, if sound is choppy)</string>
  <string name="audiobuf_question">Size of audio buffer</string>

  <string name="remap_hwkeys">Remap physical keys</string>
  <string name="remap_hwkeys_press">Press any key except HOME and POWER, you may use volume keys</string>
  <string name="remap_hwkeys_select">Select SDL keycode</string>
  <string name="remap_hwkeys_select_simple">Select action</string>
  <string name="remap_hwkeys_select_more_keys">Show all keycodes</string>

  <string name="remap_screenkb">Remap on-screen controls</string>
  <string name="remap_screenkb_joystick">Joystick</string>
  <string name="remap_screenkb_button">Button</string>
  <string name="remap_screenkb_button_text">Text input button</string>
  <string name="remap_screenkb_button_gestures">Two-finger screen gestures</string>
  <string name="remap_screenkb_button_gestures_sensitivity">Two-finger screen gestures sensitivity</string>
  <string name="remap_screenkb_button_zoomin">Zoom in two-finger gesture</string>
  <string name="remap_screenkb_button_zoomout">Zoom out two-finger gesture</string>
  <string name="remap_screenkb_button_rotateleft">Rotate left two-finger gesture</string>
  <string name="remap_screenkb_button_rotateright">Rotate right two-finger gesture</string>

  <string name="screenkb_custom_layout">Customize on-screen screenKeyboard layout</string>
  <string name="screenkb_custom_layout_help">Press BACK when done. Resize buttons by sliding on empty space.</string>
  <string name="screenkb_floating_joystick">Floating joystick</string>

  <string name="calibrate_touchscreen">Calibrate touchscreen</string>
  <string name="calibrate_touchscreen_touch">Touch all edges of the screen, press BACK when done</string>

  <string name="video">Video settings</string>
  <string name="video_smooth">Linear video filtering</string>
  <string name="video_separatethread">Separate thread for video, it can increase FPS, it also can crash the app
  </string>
  <string name="video_orientation_vertical">Portrait/vertical screen orientation</string>
  <string name="video_orientation_autodetect">Auto-detect screen orientation</string>
  <string name="video_bpp_24">24 bpp screen color depth</string>
  <string name="video_immersive">Hide system navigation buttons / immersive mode</string>
  <string name="tv_borders">TV borders</string>

  <string name="text_edit_click_here">Tap to start typing, press Back when done</string>

  <string name="display_size_mouse">Mouse emulation mode</string>
  <string name="display_size">Display size for mouse emulation</string>
  <string name="display_size_desktop">Desktop, no emulation</string>
  <string name="display_size_large">Large (tablets)</string>
  <string name="display_size_small">Small, magnifying glass</string>
  <string name="display_size_small_touchpad">Small, touchpad mode</string>
  <string name="display_size_tiny">Tiny</string>
  <string name="display_size_tiny_touchpad">Tiny, touchpad mode</string>

  <string name="show_more_options">Show more options</string>

  <string name="hardware_mouse_detected">Hardware mouse detected, disabling mouse emulation</string>

  <string name="not_enough_ram">Not enough RAM</string>
  <string name="not_enough_ram_size">This app needs %1$d Mb RAM, your device has %2$d Mb</string>
  <string name="ignore">Ignore</string>

  <string name="calibrate_gyroscope">Calibrate gyroscope</string>
  <string name="calibrate_gyroscope_text">Put your device on a flat surface</string>
  <string name="calibrate_gyroscope_not_supported">Your device does not have gyroscope</string>

  <string name="reset_config">Reset config to defaults</string>
  <string name="reset_config_ask">Reset all options to default values?</string>

  <string name="cancel_download">Cancel data downloading?</string>
  <string name="cancel_download_resume">You can resume it later, the data will not be downloaded twice.</string>
  <string name="yes">Yes</string>
  <string name="no">No</string>

  <!-- Play Game Services strings -->
  <string name="gamehelper_sign_in_failed">Failed to sign in. Please check your network connection and try again.
  </string>
  <string name="gamehelper_app_misconfigured">The application is incorrectly configured. Check that the package name
    and signing certificate match the client ID created in Developer Console. Also, if the application is not yet
    published, check that the account you are trying to sign in with is listed as a tester account. See logs for
    more information.
  </string>
  <string name="gamehelper_license_failed">License check failed.</string>
  <string name="gamehelper_unknown_error">Unknown error.</string>
  <string name="accessing_network">Accessing network, please wait</string>

  <string name="google_play_game_services_app_id" translatable="false">==GOOGLEPLAYGAMESERVICES_APP_ID==</string>

  <string name="restarting_please_wait">Restarting, please wait.</string>

  <string name="notification_app_is_running">%s is running</string>
  <string name="notification_stop">Stop</string>

</resources>

```

`Xorg/src/main/res/xml/amiga.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<Keyboard android:keyWidth="10.000002%p" android:keyHeight="10.000002%p" android:horizontalGap="0.0px"
          android:verticalGap="0.0px"
          xmlns:android="http://schemas.android.com/apk/res/android">
  <Row>
    <Key android:codes="45" android:keyEdgeFlags="left" android:keyLabel="q"/>
    <Key android:codes="51" android:keyLabel="w"/>
    <Key android:codes="33" android:keyLabel="e"/>
    <Key android:codes="46" android:keyLabel="r"/>
    <Key android:codes="48" android:keyLabel="t"/>
    <Key android:codes="53" android:keyLabel="y"/>
    <Key android:codes="49" android:keyLabel="u"/>
    <Key android:codes="37" android:keyLabel="i"/>
    <Key android:codes="43" android:keyLabel="o"/>
    <Key android:codes="44" android:keyEdgeFlags="right" android:keyLabel="p"/>
  </Row>
  <Row>
    <Key android:codes="29" android:keyEdgeFlags="left" android:keyLabel="a"/>
    <Key android:codes="47" android:keyLabel="s"/>
    <Key android:codes="32" android:keyLabel="d"/>
    <Key android:codes="34" android:keyLabel="f"/>
    <Key android:codes="35" android:keyLabel="g"/>
    <Key android:codes="36" android:keyLabel="h"/>
    <Key android:codes="38" android:keyLabel="j"/>
    <Key android:codes="39" android:keyLabel="k"/>
    <Key android:codes="40" android:keyLabel="l"/>
    <Key android:codes="74" android:keyEdgeFlags="right" android:keyLabel=";"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyEdgeFlags="left" android:keyLabel="⇪"/>
    <Key android:codes="54" android:keyLabel="z"/>
    <Key android:codes="52" android:keyLabel="x"/>
    <Key android:codes="31" android:keyLabel="c"/>
    <Key android:codes="50" android:keyLabel="v"/>
    <Key android:codes="30" android:keyLabel="b"/>
    <Key android:codes="42" android:keyLabel="n"/>
    <Key android:codes="41" android:keyLabel="m"/>
    <Key android:keyWidth="20.000004%p" android:codes="67" android:keyEdgeFlags="right" android:keyLabel="≪ ×"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyEdgeFlags="left" android:keyLabel="123…"/>
    <Key android:codes="71" android:keyLabel="["/>
    <Key android:codes="72" android:keyLabel="]"/>
    <Key android:codes="76" android:keyLabel="/"/>
    <Key android:keyWidth="20.000004%p" android:codes="62" android:keyLabel="Space"/>
    <Key android:codes="55" android:keyLabel=","/>
    <Key android:codes="56" android:keyLabel="."/>
    <Key android:keyWidth="20.000004%p" android:codes="66" android:keyEdgeFlags="right" android:keyLabel="Enter"/>
  </Row>
</Keyboard>
```

`Xorg/src/main/res/xml/amiga_alt.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">

  <Row>
    <Key android:codes="8" android:keyLabel="1" android:keyEdgeFlags="left"/>
    <Key android:codes="9" android:keyLabel="2"/>
    <Key android:codes="10" android:keyLabel="3"/>
    <Key android:codes="11" android:keyLabel="4"/>
    <Key android:codes="12" android:keyLabel="5"/>
    <Key android:codes="13" android:keyLabel="6"/>
    <Key android:codes="14" android:keyLabel="7"/>
    <Key android:codes="15" android:keyLabel="8"/>
    <Key android:codes="16" android:keyLabel="9"/>
    <Key android:codes="7" android:keyLabel="0" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="111" android:keyLabel="Esc" android:keyEdgeFlags="left"/>
    <Key android:codes="68" android:keyLabel="`"/>
    <Key android:codes="69" android:keyLabel="-"/>
    <Key android:codes="70" android:keyLabel="="/>
    <Key android:codes="73" android:keyLabel="\\"/>
    <Key android:codes="124" android:keyLabel="Ins"/>
    <Key android:codes="92" android:keyLabel="PgUp"/>
    <Key android:codes="122" android:keyLabel="Home"/>
    <Key android:codes="19" android:keyLabel="↑"/>
    <Key android:codes="123" android:keyLabel="End" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyLabel="!@#…" android:keyEdgeFlags="left"/>
    <Key android:codes="75" android:keyLabel="'"/>
    <Key android:codes="100075" android:keyLabel="&quot;"/>
    <Key android:codes="61" android:keyLabel="Tab"/>
    <Key android:codes="115" android:keyLabel="CapsLk"/>
    <Key android:codes="112" android:keyLabel="Del"/>
    <Key android:codes="93" android:keyLabel="PgDn"/>
    <Key android:codes="21" android:keyLabel="←"/>
    <Key android:codes="20" android:keyLabel="↓"/>
    <Key android:codes="22" android:keyLabel="→" android:keyEdgeFlags="right"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyLabel="abc…" android:keyEdgeFlags="left"/>
    <Key android:codes="59" android:keyLabel="Shift" android:isSticky="true"/>
    <Key android:codes="113" android:keyLabel="Ctrl" android:isSticky="true"/>
    <Key android:codes="117" android:keyLabel="Meta" android:isSticky="true"/>
    <Key android:codes="57" android:keyLabel="Alt" android:isSticky="true"/>
    <Key android:codes="58" android:keyLabel="Alt" android:isSticky="true"/>
    <Key android:codes="118" android:keyLabel="Meta" android:isSticky="true"/>
    <Key android:codes="226" android:keyLabel="Menu" android:isSticky="true"/>
    <Key android:codes="114" android:keyLabel="Ctrl" android:isSticky="true"/>
    <Key android:codes="60" android:keyLabel="Shift" android:isSticky="true"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/amiga_alt_shift.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">

  <Row>
    <Key android:codes="100008" android:keyLabel="!" android:keyEdgeFlags="left"/>
    <Key android:codes="100009" android:keyLabel="\@"/>
    <Key android:codes="100010" android:keyLabel="#"/>
    <Key android:codes="100011" android:keyLabel="$"/>
    <Key android:codes="100012" android:keyLabel="%"/>
    <Key android:codes="100013" android:keyLabel="^"/>
    <Key android:codes="100014" android:keyLabel="&amp;"/>
    <Key android:codes="100015" android:keyLabel="*"/>
    <Key android:codes="100016" android:keyLabel="("/>
    <Key android:codes="100007" android:keyLabel=")" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="111" android:keyLabel="Esc" android:keyEdgeFlags="left"/>
    <Key android:codes="124" android:keyLabel="Help"/>
    <Key android:codes="100069" android:keyLabel="_"/>
    <Key android:codes="100070" android:keyLabel="+"/>
    <Key android:codes="100073" android:keyLabel="|"/>
    <Key android:codes="100068" android:keyLabel="~"/>
    <Key android:codes="131" android:keyLabel="F1"/>
    <Key android:codes="132" android:keyLabel="F2"/>
    <Key android:codes="133" android:keyLabel="F3"/>
    <Key android:codes="134" android:keyLabel="F4" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyLabel="123…" android:keyEdgeFlags="left"/>
    <Key android:codes="143" android:keyLabel="NumLk" android:isSticky="true"/>
    <Key android:codes="120" android:keyLabel="Print"/>
    <Key android:codes="116" android:keyLabel="ScrollLk"/>
    <Key android:codes="121" android:keyLabel="Pause"/>
    <Key android:codes="158" android:keyLabel="Kp ."/>
    <Key android:codes="135" android:keyLabel="F5"/>
    <Key android:codes="136" android:keyLabel="F6"/>
    <Key android:codes="137" android:keyLabel="F7"/>
    <Key android:codes="138" android:keyLabel="F8" android:keyEdgeFlags="right"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyLabel="abc…" android:keyEdgeFlags="left"/>
    <Key android:codes="154" android:keyLabel="Kp /"/>
    <Key android:codes="155" android:keyLabel="Kp *"/>
    <Key android:codes="156" android:keyLabel="Kp -"/>
    <Key android:codes="157" android:keyLabel="Kp +"/>
    <Key android:codes="160" android:keyLabel="Kp ↵"/>
    <Key android:codes="139" android:keyLabel="F9"/>
    <Key android:codes="140" android:keyLabel="F10"/>
    <Key android:codes="141" android:keyLabel="F11"/>
    <Key android:codes="142" android:keyLabel="F12" android:keyEdgeFlags="right"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/amiga_old.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">
  <Row>
    <Key android:codes="111" android:keyLabel="ESC" android:keyEdgeFlags="left"/>
    <Key android:codes="131" android:keyLabel="F1"/>
    <Key android:codes="132" android:keyLabel="F2"/>
    <Key android:codes="133" android:keyLabel="F3"/>
    <Key android:codes="134" android:keyLabel="F4"/>
    <Key android:codes="135" android:keyLabel="F5"/>
    <Key android:codes="136" android:keyLabel="F6"/>
    <Key android:codes="137" android:keyLabel="F7"/>
    <Key android:codes="138" android:keyLabel="F8"/>
    <Key android:codes="139" android:keyLabel="F9"/>
    <Key android:codes="140" android:keyLabel="F10"/>
    <Key android:codes="124" android:keyLabel="HELP" android:keyEdgeFlags="right"/>
  </Row>

  <Row>
    <Key android:codes="75" android:keyLabel="`" android:keyEdgeFlags="left"/>
    <Key android:codes="8" android:keyLabel="1"/>
    <Key android:codes="9" android:keyLabel="2"/>
    <Key android:codes="10" android:keyLabel="3"/>
    <Key android:codes="11" android:keyLabel="4"/>
    <Key android:codes="12" android:keyLabel="5"/>
    <Key android:codes="13" android:keyLabel="6"/>
    <Key android:codes="14" android:keyLabel="7"/>
    <Key android:codes="15" android:keyLabel="8"/>
    <Key android:codes="16" android:keyLabel="9"/>
    <Key android:codes="7" android:keyLabel="0"/>
    <Key android:codes="67" android:keyLabel="DEL" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="61" android:keyLabel="TAB" android:keyEdgeFlags="left"/>
    <Key android:codes="45" android:keyLabel="q"/>
    <Key android:codes="51" android:keyLabel="w"/>
    <Key android:codes="33" android:keyLabel="e"/>
    <Key android:codes="46" android:keyLabel="r"/>
    <Key android:codes="48" android:keyLabel="t"/>
    <Key android:codes="53" android:keyLabel="y"/>
    <Key android:codes="49" android:keyLabel="u"/>
    <Key android:codes="37" android:keyLabel="i"/>
    <Key android:codes="43" android:keyLabel="o"/>
    <Key android:codes="44" android:keyLabel="p"/>
    <Key android:codes="66" android:keyLabel="RET" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="113" android:keyLabel="CTRL" android:keyEdgeFlags="left"/>
    <Key android:codes="115" android:keyLabel="CL"/>
    <Key android:codes="29" android:keyLabel="a"/>
    <Key android:codes="47" android:keyLabel="s"/>
    <Key android:codes="32" android:keyLabel="d"/>
    <Key android:codes="34" android:keyLabel="f"/>
    <Key android:codes="35" android:keyLabel="g"/>
    <Key android:codes="36" android:keyLabel="h"/>
    <Key android:codes="38" android:keyLabel="j"/>
    <Key android:codes="39" android:keyLabel="k"/>
    <Key android:codes="40" android:keyLabel="l"/>
    <Key android:codes="74" android:keyLabel=";" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="59" android:keyLabel="SHFT" android:keyEdgeFlags="left"/>
    <Key android:codes="54" android:keyLabel="z"/>
    <Key android:codes="52" android:keyLabel="x"/>
    <Key android:codes="31" android:keyLabel="c"/>
    <Key android:codes="50" android:keyLabel="v"/>
    <Key android:codes="30" android:keyLabel="b"/>
    <Key android:codes="42" android:keyLabel="n"/>
    <Key android:codes="41" android:keyLabel="m"/>
    <Key android:codes="55" android:keyLabel=","/>
    <Key android:codes="56" android:keyLabel="."/>
    <Key android:codes="76" android:keyLabel="/"/>
    <Key android:codes="60" android:keyLabel="SHFT" android:keyEdgeFlags="right"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="57" android:keyLabel="ALT" android:keyEdgeFlags="left"/>
    <Key android:codes="68" android:keyLabel="'"/>
    <Key android:codes="73" android:keyLabel="\\"/>
    <Key android:codes="69" android:keyLabel="-"/>
    <Key android:codes="62" android:keyLabel="SPACE" android:keyWidth="30%p"/>
    <Key android:codes="70" android:keyLabel="="/>
    <Key android:codes="71" android:keyLabel="["/>
    <Key android:codes="72" android:keyLabel="]"/>
    <Key android:codes="58" android:keyLabel="ALT" android:keyEdgeFlags="right"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/amiga_shift.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">
  <Row>
    <Key android:codes="45" android:keyLabel="Q" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="51" android:keyLabel="W" android:isRepeatable="true"/>
    <Key android:codes="33" android:keyLabel="E" android:isRepeatable="true"/>
    <Key android:codes="46" android:keyLabel="R" android:isRepeatable="true"/>
    <Key android:codes="48" android:keyLabel="T" android:isRepeatable="true"/>
    <Key android:codes="53" android:keyLabel="Y" android:isRepeatable="true"/>
    <Key android:codes="49" android:keyLabel="U" android:isRepeatable="true"/>
    <Key android:codes="37" android:keyLabel="I" android:isRepeatable="true"/>
    <Key android:codes="43" android:keyLabel="O" android:isRepeatable="true"/>
    <Key android:codes="44" android:keyLabel="P" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="29" android:keyLabel="A" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="47" android:keyLabel="S" android:isRepeatable="true"/>
    <Key android:codes="32" android:keyLabel="D" android:isRepeatable="true"/>
    <Key android:codes="34" android:keyLabel="F" android:isRepeatable="true"/>
    <Key android:codes="35" android:keyLabel="G" android:isRepeatable="true"/>
    <Key android:codes="36" android:keyLabel="H" android:isRepeatable="true"/>
    <Key android:codes="38" android:keyLabel="J" android:isRepeatable="true"/>
    <Key android:codes="39" android:keyLabel="K" android:isRepeatable="true"/>
    <Key android:codes="40" android:keyLabel="L" android:isRepeatable="true"/>
    <Key android:codes="74" android:keyLabel=":" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyLabel="⇫" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="54" android:keyLabel="Z" android:isRepeatable="true"/>
    <Key android:codes="52" android:keyLabel="X" android:isRepeatable="true"/>
    <Key android:codes="31" android:keyLabel="C" android:isRepeatable="true"/>
    <Key android:codes="50" android:keyLabel="V" android:isRepeatable="true"/>
    <Key android:codes="30" android:keyLabel="B" android:isRepeatable="true"/>
    <Key android:codes="42" android:keyLabel="N" android:isRepeatable="true"/>
    <Key android:codes="41" android:keyLabel="M" android:isRepeatable="true"/>
    <Key android:codes="67" android:keyLabel="≪ ×" android:keyWidth="20%p" android:keyEdgeFlags="right"
         android:isRepeatable="true"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyLabel="!@#…" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="71" android:keyLabel="{" android:isRepeatable="true"/>
    <Key android:codes="72" android:keyLabel="}" android:isRepeatable="true"/>
    <Key android:codes="76" android:keyLabel="\?" android:isRepeatable="true"/>
    <Key android:codes="62" android:keyLabel="Space" android:keyWidth="20%p" android:isRepeatable="true"/>
    <Key android:codes="55" android:keyLabel="&lt;" android:isRepeatable="true"/>
    <Key android:codes="56" android:keyLabel="&gt;" android:isRepeatable="true"/>
    <Key android:codes="66" android:keyLabel="Enter" android:keyWidth="20%p" android:keyEdgeFlags="right"
         android:isRepeatable="true"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/atari800.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">
  <Row>
    <Key android:codes="111" android:keyLabel="Esc" android:keyEdgeFlags="left"/>
    <Key android:codes="122" android:keyLabel="Clear"/>
    <Key android:codes="124" android:keyLabel="Insert"/>
    <Key android:codes="123" android:keyLabel="Help"/>
    <Key android:codes="129" android:keyLabel="Start"/>
    <Key android:codes="128" android:keyLabel="Select"/>
    <Key android:codes="127" android:keyLabel="Option"/>
    <Key android:codes="130" android:keyLabel="Reset" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="75" android:keyLabel="`" android:keyEdgeFlags="left"/>
    <Key android:codes="8" android:keyLabel="1"/>
    <Key android:codes="9" android:keyLabel="2"/>
    <Key android:codes="10" android:keyLabel="3"/>
    <Key android:codes="11" android:keyLabel="4"/>
    <Key android:codes="12" android:keyLabel="5"/>
    <Key android:codes="13" android:keyLabel="6"/>
    <Key android:codes="14" android:keyLabel="7"/>
    <Key android:codes="15" android:keyLabel="8"/>
    <Key android:codes="16" android:keyLabel="9"/>
    <Key android:codes="7" android:keyLabel="0"/>
    <Key android:codes="67" android:keyLabel="DEL" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="61" android:keyLabel="TAB" android:keyEdgeFlags="left"/>
    <Key android:codes="45" android:keyLabel="q"/>
    <Key android:codes="51" android:keyLabel="w"/>
    <Key android:codes="33" android:keyLabel="e"/>
    <Key android:codes="46" android:keyLabel="r"/>
    <Key android:codes="48" android:keyLabel="t"/>
    <Key android:codes="53" android:keyLabel="y"/>
    <Key android:codes="49" android:keyLabel="u"/>
    <Key android:codes="37" android:keyLabel="i"/>
    <Key android:codes="43" android:keyLabel="o"/>
    <Key android:codes="44" android:keyLabel="p"/>
    <Key android:codes="66" android:keyLabel="RET" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="113" android:keyLabel="CTRL" android:keyEdgeFlags="left"/>
    <Key android:codes="29" android:keyLabel="a"/>
    <Key android:codes="47" android:keyLabel="s"/>
    <Key android:codes="32" android:keyLabel="d"/>
    <Key android:codes="34" android:keyLabel="f"/>
    <Key android:codes="35" android:keyLabel="g"/>
    <Key android:codes="36" android:keyLabel="h"/>
    <Key android:codes="38" android:keyLabel="j"/>
    <Key android:codes="39" android:keyLabel="k"/>
    <Key android:codes="40" android:keyLabel="l"/>
    <Key android:codes="74" android:keyLabel=";"/>
    <Key android:codes="115" android:keyLabel="Caps" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="59" android:keyLabel="SHFT" android:keyEdgeFlags="left"/>
    <Key android:codes="54" android:keyLabel="z"/>
    <Key android:codes="52" android:keyLabel="x"/>
    <Key android:codes="31" android:keyLabel="c"/>
    <Key android:codes="50" android:keyLabel="v"/>
    <Key android:codes="30" android:keyLabel="b"/>
    <Key android:codes="42" android:keyLabel="n"/>
    <Key android:codes="41" android:keyLabel="m"/>
    <Key android:codes="55" android:keyLabel=","/>
    <Key android:codes="56" android:keyLabel="."/>
    <Key android:codes="76" android:keyLabel="/"/>
    <Key android:codes="60" android:keyLabel="SHFT" android:keyEdgeFlags="right"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="73" android:keyLabel="\\" android:keyEdgeFlags="left"/>
    <Key android:codes="69" android:keyLabel="-"/>
    <Key android:codes="81" android:keyLabel="+"/>
    <Key android:codes="70" android:keyLabel="="/>
    <Key android:codes="62" android:keyLabel="SPACE" android:keyWidth="30%p"/>
    <Key android:codes="71" android:keyLabel="["/>
    <Key android:codes="72" android:keyLabel="]"/>
    <Key android:codes="18" android:keyLabel="#"/>
    <Key android:codes="68" android:keyLabel="INV" android:keyEdgeFlags="right"/>
  </Row>
</Keyboard>
```

`Xorg/src/main/res/xml/c64.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">
  <Row>
    <Key android:codes="113" android:keyLabel="C=" android:keyEdgeFlags="left"/>
    <Key android:codes="111" android:keyLabel="RS"/>
    <Key android:codes="5" android:keyLabel="CTRL"/>
    <Key android:codes="126" android:keyLabel="F1"/>
    <Key android:codes="103" android:keyLabel="F3"/>
    <Key android:codes="104" android:keyLabel="F5"/>
    <Key android:codes="105" android:keyLabel="F7"/>
    <Key android:codes="3" android:keyLabel="Home"/>
    <Key android:codes="71" android:keyLabel="\@"/>
    <Key android:codes="67" android:keyLabel="DEL" android:keyEdgeFlags="right"/>
  </Row>

  <Row>
    <Key android:codes="8" android:keyLabel="1" android:keyEdgeFlags="left"/>
    <Key android:codes="9" android:keyLabel="2"/>
    <Key android:codes="10" android:keyLabel="3"/>
    <Key android:codes="11" android:keyLabel="4"/>
    <Key android:codes="12" android:keyLabel="5"/>
    <Key android:codes="13" android:keyLabel="6"/>
    <Key android:codes="14" android:keyLabel="7"/>
    <Key android:codes="15" android:keyLabel="8"/>
    <Key android:codes="16" android:keyLabel="9"/>
    <Key android:codes="7" android:keyLabel="0"/>
    <Key android:codes="69" android:keyLabel="+"/>
    <Key android:codes="70" android:keyLabel="-" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="45" android:keyLabel="q" android:keyEdgeFlags="left"/>
    <Key android:codes="51" android:keyLabel="w"/>
    <Key android:codes="33" android:keyLabel="e"/>
    <Key android:codes="46" android:keyLabel="r"/>
    <Key android:codes="48" android:keyLabel="t"/>
    <Key android:codes="53" android:keyLabel="y"/>
    <Key android:codes="49" android:keyLabel="u"/>
    <Key android:codes="37" android:keyLabel="i"/>
    <Key android:codes="43" android:keyLabel="o"/>
    <Key android:codes="44" android:keyLabel="p"/>
    <Key android:codes="72" android:keyLabel="*"/>
    <Key android:codes="92" android:keyLabel="RST" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="115" android:keyLabel="SL" android:keyEdgeFlags="left"/>
    <Key android:codes="29" android:keyLabel="a"/>
    <Key android:codes="47" android:keyLabel="s"/>
    <Key android:codes="32" android:keyLabel="d"/>
    <Key android:codes="34" android:keyLabel="f"/>
    <Key android:codes="35" android:keyLabel="g"/>
    <Key android:codes="36" android:keyLabel="h"/>
    <Key android:codes="38" android:keyLabel="j"/>
    <Key android:codes="39" android:keyLabel="k"/>
    <Key android:codes="40" android:keyLabel="l"/>
    <Key android:codes="74" android:keyLabel=":"/>
    <Key android:codes="75" android:keyLabel=";" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="59" android:keyLabel="SHFT" android:keyEdgeFlags="left"/>
    <Key android:codes="54" android:keyLabel="z"/>
    <Key android:codes="52" android:keyLabel="x"/>
    <Key android:codes="31" android:keyLabel="c"/>
    <Key android:codes="50" android:keyLabel="v"/>
    <Key android:codes="30" android:keyLabel="b"/>
    <Key android:codes="42" android:keyLabel="n"/>
    <Key android:codes="41" android:keyLabel="m"/>
    <Key android:codes="55" android:keyLabel=","/>
    <Key android:codes="56" android:keyLabel="."/>
    <Key android:codes="76" android:keyLabel="/"/>
    <Key android:codes="60" android:keyLabel="SHFT" android:keyEdgeFlags="right"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="124" android:keyLabel="GBP" android:keyWidth="10%p" android:keyEdgeFlags="left"/>
    <Key android:codes="68" android:keyLabel="-" android:keyWidth="10%p"/>
    <Key android:codes="112" android:keyLabel="|" android:keyWidth="10%p"/>
    <Key android:codes="62" android:keyLabel="SPACE" android:keyWidth="40%p"/>
    <Key android:codes="73" android:keyLabel="=" android:keyWidth="10%p"/>
    <Key android:codes="23" android:keyLabel="RETURN" android:keyWidth="20%p" android:keyEdgeFlags="right"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/qwerty.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">
  <Row>
    <Key android:codes="45" android:keyLabel="q" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="51" android:keyLabel="w" android:isRepeatable="true"/>
    <Key android:codes="33" android:keyLabel="e" android:isRepeatable="true"/>
    <Key android:codes="46" android:keyLabel="r" android:isRepeatable="true"/>
    <Key android:codes="48" android:keyLabel="t" android:isRepeatable="true"/>
    <Key android:codes="53" android:keyLabel="y" android:isRepeatable="true"/>
    <Key android:codes="49" android:keyLabel="u" android:isRepeatable="true"/>
    <Key android:codes="37" android:keyLabel="i" android:isRepeatable="true"/>
    <Key android:codes="43" android:keyLabel="o" android:isRepeatable="true"/>
    <Key android:codes="44" android:keyLabel="p" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="29" android:keyLabel="a" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="47" android:keyLabel="s" android:isRepeatable="true"/>
    <Key android:codes="32" android:keyLabel="d" android:isRepeatable="true"/>
    <Key android:codes="34" android:keyLabel="f" android:isRepeatable="true"/>
    <Key android:codes="35" android:keyLabel="g" android:isRepeatable="true"/>
    <Key android:codes="36" android:keyLabel="h" android:isRepeatable="true"/>
    <Key android:codes="38" android:keyLabel="j" android:isRepeatable="true"/>
    <Key android:codes="39" android:keyLabel="k" android:isRepeatable="true"/>
    <Key android:codes="40" android:keyLabel="l" android:isRepeatable="true"/>
    <Key android:codes="74" android:keyLabel=";" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyLabel="⇪" android:keyEdgeFlags="left"/>
    <Key android:codes="54" android:keyLabel="z" android:isRepeatable="true"/>
    <Key android:codes="52" android:keyLabel="x" android:isRepeatable="true"/>
    <Key android:codes="31" android:keyLabel="c" android:isRepeatable="true"/>
    <Key android:codes="50" android:keyLabel="v" android:isRepeatable="true"/>
    <Key android:codes="30" android:keyLabel="b" android:isRepeatable="true"/>
    <Key android:codes="42" android:keyLabel="n" android:isRepeatable="true"/>
    <Key android:codes="41" android:keyLabel="m" android:isRepeatable="true"/>
    <Key android:codes="67" android:keyLabel="≪ ×" android:keyWidth="20%p" android:keyEdgeFlags="right"
         android:isRepeatable="true"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyLabel="123…" android:keyEdgeFlags="left"/>
    <Key android:codes="71" android:keyLabel="[" android:isRepeatable="true"/>
    <Key android:codes="72" android:keyLabel="]" android:isRepeatable="true"/>
    <Key android:codes="76" android:keyLabel="/" android:isRepeatable="true"/>
    <Key android:codes="62" android:keyLabel="Space" android:keyWidth="20%p" android:isRepeatable="true"/>
    <Key android:codes="55" android:keyLabel="," android:isRepeatable="true"/>
    <Key android:codes="56" android:keyLabel="." android:isRepeatable="true"/>
    <Key android:codes="66" android:keyLabel="Enter" android:keyWidth="20%p" android:keyEdgeFlags="right"
         android:isRepeatable="true"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/qwerty_alt.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">

  <Row>
    <Key android:codes="8" android:keyLabel="1" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="9" android:keyLabel="2" android:isRepeatable="true"/>
    <Key android:codes="10" android:keyLabel="3" android:isRepeatable="true"/>
    <Key android:codes="11" android:keyLabel="4" android:isRepeatable="true"/>
    <Key android:codes="12" android:keyLabel="5" android:isRepeatable="true"/>
    <Key android:codes="13" android:keyLabel="6" android:isRepeatable="true"/>
    <Key android:codes="14" android:keyLabel="7" android:isRepeatable="true"/>
    <Key android:codes="15" android:keyLabel="8" android:isRepeatable="true"/>
    <Key android:codes="16" android:keyLabel="9" android:isRepeatable="true"/>
    <Key android:codes="7" android:keyLabel="0" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="111" android:keyLabel="Esc" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="68" android:keyLabel="`" android:isRepeatable="true"/>
    <Key android:codes="69" android:keyLabel="-" android:isRepeatable="true"/>
    <Key android:codes="70" android:keyLabel="=" android:isRepeatable="true"/>
    <Key android:codes="73" android:keyLabel="\\" android:isRepeatable="true"/>
    <Key android:codes="124" android:keyLabel="Ins" android:isRepeatable="true"/>
    <Key android:codes="92" android:keyLabel="PgUp" android:isRepeatable="true"/>
    <Key android:codes="122" android:keyLabel="Home" android:isRepeatable="true"/>
    <Key android:codes="19" android:keyLabel="↑" android:isRepeatable="true"/>
    <Key android:codes="123" android:keyLabel="End" android:isRepeatable="true" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyLabel="!@#…" android:keyEdgeFlags="left"/>
    <Key android:codes="75" android:keyLabel="'" android:isRepeatable="true"/>
    <Key android:codes="100075" android:keyLabel="&quot;" android:isRepeatable="true"/>
    <Key android:codes="61" android:keyLabel="Tab" android:isRepeatable="true"/>
    <Key android:codes="115" android:keyLabel="CapsLk" android:isRepeatable="true"/>
    <Key android:codes="112" android:keyLabel="Del" android:isRepeatable="true"/>
    <Key android:codes="93" android:keyLabel="PgDn" android:isRepeatable="true"/>
    <Key android:codes="21" android:keyLabel="←" android:isRepeatable="true"/>
    <Key android:codes="20" android:keyLabel="↓" android:isRepeatable="true"/>
    <Key android:codes="22" android:keyLabel="→" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyLabel="abc…" android:keyEdgeFlags="left"/>
    <Key android:codes="59" android:keyLabel="Shift" android:isSticky="true"/>
    <Key android:codes="113" android:keyLabel="Ctrl" android:isSticky="true"/>
    <Key android:codes="117" android:keyLabel="Meta" android:isSticky="true"/>
    <Key android:codes="57" android:keyLabel="Alt" android:isSticky="true"/>
    <Key android:codes="58" android:keyLabel="Alt" android:isSticky="true"/>
    <Key android:codes="118" android:keyLabel="Meta" android:isSticky="true"/>
    <Key android:codes="226" android:keyLabel="Menu" android:isRepeatable="true"/>
    <Key android:codes="114" android:keyLabel="Ctrl" android:isSticky="true"/>
    <Key android:codes="60" android:keyLabel="Shift" android:isSticky="true"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/qwerty_alt_shift.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">

  <Row>
    <Key android:codes="100008" android:keyLabel="!" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="100009" android:keyLabel="\@" android:isRepeatable="true"/>
    <Key android:codes="100010" android:keyLabel="#" android:isRepeatable="true"/>
    <Key android:codes="100011" android:keyLabel="$" android:isRepeatable="true"/>
    <Key android:codes="100012" android:keyLabel="%" android:isRepeatable="true"/>
    <Key android:codes="100013" android:keyLabel="^" android:isRepeatable="true"/>
    <Key android:codes="100014" android:keyLabel="&amp;" android:isRepeatable="true"/>
    <Key android:codes="100015" android:keyLabel="*" android:isRepeatable="true"/>
    <Key android:codes="100016" android:keyLabel="(" android:isRepeatable="true"/>
    <Key android:codes="100007" android:keyLabel=")" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="111" android:keyLabel="Esc" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="100068" android:keyLabel="~" android:isRepeatable="true"/>
    <Key android:codes="100069" android:keyLabel="_" android:isRepeatable="true"/>
    <Key android:codes="100070" android:keyLabel="+" android:isRepeatable="true"/>
    <Key android:codes="100073" android:keyLabel="|" android:isRepeatable="true"/>
    <Key android:codes="100075" android:keyLabel="&quot;" android:isRepeatable="true"/>
    <Key android:codes="131" android:keyLabel="F1" android:isRepeatable="true"/>
    <Key android:codes="132" android:keyLabel="F2" android:isRepeatable="true"/>
    <Key android:codes="133" android:keyLabel="F3" android:isRepeatable="true"/>
    <Key android:codes="134" android:keyLabel="F4" android:isRepeatable="true" android:keyEdgeFlags="right"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyLabel="123…" android:keyEdgeFlags="left"/>
    <Key android:codes="143" android:keyLabel="NumLk" android:isSticky="true"/>
    <Key android:codes="120" android:keyLabel="Print" android:isRepeatable="true"/>
    <Key android:codes="116" android:keyLabel="ScrollLk" android:isRepeatable="true"/>
    <Key android:codes="121" android:keyLabel="Pause" android:isRepeatable="true"/>
    <Key android:codes="158" android:keyLabel="Kp ." android:isRepeatable="true"/>
    <Key android:codes="135" android:keyLabel="F5" android:isRepeatable="true"/>
    <Key android:codes="136" android:keyLabel="F6" android:isRepeatable="true"/>
    <Key android:codes="137" android:keyLabel="F7" android:isRepeatable="true"/>
    <Key android:codes="138" android:keyLabel="F8" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyLabel="abc…" android:keyEdgeFlags="left"/>
    <Key android:codes="154" android:keyLabel="Kp /" android:isRepeatable="true"/>
    <Key android:codes="155" android:keyLabel="Kp *" android:isRepeatable="true"/>
    <Key android:codes="156" android:keyLabel="Kp -" android:isRepeatable="true"/>
    <Key android:codes="157" android:keyLabel="Kp +" android:isRepeatable="true"/>
    <Key android:codes="160" android:keyLabel="Kp ↵" android:isRepeatable="true"/>
    <Key android:codes="139" android:keyLabel="F9" android:isRepeatable="true"/>
    <Key android:codes="140" android:keyLabel="F10" android:isRepeatable="true"/>
    <Key android:codes="141" android:keyLabel="F11" android:isRepeatable="true"/>
    <Key android:codes="142" android:keyLabel="F12" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
</Keyboard>

```

`Xorg/src/main/res/xml/qwerty_shift.xml`:

```xml
<?xml version="1.0"?>
<!-- When creating screenKeyboardoard layout, add it to TextInputKeyboardList array in project/java/MainActivity.java -->
<Keyboard xmlns:android="http://schemas.android.com/apk/res/android"
          android:keyWidth="10%p"
          android:horizontalGap="0px"
          android:verticalGap="0px"
          android:keyHeight="10%p">
  <Row>
    <Key android:codes="45" android:keyLabel="Q" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="51" android:keyLabel="W" android:isRepeatable="true"/>
    <Key android:codes="33" android:keyLabel="E" android:isRepeatable="true"/>
    <Key android:codes="46" android:keyLabel="R" android:isRepeatable="true"/>
    <Key android:codes="48" android:keyLabel="T" android:isRepeatable="true"/>
    <Key android:codes="53" android:keyLabel="Y" android:isRepeatable="true"/>
    <Key android:codes="49" android:keyLabel="U" android:isRepeatable="true"/>
    <Key android:codes="37" android:keyLabel="I" android:isRepeatable="true"/>
    <Key android:codes="43" android:keyLabel="O" android:isRepeatable="true"/>
    <Key android:codes="44" android:keyLabel="P" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="29" android:keyLabel="A" android:keyEdgeFlags="left" android:isRepeatable="true"/>
    <Key android:codes="47" android:keyLabel="S" android:isRepeatable="true"/>
    <Key android:codes="32" android:keyLabel="D" android:isRepeatable="true"/>
    <Key android:codes="34" android:keyLabel="F" android:isRepeatable="true"/>
    <Key android:codes="35" android:keyLabel="G" android:isRepeatable="true"/>
    <Key android:codes="36" android:keyLabel="H" android:isRepeatable="true"/>
    <Key android:codes="38" android:keyLabel="J" android:isRepeatable="true"/>
    <Key android:codes="39" android:keyLabel="K" android:isRepeatable="true"/>
    <Key android:codes="40" android:keyLabel="L" android:isRepeatable="true"/>
    <Key android:codes="74" android:keyLabel=":" android:keyEdgeFlags="right" android:isRepeatable="true"/>
  </Row>
  <Row>
    <Key android:codes="-1" android:keyLabel="⇫" android:keyEdgeFlags="left"/>
    <Key android:codes="54" android:keyLabel="Z" android:isRepeatable="true"/>
    <Key android:codes="52" android:keyLabel="X" android:isRepeatable="true"/>
    <Key android:codes="31" android:keyLabel="C" android:isRepeatable="true"/>
    <Key android:codes="50" android:keyLabel="V" android:isRepeatable="true"/>
    <Key android:codes="30" android:keyLabel="B" android:isRepeatable="true"/>
    <Key android:codes="42" android:keyLabel="N" android:isRepeatable="true"/>
    <Key android:codes="41" android:keyLabel="M" android:isRepeatable="true"/>
    <Key android:codes="67" android:keyLabel="≪ ×" android:keyWidth="20%p" android:keyEdgeFlags="right"
         android:isRepeatable="true"/>
  </Row>
  <Row android:rowEdgeFlags="bottom">
    <Key android:codes="-6" android:keyLabel="!@#…" android:keyEdgeFlags="left"/>
    <Key android:codes="71" android:keyLabel="{" android:isRepeatable="true"/>
    <Key android:codes="72" android:keyLabel="}" android:isRepeatable="true"/>
    <Key android:codes="76" android:keyLabel="\?" android:isRepeatable="true"/>
    <Key android:codes="62" android:keyLabel="Space" android:keyWidth="20%p" android:isRepeatable="true"/>
    <Key android:codes="55" android:keyLabel="&lt;" android:isRepeatable="true"/>
    <Key android:codes="56" android:keyLabel="&gt;" android:isRepeatable="true"/>
    <Key android:codes="66" android:keyLabel="Enter" android:keyWidth="20%p" android:keyEdgeFlags="right"
         android:isRepeatable="true"/>
  </Row>
</Keyboard>

```

`Xorg/src/test/java/io/neoterm/ExampleUnitTest.java`:

```java
package io.neoterm;

import org.junit.Test;

import static org.junit.Assert.assertEquals;

/**
 * Example local unit test, which will execute on the development machine (host).
 *
 * @see <a href="http://d.android.com/tools/testing">Testing documentation</a>
 */
public class ExampleUnitTest {
  @Test
  public void addition_isCorrect() throws Exception {
    assertEquals(4, 2 + 2);
  }
}
```

`app/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.4.1)

add_library(neoterm
             SHARED
             src/main/cpp/neoterm.cpp)

target_link_libraries(neoterm)

#add_library(nexec
#             SHARED
#             src/main/cpp/exec.c)


```

`app/build.gradle`:

```gradle
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'

android {
  compileSdkVersion rootProject.ext.android.COMPILE_SDK_VERSION

  defaultConfig {
    applicationId "io.neoterm"
    minSdkVersion rootProject.ext.android.MIN_SDK_VERSION
    targetSdkVersion rootProject.ext.android.TARGET_SDK_VERSION
    versionCode 38
    versionName "2.0.5"
    testInstrumentationRunner 'androidx.test.runner.AndroidJUnitRunner'
    resConfigs "zh-rCN", "zh-rTW"
    externalNativeBuild {
      cmake {
        cppFlags "-std=c++11"
        abiFilters 'arm64-v8a'
      }
    }
    sourceSets {
      main {
        jniLibs.srcDirs = ['src/main/jniLibs']
      }
    }
  }
  buildTypes {
    release {
      minifyEnabled true
      zipAlignEnabled true
      shrinkResources true
    }
  }
  externalNativeBuild {
    cmake {
      path "CMakeLists.txt"
    }
  }
  lintOptions {
    abortOnError false
    checkReleaseBuilds false
  }
  compileOptions {
    targetCompatibility 1.8
    sourceCompatibility 1.8
  }
  kotlinOptions {
    freeCompilerArgs = ["-Xallow-result-return-type"]
  }
}

dependencies {
  implementation fileTree(include: ['*.jar'], dir: 'libs')
  testImplementation rootProject.ext.deps["junit"]
  androidTestImplementation project(path: ':NeoLang')

  implementation rootProject.ext.deps["kotlin-stdlib"]

  implementation 'org.greenrobot:eventbus:3.0.0'
  implementation 'com.github.wrdlbrnft:modular-adapter:0.2.0.6'
  implementation 'com.github.wrdlbrnft:sorted-list-adapter:0.2.0.19'
  implementation 'com.simplecityapps:recyclerview-fastscroll:1.0.16'
  implementation 'de.psdev.licensesdialog:licensesdialog:1.8.3'
  implementation 'com.github.GrenderG:Color-O-Matic:1.1.5'
  implementation 'androidx.annotation:annotation:1.2.0'
  implementation 'androidx.cardview:cardview:1.0.0'
  implementation 'androidx.appcompat:appcompat:1.2.0'
  implementation 'androidx.appcompat:appcompat-resources:1.2.0'

  implementation project(':chrome-tabs')
  implementation project(':NeoLang')
  implementation project(':NeoTermBridge')
  implementation project(':Xorg')
}

```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
          package="io.neoterm">

  <uses-feature
    android:name="android.hardware.touchscreen"
    android:required="false"/>
  <uses-feature
    android:name="android.software.leanback"
    android:required="false"/>

  <uses-permission android:name="android.permission.VIBRATE"/>
  <uses-permission android:name="android.permission.INTERNET"/>
  <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/>
  <uses-permission android:name="android.permission.WAKE_LOCK"/>
  <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
  <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>

  <application
    android:name=".App"
    android:allowBackup="true"
    android:banner="@drawable/banner"
    android:extractNativeLibs="true"
    android:fullBackupContent="@xml/backup_config"
    android:icon="@mipmap/ic_launcher_neoterm_round"
    android:label="@string/app_name"
    android:usesCleartextTraffic="true"
    android:resizeableActivity="true"
    android:roundIcon="@mipmap/ic_launcher_neoterm_round"
    android:supportsRtl="true"
    android:theme="@style/AppTheme">
    <activity
      android:name=".ui.term.NeoTermActivity"
      android:configChanges="orientation|keyboardHidden|screenSize"
      android:launchMode="singleTask"
      android:theme="@style/AppTheme.NoActionBar.Dark"
      android:windowSoftInputMode="adjustResize|stateHidden">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>

        <category android:name="android.intent.category.LAUNCHER"/>
      </intent-filter>
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>
        <category android:name="android.intent.category.LEANBACK_LAUNCHER"/>
      </intent-filter>

      <meta-data
        android:name="android.app.shortcuts"
        android:resource="@xml/app_shortcuts"/>
    </activity>

    <activity-alias
      android:name=".NeoLotMainActivity"
      android:targetActivity="io.neoterm.ui.term.NeoTermActivity">
      <intent-filter>
        <action android:name="android.intent.action.MAIN"/>

        <category android:name="android.intent.category.IOT_LAUNCHER"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>
    </activity-alias>

    <activity
      android:name=".ui.term.NeoTermRemoteInterface"
      android:configChanges="orientation|keyboardHidden"
      android:exported="true"
      android:theme="@style/AppTheme.Dark"
      android:windowSoftInputMode="adjustResize|stateHidden">
      <intent-filter>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>
    </activity>

    <activity-alias
      android:name=".ui.term.TermHere"
      android:exported="true"
      android:label="@string/term_here"
      android:targetActivity=".ui.term.NeoTermRemoteInterface">
      <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <action android:name="android.intent.action.MAIN"/>

        <data android:mimeType="*/*"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>
    </activity-alias>

    <activity-alias
      android:name=".ui.term.UserScript"
      android:exported="true"
      android:label="@string/user_script"
      android:targetActivity=".ui.term.NeoTermRemoteInterface">
      <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <action android:name="android.intent.action.SEND_MULTIPLE"/>
        <action android:name="android.intent.action.MAIN"/>

        <data android:mimeType="*/*"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>
      <intent-filter>
        <data android:scheme="file"/>

        <action android:name="android.intent.action.VIEW"/>
        <action android:name="android.intent.action.MAIN"/>

        <data android:mimeType="*/*"/>
        <category android:name="android.intent.category.DEFAULT"/>
      </intent-filter>
      <intent-filter>
        <action android:name="android.intent.action.VIEW"/>

        <category android:name="android.intent.category.BROWSABLE"/>
        <category android:name="android.intent.category.DEFAULT"/>

        <data android:scheme="http"/>
        <data android:scheme="https"/>
        <data android:scheme="ftp"/>
        <data android:mimeType="application/*"/>
        <data android:mimeType="audio/*"/>
        <data android:mimeType="video/*"/>
      </intent-filter>
    </activity-alias>

    <activity
      android:name=".ui.other.AboutActivity"
      android:exported="false"
      android:label="@string/about"
      android:theme="@style/AppTheme.NoActionBar.Dark"/>
    <activity
      android:name=".ui.other.CrashActivity"
      android:exported="false"
      android:label="@string/error"
      android:theme="@style/AppTheme.NoActionBar.Dark"/>
    <activity
      android:name=".ui.other.SetupActivity"
      android:configChanges="keyboardHidden|orientation|screenSize"
      android:exported="true"
      android:theme="@style/AppTheme.NoActionBar"/>
    <activity
      android:name=".ui.other.BonusActivity"
      android:configChanges="orientation|keyboardHidden"
      android:exported="false"
      android:theme="@style/AppTheme.NoActionBar.Dark"/>
    <activity
      android:name=".ui.pm.PackageManagerActivity"
      android:exported="false"
      android:label="@string/package_settings"
      android:theme="@style/AppTheme.NoActionBar.Dark"/>
    <activity
      android:name=".ui.customize.CustomizeActivity"
      android:exported="false"
      android:label="@string/customization_settings"
      android:theme="@style/AppTheme.NoActionBar.Dark"/>
    <activity
      android:name=".ui.customize.ColorSchemeActivity"
      android:exported="false"
      android:label="@string/pref_customization_color_scheme"
      android:theme="@style/AppTheme.NoActionBar.Dark"/>
    <activity
      android:name=".ui.settings.SettingActivity"
      android:exported="false"
      android:theme="@style/AppTheme.Dark"/>
    <activity
      android:name=".ui.settings.GeneralSettingsActivity"
      android:exported="false"
      android:theme="@style/AppTheme.Dark"/>
    <activity
      android:name=".ui.settings.UISettingsActivity"
      android:exported="false"
      android:theme="@style/AppTheme.Dark"/>

    <service
      android:name=".services.NeoTermService"
      android:enabled="true"/>

    <meta-data
      android:name="com.sec.android.support.multiwindow"
      android:value="true"/>

    <meta-data
      android:name="com.lge.support.SPLIT_WINDOW"
      android:value="true"/>
  </application>

</manifest>

```

`app/src/main/assets/colors/Default.nl`:

```nl
color-scheme: {
    name: "Default"
    version: 1.1

    colors: {
        foreground: #ffffff
        cursor: #a9aaa9
        background: #14181c
    }
}

```

`app/src/main/assets/colors/Dracula.nl`:

```nl
color-scheme: {
    name: "Dracula"
    version: 1.1

    colors: {
        foreground: #f8f8f2
        cursor: #f8f8f2
        background: #282a36
        
        color0: #000000
        color8: #4d4d4d

        color1: #ff5555
        color9: #ff6e67

        color2: #50fa7b
        color10: #5af78e

        color3: #f1fa8c
        color11: #f4f99d

        color4: #caa9fa
        color12: #caa9fa

        color5: #ff79c6
        color13: #ff92d0

        color6: #8be9fd
        color14: #9aedfe

        color7: #bfbfbf
        color15: #e6e6e6
    }
}

```

`app/src/main/assets/colors/Material.nl`:

```nl
color-scheme: {
    name: "Material"
    version: 1.1

    colors: {
        background: #263238
        foreground: #eceff1

        color0: #263238
        color8: #37474f

        color1: #ff9800
        color9: #ffa74d

        color2: #8bc34a
        color10: #9ccc65

        color3: #ffc107
        color11: #ffa000

        color4: #03a9f4
        color12: #81d4fa

        color5: #e91e63
        color13: #ad1457

        color6: #009688
        color14: #26a69a

        color7: #cfd8dc
        color15: #eceff1
    }
}

```

`app/src/main/assets/colors/SolarizedDark.nl`:

```nl
color-scheme: {
    name: "Solarized Dark"
    version: 1.1

    colors: {
        background: #002b36
        foreground: #839496
        cursor: #93a1a1

        color0: #073642
        color1: #dc322f
        color2: #859900
        color3: #b58900
        color4: #268bd2
        color5: #d33682
        color6: #2aa198
        color7: #eee8d5
        color9: #cb4b16
        color8: #002b36
        color10: #586e75
        color11: #657b83
        color12: #839496
        color13: #6c71c4
        color14: #93a1a1
        color15: #fdf6e3
    }
}


```

`app/src/main/assets/colors/SolarizedLight.nl`:

```nl
color-scheme: {
    name: "Solarized Light"
    version: 1.1

    colors: {
        background: #fdf6e3
        foreground: #657b83
        cursor: #586e75

        color0: #073642
        color1: #dc322f
        color2: #859900
        color3: #b58900
        color4: #268bd2
        color5: #d33682
        color6: #2aa198
        color7: #eee8d5
        color8: #002b36
        color9: #cb4b16
        color10: #586e75
        color11: #657b83
        color12: #839496
        color13: #6c71c4
        color14: #93a1a1
        color15: #fdf6e3
    }
}

```

`app/src/main/assets/eks/default.nl`:

```nl
extra-key: {
    version: 20
    program: [ default ]

    key: [
        {
            code: "-"
        },
        {
            code: "/"
        },
        {
            code: "\"
        },
        {
            code: "|"
        },
        {
            code: "$"
        },
        {
            code: "<"
        },
        {
            code: ">"
        }
    ]
}
```

`app/src/main/assets/eks/vim.nl`:

```nl
extra-key: {
    version: 20
    with-default: true
    program: [ vim, vi, nvim ]

    key: [
        {
            code: "<Esc> dd"
            display: "dd"
            with-enter: true
        },
        {
            code: "<Esc> :x"
            display: ":x"
            with-enter: true
        },
        {
            code: "<Esc> :w"
            display: ":w"
            with-enter: true
        },
        {
            code: "<Esc> :q"
            display: ":q"
            with-enter: true
        }
    ]
}
```

`app/src/main/assets/scripts/extract-archive`:

```
#!/data/data/io.neoterm/files/usr/bin/bash

function file_suffix() {
    echo "${1##*.}"
}

function detect_program() {
    case "$1" in
        *.tar.* | *.tar ) echo "tar xvf %s" ;;
        *.7z )    echo "7za x %s" ;;
        *.rar )   echo "unrar x %s" ;;
        *.zip )   echo "unzip %s" ;;
        * )       echo "" ;;
    esac
}

function do_extract() {
    local file="$1"
    local dir="$(dirname $file)"

    if [[ ! -f "$file" ]]; then
        echo "$file: no such file or directory"
        return 1
    fi

    local program="$(detect_program $file)"

    if [[ "$program" == "" ]]; then
        echo "Unsupported format: $(file_suffix $file)"
        return 1
    fi

    local command="$(printf "$program" "$file")"

    if [[ ! -w "$dir" || ! -r "$file" ]]; then
        command="sudo $command"
    fi

    cd "$dir" || {
        echo "Failed to cd: $dir"
        return 1
    }

    eval "$command"
}

if [[ "$#" == 0 ]]; then
    echo "You must specific at least a file to extract."
    exit 1
fi

clear
while [[ "$#" != 0 ]]; do
    file="$1"; shift
    echo "[Extracting] $(basename $file)"
    do_extract "$file"
done

```

`app/src/main/assets/scripts/open-in-vim`:

```
#!/data/data/io.neoterm/files/usr/bin/bash

set -e

VIM="$(which vim)"

if [[ "$VIM"x == ""x ]]; then
    echo "Vim is not installed, now installing..."
    apt update && apt install -y vim
fi

$VIM "$@"

```

`app/src/main/cpp/exec.c`:

```c
#include <dlfcn.h>
#include <libgen.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>

static const char *rewrite_executable(const char *filename, char *buffer, int buffer_len) {
    strcpy(buffer, "/data/data/io.neoterm/files/usr/bin/");
    char *bin_match = strstr(filename, "/bin/");
    if (bin_match == filename || bin_match == (filename + 4)) {
        // We have either found "/bin/" at the start of the string or at
        // "/xxx/bin/". Take the path after that.
        strncpy(buffer + 36, bin_match + 5, (size_t) (buffer_len - 37));
        filename = buffer;
    }
    return filename;
}

int execve(const char *filename, char *const *argv, char *const envp[]) {
    int fd = -1;
    const char **new_argv = NULL;

    char filename_buffer[512];
    filename = rewrite_executable(filename, filename_buffer, sizeof(filename_buffer));

    // Error out if the file is not executable:
    if (access(filename, X_OK) != 0) goto final;

    fd = open(filename, O_RDONLY);
    if (fd == -1) goto final;

    // execve(2): "A maximum line length of 127 characters is allowed
    // for the first line in a #! executable shell script."
    char shebang[128];
    ssize_t read_bytes = read(fd, shebang, sizeof(shebang) - 1);
    if (read_bytes < 5 || !(shebang[0] == '#' && shebang[1] == '!')) goto final;

    shebang[read_bytes] = 0;
    char *newline_location = strchr(shebang, '\n');
    if (newline_location == NULL) goto final;

    // Strip whitespace at end of shebang:
    while (*(newline_location - 1) == ' ') newline_location--;

    // Null-terminate the shebang line:
    *newline_location = 0;

    // Skip whitespace to find interpreter start:
    char *interpreter = shebang + 2;
    while (*interpreter == ' ') interpreter++;
    if (interpreter == newline_location) goto final;

    char *arg = NULL;
    char *whitespace_pos = strchr(interpreter, ' ');
    if (whitespace_pos != NULL) {
        // Null-terminate the interpreter string.
        *whitespace_pos = 0;

        // Find start of argument:
        arg = whitespace_pos + 1;
        while (*arg != 0 && *arg == ' ') arg++;
        if (arg == newline_location) {
            // Only whitespace after interpreter.
            arg = NULL;
        }
    }

    char interp_buf[512];
    const char *new_interpreter = rewrite_executable(interpreter, interp_buf, sizeof(interp_buf));
    if (new_interpreter == interpreter) goto final;

    int orig_argv_count = 0;
    while (argv[orig_argv_count] != NULL) orig_argv_count++;

    new_argv = (const char **) malloc(sizeof(char *) * (4 + orig_argv_count));

    int current_argc = 0;
    new_argv[current_argc++] = basename(interpreter);
    if (arg) new_argv[current_argc++] = arg;
    new_argv[current_argc++] = filename;
    int i = 1;
    while (orig_argv_count-- > 1) new_argv[current_argc++] = argv[i++];
    new_argv[current_argc] = NULL;

    filename = new_interpreter;
    argv = (char **) new_argv;

    final:
    if (fd != -1) close(fd);
    int (*real_execve)(const char *, char *const[], char *const[]) = (int (*)(const char *,
                                                                              char *const *,
                                                                              char *const *)) dlsym(
            RTLD_NEXT, "execve");
    int ret = real_execve(filename, argv, envp);
    free(new_argv);
    return ret;
}

```

`app/src/main/cpp/neoterm.cpp`:

```cpp
#include <dirent.h>
#include <fcntl.h>
#include <jni.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/ioctl.h>
#include <sys/wait.h>
#include <termios.h>
#include <unistd.h>
#include <string.h>

#define __neoterm_no_return __attribute__((__noreturn__))

#define TERMUX_UNUSED(x) x __attribute__((__unused__))
#ifdef __APPLE__
# define LACKS_PTSNAME_R
#endif

static int throw_runtime_exception(JNIEnv *env, char const *message) {
    jclass exClass = env->FindClass("java/lang/RuntimeException");
    env->ThrowNew(exClass, message);
    return -1;
}

static int create_subprocess(JNIEnv *env,
                             char const *cmd,
                             char const *cwd,
                             char *const argv[],
                             char **envp,
                             int *pProcessId,
                             jint rows,
                             jint columns) {
    int ptm = open("/dev/ptmx", O_RDWR | O_CLOEXEC);
    if (ptm < 0) return throw_runtime_exception(env, "Cannot open /dev/ptmx");

#ifdef LACKS_PTSNAME_R
    char* devname;
#else
    char devname[64];
#endif
    if (grantpt(ptm) || unlockpt(ptm) ||
        #ifdef LACKS_PTSNAME_R
        (devname = ptsname(ptm)) == NULL
        #else
        ptsname_r(ptm, devname, sizeof(devname))
#endif
            ) {
        return throw_runtime_exception(env, "Cannot grantpt()/unlockpt()/ptsname_r() on /dev/ptmx");
    }

    // Enable UTF-8 mode and disable flow control to prevent Ctrl+S from locking up the display.
    struct termios tios;
    tcgetattr(ptm, &tios);
    tios.c_iflag |= IUTF8;
    tios.c_iflag &= ~(IXON | IXOFF);
    tcsetattr(ptm, TCSANOW, &tios);

    /** Set initial winsize. */
    struct winsize sz = {.ws_row = static_cast<unsigned short>(rows), .ws_col = static_cast<unsigned short>(columns)};
    ioctl(ptm, TIOCSWINSZ, &sz);

    pid_t pid = fork();
    if (pid < 0) {
        return throw_runtime_exception(env, "Fork failed");
    } else if (pid > 0) {
        *pProcessId = (int) pid;
        return ptm;
    } else {
        // Clear signals which the Android java process may have blocked:
        sigset_t signals_to_unblock;
        sigfillset(&signals_to_unblock);
        sigprocmask(SIG_UNBLOCK, &signals_to_unblock, 0);

        close(ptm);
        setsid();

        int pts = open(devname, O_RDWR);
        if (pts < 0) exit(-1);

        dup2(pts, 0);
        dup2(pts, 1);
        dup2(pts, 2);

        DIR *self_dir = opendir("/proc/self/fd");
        if (self_dir != NULL) {
            int self_dir_fd = dirfd(self_dir);
            struct dirent *entry;
            while ((entry = readdir(self_dir)) != NULL) {
                int fd = atoi(entry->d_name);
                if (fd > 2 && fd != self_dir_fd) close(fd);
            }
            closedir(self_dir);
        }

        clearenv();
        if (envp) for (; *envp; ++envp) putenv(*envp);

        if (chdir(cwd) != 0) {
            char *error_message;
            // No need to free asprintf()-allocated memory since doing execvp() or exit() below.
            if (asprintf(&error_message, "chdir(\"%s\")", cwd) == -1)
                error_message = const_cast<char *>("chdir()");
            perror(error_message);
            fflush(stderr);
        }
        execvp(cmd, argv);
        // Show terminal output about failing exec() call:
        char *error_message;
        if (asprintf(&error_message, "exec(\"%s\")", cmd) == -1)
            error_message = const_cast<char *>("exec()");;
        perror(error_message);
        _exit(1);
    }
}

extern "C" JNIEXPORT jint JNICALL Java_io_neoterm_backend_JNI_createSubprocess(
        JNIEnv *env,
        jclass TERMUX_UNUSED(clazz),
        jstring cmd,
        jstring cwd,
        jobjectArray args,
        jobjectArray envVars,
        jintArray processIdArray,
        jint rows,
        jint columns) {
    jsize size = args ? env->GetArrayLength(args) : 0;
    char **argv = NULL;
    if (size > 0) {
        argv = (char **) malloc((size + 1) * sizeof(char *));
        if (!argv) return throw_runtime_exception(env, "Couldn't allocate argv array");
        for (int i = 0; i < size; ++i) {
            jstring arg_java_string = (jstring) env->GetObjectArrayElement(args, i);
            char const *arg_utf8 = env->GetStringUTFChars(arg_java_string, NULL);
            if (!arg_utf8)
                return throw_runtime_exception(env, "GetStringUTFChars() failed for argv");
            argv[i] = strdup(arg_utf8);
            env->ReleaseStringUTFChars(arg_java_string, arg_utf8);
        }
        argv[size] = NULL;
    }

    size = envVars ? env->GetArrayLength(envVars) : 0;
    char **envp = NULL;
    if (size > 0) {
        envp = (char **) malloc((size + 1) * sizeof(char *));
        if (!envp) return throw_runtime_exception(env, "malloc() for envp array failed");
        for (int i = 0; i < size; ++i) {
            jstring env_java_string = (jstring) env->GetObjectArrayElement(envVars, i);
            char const *env_utf8 = env->GetStringUTFChars(env_java_string, 0);
            if (!env_utf8)
                return throw_runtime_exception(env, "GetStringUTFChars() failed for env");
            envp[i] = strdup(env_utf8);
            env->ReleaseStringUTFChars(env_java_string, env_utf8);
        }
        envp[size] = NULL;
    }

    int procId = 0;
    char const *cmd_cwd = env->GetStringUTFChars(cwd, NULL);
    char const *cmd_utf8 = env->GetStringUTFChars(cmd, NULL);
    int ptm = create_subprocess(env, cmd_utf8, cmd_cwd, argv, envp, &procId, rows, columns);
    env->ReleaseStringUTFChars(cmd, cmd_utf8);
    env->ReleaseStringUTFChars(cmd, cmd_cwd);

    if (argv) {
        for (char **tmp = argv; *tmp; ++tmp) free(*tmp);
        free(argv);
    }
    if (envp) {
        for (char **tmp = envp; *tmp; ++tmp) free(*tmp);
        free(envp);
    }

    int *pProcId = (int *) env->GetPrimitiveArrayCritical(processIdArray, NULL);
    if (!pProcId)
        return throw_runtime_exception(env,
                                       "JNI call GetPrimitiveArrayCritical(processIdArray, &isCopy) failed");

    *pProcId = procId;
    env->ReleasePrimitiveArrayCritical(processIdArray, pProcId, 0);

    return ptm;
}

extern "C" JNIEXPORT void JNICALL
Java_io_neoterm_backend_JNI_setPtyWindowSize(JNIEnv *TERMUX_UNUSED(env),
                                              jclass TERMUX_UNUSED(clazz),
                                              jint fd, jint rows,
                                              jint cols) {
    struct winsize sz = {.ws_row = static_cast<unsigned short>(rows), .ws_col = static_cast<unsigned short>(cols)};
    ioctl(fd, TIOCSWINSZ, &sz);
}

extern "C" JNIEXPORT void JNICALL
Java_io_neoterm_backend_JNI_setPtyUTF8Mode(JNIEnv *TERMUX_UNUSED(env), jclass TERMUX_UNUSED(clazz),
                                            jint fd) {
    struct termios tios;
    tcgetattr(fd, &tios);
    if ((tios.c_iflag & IUTF8) == 0) {
        tios.c_iflag |= IUTF8;
        tcsetattr(fd, TCSANOW, &tios);
    }
}

extern "C" JNIEXPORT int JNICALL
Java_io_neoterm_backend_JNI_waitFor(JNIEnv *TERMUX_UNUSED(env), jclass TERMUX_UNUSED(clazz),
                                     jint pid) {
    int status;
    waitpid(pid, &status, 0);
    if (WIFEXITED(status)) {
        return WEXITSTATUS(status);
    } else if (WIFSIGNALED(status)) {
        return -WTERMSIG(status);
    } else {
        // Should never happen - waitpid(2) says "One of the first three macros will evaluate to a non-zero (true) value".
        return 0;
    }
}

extern "C" JNIEXPORT void JNICALL
Java_io_neoterm_backend_JNI_close(JNIEnv *TERMUX_UNUSED(env), jclass TERMUX_UNUSED(clazz),
                                   jint fileDescriptor) {
    close(fileDescriptor);
}

```

`app/src/main/java/io/neoterm/App.kt`:

```kt
package io.neoterm

import android.annotation.SuppressLint
import android.app.Application
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.view.Gravity
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import io.neoterm.component.NeoInitializer
import io.neoterm.component.config.NeoPreference
import io.neoterm.ui.other.BonusActivity
import io.neoterm.utils.CrashHandler

/**
 * @author kiva
 */
class App : Application() {
  override fun onCreate() {
    super.onCreate()
    app = this
    NeoPreference.init(this)
    CrashHandler.init()
    NeoInitializer.init(this)
  }

  fun errorDialog(context: Context, message: Int, dismissCallback: (() -> Unit)?) {
    errorDialog(context, getString(message), dismissCallback)
  }

  fun errorDialog(context: Context, message: String, dismissCallback: (() -> Unit)?) {
    AlertDialog.Builder(context)
      .setTitle(R.string.error)
      .setMessage(message)
      .setNegativeButton(android.R.string.no, null)
      .setPositiveButton(R.string.show_help) { _, _ ->
        openHelpLink()
      }
      .setOnDismissListener {
        dismissCallback?.invoke()
      }
      .show()
  }

  fun openHelpLink() {
    val intent = Intent(Intent.ACTION_VIEW, Uri.parse("https://neoterm.gitbooks.io/neoterm-wiki/content/"))
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    startActivity(intent)
  }

  fun easterEgg(context: Context, message: String) {
    val happyCount = NeoPreference.loadInt(NeoPreference.KEY_HAPPY_EGG, 0) + 1
    NeoPreference.store(NeoPreference.KEY_HAPPY_EGG, happyCount)

    val trigger = NeoPreference.VALUE_HAPPY_EGG_TRIGGER

    if (happyCount == trigger / 2) {
      @SuppressLint("ShowToast")
      val toast = Toast.makeText(this, message, Toast.LENGTH_LONG)
      toast.setGravity(Gravity.CENTER, 0, 0)
      toast.show()
    } else if (happyCount > trigger) {
      NeoPreference.store(NeoPreference.KEY_HAPPY_EGG, 0)
      context.startActivity(Intent(context, BonusActivity::class.java))
    }
  }

  companion object {
    private var app: App? = null

    fun get(): App {
      return app!!
    }
  }
}

```

`app/src/main/java/io/neoterm/backend/ByteQueue.java`:

```java
package io.neoterm.backend;

/**
 * A circular byte buffer allowing one producer and one consumer thread.
 */
final class ByteQueue {

  private final byte[] mBuffer;
  private int mHead;
  private int mStoredBytes;
  private boolean mOpen = true;

  public ByteQueue(int size) {
    mBuffer = new byte[size];
  }

  public synchronized void close() {
    mOpen = false;
    notify();
  }

  public synchronized int read(byte[] buffer, boolean block) {
    while (mStoredBytes == 0 && mOpen) {
      if (block) {
        try {
          wait();
        } catch (InterruptedException e) {
          // Ignore.
        }
      } else {
        return 0;
      }
    }
    if (!mOpen) return -1;

    int totalRead = 0;
    int bufferLength = mBuffer.length;
    boolean wasFull = bufferLength == mStoredBytes;
    int length = buffer.length;
    int offset = 0;
    while (length > 0 && mStoredBytes > 0) {
      int oneRun = Math.min(bufferLength - mHead, mStoredBytes);
      int bytesToCopy = Math.min(length, oneRun);
      System.arraycopy(mBuffer, mHead, buffer, offset, bytesToCopy);
      mHead += bytesToCopy;
      if (mHead >= bufferLength) mHead = 0;
      mStoredBytes -= bytesToCopy;
      length -= bytesToCopy;
      offset += bytesToCopy;
      totalRead += bytesToCopy;
    }
    if (wasFull) notify();
    return totalRead;
  }

  /**
   * Attempt to write the specified portion of the provided buffer to the queue.
   * <p/>
   * Returns whether the output was totally written, false if it was closed before.
   */
  public boolean write(byte[] buffer, int offset, int lengthToWrite) {
    if (lengthToWrite + offset > buffer.length) {
      throw new IllegalArgumentException("length + offset > buffer.length");
    } else if (lengthToWrite <= 0) {
      throw new IllegalArgumentException("length <= 0");
    }

    final int bufferLength = mBuffer.length;

    synchronized (this) {
      while (lengthToWrite > 0) {
        while (bufferLength == mStoredBytes && mOpen) {
          try {
            wait();
          } catch (InterruptedException e) {
            // Ignore.
          }
        }
        if (!mOpen) return false;
        final boolean wasEmpty = mStoredBytes == 0;
        int bytesToWriteBeforeWaiting = Math.min(lengthToWrite, bufferLength - mStoredBytes);
        lengthToWrite -= bytesToWriteBeforeWaiting;

        while (bytesToWriteBeforeWaiting > 0) {
          int tail = mHead + mStoredBytes;
          int oneRun;
          if (tail >= bufferLength) {
            // Buffer: [.............]
            // ________________H_______T
            // =>
            // Buffer: [.............]
            // ___________T____H
            // onRun= _____----_
            tail = tail - bufferLength;
            oneRun = mHead - tail;
          } else {
            oneRun = bufferLength - tail;
          }
          int bytesToCopy = Math.min(oneRun, bytesToWriteBeforeWaiting);
          System.arraycopy(buffer, offset, mBuffer, tail, bytesToCopy);
          offset += bytesToCopy;
          bytesToWriteBeforeWaiting -= bytesToCopy;
          mStoredBytes += bytesToCopy;
        }
        if (wasEmpty) notify();
      }
    }
    return true;
  }
}

```

`app/src/main/java/io/neoterm/backend/EmulatorDebug.java`:

```java
package io.neoterm.backend;

import android.util.Log;

public final class EmulatorDebug {

  /**
   * The tag to use with {@link Log}.
   */
  public static final String LOG_TAG = "NeoTerm-Emulator";

}

```

`app/src/main/java/io/neoterm/backend/JNI.java`:

```java
package io.neoterm.backend;

/**
 * Native methods for creating and managing pseudoterminal subprocesses. C code is in jni/termux.c.
 */
final class JNI {

  static {
    System.loadLibrary("neoterm");
  }

  /**
   * Create a subprocess. Differs from {@link ProcessBuilder} in that a pseudoterminal is used to communicate with the
   * subprocess.
   * <p/>
   * Callers are responsible for calling {@link #close(int)} on the returned file descriptor.
   *
   * @param cmd       The command to execute
   * @param cwd       The current working directory for the executed command
   * @param args      An array of arguments to the command
   * @param envVars   An array of strings of the form "VAR=value" to be added to the environment of the process
   * @param processId A one-element array to which the process ID of the started process will be written.
   * @return the file descriptor resulting from opening /dev/ptmx master device. The sub process will have opened the
   * slave device counterpart (/dev/pts/$N) and have it as stdint, stdout and stderr.
   */
  public static native int createSubprocess(String cmd, String cwd, String[] args, String[] envVars, int[] processId, int rows, int columns);

  /**
   * Set the window size for a given pty, which allows connected programs to learn how large their screen is.
   */
  public static native void setPtyWindowSize(int fd, int rows, int cols);

  /**
   * Causes the calling thread to wait for the process associated with the receiver to finish executing.
   *
   * @return if >= 0, the exit status of the process. If < 0, the signal causing the process to stop negated.
   */
  public static native int waitFor(int processId);

  /**
   * Close a file descriptor through the close(2) system call.
   */
  public static native void close(int fileDescriptor);

}

```

`app/src/main/java/io/neoterm/backend/KeyHandler.java`:

```java
package io.neoterm.backend;

import java.util.HashMap;
import java.util.Map;

import static android.view.KeyEvent.*;

public final class KeyHandler {

  public static final int KEYMOD_ALT = 0x80000000;
  public static final int KEYMOD_CTRL = 0x40000000;
  public static final int KEYMOD_SHIFT = 0x20000000;

  private static final Map<String, Integer> TERMCAP_TO_KEYCODE = new HashMap<>();

  static {
    // terminfo: http://pubs.opengroup.org/onlinepubs/7990989799/xcurses/terminfo.html
    // termcap: http://man7.org/linux/man-pages/man5/termcap.5.html
    TERMCAP_TO_KEYCODE.put("%i", KEYMOD_SHIFT | KEYCODE_DPAD_RIGHT);
    TERMCAP_TO_KEYCODE.put("#2", KEYMOD_SHIFT | KEYCODE_MOVE_HOME); // Shifted home
    TERMCAP_TO_KEYCODE.put("#4", KEYMOD_SHIFT | KEYCODE_DPAD_LEFT);
    TERMCAP_TO_KEYCODE.put("*7", KEYMOD_SHIFT | KEYCODE_MOVE_END); // Shifted end key

    TERMCAP_TO_KEYCODE.put("k1", KEYCODE_F1);
    TERMCAP_TO_KEYCODE.put("k2", KEYCODE_F2);
    TERMCAP_TO_KEYCODE.put("k3", KEYCODE_F3);
    TERMCAP_TO_KEYCODE.put("k4", KEYCODE_F4);
    TERMCAP_TO_KEYCODE.put("k5", KEYCODE_F5);
    TERMCAP_TO_KEYCODE.put("k6", KEYCODE_F6);
    TERMCAP_TO_KEYCODE.put("k7", KEYCODE_F7);
    TERMCAP_TO_KEYCODE.put("k8", KEYCODE_F8);
    TERMCAP_TO_KEYCODE.put("k9", KEYCODE_F9);
    TERMCAP_TO_KEYCODE.put("k;", KEYCODE_F10);
    TERMCAP_TO_KEYCODE.put("F1", KEYCODE_F11);
    TERMCAP_TO_KEYCODE.put("F2", KEYCODE_F12);
    TERMCAP_TO_KEYCODE.put("F3", KEYMOD_SHIFT | KEYCODE_F1);
    TERMCAP_TO_KEYCODE.put("F4", KEYMOD_SHIFT | KEYCODE_F2);
    TERMCAP_TO_KEYCODE.put("F5", KEYMOD_SHIFT | KEYCODE_F3);
    TERMCAP_TO_KEYCODE.put("F6", KEYMOD_SHIFT | KEYCODE_F4);
    TERMCAP_TO_KEYCODE.put("F7", KEYMOD_SHIFT | KEYCODE_F5);
    TERMCAP_TO_KEYCODE.put("F8", KEYMOD_SHIFT | KEYCODE_F6);
    TERMCAP_TO_KEYCODE.put("F9", KEYMOD_SHIFT | KEYCODE_F7);
    TERMCAP_TO_KEYCODE.put("FA", KEYMOD_SHIFT | KEYCODE_F8);
    TERMCAP_TO_KEYCODE.put("FB", KEYMOD_SHIFT | KEYCODE_F9);
    TERMCAP_TO_KEYCODE.put("FC", KEYMOD_SHIFT | KEYCODE_F10);
    TERMCAP_TO_KEYCODE.put("FD", KEYMOD_SHIFT | KEYCODE_F11);
    TERMCAP_TO_KEYCODE.put("FE", KEYMOD_SHIFT | KEYCODE_F12);

    TERMCAP_TO_KEYCODE.put("kb", KEYCODE_DEL); // backspace key

    TERMCAP_TO_KEYCODE.put("kd", KEYCODE_DPAD_DOWN); // terminfo=kcud1, down-arrow key
    TERMCAP_TO_KEYCODE.put("kh", KEYCODE_MOVE_HOME);
    TERMCAP_TO_KEYCODE.put("kl", KEYCODE_DPAD_LEFT);
    TERMCAP_TO_KEYCODE.put("kr", KEYCODE_DPAD_RIGHT);

    // K1=Upper left of keypad:
    // t_K1 <kHome> keypad home key
    // t_K3 <kPageUp> keypad page-up key
    // t_K4 <kEnd> keypad end key
    // t_K5 <kPageDown> keypad page-down key
    TERMCAP_TO_KEYCODE.put("K1", KEYCODE_MOVE_HOME);
    TERMCAP_TO_KEYCODE.put("K3", KEYCODE_PAGE_UP);
    TERMCAP_TO_KEYCODE.put("K4", KEYCODE_MOVE_END);
    TERMCAP_TO_KEYCODE.put("K5", KEYCODE_PAGE_DOWN);

    TERMCAP_TO_KEYCODE.put("ku", KEYCODE_DPAD_UP);

    TERMCAP_TO_KEYCODE.put("kB", KEYMOD_SHIFT | KEYCODE_TAB); // termcap=kB, terminfo=kcbt: Back-tab_switcher
    TERMCAP_TO_KEYCODE.put("kD", KEYCODE_FORWARD_DEL); // terminfo=kdch1, delete-character key
    TERMCAP_TO_KEYCODE.put("kDN", KEYMOD_SHIFT | KEYCODE_DPAD_DOWN); // non-standard shifted arrow down
    TERMCAP_TO_KEYCODE.put("kF", KEYMOD_SHIFT | KEYCODE_DPAD_DOWN); // terminfo=kind, scroll-forward key
    TERMCAP_TO_KEYCODE.put("kI", KEYCODE_INSERT);
    TERMCAP_TO_KEYCODE.put("kN", KEYCODE_PAGE_UP);
    TERMCAP_TO_KEYCODE.put("kP", KEYCODE_PAGE_DOWN);
    TERMCAP_TO_KEYCODE.put("kR", KEYMOD_SHIFT | KEYCODE_DPAD_UP); // terminfo=kri, scroll-backward key
    TERMCAP_TO_KEYCODE.put("kUP", KEYMOD_SHIFT | KEYCODE_DPAD_UP); // non-standard shifted up

    TERMCAP_TO_KEYCODE.put("@7", KEYCODE_MOVE_END);
    TERMCAP_TO_KEYCODE.put("@8", KEYCODE_NUMPAD_ENTER);
  }

  static String getCodeFromTermcap(String termcap, boolean cursorKeysApplication, boolean keypadApplication) {
    Integer keyCodeAndMod = TERMCAP_TO_KEYCODE.get(termcap);
    if (keyCodeAndMod == null) return null;
    int keyCode = keyCodeAndMod;
    int keyMod = 0;
    if ((keyCode & KEYMOD_SHIFT) != 0) {
      keyMod |= KEYMOD_SHIFT;
      keyCode &= ~KEYMOD_SHIFT;
    }
    if ((keyCode & KEYMOD_CTRL) != 0) {
      keyMod |= KEYMOD_CTRL;
      keyCode &= ~KEYMOD_CTRL;
    }
    if ((keyCode & KEYMOD_ALT) != 0) {
      keyMod |= KEYMOD_ALT;
      keyCode &= ~KEYMOD_ALT;
    }
    return getCode(keyCode, keyMod, cursorKeysApplication, keypadApplication);
  }

  public static String getCode(int keyCode, int keyMode, boolean cursorApp, boolean keypadApplication) {
    switch (keyCode) {
      case KEYCODE_DPAD_CENTER:
        return "\015";

      case KEYCODE_DPAD_UP:
        return (keyMode == 0) ? (cursorApp ? "\033OA" : "\033[A") : transformForModifiers("\033[1", keyMode, 'A');
      case KEYCODE_DPAD_DOWN:
        return (keyMode == 0) ? (cursorApp ? "\033OB" : "\033[B") : transformForModifiers("\033[1", keyMode, 'B');
      case KEYCODE_DPAD_RIGHT:
        return (keyMode == 0) ? (cursorApp ? "\033OC" : "\033[C") : transformForModifiers("\033[1", keyMode, 'C');
      case KEYCODE_DPAD_LEFT:
        return (keyMode == 0) ? (cursorApp ? "\033OD" : "\033[D") : transformForModifiers("\033[1", keyMode, 'D');

      case KEYCODE_MOVE_HOME:
        // Note that KEYCODE_HOME is handled by the system and never delivered to applications.
        // On a Logitech k810 keyboard KEYCODE_MOVE_HOME is sent by FN+LeftArrow.
        return (keyMode == 0) ? (cursorApp ? "\033OH" : "\033[H") : transformForModifiers("\033[1", keyMode, 'H');
      case KEYCODE_MOVE_END:
        return (keyMode == 0) ? (cursorApp ? "\033OF" : "\033[F") : transformForModifiers("\033[1", keyMode, 'F');

      // An xterm can send function keys F1 to F4 in two modes: vt100 compatible or
      // not. Because Vim may not know what the xterm is sending, both types of keys
      // are recognized. The same happens for the <Home> and <End> keys.
      // normal vt100 ~
      // <F1> t_k1 <Esc>[11~ <xF1> <Esc>OP *<xF1>-xterm*
      // <F2> t_k2 <Esc>[12~ <xF2> <Esc>OQ *<xF2>-xterm*
      // <F3> t_k3 <Esc>[13~ <xF3> <Esc>OR *<xF3>-xterm*
      // <F4> t_k4 <Esc>[14~ <xF4> <Esc>OS *<xF4>-xterm*
      // <Home> t_kh <Esc>[7~ <xHome> <Esc>OH *<xHome>-xterm*
      // <End> t_@7 <Esc>[4~ <xEnd> <Esc>OF *<xEnd>-xterm*
      case KEYCODE_F1:
        return (keyMode == 0) ? "\033OP" : transformForModifiers("\033[1", keyMode, 'P');
      case KEYCODE_F2:
        return (keyMode == 0) ? "\033OQ" : transformForModifiers("\033[1", keyMode, 'Q');
      case KEYCODE_F3:
        return (keyMode == 0) ? "\033OR" : transformForModifiers("\033[1", keyMode, 'R');
      case KEYCODE_F4:
        return (keyMode == 0) ? "\033OS" : transformForModifiers("\033[1", keyMode, 'S');
      case KEYCODE_F5:
        return transformForModifiers("\033[15", keyMode, '~');
      case KEYCODE_F6:
        return transformForModifiers("\033[17", keyMode, '~');
      case KEYCODE_F7:
        return transformForModifiers("\033[18", keyMode, '~');
      case KEYCODE_F8:
        return transformForModifiers("\033[19", keyMode, '~');
      case KEYCODE_F9:
        return transformForModifiers("\033[20", keyMode, '~');
      case KEYCODE_F10:
        return transformForModifiers("\033[21", keyMode, '~');
      case KEYCODE_F11:
        return transformForModifiers("\033[23", keyMode, '~');
      case KEYCODE_F12:
        return transformForModifiers("\033[24", keyMode, '~');

      case KEYCODE_SYSRQ:
        return "\033[32~"; // Sys Request / Print
      // Is this Scroll lock? case Cancel: return "\033[33~";
      case KEYCODE_BREAK:
        return "\033[34~"; // Pause/Break

      case KEYCODE_ESCAPE:
      case KEYCODE_BACK:
        return "\033";

      case KEYCODE_INSERT:
        return transformForModifiers("\033[2", keyMode, '~');
      case KEYCODE_FORWARD_DEL:
        return transformForModifiers("\033[3", keyMode, '~');

      case KEYCODE_PAGE_UP:
        return "\033[5~";
      case KEYCODE_PAGE_DOWN:
        return "\033[6~";
      case KEYCODE_DEL:
        String prefix = ((keyMode & KEYMOD_ALT) == 0) ? "" : "\033";
        // Just do what xterm and gnome-terminal does:
        return prefix + (((keyMode & KEYMOD_CTRL) == 0) ? "\u007F" : "\u0008");
      case KEYCODE_NUM_LOCK:
        return "\033OP";

      case KEYCODE_SPACE:
        // If ctrl is not down, return null so that it goes through normal input processing (which may e.g. cause a
        // combining accent to be written):
        return ((keyMode & KEYMOD_CTRL) == 0) ? null : "\0";
      case KEYCODE_TAB:
        // This is back-tab_switcher when shifted:
        return (keyMode & KEYMOD_SHIFT) == 0 ? "\011" : "\033[Z";
      case KEYCODE_ENTER:
        return ((keyMode & KEYMOD_ALT) == 0) ? "\r" : "\033\r";

      case KEYCODE_NUMPAD_ENTER:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'M') : "\n";
      case KEYCODE_NUMPAD_MULTIPLY:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'j') : "*";
      case KEYCODE_NUMPAD_ADD:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'k') : "+";
      case KEYCODE_NUMPAD_COMMA:
        return ",";
      case KEYCODE_NUMPAD_DOT:
        return keypadApplication ? "\033On" : ".";
      case KEYCODE_NUMPAD_SUBTRACT:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'm') : "-";
      case KEYCODE_NUMPAD_DIVIDE:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'o') : "/";
      case KEYCODE_NUMPAD_0:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'p') : "0";
      case KEYCODE_NUMPAD_1:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'q') : "1";
      case KEYCODE_NUMPAD_2:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'r') : "2";
      case KEYCODE_NUMPAD_3:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 's') : "3";
      case KEYCODE_NUMPAD_4:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 't') : "4";
      case KEYCODE_NUMPAD_5:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'u') : "5";
      case KEYCODE_NUMPAD_6:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'v') : "6";
      case KEYCODE_NUMPAD_7:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'w') : "7";
      case KEYCODE_NUMPAD_8:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'x') : "8";
      case KEYCODE_NUMPAD_9:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'y') : "9";
      case KEYCODE_NUMPAD_EQUALS:
        return keypadApplication ? transformForModifiers("\033O", keyMode, 'X') : "=";
    }

    return null;
  }

  private static String transformForModifiers(String start, int keymod, char lastChar) {
    int modifier;
    switch (keymod) {
      case KEYMOD_SHIFT:
        modifier = 2;
        break;
      case KEYMOD_ALT:
        modifier = 3;
        break;
      case (KEYMOD_SHIFT | KEYMOD_ALT):
        modifier = 4;
        break;
      case KEYMOD_CTRL:
        modifier = 5;
        break;
      case KEYMOD_SHIFT | KEYMOD_CTRL:
        modifier = 6;
        break;
      case KEYMOD_ALT | KEYMOD_CTRL:
        modifier = 7;
        break;
      case KEYMOD_SHIFT | KEYMOD_ALT | KEYMOD_CTRL:
        modifier = 8;
        break;
      default:
        return start + lastChar;
    }
    return start + (";" + modifier) + lastChar;
  }
}

```

`app/src/main/java/io/neoterm/backend/TerminalBuffer.java`:

```java
package io.neoterm.backend;

/**
 * A circular buffer of {@link TerminalRow}:s which keeps notes about what is visible on a logical screen and the scroll
 * history.
 * <p>
 * See {@link #externalToInternalRow(int)} for how to map from logical screen rows to array indices.
 */
public final class TerminalBuffer {

  TerminalRow[] mLines;
  /**
   * The length of {@link #mLines}.
   */
  int mTotalRows;
  /**
   * The number of rows and columns visible on the screen.
   */
  int mScreenRows, mColumns;
  /**
   * The number of rows kept in history.
   */
  private int mActiveTranscriptRows = 0;
  /**
   * The index in the circular buffer where the visible screen starts.
   */
  private int mScreenFirstRow = 0;

  /**
   * Create a transcript screen.
   *
   * @param columns    the width of the screen in characters.
   * @param totalRows  the height of the entire text area, in rows of text.
   * @param screenRows the height of just the screen, not including the transcript that holds lines that have scrolled off
   *                   the top of the screen.
   */
  public TerminalBuffer(int columns, int totalRows, int screenRows) {
    mColumns = columns;
    mTotalRows = totalRows;
    mScreenRows = screenRows;
    mLines = new TerminalRow[totalRows];

    blockSet(0, 0, columns, screenRows, ' ', TextStyle.NORMAL);
  }

  public String getTranscriptText() {
    return getSelectedText(0, -getActiveTranscriptRows(), mColumns, mScreenRows).trim();
  }

  public String getSelectedText(int selX1, int selY1, int selX2, int selY2) {
    final StringBuilder builder = new StringBuilder();
    final int columns = mColumns;

    if (selY1 < -getActiveTranscriptRows()) selY1 = -getActiveTranscriptRows();
    if (selY2 >= mScreenRows) selY2 = mScreenRows - 1;

    for (int row = selY1; row <= selY2; row++) {
      int x1 = (row == selY1) ? selX1 : 0;
      int x2;
      if (row == selY2) {
        x2 = selX2 + 1;
        if (x2 > columns) x2 = columns;
      } else {
        x2 = columns;
      }
      TerminalRow lineObject = mLines[externalToInternalRow(row)];
      int x1Index = lineObject.findStartOfColumn(x1);
      int x2Index = (x2 < mColumns) ? lineObject.findStartOfColumn(x2) : lineObject.getSpaceUsed();
      if (x2Index == x1Index) {
        // Selected the start of a wide character.
        x2Index = lineObject.findStartOfColumn(x2 + 1);
      }
      char[] line = lineObject.mText;
      int lastPrintingCharIndex = -1;
      int i;
      boolean rowLineWrap = getLineWrap(row);
      if (rowLineWrap && x2 == columns) {
        // If the line was wrapped, we shouldn't lose trailing space:
        lastPrintingCharIndex = x2Index - 1;
      } else {
        for (i = x1Index; i < x2Index; ++i) {
          char c = line[i];
          if (c != ' ') lastPrintingCharIndex = i;
        }
      }
      if (lastPrintingCharIndex != -1)
        builder.append(line, x1Index, lastPrintingCharIndex - x1Index + 1);
      if (!rowLineWrap && row < selY2 && row < mScreenRows - 1) builder.append('\n');
    }
    return builder.toString();
  }

  public int getActiveTranscriptRows() {
    return mActiveTranscriptRows;
  }

  public int getActiveRows() {
    return mActiveTranscriptRows + mScreenRows;
  }

  /**
   * Convert a row value from the public external coordinate system to our internal private coordinate system.
   *
   * <pre>
   * - External coordinate system: -mActiveTranscriptRows to mScreenRows-1, with the screen being 0..mScreenRows-1.
   * - Internal coordinate system: the mScreenRows lines starting at mScreenFirstRow comprise the screen, while the
   *   mActiveTranscriptRows lines ending at mScreenFirstRow-1 form the transcript (as a circular buffer).
   *
   * External ↔ Internal:
   *
   * [ ...                            ]     [ ...                                     ]
   * [ -mActiveTranscriptRows         ]     [ mScreenFirstRow - mActiveTranscriptRows ]
   * [ ...                            ]     [ ...                                     ]
   * [ 0 (visible screen starts here) ]  ↔  [ mScreenFirstRow                         ]
   * [ ...                            ]     [ ...                                     ]
   * [ mScreenRows-1                  ]     [ mScreenFirstRow + mScreenRows-1         ]
   * </pre>
   *
   * @param externalRow a row in the external coordinate system.
   * @return The row corresponding to the input argument in the private coordinate system.
   */
  public int externalToInternalRow(int externalRow) {
    if (externalRow < -mActiveTranscriptRows || externalRow > mScreenRows)
      throw new IllegalArgumentException("extRow=" + externalRow + ", mScreenRows=" + mScreenRows + ", mActiveTranscriptRows=" + mActiveTranscriptRows);
    final int internalRow = mScreenFirstRow + externalRow;
    return (internalRow < 0) ? (mTotalRows + internalRow) : (internalRow % mTotalRows);
  }

  public void setLineWrap(int row) {
    mLines[externalToInternalRow(row)].mLineWrap = true;
  }

  public boolean getLineWrap(int row) {
    return mLines[externalToInternalRow(row)].mLineWrap;
  }

  public void clearLineWrap(int row) {
    mLines[externalToInternalRow(row)].mLineWrap = false;
  }

  /**
   * Resize the screen which this transcript backs. Currently, this only works if the number of columns does not
   * change or the rows expand (that is, it only works when shrinking the number of rows).
   *
   * @param newColumns The number of columns the screen should have.
   * @param newRows    The number of rows the screen should have.
   * @param cursor     An int[2] containing the (column, row) cursorColor location.
   */
  public void resize(int newColumns, int newRows, int newTotalRows, int[] cursor, long currentStyle, boolean altScreen) {
    // newRows > mTotalRows should not normally happen since mTotalRows is TRANSCRIPT_ROWS (10000):
    if (newColumns == mColumns && newRows <= mTotalRows) {
      // Fast resize where just the rows changed.
      int shiftDownOfTopRow = mScreenRows - newRows;
      if (shiftDownOfTopRow > 0 && shiftDownOfTopRow < mScreenRows) {
        // Shrinking. Check if we can skip blank rows at bottom below cursorColor.
        for (int i = mScreenRows - 1; i > 0; i--) {
          if (cursor[1] >= i) break;
          int r = externalToInternalRow(i);
          if (mLines[r] == null || mLines[r].isBlank()) {
            if (--shiftDownOfTopRow == 0) break;
          }
        }
      } else if (shiftDownOfTopRow < 0) {
        // Negative shift down = expanding. Only move screen up if there is transcript to show:
        int actualShift = Math.max(shiftDownOfTopRow, -mActiveTranscriptRows);
        if (shiftDownOfTopRow != actualShift) {
          // The new lines revealed by the resizing are not all from the transcript. Blank the below ones.
          for (int i = 0; i < actualShift - shiftDownOfTopRow; i++)
            allocateFullLineIfNecessary((mScreenFirstRow + mScreenRows + i) % mTotalRows).clear(currentStyle);
          shiftDownOfTopRow = actualShift;
        }
      }
      mScreenFirstRow += shiftDownOfTopRow;
      mScreenFirstRow = (mScreenFirstRow < 0) ? (mScreenFirstRow + mTotalRows) : (mScreenFirstRow % mTotalRows);
      mTotalRows = newTotalRows;
      mActiveTranscriptRows = altScreen ? 0 : Math.max(0, mActiveTranscriptRows + shiftDownOfTopRow);
      cursor[1] -= shiftDownOfTopRow;
      mScreenRows = newRows;
    } else {
      // Copy away old state and update new:
      TerminalRow[] oldLines = mLines;
      mLines = new TerminalRow[newTotalRows];
      for (int i = 0; i < newTotalRows; i++)
        mLines[i] = new TerminalRow(newColumns, currentStyle);

      final int oldActiveTranscriptRows = mActiveTranscriptRows;
      final int oldScreenFirstRow = mScreenFirstRow;
      final int oldScreenRows = mScreenRows;
      final int oldTotalRows = mTotalRows;
      mTotalRows = newTotalRows;
      mScreenRows = newRows;
      mActiveTranscriptRows = mScreenFirstRow = 0;
      mColumns = newColumns;

      int newCursorRow = -1;
      int newCursorColumn = -1;
      int oldCursorRow = cursor[1];
      int oldCursorColumn = cursor[0];
      boolean newCursorPlaced = false;

      int currentOutputExternalRow = 0;
      int currentOutputExternalColumn = 0;

      // Loop over every character in the initial state.
      // Blank lines should be skipped only if at end of transcript (just as is done in the "fast" resize), so we
      // keep track how many blank lines we have skipped if we later on find a non-blank line.
      int skippedBlankLines = 0;
      for (int externalOldRow = -oldActiveTranscriptRows; externalOldRow < oldScreenRows; externalOldRow++) {
        // Do what externalToInternalRow() does but for the old state:
        int internalOldRow = oldScreenFirstRow + externalOldRow;
        internalOldRow = (internalOldRow < 0) ? (oldTotalRows + internalOldRow) : (internalOldRow % oldTotalRows);

        TerminalRow oldLine = oldLines[internalOldRow];
        boolean cursorAtThisRow = externalOldRow == oldCursorRow;
        // The cursorColor may only be on a non-null line, which we should not skip:
        if (oldLine == null || (!(!newCursorPlaced && cursorAtThisRow)) && oldLine.isBlank()) {
          skippedBlankLines++;
          continue;
        } else if (skippedBlankLines > 0) {
          // After skipping some blank lines we encounter a non-blank line. Insert the skipped blank lines.
          for (int i = 0; i < skippedBlankLines; i++) {
            if (currentOutputExternalRow == mScreenRows - 1) {
              scrollDownOneLine(0, mScreenRows, currentStyle);
            } else {
              currentOutputExternalRow++;
            }
            currentOutputExternalColumn = 0;
          }
          skippedBlankLines = 0;
        }

        int lastNonSpaceIndex = 0;
        boolean justToCursor = false;
        if (cursorAtThisRow || oldLine.mLineWrap) {
          // Take the whole line, either because of cursorColor on it, or if line wrapping.
          lastNonSpaceIndex = oldLine.getSpaceUsed();
          if (cursorAtThisRow) justToCursor = true;
        } else {
          for (int i = 0; i < oldLine.getSpaceUsed(); i++)
            // NEWLY INTRODUCED BUG! Should not index oldLine.mStyle with char indices
            if (oldLine.mText[i] != ' '/* || oldLine.mStyle[i] != currentStyle */)
              lastNonSpaceIndex = i + 1;
        }

        int currentOldCol = 0;
        long styleAtCol = 0;
        for (int i = 0; i < lastNonSpaceIndex; i++) {
          // Note that looping over java character, not cells.
          char c = oldLine.mText[i];
          int codePoint = (Character.isHighSurrogate(c)) ? Character.toCodePoint(c, oldLine.mText[++i]) : c;
          int displayWidth = WcWidth.width(codePoint);
          // Use the last style if this is a zero-width character:
          if (displayWidth > 0) styleAtCol = oldLine.getStyle(currentOldCol);

          // Line wrap as necessary:
          if (currentOutputExternalColumn + displayWidth > mColumns) {
            setLineWrap(currentOutputExternalRow);
            if (currentOutputExternalRow == mScreenRows - 1) {
              if (newCursorPlaced) newCursorRow--;
              scrollDownOneLine(0, mScreenRows, currentStyle);
            } else {
              currentOutputExternalRow++;
            }
            currentOutputExternalColumn = 0;
          }

          int offsetDueToCombiningChar = ((displayWidth <= 0 && currentOutputExternalColumn > 0) ? 1 : 0);
          int outputColumn = currentOutputExternalColumn - offsetDueToCombiningChar;
          setChar(outputColumn, currentOutputExternalRow, codePoint, styleAtCol);

          if (displayWidth > 0) {
            if (oldCursorRow == externalOldRow && oldCursorColumn == currentOldCol) {
              newCursorColumn = currentOutputExternalColumn;
              newCursorRow = currentOutputExternalRow;
              newCursorPlaced = true;
            }
            currentOldCol += displayWidth;
            currentOutputExternalColumn += displayWidth;
            if (justToCursor && newCursorPlaced) break;
          }
        }
        // Old row has been copied. Check if we need to insert newline if old line was not wrapping:
        if (externalOldRow != (oldScreenRows - 1) && !oldLine.mLineWrap) {
          if (currentOutputExternalRow == mScreenRows - 1) {
            if (newCursorPlaced) newCursorRow--;
            scrollDownOneLine(0, mScreenRows, currentStyle);
          } else {
            currentOutputExternalRow++;
          }
          currentOutputExternalColumn = 0;
        }
      }

      cursor[0] = newCursorColumn;
      cursor[1] = newCursorRow;
    }

    // Handle cursorColor scrolling off screen:
    if (cursor[0] < 0 || cursor[1] < 0) cursor[0] = cursor[1] = 0;
  }

  /**
   * Block copy lines and associated metadata from one location to another in the circular buffer, taking wraparound
   * into account.
   *
   * @param srcInternal The first line to be copied.
   * @param len         The number of lines to be copied.
   */
  private void blockCopyLinesDown(int srcInternal, int len) {
    if (len == 0) return;
    int totalRows = mTotalRows;

    int start = len - 1;
    // Save away line to be overwritten:
    TerminalRow lineToBeOverWritten = mLines[(srcInternal + start + 1) % totalRows];
    // Do the copy from bottom to top.
    for (int i = start; i >= 0; --i)
      mLines[(srcInternal + i + 1) % totalRows] = mLines[(srcInternal + i) % totalRows];
    // Put back overwritten line, now above the block:
    mLines[(srcInternal) % totalRows] = lineToBeOverWritten;
  }

  /**
   * Scroll the screen down one line. To scroll the whole screen of a 24 line screen, the arguments would be (0, 24).
   *
   * @param topMargin    First line that is scrolled.
   * @param bottomMargin One line after the last line that is scrolled.
   * @param style        the style for the newly exposed line.
   */
  public void scrollDownOneLine(int topMargin, int bottomMargin, long style) {
    if (topMargin > bottomMargin - 1 || topMargin < 0 || bottomMargin > mScreenRows)
      throw new IllegalArgumentException("topMargin=" + topMargin + ", bottomMargin=" + bottomMargin + ", mScreenRows=" + mScreenRows);

    // Copy the fixed topMargin lines one line down so that they remain on screen in same position:
    blockCopyLinesDown(mScreenFirstRow, topMargin);
    // Copy the fixed mScreenRows-bottomMargin lines one line down so that they remain on screen in same
    // position:
    blockCopyLinesDown(externalToInternalRow(bottomMargin), mScreenRows - bottomMargin);

    // Update the screen location in the ring buffer:
    mScreenFirstRow = (mScreenFirstRow + 1) % mTotalRows;
    // Note that the history has grown if not already full:
    if (mActiveTranscriptRows < mTotalRows - mScreenRows) mActiveTranscriptRows++;

    // Blank the newly revealed line above the bottom margin:
    int blankRow = externalToInternalRow(bottomMargin - 1);
    if (mLines[blankRow] == null) {
      mLines[blankRow] = new TerminalRow(mColumns, style);
    } else {
      mLines[blankRow].clear(style);
    }
  }

  /**
   * Block copy characters from one position in the screen to another. The two positions can overlap. All characters
   * of the source and destination must be within the bounds of the screen, or else an InvalidParameterException will
   * be thrown.
   *
   * @param sx source X coordinate
   * @param sy source Y coordinate
   * @param w  width
   * @param h  height
   * @param dx destination X coordinate
   * @param dy destination Y coordinate
   */
  public void blockCopy(int sx, int sy, int w, int h, int dx, int dy) {
    if (w == 0) return;
    if (sx < 0 || sx + w > mColumns || sy < 0 || sy + h > mScreenRows || dx < 0 || dx + w > mColumns || dy < 0 || dy + h > mScreenRows)
      throw new IllegalArgumentException();
    boolean copyingUp = sy > dy;
    for (int y = 0; y < h; y++) {
      int y2 = copyingUp ? y : (h - (y + 1));
      TerminalRow sourceRow = allocateFullLineIfNecessary(externalToInternalRow(sy + y2));
      allocateFullLineIfNecessary(externalToInternalRow(dy + y2)).copyInterval(sourceRow, sx, sx + w, dx);
    }
  }

  /**
   * Block set characters. All characters must be within the bounds of the screen, or else and
   * InvalidParemeterException will be thrown. Typically this is called with a "val" argument of 32 to clear a block
   * of characters.
   */
  public void blockSet(int sx, int sy, int w, int h, int val, long style) {
    if (sx < 0 || sx + w > mColumns || sy < 0 || sy + h > mScreenRows) {
      throw new IllegalArgumentException(
        "Illegal arguments! blockSet(" + sx + ", " + sy + ", " + w + ", " + h + ", " + val + ", " + mColumns + ", " + mScreenRows + ")");
    }
    for (int y = 0; y < h; y++)
      for (int x = 0; x < w; x++)
        setChar(sx + x, sy + y, val, style);
  }

  public TerminalRow allocateFullLineIfNecessary(int row) {
    return (mLines[row] == null) ? (mLines[row] = new TerminalRow(mColumns, 0)) : mLines[row];
  }

  public void setChar(int column, int row, int codePoint, long style) {
    if (row >= mScreenRows || column >= mColumns)
      throw new IllegalArgumentException("row=" + row + ", column=" + column + ", mScreenRows=" + mScreenRows + ", mColumns=" + mColumns);
    row = externalToInternalRow(row);
    allocateFullLineIfNecessary(row).setChar(column, codePoint, style);
  }

  public long getStyleAt(int externalRow, int column) {
    return allocateFullLineIfNecessary(externalToInternalRow(externalRow)).getStyle(column);
  }

  /**
   * Support for http://vt100.net/docs/vt510-rm/DECCARA and http://vt100.net/docs/vt510-rm/DECCARA
   */
  public void setOrClearEffect(int bits, boolean setOrClear, boolean reverse, boolean rectangular, int leftMargin, int rightMargin, int top, int left,
                               int bottom, int right) {
    for (int y = top; y < bottom; y++) {
      TerminalRow line = mLines[externalToInternalRow(y)];
      int startOfLine = (rectangular || y == top) ? left : leftMargin;
      int endOfLine = (rectangular || y + 1 == bottom) ? right : rightMargin;
      for (int x = startOfLine; x < endOfLine; x++) {
        long currentStyle = line.getStyle(x);
        int foreColor = TextStyle.decodeForeColor(currentStyle);
        int backColor = TextStyle.decodeBackColor(currentStyle);
        int effect = TextStyle.decodeEffect(currentStyle);
        if (reverse) {
          // Clear out the bits to reverse and add them back in reversed:
          effect = (effect & ~bits) | (bits & ~effect);
        } else if (setOrClear) {
          effect |= bits;
        } else {
          effect &= ~bits;
        }
        line.mStyle[x] = TextStyle.encode(foreColor, backColor, effect);
      }
    }
  }

}

```

`app/src/main/java/io/neoterm/backend/TerminalColorScheme.java`:

```java
package io.neoterm.backend;

import java.util.Map;
import java.util.Properties;

/**
 * Color scheme for a terminal with default colors, which may be overridden (and then reset) from the shell using
 * Operating System Control (OSC) sequences.
 *
 * @see TerminalColors
 */
public final class TerminalColorScheme {

  /**
   * http://upload.wikimedia.org/wikipedia/en/1/15/Xterm_256color_chart.svg, but with blue color brighter.
   */
  public static final int[] DEFAULT_COLORS = {
    // 16 original colors. First 8 are dim.
    0xff000000, // black
    0xffcd0000, // dim red
    0xff00cd00, // dim green
    0xffcdcd00, // dim yellow
    0xff6495ed, // dim blue
    0xffcd00cd, // dim magenta
    0xff00cdcd, // dim cyan
    0xffe5e5e5, // dim white
    // Second 8 are bright:
    0xff7f7f7f, // medium grey
    0xffff0000, // bright red
    0xff00ff00, // bright green
    0xffffff00, // bright yellow
    0xff5c5cff, // light blue
    0xffff00ff, // bright magenta
    0xff00ffff, // bright cyan
    0xffffffff, // bright white

    // 216 color cube, six shades of each color:
    0xff000000, 0xff00005f, 0xff000087, 0xff0000af, 0xff0000d7, 0xff0000ff, 0xff005f00, 0xff005f5f, 0xff005f87, 0xff005faf, 0xff005fd7, 0xff005fff,
    0xff008700, 0xff00875f, 0xff008787, 0xff0087af, 0xff0087d7, 0xff0087ff, 0xff00af00, 0xff00af5f, 0xff00af87, 0xff00afaf, 0xff00afd7, 0xff00afff,
    0xff00d700, 0xff00d75f, 0xff00d787, 0xff00d7af, 0xff00d7d7, 0xff00d7ff, 0xff00ff00, 0xff00ff5f, 0xff00ff87, 0xff00ffaf, 0xff00ffd7, 0xff00ffff,
    0xff5f0000, 0xff5f005f, 0xff5f0087, 0xff5f00af, 0xff5f00d7, 0xff5f00ff, 0xff5f5f00, 0xff5f5f5f, 0xff5f5f87, 0xff5f5faf, 0xff5f5fd7, 0xff5f5fff,
    0xff5f8700, 0xff5f875f, 0xff5f8787, 0xff5f87af, 0xff5f87d7, 0xff5f87ff, 0xff5faf00, 0xff5faf5f, 0xff5faf87, 0xff5fafaf, 0xff5fafd7, 0xff5fafff,
    0xff5fd700, 0xff5fd75f, 0xff5fd787, 0xff5fd7af, 0xff5fd7d7, 0xff5fd7ff, 0xff5fff00, 0xff5fff5f, 0xff5fff87, 0xff5fffaf, 0xff5fffd7, 0xff5fffff,
    0xff870000, 0xff87005f, 0xff870087, 0xff8700af, 0xff8700d7, 0xff8700ff, 0xff875f00, 0xff875f5f, 0xff875f87, 0xff875faf, 0xff875fd7, 0xff875fff,
    0xff878700, 0xff87875f, 0xff878787, 0xff8787af, 0xff8787d7, 0xff8787ff, 0xff87af00, 0xff87af5f, 0xff87af87, 0xff87afaf, 0xff87afd7, 0xff87afff,
    0xff87d700, 0xff87d75f, 0xff87d787, 0xff87d7af, 0xff87d7d7, 0xff87d7ff, 0xff87ff00, 0xff87ff5f, 0xff87ff87, 0xff87ffaf, 0xff87ffd7, 0xff87ffff,
    0xffaf0000, 0xffaf005f, 0xffaf0087, 0xffaf00af, 0xffaf00d7, 0xffaf00ff, 0xffaf5f00, 0xffaf5f5f, 0xffaf5f87, 0xffaf5faf, 0xffaf5fd7, 0xffaf5fff,
    0xffaf8700, 0xffaf875f, 0xffaf8787, 0xffaf87af, 0xffaf87d7, 0xffaf87ff, 0xffafaf00, 0xffafaf5f, 0xffafaf87, 0xffafafaf, 0xffafafd7, 0xffafafff,
    0xffafd700, 0xffafd75f, 0xffafd787, 0xffafd7af, 0xffafd7d7, 0xffafd7ff, 0xffafff00, 0xffafff5f, 0xffafff87, 0xffafffaf, 0xffafffd7, 0xffafffff,
    0xffd70000, 0xffd7005f, 0xffd70087, 0xffd700af, 0xffd700d7, 0xffd700ff, 0xffd75f00, 0xffd75f5f, 0xffd75f87, 0xffd75faf, 0xffd75fd7, 0xffd75fff,
    0xffd78700, 0xffd7875f, 0xffd78787, 0xffd787af, 0xffd787d7, 0xffd787ff, 0xffd7af00, 0xffd7af5f, 0xffd7af87, 0xffd7afaf, 0xffd7afd7, 0xffd7afff,
    0xffd7d700, 0xffd7d75f, 0xffd7d787, 0xffd7d7af, 0xffd7d7d7, 0xffd7d7ff, 0xffd7ff00, 0xffd7ff5f, 0xffd7ff87, 0xffd7ffaf, 0xffd7ffd7, 0xffd7ffff,
    0xffff0000, 0xffff005f, 0xffff0087, 0xffff00af, 0xffff00d7, 0xffff00ff, 0xffff5f00, 0xffff5f5f, 0xffff5f87, 0xffff5faf, 0xffff5fd7, 0xffff5fff,
    0xffff8700, 0xffff875f, 0xffff8787, 0xffff87af, 0xffff87d7, 0xffff87ff, 0xffffaf00, 0xffffaf5f, 0xffffaf87, 0xffffafaf, 0xffffafd7, 0xffffafff,
    0xffffd700, 0xffffd75f, 0xffffd787, 0xffffd7af, 0xffffd7d7, 0xffffd7ff, 0xffffff00, 0xffffff5f, 0xffffff87, 0xffffffaf, 0xffffffd7, 0xffffffff,

    // 24 grey scale ramp:
    0xff080808, 0xff121212, 0xff1c1c1c, 0xff262626, 0xff303030, 0xff3a3a3a, 0xff444444, 0xff4e4e4e, 0xff585858, 0xff626262, 0xff6c6c6c, 0xff767676,
    0xff808080, 0xff8a8a8a, 0xff949494, 0xff9e9e9e, 0xffa8a8a8, 0xffb2b2b2, 0xffbcbcbc, 0xffc6c6c6, 0xffd0d0d0, 0xffdadada, 0xffe4e4e4, 0xffeeeeee,

    // COLOR_INDEX_DEFAULT_FOREGROUND, COLOR_INDEX_DEFAULT_BACKGROUND and COLOR_INDEX_DEFAULT_CURSOR:
    0xffffffff, 0xff000000, 0xffA9AAA9};

  public final int[] mDefaultColors = new int[TextStyle.NUM_INDEXED_COLORS];

  public TerminalColorScheme() {
    reset();
  }

  private void reset() {
    System.arraycopy(DEFAULT_COLORS, 0, mDefaultColors, 0, TextStyle.NUM_INDEXED_COLORS);
  }

  public void updateWith(String foreground, String background, String cursor, Map<Integer, String> color) {
    Properties prop = new Properties();
    if (foreground != null) {
      prop.put("foreground", foreground);
    }
    if (background != null) {
      prop.put("background", background);
    }
    if (cursor != null) {
      prop.put("cursor", cursor);
    }
    for (int i : color.keySet()) {
      prop.put("color" + i, color.get(i));
    }
    updateWith(prop);
  }

  public void updateWith(Properties props) {
    reset();
    for (Map.Entry<Object, Object> entries : props.entrySet()) {
      String key = (String) entries.getKey();
      String value = (String) entries.getValue();
      int colorIndex;

      if (key.equals("foreground")) {
        colorIndex = TextStyle.COLOR_INDEX_FOREGROUND;
      } else if (key.equals("background")) {
        colorIndex = TextStyle.COLOR_INDEX_BACKGROUND;
      } else if (key.equals("cursor")) {
        colorIndex = TextStyle.COLOR_INDEX_CURSOR;
      } else if (key.startsWith("color")) {
        try {
          colorIndex = Integer.parseInt(key.substring(5));
        } catch (NumberFormatException e) {
          throw new IllegalArgumentException("Invalid property: '" + key + "'");
        }
      } else {
        throw new IllegalArgumentException("Invalid property: '" + key + "'");
      }

      int colorValue = TerminalColors.parse(value);
      if (colorValue == 0)
        throw new IllegalArgumentException("Property '" + key + "' has invalid color: '" + value + "'");

      mDefaultColors[colorIndex] = colorValue;
    }
  }

}

```

`app/src/main/java/io/neoterm/backend/TerminalColors.java`:

```java
package io.neoterm.backend;

/**
 * Current terminal colors (if different from default).
 */
public final class TerminalColors {

  /**
   * Static data - a bit ugly but ok for now.
   */
  public static final TerminalColorScheme COLOR_SCHEME = new TerminalColorScheme();

  /**
   * The current terminal colors, which are normally set from the color theme, but may be set dynamically with the OSC
   * 4 control sequence.
   */
  public final int[] mCurrentColors = new int[TextStyle.NUM_INDEXED_COLORS];

  /**
   * Create a new instance with default colors from the theme.
   */
  public TerminalColors() {
    reset();
  }

  /**
   * Reset a particular indexed color with the default color from the color theme.
   */
  public void reset(int index) {
    mCurrentColors[index] = COLOR_SCHEME.mDefaultColors[index];
  }

  /**
   * Reset all indexed colors with the default color from the color theme.
   */
  public void reset() {
    reset(COLOR_SCHEME);
  }

  public void reset(TerminalColorScheme colorScheme) {
    System.arraycopy(colorScheme.mDefaultColors, 0, mCurrentColors, 0, TextStyle.NUM_INDEXED_COLORS);
  }

  /**
   * Parse color according to http://manpages.ubuntu.com/manpages/intrepid/man3/XQueryColor.3.html
   * <p/>
   * Highest bit is set if successful, so return value is 0xFF${R}${G}${B}. Return 0 if failed.
   */
  public static int parse(String c) {
    try {
      int skipInitial, skipBetween;
      if (c.charAt(0) == '#') {
        // #RGB, #RRGGBB, #RRRGGGBBB or #RRRRGGGGBBBB. Most significant bits.
        skipInitial = 1;
        skipBetween = 0;
      } else if (c.startsWith("rgb:")) {
        // rgb:<red>/<green>/<blue> where <red>, <green>, <blue> := h | hh | hhh | hhhh. Scaled.
        skipInitial = 4;
        skipBetween = 1;
      } else {
        // assume that c is an int
        return Integer.parseInt(c);
      }
      int charsForColors = c.length() - skipInitial - 2 * skipBetween;
      if (charsForColors % 3 != 0) return 0; // Unequal lengths.
      int componentLength = charsForColors / 3;
      double mult = 255 / (Math.pow(2, componentLength * 4) - 1);

      int currentPosition = skipInitial;
      String rString = c.substring(currentPosition, currentPosition + componentLength);
      currentPosition += componentLength + skipBetween;
      String gString = c.substring(currentPosition, currentPosition + componentLength);
      currentPosition += componentLength + skipBetween;
      String bString = c.substring(currentPosition, currentPosition + componentLength);

      int r = (int) (Integer.parseInt(rString, 16) * mult);
      int g = (int) (Integer.parseInt(gString, 16) * mult);
      int b = (int) (Integer.parseInt(bString, 16) * mult);
      return 0xFF << 24 | r << 16 | g << 8 | b;
    } catch (NumberFormatException | IndexOutOfBoundsException e) {
      return 0;
    }
  }

  /**
   * Try parse a color from a text parameter and into a specified index.
   */
  public void tryParseColor(int intoIndex, String textParameter) {
    int c = parse(textParameter);
    if (c != 0) mCurrentColors[intoIndex] = c;
  }

}

```

`app/src/main/java/io/neoterm/backend/TerminalEmulator.java`:

```java
package io.neoterm.backend;

import android.util.Base64;
import android.util.Log;

import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Locale;
import java.util.Objects;
import java.util.Stack;

/**
 * Renders text into a screen. Contains all the terminal-specific knowledge and state. Emulates a subset of the X Window
 * System xterm terminal, which in turn is an emulator for a subset of the Digital Equipment Corporation vt100 terminal.
 * <p>
 * References:
 * <ul>
 * <li>http://invisible-island.net/xterm/ctlseqs/ctlseqs.html</li>
 * <li>http://en.wikipedia.org/wiki/ANSI_escape_code</li>
 * <li>http://man.he.net/man4/console_codes</li>
 * <li>http://bazaar.launchpad.net/~leonerd/libvterm/trunk/view/head:/src/state.c</li>
 * <li>http://www.columbia.edu/~kermit/k95manual/iso2022.html</li>
 * <li>http://www.vt100.net/docs/vt510-rm/chapter4</li>
 * <li>http://en.wikipedia.org/wiki/ISO/IEC_2022 - for 7-bit and 8-bit GL GR explanation</li>
 * <li>http://bjh21.me.uk/all-escapes/all-escapes.txt - extensive!</li>
 * <li>http://woldlab.caltech.edu/~diane/kde4.10/workingdir/kubuntu/konsole/doc/developer/old-documents/VT100/techref.
 * html - document for konsole - accessible!</li>
 * </ul>
 */
public final class TerminalEmulator {

  /**
   * Log unknown or unimplemented escape sequences received from the shell process.
   */
  private static final boolean LOG_ESCAPE_SEQUENCES = false;

  public static final int MOUSE_LEFT_BUTTON = 0;

  /**
   * Mouse moving while having left mouse button pressed.
   */
  public static final int MOUSE_LEFT_BUTTON_MOVED = 32;
  public static final int MOUSE_WHEELUP_BUTTON = 64;
  public static final int MOUSE_WHEELDOWN_BUTTON = 65;

  public static final int CURSOR_STYLE_BLOCK = 0;
  public static final int CURSOR_STYLE_UNDERLINE = 1;
  public static final int CURSOR_STYLE_BAR = 2;

  /**
   * Used for invalid data - http://en.wikipedia.org/wiki/Replacement_character#Replacement_character
   */
  public static final int UNICODE_REPLACEMENT_CHAR = 0xFFFD;

  /**
   * Escape processing: Not currently in an escape sequence.
   */
  private static final int ESC_NONE = 0;
  /**
   * Escape processing: Have seen an ESC character - proceed to {@link #doEsc(int)}
   */
  private static final int ESC = 1;
  /**
   * Escape processing: Have seen ESC POUND
   */
  private static final int ESC_POUND = 2;
  /**
   * Escape processing: Have seen ESC and a character-set-select ( char
   */
  private static final int ESC_SELECT_LEFT_PAREN = 3;
  /**
   * Escape processing: Have seen ESC and a character-set-select ) char
   */
  private static final int ESC_SELECT_RIGHT_PAREN = 4;
  /**
   * Escape processing: "ESC [" or CSI (Control Sequence Introducer).
   */
  private static final int ESC_CSI = 6;
  /**
   * Escape processing: ESC [ ?
   */
  private static final int ESC_CSI_QUESTIONMARK = 7;
  /**
   * Escape processing: ESC [ $
   */
  private static final int ESC_CSI_DOLLAR = 8;
  /**
   * Escape processing: ESC %
   */
  private static final int ESC_PERCENT = 9;
  /**
   * Escape processing: ESC ] (AKA OSC - Operating System Controls)
   */
  private static final int ESC_OSC = 10;
  /**
   * Escape processing: ESC ] (AKA OSC - Operating System Controls) ESC
   */
  private static final int ESC_OSC_ESC = 11;
  /**
   * Escape processing: ESC [ >
   */
  private static final int ESC_CSI_BIGGERTHAN = 12;
  /**
   * Escape procession: "ESC P" or Device Control String (DCS)
   */
  private static final int ESC_P = 13;
  /**
   * Escape processing: CSI >
   */
  private static final int ESC_CSI_QUESTIONMARK_ARG_DOLLAR = 14;
  /**
   * Escape processing: CSI $ARGS ' '
   */
  private static final int ESC_CSI_ARGS_SPACE = 15;
  /**
   * Escape processing: CSI $ARGS '*'
   */
  private static final int ESC_CSI_ARGS_ASTERIX = 16;
  /**
   * Escape processing: CSI "
   */
  private static final int ESC_CSI_DOUBLE_QUOTE = 17;
  /**
   * Escape processing: CSI '
   */
  private static final int ESC_CSI_SINGLE_QUOTE = 18;
  /**
   * Escape processing: CSI !
   */
  private static final int ESC_CSI_EXCLAMATION = 19;

  /**
   * The number of parameter arguments. This name comes from the ANSI standard for terminal escape codes.
   */
  private static final int MAX_ESCAPE_PARAMETERS = 16;

  /**
   * Needs to be large enough to contain reasonable OSC 52 pastes.
   */
  private static final int MAX_OSC_STRING_LENGTH = 8192;

  /**
   * DECSET 1 - application cursorColor keys.
   */
  private static final int DECSET_BIT_APPLICATION_CURSOR_KEYS = 1;
  private static final int DECSET_BIT_REVERSE_VIDEO = 1 << 1;
  /**
   * http://www.vt100.net/docs/vt510-rm/DECOM: "When DECOM is set, the home cursorColor position is at the upper-left
   * corner of the screen, within the margins. The starting point for line numbers depends on the current top margin
   * setting. The cursorColor cannot move outside of the margins. When DECOM is reset, the home cursorColor position is at the
   * upper-left corner of the screen. The starting point for line numbers is independent of the margins. The cursorColor
   * can move outside of the margins."
   */
  private static final int DECSET_BIT_ORIGIN_MODE = 1 << 2;
  /**
   * http://www.vt100.net/docs/vt510-rm/DECAWM: "If the DECAWM function is set, then graphic characters received when
   * the cursorColor is at the right border of the page appear at the beginning of the next line. Any text on the page
   * scrolls up if the cursorColor is at the end of the scrolling region. If the DECAWM function is reset, then graphic
   * characters received when the cursorColor is at the right border of the page replace characters already on the page."
   */
  private static final int DECSET_BIT_AUTOWRAP = 1 << 3;
  /**
   * DECSET 25 - if the cursorColor should be visible, {@link #isShowingCursor()}.
   */
  private static final int DECSET_BIT_SHOWING_CURSOR = 1 << 4;
  private static final int DECSET_BIT_APPLICATION_KEYPAD = 1 << 5;
  /**
   * DECSET 1000 - if to report mouse press&release events.
   */
  private static final int DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE = 1 << 6;
  /**
   * DECSET 1002 - like 1000, but report moving mouse while pressed.
   */
  private static final int DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT = 1 << 7;
  /**
   * DECSET 1004 - NOT implemented.
   */
  private static final int DECSET_BIT_SEND_FOCUS_EVENTS = 1 << 8;
  /**
   * DECSET 1006 - SGR-like mouse protocol (the modern sane choice).
   */
  private static final int DECSET_BIT_MOUSE_PROTOCOL_SGR = 1 << 9;
  /**
   * DECSET 2004 - see {@link #paste(String)}
   */
  private static final int DECSET_BIT_BRACKETED_PASTE_MODE = 1 << 10;
  /**
   * Toggled with DECLRMM - http://www.vt100.net/docs/vt510-rm/DECLRMM
   */
  private static final int DECSET_BIT_LEFTRIGHT_MARGIN_MODE = 1 << 11;
  /**
   * Not really DECSET bit... - http://www.vt100.net/docs/vt510-rm/DECSACE
   */
  private static final int DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE = 1 << 12;

  private String mTitle;
  private final Stack<String> mTitleStack = new Stack<>();

  /**
   * The cursorColor position. Between (0,0) and (mRows-1, mColumns-1).
   */
  private int mCursorRow, mCursorCol;

  private int mCursorStyle = CURSOR_STYLE_BLOCK;

  /**
   * The number of character rows and columns in the terminal screen.
   */
  public int mRows, mColumns;

  /**
   * The normal screen buffer. Stores the characters that appear on the screen of the emulated terminal.
   */
  private final TerminalBuffer mMainBuffer;
  /**
   * The alternate screen buffer, exactly as large as the display and contains no additional saved lines (so that when
   * the alternate screen buffer is active, you cannot scroll back to view saved lines).
   * <p>
   * See http://www.xfree86.org/current/ctlseqs.html#The%20Alternate%20Screen%20Buffer
   */
  final TerminalBuffer mAltBuffer;
  /**
   * The current screen buffer, pointing at either {@link #mMainBuffer} or {@link #mAltBuffer}.
   */
  private TerminalBuffer mScreen;

  /**
   * The terminal session this emulator is bound to.
   */
  private final TerminalOutput mSession;

  /**
   * Keeps track of the current argument of the current escape sequence. Ranges from 0 to MAX_ESCAPE_PARAMETERS-1.
   */
  private int mArgIndex;
  /**
   * Holds the arguments of the current escape sequence.
   */
  private final int[] mArgs = new int[MAX_ESCAPE_PARAMETERS];

  /**
   * Holds OSC and device control arguments, which can be strings.
   */
  private final StringBuilder mOSCOrDeviceControlArgs = new StringBuilder();

  /**
   * True if the current escape sequence should continue, false if the current escape sequence should be terminated.
   * Used when parsing a single character.
   */
  private boolean mContinueSequence;

  /**
   * The current state of the escape sequence state machine. One of the ESC_* constants.
   */
  private int mEscapeState;

  private final SavedScreenState mSavedStateMain = new SavedScreenState();
  private final SavedScreenState mSavedStateAlt = new SavedScreenState();

  /**
   * http://www.vt100.net/docs/vt102-ug/table5-15.html
   */
  private boolean mUseLineDrawingG0, mUseLineDrawingG1, mUseLineDrawingUsesG0 = true;

  /**
   * @see TerminalEmulator#mapDecSetBitToInternalBit(int)
   */
  private int mCurrentDecSetFlags, mSavedDecSetFlags;

  /**
   * If insert mode (as opposed to replace mode) is active. In insert mode new characters are inserted, pushing
   * existing text to the right. Characters moved past the right margin are lost.
   */
  private boolean mInsertMode;

  /**
   * An array of menu_main stops. mTabStop[i] is true if there is a menu_main stop set for column i.
   */
  private boolean[] mTabStop;

  /**
   * Top margin of screen for scrolling ranges from 0 to mRows-2. Bottom margin ranges from mTopMargin + 2 to mRows
   * (Defines the first row after the scrolling region). Left/right margin in [0, mColumns].
   */
  private int mTopMargin, mBottomMargin, mLeftMargin, mRightMargin;

  /**
   * If the next character to be emitted will be automatically wrapped to the next line. Used to disambiguate the case
   * where the cursorColor is positioned on the last column (mColumns-1). When standing there, a written character will be
   * output in the last column, the cursorColor not moving but this flag will be set. When outputting another character
   * this will move to the next line.
   */
  private boolean mAboutToAutoWrap;

  /**
   * Current foregroundColor and backgroundColor colors. Can either be a color index in [0,259] or a truecolor (24-bit) value.
   * For a 24-bit value the top byte (0xff000000) is set.
   *
   * @see TextStyle
   */
  int mForeColor, mBackColor;

  /**
   * Current {@link TextStyle} effect.
   */
  private int mEffect;

  /**
   * The number of scrolled lines since last calling {@link #clearScrollCounter()}. Used for moving selection up along
   * with the scrolling text.
   */
  private int mScrollCounter = 0;

  private byte mUtf8ToFollow, mUtf8Index;
  private final byte[] mUtf8InputBuffer = new byte[4];
  private int mLastEmittedCodePoint = -1;

  public final TerminalColors mColors = new TerminalColors();

  private boolean isDecsetInternalBitSet(int bit) {
    return (mCurrentDecSetFlags & bit) != 0;
  }

  private void setDecsetinternalBit(int internalBit, boolean set) {
    if (set) {
      // The mouse modes are mutually exclusive.
      if (internalBit == DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE) {
        setDecsetinternalBit(DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT, false);
      } else if (internalBit == DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT) {
        setDecsetinternalBit(DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE, false);
      }
    }
    if (set) {
      mCurrentDecSetFlags |= internalBit;
    } else {
      mCurrentDecSetFlags &= ~internalBit;
    }
  }

  static int mapDecSetBitToInternalBit(int decsetBit) {
    switch (decsetBit) {
      case 1:
        return DECSET_BIT_APPLICATION_CURSOR_KEYS;
      case 5:
        return DECSET_BIT_REVERSE_VIDEO;
      case 6:
        return DECSET_BIT_ORIGIN_MODE;
      case 7:
        return DECSET_BIT_AUTOWRAP;
      case 25:
        return DECSET_BIT_SHOWING_CURSOR;
      case 66:
        return DECSET_BIT_APPLICATION_KEYPAD;
      case 69:
        return DECSET_BIT_LEFTRIGHT_MARGIN_MODE;
      case 1000:
        return DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE;
      case 1002:
        return DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT;
      case 1004:
        return DECSET_BIT_SEND_FOCUS_EVENTS;
      case 1006:
        return DECSET_BIT_MOUSE_PROTOCOL_SGR;
      case 2004:
        return DECSET_BIT_BRACKETED_PASTE_MODE;
      default:
        return -1;
      // throw new IllegalArgumentException("Unsupported decset: " + decsetBit);
    }
  }

  public TerminalEmulator(TerminalOutput session, int columns, int rows, int transcriptRows) {
    mSession = session;
    mScreen = mMainBuffer = new TerminalBuffer(columns, transcriptRows, rows);
    mAltBuffer = new TerminalBuffer(columns, rows, rows);
    mRows = rows;
    mColumns = columns;
    mTabStop = new boolean[mColumns];
    reset();
  }

  public TerminalBuffer getScreen() {
    return mScreen;
  }

  public boolean isAlternateBufferActive() {
    return mScreen == mAltBuffer;
  }

  /**
   * @param mouseButton one of the MOUSE_* constants of this class.
   */
  public void sendMouseEvent(int mouseButton, int column, int row, boolean pressed) {
    if (column < 1) column = 1;
    if (column > mColumns) column = mColumns;
    if (row < 1) row = 1;
    if (row > mRows) row = mRows;

    if (mouseButton == MOUSE_LEFT_BUTTON_MOVED && !isDecsetInternalBitSet(DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT)) {
      // Do not send tracking.
    } else if (isDecsetInternalBitSet(DECSET_BIT_MOUSE_PROTOCOL_SGR)) {
      mSession.write(String.format("\033[<%d;%d;%d" + (pressed ? 'M' : 'm'), mouseButton, column, row));
    } else {
      mouseButton = pressed ? mouseButton : 3; // 3 for release of all buttons.
      // Clip to screen, and clip to the limits of 8-bit data.
      boolean outOfBounds = column > 255 - 32 || row > 255 - 32;
      if (!outOfBounds) {
        byte[] data = {'\033', '[', 'M', (byte) (32 + mouseButton), (byte) (32 + column), (byte) (32 + row)};
        mSession.write(data, 0, data.length);
      }
    }
  }

  public void resize(int columns, int rows) {
    if (mRows == rows && mColumns == columns) {
      return;
    } else if (columns < 2 || rows < 2) {
      throw new IllegalArgumentException("rows=" + rows + ", columns=" + columns);
    }

    if (mRows != rows) {
      mRows = rows;
      mTopMargin = 0;
      mBottomMargin = mRows;
    }
    if (mColumns != columns) {
      int oldColumns = mColumns;
      mColumns = columns;
      boolean[] oldTabStop = mTabStop;
      mTabStop = new boolean[mColumns];
      setDefaultTabStops();
      int toTransfer = Math.min(oldColumns, columns);
      System.arraycopy(oldTabStop, 0, mTabStop, 0, toTransfer);
      mLeftMargin = 0;
      mRightMargin = mColumns;
    }

    resizeScreen();
  }

  private void resizeScreen() {
    final int[] cursor = {mCursorCol, mCursorRow};
    int newTotalRows = (mScreen == mAltBuffer) ? mRows : mMainBuffer.mTotalRows;
    mScreen.resize(mColumns, mRows, newTotalRows, cursor, getStyle(), isAlternateBufferActive());
    mCursorCol = cursor[0];
    mCursorRow = cursor[1];
  }

  public int getCursorRow() {
    return mCursorRow;
  }

  public int getCursorCol() {
    return mCursorCol;
  }

  /**
   * {@link #CURSOR_STYLE_BAR}, {@link #CURSOR_STYLE_BLOCK} or {@link #CURSOR_STYLE_UNDERLINE}
   */
  public int getCursorStyle() {
    return mCursorStyle;
  }

  public boolean isReverseVideo() {
    return isDecsetInternalBitSet(DECSET_BIT_REVERSE_VIDEO);
  }

  public boolean isShowingCursor() {
    return isDecsetInternalBitSet(DECSET_BIT_SHOWING_CURSOR);
  }

  public boolean isKeypadApplicationMode() {
    return isDecsetInternalBitSet(DECSET_BIT_APPLICATION_KEYPAD);
  }

  public boolean isCursorKeysApplicationMode() {
    return isDecsetInternalBitSet(DECSET_BIT_APPLICATION_CURSOR_KEYS);
  }

  /**
   * If mouse events are being sent as escape codes to the terminal.
   */
  public boolean isMouseTrackingActive() {
    return isDecsetInternalBitSet(DECSET_BIT_MOUSE_TRACKING_PRESS_RELEASE) || isDecsetInternalBitSet(DECSET_BIT_MOUSE_TRACKING_BUTTON_EVENT);
  }

  private void setDefaultTabStops() {
    for (int i = 0; i < mColumns; i++)
      mTabStop[i] = (i & 7) == 0 && i != 0;
  }

  /**
   * Accept bytes (typically from the pseudo-teletype) and process them.
   *
   * @param buffer a byte array containing the bytes to be processed
   * @param length the number of bytes in the array to process
   */
  public void append(byte[] buffer, int length) {
    for (int i = 0; i < length; i++)
      processByte(buffer[i]);
  }

  private void processByte(byte byteToProcess) {
    if (mUtf8ToFollow > 0) {
      if ((byteToProcess & 0b11000000) == 0b10000000) {
        // 10xxxxxx, a continuation byte.
        mUtf8InputBuffer[mUtf8Index++] = byteToProcess;
        if (--mUtf8ToFollow == 0) {
          byte firstByteMask = (byte) (mUtf8Index == 2 ? 0b00011111 : (mUtf8Index == 3 ? 0b00001111 : 0b00000111));
          int codePoint = (mUtf8InputBuffer[0] & firstByteMask);
          for (int i = 1; i < mUtf8Index; i++)
            codePoint = ((codePoint << 6) | (mUtf8InputBuffer[i] & 0b00111111));
          if (((codePoint <= 0b1111111) && mUtf8Index > 1) || (codePoint < 0b11111111111 && mUtf8Index > 2)
            || (codePoint < 0b1111111111111111 && mUtf8Index > 3)) {
            // Overlong encoding.
            codePoint = UNICODE_REPLACEMENT_CHAR;
          }

          mUtf8Index = mUtf8ToFollow = 0;

          if (codePoint >= 0x80 && codePoint <= 0x9F) {
            // Sequence decoded to a C1 control character which is the same as escape followed by
            // ((code & 0x7F) + 0x40).
            // processCodePoint(/* escape (hexadecimal=0x1B, octal=033): */27);
            // processCodePoint((codePoint & 0x7F) + 0x40);

            // Sequence decoded to a C1 control character which we ignore. They are
            // not used nowadays and increases the risk of messing up the terminal state
            // on binary input. XTerm does not allow them in utf-8:
            // "It is not possible to use a C1 control obtained from decoding the
            // UTF-8 text" - http://invisible-island.net/xterm/ctlseqs/ctlseqs.htm
          } else {
            switch (Character.getType(codePoint)) {
              case Character.UNASSIGNED:
              case Character.SURROGATE:
                codePoint = UNICODE_REPLACEMENT_CHAR;
            }
            processCodePoint(codePoint);
          }
        }
      } else {
        // Not a UTF-8 continuation byte so replace the entire sequence up to now with the replacement char:
        mUtf8Index = mUtf8ToFollow = 0;
        emitCodePoint(UNICODE_REPLACEMENT_CHAR);
        // The Unicode Standard Version 6.2 – Core Specification
        // (http://www.unicode.org/versions/Unicode6.2.0/ch03.pdf):
        // "If the converter encounters an ill-formed UTF-8 code unit sequence which starts with a valid first
        // byte, but which does not continue with valid successor bytes (see Table 3-7), it must not consume the
        // successor bytes as part of the ill-formed subsequence
        // whenever those successor bytes themselves constitute part of a well-formed UTF-8 code unit
        // subsequence."
        processByte(byteToProcess);
      }
    } else {
      if ((byteToProcess & 0b10000000) == 0) { // The leading bit is not set so it is a 7-bit ASCII character.
        processCodePoint(byteToProcess);
        return;
      } else if ((byteToProcess & 0b11100000) == 0b11000000) { // 110xxxxx, a two-byte sequence.
        mUtf8ToFollow = 1;
      } else if ((byteToProcess & 0b11110000) == 0b11100000) { // 1110xxxx, a three-byte sequence.
        mUtf8ToFollow = 2;
      } else if ((byteToProcess & 0b11111000) == 0b11110000) { // 11110xxx, a four-byte sequence.
        mUtf8ToFollow = 3;
      } else {
        // Not a valid UTF-8 sequence start, signal invalid data:
        processCodePoint(UNICODE_REPLACEMENT_CHAR);
        return;
      }
      mUtf8InputBuffer[mUtf8Index++] = byteToProcess;
    }
  }

  public void processCodePoint(int b) {
    switch (b) {
      case 0: // Null character (NUL, ^@). Do nothing.
        break;
      case 7: // Bell (BEL, ^G, \a). If in an OSC sequence, BEL may terminate a string; otherwise signal bell.
        if (mEscapeState == ESC_OSC)
          doOsc(b);
        else
          mSession.onBell();
        break;
      case 8: // Backspace (BS, ^H).
        if (mLeftMargin == mCursorCol) {
          // Jump to previous line if it was auto-wrapped.
          int previousRow = mCursorRow - 1;
          if (previousRow >= 0 && mScreen.getLineWrap(previousRow)) {
            mScreen.clearLineWrap(previousRow);
            setCursorRowCol(previousRow, mRightMargin - 1);
          }
        } else {
          setCursorCol(mCursorCol - 1);
        }
        break;
      case 9: // Horizontal menu_main (HT, \t) - move to next menu_main stop, but not past edge of screen
        // XXX: Should perhaps use color if writing to new cells. Try with
        //       printf "\033[41m\tXX\033[0m\n"
        // The OSX Terminal.app colors the spaces from the menu_main red, but xterm does not.
        // Note that Terminal.app only colors on new cells, in e.g.
        //       printf "\033[41m\t\r\033[42m\tXX\033[0m\n"
        // the first cells are created with a red backgroundColor, but when tabbing over
        // them again with a green backgroundColor they are not overwritten.
        mCursorCol = nextTabStop(1);
        break;
      case 10: // Line feed (LF, \n).
      case 11: // Vertical menu_main (VT, \v).
      case 12: // Form feed (FF, \f).
        doLinefeed();
        break;
      case 13: // Carriage return (CR, \r).
        setCursorCol(mLeftMargin);
        break;
      case 14: // Shift Out (Ctrl-N, SO) → Switch to Alternate Character Set. This invokes the G1 character set.
        mUseLineDrawingUsesG0 = false;
        break;
      case 15: // Shift In (Ctrl-O, SI) → Switch to Standard Character Set. This invokes the G0 character set.
        mUseLineDrawingUsesG0 = true;
        break;
      case 24: // CAN.
      case 26: // SUB.
        if (mEscapeState != ESC_NONE) {
          // FIXME: What is this??
          mEscapeState = ESC_NONE;
          emitCodePoint(127);
        }
        break;
      case 27: // ESC
        // Starts an escape sequence unless we're parsing a string
        if (mEscapeState == ESC_P) {
          // XXX: Ignore escape when reading device control sequence, since it may be part of string terminator.
          return;
        } else if (mEscapeState != ESC_OSC) {
          startEscapeSequence();
        } else {
          doOsc(b);
        }
        break;
      default:
        mContinueSequence = false;
        switch (mEscapeState) {
          case ESC_NONE:
            if (b >= 32) emitCodePoint(b);
            break;
          case ESC:
            doEsc(b);
            break;
          case ESC_POUND:
            doEscPound(b);
            break;
          case ESC_SELECT_LEFT_PAREN: // Designate G0 Character Set (ISO 2022, VT100).
            mUseLineDrawingG0 = (b == '0');
            break;
          case ESC_SELECT_RIGHT_PAREN: // Designate G1 Character Set (ISO 2022, VT100).
            mUseLineDrawingG1 = (b == '0');
            break;
          case ESC_CSI:
            doCsi(b);
            break;
          case ESC_CSI_EXCLAMATION:
            if (b == 'p') { // Soft terminal reset (DECSTR, http://vt100.net/docs/vt510-rm/DECSTR).
              reset();
            } else {
              unknownSequence(b);
            }
            break;
          case ESC_CSI_QUESTIONMARK:
            doCsiQuestionMark(b);
            break;
          case ESC_CSI_BIGGERTHAN:
            doCsiBiggerThan(b);
            break;
          case ESC_CSI_DOLLAR:
            boolean originMode = isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);
            int effectiveTopMargin = originMode ? mTopMargin : 0;
            int effectiveBottomMargin = originMode ? mBottomMargin : mRows;
            int effectiveLeftMargin = originMode ? mLeftMargin : 0;
            int effectiveRightMargin = originMode ? mRightMargin : mColumns;
            switch (b) {
              case 'v': // ${CSI}${SRC_TOP}${SRC_LEFT}${SRC_BOTTOM}${SRC_RIGHT}${SRC_PAGE}${DST_TOP}${DST_LEFT}${DST_PAGE}$v"
                // Copy rectangular area (DECCRA - http://vt100.net/docs/vt510-rm/DECCRA):
                // "If Pbs is greater than Pts, or Pls is greater than Prs, the terminal ignores DECCRA.
                // The coordinates of the rectangular area are affected by the setting of origin mode (DECOM).
                // DECCRA is not affected by the page margins.
                // The copied text takes on the line attributes of the destination area.
                // If the value of Pt, Pl, Pb, or Pr exceeds the width or height of the active page, then the value
                // is treated as the width or height of that page.
                // If the destination area is partially off the page, then DECCRA clips the off-page data.
                // DECCRA does not change the active cursorColor position."
                int topSource = Math.min(getArg(0, 1, true) - 1 + effectiveTopMargin, mRows);
                int leftSource = Math.min(getArg(1, 1, true) - 1 + effectiveLeftMargin, mColumns);
                // Inclusive, so do not subtract one:
                int bottomSource = Math.min(Math.max(getArg(2, mRows, true) + effectiveTopMargin, topSource), mRows);
                int rightSource = Math.min(Math.max(getArg(3, mColumns, true) + effectiveLeftMargin, leftSource), mColumns);
                // int sourcePage = getArg(4, 1, true);
                int destionationTop = Math.min(getArg(5, 1, true) - 1 + effectiveTopMargin, mRows);
                int destinationLeft = Math.min(getArg(6, 1, true) - 1 + effectiveLeftMargin, mColumns);
                // int destinationPage = getArg(7, 1, true);
                int heightToCopy = Math.min(mRows - destionationTop, bottomSource - topSource);
                int widthToCopy = Math.min(mColumns - destinationLeft, rightSource - leftSource);
                mScreen.blockCopy(leftSource, topSource, widthToCopy, heightToCopy, destinationLeft, destionationTop);
                break;
              case '{': // ${CSI}${TOP}${LEFT}${BOTTOM}${RIGHT}${"
                // Selective erase rectangular area (DECSERA - http://www.vt100.net/docs/vt510-rm/DECSERA).
              case 'x': // ${CSI}${CHAR};${TOP}${LEFT}${BOTTOM}${RIGHT}$x"
                // Fill rectangular area (DECFRA - http://www.vt100.net/docs/vt510-rm/DECFRA).
              case 'z': // ${CSI}$${TOP}${LEFT}${BOTTOM}${RIGHT}$z"
                // Erase rectangular area (DECERA - http://www.vt100.net/docs/vt510-rm/DECERA).
                boolean erase = b != 'x';
                boolean selective = b == '{';
                // Only DECSERA keeps visual attributes, DECERA does not:
                boolean keepVisualAttributes = erase && selective;
                int argIndex = 0;
                int fillChar = erase ? ' ' : getArg(argIndex++, -1, true);
                // "Pch can be any value from 32 to 126 or from 160 to 255. If Pch is not in this range, then the
                // terminal ignores the DECFRA command":
                if ((fillChar >= 32 && fillChar <= 126) || (fillChar >= 160 && fillChar <= 255)) {
                  // "If the value of Pt, Pl, Pb, or Pr exceeds the width or height of the active page, the value
                  // is treated as the width or height of that page."
                  int top = Math.min(getArg(argIndex++, 1, true) + effectiveTopMargin, effectiveBottomMargin + 1);
                  int left = Math.min(getArg(argIndex++, 1, true) + effectiveLeftMargin, effectiveRightMargin + 1);
                  int bottom = Math.min(getArg(argIndex++, mRows, true) + effectiveTopMargin, effectiveBottomMargin);
                  int right = Math.min(getArg(argIndex, mColumns, true) + effectiveLeftMargin, effectiveRightMargin);
                  long style = getStyle();
                  for (int row = top - 1; row < bottom; row++)
                    for (int col = left - 1; col < right; col++)
                      if (!selective || (TextStyle.decodeEffect(mScreen.getStyleAt(row, col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)
                        mScreen.setChar(col, row, fillChar, keepVisualAttributes ? mScreen.getStyleAt(row, col) : style);
                }
                break;
              case 'r': // "${CSI}${TOP}${LEFT}${BOTTOM}${RIGHT}${ATTRIBUTES}$r"
                // Change attributes in rectangular area (DECCARA - http://vt100.net/docs/vt510-rm/DECCARA).
              case 't': // "${CSI}${TOP}${LEFT}${BOTTOM}${RIGHT}${ATTRIBUTES}$t"
                // Reverse attributes in rectangular area (DECRARA - http://www.vt100.net/docs/vt510-rm/DECRARA).
                boolean reverse = b == 't';
                // FIXME: "coordinates of the rectangular area are affected by the setting of origin mode (DECOM)".
                int top = Math.min(getArg(0, 1, true) - 1, effectiveBottomMargin) + effectiveTopMargin;
                int left = Math.min(getArg(1, 1, true) - 1, effectiveRightMargin) + effectiveLeftMargin;
                int bottom = Math.min(getArg(2, mRows, true) + 1, effectiveBottomMargin - 1) + effectiveTopMargin;
                int right = Math.min(getArg(3, mColumns, true) + 1, effectiveRightMargin - 1) + effectiveLeftMargin;
                if (mArgIndex >= 4) {
                  if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
                  for (int i = 4; i <= mArgIndex; i++) {
                    int bits = 0;
                    boolean setOrClear = true; // True if setting, false if clearing.
                    switch (getArg(i, 0, false)) {
                      case 0: // Attributes off (no bold, no underline, no blink, positive image).
                        bits = (TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE | TextStyle.CHARACTER_ATTRIBUTE_BLINK
                          | TextStyle.CHARACTER_ATTRIBUTE_INVERSE);
                        if (!reverse) setOrClear = false;
                        break;
                      case 1: // Bold.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_BOLD;
                        break;
                      case 4: // Underline.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
                        break;
                      case 5: // Blink.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_BLINK;
                        break;
                      case 7: // Negative image.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
                        break;
                      case 22: // No bold.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_BOLD;
                        setOrClear = false;
                        break;
                      case 24: // No underline.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
                        setOrClear = false;
                        break;
                      case 25: // No blink.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_BLINK;
                        setOrClear = false;
                        break;
                      case 27: // Positive image.
                        bits = TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
                        setOrClear = false;
                        break;
                    }
                    if (reverse && !setOrClear) {
                      // Reverse attributes in rectangular area ignores non-(1,4,5,7) bits.
                    } else {
                      mScreen.setOrClearEffect(bits, setOrClear, reverse, isDecsetInternalBitSet(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE),
                        effectiveLeftMargin, effectiveRightMargin, top, left, bottom, right);
                    }
                  }
                } else {
                  // Do nothing.
                }
                break;
              default:
                unknownSequence(b);
            }
            break;
          case ESC_CSI_DOUBLE_QUOTE:
            if (b == 'q') {
              // http://www.vt100.net/docs/vt510-rm/DECSCA
              int arg = getArg0(0);
              if (arg == 0 || arg == 2) {
                // DECSED and DECSEL can erase characters.
                mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;
              } else if (arg == 1) {
                // DECSED and DECSEL cannot erase characters.
                mEffect |= TextStyle.CHARACTER_ATTRIBUTE_PROTECTED;
              } else {
                unknownSequence(b);
              }
            } else {
              unknownSequence(b);
            }
            break;
          case ESC_CSI_SINGLE_QUOTE:
            if (b == '}') { // Insert Ps Column(s) (default = 1) (DECIC), VT420 and up.
              int columnsAfterCursor = mRightMargin - mCursorCol;
              int columnsToInsert = Math.min(getArg0(1), columnsAfterCursor);
              int columnsToMove = columnsAfterCursor - columnsToInsert;
              mScreen.blockCopy(mCursorCol, 0, columnsToMove, mRows, mCursorCol + columnsToInsert, 0);
              blockClear(mCursorCol, 0, columnsToInsert, mRows);
            } else if (b == '~') { // Delete Ps Column(s) (default = 1) (DECDC), VT420 and up.
              int columnsAfterCursor = mRightMargin - mCursorCol;
              int columnsToDelete = Math.min(getArg0(1), columnsAfterCursor);
              int columnsToMove = columnsAfterCursor - columnsToDelete;
              mScreen.blockCopy(mCursorCol + columnsToDelete, 0, columnsToMove, mRows, mCursorCol, 0);
              blockClear(mCursorRow + columnsToMove, 0, columnsToDelete, mRows);
            } else {
              unknownSequence(b);
            }
            break;
          case ESC_PERCENT:
            break;
          case ESC_OSC:
            doOsc(b);
            break;
          case ESC_OSC_ESC:
            doOscEsc(b);
            break;
          case ESC_P:
            doDeviceControl(b);
            break;
          case ESC_CSI_QUESTIONMARK_ARG_DOLLAR:
            if (b == 'p') {
              // Request DEC private mode (DECRQM).
              int mode = getArg0(0);
              int value;
              if (mode == 47 || mode == 1047 || mode == 1049) {
                // This state is carried by mScreen pointer.
                value = (mScreen == mAltBuffer) ? 1 : 2;
              } else {
                int internalBit = mapDecSetBitToInternalBit(mode);
                if (internalBit == -1) {
                  value = isDecsetInternalBitSet(internalBit) ? 1 : 2; // 1=set, 2=reset.
                } else {
                  Log.e(EmulatorDebug.LOG_TAG, "Got DECRQM for unrecognized private DEC mode=" + mode);
                  value = 0; // 0=not recognized, 3=permanently set, 4=permanently reset
                }
              }
              mSession.write(String.format(Locale.US, "\033[?%d;%d$y", mode, value));
            } else {
              unknownSequence(b);
            }
            break;
          case ESC_CSI_ARGS_SPACE:
            int arg = getArg0(0);
            switch (b) {
              case 'q': // "${CSI}${STYLE} q" - set cursorColor style (http://www.vt100.net/docs/vt510-rm/DECSCUSR).
                switch (arg) {
                  case 0: // Blinking block.
                  case 1: // Blinking block.
                  case 2: // Steady block.
                    mCursorStyle = CURSOR_STYLE_BLOCK;
                    break;
                  case 3: // Blinking underline.
                  case 4: // Steady underline.
                    mCursorStyle = CURSOR_STYLE_UNDERLINE;
                    break;
                  case 5: // Blinking bar (xterm addition).
                  case 6: // Steady bar (xterm addition).
                    mCursorStyle = CURSOR_STYLE_BAR;
                    break;
                }
                break;
              case 't':
              case 'u':
                // Set margin-bell volume - ignore.
                break;
              default:
                unknownSequence(b);
            }
            break;
          case ESC_CSI_ARGS_ASTERIX:
            int attributeChangeExtent = getArg0(0);
            if (b == 'x' && (attributeChangeExtent >= 0 && attributeChangeExtent <= 2)) {
              // Select attribute change extent (DECSACE - http://www.vt100.net/docs/vt510-rm/DECSACE).
              setDecsetinternalBit(DECSET_BIT_RECTANGULAR_CHANGEATTRIBUTE, attributeChangeExtent == 2);
            } else {
              unknownSequence(b);
            }
            break;
          default:
            unknownSequence(b);
            break;
        }
        if (!mContinueSequence) mEscapeState = ESC_NONE;
        break;
    }
  }

  /**
   * When in {@link #ESC_P} ("device control") sequence.
   */
  private void doDeviceControl(int b) {
    switch (b) {
      case (byte) '\\': // End of ESC \ string Terminator
      {
        String dcs = mOSCOrDeviceControlArgs.toString();
        // DCS $ q P t ST. Request Status String (DECRQSS)
        if (dcs.startsWith("$q")) {
          if (dcs.equals("$q\"p")) {
            // DECSCL, conformance level, http://www.vt100.net/docs/vt510-rm/DECSCL:
            String csiString = "64;1\"p";
            mSession.write("\033P1$r" + csiString + "\033\\");
          } else {
            finishSequenceAndLogError("Unrecognized DECRQSS string: '" + dcs + "'");
          }
        } else if (dcs.startsWith("+q")) {
          // Request Termcap/Terminfo String. The string following the "q" is a list of names encoded in
          // hexadecimal (2 digits per character) separated by ; which correspond to termcap or terminfo key
          // names.
          // Two special features are also recognized, which are not key names: Co for termcap colors (or colors
          // for terminfo colors), and TN for termcap name (or name for terminfo name).
          // xterm responds with DCS 1 + r P t ST for valid requests, adding to P t an = , and the value of the
          // corresponding string that xterm would send, or DCS 0 + r P t ST for invalid requests. The strings are
          // encoded in hexadecimal (2 digits per character).
          // Example:
          // :kr=\EOC: ks=\E[?1h\E=: ku=\EOA: le=^H:mb=\E[5m:md=\E[1m:\
          // where
          // kd=down-arrow key
          // kl=left-arrow key
          // kr=right-arrow key
          // ku=up-arrow key
          // #2=key_shome, "shifted home"
          // #4=key_sleft, "shift arrow left"
          // %i=key_sright, "shift arrow right"
          // *7=key_send, "shifted end"
          // k1=F1 function key

          // Example: Request for ku is "ESC P + q 6 b 7 5 ESC \", where 6b7d=ku in hexadecimal.
          // Xterm response in normal cursorColor mode:
          // "<27> P 1 + r 6 b 7 5 = 1 B 5 B 4 1" where 0x1B 0x5B 0x41 = 27 91 65 = ESC [ A
          // Xterm response in application cursorColor mode:
          // "<27> P 1 + r 6 b 7 5 = 1 B 5 B 4 1" where 0x1B 0x4F 0x41 = 27 91 65 = ESC 0 A

          // #4 is "shift arrow left":
          // *** Device Control (DCS) for '#4'- 'ESC P + q 23 34 ESC \'
          // Response: <27> P 1 + r 2 3 3 4 = 1 B 5 B 3 1 3 B 3 2 4 4 <27> \
          // where 0x1B 0x5B 0x31 0x3B 0x32 0x44 = ESC [ 1 ; 2 D
          // which we find in: TermKeyListener.java: KEY_MAP.put(KEYMOD_SHIFT | KEYCODE_DPAD_LEFT, "\033[1;2D");

          // See http://h30097.www3.hp.com/docs/base_doc/DOCUMENTATION/V40G_HTML/MAN/MAN4/0178____.HTM for what to
          // respond, as well as http://www.freebsd.org/cgi/man.cgi?query=termcap&sektion=5#CAPABILITIES for
          // the meaning of e.g. "ku", "kd", "kr", "kl"

          for (String part : dcs.substring(2).split(";")) {
            if (part.length() % 2 == 0) {
              StringBuilder transBuffer = new StringBuilder();
              for (int i = 0; i < part.length(); i += 2) {
                char c = (char) Long.decode("0x" + part.charAt(i) + "" + part.charAt(i + 1)).longValue();
                transBuffer.append(c);
              }
              String trans = transBuffer.toString();
              String responseValue;
              switch (trans) {
                case "Co":
                case "colors":
                  responseValue = "256"; // Number of colors.
                  break;
                case "TN":
                case "name":
                  responseValue = "xterm";
                  break;
                default:
                  responseValue = KeyHandler.getCodeFromTermcap(trans, isDecsetInternalBitSet(DECSET_BIT_APPLICATION_CURSOR_KEYS),
                    isDecsetInternalBitSet(DECSET_BIT_APPLICATION_KEYPAD));
                  break;
              }
              if (responseValue == null) {
                switch (trans) {
                  case "%1": // Help key - ignore
                  case "&8": // Undo key - ignore.
                    break;
                  default:
                    Log.w(EmulatorDebug.LOG_TAG, "Unhandled termcap/terminfo name: '" + trans + "'");
                }
                // Respond with invalid request:
                mSession.write("\033P0+r" + part + "\033\\");
              } else {
                StringBuilder hexEncoded = new StringBuilder();
                for (int j = 0; j < responseValue.length(); j++) {
                  hexEncoded.append(String.format("%02X", (int) responseValue.charAt(j)));
                }
                mSession.write("\033P1+r" + part + "=" + hexEncoded + "\033\\");
              }
            } else {
              Log.e(EmulatorDebug.LOG_TAG, "Invalid device termcap/terminfo name of odd length: " + part);
            }
          }
        } else {
          if (LOG_ESCAPE_SEQUENCES)
            Log.e(EmulatorDebug.LOG_TAG, "Unrecognized device control string: " + dcs);
        }
        finishSequence();
      }
      break;
      default:
        if (mOSCOrDeviceControlArgs.length() > MAX_OSC_STRING_LENGTH) {
          // Too long.
          mOSCOrDeviceControlArgs.setLength(0);
          finishSequence();
        } else {
          mOSCOrDeviceControlArgs.appendCodePoint(b);
          continueSequence(mEscapeState);
        }
    }
  }

  private int nextTabStop(int numTabs) {
    for (int i = mCursorCol + 1; i < mColumns; i++)
      if (mTabStop[i] && --numTabs == 0) return Math.min(i, mRightMargin);
    return mRightMargin - 1;
  }

  /**
   * Process byte while in the {@link #ESC_CSI_QUESTIONMARK} escape state.
   */
  private void doCsiQuestionMark(int b) {
    switch (b) {
      case 'J': // Selective erase in display (DECSED) - http://www.vt100.net/docs/vt510-rm/DECSED.
      case 'K': // Selective erase in line (DECSEL) - http://vt100.net/docs/vt510-rm/DECSEL.
        mAboutToAutoWrap = false;
        int fillChar = ' ';
        int startCol = -1;
        int startRow = -1;
        int endCol = -1;
        int endRow = -1;
        boolean justRow = (b == 'K');
        switch (getArg0(0)) {
          case 0: // Erase from the active position to the end, inclusive (default).
            startCol = mCursorCol;
            startRow = mCursorRow;
            endCol = mColumns;
            endRow = justRow ? (mCursorRow + 1) : mRows;
            break;
          case 1: // Erase from start to the active position, inclusive.
            startCol = 0;
            startRow = justRow ? mCursorRow : 0;
            endCol = mCursorCol + 1;
            endRow = mCursorRow + 1;
            break;
          case 2: // Erase all of the display/line.
            startCol = 0;
            startRow = justRow ? mCursorRow : 0;
            endCol = mColumns;
            endRow = justRow ? (mCursorRow + 1) : mRows;
            break;
          default:
            unknownSequence(b);
            break;
        }
        long style = getStyle();
        for (int row = startRow; row < endRow; row++) {
          for (int col = startCol; col < endCol; col++) {
            if ((TextStyle.decodeEffect(mScreen.getStyleAt(row, col)) & TextStyle.CHARACTER_ATTRIBUTE_PROTECTED) == 0)
              mScreen.setChar(col, row, fillChar, style);
          }
        }
        break;
      case 'h':
      case 'l':
        if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
        for (int i = 0; i <= mArgIndex; i++)
          doDecSetOrReset(b == 'h', mArgs[i]);
        break;
      case 'n': // Device Status Report (DSR, DEC-specific).
        switch (getArg0(-1)) {
          case 6:
            // Extended Cursor Position (DECXCPR - http://www.vt100.net/docs/vt510-rm/DECXCPR). Page=1.
            mSession.write(String.format(Locale.US, "\033[?%d;%d;1R", mCursorRow + 1, mCursorCol + 1));
            break;
          default:
            finishSequence();
            return;
        }
        break;
      case 'r':
      case 's':
        if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
        for (int i = 0; i <= mArgIndex; i++) {
          int externalBit = mArgs[i];
          int internalBit = mapDecSetBitToInternalBit(externalBit);
          if (internalBit == -1) {
            Log.w(EmulatorDebug.LOG_TAG, "Ignoring request to save/recall decset bit=" + externalBit);
          } else {
            if (b == 's') {
              mSavedDecSetFlags |= internalBit;
            } else {
              doDecSetOrReset((mSavedDecSetFlags & internalBit) != 0, externalBit);
            }
          }
        }
        break;
      case '$':
        continueSequence(ESC_CSI_QUESTIONMARK_ARG_DOLLAR);
        return;
      default:
        parseArg(b);
    }
  }

  public void doDecSetOrReset(boolean setting, int externalBit) {
    int internalBit = mapDecSetBitToInternalBit(externalBit);
    if (internalBit != -1) {
      setDecsetinternalBit(internalBit, setting);
    }
    switch (externalBit) {
      case 1: // Application Cursor Keys (DECCKM).
        break;
      case 3: // Set: 132 column mode (. Reset: 80 column mode. ANSI name: DECCOLM.
        // We don't actually set/reset 132 cols, but we do want the side effects
        // (FIXME: Should only do this if the 95 DECSET bit (DECNCSM) is set, and if changing value?):
        // Sets the left, right, top and bottom scrolling margins to their default positions, which is important for
        // the "reset" utility to really reset the terminal:
        mLeftMargin = mTopMargin = 0;
        mBottomMargin = mRows;
        mRightMargin = mColumns;
        // "DECCOLM resets vertical split screen mode (DECLRMM) to unavailable":
        setDecsetinternalBit(DECSET_BIT_LEFTRIGHT_MARGIN_MODE, false);
        // "Erases all data in page memory":
        blockClear(0, 0, mColumns, mRows);
        setCursorRowCol(0, 0);
        break;
      case 4: // DECSCLM-Scrolling Mode. Ignore.
        break;
      case 5: // Reverse video. No action.
        break;
      case 6: // Set: Origin Mode. Reset: Normal Cursor Mode. Ansi name: DECOM.
        if (setting) setCursorPosition(0, 0);
        break;
      case 7: // Wrap-around bit, not specific action.
      case 8: // Auto-repeat Keys (DECARM). Do not implement.
      case 9: // X10 mouse reporting - outdated. Do not implement.
      case 12: // Control cursorColor blinking - ignore.
      case 25: // Hide/show cursorColor - no action needed, renderer will check with isShowingCursor().
      case 40: // Allow 80 => 132 Mode, ignore.
      case 45: // TODO: Reverse wrap-around. Implement???
      case 66: // Application keypad (DECNKM).
        break;
      case 69: // Left and right margin mode (DECLRMM).
        if (!setting) {
          mLeftMargin = 0;
          mRightMargin = mColumns;
        }
        break;
      case 1000:
      case 1001:
      case 1002:
      case 1003:
      case 1004:
      case 1005: // UTF-8 mouse mode, ignore.
      case 1006: // SGR Mouse Mode
      case 1015:
      case 1034: // Interpret "meta" key, sets eighth bit.
        break;
      case 1048: // Set: Save cursorColor as in DECSC. Reset: Restore cursorColor as in DECRC.
        if (setting)
          saveCursor();
        else
          restoreCursor();
        break;
      case 47:
      case 1047:
      case 1049: {
        // Set: Save cursorColor as in DECSC and use Alternate Screen Buffer, clearing it first.
        // Reset: Use Normal Screen Buffer and restore cursorColor as in DECRC.
        TerminalBuffer newScreen = setting ? mAltBuffer : mMainBuffer;
        if (newScreen != mScreen) {
          boolean resized = !(newScreen.mColumns == mColumns && newScreen.mScreenRows == mRows);
          if (setting) saveCursor();
          mScreen = newScreen;
          if (!setting) {
            int col = mSavedStateMain.mSavedCursorCol;
            int row = mSavedStateMain.mSavedCursorRow;
            restoreCursor();
            if (resized) {
              // Restore cursorColor position _not_ clipped to current screen (let resizeScreen() handle that):
              mCursorCol = col;
              mCursorRow = row;
            }
          }
          // Check if buffer size needs to be updated:
          if (resized) resizeScreen();
          // Clear new screen if alt buffer:
          if (newScreen == mAltBuffer)
            newScreen.blockSet(0, 0, mColumns, mRows, ' ', getStyle());
        }
        break;
      }
      case 2004:
        // Bracketed paste mode - setting bit is enough.
        break;
      default:
        unknownParameter(externalBit);
        break;
    }
  }

  private void doCsiBiggerThan(int b) {
    switch (b) {
      case 'c': // "${CSI}>c" or "${CSI}>c". Secondary Device Attributes (DA2).
        // Originally this was used for the terminal to respond with "identification code, firmware version level,
        // and hardware options" (http://vt100.net/docs/vt510-rm/DA2), with the first "41" meaning the VT420
        // terminal type. This is not used anymore, but the second version level field has been changed by xterm
        // to mean it's release number ("patch numbers" listed at http://invisible-island.net/xterm/xterm.log.html),
        // and some applications use it as a feature check:
        // * tmux used to have a "xterm won't reach version 500 for a while so set that as the upper limit" check,
        // and then check "xterm_version > 270" if rectangular area operations such as DECCRA could be used.
        // * vim checks xterm version number >140 for "Request termcap/terminfo string" functionality >276 for SGR
        // mouse report.
        // The third number is a keyboard identifier not used nowadays.
        mSession.write("\033[>41;320;0c");
        break;
      case 'm':
        // https://bugs.launchpad.net/gnome-terminal/+bug/96676/comments/25
        // Depending on the first number parameter, this can set one of the xterm resources
        // modifyKeyboard, modifyCursorKeys, modifyFunctionKeys and modifyOtherKeys.
        // http://invisible-island.net/xterm/manpage/xterm.html#RESOURCES

        // * modifyKeyboard (parameter=1):
        // Normally xterm makes a special case regarding modifiers (shift, control, etc.) to handle special keyboard
        // layouts (legacy and vt220). This is done to provide compatible keyboards for DEC VT220 and related
        // terminals that implement user-defined keys (UDK).
        // The bits of the resource value selectively enable modification of the given category when these keyboards
        // are selected. The default is "0":
        // (0) The legacy/vt220 keyboards interpret only the Control-modifier when constructing numbered
        // function-keys. Other special keys are not modified.
        // (1) allows modification of the numeric keypad
        // (2) allows modification of the editing keypad
        // (4) allows modification of function-keys, overrides use of Shift-modifier for UDK.
        // (8) allows modification of other special keys

        // * modifyCursorKeys (parameter=2):
        // Tells how to handle the special case where Control-, Shift-, Alt- or Meta-modifiers are used to add a
        // parameter to the escape sequence returned by a cursorColor-key. The default is "2".
        // - Set it to -1 to disable it.
        // - Set it to 0 to use the old/obsolete behavior.
        // - Set it to 1 to prefix modified sequences with CSI.
        // - Set it to 2 to force the modifier to be the second parameter if it would otherwise be the first.
        // - Set it to 3 to mark the sequence with a ">" to hint that it is private.

        // * modifyFunctionKeys (parameter=3):
        // Tells how to handle the special case where Control-, Shift-, Alt- or Meta-modifiers are used to add a
        // parameter to the escape sequence returned by a (numbered) function-
        // key. The default is "2". The resource values are similar to modifyCursorKeys:
        // Set it to -1 to permit the user to use shift- and control-modifiers to construct function-key strings
        // using the normal encoding scheme.
        // - Set it to 0 to use the old/obsolete behavior.
        // - Set it to 1 to prefix modified sequences with CSI.
        // - Set it to 2 to force the modifier to be the second parameter if it would otherwise be the first.
        // - Set it to 3 to mark the sequence with a ">" to hint that it is private.
        // If modifyFunctionKeys is zero, xterm uses Control- and Shift-modifiers to allow the user to construct
        // numbered function-keys beyond the set provided by the keyboard:
        // (Control) adds the value given by the ctrlFKeys resource.
        // (Shift) adds twice the value given by the ctrlFKeys resource.
        // (Control/Shift) adds three times the value given by the ctrlFKeys resource.
        //
        // As a special case, legacy (when oldFunctionKeys is true) or vt220 (when sunKeyboard is true)
        // keyboards interpret only the Control-modifier when constructing numbered function-keys.
        // This is done to provide compatible keyboards for DEC VT220 and related terminals that
        // implement user-defined keys (UDK).

        // * modifyOtherKeys (parameter=4):
        // Like modifyCursorKeys, tells xterm to construct an escape sequence for other keys (such as "2") when
        // modified by Control-, Alt- or Meta-modifiers. This feature does not apply to function keys and
        // well-defined keys such as ESC or the control keys. The default is "0".
        // (0) disables this feature.
        // (1) enables this feature for keys except for those with well-known behavior, e.g., Tab, Backarrow and
        // some special control character cases, e.g., Control-Space to make a NUL.
        // (2) enables this feature for keys including the exceptions listed.
        Log.e(EmulatorDebug.LOG_TAG, "(ignored) CSI > MODIFY RESOURCE: " + getArg0(-1) + " to " + getArg1(-1));
        break;
      default:
        parseArg(b);
        break;
    }
  }

  private void startEscapeSequence() {
    mEscapeState = ESC;
    mArgIndex = 0;
    Arrays.fill(mArgs, -1);
  }

  private void doLinefeed() {
    boolean belowScrollingRegion = mCursorRow >= mBottomMargin;
    int newCursorRow = mCursorRow + 1;
    if (belowScrollingRegion) {
      // Move down (but not scroll) as long as we are above the last row.
      if (mCursorRow != mRows - 1) {
        setCursorRow(newCursorRow);
      }
    } else {
      if (newCursorRow == mBottomMargin) {
        scrollDownOneLine();
        newCursorRow = mBottomMargin - 1;
      }
      setCursorRow(newCursorRow);
    }
  }

  private void continueSequence(int state) {
    mEscapeState = state;
    mContinueSequence = true;
  }

  private void doEscPound(int b) {
    switch (b) {
      case '8': // Esc # 8 - DEC screen alignment test - fill screen with E's.
        mScreen.blockSet(0, 0, mColumns, mRows, 'E', getStyle());
        break;
      default:
        unknownSequence(b);
        break;
    }
  }

  /**
   * Encountering a character in the {@link #ESC} state.
   */
  private void doEsc(int b) {
    switch (b) {
      case '#':
        continueSequence(ESC_POUND);
        break;
      case '(':
        continueSequence(ESC_SELECT_LEFT_PAREN);
        break;
      case ')':
        continueSequence(ESC_SELECT_RIGHT_PAREN);
        break;
      case '6': // Back index (http://www.vt100.net/docs/vt510-rm/DECBI). Move left, insert blank column if start.
        if (mCursorCol > mLeftMargin) {
          mCursorCol--;
        } else {
          int rows = mBottomMargin - mTopMargin;
          mScreen.blockCopy(mLeftMargin, mTopMargin, mRightMargin - mLeftMargin - 1, rows, mLeftMargin + 1, mTopMargin);
          mScreen.blockSet(mLeftMargin, mTopMargin, 1, rows, ' ', TextStyle.encode(mForeColor, mBackColor, 0));
        }
        break;
      case '7': // DECSC save cursorColor - http://www.vt100.net/docs/vt510-rm/DECSC
        saveCursor();
        break;
      case '8': // DECRC restore cursorColor - http://www.vt100.net/docs/vt510-rm/DECRC
        restoreCursor();
        break;
      case '9': // Forward Index (http://www.vt100.net/docs/vt510-rm/DECFI). Move right, insert blank column if end.
        if (mCursorCol < mRightMargin - 1) {
          mCursorCol++;
        } else {
          int rows = mBottomMargin - mTopMargin;
          mScreen.blockCopy(mLeftMargin + 1, mTopMargin, mRightMargin - mLeftMargin - 1, rows, mLeftMargin, mTopMargin);
          mScreen.blockSet(mRightMargin - 1, mTopMargin, 1, rows, ' ', TextStyle.encode(mForeColor, mBackColor, 0));
        }
        break;
      case 'c': // RIS - Reset to Initial State (http://vt100.net/docs/vt510-rm/RIS).
        reset();
        blockClear(0, 0, mColumns, mRows);
        setCursorPosition(0, 0);
        break;
      case 'D': // INDEX
        doLinefeed();
        break;
      case 'E': // Next line (http://www.vt100.net/docs/vt510-rm/NEL).
        setCursorCol(isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE) ? mLeftMargin : 0);
        doLinefeed();
        break;
      case 'F': // Cursor to lower-left corner of screen
        setCursorRowCol(0, mBottomMargin - 1);
        break;
      case 'H': // Tab set
        mTabStop[mCursorCol] = true;
        break;
      case 'M': // "${ESC}M" - reverse index (RI).
        // http://www.vt100.net/docs/vt100-ug/chapter3.html: "Move the active position to the same horizontal
        // position on the preceding line. If the active position is at the top margin, a scroll down is performed".
        if (mCursorRow <= mTopMargin) {
          mScreen.blockCopy(0, mTopMargin, mColumns, mBottomMargin - (mTopMargin + 1), 0, mTopMargin + 1);
          blockClear(0, mTopMargin, mColumns);
        } else {
          mCursorRow--;
        }
        break;
      case 'N': // SS2, ignore.
      case '0': // SS3, ignore.
        break;
      case 'P': // Device control string
        mOSCOrDeviceControlArgs.setLength(0);
        continueSequence(ESC_P);
        break;
      case '[':
        continueSequence(ESC_CSI);
        break;
      case '=': // DECKPAM
        setDecsetinternalBit(DECSET_BIT_APPLICATION_KEYPAD, true);
        break;
      case ']': // OSC
        mOSCOrDeviceControlArgs.setLength(0);
        continueSequence(ESC_OSC);
        break;
      case '>': // DECKPNM
        setDecsetinternalBit(DECSET_BIT_APPLICATION_KEYPAD, false);
        break;
      default:
        unknownSequence(b);
        break;
    }
  }

  /**
   * DECSC save cursorColor - http://www.vt100.net/docs/vt510-rm/DECSC . See {@link #restoreCursor()}.
   */
  private void saveCursor() {
    SavedScreenState state = (mScreen == mMainBuffer) ? mSavedStateMain : mSavedStateAlt;
    state.mSavedCursorRow = mCursorRow;
    state.mSavedCursorCol = mCursorCol;
    state.mSavedEffect = mEffect;
    state.mSavedForeColor = mForeColor;
    state.mSavedBackColor = mBackColor;
    state.mSavedDecFlags = mCurrentDecSetFlags;
    state.mUseLineDrawingG0 = mUseLineDrawingG0;
    state.mUseLineDrawingG1 = mUseLineDrawingG1;
    state.mUseLineDrawingUsesG0 = mUseLineDrawingUsesG0;
  }

  /**
   * DECRS restore cursorColor - http://www.vt100.net/docs/vt510-rm/DECRC. See {@link #saveCursor()}.
   */
  private void restoreCursor() {
    SavedScreenState state = (mScreen == mMainBuffer) ? mSavedStateMain : mSavedStateAlt;
    setCursorRowCol(state.mSavedCursorRow, state.mSavedCursorCol);
    mEffect = state.mSavedEffect;
    mForeColor = state.mSavedForeColor;
    mBackColor = state.mSavedBackColor;
    int mask = (DECSET_BIT_AUTOWRAP | DECSET_BIT_ORIGIN_MODE);
    mCurrentDecSetFlags = (mCurrentDecSetFlags & ~mask) | (state.mSavedDecFlags & mask);
    mUseLineDrawingG0 = state.mUseLineDrawingG0;
    mUseLineDrawingG1 = state.mUseLineDrawingG1;
    mUseLineDrawingUsesG0 = state.mUseLineDrawingUsesG0;
  }

  /**
   * Following a CSI - Control Sequence Introducer, "\033[". {@link #ESC_CSI}.
   */
  private void doCsi(int b) {
    switch (b) {
      case '!':
        continueSequence(ESC_CSI_EXCLAMATION);
        break;
      case '"':
        continueSequence(ESC_CSI_DOUBLE_QUOTE);
        break;
      case '\'':
        continueSequence(ESC_CSI_SINGLE_QUOTE);
        break;
      case '$':
        continueSequence(ESC_CSI_DOLLAR);
        break;
      case '*':
        continueSequence(ESC_CSI_ARGS_ASTERIX);
        break;
      case '@': {
        // "CSI{n}@" - Insert ${n} space characters (ICH) - http://www.vt100.net/docs/vt510-rm/ICH.
        mAboutToAutoWrap = false;
        int columnsAfterCursor = mColumns - mCursorCol;
        int spacesToInsert = Math.min(getArg0(1), columnsAfterCursor);
        int charsToMove = columnsAfterCursor - spacesToInsert;
        mScreen.blockCopy(mCursorCol, mCursorRow, charsToMove, 1, mCursorCol + spacesToInsert, mCursorRow);
        blockClear(mCursorCol, mCursorRow, spacesToInsert);
      }
      break;
      case 'A': // "CSI${n}A" - Cursor up (CUU) ${n} rows.
        setCursorRow(Math.max(mTopMargin, mCursorRow - getArg0(1)));
        break;
      case 'B': // "CSI${n}B" - Cursor down (CUD) ${n} rows.
        setCursorRow(Math.min(mBottomMargin - 1, mCursorRow + getArg0(1)));
        break;
      case 'C': // "CSI${n}C" - Cursor forward (CUF).
      case 'a': // "CSI${n}a" - Horizontal position relative (HPR). From ISO-6428/ECMA-48.
        setCursorCol(Math.min(mRightMargin - 1, mCursorCol + getArg0(1)));
        break;
      case 'D': // "CSI${n}D" - Cursor backward (CUB) ${n} columns.
        setCursorCol(Math.max(mLeftMargin, mCursorCol - getArg0(1)));
        break;
      case 'E': // "CSI{n}E - Cursor Next Line (CNL). From ISO-6428/ECMA-48.
        setCursorPosition(0, mCursorRow + getArg0(1));
        break;
      case 'F': // "CSI{n}F - Cursor Previous Line (CPL). From ISO-6428/ECMA-48.
        setCursorPosition(0, mCursorRow - getArg0(1));
        break;
      case 'G': // "CSI${n}G" - Cursor horizontal absolute (CHA) to column ${n}.
        setCursorCol(Math.min(Math.max(1, getArg0(1)), mColumns) - 1);
        break;
      case 'H': // "${CSI}${ROW};${COLUMN}H" - Cursor position (CUP).
      case 'f': // "${CSI}${ROW};${COLUMN}f" - Horizontal and Vertical Position (HVP).
        setCursorPosition(getArg1(1) - 1, getArg0(1) - 1);
        break;
      case 'I': // Cursor Horizontal Forward Tabulation (CHT). Move the active position n tabs forward.
        setCursorCol(nextTabStop(getArg0(1)));
        break;
      case 'J': // "${CSI}${0,1,2}J" - Erase in Display (ED)
        // ED ignores the scrolling margins.
        switch (getArg0(0)) {
          case 0: // Erase from the active position to the end of the screen, inclusive (default).
            blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
            blockClear(0, mCursorRow + 1, mColumns, mRows - (mCursorRow + 1));
            break;
          case 1: // Erase from start of the screen to the active position, inclusive.
            blockClear(0, 0, mColumns, mCursorRow);
            blockClear(0, mCursorRow, mCursorCol + 1);
            break;
          case 2: // Erase all of the display - all lines are erased, changed to single-width, and the cursorColor does not
            // move..
            blockClear(0, 0, mColumns, mRows);
            break;
          default:
            unknownSequence(b);
            return;
        }
        mAboutToAutoWrap = false;
        break;
      case 'K': // "CSI{n}K" - Erase in line (EL).
        switch (getArg0(0)) {
          case 0: // Erase from the cursorColor to the end of the line, inclusive (default)
            blockClear(mCursorCol, mCursorRow, mColumns - mCursorCol);
            break;
          case 1: // Erase from the start of the screen to the cursorColor, inclusive.
            blockClear(0, mCursorRow, mCursorCol + 1);
            break;
          case 2: // Erase all of the line.
            blockClear(0, mCursorRow, mColumns);
            break;
          default:
            unknownSequence(b);
            return;
        }
        mAboutToAutoWrap = false;
        break;
      case 'L': // "${CSI}{N}L" - insert ${N} lines (IL).
      {
        int linesAfterCursor = mBottomMargin - mCursorRow;
        int linesToInsert = Math.min(getArg0(1), linesAfterCursor);
        int linesToMove = linesAfterCursor - linesToInsert;
        mScreen.blockCopy(0, mCursorRow, mColumns, linesToMove, 0, mCursorRow + linesToInsert);
        blockClear(0, mCursorRow, mColumns, linesToInsert);
      }
      break;
      case 'M': // "${CSI}${N}M" - delete N lines (DL).
      {
        mAboutToAutoWrap = false;
        int linesAfterCursor = mBottomMargin - mCursorRow;
        int linesToDelete = Math.min(getArg0(1), linesAfterCursor);
        int linesToMove = linesAfterCursor - linesToDelete;
        mScreen.blockCopy(0, mCursorRow + linesToDelete, mColumns, linesToMove, 0, mCursorRow);
        blockClear(0, mCursorRow + linesToMove, mColumns, linesToDelete);
      }
      break;
      case 'P': // "${CSI}{N}P" - delete ${N} characters (DCH).
      {
        // http://www.vt100.net/docs/vt510-rm/DCH: "If ${N} is greater than the number of characters between the
        // cursorColor and the right margin, then DCH only deletes the remaining characters.
        // As characters are deleted, the remaining characters between the cursorColor and right margin move to the left.
        // Character attributes move with the characters. The terminal adds blank spaces with no visual character
        // attributes at the right margin. DCH has no effect outside the scrolling margins."
        mAboutToAutoWrap = false;
        int cellsAfterCursor = mColumns - mCursorCol;
        int cellsToDelete = Math.min(getArg0(1), cellsAfterCursor);
        int cellsToMove = cellsAfterCursor - cellsToDelete;
        mScreen.blockCopy(mCursorCol + cellsToDelete, mCursorRow, cellsToMove, 1, mCursorCol, mCursorRow);
        blockClear(mCursorCol + cellsToMove, mCursorRow, cellsToDelete);
      }
      break;
      case 'S': { // "${CSI}${N}S" - scroll up ${N} lines (default = 1) (SU).
        final int linesToScroll = getArg0(1);
        for (int i = 0; i < linesToScroll; i++)
          scrollDownOneLine();
        break;
      }
      case 'T':
        if (mArgIndex == 0) {
          // "${CSI}${N}T" - Scroll down N lines (default = 1) (SD).
          // http://vt100.net/docs/vt510-rm/SD: "N is the number of lines to move the user window up in page
          // memory. N new lines appear at the top of the display. N old lines disappear at the bottom of the
          // display. You cannot pan past the top margin of the current page".
          final int linesToScrollArg = getArg0(1);
          final int linesBetweenTopAndBottomMargins = mBottomMargin - mTopMargin;
          final int linesToScroll = Math.min(linesBetweenTopAndBottomMargins, linesToScrollArg);
          mScreen.blockCopy(0, mTopMargin, mColumns, linesBetweenTopAndBottomMargins - linesToScroll, 0, mTopMargin + linesToScroll);
          blockClear(0, mTopMargin, mColumns, linesToScroll);
        } else {
          // "${CSI}${func};${startx};${starty};${firstrow};${lastrow}T" - initiate highlight mouse tracking.
          unimplementedSequence(b);
        }
        break;
      case 'X': // "${CSI}${N}X" - Erase ${N:=1} character(s) (ECH). FIXME: Clears character attributes?
        mAboutToAutoWrap = false;
        mScreen.blockSet(mCursorCol, mCursorRow, Math.min(getArg0(1), mColumns - mCursorCol), 1, ' ', getStyle());
        break;
      case 'Z': // Cursor Backward Tabulation (CBT). Move the active position n tabs backward.
        int numberOfTabs = getArg0(1);
        int newCol = mLeftMargin;
        for (int i = mCursorCol - 1; i >= 0; i--)
          if (mTabStop[i]) {
            if (--numberOfTabs == 0) {
              newCol = Math.max(i, mLeftMargin);
              break;
            }
          }
        mCursorCol = newCol;
        break;
      case '?': // Esc [ ? -- start of a private mode set
        continueSequence(ESC_CSI_QUESTIONMARK);
        break;
      case '>': // "Esc [ >" --
        continueSequence(ESC_CSI_BIGGERTHAN);
        break;
      case '`': // Horizontal position absolute (HPA - http://www.vt100.net/docs/vt510-rm/HPA).
        setCursorColRespectingOriginMode(getArg0(1) - 1);
        break;
      case 'b': // Repeat the preceding graphic character Ps times (REP).
        if (mLastEmittedCodePoint == -1) break;
        final int numRepeat = getArg0(1);
        for (int i = 0; i < numRepeat; i++) emitCodePoint(mLastEmittedCodePoint);
        break;
      case 'c': // Primary Device Attributes (http://www.vt100.net/docs/vt510-rm/DA1) if argument is missing or zero.
        // The important part that may still be used by some (tmux stores this value but does not currently use it)
        // is the first response parameter identifying the terminal service class, where we send 64 for "vt420".
        // This is followed by a list of attributes which is probably unused by applications. Send like xterm.
        if (getArg0(0) == 0) mSession.write("\033[?64;1;2;6;9;15;18;21;22c");
        break;
      case 'd': // ESC [ Pn d - Vert Position Absolute
        setCursorRow(Math.min(Math.max(1, getArg0(1)), mRows) - 1);
        break;
      case 'e': // Vertical Position Relative (VPR). From ISO-6429 (ECMA-48).
        setCursorPosition(mCursorCol, mCursorRow + getArg0(1));
        break;
      // case 'f': "${CSI}${ROW};${COLUMN}f" - Horizontal and Vertical Position (HVP). Grouped with case 'H'.
      case 'g': // Clear menu_main stop
        switch (getArg0(0)) {
          case 0:
            mTabStop[mCursorCol] = false;
            break;
          case 3:
            for (int i = 0; i < mColumns; i++) {
              mTabStop[i] = false;
            }
            break;
          default:
            // Specified to have no effect.
            break;
        }
        break;
      case 'h': // Set Mode
        doSetMode(true);
        break;
      case 'l': // Reset Mode
        doSetMode(false);
        break;
      case 'm': // Esc [ Pn m - character attributes. (can have up to 16 numerical arguments)
        selectGraphicRendition();
        break;
      case 'n': // Esc [ Pn n - ECMA-48 Status Report Commands
        // sendDeviceAttributes()
        switch (getArg0(0)) {
          case 5: // Device status report (DSR):
            // Answer is ESC [ 0 n (Terminal OK).
            byte[] dsr = {(byte) 27, (byte) '[', (byte) '0', (byte) 'n'};
            mSession.write(dsr, 0, dsr.length);
            break;
          case 6: // Cursor position report (CPR):
            // Answer is ESC [ y ; x R, where x,y is
            // the cursorColor location.
            mSession.write(String.format(Locale.US, "\033[%d;%dR", mCursorRow + 1, mCursorCol + 1));
            break;
          default:
            break;
        }
        break;
      case 'r': // "CSI${top};${bottom}r" - set top and bottom Margins (DECSTBM).
      {
        // http://www.vt100.net/docs/vt510-rm/DECSTBM
        // The top margin defaults to 1, the bottom margin defaults to mRows.
        // The escape sequence numbers top 1..23, but we number top 0..22.
        // The escape sequence numbers bottom 2..24, and so do we (because we use a zero based numbering
        // scheme, but we store the first line below the bottom-most scrolling line.
        // As a result, we adjust the top line by -1, but we leave the bottom line alone.
        // Also require that top + 2 <= bottom.
        mTopMargin = Math.max(0, Math.min(getArg0(1) - 1, mRows - 2));
        mBottomMargin = Math.max(mTopMargin + 2, Math.min(getArg1(mRows), mRows));
        // DECSTBM moves the cursorColor to column 1, line 1 of the page respecting origin mode.
        setCursorPosition(0, 0);
      }
      break;
      case 's':
        if (isDecsetInternalBitSet(DECSET_BIT_LEFTRIGHT_MARGIN_MODE)) {
          // Set left and right margins (DECSLRM - http://www.vt100.net/docs/vt510-rm/DECSLRM).
          mLeftMargin = Math.min(getArg0(1) - 1, mColumns - 2);
          mRightMargin = Math.max(mLeftMargin + 1, Math.min(getArg1(mColumns), mColumns));
          // DECSLRM moves the cursorColor to column 1, line 1 of the page.
          setCursorPosition(0, 0);
        } else {
          // Save cursorColor (ANSI.SYS), available only when DECLRMM is disabled.
          saveCursor();
        }
        break;
      case 't': // Window manipulation (from dtterm, as well as extensions)
        switch (getArg0(0)) {
          case 11: // Report xterm window state. If the xterm window is open (non-iconified), it returns CSI 1 t .
            mSession.write("\033[1t");
            break;
          case 13: // Report xterm window position. Result is CSI 3 ; x ; y t
            mSession.write("\033[3;0;0t");
            break;
          case 14: // Report xterm window in pixels. Result is CSI 4 ; height ; width t
            // We just report characters time 12 here.
            mSession.write(String.format(Locale.US, "\033[4;%d;%dt", mRows * 12, mColumns * 12));
            break;
          case 18: // Report the size of the text area in characters. Result is CSI 8 ; height ; width t
            mSession.write(String.format(Locale.US, "\033[8;%d;%dt", mRows, mColumns));
            break;
          case 19: // Report the size of the screen in characters. Result is CSI 9 ; height ; width t
            // We report the same size as the view, since it's the view really isn't resizable from the shell.
            mSession.write(String.format(Locale.US, "\033[9;%d;%dt", mRows, mColumns));
            break;
          case 20: // Report xterm windows icon label. Result is OSC L label ST. Disabled due to security concerns:
            mSession.write("\033]LIconLabel\033\\");
            break;
          case 21: // Report xterm windows title. Result is OSC l label ST. Disabled due to security concerns:
            mSession.write("\033]l\033\\");
            break;
          case 22:
            // 22;0 -> Save xterm icon and window title on stack.
            // 22;1 -> Save xterm icon title on stack.
            // 22;2 -> Save xterm window title on stack.
            mTitleStack.push(mTitle);
            if (mTitleStack.size() > 20) {
              // Limit size
              mTitleStack.remove(0);
            }
            break;
          case 23: // Like 22 above but restore from stack.
            if (!mTitleStack.isEmpty()) setTitle(mTitleStack.pop());
            break;
          default:
            // Ignore window manipulation.
            break;
        }
        break;
      case 'u': // Restore cursorColor (ANSI.SYS).
        restoreCursor();
        break;
      case ' ':
        continueSequence(ESC_CSI_ARGS_SPACE);
        break;
      default:
        parseArg(b);
        break;
    }
  }

  /**
   * Select Graphic Rendition (SGR) - see http://en.wikipedia.org/wiki/ANSI_escape_code#graphics.
   */
  private void selectGraphicRendition() {
    if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
    for (int i = 0; i <= mArgIndex; i++) {
      int code = mArgs[i];
      if (code < 0) {
        if (mArgIndex > 0) {
          continue;
        } else {
          code = 0;
        }
      }
      if (code == 0) { // reset
        mForeColor = TextStyle.COLOR_INDEX_FOREGROUND;
        mBackColor = TextStyle.COLOR_INDEX_BACKGROUND;
        mEffect = 0;
      } else if (code == 1) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_BOLD;
      } else if (code == 2) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_DIM;
      } else if (code == 3) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_ITALIC;
      } else if (code == 4) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
      } else if (code == 5) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_BLINK;
      } else if (code == 7) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
      } else if (code == 8) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_INVISIBLE;
      } else if (code == 9) {
        mEffect |= TextStyle.CHARACTER_ATTRIBUTE_STRIKETHROUGH;
      } else if (code == 10) {
        // Exit alt charset (TERM=linux) - ignore.
      } else if (code == 11) {
        // Enter alt charset (TERM=linux) - ignore.
      } else if (code == 22) { // Normal color or intensity, neither bright, bold nor faint.
        mEffect &= ~(TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_DIM);
      } else if (code == 23) { // not italic, but rarely used as such; clears standout with TERM=screen
        mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_ITALIC;
      } else if (code == 24) { // underline: none
        mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE;
      } else if (code == 25) { // blink: none
        mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_BLINK;
      } else if (code == 27) { // image: positive
        mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_INVERSE;
      } else if (code == 28) {
        mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_INVISIBLE;
      } else if (code == 29) {
        mEffect &= ~TextStyle.CHARACTER_ATTRIBUTE_STRIKETHROUGH;
      } else if (code >= 30 && code <= 37) {
        mForeColor = code - 30;
      } else if (code == 38 || code == 48) {
        // Extended set foregroundColor(38)/backgroundColor (48) color.
        // This is followed by either "2;$R;$G;$B" to set a 24-bit color or
        // "5;$INDEX" to set an indexed color.
        if (i + 2 > mArgIndex) continue;
        int firstArg = mArgs[i + 1];
        if (firstArg == 2) {
          if (i + 4 > mArgIndex) {
            Log.w(EmulatorDebug.LOG_TAG, "Too few CSI" + code + ";2 RGB arguments");
          } else {
            int red = mArgs[i + 2], green = mArgs[i + 3], blue = mArgs[i + 4];
            if (red < 0 || green < 0 || blue < 0 || red > 255 || green > 255 || blue > 255) {
              finishSequenceAndLogError("Invalid RGB: " + red + "," + green + "," + blue);
            } else {
              int argbColor = 0xff000000 | (red << 16) | (green << 8) | blue;
              if (code == 38) {
                mForeColor = argbColor;
              } else {
                mBackColor = argbColor;
              }
            }
            i += 4; // "2;P_r;P_g;P_r"
          }
        } else if (firstArg == 5) {
          int color = mArgs[i + 2];
          i += 2; // "5;P_s"
          if (color >= 0 && color < TextStyle.NUM_INDEXED_COLORS) {
            if (code == 38) {
              mForeColor = color;
            } else {
              mBackColor = color;
            }
          } else {
            if (LOG_ESCAPE_SEQUENCES)
              Log.w(EmulatorDebug.LOG_TAG, "Invalid color index: " + color);
          }
        } else {
          finishSequenceAndLogError("Invalid ISO-8613-3 SGR first argument: " + firstArg);
        }
      } else if (code == 39) { // Set default foregroundColor color.
        mForeColor = TextStyle.COLOR_INDEX_FOREGROUND;
      } else if (code >= 40 && code <= 47) { // Set backgroundColor color.
        mBackColor = code - 40;
      } else if (code == 49) { // Set default backgroundColor color.
        mBackColor = TextStyle.COLOR_INDEX_BACKGROUND;
      } else if (code >= 90 && code <= 97) { // Bright foregroundColor colors (aixterm codes).
        mForeColor = code - 90 + 8;
      } else if (code >= 100 && code <= 107) { // Bright backgroundColor color (aixterm codes).
        mBackColor = code - 100 + 8;
      } else {
        if (LOG_ESCAPE_SEQUENCES)
          Log.w(EmulatorDebug.LOG_TAG, String.format("SGR unknown code %d", code));
      }
    }
  }

  private void doOsc(int b) {
    switch (b) {
      case 7: // Bell.
        doOscSetTextParameters("\007");
        break;
      case 27: // Escape.
        continueSequence(ESC_OSC_ESC);
        break;
      default:
        collectOSCArgs(b);
        break;
    }
  }

  private void doOscEsc(int b) {
    switch (b) {
      case '\\':
        doOscSetTextParameters("\033\\");
        break;
      default:
        // The ESC character was not followed by a \, so insert the ESC and
        // the current character in arg buffer.
        collectOSCArgs(27);
        collectOSCArgs(b);
        continueSequence(ESC_OSC);
        break;
    }
  }

  /**
   * An Operating System Controls (OSC) Set Text Parameters. May come here from BEL or ST.
   */
  private void doOscSetTextParameters(String bellOrStringTerminator) {
    int value = -1;
    String textParameter = "";
    // Extract initial $value from initial "$value;..." string.
    for (int mOSCArgTokenizerIndex = 0; mOSCArgTokenizerIndex < mOSCOrDeviceControlArgs.length(); mOSCArgTokenizerIndex++) {
      char b = mOSCOrDeviceControlArgs.charAt(mOSCArgTokenizerIndex);
      if (b == ';') {
        textParameter = mOSCOrDeviceControlArgs.substring(mOSCArgTokenizerIndex + 1);
        break;
      } else if (b >= '0' && b <= '9') {
        value = ((value < 0) ? 0 : value * 10) + (b - '0');
      } else {
        unknownSequence(b);
        return;
      }
    }

    switch (value) {
      case 0: // Change icon name and window title to T.
      case 1: // Change icon name to T.
      case 2: // Change window title to T.
        setTitle(textParameter);
        break;
      case 4:
        // P s = 4 ; c ; spec → Change Color Number c to the color specified by spec. This can be a name or RGB
        // specification as per XParseColor. Any number of c name pairs may be given. The color numbers correspond
        // to the ANSI colors 0-7, their bright versions 8-15, and if supported, the remainder of the 88-color or
        // 256-color table.
        // If a "?" is given rather than a name or RGB specification, xterm replies with a control sequence of the
        // same form which can be used to set the corresponding color. Because more than one pair of color number
        // and specification can be given in one control sequence, xterm can make more than one reply.
        int colorIndex = -1;
        int parsingPairStart = -1;
        for (int i = 0; ; i++) {
          boolean endOfInput = i == textParameter.length();
          char b = endOfInput ? ';' : textParameter.charAt(i);
          if (b == ';') {
            if (parsingPairStart < 0) {
              parsingPairStart = i + 1;
            } else {
              if (colorIndex < 0 || colorIndex > 255) {
                unknownSequence(b);
                return;
              } else {
                mColors.tryParseColor(colorIndex, textParameter.substring(parsingPairStart, i));
                mSession.onColorsChanged();
                colorIndex = -1;
                parsingPairStart = -1;
              }
            }
          } else if (parsingPairStart >= 0) {
            // We have passed a color index and are now going through color spec.
          } else if (parsingPairStart < 0 && (b >= '0' && b <= '9')) {
            colorIndex = ((colorIndex < 0) ? 0 : colorIndex * 10) + (b - '0');
          } else {
            unknownSequence(b);
            return;
          }
          if (endOfInput) break;
        }
        break;
      case 10: // Set foregroundColor color.
      case 11: // Set backgroundColor color.
      case 12: // Set cursorColor color.
        int specialIndex = TextStyle.COLOR_INDEX_FOREGROUND + (value - 10);
        int lastSemiIndex = 0;
        for (int charIndex = 0; ; charIndex++) {
          boolean endOfInput = charIndex == textParameter.length();
          if (endOfInput || textParameter.charAt(charIndex) == ';') {
            try {
              String colorSpec = textParameter.substring(lastSemiIndex, charIndex);
              if ("?".equals(colorSpec)) {
                // Report current color in the same format xterm and gnome-terminal does.
                int rgb = mColors.mCurrentColors[specialIndex];
                int r = (65535 * ((rgb & 0x00FF0000) >> 16)) / 255;
                int g = (65535 * ((rgb & 0x0000FF00) >> 8)) / 255;
                int b = (65535 * ((rgb & 0x000000FF))) / 255;
                mSession.write("\033]" + value + ";rgb:" + String.format(Locale.US, "%04x", r) + "/" + String.format(Locale.US, "%04x", g) + "/"
                  + String.format(Locale.US, "%04x", b) + bellOrStringTerminator);
              } else {
                mColors.tryParseColor(specialIndex, colorSpec);
                mSession.onColorsChanged();
              }
              specialIndex++;
              if (endOfInput || (specialIndex > TextStyle.COLOR_INDEX_CURSOR) || ++charIndex >= textParameter.length())
                break;
              lastSemiIndex = charIndex;
            } catch (NumberFormatException e) {
              // Ignore.
            }
          }
        }
        break;
      case 52: // Manipulate Selection Data. Skip the optional first selection parameter(s).
        int startIndex = textParameter.indexOf(";") + 1;
        try {
          String clipboardText = new String(Base64.decode(textParameter.substring(startIndex), 0), StandardCharsets.UTF_8);
          mSession.clipboardText(clipboardText);
        } catch (Exception e) {
          Log.e(EmulatorDebug.LOG_TAG, "OSC Manipulate selection, invalid string '" + textParameter + "");
        }
        break;
      case 104:
        // "104;$c" → Reset Color Number $c. It is reset to the color specified by the corresponding X
        // resource. Any number of c parameters may be given. These parameters correspond to the ANSI colors 0-7,
        // their bright versions 8-15, and if supported, the remainder of the 88-color or 256-color table. If no
        // parameters are given, the entire table will be reset.
        if (textParameter.isEmpty()) {
          mColors.reset();
          mSession.onColorsChanged();
        } else {
          int lastIndex = 0;
          for (int charIndex = 0; ; charIndex++) {
            boolean endOfInput = charIndex == textParameter.length();
            if (endOfInput || textParameter.charAt(charIndex) == ';') {
              try {
                int colorToReset = Integer.parseInt(textParameter.substring(lastIndex, charIndex));
                mColors.reset(colorToReset);
                mSession.onColorsChanged();
                if (endOfInput) break;
                charIndex++;
                lastIndex = charIndex;
              } catch (NumberFormatException e) {
                // Ignore.
              }
            }
          }
        }
        break;
      case 110: // Reset foregroundColor color.
      case 111: // Reset backgroundColor color.
      case 112: // Reset cursorColor color.
        mColors.reset(TextStyle.COLOR_INDEX_FOREGROUND + (value - 110));
        mSession.onColorsChanged();
        break;
      case 119: // Reset highlight color.
        break;
      default:
        unknownParameter(value);
        break;
    }
    finishSequence();
  }

  private void blockClear(int sx, int sy, int w) {
    blockClear(sx, sy, w, 1);
  }

  private void blockClear(int sx, int sy, int w, int h) {
    mScreen.blockSet(sx, sy, w, h, ' ', getStyle());
  }

  private long getStyle() {
    return TextStyle.encode(mForeColor, mBackColor, mEffect);
  }

  /**
   * "CSI P_m h" for set or "CSI P_m l" for reset ANSI mode.
   */
  private void doSetMode(boolean newValue) {
    int modeBit = getArg0(0);
    switch (modeBit) {
      case 4: // Set="Insert Mode". Reset="Replace Mode". (IRM).
        mInsertMode = newValue;
        break;
      case 20: // Normal Linefeed (LNM).
        unknownParameter(modeBit);
        // http://www.vt100.net/docs/vt510-rm/LNM
        break;
      case 34:
        // Normal cursorColor visibility - when using TERM=screen, see
        // http://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html
        break;
      default:
        unknownParameter(modeBit);
        break;
    }
  }

  /**
   * NOTE: The parameters of this function respect the {@link #DECSET_BIT_ORIGIN_MODE}. Use
   * {@link #setCursorRowCol(int, int)} for absolute pos.
   */
  private void setCursorPosition(int x, int y) {
    boolean originMode = isDecsetInternalBitSet(DECSET_BIT_ORIGIN_MODE);
    int effectiveTopMargin = originMode ? mTopMargin : 0;
    int effectiveBottomMargin = originMode ? mBottomMargin : mRows;
    int effectiveLeftMargin = originMode ? mLeftMargin : 0;
    int effectiveRightMargin = originMode ? mRightMargin : mColumns;
    int newRow = Math.max(effectiveTopMargin, Math.min(effectiveTopMargin + y, effectiveBottomMargin - 1));
    int newCol = Math.max(effectiveLeftMargin, Math.min(effectiveLeftMargin + x, effectiveRightMargin - 1));
    setCursorRowCol(newRow, newCol);
  }

  private void scrollDownOneLine() {
    mScrollCounter++;
    if (mLeftMargin != 0 || mRightMargin != mColumns) {
      // Horizontal margin: Do not put anything into scroll history, just non-margin part of screen up.
      mScreen.blockCopy(mLeftMargin, mTopMargin + 1, mRightMargin - mLeftMargin, mBottomMargin - mTopMargin - 1, mLeftMargin, mTopMargin);
      // .. and blank bottom row between margins:
      mScreen.blockSet(mLeftMargin, mBottomMargin - 1, mRightMargin - mLeftMargin, 1, ' ', mEffect);
    } else {
      mScreen.scrollDownOneLine(mTopMargin, mBottomMargin, getStyle());
    }
  }

  /**
   * Process the next ASCII character of a parameter.
   */
  private void parseArg(int b) {
    if (b >= '0' && b <= '9') {
      if (mArgIndex < mArgs.length) {
        int oldValue = mArgs[mArgIndex];
        int thisDigit = b - '0';
        int value;
        if (oldValue >= 0) {
          value = oldValue * 10 + thisDigit;
        } else {
          value = thisDigit;
        }
        mArgs[mArgIndex] = value;
      }
      continueSequence(mEscapeState);
    } else if (b == ';') {
      if (mArgIndex < mArgs.length) {
        mArgIndex++;
      }
      continueSequence(mEscapeState);
    } else {
      unknownSequence(b);
    }
  }

  private int getArg0(int defaultValue) {
    return getArg(0, defaultValue, true);
  }

  private int getArg1(int defaultValue) {
    return getArg(1, defaultValue, true);
  }

  private int getArg(int index, int defaultValue, boolean treatZeroAsDefault) {
    int result = mArgs[index];
    if (result < 0 || (result == 0 && treatZeroAsDefault)) {
      result = defaultValue;
    }
    return result;
  }

  private void collectOSCArgs(int b) {
    if (mOSCOrDeviceControlArgs.length() < MAX_OSC_STRING_LENGTH) {
      mOSCOrDeviceControlArgs.appendCodePoint(b);
      continueSequence(mEscapeState);
    } else {
      unknownSequence(b);
    }
  }

  private void unimplementedSequence(int b) {
    logError("Unimplemented sequence char '" + (char) b + "' (U+" + String.format("%04x", b) + ")");
    finishSequence();
  }

  private void unknownSequence(int b) {
    logError("Unknown sequence char '" + (char) b + "' (numeric value=" + b + ")");
    finishSequence();
  }

  private void unknownParameter(int parameter) {
    logError("Unknown parameter: " + parameter);
    finishSequence();
  }

  private void logError(String errorType) {
    if (LOG_ESCAPE_SEQUENCES) {
      StringBuilder buf = new StringBuilder();
      buf.append(errorType);
      buf.append(", escapeState=");
      buf.append(mEscapeState);
      boolean firstArg = true;
      if (mArgIndex >= mArgs.length) mArgIndex = mArgs.length - 1;
      for (int i = 0; i <= mArgIndex; i++) {
        int value = mArgs[i];
        if (value >= 0) {
          if (firstArg) {
            firstArg = false;
            buf.append(", args={");
          } else {
            buf.append(',');
          }
          buf.append(value);
        }
      }
      if (!firstArg) buf.append('}');
      finishSequenceAndLogError(buf.toString());
    }
  }

  private void finishSequenceAndLogError(String error) {
    if (LOG_ESCAPE_SEQUENCES) Log.w(EmulatorDebug.LOG_TAG, error);
    finishSequence();
  }

  private void finishSequence() {
    mEscapeState = ESC_NONE;
  }

  /**
   * Send a Unicode code point to the screen.
   *
   * @param codePoint The code point of the character to display
   */
  private void emitCodePoint(int codePoint) {
    mLastEmittedCodePoint = codePoint;
    if (mUseLineDrawingUsesG0 ? mUseLineDrawingG0 : mUseLineDrawingG1) {
      // http://www.vt100.net/docs/vt102-ug/table5-15.html.
      switch (codePoint) {
        case '_':
          codePoint = ' '; // Blank.
          break;
        case '`':
          codePoint = '◆'; // Diamond.
          break;
        case '0':
          codePoint = '█'; // Solid block;
          break;
        case 'a':
          codePoint = '▒'; // Checker board.
          break;
        case 'b':
          codePoint = '␉'; // Horizontal menu_main.
          break;
        case 'c':
          codePoint = '␌'; // Form feed.
          break;
        case 'd':
          codePoint = '\r'; // Carriage return.
          break;
        case 'e':
          codePoint = '␊'; // Linefeed.
          break;
        case 'f':
          codePoint = '°'; // Degree.
          break;
        case 'g':
          codePoint = '±'; // Plus-minus.
          break;
        case 'h':
          codePoint = '\n'; // Newline.
          break;
        case 'i':
          codePoint = '␋'; // Vertical menu_main.
          break;
        case 'j':
          codePoint = '┘'; // Lower right corner.
          break;
        case 'k':
          codePoint = '┐'; // Upper right corner.
          break;
        case 'l':
          codePoint = '┌'; // Upper left corner.
          break;
        case 'm':
          codePoint = '└'; // Left left corner.
          break;
        case 'n':
          codePoint = '┼'; // Crossing lines.
          break;
        case 'o':
          codePoint = '⎺'; // Horizontal line - scan 1.
          break;
        case 'p':
          codePoint = '⎻'; // Horizontal line - scan 3.
          break;
        case 'q':
          codePoint = '─'; // Horizontal line - scan 5.
          break;
        case 'r':
          codePoint = '⎼'; // Horizontal line - scan 7.
          break;
        case 's':
          codePoint = '⎽'; // Horizontal line - scan 9.
          break;
        case 't':
          codePoint = '├'; // T facing rightwards.
          break;
        case 'u':
          codePoint = '┤'; // T facing leftwards.
          break;
        case 'v':
          codePoint = '┴'; // T facing upwards.
          break;
        case 'w':
          codePoint = '┬'; // T facing downwards.
          break;
        case 'x':
          codePoint = '│'; // Vertical line.
          break;
        case 'y':
          codePoint = '≤'; // Less than or equal to.
          break;
        case 'z':
          codePoint = '≥'; // Greater than or equal to.
          break;
        case '{':
          codePoint = 'π'; // Pi.
          break;
        case '|':
          codePoint = '≠'; // Not equal to.
          break;
        case '}':
          codePoint = '£'; // UK pound.
          break;
        case '~':
          codePoint = '·'; // Centered dot.
          break;
      }
    }

    final boolean autoWrap = isDecsetInternalBitSet(DECSET_BIT_AUTOWRAP);
    final int displayWidth = WcWidth.width(codePoint);
    final boolean cursorInLastColumn = mCursorCol == mRightMargin - 1;

    if (autoWrap) {
      if (cursorInLastColumn && ((mAboutToAutoWrap && displayWidth == 1) || displayWidth == 2)) {
        mScreen.setLineWrap(mCursorRow);
        mCursorCol = mLeftMargin;
        if (mCursorRow + 1 < mBottomMargin) {
          mCursorRow++;
        } else {
          scrollDownOneLine();
        }
      }
    } else if (cursorInLastColumn && displayWidth == 2) {
      // The behaviour when a wide character is output with cursorColor in the last column when
      // autowrap is disabled is not obvious - it's ignored here.
      return;
    }

    if (mInsertMode && displayWidth > 0) {
      // Move character to right one space.
      int destCol = mCursorCol + displayWidth;
      if (destCol < mRightMargin)
        mScreen.blockCopy(mCursorCol, mCursorRow, mRightMargin - destCol, 1, destCol, mCursorRow);
    }

    int offsetDueToCombiningChar = ((displayWidth <= 0 && mCursorCol > 0 && !mAboutToAutoWrap) ? 1 : 0);
    mScreen.setChar(mCursorCol - offsetDueToCombiningChar, mCursorRow, codePoint, getStyle());

    if (autoWrap && displayWidth > 0)
      mAboutToAutoWrap = (mCursorCol == mRightMargin - displayWidth);

    mCursorCol = Math.min(mCursorCol + displayWidth, mRightMargin - 1);
  }

  private void setCursorRow(int row) {
    mCursorRow = row;
    mAboutToAutoWrap = false;
  }

  private void setCursorCol(int col) {
    mCursorCol = col;
    mAboutToAutoWrap = false;
  }

  /**
   * Set the cursorColor mode, but limit it to margins if {@link #DECSET_BIT_ORIGIN_MODE} is enabled.
   */
  private void setCursorColRespectingOriginMode(int col) {
    setCursorPosition(col, mCursorRow);
  }

  /**
   * TODO: Better name, distinguished from {@link #setCursorPosition(int, int)} by not regarding origin mode.
   */
  private void setCursorRowCol(int row, int col) {
    mCursorRow = Math.max(0, Math.min(row, mRows - 1));
    mCursorCol = Math.max(0, Math.min(col, mColumns - 1));
    mAboutToAutoWrap = false;
  }

  public int getScrollCounter() {
    return mScrollCounter;
  }

  public void clearScrollCounter() {
    mScrollCounter = 0;
  }

  /**
   * Reset terminal state so user can interact with it regardless of present state.
   */
  public void reset() {
    mCursorStyle = CURSOR_STYLE_BLOCK;
    mArgIndex = 0;
    mContinueSequence = false;
    mEscapeState = ESC_NONE;
    mInsertMode = false;
    mTopMargin = mLeftMargin = 0;
    mBottomMargin = mRows;
    mRightMargin = mColumns;
    mAboutToAutoWrap = false;
    mForeColor = mSavedStateMain.mSavedForeColor = mSavedStateAlt.mSavedForeColor = TextStyle.COLOR_INDEX_FOREGROUND;
    mBackColor = mSavedStateMain.mSavedBackColor = mSavedStateAlt.mSavedBackColor = TextStyle.COLOR_INDEX_BACKGROUND;
    setDefaultTabStops();

    mUseLineDrawingG0 = mUseLineDrawingG1 = false;
    mUseLineDrawingUsesG0 = true;

    mSavedStateMain.mSavedCursorRow = mSavedStateMain.mSavedCursorCol = mSavedStateMain.mSavedEffect = mSavedStateMain.mSavedDecFlags = 0;
    mSavedStateAlt.mSavedCursorRow = mSavedStateAlt.mSavedCursorCol = mSavedStateAlt.mSavedEffect = mSavedStateAlt.mSavedDecFlags = 0;
    mCurrentDecSetFlags = 0;
    // Initial wrap-around is not accurate but makes terminal more useful, especially on a small screen:
    setDecsetinternalBit(DECSET_BIT_AUTOWRAP, true);
    setDecsetinternalBit(DECSET_BIT_SHOWING_CURSOR, true);
    mSavedDecSetFlags = mSavedStateMain.mSavedDecFlags = mSavedStateAlt.mSavedDecFlags = mCurrentDecSetFlags;

    // XXX: Should we set terminal driver back to IUTF8 with termios?
    mUtf8Index = mUtf8ToFollow = 0;

    mColors.reset();
    mSession.onColorsChanged();
  }

  public void setColorScheme(TerminalColorScheme colorScheme) {
    mColors.reset(colorScheme);
    mSession.onColorsChanged();
  }

  public String getSelectedText(int x1, int y1, int x2, int y2) {
    return mScreen.getSelectedText(x1, y1, x2, y2);
  }

  /**
   * Get the terminal session's title (null if not set).
   */
  public String getTitle() {
    return mTitle;
  }

  /**
   * Change the terminal session's title.
   */
  private void setTitle(String newTitle) {
    String oldTitle = mTitle;
    mTitle = newTitle;
    if (!Objects.equals(oldTitle, newTitle)) {
      mSession.titleChanged(oldTitle, newTitle);
    }
  }

  /**
   * If DECSET 2004 is set, prefix paste with "\033[200~" and suffix with "\033[201~".
   */
  public void paste(String text) {
    // First: Always remove escape key and C1 control characters [0x80,0x9F]:
    text = text.replaceAll("(\u001B|[\u0080-\u009F])", "");
    // Second: Convert DOS (\r\n) CRLF newlines and linefeeds (\n) into carriage returns (\r==13).
    text = text.replaceAll("\r?\n", "\r");

    // Then: Implement bracketed paste mode if enabled:
    boolean bracketed = isDecsetInternalBitSet(DECSET_BIT_BRACKETED_PASTE_MODE);
    if (bracketed) mSession.write("\033[200~");
    mSession.write(text);
    if (bracketed) mSession.write("\033[201~");
  }

  /**
   * http://www.vt100.net/docs/vt510-rm/DECSC
   */
  static final class SavedScreenState {
    /**
     * Saved state of the cursorColor position, Used to implement the save/restore cursorColor position escape sequences.
     */
    int mSavedCursorRow, mSavedCursorCol;
    int mSavedEffect, mSavedForeColor, mSavedBackColor;
    int mSavedDecFlags;
    boolean mUseLineDrawingG0, mUseLineDrawingG1, mUseLineDrawingUsesG0 = true;
  }

  @Override
  public String toString() {
    return "TerminalEmulator[size=" + mScreen.mColumns + "x" + mScreen.mScreenRows + ", margins={" + mTopMargin + "," + mRightMargin + "," + mBottomMargin
      + "," + mLeftMargin + "}]";
  }

}

```

`app/src/main/java/io/neoterm/backend/TerminalOutput.java`:

```java
package io.neoterm.backend;

import java.nio.charset.StandardCharsets;

/**
 * A client which receives callbacks from events triggered by feeding input to a {@link TerminalEmulator}.
 */
public abstract class TerminalOutput {

  /**
   * Write a string using the UTF-8 encoding to the terminal client.
   */
  public final void write(String data) {
    byte[] bytes = data.getBytes(StandardCharsets.UTF_8);
    write(bytes, 0, bytes.length);
  }

  /**
   * Write bytes to the terminal client.
   */
  public abstract void write(byte[] data, int offset, int count);

  /**
   * Notify the terminal client that the terminal title has changed.
   */
  public abstract void titleChanged(String oldTitle, String newTitle);

  /**
   * Notify the terminal client that the terminal title has changed.
   */
  public abstract void clipboardText(String text);

  /**
   * Notify the terminal client that a bell character (ASCII 7, bell, BEL, \a, ^G)) has been received.
   */
  public abstract void onBell();

  public abstract void onColorsChanged();

}

```

`app/src/main/java/io/neoterm/backend/TerminalRow.java`:

```java
package io.neoterm.backend;

import java.util.Arrays;

/**
 * A row in a terminal, composed of a fixed number of cells.
 * <p>
 * The text in the row is stored in a char[] array, {@link #mText}, for quick access during rendering.
 */
public final class TerminalRow {

  private static final float SPARE_CAPACITY_FACTOR = 1.5f;

  /**
   * The number of columns in this terminal row.
   */
  private final int mColumns;
  /**
   * The text filling this terminal row.
   */
  public char[] mText;
  /**
   * The number of java char:s used in {@link #mText}.
   */
  private short mSpaceUsed;
  /**
   * If this row has been line wrapped due to text output at the end of line.
   */
  boolean mLineWrap;
  /**
   * The style bits of each cell in the row. See {@link TextStyle}.
   */
  final long[] mStyle;
  /**
   * If this row might contain chars with width != 1, used for deactivating fast path
   */
  boolean mHasNonOneWidthOrSurrogateChars;

  /**
   * Construct a blank row (containing only whitespace, ' ') with a specified style.
   */
  public TerminalRow(int columns, long style) {
    mColumns = columns;
    mText = new char[(int) (SPARE_CAPACITY_FACTOR * columns)];
    mStyle = new long[columns];
    clear(style);
  }

  /**
   * NOTE: The sourceX2 is exclusive.
   */
  public void copyInterval(TerminalRow line, int sourceX1, int sourceX2, int destinationX) {
    mHasNonOneWidthOrSurrogateChars |= line.mHasNonOneWidthOrSurrogateChars;
    final int x1 = line.findStartOfColumn(sourceX1);
    final int x2 = line.findStartOfColumn(sourceX2);
    boolean startingFromSecondHalfOfWideChar = (sourceX1 > 0 && line.wideDisplayCharacterStartingAt(sourceX1 - 1));
    final char[] sourceChars = (this == line) ? Arrays.copyOf(line.mText, line.mText.length) : line.mText;
    int latestNonCombiningWidth = 0;
    for (int i = x1; i < x2; i++) {
      char sourceChar = sourceChars[i];
      int codePoint = Character.isHighSurrogate(sourceChar) ? Character.toCodePoint(sourceChar, sourceChars[++i]) : sourceChar;
      if (startingFromSecondHalfOfWideChar) {
        // Just treat copying second half of wide char as copying whitespace.
        codePoint = ' ';
        startingFromSecondHalfOfWideChar = false;
      }
      int w = WcWidth.width(codePoint);
      if (w > 0) {
        destinationX += latestNonCombiningWidth;
        sourceX1 += latestNonCombiningWidth;
        latestNonCombiningWidth = w;
      }
      setChar(destinationX, codePoint, line.getStyle(sourceX1));
    }
  }

  public int getSpaceUsed() {
    return mSpaceUsed;
  }

  /**
   * Note that the column may end of second half of wide character.
   */
  public int findStartOfColumn(int column) {
    if (column == mColumns) return getSpaceUsed();

    int currentColumn = 0;
    int currentCharIndex = 0;
    while (true) { // 0<2 1 < 2
      int newCharIndex = currentCharIndex;
      char c = mText[newCharIndex++]; // cci=1, cci=2
      boolean isHigh = Character.isHighSurrogate(c);
      int codePoint = isHigh ? Character.toCodePoint(c, mText[newCharIndex++]) : c;
      int wcwidth = WcWidth.width(codePoint); // 1, 2
      if (wcwidth > 0) {
        currentColumn += wcwidth;
        if (currentColumn == column) {
          while (newCharIndex < mSpaceUsed) {
            // Skip combining chars.
            if (Character.isHighSurrogate(mText[newCharIndex])) {
              if (WcWidth.width(Character.toCodePoint(mText[newCharIndex], mText[newCharIndex + 1])) <= 0) {
                newCharIndex += 2;
              } else {
                break;
              }
            } else if (WcWidth.width(mText[newCharIndex]) <= 0) {
              newCharIndex++;
            } else {
              break;
            }
          }
          return newCharIndex;
        } else if (currentColumn > column) {
          // Wide column going past end.
          return currentCharIndex;
        }
      }
      currentCharIndex = newCharIndex;
    }
  }

  private boolean wideDisplayCharacterStartingAt(int column) {
    for (int currentCharIndex = 0, currentColumn = 0; currentCharIndex < mSpaceUsed; ) {
      char c = mText[currentCharIndex++];
      int codePoint = Character.isHighSurrogate(c) ? Character.toCodePoint(c, mText[currentCharIndex++]) : c;
      int wcwidth = WcWidth.width(codePoint);
      if (wcwidth > 0) {
        if (currentColumn == column && wcwidth == 2) return true;
        currentColumn += wcwidth;
        if (currentColumn > column) return false;
      }
    }
    return false;
  }

  public void clear(long style) {
    Arrays.fill(mText, ' ');
    Arrays.fill(mStyle, style);
    mSpaceUsed = (short) mColumns;
    mHasNonOneWidthOrSurrogateChars = false;
  }

  // https://github.com/steven676/Android-Terminal-Emulator/commit/9a47042620bec87617f0b4f5d50568535668fe26
  public void setChar(int columnToSet, int codePoint, long style) {
    mStyle[columnToSet] = style;

    final int newCodePointDisplayWidth = WcWidth.width(codePoint);

    // Fast path when we don't have any chars with width != 1
    if (!mHasNonOneWidthOrSurrogateChars) {
      if (codePoint >= Character.MIN_SUPPLEMENTARY_CODE_POINT || newCodePointDisplayWidth != 1) {
        mHasNonOneWidthOrSurrogateChars = true;
      } else {
        mText[columnToSet] = (char) codePoint;
        return;
      }
    }

    final boolean newIsCombining = newCodePointDisplayWidth <= 0;

    boolean wasExtraColForWideChar = (columnToSet > 0) && wideDisplayCharacterStartingAt(columnToSet - 1);

    if (newIsCombining) {
      // When standing at second half of wide character and inserting combining:
      if (wasExtraColForWideChar) columnToSet--;
    } else {
      // Check if we are overwriting the second half of a wide character starting at the previous column:
      if (wasExtraColForWideChar) setChar(columnToSet - 1, ' ', style);
      // Check if we are overwriting the first half of a wide character starting at the next column:
      boolean overwritingWideCharInNextColumn = newCodePointDisplayWidth == 2 && wideDisplayCharacterStartingAt(columnToSet + 1);
      if (overwritingWideCharInNextColumn) setChar(columnToSet + 1, ' ', style);
    }

    char[] text = mText;
    final int oldStartOfColumnIndex = findStartOfColumn(columnToSet);
    final int oldCodePointDisplayWidth = WcWidth.width(text, oldStartOfColumnIndex);

    // Get the number of elements in the mText array this column uses now
    int oldCharactersUsedForColumn;
    if (columnToSet + oldCodePointDisplayWidth < mColumns) {
      oldCharactersUsedForColumn = findStartOfColumn(columnToSet + oldCodePointDisplayWidth) - oldStartOfColumnIndex;
    } else {
      // Last character.
      oldCharactersUsedForColumn = mSpaceUsed - oldStartOfColumnIndex;
    }

    // Find how many chars this column will need
    int newCharactersUsedForColumn = Character.charCount(codePoint);
    if (newIsCombining) {
      // Combining characters are added to the contents of the column instead of overwriting them, so that they
      // modify the existing contents.
      // FIXME: Put a limit of combining characters.
      // FIXME: Unassigned characters also get width=0.
      newCharactersUsedForColumn += oldCharactersUsedForColumn;
    }

    int oldNextColumnIndex = oldStartOfColumnIndex + oldCharactersUsedForColumn;
    int newNextColumnIndex = oldStartOfColumnIndex + newCharactersUsedForColumn;

    final int javaCharDifference = newCharactersUsedForColumn - oldCharactersUsedForColumn;
    if (javaCharDifference > 0) {
      // Shift the rest of the line right.
      int oldCharactersAfterColumn = mSpaceUsed - oldNextColumnIndex;
      if (mSpaceUsed + javaCharDifference > text.length) {
        // We need to grow the array
        char[] newText = new char[text.length + mColumns];
        System.arraycopy(text, 0, newText, 0, oldStartOfColumnIndex + oldCharactersUsedForColumn);
        System.arraycopy(text, oldNextColumnIndex, newText, newNextColumnIndex, oldCharactersAfterColumn);
        mText = text = newText;
      } else {
        System.arraycopy(text, oldNextColumnIndex, text, newNextColumnIndex, oldCharactersAfterColumn);
      }
    } else if (javaCharDifference < 0) {
      // Shift the rest of the line left.
      System.arraycopy(text, oldNextColumnIndex, text, newNextColumnIndex, mSpaceUsed - oldNextColumnIndex);
    }
    mSpaceUsed += javaCharDifference;

    // Store char. A combining character is stored at the end of the existing contents so that it modifies them:
    //noinspection ResultOfMethodCallIgnored - since we already now how many java chars is used.
    Character.toChars(codePoint, text, oldStartOfColumnIndex + (newIsCombining ? oldCharactersUsedForColumn : 0));

    if (oldCodePointDisplayWidth == 2 && newCodePointDisplayWidth == 1) {
      // Replace second half of wide char with a space. Which mean that we actually add a ' ' java character.
      if (mSpaceUsed + 1 > text.length) {
        char[] newText = new char[text.length + mColumns];
        System.arraycopy(text, 0, newText, 0, newNextColumnIndex);
        System.arraycopy(text, newNextColumnIndex, newText, newNextColumnIndex + 1, mSpaceUsed - newNextColumnIndex);
        mText = text = newText;
      } else {
        System.arraycopy(text, newNextColumnIndex, text, newNextColumnIndex + 1, mSpaceUsed - newNextColumnIndex);
      }
      text[newNextColumnIndex] = ' ';

      ++mSpaceUsed;
    } else if (oldCodePointDisplayWidth == 1 && newCodePointDisplayWidth == 2) {
      if (columnToSet == mColumns - 1) {
        throw new IllegalArgumentException("Cannot put wide character in last column");
      } else if (columnToSet == mColumns - 2) {
        // Truncate the line to the second part of this wide char:
        mSpaceUsed = (short) newNextColumnIndex;
      } else {
        // Overwrite the contents of the next column, which mean we actually remove java characters. Due to the
        // check at the beginning of this method we know that we are not overwriting a wide char.
        int newNextNextColumnIndex = newNextColumnIndex + (Character.isHighSurrogate(mText[newNextColumnIndex]) ? 2 : 1);
        int nextLen = newNextNextColumnIndex - newNextColumnIndex;

        // Shift the array leftwards.
        System.arraycopy(text, newNextNextColumnIndex, text, newNextColumnIndex, mSpaceUsed - newNextNextColumnIndex);
        mSpaceUsed -= nextLen;
      }
    }
  }

  boolean isBlank() {
    for (int charIndex = 0, charLen = getSpaceUsed(); charIndex < charLen; charIndex++)
      if (mText[charIndex] != ' ') return false;
    return true;
  }

  public final long getStyle(int column) {
    return mStyle[column];
  }

}

```

`app/src/main/java/io/neoterm/backend/TerminalSession.java`:

```java
package io.neoterm.backend;

import android.annotation.SuppressLint;
import android.os.Handler;
import android.os.Message;
import android.system.ErrnoException;
import android.system.Os;
import android.system.OsConstants;
import android.util.Log;

import java.io.*;
import java.lang.reflect.Field;
import java.nio.charset.StandardCharsets;
import java.util.UUID;

/**
 * A terminal session, consisting of a process coupled to a terminal interface.
 * <p>
 * The subprocess will be executed by the constructor, and when the size is made known by a call to
 * {@link #updateSize(int, int)} terminal emulation will begin and threads will be spawned to handle the subprocess I/O.
 * All terminal emulation and callback methods will be performed on the main thread.
 * <p>
 * The child process may be exited forcefully by using the {@link #finishIfRunning()} method.
 * <p>
 * NOTE: The terminal session may outlive the EmulatorView, so be careful with callbacks!
 */
public class TerminalSession extends TerminalOutput {

  /**
   * Callback to be invoked when a {@link TerminalSession} changes.
   */
  public interface SessionChangedCallback {
    void onTextChanged(TerminalSession changedSession);

    void onTitleChanged(TerminalSession changedSession);

    void onSessionFinished(TerminalSession finishedSession);

    void onClipboardText(TerminalSession session, String text);

    void onBell(TerminalSession session);

    void onColorsChanged(TerminalSession session);

  }

  @SuppressWarnings("JavaReflectionMemberAccess")
  private static FileDescriptor wrapFileDescriptor(int fileDescriptor) {
    FileDescriptor result = new FileDescriptor();
    try {
      Field descriptorField;
      try {
        descriptorField = FileDescriptor.class.getDeclaredField("descriptor");
      } catch (NoSuchFieldException e) {
        // For desktop java:
        descriptorField = FileDescriptor.class.getDeclaredField("fd");
      }
      descriptorField.setAccessible(true);
      descriptorField.set(result, fileDescriptor);
    } catch (NoSuchFieldException | IllegalAccessException | IllegalArgumentException e) {
      Log.wtf(EmulatorDebug.LOG_TAG, "Error accessing FileDescriptor#descriptor private field", e);
      System.exit(1);
    }
    return result;
  }

  private static final int MSG_NEW_INPUT = 1;
  private static final int MSG_PROCESS_EXITED = 4;

  public final String mHandle = UUID.randomUUID().toString();

  private TerminalEmulator mEmulator;

  /**
   * A queue written to from a separate thread when the process outputs, and read by main thread to process by
   * terminal emulator.
   */
  private final ByteQueue mProcessToTerminalIOQueue = new ByteQueue(4096);
  /**
   * A queue written to from the main thread due to user interaction, and read by another thread which forwards by
   * writing to the {@link #mTerminalFileDescriptor}.
   */
  private final ByteQueue mTerminalToProcessIOQueue = new ByteQueue(4096);
  /**
   * Buffer to write translate code points into utf8 before writing to mTerminalToProcessIOQueue
   */
  private final byte[] mUtf8InputBuffer = new byte[5];

  public SessionChangedCallback getSessionChangedCallback() {
    return mChangeCallback;
  }

  /**
   * Callback which gets notified when a session finishes or changes title.
   */
  private final SessionChangedCallback mChangeCallback;

  /**
   * The pid of the executablePath process. 0 if not started and -1 if finished running.
   */
  private int mShellPid;

  /**
   * The exit status of the executablePath process. Only valid if ${@link #mShellPid} is -1.
   */
  private int mShellExitStatus;

  /**
   * The file descriptor referencing the master half of a pseudo-terminal pair, resulting from calling
   * {@link JNI#createSubprocess(String, String, String[], String[], int[], int, int)}.
   */
  private int mTerminalFileDescriptor;

  /**
   * Set by the application for user identification of session, not by terminal.
   */
  public String mSessionName;

  @SuppressLint("HandlerLeak")
  private final Handler mMainThreadHandler = new Handler() {
    final byte[] mReceiveBuffer = new byte[4 * 1024];

    @Override
    public void handleMessage(Message msg) {
      if (msg.what == MSG_NEW_INPUT && isRunning()) {
        int bytesRead = mProcessToTerminalIOQueue.read(mReceiveBuffer, false);
        if (bytesRead > 0) {
          mEmulator.append(mReceiveBuffer, bytesRead);
          notifyScreenUpdate();
        }
      } else if (msg.what == MSG_PROCESS_EXITED) {
        int exitCode = (Integer) msg.obj;
        cleanupResources(exitCode);
        mChangeCallback.onSessionFinished(TerminalSession.this);

        String exitDescription = getExitDescription(exitCode);
        byte[] bytesToWrite = exitDescription.getBytes(StandardCharsets.UTF_8);
        mEmulator.append(bytesToWrite, bytesToWrite.length);
        notifyScreenUpdate();
      }
    }
  };

  private final String mShellPath;
  private final String mCwd;
  private final String[] mArgs;
  private final String[] mEnv;

  public TerminalSession(String shellPath, String cwd, String[] args, String[] env, SessionChangedCallback changeCallback) {
    mChangeCallback = changeCallback;

    this.mShellPath = shellPath;
    this.mCwd = cwd;
    this.mArgs = args;
    this.mEnv = env;
  }

  /**
   * Inform the attached pty of the new size and reflow or initialize the emulator.
   */
  public void updateSize(int columns, int rows) {
    if (mEmulator == null) {
      initializeEmulator(columns, rows);
    } else {
      JNI.setPtyWindowSize(mTerminalFileDescriptor, rows, columns);
      mEmulator.resize(columns, rows);
    }
  }

  /**
   * The terminal title as set through escape sequences or null if none set.
   */
  public String getTitle() {
    return (mEmulator == null) ? null : mEmulator.getTitle();
  }

  /**
   * Set the terminal emulator's window size and start terminal emulation.
   *
   * @param columns The number of columns in the terminal window.
   * @param rows    The number of rows in the terminal window.
   */
  public void initializeEmulator(int columns, int rows) {
    mEmulator = new TerminalEmulator(this, columns, rows, /* transcript= */2000);

    int[] processId = new int[1];
    mTerminalFileDescriptor = JNI.createSubprocess(mShellPath, mCwd, mArgs, mEnv, processId, rows, columns);
    mShellPid = processId[0];

    final FileDescriptor terminalFileDescriptorWrapped = wrapFileDescriptor(mTerminalFileDescriptor);

    new Thread("TermSessionInputReader[pid=" + mShellPid + "]") {
      @Override
      public void run() {
        try (InputStream termIn = new FileInputStream(terminalFileDescriptorWrapped)) {
          final byte[] buffer = new byte[4096];
          while (true) {
            int read = termIn.read(buffer);
            if (read == -1) return;
            if (!mProcessToTerminalIOQueue.write(buffer, 0, read)) return;
            mMainThreadHandler.sendEmptyMessage(MSG_NEW_INPUT);
          }
        } catch (Exception e) {
          // Ignore, just shutting down.
        }
      }
    }.start();

    new Thread("TermSessionOutputWriter[pid=" + mShellPid + "]") {
      @Override
      public void run() {
        final byte[] buffer = new byte[4096];
        try (FileOutputStream termOut = new FileOutputStream(terminalFileDescriptorWrapped)) {
          while (true) {
            int bytesToWrite = mTerminalToProcessIOQueue.read(buffer, true);
            if (bytesToWrite == -1) return;
            termOut.write(buffer, 0, bytesToWrite);
          }
        } catch (IOException e) {
          // Ignore.
        }
      }
    }.start();

    new Thread("TermSessionWaiter[pid=" + mShellPid + "]") {
      @Override
      public void run() {
        int processExitCode = JNI.waitFor(mShellPid);
        mMainThreadHandler.sendMessage(mMainThreadHandler.obtainMessage(MSG_PROCESS_EXITED, processExitCode));
      }
    }.start();
  }

  /**
   * Write data to the executablePath process.
   */
  @Override
  public void write(byte[] data, int offset, int count) {
    if (mShellPid > 0) mTerminalToProcessIOQueue.write(data, offset, count);
  }

  /**
   * Write the Unicode code point to the terminal encoded in UTF-8.
   */
  public void writeCodePoint(boolean prependEscape, int codePoint) {
    if (codePoint > 1114111 || (codePoint >= 0xD800 && codePoint <= 0xDFFF)) {
      // 1114111 (= 2**16 + 1024**2 - 1) is the highest code point, [0xD800,0xDFFF] is the surrogate range.
      throw new IllegalArgumentException("Invalid code point: " + codePoint);
    }

    int bufferPosition = 0;
    if (prependEscape) mUtf8InputBuffer[bufferPosition++] = 27;

    if (codePoint <= /* 7 bits */0b1111111) {
      mUtf8InputBuffer[bufferPosition++] = (byte) codePoint;
    } else if (codePoint <= /* 11 bits */0b11111111111) {
      /* 110xxxxx leading byte with leading 5 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b11000000 | (codePoint >> 6));
      /* 10xxxxxx continuation byte with following 6 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b10000000 | (codePoint & 0b111111));
    } else if (codePoint <= /* 16 bits */0b1111111111111111) {
      /* 1110xxxx leading byte with leading 4 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b11100000 | (codePoint >> 12));
      /* 10xxxxxx continuation byte with following 6 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b10000000 | ((codePoint >> 6) & 0b111111));
      /* 10xxxxxx continuation byte with following 6 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b10000000 | (codePoint & 0b111111));
    } else { /* We have checked codePoint <= 1114111 above, so we have max 21 bits = 0b111111111111111111111 */
      /* 11110xxx leading byte with leading 3 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b11110000 | (codePoint >> 18));
      /* 10xxxxxx continuation byte with following 6 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b10000000 | ((codePoint >> 12) & 0b111111));
      /* 10xxxxxx continuation byte with following 6 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b10000000 | ((codePoint >> 6) & 0b111111));
      /* 10xxxxxx continuation byte with following 6 bits */
      mUtf8InputBuffer[bufferPosition++] = (byte) (0b10000000 | (codePoint & 0b111111));
    }
    write(mUtf8InputBuffer, 0, bufferPosition);
  }

  public TerminalEmulator getEmulator() {
    return mEmulator;
  }

  /**
   * Notify the {@link #mChangeCallback} that the screen has changed.
   */
  private void notifyScreenUpdate() {
    mChangeCallback.onTextChanged(this);
  }

  /**
   * Reset state for terminal emulator state.
   */
  public void reset() {
    mEmulator.reset();
    notifyScreenUpdate();
  }

  /**
   * Finish this terminal session by sending SIGKILL to the executablePath.
   */
  public void finishIfRunning() {
    if (isRunning()) {
      try {
        Os.kill(mShellPid, OsConstants.SIGKILL);
      } catch (ErrnoException e) {
        Log.w("neoterm-shell-session",
          "Failed sending SIGKILL: " + e.getMessage());
      }
    }
  }

  protected String getExitDescription(int exitCode) {
    String exitDescription = "\r\n[Process completed";
    if (exitCode > 0) {
      // Non-zero process exit.
      exitDescription += " (code " + exitCode + ")";
    } else if (exitCode < 0) {
      // Negated signal.
      exitDescription += " (signal " + (-exitCode) + ")";
    }
    exitDescription += " - press Enter]";
    return exitDescription;
  }

  /**
   * Cleanup resources when the process exits.
   */
  private void cleanupResources(int exitStatus) {
    synchronized (this) {
      mShellPid = -1;
      mShellExitStatus = exitStatus;
    }

    // Stop the reader and writer threads, and close the I/O streams
    mTerminalToProcessIOQueue.close();
    mProcessToTerminalIOQueue.close();
    JNI.close(mTerminalFileDescriptor);
  }

  @Override
  public void titleChanged(String oldTitle, String newTitle) {
    mChangeCallback.onTitleChanged(this);
  }

  public synchronized boolean isRunning() {
    return mShellPid != -1;
  }

  /**
   * Only valid if not {@link #isRunning()}.
   */
  public synchronized int getExitStatus() {
    return mShellExitStatus;
  }

  @Override
  public void clipboardText(String text) {
    mChangeCallback.onClipboardText(this, text);
  }

  @Override
  public void onBell() {
    mChangeCallback.onBell(this);
  }

  @Override
  public void onColorsChanged() {
    mChangeCallback.onColorsChanged(this);
  }

  public int getPid() {
    return mShellPid;
  }

}

```

`app/src/main/java/io/neoterm/backend/TextStyle.java`:

```java
package io.neoterm.backend;

/**
 * <p>
 * Encodes effects, foregroundColor and backgroundColor colors into a 64 bit long, which are stored for each cell in a terminal
 * row in {@link TerminalRow#mStyle}.
 * </p>
 * <p>
 * The bit layout is:
 * </p>
 * - 16 flags (11 currently used).
 * - 24 for foregroundColor color (only 9 first bits if a color index).
 * - 24 for backgroundColor color (only 9 first bits if a color index).
 */
public final class TextStyle {

  public final static int CHARACTER_ATTRIBUTE_BOLD = 1;
  public final static int CHARACTER_ATTRIBUTE_ITALIC = 1 << 1;
  public final static int CHARACTER_ATTRIBUTE_UNDERLINE = 1 << 2;
  public final static int CHARACTER_ATTRIBUTE_BLINK = 1 << 3;
  public final static int CHARACTER_ATTRIBUTE_INVERSE = 1 << 4;
  public final static int CHARACTER_ATTRIBUTE_INVISIBLE = 1 << 5;
  public final static int CHARACTER_ATTRIBUTE_STRIKETHROUGH = 1 << 6;
  /**
   * The selective erase control functions (DECSED and DECSEL) can only erase characters defined as erasable.
   * <p>
   * This bit is set if DECSCA (Select Character Protection Attribute) has been used to define the characters that
   * come after it as erasable from the screen.
   * </p>
   */
  public final static int CHARACTER_ATTRIBUTE_PROTECTED = 1 << 7;
  /**
   * Dim colors. Also known as faint or half intensity.
   */
  public final static int CHARACTER_ATTRIBUTE_DIM = 1 << 8;
  /**
   * If true (24-bit) color is used for the cell for foregroundColor.
   */
  private final static int CHARACTER_ATTRIBUTE_TRUECOLOR_FOREGROUND = 1 << 9;
  /**
   * If true (24-bit) color is used for the cell for foregroundColor.
   */
  private final static int CHARACTER_ATTRIBUTE_TRUECOLOR_BACKGROUND = 1 << 10;

  public final static int COLOR_INDEX_FOREGROUND = 256;
  public final static int COLOR_INDEX_BACKGROUND = 257;
  public final static int COLOR_INDEX_CURSOR = 258;

  /**
   * The 256 standard color entries and the three special (foregroundColor, backgroundColor and cursorColor) ones.
   */
  public final static int NUM_INDEXED_COLORS = 259;

  /**
   * Normal foregroundColor and backgroundColor colors and no effects.
   */
  final static long NORMAL = encode(COLOR_INDEX_FOREGROUND, COLOR_INDEX_BACKGROUND, 0);

  static long encode(int foreColor, int backColor, int effect) {
    long result = effect & 0b111111111;
    if ((0xff000000 & foreColor) == 0xff000000) {
      // 24-bit color.
      result |= CHARACTER_ATTRIBUTE_TRUECOLOR_FOREGROUND | ((foreColor & 0x00ffffffL) << 40L);
    } else {
      // Indexed color.
      result |= (foreColor & 0b111111111L) << 40;
    }
    if ((0xff000000 & backColor) == 0xff000000) {
      // 24-bit color.
      result |= CHARACTER_ATTRIBUTE_TRUECOLOR_BACKGROUND | ((backColor & 0x00ffffffL) << 16L);
    } else {
      // Indexed color.
      result |= (backColor & 0b111111111L) << 16L;
    }

    return result;
  }

  public static int decodeForeColor(long style) {
    if ((style & CHARACTER_ATTRIBUTE_TRUECOLOR_FOREGROUND) == 0) {
      return (int) ((style >>> 40) & 0b111111111L);
    } else {
      return 0xff000000 | (int) ((style >>> 40) & 0x00ffffffL);
    }

  }

  public static int decodeBackColor(long style) {
    if ((style & CHARACTER_ATTRIBUTE_TRUECOLOR_BACKGROUND) == 0) {
      return (int) ((style >>> 16) & 0b111111111L);
    } else {
      return 0xff000000 | (int) ((style >>> 16) & 0x00ffffffL);
    }
  }

  public static int decodeEffect(long style) {
    return (int) (style & 0b11111111111);
  }

}

```

`app/src/main/java/io/neoterm/backend/WcWidth.java`:

```java
package io.neoterm.backend;

/**
 * Implementation of wcwidth(3) for Unicode 9.
 * <p>
 * Implementation from https://github.com/jquast/wcwidth but we return 0 for unprintable characters.
 */
public final class WcWidth {

  // From https://github.com/jquast/wcwidth/blob/master/wcwidth/table_zero.py
  // t commit 0d7de112202cc8b2ebe9232ff4a5c954f19d561a (2016-07-02):
  private static final int[][] ZERO_WIDTH = {
    {0x0300, 0x036f},  // Combining Grave Accent  ..Combining Latin Small Le
    {0x0483, 0x0489},  // Combining Cyrillic Titlo..Combining Cyrillic Milli
    {0x0591, 0x05bd},  // Hebrew Accent Etnahta   ..Hebrew Point Meteg
    {0x05bf, 0x05bf},  // Hebrew Point Rafe       ..Hebrew Point Rafe
    {0x05c1, 0x05c2},  // Hebrew Point Shin Dot   ..Hebrew Point Sin Dot
    {0x05c4, 0x05c5},  // Hebrew Mark Upper Dot   ..Hebrew Mark Lower Dot
    {0x05c7, 0x05c7},  // Hebrew Point Qamats Qata..Hebrew Point Qamats Qata
    {0x0610, 0x061a},  // Arabic Sign Sallallahou ..Arabic Small Kasra
    {0x064b, 0x065f},  // Arabic Fathatan         ..Arabic Wavy Hamza Below
    {0x0670, 0x0670},  // Arabic Letter Superscrip..Arabic Letter Superscrip
    {0x06d6, 0x06dc},  // Arabic Small High Ligatu..Arabic Small High Seen
    {0x06df, 0x06e4},  // Arabic Small High Rounde..Arabic Small High Madda
    {0x06e7, 0x06e8},  // Arabic Small High Yeh   ..Arabic Small High Noon
    {0x06ea, 0x06ed},  // Arabic Empty Centre Low ..Arabic Small Low Meem
    {0x0711, 0x0711},  // Syriac Letter Superscrip..Syriac Letter Superscrip
    {0x0730, 0x074a},  // Syriac Pthaha Above     ..Syriac Barrekh
    {0x07a6, 0x07b0},  // Thaana Abafili          ..Thaana Sukun
    {0x07eb, 0x07f3},  // Nko Combining Sh||t High..Nko Combining Double Dot
    {0x0816, 0x0819},  // Samaritan Mark In       ..Samaritan Mark Dagesh
    {0x081b, 0x0823},  // Samaritan Mark Epentheti..Samaritan Vowel Sign A
    {0x0825, 0x0827},  // Samaritan Vowel Sign Sho..Samaritan Vowel Sign U
    {0x0829, 0x082d},  // Samaritan Vowel Sign Lon..Samaritan Mark Nequdaa
    {0x0859, 0x085b},  // Mandaic Affrication Mark..Mandaic Gemination Mark
    {0x08d4, 0x08e1},  // (nil)                   ..
    {0x08e3, 0x0902},  // Arabic Turned Damma Belo..Devanagari Sign Anusvara
    {0x093a, 0x093a},  // Devanagari Vowel Sign Oe..Devanagari Vowel Sign Oe
    {0x093c, 0x093c},  // Devanagari Sign Nukta   ..Devanagari Sign Nukta
    {0x0941, 0x0948},  // Devanagari Vowel Sign U ..Devanagari Vowel Sign Ai
    {0x094d, 0x094d},  // Devanagari Sign Virama  ..Devanagari Sign Virama
    {0x0951, 0x0957},  // Devanagari Stress Sign U..Devanagari Vowel Sign Uu
    {0x0962, 0x0963},  // Devanagari Vowel Sign Vo..Devanagari Vowel Sign Vo
    {0x0981, 0x0981},  // Bengali Sign Candrabindu..Bengali Sign Candrabindu
    {0x09bc, 0x09bc},  // Bengali Sign Nukta      ..Bengali Sign Nukta
    {0x09c1, 0x09c4},  // Bengali Vowel Sign U    ..Bengali Vowel Sign Vocal
    {0x09cd, 0x09cd},  // Bengali Sign Virama     ..Bengali Sign Virama
    {0x09e2, 0x09e3},  // Bengali Vowel Sign Vocal..Bengali Vowel Sign Vocal
    {0x0a01, 0x0a02},  // Gurmukhi Sign Adak Bindi..Gurmukhi Sign Bindi
    {0x0a3c, 0x0a3c},  // Gurmukhi Sign Nukta     ..Gurmukhi Sign Nukta
    {0x0a41, 0x0a42},  // Gurmukhi Vowel Sign U   ..Gurmukhi Vowel Sign Uu
    {0x0a47, 0x0a48},  // Gurmukhi Vowel Sign Ee  ..Gurmukhi Vowel Sign Ai
    {0x0a4b, 0x0a4d},  // Gurmukhi Vowel Sign Oo  ..Gurmukhi Sign Virama
    {0x0a51, 0x0a51},  // Gurmukhi Sign Udaat     ..Gurmukhi Sign Udaat
    {0x0a70, 0x0a71},  // Gurmukhi Tippi          ..Gurmukhi Addak
    {0x0a75, 0x0a75},  // Gurmukhi Sign Yakash    ..Gurmukhi Sign Yakash
    {0x0a81, 0x0a82},  // Gujarati Sign Candrabind..Gujarati Sign Anusvara
    {0x0abc, 0x0abc},  // Gujarati Sign Nukta     ..Gujarati Sign Nukta
    {0x0ac1, 0x0ac5},  // Gujarati Vowel Sign U   ..Gujarati Vowel Sign Cand
    {0x0ac7, 0x0ac8},  // Gujarati Vowel Sign E   ..Gujarati Vowel Sign Ai
    {0x0acd, 0x0acd},  // Gujarati Sign Virama    ..Gujarati Sign Virama
    {0x0ae2, 0x0ae3},  // Gujarati Vowel Sign Voca..Gujarati Vowel Sign Voca
    {0x0b01, 0x0b01},  // ||iya Sign Candrabindu  ..||iya Sign Candrabindu
    {0x0b3c, 0x0b3c},  // ||iya Sign Nukta        ..||iya Sign Nukta
    {0x0b3f, 0x0b3f},  // ||iya Vowel Sign I      ..||iya Vowel Sign I
    {0x0b41, 0x0b44},  // ||iya Vowel Sign U      ..||iya Vowel Sign Vocalic
    {0x0b4d, 0x0b4d},  // ||iya Sign Virama       ..||iya Sign Virama
    {0x0b56, 0x0b56},  // ||iya Ai Length Mark    ..||iya Ai Length Mark
    {0x0b62, 0x0b63},  // ||iya Vowel Sign Vocalic..||iya Vowel Sign Vocalic
    {0x0b82, 0x0b82},  // Tamil Sign Anusvara     ..Tamil Sign Anusvara
    {0x0bc0, 0x0bc0},  // Tamil Vowel Sign Ii     ..Tamil Vowel Sign Ii
    {0x0bcd, 0x0bcd},  // Tamil Sign Virama       ..Tamil Sign Virama
    {0x0c00, 0x0c00},  // Telugu Sign Combining Ca..Telugu Sign Combining Ca
    {0x0c3e, 0x0c40},  // Telugu Vowel Sign Aa    ..Telugu Vowel Sign Ii
    {0x0c46, 0x0c48},  // Telugu Vowel Sign E     ..Telugu Vowel Sign Ai
    {0x0c4a, 0x0c4d},  // Telugu Vowel Sign O     ..Telugu Sign Virama
    {0x0c55, 0x0c56},  // Telugu Length Mark      ..Telugu Ai Length Mark
    {0x0c62, 0x0c63},  // Telugu Vowel Sign Vocali..Telugu Vowel Sign Vocali
    {0x0c81, 0x0c81},  // Kannada Sign Candrabindu..Kannada Sign Candrabindu
    {0x0cbc, 0x0cbc},  // Kannada Sign Nukta      ..Kannada Sign Nukta
    {0x0cbf, 0x0cbf},  // Kannada Vowel Sign I    ..Kannada Vowel Sign I
    {0x0cc6, 0x0cc6},  // Kannada Vowel Sign E    ..Kannada Vowel Sign E
    {0x0ccc, 0x0ccd},  // Kannada Vowel Sign Au   ..Kannada Sign Virama
    {0x0ce2, 0x0ce3},  // Kannada Vowel Sign Vocal..Kannada Vowel Sign Vocal
    {0x0d01, 0x0d01},  // Malayalam Sign Candrabin..Malayalam Sign Candrabin
    {0x0d41, 0x0d44},  // Malayalam Vowel Sign U  ..Malayalam Vowel Sign Voc
    {0x0d4d, 0x0d4d},  // Malayalam Sign Virama   ..Malayalam Sign Virama
    {0x0d62, 0x0d63},  // Malayalam Vowel Sign Voc..Malayalam Vowel Sign Voc
    {0x0dca, 0x0dca},  // Sinhala Sign Al-lakuna  ..Sinhala Sign Al-lakuna
    {0x0dd2, 0x0dd4},  // Sinhala Vowel Sign Ketti..Sinhala Vowel Sign Ketti
    {0x0dd6, 0x0dd6},  // Sinhala Vowel Sign Diga ..Sinhala Vowel Sign Diga
    {0x0e31, 0x0e31},  // Thai Character Mai Han-a..Thai Character Mai Han-a
    {0x0e34, 0x0e3a},  // Thai Character Sara I   ..Thai Character Phinthu
    {0x0e47, 0x0e4e},  // Thai Character Maitaikhu..Thai Character Yamakkan
    {0x0eb1, 0x0eb1},  // Lao Vowel Sign Mai Kan  ..Lao Vowel Sign Mai Kan
    {0x0eb4, 0x0eb9},  // Lao Vowel Sign I        ..Lao Vowel Sign Uu
    {0x0ebb, 0x0ebc},  // Lao Vowel Sign Mai Kon  ..Lao Semivowel Sign Lo
    {0x0ec8, 0x0ecd},  // Lao Tone Mai Ek         ..Lao Niggahita
    {0x0f18, 0x0f19},  // Tibetan Astrological Sig..Tibetan Astrological Sig
    {0x0f35, 0x0f35},  // Tibetan Mark Ngas Bzung ..Tibetan Mark Ngas Bzung
    {0x0f37, 0x0f37},  // Tibetan Mark Ngas Bzung ..Tibetan Mark Ngas Bzung
    {0x0f39, 0x0f39},  // Tibetan Mark Tsa -phru  ..Tibetan Mark Tsa -phru
    {0x0f71, 0x0f7e},  // Tibetan Vowel Sign Aa   ..Tibetan Sign Rjes Su Nga
    {0x0f80, 0x0f84},  // Tibetan Vowel Sign Rever..Tibetan Mark Halanta
    {0x0f86, 0x0f87},  // Tibetan Sign Lci Rtags  ..Tibetan Sign Yang Rtags
    {0x0f8d, 0x0f97},  // Tibetan Subjoined Sign L..Tibetan Subjoined Letter
    {0x0f99, 0x0fbc},  // Tibetan Subjoined Letter..Tibetan Subjoined Letter
    {0x0fc6, 0x0fc6},  // Tibetan Symbol Padma Gda..Tibetan Symbol Padma Gda
    {0x102d, 0x1030},  // Myanmar Vowel Sign I    ..Myanmar Vowel Sign Uu
    {0x1032, 0x1037},  // Myanmar Vowel Sign Ai   ..Myanmar Sign Dot Below
    {0x1039, 0x103a},  // Myanmar Sign Virama     ..Myanmar Sign Asat
    {0x103d, 0x103e},  // Myanmar Consonant Sign M..Myanmar Consonant Sign M
    {0x1058, 0x1059},  // Myanmar Vowel Sign Vocal..Myanmar Vowel Sign Vocal
    {0x105e, 0x1060},  // Myanmar Consonant Sign M..Myanmar Consonant Sign M
    {0x1071, 0x1074},  // Myanmar Vowel Sign Geba ..Myanmar Vowel Sign Kayah
    {0x1082, 0x1082},  // Myanmar Consonant Sign S..Myanmar Consonant Sign S
    {0x1085, 0x1086},  // Myanmar Vowel Sign Shan ..Myanmar Vowel Sign Shan
    {0x108d, 0x108d},  // Myanmar Sign Shan Counci..Myanmar Sign Shan Counci
    {0x109d, 0x109d},  // Myanmar Vowel Sign Aiton..Myanmar Vowel Sign Aiton
    {0x135d, 0x135f},  // Ethiopic Combining Gemin..Ethiopic Combining Gemin
    {0x1712, 0x1714},  // Tagalog Vowel Sign I    ..Tagalog Sign Virama
    {0x1732, 0x1734},  // Hanunoo Vowel Sign I    ..Hanunoo Sign Pamudpod
    {0x1752, 0x1753},  // Buhid Vowel Sign I      ..Buhid Vowel Sign U
    {0x1772, 0x1773},  // Tagbanwa Vowel Sign I   ..Tagbanwa Vowel Sign U
    {0x17b4, 0x17b5},  // Khmer Vowel Inherent Aq ..Khmer Vowel Inherent Aa
    {0x17b7, 0x17bd},  // Khmer Vowel Sign I      ..Khmer Vowel Sign Ua
    {0x17c6, 0x17c6},  // Khmer Sign Nikahit      ..Khmer Sign Nikahit
    {0x17c9, 0x17d3},  // Khmer Sign Muusikatoan  ..Khmer Sign Bathamasat
    {0x17dd, 0x17dd},  // Khmer Sign Atthacan     ..Khmer Sign Atthacan
    {0x180b, 0x180d},  // Mongolian Free Variation..Mongolian Free Variation
    {0x1885, 0x1886},  // Mongolian Letter Ali Gal..Mongolian Letter Ali Gal
    {0x18a9, 0x18a9},  // Mongolian Letter Ali Gal..Mongolian Letter Ali Gal
    {0x1920, 0x1922},  // Limbu Vowel Sign A      ..Limbu Vowel Sign U
    {0x1927, 0x1928},  // Limbu Vowel Sign E      ..Limbu Vowel Sign O
    {0x1932, 0x1932},  // Limbu Small Letter Anusv..Limbu Small Letter Anusv
    {0x1939, 0x193b},  // Limbu Sign Mukphreng    ..Limbu Sign Sa-i
    {0x1a17, 0x1a18},  // Buginese Vowel Sign I   ..Buginese Vowel Sign U
    {0x1a1b, 0x1a1b},  // Buginese Vowel Sign Ae  ..Buginese Vowel Sign Ae
    {0x1a56, 0x1a56},  // Tai Tham Consonant Sign ..Tai Tham Consonant Sign
    {0x1a58, 0x1a5e},  // Tai Tham Sign Mai Kang L..Tai Tham Consonant Sign
    {0x1a60, 0x1a60},  // Tai Tham Sign Sakot     ..Tai Tham Sign Sakot
    {0x1a62, 0x1a62},  // Tai Tham Vowel Sign Mai ..Tai Tham Vowel Sign Mai
    {0x1a65, 0x1a6c},  // Tai Tham Vowel Sign I   ..Tai Tham Vowel Sign Oa B
    {0x1a73, 0x1a7c},  // Tai Tham Vowel Sign Oa A..Tai Tham Sign Khuen-lue
    {0x1a7f, 0x1a7f},  // Tai Tham Combining Crypt..Tai Tham Combining Crypt
    {0x1ab0, 0x1abe},  // Combining Doubled Circum..Combining Parentheses Ov
    {0x1b00, 0x1b03},  // Balinese Sign Ulu Ricem ..Balinese Sign Surang
    {0x1b34, 0x1b34},  // Balinese Sign Rerekan   ..Balinese Sign Rerekan
    {0x1b36, 0x1b3a},  // Balinese Vowel Sign Ulu ..Balinese Vowel Sign Ra R
    {0x1b3c, 0x1b3c},  // Balinese Vowel Sign La L..Balinese Vowel Sign La L
    {0x1b42, 0x1b42},  // Balinese Vowel Sign Pepe..Balinese Vowel Sign Pepe
    {0x1b6b, 0x1b73},  // Balinese Musical Symbol ..Balinese Musical Symbol
    {0x1b80, 0x1b81},  // Sundanese Sign Panyecek ..Sundanese Sign Panglayar
    {0x1ba2, 0x1ba5},  // Sundanese Consonant Sign..Sundanese Vowel Sign Pan
    {0x1ba8, 0x1ba9},  // Sundanese Vowel Sign Pam..Sundanese Vowel Sign Pan
    {0x1bab, 0x1bad},  // Sundanese Sign Virama   ..Sundanese Consonant Sign
    {0x1be6, 0x1be6},  // Batak Sign Tompi        ..Batak Sign Tompi
    {0x1be8, 0x1be9},  // Batak Vowel Sign Pakpak ..Batak Vowel Sign Ee
    {0x1bed, 0x1bed},  // Batak Vowel Sign Karo O ..Batak Vowel Sign Karo O
    {0x1bef, 0x1bf1},  // Batak Vowel Sign U F|| S..Batak Consonant Sign H
    {0x1c2c, 0x1c33},  // Lepcha Vowel Sign E     ..Lepcha Consonant Sign T
    {0x1c36, 0x1c37},  // Lepcha Sign Ran         ..Lepcha Sign Nukta
    {0x1cd0, 0x1cd2},  // Vedic Tone Karshana     ..Vedic Tone Prenkha
    {0x1cd4, 0x1ce0},  // Vedic Sign Yajurvedic Mi..Vedic Tone Rigvedic Kash
    {0x1ce2, 0x1ce8},  // Vedic Sign Visarga Svari..Vedic Sign Visarga Anuda
    {0x1ced, 0x1ced},  // Vedic Sign Tiryak       ..Vedic Sign Tiryak
    {0x1cf4, 0x1cf4},  // Vedic Tone Candra Above ..Vedic Tone Candra Above
    {0x1cf8, 0x1cf9},  // Vedic Tone Ring Above   ..Vedic Tone Double Ring A
    {0x1dc0, 0x1df5},  // Combining Dotted Grave A..Combining Up Tack Above
    {0x1dfb, 0x1dff},  // (nil)                   ..Combining Right Arrowhea
    {0x20d0, 0x20f0},  // Combining Left Harpoon A..Combining Asterisk Above
    {0x2cef, 0x2cf1},  // Coptic Combining Ni Abov..Coptic Combining Spiritu
    {0x2d7f, 0x2d7f},  // Tifinagh Consonant Joine..Tifinagh Consonant Joine
    {0x2de0, 0x2dff},  // Combining Cyrillic Lette..Combining Cyrillic Lette
    {0x302a, 0x302d},  // Ideographic Level Tone M..Ideographic Entering Ton
    {0x3099, 0x309a},  // Combining Katakana-hirag..Combining Katakana-hirag
    {0xa66f, 0xa672},  // Combining Cyrillic Vzmet..Combining Cyrillic Thous
    {0xa674, 0xa67d},  // Combining Cyrillic Lette..Combining Cyrillic Payer
    {0xa69e, 0xa69f},  // Combining Cyrillic Lette..Combining Cyrillic Lette
    {0xa6f0, 0xa6f1},  // Bamum Combining Mark Koq..Bamum Combining Mark Tuk
    {0xa802, 0xa802},  // Syloti Nagri Sign Dvisva..Syloti Nagri Sign Dvisva
    {0xa806, 0xa806},  // Syloti Nagri Sign Hasant..Syloti Nagri Sign Hasant
    {0xa80b, 0xa80b},  // Syloti Nagri Sign Anusva..Syloti Nagri Sign Anusva
    {0xa825, 0xa826},  // Syloti Nagri Vowel Sign ..Syloti Nagri Vowel Sign
    {0xa8c4, 0xa8c5},  // Saurashtra Sign Virama  ..
    {0xa8e0, 0xa8f1},  // Combining Devanagari Dig..Combining Devanagari Sig
    {0xa926, 0xa92d},  // Kayah Li Vowel Ue       ..Kayah Li Tone Calya Plop
    {0xa947, 0xa951},  // Rejang Vowel Sign I     ..Rejang Consonant Sign R
    {0xa980, 0xa982},  // Javanese Sign Panyangga ..Javanese Sign Layar
    {0xa9b3, 0xa9b3},  // Javanese Sign Cecak Telu..Javanese Sign Cecak Telu
    {0xa9b6, 0xa9b9},  // Javanese Vowel Sign Wulu..Javanese Vowel Sign Suku
    {0xa9bc, 0xa9bc},  // Javanese Vowel Sign Pepe..Javanese Vowel Sign Pepe
    {0xa9e5, 0xa9e5},  // Myanmar Sign Shan Saw   ..Myanmar Sign Shan Saw
    {0xaa29, 0xaa2e},  // Cham Vowel Sign Aa      ..Cham Vowel Sign Oe
    {0xaa31, 0xaa32},  // Cham Vowel Sign Au      ..Cham Vowel Sign Ue
    {0xaa35, 0xaa36},  // Cham Consonant Sign La  ..Cham Consonant Sign Wa
    {0xaa43, 0xaa43},  // Cham Consonant Sign Fina..Cham Consonant Sign Fina
    {0xaa4c, 0xaa4c},  // Cham Consonant Sign Fina..Cham Consonant Sign Fina
    {0xaa7c, 0xaa7c},  // Myanmar Sign Tai Laing T..Myanmar Sign Tai Laing T
    {0xaab0, 0xaab0},  // Tai Viet Mai Kang       ..Tai Viet Mai Kang
    {0xaab2, 0xaab4},  // Tai Viet Vowel I        ..Tai Viet Vowel U
    {0xaab7, 0xaab8},  // Tai Viet Mai Khit       ..Tai Viet Vowel Ia
    {0xaabe, 0xaabf},  // Tai Viet Vowel Am       ..Tai Viet Tone Mai Ek
    {0xaac1, 0xaac1},  // Tai Viet Tone Mai Tho   ..Tai Viet Tone Mai Tho
    {0xaaec, 0xaaed},  // Meetei Mayek Vowel Sign ..Meetei Mayek Vowel Sign
    {0xaaf6, 0xaaf6},  // Meetei Mayek Virama     ..Meetei Mayek Virama
    {0xabe5, 0xabe5},  // Meetei Mayek Vowel Sign ..Meetei Mayek Vowel Sign
    {0xabe8, 0xabe8},  // Meetei Mayek Vowel Sign ..Meetei Mayek Vowel Sign
    {0xabed, 0xabed},  // Meetei Mayek Apun Iyek  ..Meetei Mayek Apun Iyek
    {0xfb1e, 0xfb1e},  // Hebrew Point Judeo-spani..Hebrew Point Judeo-spani
    {0xfe00, 0xfe0f},  // Variation Select||-1    ..Variation Select||-16
    {0xfe20, 0xfe2f},  // Combining Ligature Left ..Combining Cyrillic Titlo
    {0x101fd, 0x101fd},  // Phaistos Disc Sign Combi..Phaistos Disc Sign Combi
    {0x102e0, 0x102e0},  // Coptic Epact Thousands M..Coptic Epact Thousands M
    {0x10376, 0x1037a},  // Combining Old Permic Let..Combining Old Permic Let
    {0x10a01, 0x10a03},  // Kharoshthi Vowel Sign I ..Kharoshthi Vowel Sign Vo
    {0x10a05, 0x10a06},  // Kharoshthi Vowel Sign E ..Kharoshthi Vowel Sign O
    {0x10a0c, 0x10a0f},  // Kharoshthi Vowel Length ..Kharoshthi Sign Visarga
    {0x10a38, 0x10a3a},  // Kharoshthi Sign Bar Abov..Kharoshthi Sign Dot Belo
    {0x10a3f, 0x10a3f},  // Kharoshthi Virama       ..Kharoshthi Virama
    {0x10ae5, 0x10ae6},  // Manichaean Abbreviation ..Manichaean Abbreviation
    {0x11001, 0x11001},  // Brahmi Sign Anusvara    ..Brahmi Sign Anusvara
    {0x11038, 0x11046},  // Brahmi Vowel Sign Aa    ..Brahmi Virama
    {0x1107f, 0x11081},  // Brahmi Number Joiner    ..Kaithi Sign Anusvara
    {0x110b3, 0x110b6},  // Kaithi Vowel Sign U     ..Kaithi Vowel Sign Ai
    {0x110b9, 0x110ba},  // Kaithi Sign Virama      ..Kaithi Sign Nukta
    {0x11100, 0x11102},  // Chakma Sign Candrabindu ..Chakma Sign Visarga
    {0x11127, 0x1112b},  // Chakma Vowel Sign A     ..Chakma Vowel Sign Uu
    {0x1112d, 0x11134},  // Chakma Vowel Sign Ai    ..Chakma Maayyaa
    {0x11173, 0x11173},  // Mahajani Sign Nukta     ..Mahajani Sign Nukta
    {0x11180, 0x11181},  // Sharada Sign Candrabindu..Sharada Sign Anusvara
    {0x111b6, 0x111be},  // Sharada Vowel Sign U    ..Sharada Vowel Sign O
    {0x111ca, 0x111cc},  // Sharada Sign Nukta      ..Sharada Extra Sh||t Vowe
    {0x1122f, 0x11231},  // Khojki Vowel Sign U     ..Khojki Vowel Sign Ai
    {0x11234, 0x11234},  // Khojki Sign Anusvara    ..Khojki Sign Anusvara
    {0x11236, 0x11237},  // Khojki Sign Nukta       ..Khojki Sign Shadda
    {0x1123e, 0x1123e},  // (nil)                   ..
    {0x112df, 0x112df},  // Khudawadi Sign Anusvara ..Khudawadi Sign Anusvara
    {0x112e3, 0x112ea},  // Khudawadi Vowel Sign U  ..Khudawadi Sign Virama
    {0x11300, 0x11301},  // Grantha Sign Combining A..Grantha Sign Candrabindu
    {0x1133c, 0x1133c},  // Grantha Sign Nukta      ..Grantha Sign Nukta
    {0x11340, 0x11340},  // Grantha Vowel Sign Ii   ..Grantha Vowel Sign Ii
    {0x11366, 0x1136c},  // Combining Grantha Digit ..Combining Grantha Digit
    {0x11370, 0x11374},  // Combining Grantha Letter..Combining Grantha Letter
    {0x11438, 0x1143f},  // (nil)                   ..
    {0x11442, 0x11444},  // (nil)                   ..
    {0x11446, 0x11446},  // (nil)                   ..
    {0x114b3, 0x114b8},  // Tirhuta Vowel Sign U    ..Tirhuta Vowel Sign Vocal
    {0x114ba, 0x114ba},  // Tirhuta Vowel Sign Sh||t..Tirhuta Vowel Sign Sh||t
    {0x114bf, 0x114c0},  // Tirhuta Sign Candrabindu..Tirhuta Sign Anusvara
    {0x114c2, 0x114c3},  // Tirhuta Sign Virama     ..Tirhuta Sign Nukta
    {0x115b2, 0x115b5},  // Siddham Vowel Sign U    ..Siddham Vowel Sign Vocal
    {0x115bc, 0x115bd},  // Siddham Sign Candrabindu..Siddham Sign Anusvara
    {0x115bf, 0x115c0},  // Siddham Sign Virama     ..Siddham Sign Nukta
    {0x115dc, 0x115dd},  // Siddham Vowel Sign Alter..Siddham Vowel Sign Alter
    {0x11633, 0x1163a},  // Modi Vowel Sign U       ..Modi Vowel Sign Ai
    {0x1163d, 0x1163d},  // Modi Sign Anusvara      ..Modi Sign Anusvara
    {0x1163f, 0x11640},  // Modi Sign Virama        ..Modi Sign Ardhacandra
    {0x116ab, 0x116ab},  // Takri Sign Anusvara     ..Takri Sign Anusvara
    {0x116ad, 0x116ad},  // Takri Vowel Sign Aa     ..Takri Vowel Sign Aa
    {0x116b0, 0x116b5},  // Takri Vowel Sign U      ..Takri Vowel Sign Au
    {0x116b7, 0x116b7},  // Takri Sign Nukta        ..Takri Sign Nukta
    {0x1171d, 0x1171f},  // Ahom Consonant Sign Medi..Ahom Consonant Sign Medi
    {0x11722, 0x11725},  // Ahom Vowel Sign I       ..Ahom Vowel Sign Uu
    {0x11727, 0x1172b},  // Ahom Vowel Sign Aw      ..Ahom Sign Killer
    {0x11c30, 0x11c36},  // (nil)                   ..
    {0x11c38, 0x11c3d},  // (nil)                   ..
    {0x11c3f, 0x11c3f},  // (nil)                   ..
    {0x11c92, 0x11ca7},  // (nil)                   ..
    {0x11caa, 0x11cb0},  // (nil)                   ..
    {0x11cb2, 0x11cb3},  // (nil)                   ..
    {0x11cb5, 0x11cb6},  // (nil)                   ..
    {0x16af0, 0x16af4},  // Bassa Vah Combining High..Bassa Vah Combining High
    {0x16b30, 0x16b36},  // Pahawh Hmong Mark Cim Tu..Pahawh Hmong Mark Cim Ta
    {0x16f8f, 0x16f92},  // Miao Tone Right         ..Miao Tone Below
    {0x1bc9d, 0x1bc9e},  // Duployan Thick Letter Se..Duployan Double Mark
    {0x1d167, 0x1d169},  // Musical Symbol Combining..Musical Symbol Combining
    {0x1d17b, 0x1d182},  // Musical Symbol Combining..Musical Symbol Combining
    {0x1d185, 0x1d18b},  // Musical Symbol Combining..Musical Symbol Combining
    {0x1d1aa, 0x1d1ad},  // Musical Symbol Combining..Musical Symbol Combining
    {0x1d242, 0x1d244},  // Combining Greek Musical ..Combining Greek Musical
    {0x1da00, 0x1da36},  // Signwriting Head Rim    ..Signwriting Air Sucking
    {0x1da3b, 0x1da6c},  // Signwriting Mouth Closed..Signwriting Excitement
    {0x1da75, 0x1da75},  // Signwriting Upper Body T..Signwriting Upper Body T
    {0x1da84, 0x1da84},  // Signwriting Location Hea..Signwriting Location Hea
    {0x1da9b, 0x1da9f},  // Signwriting Fill Modifie..Signwriting Fill Modifie
    {0x1daa1, 0x1daaf},  // Signwriting Rotation Mod..Signwriting Rotation Mod
    {0x1e000, 0x1e006},  // (nil)                   ..
    {0x1e008, 0x1e018},  // (nil)                   ..
    {0x1e01b, 0x1e021},  // (nil)                   ..
    {0x1e023, 0x1e024},  // (nil)                   ..
    {0x1e026, 0x1e02a},  // (nil)                   ..
    {0x1e8d0, 0x1e8d6},  // Mende Kikakui Combining ..Mende Kikakui Combining
    {0x1e944, 0x1e94a},  // (nil)                   ..
    {0xe0100, 0xe01ef},  // Variation Select||-17   ..Variation Select||-256
  };

  // https://github.com/jquast/wcwidth/blob/master/wcwidth/table_wide.py
  // at commit 0d7de112202cc8b2ebe9232ff4a5c954f19d561a (2016-07-02):
  private static final int[][] WIDE_EASTASIAN = {
    {0x1100, 0x115f},  // Hangul Choseong Kiyeok  ..Hangul Choseong Filler
    {0x231a, 0x231b},  // Watch                   ..Hourglass
    {0x2329, 0x232a},  // Left-pointing Angle Brac..Right-pointing Angle Bra
    {0x23e9, 0x23ec},  // Black Right-pointing Dou..Black Down-pointing Doub
    {0x23f0, 0x23f0},  // Alarm Clock             ..Alarm Clock
    {0x23f3, 0x23f3},  // Hourglass With Flowing S..Hourglass With Flowing S
    {0x25fd, 0x25fe},  // White Medium Small Squar..Black Medium Small Squar
    {0x2614, 0x2615},  // Umbrella With Rain Drops..Hot Beverage
    {0x2648, 0x2653},  // Aries                   ..Pisces
    {0x267f, 0x267f},  // Wheelchair Symbol       ..Wheelchair Symbol
    {0x2693, 0x2693},  // Anch||                  ..Anch||
    {0x26a1, 0x26a1},  // High Voltage Sign       ..High Voltage Sign
    {0x26aa, 0x26ab},  // Medium White Circle     ..Medium Black Circle
    {0x26bd, 0x26be},  // Soccer Ball             ..Baseball
    {0x26c4, 0x26c5},  // Snowman Without Snow    ..Sun Behind Cloud
    {0x26ce, 0x26ce},  // Ophiuchus               ..Ophiuchus
    {0x26d4, 0x26d4},  // No Entry                ..No Entry
    {0x26ea, 0x26ea},  // Church                  ..Church
    {0x26f2, 0x26f3},  // Fountain                ..Flag In Hole
    {0x26f5, 0x26f5},  // Sailboat                ..Sailboat
    {0x26fa, 0x26fa},  // Tent                    ..Tent
    {0x26fd, 0x26fd},  // Fuel Pump               ..Fuel Pump
    {0x2705, 0x2705},  // White Heavy Check Mark  ..White Heavy Check Mark
    {0x270a, 0x270b},  // Raised Fist             ..Raised Hand
    {0x2728, 0x2728},  // Sparkles                ..Sparkles
    {0x274c, 0x274c},  // Cross Mark              ..Cross Mark
    {0x274e, 0x274e},  // Negative Squared Cross M..Negative Squared Cross M
    {0x2753, 0x2755},  // Black Question Mark ||na..White Exclamation Mark O
    {0x2757, 0x2757},  // Heavy Exclamation Mark S..Heavy Exclamation Mark S
    {0x2795, 0x2797},  // Heavy Plus Sign         ..Heavy Division Sign
    {0x27b0, 0x27b0},  // Curly Loop              ..Curly Loop
    {0x27bf, 0x27bf},  // Double Curly Loop       ..Double Curly Loop
    {0x2b1b, 0x2b1c},  // Black Large Square      ..White Large Square
    {0x2b50, 0x2b50},  // White Medium Star       ..White Medium Star
    {0x2b55, 0x2b55},  // Heavy Large Circle      ..Heavy Large Circle
    {0x2e80, 0x2e99},  // Cjk Radical Repeat      ..Cjk Radical Rap
    {0x2e9b, 0x2ef3},  // Cjk Radical Choke       ..Cjk Radical C-simplified
    {0x2f00, 0x2fd5},  // Kangxi Radical One      ..Kangxi Radical Flute
    {0x2ff0, 0x2ffb},  // Ideographic Description ..Ideographic Description
    {0x3000, 0x303e},  // Ideographic Space       ..Ideographic Variation In
    {0x3041, 0x3096},  // Hiragana Letter Small A ..Hiragana Letter Small Ke
    {0x3099, 0x30ff},  // Combining Katakana-hirag..Katakana Digraph Koto
    {0x3105, 0x312d},  // Bopomofo Letter B       ..Bopomofo Letter Ih
    {0x3131, 0x318e},  // Hangul Letter Kiyeok    ..Hangul Letter Araeae
    {0x3190, 0x31ba},  // Ideographic Annotation L..Bopomofo Letter Zy
    {0x31c0, 0x31e3},  // Cjk Stroke T            ..Cjk Stroke Q
    {0x31f0, 0x321e},  // Katakana Letter Small Ku..Parenthesized K||ean Cha
    {0x3220, 0x3247},  // Parenthesized Ideograph ..Circled Ideograph Koto
    {0x3250, 0x32fe},  // Partnership Sign        ..Circled Katakana Wo
    {0x3300, 0x4dbf},  // Square Apaato           ..
    {0x4e00, 0xa48c},  // Cjk Unified Ideograph-4e..Yi Syllable Yyr
    {0xa490, 0xa4c6},  // Yi Radical Qot          ..Yi Radical Ke
    {0xa960, 0xa97c},  // Hangul Choseong Tikeut-m..Hangul Choseong Ssangyeo
    {0xac00, 0xd7a3},  // Hangul Syllable Ga      ..Hangul Syllable Hih
    {0xf900, 0xfaff},  // Cjk Compatibility Ideogr..
    {0xfe10, 0xfe19},  // Presentation F||m F|| Ve..Presentation F||m F|| Ve
    {0xfe30, 0xfe52},  // Presentation F||m F|| Ve..Small Full Stop
    {0xfe54, 0xfe66},  // Small Semicolon         ..Small Equals Sign
    {0xfe68, 0xfe6b},  // Small Reverse Solidus   ..Small Commercial At
    {0xff01, 0xff60},  // Fullwidth Exclamation Ma..Fullwidth Right White Pa
    {0xffe0, 0xffe6},  // Fullwidth Cent Sign     ..Fullwidth Won Sign
    {0x16fe0, 0x16fe0},  // (nil)                   ..
    {0x17000, 0x187ec},  // (nil)                   ..
    {0x18800, 0x18af2},  // (nil)                   ..
    {0x1b000, 0x1b001},  // Katakana Letter Archaic ..Hiragana Letter Archaic
    {0x1f004, 0x1f004},  // Mahjong Tile Red Dragon ..Mahjong Tile Red Dragon
    {0x1f0cf, 0x1f0cf},  // Playing Card Black Joker..Playing Card Black Joker
    {0x1f18e, 0x1f18e},  // Negative Squared Ab     ..Negative Squared Ab
    {0x1f191, 0x1f19a},  // Squared Cl              ..Squared Vs
    {0x1f200, 0x1f202},  // Square Hiragana Hoka    ..Squared Katakana Sa
    {0x1f210, 0x1f23b},  // Squared Cjk Unified Ideo..
    {0x1f240, 0x1f248},  // T||toise Shell Bracketed..T||toise Shell Bracketed
    {0x1f250, 0x1f251},  // Circled Ideograph Advant..Circled Ideograph Accept
    {0x1f300, 0x1f320},  // Cyclone                 ..Shooting Star
    {0x1f32d, 0x1f335},  // Hot Dog                 ..Cactus
    {0x1f337, 0x1f37c},  // Tulip                   ..Baby Bottle
    {0x1f37e, 0x1f393},  // Bottle With Popping C||k..Graduation Cap
    {0x1f3a0, 0x1f3ca},  // Carousel H||se          ..Swimmer
    {0x1f3cf, 0x1f3d3},  // Cricket Bat And Ball    ..Table Tennis Paddle And
    {0x1f3e0, 0x1f3f0},  // House Building          ..European Castle
    {0x1f3f4, 0x1f3f4},  // Waving Black Flag       ..Waving Black Flag
    {0x1f3f8, 0x1f43e},  // Badminton Racquet And Sh..Paw Prints
    {0x1f440, 0x1f440},  // Eyes                    ..Eyes
    {0x1f442, 0x1f4fc},  // Ear                     ..Videocassette
    {0x1f4ff, 0x1f53d},  // Prayer Beads            ..Down-pointing Small Red
    {0x1f54b, 0x1f54e},  // Kaaba                   ..Men||ah With Nine Branch
    {0x1f550, 0x1f567},  // Clock Face One Oclock   ..Clock Face Twelve-thirty
    {0x1f57a, 0x1f57a},  // (nil)                   ..
    {0x1f595, 0x1f596},  // Reversed Hand With Middl..Raised Hand With Part Be
    {0x1f5a4, 0x1f5a4},  // (nil)                   ..
    {0x1f5fb, 0x1f64f},  // Mount Fuji              ..Person With Folded Hands
    {0x1f680, 0x1f6c5},  // Rocket                  ..Left Luggage
    {0x1f6cc, 0x1f6cc},  // Sleeping Accommodation  ..Sleeping Accommodation
    {0x1f6d0, 0x1f6d2},  // Place Of W||ship        ..
    {0x1f6eb, 0x1f6ec},  // Airplane Departure      ..Airplane Arriving
    {0x1f6f4, 0x1f6f6},  // (nil)                   ..
    {0x1f910, 0x1f91e},  // Zipper-mouth Face       ..
    {0x1f920, 0x1f927},  // (nil)                   ..
    {0x1f930, 0x1f930},  // (nil)                   ..
    {0x1f933, 0x1f93e},  // (nil)                   ..
    {0x1f940, 0x1f94b},  // (nil)                   ..
    {0x1f950, 0x1f95e},  // (nil)                   ..
    {0x1f980, 0x1f991},  // Crab                    ..
    {0x1f9c0, 0x1f9c0},  // Cheese Wedge            ..Cheese Wedge
    {0x20000, 0x2fffd},  // Cjk Unified Ideograph-20..
    {0x30000, 0x3fffd},  // (nil)                   ..
  };


  private static boolean intable(int[][] table, int c) {
    // First quick check f|| Latin1 etc. characters.
    if (c < table[0][0]) return false;

    // Binary search in table.
    int bot = 0;
    int top = table.length - 1; // (int)(size / sizeof(struct interval) - 1);
    while (top >= bot) {
      int mid = (bot + top) / 2;
      if (table[mid][1] < c) {
        bot = mid + 1;
      } else if (table[mid][0] > c) {
        top = mid - 1;
      } else {
        return true;
      }
    }
    return false;
  }

  /**
   * Return the terminal display width of a code point: 0, 1 || 2.
   */
  public static int width(int ucs) {
    if (ucs == 0 ||
      ucs == 0x034F ||
      (0x200B <= ucs && ucs <= 0x200F) ||
      ucs == 0x2028 ||
      ucs == 0x2029 ||
      (0x202A <= ucs && ucs <= 0x202E) ||
      (0x2060 <= ucs && ucs <= 0x2063)) {
      return 0;
    }

    // C0/C1 control characters
    // Termux change: Return 0 instead of -1.
    if (ucs < 32 || (0x07F <= ucs && ucs < 0x0A0)) return 0;

    // combining characters with zero width
    if (intable(ZERO_WIDTH, ucs)) return 0;

    return intable(WIDE_EASTASIAN, ucs) ? 2 : 1;
  }

  /**
   * The width at an index position in a java char array.
   */
  public static int width(char[] chars, int index) {
    char c = chars[index];
    return Character.isHighSurrogate(c) ? width(Character.toCodePoint(c, chars[index + 1])) : width(c);
  }

}

```

`app/src/main/java/io/neoterm/component/codegen/comp.kt`:

```kt
package io.neoterm.component.codegen

import io.neoterm.component.NeoComponent


class CodeGenComponent : NeoComponent {
  override fun onServiceInit() {
  }

  override fun onServiceDestroy() {
  }

  override fun onServiceObtained() {
  }

  fun newGenerator(codeObject: CodeGenObject): CodeGenerator {
    val parameter = CodeGenParameter()
    return codeObject.getCodeGenerator(parameter)
  }
}

class CodeGenParameter

```

`app/src/main/java/io/neoterm/component/codegen/generators.kt`:

```kt
package io.neoterm.component.codegen

import io.neoterm.component.ComponentManager
import io.neoterm.component.colorscheme.NeoColorScheme
import io.neoterm.component.config.ConfigureComponent

class NeoColorGenerator(parameter: CodeGenParameter) : CodeGenerator(parameter) {
  override fun getGeneratorName(): String {
    return "NeoColorScheme-Generator"
  }

  override fun generateCode(codeGenObject: CodeGenObject): String {
    if (codeGenObject !is NeoColorScheme) {
      throw RuntimeException("Invalid object type, expected NeoColorScheme, got ${codeGenObject.javaClass.simpleName}")
    }

    return buildString {
      start(this)
      generateMetaData(this, codeGenObject)
      generateColors(this, codeGenObject)
      end(this)
    }
  }

  private fun start(builder: StringBuilder) {
    builder.append("${NeoColorScheme.CONTEXT_META_NAME}: {\n")
  }

  private fun end(builder: StringBuilder) {
    builder.append("}\n")
  }

  private fun generateMetaData(builder: StringBuilder, colorScheme: NeoColorScheme) {
    val component = ComponentManager.getComponent<ConfigureComponent>()

    builder.append("    ${NeoColorScheme.COLOR_META_NAME}: \"${colorScheme.colorName}\"\n")
    builder.append(
      "    ${NeoColorScheme.COLOR_META_VERSION}: ${
        colorScheme.colorVersion
          ?: component.getLoaderVersion()
      }\n",
    )
    builder.append("\n")
  }

  private fun generateColors(builder: StringBuilder, colorScheme: NeoColorScheme) {
    builder.append("    ${NeoColorScheme.CONTEXT_COLOR_NAME}: {\n")

    builder.append("        ${NeoColorScheme.COLOR_DEF_BACKGROUND}: ${colorScheme.backgroundColor}\n")
    builder.append("        ${NeoColorScheme.COLOR_DEF_FOREGROUND}: ${colorScheme.foregroundColor}\n")
    builder.append("        ${NeoColorScheme.COLOR_DEF_CURSOR}: ${colorScheme.cursorColor}\n")
    colorScheme.color.entries.forEach {
      builder.append("        ${NeoColorScheme.COLOR_PREFIX}${it.key}: ${it.value}\n")
    }

    builder.append("    }\n")
  }
}

class NeoProfileGenerator(parameter: CodeGenParameter) : CodeGenerator(parameter) {
  override fun getGeneratorName(): String {
    return "NeoProfile-Generator"
  }

  override fun generateCode(codeGenObject: CodeGenObject): String {
    return ""
  }
}

```

`app/src/main/java/io/neoterm/component/codegen/interfaces.kt`:

```kt
package io.neoterm.component.codegen

abstract class CodeGenerator(parameter: CodeGenParameter) {
  abstract fun getGeneratorName(): String
  abstract fun generateCode(codeGenObject: CodeGenObject): String
}

interface CodeGenObject {
  fun getCodeGenerator(parameter: CodeGenParameter): CodeGenerator
}

```

`app/src/main/java/io/neoterm/component/colorscheme/comp.kt`:

```kt
package io.neoterm.component.colorscheme

import android.content.Context
import io.neolang.frontend.ConfigVisitor
import io.neoterm.App
import io.neoterm.R
import io.neoterm.component.ComponentManager
import io.neoterm.component.ConfigFileBasedComponent
import io.neoterm.component.codegen.CodeGenComponent
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.config.NeoTermPath
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import io.neoterm.utils.extractAssetsDir
import java.io.File
import java.nio.file.Files

class ColorSchemeComponent : ConfigFileBasedComponent<NeoColorScheme>(NeoTermPath.COLORS_PATH) {
  companion object {
    fun colorFile(colorName: String): File {
      return File("${NeoTermPath.COLORS_PATH}/$colorName.nl")
    }
  }

  override val checkComponentFileWhenObtained
    get() = true

  private lateinit var DEFAULT_COLOR: NeoColorScheme
  private var colors: MutableMap<String, NeoColorScheme> = mutableMapOf()

  override fun onCheckComponentFiles() {
    val defaultColorFile = colorFile(DefaultColorScheme.colorName)
    if (!defaultColorFile.exists()) {
      if (!extractDefaultColor(App.get())) {
        DEFAULT_COLOR = DefaultColorScheme
        colors[DEFAULT_COLOR.colorName] = DEFAULT_COLOR
        return
      }
    }

    if (!reloadColorSchemes()) {
      DEFAULT_COLOR = DefaultColorScheme
      colors[DEFAULT_COLOR.colorName] = DEFAULT_COLOR
    }
  }

  override fun onCreateComponentObject(configVisitor: ConfigVisitor) = NeoColorScheme()

  fun reloadColorSchemes(): Boolean {
    colors.clear()

    File(baseDir)
      .listFiles(NEOLANG_FILTER)
      .mapNotNull { this.loadConfigure(it) }
      .forEach {
        colors.put(it.colorName, it)
      }

    if (colors.containsKey(DefaultColorScheme.colorName)) {
      DEFAULT_COLOR = colors[DefaultColorScheme.colorName]!!
      return true
    }
    return false
  }

  fun applyColorScheme(view: TerminalView?, extraKeysView: ExtraKeysView?, colorScheme: NeoColorScheme?) {
    colorScheme?.applyColorScheme(view, extraKeysView)
  }

  fun getCurrentColorScheme(): NeoColorScheme {
    return colors[getCurrentColorSchemeName()]!!
  }

  fun getCurrentColorSchemeName(): String {
    var currentColorName =
      NeoPreference.loadString(R.string.key_customization_color_scheme, DefaultColorScheme.colorName)
    if (!colors.containsKey(currentColorName)) {
      currentColorName = DefaultColorScheme.colorName
      NeoPreference.store(R.string.key_customization_color_scheme, DefaultColorScheme.colorName)
    }
    return currentColorName
  }

  fun getColorScheme(colorName: String): NeoColorScheme {
    return if (colors.containsKey(colorName)) colors[colorName]!! else getCurrentColorScheme()
  }

  fun getColorSchemeNames(): List<String> {
    val list = ArrayList<String>()
    list += colors.keys
    return list
  }

  fun setCurrentColorScheme(colorName: String) {
    NeoPreference.store(R.string.key_customization_color_scheme, colorName)
  }

  fun setCurrentColorScheme(color: NeoColorScheme) {
    setCurrentColorScheme(color.colorName)
  }

  private fun extractDefaultColor(context: Context) =
    kotlin.runCatching { context.extractAssetsDir("colors", baseDir) }.isSuccess

  fun saveColorScheme(colorScheme: NeoColorScheme) {
    val colorFile = colorFile(colorScheme.colorName)
    if (colorFile.exists()) {
      throw RuntimeException("ColorScheme already ${colorScheme.colorName} exists!")
    }

    val component = ComponentManager.getComponent<CodeGenComponent>()
    val content = component.newGenerator(colorScheme).generateCode(colorScheme)

    kotlin.runCatching {
      Files.write(colorFile.toPath(), content.toByteArray())
    }.onFailure {
      throw RuntimeException("Failed to save file ${colorFile.absolutePath}")
    }
  }
}


```

`app/src/main/java/io/neoterm/component/colorscheme/data.kt`:

```kt
package io.neoterm.component.colorscheme

import io.neolang.frontend.ConfigVisitor
import io.neoterm.backend.TerminalColorScheme
import io.neoterm.backend.TerminalColors
import io.neoterm.component.ConfigFileBasedObject
import io.neoterm.component.codegen.CodeGenObject
import io.neoterm.component.codegen.CodeGenParameter
import io.neoterm.component.codegen.CodeGenerator
import io.neoterm.component.codegen.NeoColorGenerator
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import io.neoterm.utils.NLog

open class NeoColorScheme : CodeGenObject, ConfigFileBasedObject {
  companion object {
    const val COLOR_PREFIX = "color"
    const val CONTEXT_COLOR_NAME = "colors"
    const val CONTEXT_META_NAME = "color-scheme"

    const val COLOR_META_NAME = "name"
    const val COLOR_META_VERSION = "version"
    const val COLOR_DEF_BACKGROUND = "background"
    const val COLOR_DEF_FOREGROUND = "foreground"
    const val COLOR_DEF_CURSOR = "cursor"

    val COLOR_META_PATH = arrayOf(CONTEXT_META_NAME)
    val COLOR_PATH = arrayOf(CONTEXT_META_NAME, CONTEXT_COLOR_NAME)

    const val COLOR_TYPE_BEGIN = -3
    const val COLOR_TYPE_END = 15

    const val COLOR_BACKGROUND = -3
    const val COLOR_FOREGROUND = -2
    const val COLOR_CURSOR = -1

    const val COLOR_DIM_BLACK = 0
    const val COLOR_DIM_RED = 1
    const val COLOR_DIM_GREEN = 2
    const val COLOR_DIM_YELLOW = 3
    const val COLOR_DIM_BLUE = 4
    const val COLOR_DIM_MAGENTA = 5
    const val COLOR_DIM_CYAN = 6
    const val COLOR_DIM_WHITE = 7

    const val COLOR_BRIGHT_BLACK = 8
    const val COLOR_BRIGHT_RED = 9
    const val COLOR_BRIGHT_GREEN = 10
    const val COLOR_BRIGHT_YELLOW = 11
    const val COLOR_BRIGHT_BLUE = 12
    const val COLOR_BRIGHT_MAGENTA = 13
    const val COLOR_BRIGHT_CYAN = 14
    const val COLOR_BRIGHT_WHITE = 15
  }

  lateinit var colorName: String
  var colorVersion: String? = null

  var foregroundColor: String? = null
  var backgroundColor: String? = null
  var cursorColor: String? = null
  var color: MutableMap<Int, String> = mutableMapOf()

  fun setColor(type: Int, color: String) {
    if (type < 0) {
      when (type) {
        COLOR_BACKGROUND -> backgroundColor = color
        COLOR_FOREGROUND -> foregroundColor = color
        COLOR_CURSOR -> cursorColor = color
      }
      return
    }
    this.color[type] = color
  }

  fun getColor(type: Int): String? {
    validateColors()
    return when (type) {
      COLOR_BACKGROUND -> backgroundColor
      COLOR_FOREGROUND -> foregroundColor
      COLOR_CURSOR -> cursorColor
      else -> {
        if (type in (0 until color.size)) {
          color[type]
        } else {
          ""
        }
      }
    }
  }

  fun copy(): NeoColorScheme {
    val copy = NeoColorScheme()
    copy.colorName = colorName
    copy.backgroundColor = backgroundColor
    copy.foregroundColor = foregroundColor
    copy.cursorColor = cursorColor
    this.color.forEach { copy.color.put(it.key, it.value) }
    return copy
  }

  @Throws(RuntimeException::class)
  override fun onConfigLoaded(configVisitor: ConfigVisitor) {
    val colorName = getMetaByVisitor(configVisitor, COLOR_META_NAME)
      ?: throw RuntimeException("ColorScheme must have a name")

    this.colorName = colorName
    this.colorVersion = getMetaByVisitor(configVisitor, COLOR_META_VERSION)

    backgroundColor = getColorByVisitor(configVisitor, "background")
    foregroundColor = getColorByVisitor(configVisitor, "foreground")
    cursorColor = getColorByVisitor(configVisitor, "cursor")
    configVisitor.getContext(COLOR_PATH).getAttributes().forEach {
      if (it.key.startsWith(COLOR_PREFIX)) {
        val colorIndex = try {
          it.key.substringAfter(COLOR_PREFIX).toInt()
        } catch (e: Exception) {
          -1
        }

        if (colorIndex == -1) {
          NLog.w("ColorScheme", "Invalid color type: ${it.key}")
        } else {
          setColor(colorIndex, it.value.asString())
        }
      }
    }

    validateColors()
  }

  internal fun applyColorScheme(view: TerminalView?, extraKeysView: ExtraKeysView?) {
    validateColors()

    if (view != null) {
      val scheme = TerminalColorScheme()
      scheme.updateWith(foregroundColor, backgroundColor, cursorColor, color)
      val session = view.currentSession
      if (session != null && session.emulator != null) {
        session.emulator.setColorScheme(scheme)
      }
      view.setBackgroundColor(TerminalColors.parse(backgroundColor))
    }

    if (extraKeysView != null) {
      extraKeysView.setBackgroundColor(TerminalColors.parse(backgroundColor))
      extraKeysView.setTextColor(TerminalColors.parse(foregroundColor))
    }
  }

  override fun getCodeGenerator(parameter: CodeGenParameter): CodeGenerator {
    return NeoColorGenerator(parameter)
  }

  private fun validateColors() {
    backgroundColor = backgroundColor ?: DefaultColorScheme.backgroundColor
    foregroundColor = foregroundColor ?: DefaultColorScheme.foregroundColor
    cursorColor = cursorColor ?: DefaultColorScheme.cursorColor
  }

  private fun getMetaByVisitor(visitor: ConfigVisitor, metaName: String): String? {
    return visitor.getStringValue(COLOR_META_PATH, metaName)
  }

  private fun getColorByVisitor(visitor: ConfigVisitor, colorName: String): String? {
    return visitor.getStringValue(COLOR_PATH, colorName)
  }
}

object DefaultColorScheme : NeoColorScheme() {
  init {
    /* NOTE: Keep in sync with assets/colors/Default.nl */
    colorName = "Default"

    foregroundColor = "#ffffff"
    backgroundColor = "#14181c"
    cursorColor = "#a9aaa9"
  }
}

```

`app/src/main/java/io/neoterm/component/comp.kt`:

```kt
package io.neoterm.component

import android.content.Context
import io.neoterm.component.codegen.CodeGenComponent
import io.neoterm.component.colorscheme.ColorSchemeComponent
import io.neoterm.component.completion.CompletionComponent
import io.neoterm.component.config.ConfigureComponent
import io.neoterm.component.extrakey.ExtraKeyComponent
import io.neoterm.component.font.FontComponent
import io.neoterm.component.pm.PackageComponent
import io.neoterm.component.profile.ProfileComponent
import io.neoterm.component.session.SessionComponent
import io.neoterm.component.session.ShellProfile
import io.neoterm.component.userscript.UserScriptComponent
import io.neoterm.utils.NLog
import java.util.concurrent.ConcurrentHashMap

interface NeoComponent {
  fun onServiceInit()
  fun onServiceDestroy()
  fun onServiceObtained()
}

object ComponentManager {
  private val COMPONENTS = ConcurrentHashMap<Class<out NeoComponent>, NeoComponent>()

  fun registerComponent(componentClass: Class<out NeoComponent>) {
    if (COMPONENTS.containsKey(componentClass)) {
      throw ComponentDuplicateException(componentClass.simpleName)
    }
    val component = createServiceInstance(componentClass)
    COMPONENTS.put(componentClass, component)
    component.onServiceInit()
  }

  fun unregisterComponent(componentInterface: Class<out NeoComponent>) {
    val component = COMPONENTS[componentInterface]
    if (component != null) {
      component.onServiceDestroy()
      COMPONENTS.remove(componentInterface)
    }
  }

  @Suppress("UNCHECKED_CAST")
  fun <T : NeoComponent> getComponent(componentInterface: Class<T>, errorThrow: Boolean = true): T {
    val component: NeoComponent =
      COMPONENTS[componentInterface] ?: throw ComponentNotFoundException(componentInterface.simpleName)

    component.onServiceObtained()
    return component as T
  }

  inline fun <reified T : NeoComponent> getComponent(): T {
    val componentInterface = T::class.java
    return getComponent(componentInterface);
  }

  private fun createServiceInstance(componentInterface: Class<out NeoComponent>): NeoComponent {
    return componentInterface.newInstance()
  }
}

class ComponentDuplicateException(serviceName: String) : RuntimeException("Service $serviceName duplicate")
class ComponentNotFoundException(serviceName: String) : RuntimeException("Component `$serviceName' not found")

/**
 * @author kiva
 */
object NeoInitializer {
  fun init(context: Context) {
    NLog.init(context)
    initComponents()
  }

  fun initComponents() {
    ComponentManager.registerComponent(ConfigureComponent::class.java)
    ComponentManager.registerComponent(CodeGenComponent::class.java)
    ComponentManager.registerComponent(ColorSchemeComponent::class.java)
    ComponentManager.registerComponent(FontComponent::class.java)
    ComponentManager.registerComponent(UserScriptComponent::class.java)
    ComponentManager.registerComponent(ExtraKeyComponent::class.java)
    ComponentManager.registerComponent(CompletionComponent::class.java)
    ComponentManager.registerComponent(PackageComponent::class.java)
    ComponentManager.registerComponent(SessionComponent::class.java)
    ComponentManager.registerComponent(ProfileComponent::class.java)

    val profileComp = ComponentManager.getComponent<ProfileComponent>()
    profileComp.registerProfile(ShellProfile.PROFILE_META_NAME, ShellProfile::class.java)
  }
}

```

`app/src/main/java/io/neoterm/component/completion/comp.kt`:

```kt
package io.neoterm.component.completion

import io.neoterm.component.NeoComponent

class CompletionComponent : NeoComponent {
  override fun onServiceInit() {
    CompletionManager.registerProvider(FileCompletionProvider())
    CompletionManager.registerProvider(ProgramCompletionProvider())
  }

  override fun onServiceDestroy() {
  }

  override fun onServiceObtained() {
  }
}

object CompletionManager {
  private val candidateProviders = mutableMapOf<String, ICandidateProvider>()

  fun registerProvider(provider: ICandidateProvider) {
    this.candidateProviders[provider.providerName] = provider
  }

  fun unregisterProvider(providerName: String) {
    this.candidateProviders.remove(providerName)
  }

  fun unregisterProvider(provider: ICandidateProvider) {
    unregisterProvider(provider.providerName)
  }

  fun getProvider(providerName: String): ICandidateProvider? {
    return candidateProviders[providerName]
  }

  fun tryCompleteFor(text: String): CompletionResult {
    val detector = detectProviders(text)
    val provider = detector.detectBest()

    val candidates = provider?.provideCandidates(text) ?: listOf()
    return CompletionResult(candidates, detector)
  }

  private fun detectProviders(text: String): ProviderDetector {
    return ProviderDetector(candidateProviders.values
      .takeWhile { it.canComplete(text) })
  }
}

class ProviderDetector(val providers: List<ICandidateProvider>) : MarkScoreListener {
  private var detectedProvider: ICandidateProvider? = null

  override fun onMarkScore(score: Int) {
    // TODO: Save provider score
  }

  fun detectBest(): ICandidateProvider? {
    // TODO: detect best
    detectedProvider = if (providers.isEmpty())
      null
    else
      providers[0]

    return detectedProvider
  }
}


```

`app/src/main/java/io/neoterm/component/completion/data.kt`:

```kt
package io.neoterm.component.completion

class CompletionCandidate(val completeString: String) {
  var displayName: String = completeString
  var description: String? = null
}

class CompletionResult(val candidates: List<CompletionCandidate>, var scoreMarker: MarkScoreListener) {
  fun markScore(score: Int) {
    scoreMarker.onMarkScore(score)
  }

  fun hasResult(): Boolean {
    return candidates.isNotEmpty()
  }
}


```

`app/src/main/java/io/neoterm/component/completion/listeners.kt`:

```kt
package io.neoterm.component.completion

interface MarkScoreListener {
  fun onMarkScore(score: Int)
}

interface OnAutoCompleteListener {
  fun onCompletionRequired(newText: String?)
  fun onKeyCode(keyCode: Int, keyMod: Int)
  fun onCleanUp()
  fun onFinishCompletion(): Boolean
}

interface OnCandidateSelectedListener {
  fun onCandidateSelected(candidate: CompletionCandidate)
}

```

`app/src/main/java/io/neoterm/component/completion/providers.kt`:

```kt
package io.neoterm.component.completion

import java.io.File

interface ICandidateProvider {
  val providerName: String
  fun provideCandidates(text: String): List<CompletionCandidate>
  fun canComplete(text: String): Boolean
}

open class FileCompletionProvider : ICandidateProvider {
  override val providerName: String
    get() = "NeoTermProvider.FileCompletionProvider"

  override fun provideCandidates(text: String): List<CompletionCandidate> {
    var file = File(text)
    var filter: ((File) -> Boolean)? = null

    if (!file.isDirectory) {
      val partName = file.name
      file = file.parentFile
      filter = { pathname -> pathname.name.startsWith(partName) }
    }

    return generateCandidateList(file, filter)
  }

  override fun canComplete(text: String): Boolean {
    return text.startsWith(File.separatorChar) || text.startsWith("\\./")
  }

  private fun listDirectory(path: File, filter: ((File) -> Boolean)?): Array<File> {
    return if (filter != null) path.listFiles(filter) else path.listFiles()
  }

  private fun generateCandidateList(file: File, filter: ((File) -> Boolean)?) =
    if (file.canRead()) listDirectory(file, filter).map {
      val candidate = CompletionCandidate(it.name)
      candidate.description = generateDesc(it)
      candidate.displayName = generateDisplayName(it)
      candidate
    }.toList()
    else listOf()

  open fun generateDisplayName(file: File): String {
    return if (file.isDirectory) "${file.name}/" else file.name
  }

  open fun generateDesc(file: File): String? {
    return null
  }
}

class ProgramCompletionProvider : FileCompletionProvider() {
  override val providerName: String
    get() = "NeoTermProvider.ProgramCompletionProvider"


  override fun generateDesc(file: File): String? {
    return if (file.canExecute()) "<Program>" else super.generateDesc(file)
  }
}

```

`app/src/main/java/io/neoterm/component/config/comp.kt`:

```kt
package io.neoterm.component.config

import android.content.Context
import android.content.SharedPreferences
import android.preference.PreferenceManager
import android.system.ErrnoException
import android.system.Os
import android.util.TypedValue
import io.neolang.frontend.ConfigVisitor
import io.neolang.frontend.NeoLangParser
import io.neoterm.App
import io.neoterm.R
import io.neoterm.backend.TerminalSession
import io.neoterm.component.NeoComponent
import io.neoterm.services.NeoTermService
import io.neoterm.utils.NLog
import java.io.File
import java.nio.file.Files

class ConfigureComponent : NeoComponent {
  override fun onServiceInit() {
  }

  override fun onServiceDestroy() {
  }

  override fun onServiceObtained() {
  }

  fun getLoaderVersion(): Int {
    return CONFIG_LOADER_VERSION
  }

  fun newLoader(configFile: File): IConfigureLoader {
    return when (configFile.extension) {
      "nl" -> NeoLangConfigureLoader(configFile)
      else -> OldConfigureLoader(configFile)
    }
  }

  companion object {
    private const val CONFIG_LOADER_VERSION = 20
  }
}

open class NeoConfigureFile(val configureFile: File) {
  private val configParser = NeoLangParser()
  protected open var configVisitor: ConfigVisitor? = null

  fun getVisitor() = configVisitor ?: throw IllegalStateException("Configure file not loaded or parse failed.")

  open fun parseConfigure() = kotlin.runCatching {
    val programCode = String(Files.readAllBytes(configureFile.toPath()))
    configParser.setInputSource(programCode)

    val ast = configParser.parse()
    val astVisitor = ast.visit().getVisitor(ConfigVisitor::class.java) ?: return false
    astVisitor.start()
    configVisitor = astVisitor.getCallback()
  }.isSuccess
}

object NeoPreference {
  const val KEY_HAPPY_EGG = "neoterm_fun_happy"
  const val KEY_FONT_SIZE = "neoterm_general_font_size"
  const val KEY_CURRENT_SESSION = "neoterm_service_current_session"
  const val KEY_SYSTEM_SHELL = "neoterm_core_system_shell"
  const val KEY_SOURCES = "neoterm_package_enabled_sources"

  const val VALUE_HAPPY_EGG_TRIGGER = 8

  var MIN_FONT_SIZE: Int = 0
    private set
  var MAX_FONT_SIZE: Int = 0
    private set

  private var preference: SharedPreferences? = null

  fun init(context: Context) {
    preference = PreferenceManager.getDefaultSharedPreferences(context)

    // This is a bit arbitrary and sub-optimal. We want to give a sensible default for minimum font size
    // to prevent invisible text due to zoom be mistake:
    val dipInPixels = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1f, context.resources.displayMetrics)
    MIN_FONT_SIZE = (4f * dipInPixels).toInt()
    MAX_FONT_SIZE = 256

    // load apt source
    val sourceFile = File(NeoTermPath.SOURCE_FILE)
    kotlin.runCatching {
      Files.readAllBytes(sourceFile.toPath())?.let {
        val source = String(it).trim().trimEnd()
        val array = source.split(" ")
        if (array.size >= 2 && array[0] == "deb") {
          store(R.string.key_package_source, array[1])
        }
      }
    }
  }

  fun store(key: Int, value: Any) {
    store(App.get().getString(key), value)
  }

  fun store(key: String, value: Any) {
    when (value) {
      is Int -> preference!!.edit().putInt(key, value).apply()
      is String -> preference!!.edit().putString(key, value).apply()
      is Boolean -> preference!!.edit().putBoolean(key, value).apply()
    }
  }

  fun loadInt(key: Int, defaultValue: Int): Int {
    return loadInt(App.get().getString(key), defaultValue)
  }

  fun loadString(key: Int, defaultValue: String?): String {
    return loadString(App.get().getString(key), defaultValue)
  }

  fun loadBoolean(key: Int, defaultValue: Boolean): Boolean {
    return loadBoolean(App.get().getString(key), defaultValue)
  }

  fun loadInt(key: String?, defaultValue: Int): Int {
    return preference!!.getInt(key, defaultValue)
  }

  fun loadString(key: String?, defaultValue: String?): String {
    return preference!!.getString(key, defaultValue)
  }

  fun loadBoolean(key: String?, defaultValue: Boolean): Boolean {
    return preference!!.getBoolean(key, defaultValue)
  }

  fun storeCurrentSession(session: TerminalSession) {
    preference!!.edit()
      .putString(KEY_CURRENT_SESSION, session.mHandle)
      .apply()
  }

  fun getCurrentSession(termService: NeoTermService?): TerminalSession? {
    val sessionHandle = PreferenceManager.getDefaultSharedPreferences(termService!!)
      .getString(KEY_CURRENT_SESSION, "")

    return termService.sessions
      .singleOrNull { it.mHandle == sessionHandle }
  }

  fun setLoginShellName(loginProgramName: String?): Boolean {
    if (loginProgramName == null) {
      return false
    }

    val loginProgramPath = findLoginProgram(loginProgramName) ?: return false

    store(R.string.key_general_shell, loginProgramName)
    symlinkLoginShell(loginProgramPath)
    return true
  }

  fun getLoginShellName(): String {
    return loadString(R.string.key_general_shell, DefaultValues.loginShell)
  }

  fun getLoginShellPath(): String {
    val loginProgramName = getLoginShellName()

    // Some programs like ssh needs it
    val shell = File(NeoTermPath.NEOTERM_LOGIN_SHELL_PATH)
    val loginProgramPath = findLoginProgram(loginProgramName) ?: {
      setLoginShellName(DefaultValues.loginShell)
      "${NeoTermPath.USR_PATH}/bin/${DefaultValues.loginShell}"
    }()

    if (!shell.exists()) {
      symlinkLoginShell(loginProgramPath)
    }

    return loginProgramPath
  }

  fun validateFontSize(fontSize: Int): Int {
    return Math.max(MIN_FONT_SIZE, Math.min(fontSize, MAX_FONT_SIZE))
  }

  private fun symlinkLoginShell(loginProgramPath: String) {
    File(NeoTermPath.CUSTOM_PATH).mkdirs()
    try {
      val shellSymlink = File(NeoTermPath.NEOTERM_LOGIN_SHELL_PATH)
      if (shellSymlink.exists()) {
        shellSymlink.delete()
      }
      Os.symlink(loginProgramPath, NeoTermPath.NEOTERM_LOGIN_SHELL_PATH)
      Os.chmod(NeoTermPath.NEOTERM_LOGIN_SHELL_PATH, 448 /* Decimal of 0700 */)
    } catch (e: ErrnoException) {
      NLog.e("Preference", "Failed to symlink login shell: ${e.localizedMessage}")
      e.printStackTrace()
    }
  }

  fun findLoginProgram(loginProgramName: String): String? {
    val file = File("${NeoTermPath.USR_PATH}/bin", loginProgramName)
    return if (file.canExecute()) file.absolutePath else null
  }

  fun getFontSize(): Int {
    return loadInt(
      KEY_FONT_SIZE,
      DefaultValues.fontSize
    )
  }

  fun getInitialCommand(): String {
    return loadString(
      R.string.key_general_initial_command,
      DefaultValues.initialCommand
    )
  }

  fun isBellEnabled(): Boolean {
    return loadBoolean(
      R.string.key_general_bell,
      DefaultValues.enableBell
    )
  }

  fun isVibrateEnabled(): Boolean {
    return loadBoolean(
      R.string.key_general_vibrate,
      DefaultValues.enableVibrate
    )
  }

  fun isExecveWrapperEnabled(): Boolean {
    return loadBoolean(
      R.string.key_general_use_execve_wrapper,
      DefaultValues.enableExecveWrapper
    )
  }

  fun isSpecialVolumeKeysEnabled(): Boolean {
    return loadBoolean(
      R.string.key_general_volume_as_control,
      DefaultValues.enableSpecialVolumeKeys
    )
  }

  fun isAutoCompletionEnabled(): Boolean {
    return loadBoolean(
      R.string.key_general_auto_completion,
      DefaultValues.enableAutoCompletion
    )
  }

  fun isBackButtonBeMappedToEscapeEnabled(): Boolean {
    return loadBoolean(
      R.string.key_generaL_backspace_map_to_esc,
      DefaultValues.enableBackButtonBeMappedToEscape
    )
  }

  fun isExtraKeysEnabled(): Boolean {
    return loadBoolean(
      R.string.key_ui_eks_enabled,
      DefaultValues.enableExtraKeys
    )
  }

  fun isExplicitExtraKeysWeightEnabled(): Boolean {
    return loadBoolean(
      R.string.key_ui_eks_weight_explicit,
      DefaultValues.enableExplicitExtraKeysWeight
    )
  }

  fun isFullScreenEnabled(): Boolean {
    return loadBoolean(
      R.string.key_ui_fullscreen,
      DefaultValues.enableFullScreen
    )
  }

  fun isHideToolbarEnabled(): Boolean {
    return loadBoolean(
      R.string.key_ui_hide_toolbar,
      DefaultValues.enableAutoHideToolbar
    )
  }

  fun isNextTabEnabled(): Boolean {
    return loadBoolean(
      R.string.key_ui_next_tab_anim,
      DefaultValues.enableSwitchNextTab
    )
  }

  fun isWordBasedImeEnabled(): Boolean {
    return loadBoolean(
      R.string.key_general_enable_word_based_ime,
      DefaultValues.enableWordBasedIme
    )
  }

  /**
   * TODO
   * To print the job name about to be executed in bash:
   * $ trap 'echo -ne "\e]0;${BASH_COMMAND%% *}\x07"' DEBUG
   * $ PS1='$(echo -ne "\e]0;$PWD\x07")\$ '
   */
}

```

`app/src/main/java/io/neoterm/component/config/defaults.kt`:

```kt
package io.neoterm.component.config

import android.annotation.SuppressLint

object DefaultValues {
  const val fontSize = 30

  const val enableBell = false
  const val enableVibrate = false
  const val enableExecveWrapper = true
  const val enableAutoCompletion = false
  const val enableFullScreen = false
  const val enableAutoHideToolbar = false
  const val enableSwitchNextTab = false
  const val enableExtraKeys = true
  const val enableExplicitExtraKeysWeight = false
  const val enableBackButtonBeMappedToEscape = false
  const val enableSpecialVolumeKeys = false
  const val enableWordBasedIme = false

  const val loginShell = "bash"
  const val initialCommand = ""
  const val defaultFont = "SourceCodePro"
}

object NeoTermPath {
  @SuppressLint("SdCardPath")
  const val ROOT_PATH = "/data/data/io.neoterm/files"
  const val USR_PATH = "$ROOT_PATH/usr"
  const val HOME_PATH = "$ROOT_PATH/home"
  const val APT_BIN_PATH = "$USR_PATH/bin/apt"
  const val LIB_PATH = "$USR_PATH/lib"

  const val CUSTOM_PATH = "$HOME_PATH/.neoterm"
  const val NEOTERM_LOGIN_SHELL_PATH = "$CUSTOM_PATH/shell"
  const val EKS_PATH = "$CUSTOM_PATH/eks"
  const val EKS_DEFAULT_FILE = "$EKS_PATH/default.nl"
  const val FONT_PATH = "$CUSTOM_PATH/font"
  const val COLORS_PATH = "$CUSTOM_PATH/color"
  const val USER_SCRIPT_PATH = "$CUSTOM_PATH/script"
  const val PROFILE_PATH = "$CUSTOM_PATH/profile"

  const val SOURCE_FILE = "$USR_PATH/etc/apt/sources.list"
  const val PACKAGE_LIST_DIR = "$USR_PATH/var/lib/apt/lists"

  private const val SOURCE = "https://raw.githubusercontent.com/NeoTerm/NeoTerm-repo/main"

  val DEFAULT_MAIN_PACKAGE_SOURCE: String

  init {
    DEFAULT_MAIN_PACKAGE_SOURCE = SOURCE
  }
}

```

`app/src/main/java/io/neoterm/component/config/loaders.kt`:

```kt
package io.neoterm.component.config

import io.neolang.frontend.ConfigVisitor
import io.neolang.runtime.NeoLangValue
import io.neoterm.component.colorscheme.NeoColorScheme
import io.neoterm.component.extrakey.NeoExtraKey
import io.neoterm.frontend.session.view.extrakey.TextButton
import io.neoterm.utils.NLog
import java.io.BufferedReader
import java.io.File
import java.io.FileInputStream
import java.io.FileReader
import java.util.*

interface IConfigureLoader {
  fun loadConfigure(): NeoConfigureFile?
}

class NeoLangConfigureLoader(private val configFile: File) : IConfigureLoader {
  override fun loadConfigure(): NeoConfigureFile? {
    val configureFile = NeoConfigureFile(configFile)
    return if (configureFile.parseConfigure()) configureFile else null
  }
}

class OldConfigureLoader(private val configFile: File) : IConfigureLoader {
  override fun loadConfigure(): NeoConfigureFile? {
    return when (configFile.extension) {
      "eks" -> returnConfigure(OldExtraKeysConfigureFile(configFile))
      "color" -> returnConfigure(OldColorSchemeConfigureFile(configFile))
      else -> null
    }
  }

  private fun returnConfigure(configureFile: NeoConfigureFile): NeoConfigureFile? {
    return if (configureFile.parseConfigure()) configureFile else null
  }

  companion object {
    class OldColorSchemeConfigureFile(configureFile: File) : NeoConfigureFile(configureFile) {
      override var configVisitor: ConfigVisitor? = null

      override fun parseConfigure(): Boolean {
        try {
          val visitor = ConfigVisitor()
          visitor.onStart()
          visitor.onEnterContext(NeoColorScheme.CONTEXT_META_NAME)

          visitor.getCurrentContext()
            .defineAttribute(NeoColorScheme.COLOR_META_NAME, NeoLangValue(configureFile.nameWithoutExtension))
            .defineAttribute(NeoColorScheme.COLOR_META_VERSION, NeoLangValue("1.0"))

          visitor.onEnterContext(NeoColorScheme.CONTEXT_COLOR_NAME)

          return FileInputStream(configureFile).use {
            val prop = Properties()
            prop.load(it)
            prop.forEach {
              visitor.getCurrentContext().defineAttribute(it.key as String, NeoLangValue(it.value as String))
            }
            visitor.onFinish()
            this.configVisitor = visitor
            true
          }

        } catch (e: Exception) {
          this.configVisitor = null
          NLog.e("ConfigureLoader", "Error while loading old config", e)
          return false
        }
      }
    }
    class OldExtraKeysConfigureFile(configureFile: File) : NeoConfigureFile(configureFile) {
      override var configVisitor: ConfigVisitor? = null

      override fun parseConfigure(): Boolean {
        try {
          val config = parseOldConfig(BufferedReader(FileReader(configureFile)))
          return generateVisitor(config)
        } catch (e: Exception) {
          NLog.e("ConfigureLoader", "Failed to load old extra keys config: ${e.localizedMessage}")
          return false
        }
      }

      private fun generateVisitor(config: NeoExtraKey): Boolean {
        configVisitor = ConfigVisitor()
        val visitor = configVisitor!!
        visitor.onStart()
        visitor.onEnterContext(NeoExtraKey.EKS_META_CONTEXT_NAME)
        visitor.getCurrentContext()
          .defineAttribute(NeoExtraKey.EKS_META_VERSION, NeoLangValue(config.version))
          .defineAttribute(NeoExtraKey.EKS_META_WITH_DEFAULT, NeoLangValue(config.withDefaultKeys))

        // program
        visitor.onEnterContext(NeoExtraKey.EKS_META_PROGRAM)
        config.programNames.forEachIndexed { index, program ->
          visitor.getCurrentContext().defineAttribute(index.toString(), NeoLangValue(program))
        }
        visitor.onExitContext()

        // key
        visitor.onEnterContext(NeoExtraKey.EKS_META_KEY)
        config.shortcutKeys.forEachIndexed { index, button ->
          if (button is TextButton) {
            visitor.onEnterContext(index.toString())
            visitor.getCurrentContext()
              .defineAttribute(NeoExtraKey.EKS_META_WITH_ENTER, NeoLangValue(button.withEnter))
              .defineAttribute(NeoExtraKey.EKS_META_DISPLAY, NeoLangValue(button.buttonKeys!!))
              .defineAttribute(NeoExtraKey.EKS_META_CODE, NeoLangValue(button.buttonKeys!!))
            visitor.onExitContext()
          }
        }
        visitor.onExitContext()

        visitor.onFinish()
        return true
      }

      private fun parseOldConfig(source: BufferedReader): NeoExtraKey {
        val config = NeoExtraKey()
        var line: String? = source.readLine()

        while (line != null) {
          line = line.trim().trimEnd()
          if (line.isEmpty() || line.startsWith("#")) {
            line = source.readLine()
            continue
          }

          if (line.startsWith(NeoExtraKey.EKS_META_VERSION)) {
            parseHeader(line, config)
          } else if (line.startsWith(NeoExtraKey.EKS_META_PROGRAM)) {
            parseProgram(line, config)
          } else if (line.startsWith("define")) {
            parseKeyDefine(line, config)
          } else if (line.startsWith(NeoExtraKey.EKS_META_WITH_DEFAULT)) {
            parseWithDefault(line, config)
          }
          line = source.readLine()
        }

        if (config.version < 0) {
          throw RuntimeException("Not a valid shortcut config file")
        }
        if (config.programNames.size == 0) {
          throw RuntimeException("At least one program name should be given")
        }
        return config
      }

      private fun parseWithDefault(line: String, config: NeoExtraKey) {
        val value = line.substring(NeoExtraKey.EKS_META_WITH_DEFAULT.length).trim().trimEnd()
        config.withDefaultKeys = value == "true"
      }

      private fun parseKeyDefine(line: String, config: NeoExtraKey) {
        val keyDefine = line.substring("define".length).trim().trimEnd()
        val keyValues = keyDefine.split(" ")
        if (keyValues.size < 2) {
          throw RuntimeException("Bad define")
        }

        val buttonText = keyValues[0]
        val withEnter = keyValues[1] == "true"

        config.shortcutKeys.add(TextButton(buttonText, withEnter))
      }

      private fun parseProgram(line: String, config: NeoExtraKey) {
        val programNames = line.substring(NeoExtraKey.EKS_META_PROGRAM.length).trim().trimEnd()
        if (programNames.isEmpty()) {
          return
        }

        for (name in programNames.split(" ")) {
          config.programNames.add(name)
        }
      }

      private fun parseHeader(line: String, config: NeoExtraKey) {
        val version: Int
        val versionString = line.substring(NeoExtraKey.EKS_META_VERSION.length).trim().trimEnd()
        try {
          version = Integer.parseInt(versionString)
        } catch (e: NumberFormatException) {
          throw RuntimeException("Bad version '$versionString'")
        }

        config.version = version
      }
    }
  }
}

```

`app/src/main/java/io/neoterm/component/data.kt`:

```kt
package io.neoterm.component

import io.neolang.frontend.ConfigVisitor
import io.neoterm.component.config.ConfigureComponent
import io.neoterm.utils.NLog
import java.io.File
import java.io.FileFilter

interface ConfigFileBasedObject {
  @Throws(RuntimeException::class)
  fun onConfigLoaded(configVisitor: ConfigVisitor)
}

abstract class ConfigFileBasedComponent<out T : ConfigFileBasedObject>(protected val baseDir: String) : NeoComponent {
  companion object {
    private val TAG = ConfigFileBasedComponent::class.java.simpleName

    val NEOLANG_FILTER = FileFilter {
      it.extension == "nl"
    }
  }

  open val checkComponentFileWhenObtained = false

  override fun onServiceInit() {
    val baseDirFile = File(this.baseDir)
    if (!baseDirFile.exists()) {
      if (!baseDirFile.mkdirs()) {
        throw RuntimeException("Cannot create component config directory: ${baseDirFile.absolutePath}")
      }
    }
    onCheckComponentFiles()
  }

  override fun onServiceDestroy() {
  }

  override fun onServiceObtained() {
    if (checkComponentFileWhenObtained) {
      onCheckComponentFiles()
    }
  }

  fun loadConfigure(file: File): T? {
    return try {
      val loaderService = ComponentManager.getComponent<ConfigureComponent>()
      val configure = loaderService.newLoader(file).loadConfigure()
        ?: throw RuntimeException("Parse configuration failed.")

      val configVisitor = configure.getVisitor()
      val componentObject = onCreateComponentObject(configVisitor)
      componentObject.onConfigLoaded(configVisitor)
      componentObject
    } catch (e: RuntimeException) {
      NLog.e(TAG, "Failed to load config: ${file.absolutePath}: ${e.localizedMessage}")
      null
    }
  }

  abstract fun onCheckComponentFiles()

  abstract fun onCreateComponentObject(configVisitor: ConfigVisitor): T
}


```

`app/src/main/java/io/neoterm/component/extrakey/comp.kt`:

```kt
package io.neoterm.component.extrakey

import android.content.Context
import io.neolang.frontend.ConfigVisitor
import io.neoterm.App
import io.neoterm.component.ConfigFileBasedComponent
import io.neoterm.component.config.NeoTermPath
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import io.neoterm.utils.NLog
import io.neoterm.utils.extractAssetsDir
import java.io.File

class ExtraKeyComponent : ConfigFileBasedComponent<NeoExtraKey>(NeoTermPath.EKS_PATH) {
  override val checkComponentFileWhenObtained
    get() = true

  private val extraKeys: MutableMap<String, NeoExtraKey> = mutableMapOf()

  override fun onCheckComponentFiles() {
    val defaultFile = File(NeoTermPath.EKS_DEFAULT_FILE)
    if (!defaultFile.exists()) {
      extractDefaultConfig(App.get())
    }
    reloadExtraKeyConfig()
  }

  override fun onCreateComponentObject(configVisitor: ConfigVisitor): NeoExtraKey {
    return NeoExtraKey()
  }

  fun showShortcutKeys(program: String, extraKeysView: ExtraKeysView?) {
    if (extraKeysView == null) {
      return
    }

    val extraKey = extraKeys[program]
    if (extraKey != null) {
      extraKey.applyExtraKeys(extraKeysView)
      return
    }

    extraKeysView.loadDefaultUserKeys()
  }

  private fun registerShortcutKeys(extraKey: NeoExtraKey) =
    extraKey.programNames.forEach {
      extraKeys[it] = extraKey
    }

  private fun extractDefaultConfig(context: Context) {
    try {
      context.extractAssetsDir("eks", baseDir)
    } catch (e: Exception) {
      NLog.e("ExtraKey", "Failed to extract configure: ${e.localizedMessage}")
    }
  }

  private fun reloadExtraKeyConfig() {
    extraKeys.clear()
    File(baseDir)
      .listFiles(NEOLANG_FILTER)
      .filter { it.absolutePath != NeoTermPath.EKS_DEFAULT_FILE }
      .mapNotNull { this.loadConfigure(it) }
      .forEach {
        registerShortcutKeys(it)
      }
  }
}

```

`app/src/main/java/io/neoterm/component/extrakey/data.kt`:

```kt
package io.neoterm.component.extrakey

import io.neolang.frontend.ConfigVisitor
import io.neoterm.component.ConfigFileBasedObject
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import io.neoterm.frontend.session.view.extrakey.IExtraButton
import io.neoterm.frontend.session.view.extrakey.TextButton

/**
 * @author kiva
 */
class NeoExtraKey : ConfigFileBasedObject {
  companion object {
    const val EKS_META_CONTEXT_NAME = "extra-key"

    const val EKS_META_PROGRAM = "program"
    const val EKS_META_KEY = "key"
    const val EKS_META_WITH_DEFAULT = "with-default"
    const val EKS_META_WITH_ENTER = "with-enter"
    const val EKS_META_DISPLAY = "display"
    const val EKS_META_CODE = "code"
    const val EKS_META_VERSION = "version"

    val EKS_META_CONTEXT_PATH = arrayOf(EKS_META_CONTEXT_NAME)
  }

  var version: Int = 0
  val programNames: MutableList<String> = mutableListOf()
  val shortcutKeys: MutableList<IExtraButton> = mutableListOf()
  var withDefaultKeys: Boolean = true

  fun applyExtraKeys(extraKeysView: ExtraKeysView) {
    if (withDefaultKeys) {
      extraKeysView.loadDefaultUserKeys()
    }
    for (button in shortcutKeys) {
      extraKeysView.addUserKey(button)
    }
  }

  override fun onConfigLoaded(configVisitor: ConfigVisitor) {
    // program
    val programArray = configVisitor.getArray(EKS_META_CONTEXT_PATH, EKS_META_PROGRAM)
    if (programArray.isEmpty()) {
      throw RuntimeException("Extra Key must have programs attribute")
    }

    programArray.forEach {
      if (!it.isBlock()) {
        programNames.add(it.eval().asString())
      }
    }

    // key
    val keyArray = configVisitor.getArray(EKS_META_CONTEXT_PATH, EKS_META_KEY)
    keyArray.takeWhile { it.isBlock() }
      .forEach {
        val display = it.eval(EKS_META_DISPLAY)
        val code = it.eval(EKS_META_CODE)
        if (!code.isValid()) {
          throw RuntimeException("Key must have a code")
        }

        val codeText = code.asString()
        val displayText = if (display.isValid()) display.asString() else codeText
        val withEnter = it.eval(EKS_META_WITH_ENTER)
        val withEnterBoolean = withEnter.asString() == "true"

        val button = TextButton(codeText, withEnterBoolean)
        button.displayText = displayText
        shortcutKeys.add(button)
      }

    // We must cal toDouble() before toInt()
    // Because in NeoLang, numbers are default to Double
    version = getMetaByVisitor(configVisitor, EKS_META_VERSION)?.toDouble()?.toInt() ?: 0
    withDefaultKeys = "true" == getMetaByVisitor(configVisitor, EKS_META_WITH_DEFAULT)
  }

  private fun getMetaByVisitor(visitor: ConfigVisitor, metaName: String): String? {
    return visitor.getStringValue(EKS_META_CONTEXT_PATH, metaName)
  }
}

```

`app/src/main/java/io/neoterm/component/font/comp.kt`:

```kt
package io.neoterm.component.font

import android.content.Context
import android.graphics.Typeface
import io.neoterm.App
import io.neoterm.R
import io.neoterm.component.NeoComponent
import io.neoterm.component.config.DefaultValues
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.config.NeoTermPath
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import io.neoterm.utils.extractAssetsDir
import java.io.File

class FontComponent : NeoComponent {
  private lateinit var DEFAULT_FONT: NeoFont
  private lateinit var fonts: MutableMap<String, NeoFont>

  fun applyFont(terminalView: TerminalView?, extraKeysView: ExtraKeysView?, font: NeoFont?) {
    font?.applyFont(terminalView, extraKeysView)
  }

  fun getCurrentFont(): NeoFont {
    return fonts[getCurrentFontName()]!!
  }

  fun setCurrentFont(fontName: String) {
    NeoPreference.store(R.string.key_customization_font, fontName)
  }

  fun getCurrentFontName(): String {
    val defaultFont = DefaultValues.defaultFont
    var currentFontName = NeoPreference.loadString(R.string.key_customization_font, defaultFont)
    if (!fonts.containsKey(currentFontName)) {
      currentFontName = defaultFont
      NeoPreference.store(R.string.key_customization_font, defaultFont)
    }
    return currentFontName
  }

  fun getFont(fontName: String): NeoFont {
    return if (fonts.containsKey(fontName)) fonts[fontName]!! else getCurrentFont()
  }

  fun getFontNames(): List<String> {
    val list = ArrayList<String>()
    list += fonts.keys
    return list
  }

  fun reloadFonts(): Boolean {
    fonts.clear()
    fonts.put("Monospace", NeoFont(Typeface.MONOSPACE))
    fonts.put("Sans Serif", NeoFont(Typeface.SANS_SERIF))
    fonts.put("Serif", NeoFont(Typeface.SERIF))
    val fontDir = File(NeoTermPath.FONT_PATH)
    for (file in fontDir.listFiles({ pathname -> pathname.name.endsWith(".ttf") })) {
      val fontName = fontName(file)
      val font = NeoFont(file)
      fonts.put(fontName, font)
    }

    val defaultFont = DefaultValues.defaultFont
    if (fonts.containsKey(defaultFont)) {
      DEFAULT_FONT = fonts[defaultFont]!!
      return true
    }
    return false
  }

  override fun onServiceInit() {
    checkForFiles()
  }

  override fun onServiceDestroy() {
  }

  override fun onServiceObtained() {
    checkForFiles()
  }

  private fun loadDefaultFontFromAsset(context: Context): NeoFont {
    val defaultFont = DefaultValues.defaultFont
    return NeoFont(Typeface.createFromAsset(context.assets, "fonts/$defaultFont.ttf"))
  }

  private fun extractDefaultFont(context: Context): Boolean {
    try {
      context.extractAssetsDir( "fonts", NeoTermPath.FONT_PATH)
      return true
    } catch (e: Exception) {
      return false
    }
  }

  private fun fontFile(fontName: String): File {
    return File("${NeoTermPath.FONT_PATH}/$fontName.ttf")
  }

  private fun fontName(fontFile: File): String {
    return fontFile.nameWithoutExtension
  }

  private fun checkForFiles() {
    File(NeoTermPath.FONT_PATH).mkdirs()
    fonts = mutableMapOf()

    val context = App.get()
    val defaultFont = DefaultValues.defaultFont
    val defaultFontFile = fontFile(defaultFont)

    if (!defaultFontFile.exists()) {
      if (!extractDefaultFont(context)) {
        DEFAULT_FONT = loadDefaultFontFromAsset(context)
        fonts.put(defaultFont, DEFAULT_FONT)
        return
      }
    }

    if (!reloadFonts()) {
      DEFAULT_FONT = loadDefaultFontFromAsset(context)
      fonts.put(defaultFont, DEFAULT_FONT)
    }
  }
}


```

`app/src/main/java/io/neoterm/component/font/data.kt`:

```kt
package io.neoterm.component.font

import android.graphics.Typeface
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import java.io.File

class NeoFont {
  private var fontFile: File? = null
  private var typeface: Typeface? = null

  constructor(fontFile: File) {
    this.fontFile = fontFile
  }

  constructor(typeface: Typeface) {
    this.typeface = typeface
  }

  internal fun applyFont(terminalView: TerminalView?, extraKeysView: ExtraKeysView?) {
    val typeface = getTypeFace()
    terminalView?.setTypeface(typeface)
    extraKeysView?.setTypeface(typeface)
  }

  private fun getTypeFace(): Typeface? {
    if (typeface == null && fontFile == null) {
      return null
    }

    if (typeface == null) {
      typeface = Typeface.createFromFile(fontFile)
    }
    return typeface
  }
}

```

`app/src/main/java/io/neoterm/component/pm/NeoPackageParser.java`:

```java
package io.neoterm.component.pm;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

/**
 * @author kiva
 */

public class NeoPackageParser {
  public interface ParseStateListener {
    void onStartState();

    void onEndState();

    NeoPackageInfo onCreatePackageInfo();

    void onStartParsePackage(String name, NeoPackageInfo packageInfo);

    void onEndParsePackage(NeoPackageInfo packageInfo);
  }

  private static final String
    KEY_PACKAGE_NAME = "Package",
    KEY_VERSION = "Version",
    KEY_ESSENTIAL = "Essential",
    KEY_ARCH = "Architecture",
    KEY_MAINTAINER = "Maintainer",
    KEY_INSTALLED_SIZE = "Installed-Size",
    KEY_DEPENDS = "Depends",
    KEY_FILENAME = "Filename",
    KEY_SIZE = "Size",
    KEY_MD5 = "MD5sum",
    KEY_SHA1 = "SHA1",
    KEY_SHA256 = "SHA256",
    KEY_HOMEPAGE = "Homepage",
    KEY_DESC = "Description";

  private BufferedReader reader;
  private ParseStateListener stateListener;

  NeoPackageParser(InputStream inputStream) {
    reader = new BufferedReader(new InputStreamReader(inputStream));
  }

  void setStateListener(ParseStateListener stateListener) {
    this.stateListener = stateListener;
  }

  public void parse() throws IOException {
    if (stateListener == null) {
      return;
    }

    String line;
    String[] splits = new String[2];
    String key = null;
    String value = null;
    boolean appendMode = false;

    NeoPackageInfo packageInfo = null;

    stateListener.onStartState();
    while ((line = reader.readLine()) != null) {
      if (line.isEmpty()) {
        continue;
      }

      if (splitKeyAndValue(line, splits)) {
        key = splits[0];
        value = splits[1];
        appendMode = false;
      } else {
        if (key == null) {
          // no key provided, we don't know where the value should be appended to
          continue;
        }
        // the rest value to previous key
        value = line.trim();
        appendMode = true;
      }

      if (key.equals(KEY_PACKAGE_NAME)) {
        if (packageInfo != null) {
          stateListener.onEndParsePackage(packageInfo);
        }
        packageInfo = stateListener.onCreatePackageInfo();
        packageInfo.setPackageName(value);
        stateListener.onStartParsePackage(value, packageInfo);
      }

      if (packageInfo == null) {
        continue;
      }

      if (appendMode) {
        value = appendToLastValue(packageInfo, key, value);
      }

      switch (key) {
        case KEY_ARCH:
          packageInfo.setArchitecture(Architecture.Companion.parse(value));
          break;
        case KEY_DEPENDS:
          packageInfo.setDependenciesString(value);
          break;
        case KEY_DESC:
          packageInfo.setDescription(value);
          break;
        case KEY_ESSENTIAL:
          packageInfo.setEssential(value.equals("yes"));
          break;
        case KEY_FILENAME:
          packageInfo.setFileName(value);
          break;
        case KEY_HOMEPAGE:
          packageInfo.setHomePage(value);
          break;
        case KEY_INSTALLED_SIZE:
          packageInfo.setInstalledSizeInBytes(Long.parseLong(value));
          break;
        case KEY_MAINTAINER:
          packageInfo.setMaintainer(value);
          break;
        case KEY_MD5:
          packageInfo.setMd5(value);
          break;
        case KEY_SHA1:
          packageInfo.setSha1(value);
          break;
        case KEY_SHA256:
          packageInfo.setSha256(value);
          break;
        case KEY_SIZE:
          packageInfo.setSizeInBytes(Long.parseLong(value));
          break;
        case KEY_VERSION:
          packageInfo.setVersion(value);
          break;
      }
    }
    if (packageInfo != null) {
      stateListener.onEndParsePackage(packageInfo);
    }
    stateListener.onEndState();
  }

  private String appendToLastValue(NeoPackageInfo packageInfo, String key, String value) {
    // Currently, only descriptions can be multiline
    switch (key) {
      case KEY_DESC:
        return packageInfo.getDescription() + " " + value;
      default:
        return value;
    }
  }

  private boolean splitKeyAndValue(String line, String[] splits) {
    int valueIndex = line.indexOf(':');
    if (valueIndex < 0) {
      return false;
    }

    splits[0] = line.substring(0, valueIndex).trim();
    splits[1] = line.substring(valueIndex == line.length() ? valueIndex : valueIndex + 1).trim();
    return true;
  }
}

```

`app/src/main/java/io/neoterm/component/pm/PackageComponent.java`:

```java
package io.neoterm.component.pm;

import io.neoterm.component.NeoComponent;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;

/**
 * @author kiva
 */

public class PackageComponent implements NeoComponent {
  private final Object lock = new Object();
  private boolean isRefreshing = false;
  private boolean queryEnabled = true;
  private HashMap<String, NeoPackageInfo> neoPackages;

  private NeoPackageInfo getPackageInfo(String packageName) {
    return queryEnabled ? neoPackages.get(packageName) : null;
  }

  public HashMap<String, NeoPackageInfo> getPackages() {
    return queryEnabled ? neoPackages : new HashMap<>();
  }

  public int getPackageCount() {
    return queryEnabled ? neoPackages.size() : -1;
  }

  public SourceManager getSourceManager() {
    return new SourceManager();
  }

  public void reloadPackages(File packageListFile, boolean clearPrevious) throws IOException {
    synchronized (lock) {
      if (isRefreshing) {
        return;
      }
      isRefreshing = true;
    }
    tryParsePackages(packageListFile, clearPrevious);
    synchronized (lock) {
      isRefreshing = false;
    }
  }

  public void clearPackages() {
    if (isRefreshing) {
      return;
    }
    neoPackages.clear();
  }

  private void tryParsePackages(File packageListFile, final boolean clearPrevious) throws IOException {
    NeoPackageParser packageParser = new NeoPackageParser(new FileInputStream(packageListFile));
    packageParser.setStateListener(new NeoPackageParser.ParseStateListener() {
      @Override
      public void onStartState() {
        queryEnabled = false;
        if (clearPrevious) {
          neoPackages.clear();
        }
      }

      @Override
      public void onEndState() {
        queryEnabled = true;
        for (NeoPackageInfo info : neoPackages.values()) {
          resolveDepends(info);
        }
      }

      @Override
      public NeoPackageInfo onCreatePackageInfo() {
        return new NeoPackageInfo();
      }

      @Override
      public void onStartParsePackage(String name, NeoPackageInfo packageInfo) {
      }

      @Override
      public void onEndParsePackage(NeoPackageInfo packageInfo) {
        neoPackages.put(packageInfo.getPackageName(), packageInfo);
      }
    });
    packageParser.parse();
  }

  private void resolveDepends(NeoPackageInfo info) {
    String dep = info.getDependenciesString();
    if (dep == null) {
      return;
    }

    String[] splits = dep.split(",");
    NeoPackageInfo[] depends = new NeoPackageInfo[splits.length];
    info.setDependencies(depends);

    for (int i = 0; i < splits.length; ++i) {
      String item = splits[i].trim();
      depends[i] = getPackageInfo(item);
    }
  }

  @Override
  public void onServiceInit() {
    neoPackages = new HashMap<>();
  }

  @Override
  public void onServiceDestroy() {
  }

  @Override
  public void onServiceObtained() {
  }
}

```

`app/src/main/java/io/neoterm/component/pm/Source.java`:

```java
package io.neoterm.component.pm;

import io.neoterm.framework.database.annotation.ID;
import io.neoterm.framework.database.annotation.Table;

/**
 * @author kiva
 */
@Table
public class Source {
  @ID(autoIncrement = true)
  private int id;

  public String url;

  public String repo;

  public boolean enabled;

  public Source() {
    // for Database
  }

  public Source(String url, String repo, boolean enabled) {
    this.url = url;
    this.repo = repo;
    this.enabled = enabled;
  }
}

```

`app/src/main/java/io/neoterm/component/pm/data.kt`:

```kt
package io.neoterm.component.pm

enum class Architecture {
  ALL, ARM, AARCH64, X86, X86_64;

  companion object {
    fun parse(arch: String): Architecture {
      return when (arch) {
        "arm" -> ARM
        "aarch64" -> AARCH64
        "x86" -> X86
        "x86_64" -> X86_64
        else -> ALL
      }
    }
  }
}

class NeoPackageInfo {
  var packageName: String? = null
  var isEssential: Boolean = false
  var version: String? = null
  var architecture: Architecture = Architecture.ALL
  var maintainer: String? = null
  var installedSizeInBytes: Long = 0L
  var fileName: String? = null
  var dependenciesString: String? = null
  var dependencies: Array<NeoPackageInfo>? = null
  var sizeInBytes: Long = 0L
  var md5: String? = null
  var sha1: String? = null
  var sha256: String? = null
  var homePage: String? = null
  var description: String? = null
}

```

`app/src/main/java/io/neoterm/component/pm/helper.kt`:

```kt
package io.neoterm.component.pm

import io.neoterm.App
import io.neoterm.R
import io.neoterm.component.ComponentManager
import io.neoterm.component.config.NeoTermPath
import io.neoterm.framework.NeoTermDatabase
import io.neoterm.utils.NLog
import java.io.File
import java.net.URL
import java.nio.file.Files
import java.nio.file.Paths

object SourceHelper {
  fun syncSource() {
    val sourceManager = ComponentManager.getComponent<PackageComponent>().sourceManager
    syncSource(sourceManager)
  }

  fun syncSource(sourceManager: SourceManager) {
    val content = buildString {
      this.append("# Generated by NeoTerm-Preference\n")
      sourceManager.getEnabledSources()
        .joinTo(this, "\n") { "deb [trusted=yes] ${it.url} ${it.repo}\n" }
    }
    kotlin.runCatching {
      Files.write(Paths.get(NeoTermPath.SOURCE_FILE), content.toByteArray())
    }
  }

  fun detectSourceFiles(): List<File> {
    val sourceManager = ComponentManager.getComponent<PackageComponent>().sourceManager
    val sourceFiles = ArrayList<File>()
    try {
      val prefixes = sourceManager.getEnabledSources()
        .map { detectSourceFilePrefix(it) }
        .filter { it.isNotEmpty() }

      File(NeoTermPath.PACKAGE_LIST_DIR)
        .listFiles()
        .filterTo(sourceFiles) { file ->
          prefixes.filter { file.name.startsWith(it) }
            .count() > 0
        }
    } catch (e: Exception) {
      sourceFiles.clear()
      NLog.e("PM", "Failed to detect source files: ${e.localizedMessage}")
    }

    return sourceFiles
  }

  fun detectSourceFilePrefix(source: Source): String {
    try {
      val url = URL(source.url)
      val builder = StringBuilder(url.host)
      if (url.port != -1) {
        builder.append(":${url.port}")
      }

      val path = url.path
      if (path != null && path.isNotEmpty()) {
        builder.append("_")
        val fixedPath = path.replace("/", "_").substring(1) // skip the last '/'
        builder.append(fixedPath)
      }
      builder.append("_dists_${source.repo.replace(" ".toRegex(), "_")}_binary-")
      return builder.toString()
    } catch (e: Exception) {
      NLog.e("PM", "Failed to detect source file prefix: ${e.localizedMessage}")
      return ""
    }
  }
}

class SourceManager internal constructor() {
  private val database = NeoTermDatabase.instance("sources")

  init {
    if (database.findAll<Source>(Source::class.java).isEmpty()) {
      App.get().resources.getStringArray(R.array.pref_package_source_values)
        .forEach {
          database.saveBean(Source(it, "stable main", true))
        }
    }
  }

  fun addSource(sourceUrl: String, repo: String, enabled: Boolean) {
    database.saveBean(Source(sourceUrl, repo, enabled))
  }

  fun removeSource(sourceUrl: String) {
    database.deleteBeanByWhere(Source::class.java, "url == '$sourceUrl'")
  }

  fun updateAll(sources: List<Source>) {
    database.dropAllTable()
    database.saveBeans(sources)
  }

  fun getAllSources(): List<Source> {
    return database.findAll(Source::class.java)
  }

  fun getEnabledSources(): List<Source> {
    return getAllSources().filter { it.enabled }
  }

  fun getMainPackageSource(): String {
    return getEnabledSources()
      .map { it.repo }
      .singleOrNull { it.trim() == "stable main" }
      ?: NeoTermPath.DEFAULT_MAIN_PACKAGE_SOURCE
  }

  fun applyChanges() {
    database.vacuum()
  }
}


```

`app/src/main/java/io/neoterm/component/profile/comp.kt`:

```kt
package io.neoterm.component.profile

import io.neolang.frontend.ConfigVisitor
import io.neoterm.component.ConfigFileBasedComponent
import io.neoterm.component.config.NeoTermPath
import io.neoterm.utils.NLog
import java.io.File

class ProfileComponent : ConfigFileBasedComponent<NeoProfile>(NeoTermPath.PROFILE_PATH) {
  override val checkComponentFileWhenObtained
    get() = true

  private val profileRegistry = mutableMapOf<String, Class<out NeoProfile>>()
  private val profileList = mutableMapOf<String, MutableList<NeoProfile>>()

  override fun onCheckComponentFiles() = reloadProfiles()

  override fun onCreateComponentObject(configVisitor: ConfigVisitor): NeoProfile {
    val rootContext = configVisitor.getRootContext()

    val profileClass = rootContext.children
      .mapNotNull {
        profileRegistry[it.contextName]
      }
      .singleOrNull()

    if (profileClass != null) {
      NLog.e("ProfileComponent", "Loaded profile: " + profileClass.name)
      return profileClass.newInstance()
    }

    throw IllegalArgumentException("No proper profile registry found")
  }

  fun getProfiles(metaName: String): List<NeoProfile> = profileList[metaName] ?: listOf()

  fun reloadProfiles() {
    profileList.clear()
    File(baseDir)
      .listFiles(NEOLANG_FILTER)
      .mapNotNull {
        this.loadConfigure(it)
      }
      .forEach {
        val list = profileList[it.profileMetaName]
        if (list != null) {
          list.add(it)
        } else {
          val newList = mutableListOf(it)
          profileList.put(it.profileMetaName, newList)
        }
      }
  }

  fun registerProfile(metaName: String, prototype: Class<out NeoProfile>) {
    profileRegistry[metaName] = prototype
    reloadProfiles()
  }

  fun unregisterProfile(metaName: String) {
    profileRegistry.remove(metaName)
  }
}

```

`app/src/main/java/io/neoterm/component/profile/data.kt`:

```kt
package io.neoterm.component.profile

import io.neolang.frontend.ConfigVisitor
import io.neoterm.component.ComponentManager
import io.neoterm.component.ConfigFileBasedObject
import io.neoterm.component.codegen.CodeGenObject
import io.neoterm.component.codegen.CodeGenParameter
import io.neoterm.component.codegen.CodeGenerator
import io.neoterm.component.codegen.NeoProfileGenerator
import io.neoterm.component.config.ConfigureComponent
import io.neoterm.component.config.NeoConfigureFile
import io.neoterm.utils.NLog
import org.jetbrains.annotations.TestOnly
import java.io.File

abstract class NeoProfile : CodeGenObject, ConfigFileBasedObject {
  companion object {
    private const val PROFILE_NAME = "name"
  }

  abstract val profileMetaName: String
  private val profileMetaPath
    get() = arrayOf(profileMetaName)

  var profileName = "Unknown Profile"

  override fun onConfigLoaded(configVisitor: ConfigVisitor) {
    profileName = configVisitor.getProfileString(PROFILE_NAME, profileName)
  }

  override fun getCodeGenerator(parameter: CodeGenParameter): CodeGenerator {
    return NeoProfileGenerator(parameter)
  }

  @TestOnly
  fun testLoadConfigure(file: File): Boolean {
    val loaderService = ComponentManager.getComponent<ConfigureComponent>()

    val configure: NeoConfigureFile?
    try {
      configure = loaderService.newLoader(file).loadConfigure()
      if (configure == null) {
        throw RuntimeException("Parse configuration failed.")
      }
    } catch (e: Exception) {
      NLog.e("Profile", "Failed to load profile: ${file.absolutePath}: ${e.localizedMessage}")
      return false
    }

    val visitor = configure.getVisitor()
    onConfigLoaded(visitor)
    return true
  }

  protected fun ConfigVisitor.getProfileString(key: String, fallback: String): String {
    return getProfileString(key) ?: fallback
  }

  protected fun ConfigVisitor.getProfileBoolean(key: String, fallback: Boolean): Boolean {
    return getProfileBoolean(key) ?: fallback
  }

  protected fun ConfigVisitor.getProfileString(key: String): String? {
    return this.getStringValue(profileMetaPath, key)
  }

  protected fun ConfigVisitor.getProfileBoolean(key: String): Boolean? {
    return this.getBooleanValue(profileMetaPath, key)
  }
}

```

`app/src/main/java/io/neoterm/component/session/comp.kt`:

```kt
package io.neoterm.component.session

import android.annotation.SuppressLint
import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.Globals
import io.neoterm.component.NeoComponent
import io.neoterm.component.config.NeoTermPath
import io.neoterm.utils.NLog

class SessionComponent : NeoComponent {
  companion object {
    private var IS_LIBRARIES_LOADED = false

    private fun wrapLibraryName(libName: String): String {
      return "lib$libName.so"
    }

    @SuppressLint("UnsafeDynamicallyLoadedCode")
    private fun loadLibraries(): Boolean {
      try {
        if (Globals.NeedGles3) {
          System.loadLibrary("GLESv3")
          NLog.e("SessionComponent", "Loaded GLESv3 lib")
        } else if (Globals.NeedGles2) {
          System.loadLibrary("GLESv2")
          NLog.e("SessionComponent", "Loaded GLESv2 lib")
        }
      } catch (e: UnsatisfiedLinkError) {
        NLog.e("SessionComponent", "Cannot load GLESv3 or GLESv2 lib")
      }

      var result: Boolean
      try {
        Globals.XLIBS
          .plus(Globals.XAPP_LIBS)
          .forEach {
            val soPath = "${NeoTermPath.LIB_PATH}/xorg-neoterm/${wrapLibraryName(it)}"
            NLog.e("SessionComponent", "Loading lib " + soPath)
            try {
              System.load(soPath)
            } catch (error: UnsatisfiedLinkError) {
              NLog.e(
                "SessionComponent", "Error loading lib " + soPath
                + ", reason: " + error.localizedMessage
              )
              result = false
            }
          }
        result = true

      } catch (ignore: UnsatisfiedLinkError) {
        NLog.e("SessionComponent", ignore.localizedMessage)
        result = false
      }

      return result
    }

    private fun checkLibrariesLoaded(): Boolean {
      if (!IS_LIBRARIES_LOADED) {
        synchronized(SessionComponent::class.java) {
          if (!IS_LIBRARIES_LOADED) {
            IS_LIBRARIES_LOADED = loadLibraries()
          }
        }
      }
      return IS_LIBRARIES_LOADED
    }
  }

  override fun onServiceInit() {
  }

  override fun onServiceDestroy() {
  }

  override fun onServiceObtained() {
  }

  fun createSession(context: Context, parameter: XParameter): XSession {
    if (context is AppCompatActivity) {
      if (!checkLibrariesLoaded()) {
        throw RuntimeException("Cannot load libraries!")
      }

      return XSession(context, XSessionData())
    }
    throw RuntimeException("Creating X sessions requires Activity, but got Context")
  }

  fun createSession(context: Context, parameter: ShellParameter): ShellTermSession {
    return ShellTermSession.Builder()
      .executablePath(parameter.executablePath)
      .currentWorkingDirectory(parameter.cwd)
      .callback(parameter.sessionCallback)
      .systemShell(parameter.systemShell)
      .envArray(parameter.env)
      .argArray(parameter.arguments)
      .initialCommand(parameter.initialCommand)
      .profile(parameter.shellProfile)
      .create(context)
  }
}

```

`app/src/main/java/io/neoterm/component/session/shell.kt`:

```kt
package io.neoterm.component.session

import android.content.Context
import io.neolang.frontend.ConfigVisitor
import io.neoterm.App
import io.neoterm.R
import io.neoterm.backend.TerminalSession
import io.neoterm.bridge.SessionId
import io.neoterm.component.ComponentManager
import io.neoterm.component.colorscheme.ColorSchemeComponent
import io.neoterm.component.config.DefaultValues
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.config.NeoTermPath
import io.neoterm.component.font.FontComponent
import io.neoterm.component.profile.NeoProfile
import io.neoterm.frontend.session.terminal.TermSessionCallback
import java.io.File

/**
 * @author kiva
 */
class ShellParameter {
  var sessionId: SessionId? = null
  var executablePath: String? = null
  var arguments: Array<String>? = null
  var cwd: String? = null
  var initialCommand: String? = null
  var env: Array<Pair<String, String>>? = null
  var sessionCallback: TerminalSession.SessionChangedCallback? = null
  var systemShell: Boolean = false
  var shellProfile: ShellProfile? = null

  fun executablePath(executablePath: String?): ShellParameter {
    this.executablePath = executablePath
    return this
  }

  fun arguments(arguments: Array<String>?): ShellParameter {
    this.arguments = arguments
    return this
  }

  fun currentWorkingDirectory(cwd: String?): ShellParameter {
    this.cwd = cwd
    return this
  }

  fun initialCommand(initialCommand: String?): ShellParameter {
    this.initialCommand = initialCommand
    return this
  }

  fun environment(env: Array<Pair<String, String>>?): ShellParameter {
    this.env = env
    return this
  }

  fun callback(callback: TerminalSession.SessionChangedCallback?): ShellParameter {
    this.sessionCallback = callback
    return this
  }

  fun systemShell(systemShell: Boolean): ShellParameter {
    this.systemShell = systemShell
    return this
  }

  fun profile(shellProfile: ShellProfile): ShellParameter {
    this.shellProfile = shellProfile
    return this
  }

  fun session(sessionId: SessionId?): ShellParameter {
    this.sessionId = sessionId
    return this
  }

  fun willCreateNewSession(): Boolean {
    return sessionId?.equals(SessionId.NEW_SESSION) ?: true
  }
}

/**
 * @author kiva
 */
class ShellProfile : NeoProfile() {
  companion object {
    const val PROFILE_META_NAME = "profile-shell"

    private const val LOGIN_SHELL = "login-shell"
    private const val INITIAL_COMMAND = "init-command"
    private const val BELL = "bell"
    private const val VIBRATE = "vibrate"
    private const val EXECVE_WRAPPER = "execve-wrapper"
    private const val SPECIAL_VOLUME_KEYS = "special-volume-keys"
    private const val AUTO_COMPLETION = "auto-completion"
    private const val BACK_KEY_TO_ESC = "back-key-esc"
    private const val EXTRA_KEYS = "extra-keys"
    private const val FONT = "font"
    private const val COLOR_SCHEME = "color-scheme"
    private const val WORD_BASED_IME = "word-based-ime"

    fun create(): ShellProfile {
      return ShellProfile()
    }
  }

  override val profileMetaName = PROFILE_META_NAME

  var loginShell = DefaultValues.loginShell
  var initialCommand = DefaultValues.initialCommand

  var enableBell = DefaultValues.enableBell
  var enableVibrate = DefaultValues.enableVibrate
  var enableExecveWrapper = DefaultValues.enableExecveWrapper
  var enableSpecialVolumeKeys = DefaultValues.enableSpecialVolumeKeys
  var enableAutoCompletion = DefaultValues.enableAutoCompletion
  var enableBackKeyToEscape = DefaultValues.enableBackButtonBeMappedToEscape
  var enableExtraKeys = DefaultValues.enableExtraKeys
  var enableWordBasedIme = DefaultValues.enableWordBasedIme

  var profileFont: String
  var profileColorScheme: String

  init {
    val fontComp = ComponentManager.getComponent<FontComponent>()
    val colorComp = ComponentManager.getComponent<ColorSchemeComponent>()

    profileFont = fontComp.getCurrentFontName()
    profileColorScheme = colorComp.getCurrentColorSchemeName()

    loginShell = NeoPreference.getLoginShellPath()
    initialCommand = NeoPreference.getInitialCommand()
    enableBell = NeoPreference.isBellEnabled()
    enableVibrate = NeoPreference.isVibrateEnabled()
    enableExecveWrapper = NeoPreference.isExecveWrapperEnabled()
    enableSpecialVolumeKeys = NeoPreference.isSpecialVolumeKeysEnabled()
    enableAutoCompletion = NeoPreference.isAutoCompletionEnabled()
    enableBackKeyToEscape = NeoPreference.isBackButtonBeMappedToEscapeEnabled()
    enableExtraKeys = NeoPreference.isExtraKeysEnabled()
    enableWordBasedIme = NeoPreference.isWordBasedImeEnabled()
  }

  override fun onConfigLoaded(configVisitor: ConfigVisitor) {
    super.onConfigLoaded(configVisitor)
    loginShell = configVisitor.getProfileString(LOGIN_SHELL, loginShell)
    initialCommand = configVisitor.getProfileString(INITIAL_COMMAND, initialCommand)
    enableBell = configVisitor.getProfileBoolean(BELL, enableBell)
    enableVibrate = configVisitor.getProfileBoolean(VIBRATE, enableVibrate)
    enableExecveWrapper = configVisitor.getProfileBoolean(EXECVE_WRAPPER, enableExecveWrapper)
    enableSpecialVolumeKeys = configVisitor.getProfileBoolean(SPECIAL_VOLUME_KEYS, enableSpecialVolumeKeys)
    enableAutoCompletion = configVisitor.getProfileBoolean(AUTO_COMPLETION, enableAutoCompletion)
    enableBackKeyToEscape = configVisitor.getProfileBoolean(BACK_KEY_TO_ESC, enableBackKeyToEscape)
    enableExtraKeys = configVisitor.getProfileBoolean(EXTRA_KEYS, enableExtraKeys)
    enableWordBasedIme = configVisitor.getProfileBoolean(WORD_BASED_IME, enableWordBasedIme)
    profileFont = configVisitor.getProfileString(FONT, profileFont)
    profileColorScheme = configVisitor.getProfileString(COLOR_SCHEME, profileColorScheme)
  }
}

/**
 * @author kiva
 */
open class ShellTermSession private constructor(
  shellPath: String, cwd: String,
  args: Array<String>, env: Array<String>,
  changeCallback: SessionChangedCallback,
  private val initialCommand: String?,
  val shellProfile: ShellProfile
) : TerminalSession(shellPath, cwd, args, env, changeCallback) {

  var exitPrompt = App.get().getString(R.string.process_exit_prompt)

  override fun initializeEmulator(columns: Int, rows: Int) {
    super.initializeEmulator(columns, rows)
    sendInitialCommand(shellProfile.initialCommand)
    sendInitialCommand(initialCommand)
  }

  override fun getExitDescription(exitCode: Int): String {
    val builder = StringBuilder("\r\n[")
    val context = App.get()
    builder.append(context.getString(R.string.process_exit_info))
    if (exitCode > 0) {
      // Non-zero process exit.
      builder.append(" (")
      builder.append(context.getString(R.string.process_exit_code, exitCode))
      builder.append(")")
    } else if (exitCode < 0) {
      // Negated signal.
      builder.append(" (")
      builder.append(context.getString(R.string.process_exit_signal, -exitCode))
      builder.append(")")
    }
    builder.append(" - $exitPrompt]")
    return builder.toString()
  }

  private fun sendInitialCommand(command: String?) {
    if (command?.isNotEmpty() == true) {
      write(command + '\r')
    }
  }

  class Builder {
    private var executablePath: String? = null
    private var cwd: String? = null
    private var args: MutableList<String>? = null
    private var env: MutableList<Pair<String, String>>? = null
    private var changeCallback: SessionChangedCallback? = null
    private var systemShell = false
    private var initialCommand: String? = null
    private var shellProfile = ShellProfile()

    fun profile(shellProfile: ShellProfile?): Builder {
      if (shellProfile != null) {
        this.shellProfile = shellProfile
      }
      return this
    }

    fun initialCommand(command: String?): Builder {
      this.initialCommand = command
      return this
    }

    fun executablePath(shell: String?): Builder {
      this.executablePath = shell
      return this
    }

    fun currentWorkingDirectory(cwd: String?): Builder {
      this.cwd = cwd
      return this
    }

    fun arg(arg: String?): Builder {
      if (arg != null) {
        if (args == null) {
          args = mutableListOf(arg)
        } else {
          args!!.add(arg)
        }
      } else {
        this.args = null
      }
      return this
    }

    fun argArray(args: Array<String>?): Builder {
      if (args != null) {
        if (args.isEmpty()) {
          this.args = null
          return this
        }
        args.forEach { arg(it) }
      } else {
        this.args = null
      }
      return this
    }

    fun env(env: Pair<String, String>?): Builder {
      if (env != null) {
        if (this.env == null) {
          this.env = mutableListOf(env)
        } else {
          this.env!!.add(env)
        }
      } else {
        this.env = null
      }
      return this
    }

    fun envArray(env: Array<Pair<String, String>>?): Builder {
      if (env != null) {
        if (env.isEmpty()) {
          this.env = null
          return this
        }
        env.forEach { env(it) }
      } else {
        this.env = null
      }
      return this
    }

    fun callback(callback: SessionChangedCallback?): Builder {
      this.changeCallback = callback
      return this
    }

    fun systemShell(systemShell: Boolean): Builder {
      this.systemShell = systemShell
      return this
    }

    fun create(context: Context): ShellTermSession {
      val cwd = this.cwd ?: NeoTermPath.HOME_PATH

      val shell = this.executablePath ?: if (systemShell)
        "/system/bin/sh"
      else
        shellProfile.loginShell

      val args = this.args ?: mutableListOf(shell)
      val env = transformEnvironment(this.env) ?: buildEnvironment(cwd, systemShell)
      val callback = changeCallback ?: TermSessionCallback()
      return ShellTermSession(
        shell, cwd, args.toTypedArray(), env, callback,
        initialCommand ?: "", shellProfile
      )
    }

    private fun transformEnvironment(env: MutableList<Pair<String, String>>?): Array<String>? {
      if (env == null) {
        return null
      }

      val result = mutableListOf<String>()
      return env.mapTo(result, { "${it.first}=${it.second}" })
        .toTypedArray()
    }


    private fun buildEnvironment(cwd: String?, systemShell: Boolean): Array<String> {
      val selectedCwd = cwd ?: NeoTermPath.HOME_PATH
      File(NeoTermPath.HOME_PATH).mkdirs()

      val termEnv = "TERM=xterm-256color"
      val homeEnv = "HOME=" + NeoTermPath.HOME_PATH
      val prefixEnv = "PREFIX=" + NeoTermPath.USR_PATH
      val androidRootEnv = "ANDROID_ROOT=" + System.getenv("ANDROID_ROOT")
      val androidDataEnv = "ANDROID_DATA=" + System.getenv("ANDROID_DATA")
      val externalStorageEnv = "EXTERNAL_STORAGE=" + System.getenv("EXTERNAL_STORAGE")
      val colorterm = "COLORTERM=truecolor"

      // PY Trade: Some programs support NeoTerm in a special way.
      val neotermIdEnv = "__NEOTERM=1"
      val originPathEnv = "__NEOTERM_ORIGIN_PATH=" + buildOriginPathEnv()
      val originLdEnv = "__NEOTERM_ORIGIN_LD_LIBRARY_PATH=" + buildOriginLdLibEnv()

      return if (systemShell) {
        val pathEnv = "PATH=" + System.getenv("PATH")
        arrayOf(
          termEnv, homeEnv, androidRootEnv, androidDataEnv,
          externalStorageEnv, pathEnv, neotermIdEnv, prefixEnv,
          originLdEnv, originPathEnv, colorterm
        )

      } else {
        val ps1Env = "PS1=$ "
        val langEnv = "LANG=en_US.UTF-8"
        val pathEnv = "PATH=" + buildPathEnv()
        val ldEnv = "LD_LIBRARY_PATH=" + buildLdLibraryEnv()
        val pwdEnv = "PWD=$selectedCwd"
        val tmpdirEnv = "TMPDIR=${NeoTermPath.USR_PATH}/tmp"


        // execve(2) wrapper to avoid incorrect shebang
        val ldPreloadEnv = if (shellProfile.enableExecveWrapper) {
          "LD_PRELOAD=${App.get().applicationInfo.nativeLibraryDir}/libnexec.so"
        } else {
          ""
        }

        arrayOf(
          termEnv, homeEnv, ps1Env, ldEnv, langEnv, pathEnv, pwdEnv,
          androidRootEnv, androidDataEnv, externalStorageEnv,
          tmpdirEnv, neotermIdEnv, originPathEnv, originLdEnv,
          ldPreloadEnv, prefixEnv, colorterm
        )
      }
        .filter { it.isNotEmpty() }
        .toTypedArray()
    }

    private fun buildOriginPathEnv(): String {
      val path = System.getenv("PATH")
      return path ?: ""
    }

    private fun buildOriginLdLibEnv(): String {
      val path = System.getenv("LD_LIBRARY_PATH")
      return path ?: ""
    }

    private fun buildLdLibraryEnv(): String {
      return "${NeoTermPath.USR_PATH}/lib"
    }

    private fun buildPathEnv(): String {
      return "${NeoTermPath.USR_PATH}/bin:${NeoTermPath.USR_PATH}/bin/applets"
    }
  }
}

```

`app/src/main/java/io/neoterm/component/session/x.kt`:

```kt
package io.neoterm.component.session

import android.app.UiModeManager
import android.content.Context
import android.content.pm.ActivityInfo
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.inputmethodservice.Keyboard
import android.inputmethodservice.KeyboardView
import android.os.Build
import android.os.SystemClock
import android.text.InputType
import android.view.*
import android.view.inputmethod.InputMethodManager
import android.widget.EditText
import android.widget.FrameLayout
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.*
import io.neoterm.xorg.NeoXorgViewClient
import io.neoterm.xorg.R
import java.util.*

class XParameter

class XSession constructor(private val mActivity: AppCompatActivity, val mSessionData: XSessionData) :
  NeoXorgViewClient {
  var mSessionName = "";

  init {
    if (Globals.InhibitSuspend) {
      window.setFlags(
        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,
        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
      )
    }

    mSessionData.client = this
    NeoXorgSettings.init(this)
    if (mSessionData.audioThread == null) {
      mSessionData.audioThread = NeoAudioThread(this)
    }
  }

  fun onPause() {
    mSessionData.isPaused = true
    if (mSessionData.glView != null) {
      mSessionData.glView?.onPause()
    }
  }

  fun onDestroy() {
    if (mSessionData.glView != null) {
      mSessionData.glView?.exitApp()
    }
  }

  fun onResume() {
    if (mSessionData.glView != null) {
      mSessionData.glView?.onResume()
    }
    mSessionData.isPaused = false
  }

  override fun getContext() = mActivity
  override fun isKeyboardWithoutTextInputShown() = mSessionData.keyboardWithoutTextInputShown
  override fun isPaused() = mSessionData.isPaused
  override fun runOnUiThread(runnable: Runnable?) = mActivity.runOnUiThread(runnable)
  override fun getGLView() = mSessionData.glView
  override fun getWindow() = mActivity.window!!
  override fun getWindowManager() = mActivity.windowManager!!

  override fun showScreenKeyboardWithoutTextInputField(keyboard: Int) {
    val inputManager = mActivity.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager

    if (!isKeyboardWithoutTextInputShown) {
      mSessionData.keyboardWithoutTextInputShown = true
      runOnUiThread(Runnable {
        if (keyboard == 0) {
          inputManager.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0)
          inputManager.showSoftInput(glView, InputMethodManager.SHOW_FORCED)
          window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE)
        } else {
          if (mSessionData.screenKeyboard != null)
            return@Runnable

          val builtinKeyboard = BuiltInKeyboardView(mActivity, null)
          builtinKeyboard.alpha = 0.7f
          builtinKeyboard.changeKeyboard(keyboard)
          builtinKeyboard.setOnKeyboardActionListener(object : KeyboardView.OnKeyboardActionListener {
            override fun onPress(key: Int) {
              var key = key
              if (key == KeyEvent.KEYCODE_BACK)
                return
              if (key < 0)
                return
              for (k in builtinKeyboard.keyboard.keys) {
                if (k.sticky && key == k.codes[0])
                  return
              }
              if (key > 100000) {
                key -= 100000
                mActivity.onKeyDown(
                  KeyEvent.KEYCODE_SHIFT_LEFT,
                  KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT)
                )
              }
              mActivity.onKeyDown(key, KeyEvent(KeyEvent.ACTION_DOWN, key))
            }

            override fun onRelease(key: Int) {
              var key = key
              if (key == KeyEvent.KEYCODE_BACK) {
                builtinKeyboard.setOnKeyboardActionListener(null)
                showScreenKeyboardWithoutTextInputField(0) // Hide keyboard
                return
              }
              if (key == Keyboard.KEYCODE_SHIFT) {
                builtinKeyboard.shift = !builtinKeyboard.shift
                if (builtinKeyboard.shift && !builtinKeyboard.alt)
                  mActivity.onKeyDown(
                    KeyEvent.KEYCODE_SHIFT_LEFT,
                    KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_SHIFT_LEFT)
                  )
                else
                  mActivity.onKeyUp(
                    KeyEvent.KEYCODE_SHIFT_LEFT,
                    KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT)
                  )
                builtinKeyboard.changeKeyboard(keyboard)
                return
              }
              if (key == Keyboard.KEYCODE_ALT) {
                builtinKeyboard.alt = !builtinKeyboard.alt
                if (builtinKeyboard.alt)
                  mActivity.onKeyUp(
                    KeyEvent.KEYCODE_SHIFT_LEFT,
                    KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT)
                  )
                else
                  builtinKeyboard.shift = false
                builtinKeyboard.changeKeyboard(keyboard)
                return
              }
              if (key < 0)
                return
              for (k in builtinKeyboard.keyboard.keys) {
                if (k.sticky && key == k.codes[0]) {
                  if (k.on) {
                    builtinKeyboard.stickyKeys.add(key)
                    mActivity.onKeyDown(key, KeyEvent(KeyEvent.ACTION_DOWN, key))
                  } else {
                    builtinKeyboard.stickyKeys.remove(key)
                    mActivity.onKeyUp(key, KeyEvent(KeyEvent.ACTION_UP, key))
                  }
                  return
                }
              }

              var shifted = false
              if (key > 100000) {
                key -= 100000
                shifted = true
              }

              mActivity.onKeyUp(key, KeyEvent(KeyEvent.ACTION_UP, key))

              if (shifted) {
                mActivity.onKeyUp(
                  KeyEvent.KEYCODE_SHIFT_LEFT,
                  KeyEvent(KeyEvent.ACTION_UP, KeyEvent.KEYCODE_SHIFT_LEFT)
                )
                builtinKeyboard.stickyKeys.remove(KeyEvent.KEYCODE_SHIFT_LEFT)
                for (k in builtinKeyboard.keyboard.keys) {
                  if (k.sticky && k.codes[0] == KeyEvent.KEYCODE_SHIFT_LEFT && k.on) {
                    k.on = false
                    builtinKeyboard.invalidateAllKeys()
                  }
                }
              }
            }

            override fun onText(p1: CharSequence) {}

            override fun swipeLeft() {}

            override fun swipeRight() {}

            override fun swipeDown() {}

            override fun swipeUp() {}

            override fun onKey(p1: Int, p2: IntArray) {}
          })
          mSessionData.screenKeyboard = builtinKeyboard
          val layout = FrameLayout.LayoutParams(
            FrameLayout.LayoutParams.MATCH_PARENT,
            FrameLayout.LayoutParams.WRAP_CONTENT,
            Gravity.BOTTOM
          )
          mSessionData.videoLayout!!.addView(mSessionData.screenKeyboard, layout)
        }
      })
    } else {
      mSessionData.keyboardWithoutTextInputShown = false
      runOnUiThread {
        if (mSessionData.screenKeyboard != null) {
          mSessionData.videoLayout!!.removeView(mSessionData.screenKeyboard)
          mSessionData.screenKeyboard = null
        }
        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN)
        inputManager.hideSoftInputFromWindow(glView!!.windowToken, 0)
      }
    }
    glView!!.callNativeScreenKeyboardShown(if (isKeyboardWithoutTextInputShown) 1 else 0)
  }

  override fun setScreenKeyboardHintMessage(hideMessage: String?) {
    mSessionData.screenKeyboardHintMessage = hideMessage
    if (mSessionData.screenKeyboard is EditText) {
      runOnUiThread {
        val editText = mSessionData.screenKeyboard as EditText?
        editText?.hint = hideMessage ?: mActivity.getString(R.string.text_edit_click_here)
      }
    }
  }

  override fun isScreenKeyboardShown() = mSessionData.screenKeyboard != null

  override fun showScreenKeyboard(oldText: String?) {
    if (Globals.CompatibilityHacksTextInputEmulatesHwKeyboard) {
      showScreenKeyboardWithoutTextInputField(Globals.TextInputKeyboard)
      return
    }
    if (mSessionData.screenKeyboard != null)
      return

    val screenKeyboard = EditText(
      mActivity, null,
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
        android.R.style.TextAppearance_Material_Widget_EditText
      else android.R.style.TextAppearance_Widget_EditText
    )

    val hint = mSessionData.screenKeyboardHintMessage
    screenKeyboard.hint = hint ?: mActivity.getString(R.string.text_edit_click_here)
    screenKeyboard.setText(oldText)
    screenKeyboard.setSelection(screenKeyboard.text.length)
    screenKeyboard.setOnKeyListener(SimpleKeyListener(this))
    screenKeyboard.setBackgroundColor(mActivity.resources.getColor(android.R.color.primary_text_light))
    screenKeyboard.setTextColor(mActivity.resources.getColor(android.R.color.background_light))

    if (isRunningOnOUYA && Globals.TvBorders)
      screenKeyboard.setPadding(100, 100, 100, 100) // Bad bad HDMI TVs all have cropped borders
    mSessionData.screenKeyboard = screenKeyboard
    mSessionData.videoLayout!!.addView(mSessionData.screenKeyboard)

    screenKeyboard.inputType = InputType.TYPE_CLASS_TEXT
    screenKeyboard.isFocusableInTouchMode = true
    screenKeyboard.isFocusable = true
    screenKeyboard.postDelayed({
      screenKeyboard.requestFocus()
      screenKeyboard.dispatchTouchEvent(
        MotionEvent.obtain(
          SystemClock.uptimeMillis(),
          SystemClock.uptimeMillis(),
          MotionEvent.ACTION_DOWN,
          0f,
          0f,
          0
        )
      )
      screenKeyboard.dispatchTouchEvent(
        MotionEvent.obtain(
          SystemClock.uptimeMillis(),
          SystemClock.uptimeMillis(),
          MotionEvent.ACTION_UP,
          0f,
          0f,
          0
        )
      )
      screenKeyboard.postDelayed({
        screenKeyboard.requestFocus()
        screenKeyboard.setSelection(screenKeyboard.text.length)
      }, 100)
    }, 300)
  }

  override fun hideScreenKeyboard() {
    val inputManager = mActivity.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager

    if (isKeyboardWithoutTextInputShown)
      showScreenKeyboardWithoutTextInputField(Globals.TextInputKeyboard)

    if (mSessionData.screenKeyboard == null || mSessionData.screenKeyboard !is EditText)
      return

    synchronized(mSessionData.textInput) {
      val text = (mSessionData.screenKeyboard as EditText).text.toString()
      for (i in 0 until text.length) {
        NeoRenderer.callNativeTextInput(text[i].toInt(), text.codePointAt(i))
      }
    }
    NeoRenderer.callNativeTextInputFinished()
    inputManager.hideSoftInputFromWindow(mSessionData.screenKeyboard!!.windowToken, 0)
    mSessionData.videoLayout!!.removeView(mSessionData.screenKeyboard)
    mSessionData.screenKeyboard = null
    glView!!.isFocusableInTouchMode = true
    glView!!.isFocusable = true
    glView!!.requestFocus()
  }

  override fun updateScreenOrientation() {
    var rotation: Int = windowManager.defaultDisplay.rotation
    NeoAccelerometerReader.setGyroInvertedOrientation(
      rotation == Surface.ROTATION_180 || rotation == Surface.ROTATION_270
    )
  }

  override fun initScreenOrientation() {
    Globals.AutoDetectOrientation = true
    if (Globals.AutoDetectOrientation) {
      mActivity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_FULL_USER
      return
    }
    mActivity.requestedOrientation =
      if (Globals.HorizontalOrientation) ActivityInfo.SCREEN_ORIENTATION_SENSOR_LANDSCAPE
      else ActivityInfo.SCREEN_ORIENTATION_SENSOR_PORTRAIT
  }

  override fun isRunningOnOUYA(): Boolean {
    try {
      mActivity.packageManager.getPackageInfo("tv.ouya", 0)
      return true
    } catch (e: PackageManager.NameNotFoundException) {
    }

    val uiModeManager = mActivity.getSystemService(Context.UI_MODE_SERVICE) as UiModeManager?
    return uiModeManager?.currentModeType == Configuration.UI_MODE_TYPE_TELEVISION || Globals.OuyaEmulation
  }

  override fun setSystemMousePointerVisible(visible: Int) {
    if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.N) {
      glView?.pointerIcon = PointerIcon.getSystemIcon(
        mActivity,
        if (visible == 0) PointerIcon.TYPE_NULL
        else PointerIcon.TYPE_DEFAULT
      )
    }
  }

  class SimpleKeyListener(var client: NeoXorgViewClient) : View.OnKeyListener {

    override fun onKey(v: View, keyCode: Int, event: KeyEvent): Boolean {
      if (event.action == KeyEvent.ACTION_UP && (keyCode == KeyEvent.KEYCODE_ENTER ||
          keyCode == KeyEvent.KEYCODE_BACK ||
          keyCode == KeyEvent.KEYCODE_MENU ||
          keyCode == KeyEvent.KEYCODE_BUTTON_A ||
          keyCode == KeyEvent.KEYCODE_BUTTON_B ||
          keyCode == KeyEvent.KEYCODE_BUTTON_X ||
          keyCode == KeyEvent.KEYCODE_BUTTON_Y ||
          keyCode == KeyEvent.KEYCODE_BUTTON_1 ||
          keyCode == KeyEvent.KEYCODE_BUTTON_2 ||
          keyCode == KeyEvent.KEYCODE_BUTTON_3 ||
          keyCode == KeyEvent.KEYCODE_BUTTON_4)
      ) {
        client.hideScreenKeyboard()
        return true
      }
      return false
    }
  }

  class BuiltInKeyboardView(context: Context, attrs: android.util.AttributeSet?) : KeyboardView(context, attrs) {
    var shift = false
    var alt = false
    var stickyKeys = TreeSet<Int>()

    override fun dispatchTouchEvent(ev: MotionEvent): Boolean {
      if (ev.y < top)
        return false
      if (ev.action == MotionEvent.ACTION_DOWN || ev.action == MotionEvent.ACTION_UP || ev.action == MotionEvent.ACTION_MOVE) {
        // Convert pointer coords, this will lose multitiouch data, however KeyboardView does not support multitouch anyway
        val converted =
          MotionEvent.obtain(ev.downTime, ev.eventTime, ev.action, ev.x, ev.y - top.toFloat(), ev.metaState)
        return super.dispatchTouchEvent(converted)
      }
      return false
    }

    override fun onKeyDown(key: Int, event: KeyEvent): Boolean {
      return false
    }

    override fun onKeyUp(key: Int, event: KeyEvent): Boolean {
      return false
    }

    fun changeKeyboard(keyboardIndex: Int) {
      val idx = (if (shift) 1 else 0) + if (alt) 2 else 0
      val keyboard = Keyboard(context, NeoTextInput.TextInputKeyboardList[idx][keyboardIndex])
      isPreviewEnabled = false
      isProximityCorrectionEnabled = false
      for (k in keyboard.keys) {
        if (stickyKeys.contains(k.codes[0])) {
          k.on = true
          invalidateAllKeys()
        }
      }
    }
  }
}

class XSessionData {
  var videoLayout: FrameLayout? = null
  var audioThread: NeoAudioThread? = null
  var screenKeyboard: View? = null
  var glView: NeoGLView? = null

  var isPaused = false
  var client: NeoXorgViewClient? = null

  var keyboardWithoutTextInputShown = false
  var screenKeyboardHintMessage: String? = null
  var textInput = LinkedList<Int>()
}

```

`app/src/main/java/io/neoterm/component/userscript/comp.kt`:

```kt
package io.neoterm.component.userscript

import android.content.Context
import android.system.Os
import io.neoterm.App
import io.neoterm.component.NeoComponent
import io.neoterm.component.config.NeoTermPath
import io.neoterm.utils.NLog
import io.neoterm.utils.extractAssetsDir
import java.io.File

class UserScript(val scriptFile: File)

class UserScriptComponent : NeoComponent {
  var userScripts = listOf<UserScript>()
  private val scriptDir = File(NeoTermPath.USER_SCRIPT_PATH)

  override fun onServiceInit() = checkForFiles()

  override fun onServiceDestroy() {
  }

  override fun onServiceObtained() = checkForFiles()

  private fun extractDefaultScript(context: Context) = kotlin.runCatching {
    context.extractAssetsDir("scripts", NeoTermPath.USER_SCRIPT_PATH)
    scriptDir.listFiles().forEach {
      Os.chmod(it.absolutePath, 448 /*Dec of 0700*/)
    }
  }.onFailure {
    NLog.e("UserScript", "Failed to extract default user scripts: ${it.localizedMessage}")
  }

  private fun checkForFiles() {
    extractDefaultScript(App.get())
    reloadScripts()
  }

  private fun reloadScripts() {
    userScripts = scriptDir.listFiles()
      .takeWhile { it.canExecute() }
      .map { UserScript(it) }
      .toList()
  }
}

```

`app/src/main/java/io/neoterm/framework/NeoTermDatabase.java`:

```java
package io.neoterm.framework;

import android.content.Context;
import android.database.Cursor;
import android.database.SQLException;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import io.neoterm.App;
import io.neoterm.framework.database.*;
import io.neoterm.framework.database.bean.TableInfo;
import io.neoterm.framework.reflection.Reflect;
import io.neoterm.utils.NLog;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.*;

/**
 * @author Lody, Kiva
 * <p>
 * 基于<b>DTO(DataToObject)</b>映射的数据库操纵模型.
 * 通过少量可选的注解,即可构造数据模型.
 * 增删查改异常轻松.
 * @version 1.4
 */
public class NeoTermDatabase {

  /**
   * 缓存创建的数据库,以便防止数据库冲突.
   */
  private static final Map<String, NeoTermDatabase> DAO_MAP = new HashMap<>();

  /**
   * 数据库配置
   */
  private NeoTermSQLiteConfig neoTermSQLiteConfig;
  /**
   * 内部操纵的数据库执行类
   */
  private SQLiteDatabase db;

  /**
   * 默认构造器
   *
   * @param config
   */
  private NeoTermDatabase(NeoTermSQLiteConfig config) {

    this.neoTermSQLiteConfig = config;
    String saveDir = config.getSaveDir();
    if (saveDir != null
      && saveDir.trim().length() > 0) {
      this.db = createDataBaseFileOnSDCard(saveDir,
        config.getDatabaseName());
    } else {
      this.db = new SQLiteDataBaseHelper(App.Companion.get()
        .getApplicationContext()
        .getApplicationContext(), config)
        .getWritableDatabase();
    }

  }

  /**
   * 根据配置取得用于操纵数据库的WeLikeDao实例
   *
   * @param config
   * @return
   */
  public static NeoTermDatabase instance(NeoTermSQLiteConfig config) {
    if (config.getDatabaseName() == null) {
      throw new IllegalArgumentException("DBName is null in SqLiteConfig.");
    }
    NeoTermDatabase dao = DAO_MAP.get(config.getDatabaseName());
    if (dao == null) {
      dao = new NeoTermDatabase(config);
      synchronized (DAO_MAP) {
        DAO_MAP.put(config.getDatabaseName(), dao);
      }
    } else {//更换配置
      dao.applyConfig(config);
    }

    return dao;
  }

  /**
   * 根据默认配置取得操纵数据库的WeLikeDao实例
   *
   * @return
   */
  public static NeoTermDatabase instance() {
    return instance(NeoTermSQLiteConfig.DEFAULT_CONFIG);
  }

  /**
   * 取得操纵数据库的WeLikeDao实例
   *
   * @param dbName
   * @return
   */
  public static NeoTermDatabase instance(String dbName) {
    NeoTermSQLiteConfig config = new NeoTermSQLiteConfig();
    config.setDatabaseName(dbName);
    return instance(config);
  }

  /**
   * 取得操纵数据库的WeLikeDao实例
   *
   * @param dbVersion
   * @return
   */
  public static NeoTermDatabase instance(int dbVersion) {
    NeoTermSQLiteConfig config = new NeoTermSQLiteConfig();
    config.setDatabaseVersion(dbVersion);
    return instance(config);
  }

  /**
   * 取得操纵数据库的WeLikeDao实例
   *
   * @param listener
   * @return
   */
  public static NeoTermDatabase instance(OnDatabaseUpgradedListener listener) {
    NeoTermSQLiteConfig config = new NeoTermSQLiteConfig();
    config.setOnDatabaseUpgradedListener(listener);
    return instance(config);
  }

  /**
   * 取得操纵数据库的WeLikeDao实例
   *
   * @param dbName
   * @param dbVersion
   * @return
   */
  public static NeoTermDatabase instance(String dbName, int dbVersion) {
    NeoTermSQLiteConfig config = new NeoTermSQLiteConfig();
    config.setDatabaseName(dbName);
    config.setDatabaseVersion(dbVersion);
    return instance(config);
  }

  /**
   * 取得操纵数据库的WeLikeDao实例
   *
   * @param dbName
   * @param dbVersion
   * @param listener
   * @return
   */
  public static NeoTermDatabase instance(String dbName, int dbVersion, OnDatabaseUpgradedListener listener) {
    NeoTermSQLiteConfig config = new NeoTermSQLiteConfig();
    config.setDatabaseName(dbName);
    config.setDatabaseVersion(dbVersion);
    config.setOnDatabaseUpgradedListener(listener);
    return instance(config);
  }

  /**
   * 配置为新的参数(不改变数据库名).
   *
   * @param config
   */
  private void applyConfig(NeoTermSQLiteConfig config) {
    this.neoTermSQLiteConfig.debugMode = config.debugMode;
    this.neoTermSQLiteConfig.setOnDatabaseUpgradedListener(config.getOnDatabaseUpgradedListener());
  }

  public void release() {
    DAO_MAP.clear();
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.d("缓存的DAO已经全部清除,将不占用内存.");
    }
  }


  /**
   * 在SD卡的指定目录上创建数据库文件
   *
   * @param sdcardPath sd卡路径
   * @param dbFileName 数据库文件名
   * @return
   */
  private SQLiteDatabase createDataBaseFileOnSDCard(String sdcardPath,
                                                    String dbFileName) {
    File dbFile = new File(sdcardPath, dbFileName);
    if (!dbFile.exists()) {
      try {
        if (dbFile.createNewFile()) {
          return SQLiteDatabase.openOrCreateDatabase(dbFile, null);
        }
      } catch (IOException e) {
        throw new RuntimeException("无法在 " + dbFile.getAbsolutePath() + "创建DB文件.");
      }
    } else {
      //数据库文件已经存在,无需再次创建.
      return SQLiteDatabase.openOrCreateDatabase(dbFile, null);
    }
    return null;
  }

  /**
   * 如果表不存在,需要创建它.
   *
   * @param clazz
   */
  private void createTableIfNeed(Class<?> clazz) {
    TableInfo tableInfo = TableHelper.from(clazz);
    if (tableInfo.isCreate) {
      return;
    }
    if (!isTableExist(tableInfo)) {
      String sql = SQLStatementHelper.createTable(tableInfo);
      if (neoTermSQLiteConfig.debugMode) {
        NLog.INSTANCE.w(sql);
      }
      db.execSQL(sql);
      Method afterTableCreateMethod = tableInfo.afterTableCreateMethod;
      if (afterTableCreateMethod != null) {
        //如果afterTableMethod存在,就调用它
        try {
          afterTableCreateMethod.invoke(null, this);
        } catch (Throwable ignore) {
          ignore.printStackTrace();
        }
      }
    }
  }

  /**
   * 判断表是否存在?
   *
   * @param table 需要盘的的表
   * @return
   */
  private boolean isTableExist(TableInfo table) {
    String sql = "SELECT COUNT(*) AS c FROM sqlite_master WHERE type ='table' AND name ='"
      + table.tableName + "' ";
    try (Cursor cursor = db.rawQuery(sql, null)) {
      if (cursor != null && cursor.moveToNext()) {
        int count = cursor.getInt(0);
        if (count > 0) {
          return true;
        }
      }
    } catch (Throwable ignore) {
      ignore.printStackTrace();
    }

    return false;
  }

  /**
   * 删除全部的表
   */
  public void dropAllTable() {
    try (Cursor cursor = db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type ='table'", null)) {
      if (cursor != null) {
        cursor.moveToFirst();
        while (cursor.moveToNext()) {
          try {
            dropTable(cursor.getString(0));
          } catch (SQLException ignore) {
            ignore.printStackTrace();
          }
        }
      }
    }
  }

  /**
   * 取得数据库中的表的数量
   *
   * @return 表的数量
   */
  public int tableCount() {
    try (Cursor cursor = db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type ='table'", null)) {
      return cursor == null ? 0 : cursor.getCount();
    }
  }

  /**
   * 取得数据库中的所有表名组成的List.
   *
   * @return
   */
  public List<String> getTableList() {
    try (Cursor cursor = db.rawQuery(
      "SELECT name FROM sqlite_master WHERE type ='table'", null)) {
      List<String> tableList = new ArrayList<>();
      if (cursor != null) {
        cursor.moveToFirst();
        while (cursor.moveToNext()) {
          tableList.add(cursor.getString(0));
        }
      }
      return tableList;
    }
  }

  /**
   * 删除一张表
   *
   * @param beanClass 表所对应的类
   */
  public void dropTable(Class<?> beanClass) {
    TableInfo tableInfo = TableHelper.from(beanClass);
    dropTable(tableInfo.tableName);
    tableInfo.isCreate = false;
  }

  /**
   * 删除一张表
   *
   * @param tableName 表名
   */
  public void dropTable(String tableName) {
    String statement = "DROP TABLE IF EXISTS " + tableName;
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.w(statement);
    }
    db.execSQL(statement);
    TableInfo tableInfo = TableHelper.findTableInfoByName(tableName);
    if (tableInfo != null) {
      tableInfo.isCreate = false;
    }
  }

  /**
   * 存储一个Bean.
   *
   * @param bean
   * @return
   */
  public <T> NeoTermDatabase saveBean(T bean) {
    createTableIfNeed(bean.getClass());
    String statement = SQLStatementHelper.insertIntoTable(bean);
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.w(statement);
    }
    db.execSQL(statement);
    return this;

  }

  /**
   * 存储多个Bean.
   *
   * @param beans
   * @return
   */
  public NeoTermDatabase saveBeans(Object[] beans) {
    for (Object o : beans) {
      saveBean(o);
    }

    return this;
  }

  /**
   * 存储多个Bean.
   *
   * @param beans
   * @return
   */
  public <T> NeoTermDatabase saveBeans(List<T> beans) {
    for (Object o : beans) {
      saveBean(o);
    }

    return this;
  }

  /**
   * 寻找Bean对应的全部数据
   *
   * @param clazz
   * @param <T>
   * @return
   */
  public <T> List<T> findAll(Class<?> clazz) {
    createTableIfNeed(clazz);
    TableInfo tableInfo = TableHelper.from(clazz);
    String statement = SQLStatementHelper.selectTable(tableInfo.tableName);
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.w(statement);
    }
    List<T> list = new ArrayList<T>();
    try (Cursor cursor = db.rawQuery(statement, null)) {
      if (cursor == null) {
        // DO NOT RETURN NULL
        // null checks are ugly!
        return Collections.emptyList();
      }

      while (cursor.moveToNext()) {
        T object = Reflect.on(clazz).create().get();

        if (tableInfo.containID) {
          DatabaseDataType dataType = SQLTypeParser.getDataType(tableInfo.primaryField);
          String idFieldName = tableInfo.primaryField.getName();
          ValueHelper.setKeyValue(cursor, object, tableInfo.primaryField, dataType, cursor.getColumnIndex(idFieldName));
        }

        for (Field field : tableInfo.fieldToDataTypeMap.keySet()) {
          DatabaseDataType dataType = tableInfo.fieldToDataTypeMap.get(field);
          ValueHelper.setKeyValue(cursor, object, field, dataType, cursor.getColumnIndex(field.getName()));
        }
        list.add(object);
      }
      return list;
    }
  }

  /**
   * 根据where语句寻找Bean
   *
   * @param clazz
   * @param <T>
   * @return
   */
  public <T> List<T> findBeanByWhere(Class<?> clazz, String where) {
    createTableIfNeed(clazz);
    TableInfo tableInfo = TableHelper.from(clazz);
    String statement = SQLStatementHelper.findByWhere(tableInfo, where);
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.w(statement);
    }
    List<T> list = new ArrayList<>();
    try (Cursor cursor = db.rawQuery(statement, null)) {
      if (cursor == null) {
        // DO NOT RETURN NULL
        // null checks are ugly!
        return Collections.emptyList();
      }

      while (cursor.moveToNext()) {
        T object = Reflect.on(clazz).create().get();
        if (tableInfo.containID) {
          DatabaseDataType dataType = SQLTypeParser.getDataType(tableInfo.primaryField);
          String idFieldName = tableInfo.primaryField.getName();
          ValueHelper.setKeyValue(cursor, object, tableInfo.primaryField, dataType, cursor.getColumnIndex(idFieldName));
        }
        for (Field field : tableInfo.fieldToDataTypeMap.keySet()) {
          DatabaseDataType dataType = tableInfo.fieldToDataTypeMap.get(field);
          ValueHelper.setKeyValue(cursor, object, field, dataType, cursor.getColumnIndex(field.getName()));
        }
        list.add(object);
      }
      return list;
    }
  }

  public <T> T findOneBeanByWhere(Class<?> clazz, String where) {
    List<T> list = findBeanByWhere(clazz, where);
    if (!list.isEmpty()) {
      return list.get(0);
    }
    return null;
  }

  /**
   * 根据where语句删除Bean
   *
   * @param clazz
   * @return
   */
  public NeoTermDatabase deleteBeanByWhere(Class<?> clazz, String where) {
    createTableIfNeed(clazz);
    TableInfo tableInfo = TableHelper.from(clazz);
    String statement = SQLStatementHelper.deleteByWhere(tableInfo, where);
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.w(statement);
    }
    try {
      db.execSQL(statement);
    } catch (SQLException ignore) {
      ignore.printStackTrace();
    }

    return this;
  }

  /**
   * 删除指定ID的bean
   *
   * @param tableClass
   * @param id
   * @return 删除的Bean
   */
  public NeoTermDatabase deleteBeanByID(Class<?> tableClass, Object id) {
    createTableIfNeed(tableClass);
    TableInfo tableInfo = TableHelper.from(tableClass);
    DatabaseDataType dataType = SQLTypeParser.getDataType(id.getClass());
    if (dataType != null && tableInfo.primaryField != null) {
      //判断ID类型是否与数据类型匹配
      boolean match = SQLTypeParser.matchType(tableInfo.primaryField, dataType);
      if (!match) {//不匹配,抛出异常
        throw new IllegalArgumentException("类型 " + id.getClass().getName() + " 不是主键的类型,主键的类型应该为 " + tableInfo.primaryField.getType().getName());
      }
    }
    String idValue = ValueHelper.valueToString(dataType, id);
    String statement = SQLStatementHelper.deleteByWhere(tableInfo, tableInfo.primaryField == null ? "_id" : tableInfo.primaryField.getName() + " = " + idValue);
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.w(statement);
    }

    try {
      db.execSQL(statement);
    } catch (SQLException ignore) {
      ignore.printStackTrace();
      //删除失败
    }
    return this;

  }

  /**
   * 根据给定的where更新数据
   *
   * @param tableClass
   * @param where
   * @param bean
   * @return
   */
  public NeoTermDatabase updateByWhere(Class<?> tableClass, String where, Object bean) {
    createTableIfNeed(tableClass);
    TableInfo tableInfo = TableHelper.from(tableClass);
    String statement = SQLStatementHelper.updateByWhere(tableInfo, bean, where);
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.d(statement);
    }
    db.execSQL(statement);
    return this;
  }

  /**
   * 根据给定的id更新数据
   *
   * @param tableClass
   * @param id
   * @param bean
   * @return
   */
  public NeoTermDatabase updateByID(Class<?> tableClass, Object id, Object bean) {
    createTableIfNeed(tableClass);
    TableInfo tableInfo = TableHelper.from(tableClass);
    StringBuilder subStatement = new StringBuilder();
    if (tableInfo.containID) {
      subStatement.append(tableInfo.primaryField.getName()).append(" = ").append(ValueHelper.valueToString(SQLTypeParser.getDataType(tableInfo.primaryField), id));
    } else {
      subStatement.append("_id = ").append((int) id);
    }
    updateByWhere(tableClass, subStatement.toString(), bean);

    return this;
  }

  /**
   * 根据ID查找Bean
   *
   * @param tableClass
   * @param id
   * @param <T>
   * @return
   */
  public <T> T findBeanByID(Class<?> tableClass, Object id) {
    createTableIfNeed(tableClass);
    TableInfo tableInfo = TableHelper.from(tableClass);
    DatabaseDataType dataType = SQLTypeParser.getDataType(id.getClass());
    if (dataType == null) {
      return null;
    }
    // 判断ID类型是否与数据类型匹配
    boolean match = SQLTypeParser.matchType(tableInfo.primaryField, dataType) || tableInfo.primaryField == null;
    if (!match) {// 不匹配,抛出异常
      throw new IllegalArgumentException("Type " + id.getClass().getName() + " is not the primary key, expecting " + tableInfo.primaryField.getType().getName());
    }
    String idValue = ValueHelper.valueToString(dataType, id);
    String statement = SQLStatementHelper.findByWhere(tableInfo, tableInfo.primaryField == null ? "_id" : tableInfo.primaryField.getName() + " = " + idValue);
    if (neoTermSQLiteConfig.debugMode) {
      NLog.INSTANCE.w(statement);
    }

    try (Cursor cursor = db.rawQuery(statement, null)) {
      if (cursor != null && cursor.getCount() > 0) {
        cursor.moveToFirst();
        T bean = Reflect.on(tableClass).create().get();
        for (Field field : tableInfo.fieldToDataTypeMap.keySet()) {
          DatabaseDataType fieldType = tableInfo.fieldToDataTypeMap.get(field);
          ValueHelper.setKeyValue(cursor, bean, field, fieldType, cursor.getColumnIndex(field.getName()));
        }
        try {
          Reflect.on(bean).set(tableInfo.containID ? tableInfo.primaryField.getName() : "_id", id);
        } catch (Throwable ignore) {
          // 我们允许Bean没有id字段,因此此异常可以忽略
        }
        return bean;
      }
      return null;
    }
  }

  /**
   * 通过 VACUUM 命令压缩数据库
   */
  public void vacuum() {
    db.execSQL("VACUUM");
  }

  /**
   * 调用本方法会释放当前数据库占用的内存,
   * 调用后请确保你不会在接下来的代码中继续用到本实例.
   */
  public void destroy() {
    DAO_MAP.remove(this);
    this.neoTermSQLiteConfig = null;
    this.db = null;
  }

  /**
   * 取得内部操纵的SqliteDatabase.
   *
   * @return
   */
  public SQLiteDatabase getDatabase() {
    return db;
  }

  /**
   * 内部数据库监听器,负责派发接口.
   */
  private class SQLiteDataBaseHelper extends SQLiteOpenHelper {
    private final OnDatabaseUpgradedListener onDatabaseUpgradedListener;
    private final boolean defaultDropAllTables;

    public SQLiteDataBaseHelper(Context context, NeoTermSQLiteConfig config) {
      super(context, config.getDatabaseName(), null, config.getDatabaseVersion());
      this.onDatabaseUpgradedListener = config.getOnDatabaseUpgradedListener();
      this.defaultDropAllTables = config.isDefaultDropAllTables();
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
      if (onDatabaseUpgradedListener != null) {
        onDatabaseUpgradedListener.onDatabaseUpgraded(db, oldVersion, newVersion);

      } else if (defaultDropAllTables) { // 干掉所有的表
        dropAllTable();
      }
    }
  }
}

```

`app/src/main/java/io/neoterm/framework/database/DatabaseDataType.java`:

```java
package io.neoterm.framework.database;

/**
 * @author kiva
 */
public enum DatabaseDataType {
  /**
   * int类型
   */
  INTEGER,
  /**
   * String类型
   */
  TEXT,
  /**
   * float类型
   */
  FLOAT,
  /**
   * long类型
   */
  BIGINT,
  /**
   * double类型
   */
  DOUBLE;

  boolean nullable = true;

  /**
   * 数据类型是否允许为null
   */
  public DatabaseDataType nullable(boolean nullable) {
    this.nullable = nullable;
    return this;
  }

}

```

`app/src/main/java/io/neoterm/framework/database/NeoTermSQLiteConfig.java`:

```java
package io.neoterm.framework.database;

import java.io.Serializable;

/**
 * @author kiva
 */
public class NeoTermSQLiteConfig implements Serializable {

  private static final long serialVersionUID = -4069725570156436316L;
  //==============================================================
  //                          常量
  //==============================================================
  public static String DEFAULT_DB_NAME = "we_like.db";
  public static NeoTermSQLiteConfig DEFAULT_CONFIG = new NeoTermSQLiteConfig();

  //==============================================================
  //                          字段
  //==============================================================
  /**
   * 是否为DEBUG模式
   */
  public boolean debugMode = false;
  /**
   * 数据库名
   */
  private String dbName = DEFAULT_DB_NAME;
  /**
   * 数据库升级监听器
   */
  private OnDatabaseUpgradedListener onDatabaseUpgradedListener;
  private boolean defaultDropAllTables = false;
  private String saveDir;
  private int dbVersion = 1;

  /**
   * 取得数据库的名称
   *
   * @return
   */
  public String getDatabaseName() {
    return dbName;
  }

  /**
   * 设置数据库的名称
   *
   * @param dbName
   */
  public void setDatabaseName(String dbName) {
    this.dbName = dbName;
  }

  /**
   * 取得数据库升级监听器
   *
   * @return
   */
  public OnDatabaseUpgradedListener getOnDatabaseUpgradedListener() {
    return onDatabaseUpgradedListener;
  }

  /**
   * 设置数据库升级监听器
   *
   * @param onDatabaseUpgradedListener
   */
  public void setOnDatabaseUpgradedListener(OnDatabaseUpgradedListener onDatabaseUpgradedListener) {
    this.onDatabaseUpgradedListener = onDatabaseUpgradedListener;
  }

  /**
   * 取得数据库保存目录
   *
   * @return
   */
  public String getSaveDir() {
    return saveDir;
  }

  /**
   * 设置数据库的保存目录
   *
   * @param saveDir
   */
  public void setSaveDir(String saveDir) {
    this.saveDir = saveDir;
  }

  /**
   * 获取DB的版本号
   *
   * @return
   */
  public int getDatabaseVersion() {
    return dbVersion;
  }

  /**
   * 设置DB的版本号
   *
   * @param dbVersion
   */
  public void setDatabaseVersion(int dbVersion) {
    this.dbVersion = dbVersion;
  }

  /**
   * App 更新时是否默认删除所有存在的表
   *
   * @return
   */
  public boolean isDefaultDropAllTables() {
    return defaultDropAllTables;
  }

  /**
   * 设置 App 更新时是否默认删除所有存在的表
   *
   * @param defaultDropAllTables
   */
  public void setDefaultDropAllTables(boolean defaultDropAllTables) {
    this.defaultDropAllTables = defaultDropAllTables;
  }
}

```

`app/src/main/java/io/neoterm/framework/database/OnDatabaseUpgradedListener.java`:

```java
package io.neoterm.framework.database;

import android.database.sqlite.SQLiteDatabase;

/**
 * @author kiva
 */
public interface OnDatabaseUpgradedListener {
  /**
   * @param db         数据库
   * @param oldVersion 旧版本
   * @param newVersion 新版本
   */
  void onDatabaseUpgraded(SQLiteDatabase db, int oldVersion, int newVersion);
}
```

`app/src/main/java/io/neoterm/framework/database/SQLStatementHelper.java`:

```java
package io.neoterm.framework.database;

import io.neoterm.framework.database.annotation.ID;
import io.neoterm.framework.database.bean.TableInfo;

import java.lang.reflect.Field;

/**
 * @author kiva
 */
public class SQLStatementHelper {

  /**
   * 构造<b>创建表</b>的语句
   *
   * @param tableInfo 表信息
   * @return 创建表的SQL语句
   */
  public static String createTable(TableInfo tableInfo) {
    StringBuilder statement = new StringBuilder();

    statement.append("CREATE TABLE ").append("'")
      .append(tableInfo.tableName).append("'")
      .append(" (");

    if (tableInfo.containID) {
      DatabaseDataType dataType = SQLTypeParser.getDataType(tableInfo.primaryField);
      if (dataType == null) {
        throw new IllegalArgumentException("Type of " + tableInfo.primaryField.getType().getName() + " is not support in WelikeDB.");
      }
      statement.append("'").append(tableInfo.primaryField.getName()).append("'");
      switch (dataType) {
        case INTEGER:
          statement.append(" INTEGER PRIMARY KEY ");
          ID id = tableInfo.primaryField.getAnnotation(ID.class);
          if (id != null && id.autoIncrement()) {
            statement.append("AUTOINCREMENT");
          }
          break;
        default:
          statement
            .append("  ")
            .append(dataType.name())
            .append(" PRIMARY KEY");
      }

      statement.append(",");


    } else {
      statement.append("'_id' INTEGER PRIMARY KEY AUTOINCREMENT,");
    }


    for (Field field : tableInfo.fieldToDataTypeMap.keySet()) {
      DatabaseDataType dataType = tableInfo.fieldToDataTypeMap.get(field);
      statement.append("'").append(field.getName()).append("'")
        .append(" ")
        .append(dataType.name());
      if (!dataType.nullable) {
        statement.append(" NOT NULL");
      }
      statement.append(",");
    }
    //删掉最后一个逗号
    statement.deleteCharAt(statement.length() - 1);
    statement.append(")");

    return statement.toString();
  }

  /**
   * 构建 插入一个Bean 的语句.
   *
   * @param o
   * @return
   */
  public static String insertIntoTable(Object o) {
    TableInfo tableInfo = TableHelper.from(o.getClass());
    StringBuilder statement = new StringBuilder();
    statement.append("INSERT INTO ").append(tableInfo.tableName).append(" ");
    statement.append("VALUES(");

    if (tableInfo.containID) {
      DatabaseDataType primaryDataType = SQLTypeParser.getDataType(tableInfo.primaryField);
      switch (primaryDataType) {
        case INTEGER:
          statement.append("NULL,");
          break;
        default:
          try {
            statement
              .append(ValueHelper.valueToString(primaryDataType, tableInfo.primaryField, o))
              .append(",");
          } catch (IllegalAccessException ignored) {
          }
          break;
      }

    } else {
      statement.append("NULL,");
    }

    for (Field field : tableInfo.fieldToDataTypeMap.keySet()) {
      DatabaseDataType dataType = tableInfo.fieldToDataTypeMap.get(field);
      try {
        statement.append(ValueHelper.valueToString(dataType, field, o)).append(",");
      } catch (IllegalAccessException e) {
        //不会发生...
      }
    }
    statement.deleteCharAt(statement.length() - 1);
    statement.append(")");

    return statement.toString();

  }

  /**
   * 根据where条件创建选择语句
   *
   * @param tableInfo
   * @param where
   * @return
   */
  public static String findByWhere(TableInfo tableInfo, String where) {
    StringBuilder statement = new StringBuilder("SELECT * FROM ");
    statement
      .append(tableInfo.tableName)
      .append(" ")
      .append("WHERE ")
      .append(where);

    return statement.toString();
  }


  /**
   * 根据where条件创建删除语句
   *
   * @param tableInfo
   * @param where
   * @return
   */
  public static String deleteByWhere(TableInfo tableInfo, String where) {
    StringBuilder statement = new StringBuilder("DELETE FROM ");
    statement
      .append(tableInfo.tableName)
      .append(" ")
      .append("WHERE ")
      .append(where);

    return statement.toString();
  }

  /**
   * 根据where条件创建更新语句
   *
   * @param tableInfo
   * @param bean
   * @param where
   * @return
   */
  public static String updateByWhere(TableInfo tableInfo, Object bean, String where) {
    StringBuilder builder = new StringBuilder("UPDATE ");

    builder.append(tableInfo.tableName).append(" SET ");

    for (Field f : tableInfo.fieldToDataTypeMap.keySet()) {

      try {
        builder.append(f.getName())
          .append(" = ")
          .append(ValueHelper.valueToString(
            SQLTypeParser.getDataType(f.getType()),
            f.get(bean))).append(",");
      } catch (Throwable ignored) {
      }
    }

    builder.deleteCharAt(builder.length() - 1);//删除最后一个逗号

    builder.append(" WHERE ");
    builder.append(where);
    return builder.toString();
  }

  /**
   * 创建选中table的语句
   *
   * @param tableName
   * @return
   */
  public static String selectTable(String tableName) {
    return "SELECT * FROM " + tableName;
  }

}

```

`app/src/main/java/io/neoterm/framework/database/SQLTypeParser.java`:

```java
package io.neoterm.framework.database;

import io.neoterm.framework.database.annotation.Ignore;
import io.neoterm.framework.database.annotation.NotNull;

import java.lang.reflect.Field;

/**
 * @author kiva
 */
public class SQLTypeParser {
  /**
   * 根据字段类型匹配它在数据库中的对应类型.
   *
   * @param field
   * @return
   */
  public static DatabaseDataType getDataType(Field field) {
    Class<?> clazz = field.getType();
    if (clazz == (String.class)) {
      return DatabaseDataType.TEXT.nullable((field.getAnnotation(NotNull.class) == null));
    } else if (clazz == (int.class) || clazz == (Integer.class)) {
      return DatabaseDataType.INTEGER.nullable((field.getAnnotation(NotNull.class) == null));
    } else if (clazz == (float.class) || clazz == (Float.class)) {
      return DatabaseDataType.FLOAT.nullable((field.getAnnotation(NotNull.class) == null));
    } else if (clazz == (long.class) || clazz == (Long.class)) {
      return DatabaseDataType.BIGINT.nullable((field.getAnnotation(NotNull.class) == null));
    } else if (clazz == (double.class) || clazz == (Double.class)) {
      return DatabaseDataType.DOUBLE.nullable((field.getAnnotation(NotNull.class) == null));
    } else if (clazz == (boolean.class) || clazz == (Boolean.class)) {
      return DatabaseDataType.INTEGER.nullable((field.getAnnotation(NotNull.class) == null));
    }
    return null;
  }

  /**
   * 根据字段类型匹配它在数据库中的对应类型.
   *
   * @param clazz
   * @return
   */
  public static DatabaseDataType getDataType(Class<?> clazz) {
    if (clazz == (String.class)) {
      return DatabaseDataType.TEXT;
    } else if (clazz == (int.class) || clazz == (Integer.class)) {
      return DatabaseDataType.INTEGER;
    } else if (clazz == (float.class) || clazz == (Float.class)) {
      return DatabaseDataType.FLOAT;
    } else if (clazz == (long.class) || clazz == (Long.class)) {
      return DatabaseDataType.BIGINT;
    } else if (clazz == (double.class) || clazz == (Double.class)) {
      return DatabaseDataType.DOUBLE;
    } else if (clazz == (boolean.class) || clazz == (Boolean.class)) {
      return DatabaseDataType.INTEGER;
    }
    return null;
  }

  /**
   * 字段类型与数据类型是否匹配?
   *
   * @param field
   * @param dataType
   * @return
   */
  public static boolean matchType(Field field, DatabaseDataType dataType) {
    DatabaseDataType fieldDataType = getDataType(field.getType());

    return dataType != null && fieldDataType == (dataType);
  }

  /**
   * 字段是否可以被数据库忽略?
   *
   * @param field
   * @return
   */
  public static boolean isIgnore(Field field) {
    return field.getAnnotation(Ignore.class) != null;
  }
}

```

`app/src/main/java/io/neoterm/framework/database/TableHelper.java`:

```java
package io.neoterm.framework.database;

import io.neoterm.framework.NeoTermDatabase;
import io.neoterm.framework.database.annotation.ID;
import io.neoterm.framework.database.annotation.Table;
import io.neoterm.framework.database.bean.TableInfo;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.HashMap;
import java.util.Map;

/**
 * @author kiva
 */
public class TableHelper {
  private static final Map<Class<?>, TableInfo> classToTableInfoMap = new HashMap<>();

  /**
   * 根据传入的Bean的Class将其映射为一个TableInfo.
   *
   * @param clazz
   * @return
   */
  public static TableInfo from(Class<?> clazz) {
    TableInfo tableInfo = classToTableInfoMap.get(clazz);
    if (tableInfo != null) {
      return tableInfo;
    }
    tableInfo = new TableInfo();
    //Table注解解析
    Table table = clazz.getAnnotation(Table.class);
    String afterTableCreateMethod = table != null ? table.afterTableCreate() : null;
    if (afterTableCreateMethod != null && afterTableCreateMethod.trim().length() > 0) {
      try {
        Method method = clazz.getDeclaredMethod(afterTableCreateMethod, NeoTermDatabase.class);
        if (method != null && Modifier.isStatic(method.getModifiers())) {
          method.setAccessible(true);
          tableInfo.afterTableCreateMethod = method;
        }
      } catch (Throwable ignored) {
      }
    }
    if (table != null && table.name().trim().length() != 0) {
      tableInfo.tableName = table.name();
    } else {
      tableInfo.tableName = clazz.getName().replace(".", "_");
    }

    Map<Field, DatabaseDataType> fieldEnumMap = new HashMap<>();
    for (Field field : clazz.getDeclaredFields()) {
      field.setAccessible(true);
      //如果这个字段加了ignore注解,我们就跳过
      if (SQLTypeParser.isIgnore(field)) {
        continue;
      }
      DatabaseDataType dataType = SQLTypeParser.getDataType(field);
      if (dataType != null) {
        fieldEnumMap.put(field, dataType);
      } else {
        throw new IllegalArgumentException("The type of " + field.getName() + " is not supported in database.");
      }
    }

    tableInfo.fieldToDataTypeMap = fieldEnumMap;
    buildPrimaryIDForTableInfo(tableInfo);
    tableInfo.createTableStatement = SQLStatementHelper.createTable(tableInfo);

    synchronized (classToTableInfoMap) {
      classToTableInfoMap.put(clazz, tableInfo);
    }
    return tableInfo;
  }

  /**
   * 为一个Bean匹配一个ID字段,如果ID字段不存在,使用默认的_id替代.
   *
   * @param info
   * @return
   */
  private static TableInfo buildPrimaryIDForTableInfo(TableInfo info) {

    Field idField = null;
    ID id;
    for (Field field : info.fieldToDataTypeMap.keySet()) {
      id = field.getAnnotation(ID.class);
      if (id != null) {
        idField = field;
        break;
      }
    }//end
    if (idField != null) {
      //从字段表中移除ID
      info.fieldToDataTypeMap.remove(idField);
      info.containID = true;
      info.primaryField = idField;
    } else {
      info.containID = false;
      info.primaryField = null;
    }

    return info;
  }

  /**
   * 根据表名匹配TableInfo
   *
   * @param tableName
   * @return
   */
  public static TableInfo findTableInfoByName(String tableName) {

    for (TableInfo tableInfo : classToTableInfoMap.values()) {
      if (tableInfo.tableName.equals(tableName)) {
        return tableInfo;
      }
    }

    return null;
  }

  /**
   * 清除留在内存中的TableInfo缓存
   */
  public static void clearCache() {
    classToTableInfoMap.clear();
  }

}



```

`app/src/main/java/io/neoterm/framework/database/ValueHelper.java`:

```java
package io.neoterm.framework.database;

import android.database.Cursor;

import java.lang.reflect.Field;

/**
 * @author kiva
 */
public class ValueHelper {

  /**
   * 根据数据类型将数据库中的值写入到相应的字段.
   *
   * @param cursor   游标
   * @param object   赋值对象
   * @param field    赋值字段
   * @param dataType 数据类型
   */
  public static void setKeyValue(Cursor cursor, Object object, Field field, DatabaseDataType dataType, int index) {
    switch (dataType) {
      case INTEGER:
        try {
          field.set(object, cursor.getInt(index));
        } catch (Throwable e) {
          try {
            //支持Boolean类型
            //因为Boolean默认当Integer处理
            field.set(object, cursor.getInt(index) != 0);
          } catch (IllegalAccessException ignored) {
          }
        }
        break;
      case TEXT:
        try {
          field.set(object, cursor.getString(index));
        } catch (IllegalAccessException e) {
        }
        break;
      case FLOAT:
        try {
          field.set(object, cursor.getFloat(index));
        } catch (IllegalAccessException e) {
        }
        break;
      case BIGINT:
        try {
          field.set(object, cursor.getLong(index));
        } catch (IllegalAccessException e) {
        }
        break;
      case DOUBLE:
        try {
          field.set(object, cursor.getDouble(index));
        } catch (IllegalAccessException e) {
        }
        break;

    }
  }

  /**
   * 根据数据类型从字段中提取值并转换为String
   *
   * @param dataType
   * @param field
   * @param o
   * @return
   * @throws IllegalAccessException 无法转换时抛出的异常
   */
  public static String valueToString(DatabaseDataType dataType, Field field, Object o) throws IllegalAccessException {
    switch (dataType) {
      case INTEGER:
        Object f = field.get(o);
        if (f instanceof Boolean) {
          return String.valueOf(((boolean) field.get(o)) ? 1 : 0);
        } else {
          return String.valueOf((int) field.get(o));
        }
      case TEXT:
        return "\"" + field.get(o) + "" + "\"";
      case DOUBLE:
        return String.valueOf((double) field.get(o));
      case FLOAT:
        return String.valueOf((float) field.get(o));
      case BIGINT:
        return String.valueOf((long) field.get(o));
    }
    return null;
  }

  /**
   * 根据数据类型将对象转换为String
   *
   * @param dataType
   * @param o
   * @return
   */
  public static String valueToString(DatabaseDataType dataType, Object o) {
    switch (dataType) {
      case INTEGER:
        if (o instanceof Boolean) {
          return ((boolean) o) ? "1" : "0";
        } else {
          return String.valueOf((int) o);
        }
      case TEXT:
        return "\"" + o + "\"";
      case DOUBLE:
        return String.valueOf((double) o);
      case FLOAT:
        return String.valueOf((float) o);
      case BIGINT:
        return String.valueOf((long) o);
    }
    return null;
  }
}

```

`app/src/main/java/io/neoterm/framework/database/annotation/ID.java`:

```java
package io.neoterm.framework.database.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author kiva
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface ID {
  /**
   * 只对Integer类型的ID字段有效
   *
   * @return 是否为自增长
   */
  boolean autoIncrement() default false;
}

```

`app/src/main/java/io/neoterm/framework/database/annotation/Ignore.java`:

```java
package io.neoterm.framework.database.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author kiva
 */
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.FIELD})
public @interface Ignore {
}

```

`app/src/main/java/io/neoterm/framework/database/annotation/NotNull.java`:

```java
package io.neoterm.framework.database.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author kiva
 */
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface NotNull {
}

```

`app/src/main/java/io/neoterm/framework/database/annotation/Table.java`:

```java
package io.neoterm.framework.database.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * @author kiva
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Table {
  /**
   * @return 表名
   */
  String name() default "";

  /**
   * @return 在表创建后需要回调的方法
   */
  String afterTableCreate() default "";
}

```

`app/src/main/java/io/neoterm/framework/database/bean/TableInfo.java`:

```java
package io.neoterm.framework.database.bean;


import io.neoterm.framework.database.DatabaseDataType;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Map;

/**
 * @author kiva
 */
public class TableInfo {

  /**
   * 是否包含ID
   */
  public boolean containID;
  /**
   * 主键字段
   */
  public Field primaryField;

  /**
   * 表名
   */
  public String tableName;

  /**
   * 字段表
   */
  public Map<Field, DatabaseDataType> fieldToDataTypeMap;

  /**
   * 创建table的语句
   */
  public String createTableStatement;

  /**
   * 是否已经创建
   */
  public boolean isCreate = false;

  public Method afterTableCreateMethod;

}

```

`app/src/main/java/io/neoterm/framework/reflection/NullPointer.java`:

```java
package io.neoterm.framework.reflection;

/**
 * class representing null pointer.
 *
 * @author kiva
 */
public class NullPointer {
}
```

`app/src/main/java/io/neoterm/framework/reflection/Reflect.java`:

```java
package io.neoterm.framework.reflection;

import java.lang.reflect.*;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Make reflections easier and elegant.
 *
 * @author kiva
 */
public class Reflect {
  private final Object mObject;
  private final boolean isClass;

  private Reflect(Class<?> type) {
    this.mObject = type;
    this.isClass = true;
  }

  private Reflect(Object object) {
    this.mObject = object;
    this.isClass = false;
  }

  /**
   * Create reflector from class name.
   *
   * @param name Full class name
   * @return Reflector
   * @throws ReflectionException If any error occurs
   * @see #on(Class)
   */
  public static Reflect on(String name) throws ReflectionException {
    return on(forName(name));
  }

  /**
   * Create reflector from class name using given class loader.
   *
   * @param name        Full class name
   * @param classLoader Given class loader
   * @return Reflector
   * @throws ReflectionException If any error occurs
   * @see #on(Class)
   */
  public static Reflect on(String name, ClassLoader classLoader) throws ReflectionException {
    return on(forName(name, classLoader));
  }

  /**
   * Create reflector from given class type.
   * Helpful especially when you want to access static fields.
   *
   * @param clazz Given class type
   * @return Reflector
   */
  public static Reflect on(Class<?> clazz) {
    return new Reflect(clazz);
  }

  /**
   * Wrap an object and return its reflector.<p>
   * Helpful especially when you want to access instance fields and methods on any {@link Object}
   *
   * @param object The object to be wrapped
   * @return Reflector
   */
  public static Reflect on(Object object) {
    return new Reflect(object);
  }

  private static Reflect on(Method method, Object receiver, Object... args) throws ReflectionException {
    try {
      makeAccessible(method);

      if (method.getReturnType() == void.class) {
        method.invoke(receiver, args);
        return on(receiver);
      } else {
        return on(method.invoke(receiver, args));
      }
    } catch (Exception e) {
      throw new ReflectionException(e);
    }
  }

  /**
   * Make an {@link AccessibleObject} accessible.
   *
   * @param accessible
   * @param <T>
   * @return
   */
  public static <T extends AccessibleObject> T makeAccessible(T accessible) {
    if (accessible == null) {
      return null;
    }

    if (accessible instanceof Member) {
      Member member = (Member) accessible;

      if (Modifier.isPublic(member.getModifiers()) &&
        Modifier.isPublic(member.getDeclaringClass().getModifiers())) {

        return accessible;
      }
    }

    if (!accessible.isAccessible()) {
      accessible.setAccessible(true);
    }

    return accessible;
  }

  private static String property(String string) {
    int length = string.length();

    if (length == 0) {
      return "";
    } else if (length == 1) {
      return string.toLowerCase();
    } else {
      return string.substring(0, 1).toLowerCase() + string.substring(1);
    }
  }

  private static Reflect on(Constructor<?> constructor, Object... args) throws ReflectionException {
    try {
      return on(makeAccessible(constructor).newInstance(args));
    } catch (Exception e) {
      throw new ReflectionException(e);
    }
  }

  /**
   * If we are wrapping another reflector, get its real object.
   */
  private static Object unwrap(Object object) {
    if (object instanceof Reflect) {
      return ((Reflect) object).get();
    }

    return object;
  }

  /**
   * Convert object arrays into elements' class type arrays.
   * If encountered {@code null}, use {@link NullPointer}'s class type instead.
   *
   * @see Object#getClass()
   */
  private static Class<?>[] convertTypes(Object... values) {
    if (values == null) {
      return new Class[0];
    }

    Class<?>[] result = new Class[values.length];

    for (int i = 0; i < values.length; i++) {
      Object value = values[i];
      result[i] = value == null ? NullPointer.class : value.getClass();
    }

    return result;
  }

  /**
   * Get a class type of a class, which may cause its static-initialization
   *
   * @see Class#forName(String)
   */
  private static Class<?> forName(String name) throws ReflectionException {
    try {
      return Class.forName(name);
    } catch (Exception e) {
      throw new ReflectionException(e);
    }
  }

  private static Class<?> forName(String name, ClassLoader classLoader) throws ReflectionException {
    try {
      return Class.forName(name, true, classLoader);
    } catch (Exception e) {
      throw new ReflectionException(e);
    }
  }

  /**
   * Wrap primitive class types into object class types.
   *
   * @param type Class type that may be primitive class type
   * @return Wrapped class type
   */
  private static Class<?> wrapClassType(Class<?> type) {
    if (type == null) {
      return null;
    } else if (type.isPrimitive()) {
      if (boolean.class == type) {
        return Boolean.class;
      } else if (int.class == type) {
        return Integer.class;
      } else if (long.class == type) {
        return Long.class;
      } else if (short.class == type) {
        return Short.class;
      } else if (byte.class == type) {
        return Byte.class;
      } else if (double.class == type) {
        return Double.class;
      } else if (float.class == type) {
        return Float.class;
      } else if (char.class == type) {
        return Character.class;
      } else if (void.class == type) {
        return Void.class;
      }
    }

    return type;
  }

  /**
   * Get the real object that reflector operates.
   *
   * @param <T> The type of the real object.
   * @return The real object.
   */
  @SuppressWarnings("unchecked")
  public <T> T get() {
    return (T) mObject;
  }

  /**
   * Set a field to given value.
   *
   * @param name  Field name
   * @param value New value
   * @return Reflector
   * @throws ReflectionException If any error occurs
   */
  public Reflect set(String name, Object value) throws ReflectionException {
    try {
      Field field = lookupField(name);
      field.setAccessible(true);
      field.set(mObject, unwrap(value));
      return this;
    } catch (Exception e) {
      throw new ReflectionException(e);
    }
  }

  /**
   * Get the value of given field
   *
   * @param name Field name
   * @param <T>  The type of value
   * @return Value
   * @throws ReflectionException If any error occurs
   */
  public <T> T get(String name) throws ReflectionException {
    return field(name).get();
  }

  /**
   * Get field by name.
   *
   * @param name Field name
   * @return {@link Field}
   * @throws ReflectionException If any error occurs
   */
  public Reflect field(String name) throws ReflectionException {
    try {
      Field field = lookupField(name);
      return on(field.get(mObject));
    } catch (Exception e) {
      throw new ReflectionException(e);
    }
  }

  private Field lookupField(String name) throws ReflectionException {
    Class<?> type = type();

    // 先尝试取得公有字段
    try {
      return type.getField(name);
    }

    //此时尝试非公有字段
    catch (NoSuchFieldException e) {
      do {
        try {
          return makeAccessible(type.getDeclaredField(name));
        } catch (NoSuchFieldException ignore) {
        }

        type = type.getSuperclass();
      }
      while (type != null);

      throw new ReflectionException(e);
    }
  }

  /**
   * Load all fields into a map, the key is field name and the value is its reflector.
   *
   * @return Map to all fields.
   */
  public Map<String, Reflect> fields() {
    Map<String, Reflect> result = new LinkedHashMap<String, Reflect>();
    Class<?> type = type();

    do {
      for (Field field : type.getDeclaredFields()) {
        if (!isClass ^ Modifier.isStatic(field.getModifiers())) {
          String name = field.getName();

          if (!result.containsKey(name))
            result.put(name, field(name));
        }
      }

      type = type.getSuperclass();
    }
    while (type != null);

    return result;
  }

  /**
   * Call a method by name without parameters.
   *
   * @param name Method name
   * @return Reflector to the return value of the method
   * @throws ReflectionException If any error occurs
   */
  public Reflect call(String name) throws ReflectionException {
    return call(name, new Object[0]);
  }

  /**
   * Call a method by name and parameters.
   *
   * @param name Method name
   * @param args Parameters
   * @return Reflector to the return value of the method
   * @throws ReflectionException If any error occurs
   */
  public Reflect call(String name, Object... args) throws ReflectionException {
    Class<?>[] types = convertTypes(args);

    try {
      Method method = exactMethod(name, types);
      return on(method, mObject, args);
    } catch (NoSuchMethodException e) {
      try {
        Method method = lookupSimilarMethod(name, types);
        return on(method, mObject, args);
      } catch (NoSuchMethodException e1) {
        throw new ReflectionException(e1);
      }
    }
  }

  private Method exactMethod(String name, Class<?>[] types) throws NoSuchMethodException {
    Class<?> type = type();

    try {
      return type.getMethod(name, types);
    } catch (NoSuchMethodException e) {
      do {
        try {
          return type.getDeclaredMethod(name, types);
        } catch (NoSuchMethodException ignore) {
        }

        type = type.getSuperclass();
      }
      while (type != null);

      throw new NoSuchMethodException();
    }
  }

  /**
   * Find a method that is similar to the wanted one.
   */
  private Method lookupSimilarMethod(String name, Class<?>[] types) throws NoSuchMethodException {
    Class<?> type = type();

    for (Method method : type.getMethods()) {
      if (isSignatureSimilar(method, name, types)) {
        return method;
      }
    }

    do {
      for (Method method : type.getDeclaredMethods()) {
        if (isSignatureSimilar(method, name, types)) {
          return method;
        }
      }

      type = type.getSuperclass();
    }
    while (type != null);

    throw new NoSuchMethodException("No similar method " + name + " with params " + Arrays.toString(types) + " could be found on type " + type() + ".");
  }

  private boolean isSignatureSimilar(Method possiblyMatchingMethod,
                                     String wantedMethodName,
                                     Class<?>[] wantedParamTypes) {
    return possiblyMatchingMethod.getName().equals(wantedMethodName)
      && match(possiblyMatchingMethod.getParameterTypes(), wantedParamTypes);
  }

  /**
   * Create an instance using its default constructor.
   *
   * @return Reflector to the return value of the method
   * @throws ReflectionException If any error occurs
   */
  public Reflect create() throws ReflectionException {
    return create(new Object[0]);
  }

  /**
   * Create an instance by parameters.
   *
   * @param args Parameters
   * @return Reflector to the return value of the method
   * @throws ReflectionException If any error occurs
   */
  public Reflect create(Object... args) throws ReflectionException {
    Class<?>[] types = convertTypes(args);


    try {
      Constructor<?> constructor = type().getDeclaredConstructor(types);
      return on(constructor, args);
    } catch (NoSuchMethodException e) {
      for (Constructor<?> constructor : type().getDeclaredConstructors()) {
        if (match(constructor.getParameterTypes(), types)) {
          return on(constructor, args);
        }
      }

      throw new ReflectionException(e);
    }
  }

  /**
   * Create a dynamic proxy based on the given type.
   * If we are maintaining a Map and error occurs when calling methods,
   * we will return value from Map as return value.
   * Helpful especially when creating default data handlers.
   *
   * @param proxyType The type to be proxy-ed
   * @return Proxy object
   */
  @SuppressWarnings("unchecked")
  public <P> P as(Class<P> proxyType) {
    final boolean isMap = (mObject instanceof Map);
    final InvocationHandler handler = (proxy, method, args) -> {
      String name = method.getName();
      try {
        return on(mObject).call(name, args).get();
      } catch (ReflectionException e) {
        if (isMap) {
          Map<String, Object> map = (Map<String, Object>) mObject;
          int length = (args == null ? 0 : args.length);

          // Pay special attention to those getters and setters
          if (length == 0 && name.startsWith("get")) {
            return map.get(property(name.substring(3)));
          } else if (length == 0 && name.startsWith("is")) {
            return map.get(property(name.substring(2)));
          } else if (length == 1 && name.startsWith("set")) {
            map.put(property(name.substring(3)), args[0]);
            return null;
          }
        }

        throw e;
      }
    };

    return (P) Proxy.newProxyInstance(proxyType.getClassLoader(),
      new Class[]{proxyType}, handler);
  }

  /**
   * Check whether types matches to avoid {@link ClassCastException} when calling a method.
   * If encountered primitive type, convert to object type first.
   */
  private boolean match(Class<?>[] declaredTypes, Class<?>[] actualTypes) {
    if (declaredTypes.length == actualTypes.length) {
      for (int i = 0; i < actualTypes.length; i++) {
        // nulls are acceptable on any occasions
        if (actualTypes[i] == NullPointer.class) {
          continue;
        }

        if (wrapClassType(declaredTypes[i]).isAssignableFrom(wrapClassType(actualTypes[i]))) {
          continue;
        }
        return false;
      }

      return true;
    } else {
      return false;
    }
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public int hashCode() {
    return mObject.hashCode();
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public boolean equals(Object obj) {
    if (obj instanceof Reflect) {
      return mObject.equals(((Reflect) obj).get());
    }

    return false;
  }

  /**
   * {@inheritDoc}
   */
  @Override
  public String toString() {
    return mObject.toString();
  }

  /**
   * Get the class type of the real object that reflector operates.
   *
   * @see Object#getClass()
   */
  public Class<?> type() {
    if (isClass) {
      return (Class<?>) mObject;
    } else {
      return mObject.getClass();
    }
  }
}

```

`app/src/main/java/io/neoterm/framework/reflection/ReflectionException.java`:

```java
package io.neoterm.framework.reflection;

/**
 * @author kiva
 */
public class ReflectionException extends RuntimeException {
  ReflectionException(Throwable cause) {
    super(cause);
  }
}

```

`app/src/main/java/io/neoterm/frontend/completion/CandidatePopupWindow.kt`:

```kt
package io.neoterm.frontend.completion

import android.content.Context
import android.view.Gravity
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.BaseAdapter
import android.widget.ListView
import android.widget.PopupWindow
import android.widget.TextView
import io.neoterm.R
import io.neoterm.backend.TerminalColors
import io.neoterm.component.ComponentManager
import io.neoterm.component.colorscheme.ColorSchemeComponent
import io.neoterm.component.completion.CompletionCandidate
import io.neoterm.component.completion.OnCandidateSelectedListener
import io.neoterm.frontend.session.view.TerminalView

/**
 * @author kiva
 */
class CandidatePopupWindow(val context: Context) {
  var candidates: List<CompletionCandidate>? = null
  var onCandidateSelectedListener: OnCandidateSelectedListener? = null

  private var popupWindow: PopupWindow? = null
  private var wantsToFinish = false
  private var candidateAdapter: CandidateAdapter? = null
  private var candidateListView: ListView? = null

  fun show(terminalView: TerminalView) {
    if (popupWindow == null && !wantsToFinish) {
      popupWindow = createPopupWindow()
    }

    candidateAdapter?.notifyDataSetChanged()

    val popWindow = popupWindow
    if (popWindow != null) {
      // Ensure that the popup window will not cover the IME.
      val rootView = popWindow.contentView
      if (rootView is MaxHeightView) {
        rootView.maxHeight = terminalView.height
      }

      popWindow.showAtLocation(
        terminalView, Gravity.BOTTOM.and(Gravity.START),
        terminalView.cursorAbsoluteX,
        terminalView.cursorAbsoluteY,
      )
    }
  }

  fun dismiss() {
    popupWindow?.dismiss()
  }

  fun isShowing(): Boolean {
    return popupWindow?.isShowing ?: false
  }

  private fun createPopupWindow(): PopupWindow {
    val popupWindow = PopupWindow(context)
    popupWindow.isOutsideTouchable = true
    popupWindow.isTouchable = true
    val contentView = LayoutInflater.from(context).inflate(R.layout.popup_auto_complete, null, false)
    val listView = contentView.findViewById<ListView>(R.id.popup_complete_candidate_list)
    candidateAdapter = CandidateAdapter(this)
    listView.adapter = candidateAdapter
    listView.setOnItemClickListener { _, _, position, _ ->
      val selectedItem = candidates?.get(position)
      if (selectedItem != null) {
        onCandidateSelectedListener?.onCandidateSelected(selectedItem)
      }
    }

    candidateListView = listView
    popupWindow.contentView = contentView
    return popupWindow
  }

  fun cleanup() {
    wantsToFinish = true
    popupWindow = null
    candidateListView = null
    candidateAdapter = null
    candidates = null
  }

  class CandidateAdapter(val candidatePopupWindow: CandidatePopupWindow) : BaseAdapter() {
    override fun getView(position: Int, convertView: View?, parent: ViewGroup?): View {
      var convertView = convertView
      val viewHolder: CandidateViewHolder =
        if (convertView != null) {
          convertView.tag as CandidateViewHolder
        } else {
          convertView = LayoutInflater.from(candidatePopupWindow.context)
            .inflate(R.layout.item_complete_candidate, null, false)
          val viewHolder = CandidateViewHolder(convertView)
          convertView.tag = viewHolder
          viewHolder
        }

      val candidate = getItem(position) as CompletionCandidate
      viewHolder.apply {
        display.text = candidate.displayName
        if (candidate.description != null) {
          splitView.visibility = View.VISIBLE
          description.visibility = View.VISIBLE
          description.text = candidate.description
        } else {
          splitView.visibility = View.GONE
          description.visibility = View.GONE
        }
      }
      return convertView!!
    }

    override fun getItem(position: Int): Any? {
      return candidatePopupWindow.candidates?.get(position)
    }

    override fun getItemId(position: Int): Long {
      return position.toLong()
    }

    override fun getCount(): Int {
      return candidatePopupWindow.candidates?.size ?: 0
    }
  }

  class CandidateViewHolder(rootView: View) {
    val display: TextView = rootView.findViewById<TextView>(R.id.complete_display)
    val description: TextView = rootView.findViewById<TextView>(R.id.complete_description)
    val splitView: View = rootView.findViewById(R.id.complete_split)

    init {
      val colorScheme = ComponentManager.getComponent<ColorSchemeComponent>().getCurrentColorScheme()
      val textColor = TerminalColors.parse(colorScheme.foregroundColor)
      display.setTextColor(textColor)
      description.setTextColor(textColor)
    }
  }
}

```

`app/src/main/java/io/neoterm/frontend/completion/MaxHeightView.kt`:

```kt
package io.neoterm.frontend.completion

import android.content.Context
import android.util.AttributeSet
import android.view.View
import android.widget.LinearLayout

class MaxHeightView : LinearLayout {
  var maxHeight = -1

  constructor(context: Context) : super(context)
  constructor(context: Context, attrs: AttributeSet) : super(context, attrs)
  constructor(context: Context, attrs: AttributeSet, defStyle: Int) : super(context, attrs, defStyle)

  override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
    var finalHeightMeasureSpec = heightMeasureSpec

    if (maxHeight > 0) {
      val heightMode = View.MeasureSpec.getMode(heightMeasureSpec)
      var heightSize = View.MeasureSpec.getSize(heightMeasureSpec)

      if (heightMode == View.MeasureSpec.EXACTLY) {
        heightSize = if (heightSize <= maxHeight)
          heightSize
        else
          maxHeight
      }

      if (heightMode == View.MeasureSpec.UNSPECIFIED) {
        heightSize = if (heightSize <= maxHeight)
          heightSize
        else
          maxHeight
      }
      if (heightMode == View.MeasureSpec.AT_MOST) {
        heightSize = if (heightSize <= maxHeight)
          heightSize
        else
          maxHeight
      }
      finalHeightMeasureSpec = View.MeasureSpec.makeMeasureSpec(
        heightSize,
        heightMode
      )
    }

    super.onMeasure(widthMeasureSpec, finalHeightMeasureSpec)
  }
}

```

`app/src/main/java/io/neoterm/frontend/floating/dialog.kt`:

```kt
package io.neoterm.frontend.floating

import android.annotation.SuppressLint
import android.content.Context
import android.content.DialogInterface
import android.view.LayoutInflater
import android.view.View
import androidx.appcompat.app.AlertDialog
import io.neoterm.R
import io.neoterm.backend.TerminalSession
import io.neoterm.component.session.ShellParameter
import io.neoterm.component.session.ShellTermSession
import io.neoterm.frontend.session.terminal.BasicSessionCallback
import io.neoterm.frontend.session.terminal.BasicViewClient
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.TerminalViewClient
import io.neoterm.utils.Terminals

typealias DialogSessionFinished = (TerminalDialog, TerminalSession?) -> Unit

class TerminalDialog(val context: Context) {
  private val termWindowView = WindowTermView(context)
  private val terminalSessionCallback: BasicSessionCallback
  private var dialog: AlertDialog? = null
  private var terminalSession: TerminalSession? = null
  private var sessionFinishedCallback: DialogSessionFinished? = null
  private var cancelListener: DialogInterface.OnCancelListener? = null

  init {
    termWindowView.setTerminalViewClient(BasicViewClient(termWindowView.terminalView))
    terminalSessionCallback = object : BasicSessionCallback(termWindowView.terminalView) {
      override fun onSessionFinished(finishedSession: TerminalSession?) {
        sessionFinishedCallback?.let { it(this@TerminalDialog, finishedSession) }
        super.onSessionFinished(finishedSession)
      }
    }
  }

  fun execute(executablePath: String, arguments: Array<String>?): TerminalDialog {
    if (terminalSession != null) {
      terminalSession?.finishIfRunning()
    }

    dialog = AlertDialog.Builder(context)
      .setView(termWindowView.rootView)
      .setOnCancelListener {
        terminalSession?.finishIfRunning()
        cancelListener?.onCancel(it)
      }
      .create()

    val parameter = ShellParameter()
      .executablePath(executablePath)
      .arguments(arguments)
      .callback(terminalSessionCallback)
      .systemShell(false)
    terminalSession = Terminals.createSession(context, parameter)
    if (terminalSession is ShellTermSession) {
      (terminalSession as ShellTermSession).exitPrompt = context.getString(R.string.process_exit_prompt_press_back)
    }
    termWindowView.attachSession(terminalSession)
    return this
  }

  fun onDismiss(cancelListener: DialogInterface.OnCancelListener?): TerminalDialog {
    this.cancelListener = cancelListener
    return this
  }

  fun setTitle(title: String?): TerminalDialog {
    dialog?.setTitle(title)
    return this
  }

  fun onFinish(finishedCallback: DialogSessionFinished): TerminalDialog {
    this.sessionFinishedCallback = finishedCallback
    return this
  }

  fun show(title: String?) {
    dialog?.setTitle(title)
    dialog?.setCanceledOnTouchOutside(false)
    dialog?.show()
  }

  fun dismiss(): TerminalDialog {
    dialog?.dismiss()
    return this
  }

  fun imeEnabled(enabled: Boolean): TerminalDialog {
    if (enabled) {
      termWindowView.setInputMethodEnabled(true)
    }
    return this
  }
}

class WindowTermView(val context: Context) {
  @SuppressLint("InflateParams")
  var rootView: View = LayoutInflater.from(context).inflate(R.layout.ui_term_dialog, null, false)
    private set
  var terminalView: TerminalView = rootView.findViewById<TerminalView>(R.id.terminal_view_dialog)
    private set

  init {
    Terminals.setupTerminalView(terminalView)
  }

  fun setTerminalViewClient(terminalViewClient: TerminalViewClient?) {
    terminalView.setTerminalViewClient(terminalViewClient)
  }

  fun attachSession(terminalSession: TerminalSession?) {
    terminalView.attachSession(terminalSession)
  }

  fun setInputMethodEnabled(enabled: Boolean) {
    terminalView.isFocusable = enabled
    terminalView.isFocusableInTouchMode = enabled
  }
}

```

`app/src/main/java/io/neoterm/frontend/session/terminal/data.kt`:

```kt
package io.neoterm.frontend.session.terminal

import io.neoterm.backend.TerminalSession
import io.neoterm.component.completion.OnAutoCompleteListener
import io.neoterm.component.session.ShellProfile
import io.neoterm.component.session.ShellTermSession
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView

class TermSessionData {
  var termSession: TerminalSession? = null
  var sessionCallback: TermSessionCallback? = null
  var viewClient: TermViewClient? = null
  var onAutoCompleteListener: OnAutoCompleteListener? = null

  var termUI: TermUiPresenter? = null
  var termView: TerminalView? = null
  var extraKeysView: ExtraKeysView? = null

  var profile: ShellProfile? = null

  fun cleanup() {
    onAutoCompleteListener?.onCleanUp()
    onAutoCompleteListener = null

    sessionCallback?.termSessionData = null
    viewClient?.termSessionData = null

    termUI = null
    termView = null
    extraKeysView = null
    termSession = null

    profile = null
  }

  fun initializeSessionWith(
    session: TerminalSession,
    sessionCallback: TermSessionCallback?,
    viewClient: TermViewClient?
  ) {
    this.termSession = session
    this.sessionCallback = sessionCallback
    this.viewClient = viewClient
    this.sessionCallback?.termSessionData = this
    this.viewClient?.termSessionData = this

    if (session is ShellTermSession) {
      profile = session.shellProfile
    }
  }

  fun initializeViewWith(termUI: TermUiPresenter?, termView: TerminalView?, eks: ExtraKeysView?) {
    this.termUI = termUI
    this.termView = termView
    this.extraKeysView = eks
  }
}

interface TermUiPresenter {
  fun requireClose()
  fun requireToggleFullScreen()
  fun requirePaste()
  fun requireUpdateTitle(title: String?)
  fun requireOnSessionFinished()
  fun requireHideIme()
  fun requireFinishAutoCompletion(): Boolean
  fun requireCreateNew()
  fun requireSwitchToPrevious()
  fun requireSwitchToNext()
  fun requireSwitchTo(index: Int)
}

```

`app/src/main/java/io/neoterm/frontend/session/terminal/events.kt`:

```kt
package io.neoterm.frontend.session.terminal

import io.neoterm.ui.term.TermTab

class CreateNewSessionEvent
class SwitchIndexedSessionEvent(val index: Int)
class SwitchSessionEvent(val toNext: Boolean)
class TabCloseEvent(val termTab: TermTab)
class TitleChangedEvent(val title: String)
class ToggleFullScreenEvent
class ToggleImeEvent

```

`app/src/main/java/io/neoterm/frontend/session/terminal/term-basic.kt`:

```kt
package io.neoterm.frontend.session.terminal

import android.content.Context
import android.view.KeyEvent
import android.view.MotionEvent
import android.view.inputmethod.InputMethodManager
import io.neoterm.backend.TerminalSession
import io.neoterm.component.config.NeoPreference
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.TerminalViewClient

open class BasicSessionCallback(var terminalView: TerminalView) : TerminalSession.SessionChangedCallback {
  override fun onTextChanged(changedSession: TerminalSession?) {
    if (changedSession != null) {
      terminalView.onScreenUpdated()
    }
  }

  override fun onTitleChanged(changedSession: TerminalSession?) {
  }

  override fun onSessionFinished(finishedSession: TerminalSession?) {
  }

  override fun onClipboardText(session: TerminalSession?, text: String?) {
  }

  override fun onBell(session: TerminalSession?) {
  }

  override fun onColorsChanged(session: TerminalSession?) {
    if (session != null) {
      terminalView.onScreenUpdated()
    }
  }
}

class BasicViewClient(val terminalView: TerminalView) : TerminalViewClient {
  override fun onScale(scale: Float): Float {
    if (scale < 0.9f || scale > 1.1f) {
      val increase = scale > 1f
      val changedSize = (if (increase) 1 else -1) * 2
      val fontSize = NeoPreference.validateFontSize(terminalView.textSize + changedSize)
      terminalView.textSize = fontSize
      return 1.0f
    }
    return scale
  }

  override fun onSingleTapUp(e: MotionEvent?) {
    if (terminalView.isFocusable && terminalView.isFocusableInTouchMode) {
      (terminalView.context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager)
        .showSoftInput(terminalView, InputMethodManager.SHOW_IMPLICIT)
    }
  }

  override fun shouldBackButtonBeMappedToEscape(): Boolean {
    return false
  }

  override fun copyModeChanged(copyMode: Boolean) {
  }

  override fun onKeyDown(keyCode: Int, e: KeyEvent?, session: TerminalSession?): Boolean {
    return false
  }

  override fun onKeyUp(keyCode: Int, e: KeyEvent?): Boolean {
    return false
  }

  override fun readControlKey(): Boolean {
    return false
  }

  override fun readAltKey(): Boolean {
    return false
  }

  override fun onCodePoint(codePoint: Int, ctrlDown: Boolean, session: TerminalSession?): Boolean {
    return false
  }

  override fun onLongPress(event: MotionEvent?): Boolean {
    return false
  }
}

```

`app/src/main/java/io/neoterm/frontend/session/terminal/term-standard.kt`:

```kt
package io.neoterm.frontend.session.terminal

import android.content.ClipData
import android.content.ClipboardManager
import android.content.Context
import android.media.AudioManager
import android.media.SoundPool
import android.os.Vibrator
import android.util.Log
import android.view.InputDevice
import android.view.KeyEvent
import android.view.MotionEvent
import android.view.View
import android.view.inputmethod.InputMethodManager
import io.neoterm.BuildConfig
import io.neoterm.R
import io.neoterm.backend.KeyHandler
import io.neoterm.backend.TerminalSession
import io.neoterm.component.ComponentManager
import io.neoterm.component.completion.*
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.extrakey.ExtraKeyComponent
import io.neoterm.component.session.ShellTermSession
import io.neoterm.frontend.completion.CandidatePopupWindow
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.TerminalViewClient
import java.util.*

/**
 * @author kiva
 */
class TermViewClient(val context: Context) : TerminalViewClient {
  private var mVirtualControlKeyDown: Boolean = false
  private var mVirtualFnKeyDown: Boolean = false
  private var lastTitle: String = ""

  var termSessionData: TermSessionData? = null

  override fun onScale(scale: Float): Float {
    if (scale < 0.9f || scale > 1.1f) {
      val increase = scale > 1f
      changeFontSize(increase)
      return 1.0f
    }
    return scale
  }

  override fun onSingleTapUp(e: MotionEvent?) {
    val termView = termSessionData?.termView ?: return
    (context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager)
      .showSoftInput(termView, InputMethodManager.SHOW_IMPLICIT)
  }

  override fun shouldBackButtonBeMappedToEscape(): Boolean {
    val shellSession = termSessionData?.termSession as ShellTermSession? ?: return false
    return shellSession.shellProfile.enableBackKeyToEscape
  }

  override fun copyModeChanged(copyMode: Boolean) {
    // TODO
  }

  override fun onKeyDown(keyCode: Int, e: KeyEvent?, session: TerminalSession?): Boolean {
    if (handleVirtualKeys(keyCode, e, true)) {
      return true
    }

    val termUI = termSessionData?.termUI

    when (keyCode) {
      KeyEvent.KEYCODE_ENTER -> {
        if (e?.action == KeyEvent.ACTION_DOWN && session?.isRunning == false) {
          termUI?.requireClose()
          return true
        }
        return false
      }
      KeyEvent.KEYCODE_BACK -> {
        if (e?.action == KeyEvent.ACTION_DOWN) {
          return termUI?.requireFinishAutoCompletion() ?: false
        }
        return false
      }
    }

    // TODO 自定义快捷键
    if (e != null && e.isCtrlPressed && e.isShiftPressed) {
      // Get the unmodified code point:
      val unicodeChar = e.getUnicodeChar(0).toChar()

      when (unicodeChar) {
        'v' -> termUI?.requirePaste()
        'n' -> termUI?.requireCreateNew()
        'z' -> termUI?.requireSwitchToPrevious()
        'x' -> termUI?.requireSwitchToNext()
        'f' -> termUI?.requireToggleFullScreen()
        '-' -> changeFontSize(false)
        '+' -> changeFontSize(true)
      }

      // 当要触发 NeoTerm 快捷键时，屏蔽所有终端处理key
      return true
    } else if (e != null && e.isAltPressed) {
      // Get the unmodified code point:
      val unicodeChar = e.getUnicodeChar(0).toChar()
      if (unicodeChar !in ('1'..'9')) {
        return false
      }

      // Use Alt + num to switch sessions
      val sessionIndex = unicodeChar.toInt() - '0'.toInt()
      termUI?.requireSwitchTo(sessionIndex)

      // 当要触发 NeoTerm 快捷键时，屏蔽所有终端处理key
      return true
    }
    return false
  }

  override fun onKeyUp(keyCode: Int, e: KeyEvent?): Boolean {
    return handleVirtualKeys(keyCode, e, false)
  }

  override fun readControlKey(): Boolean {
    val extraKeysView = termSessionData?.extraKeysView
    return (extraKeysView != null && extraKeysView.readControlButton()) || mVirtualControlKeyDown
  }

  override fun readAltKey(): Boolean {
    val extraKeysView = termSessionData?.extraKeysView
    return (extraKeysView != null && extraKeysView.readAltButton()) || mVirtualFnKeyDown
  }

  override fun onCodePoint(codePoint: Int, ctrlDown: Boolean, session: TerminalSession?): Boolean {
    if (mVirtualFnKeyDown) {
      var resultingKeyCode: Int = -1
      var resultingCodePoint: Int = -1
      var altDown = false
      val lowerCase = Character.toLowerCase(codePoint)
      when (lowerCase.toChar()) {
        // Arrow keys.
        'w' -> resultingKeyCode = KeyEvent.KEYCODE_DPAD_UP
        'a' -> resultingKeyCode = KeyEvent.KEYCODE_DPAD_LEFT
        's' -> resultingKeyCode = KeyEvent.KEYCODE_DPAD_DOWN
        'd' -> resultingKeyCode = KeyEvent.KEYCODE_DPAD_RIGHT

        // Page up and down.
        'p' -> resultingKeyCode = KeyEvent.KEYCODE_PAGE_UP
        'n' -> resultingKeyCode = KeyEvent.KEYCODE_PAGE_DOWN

        // Some special keys:
        't' -> resultingKeyCode = KeyEvent.KEYCODE_TAB
        'i' -> resultingKeyCode = KeyEvent.KEYCODE_INSERT
        'h' -> resultingCodePoint = '~'.toInt()

        // Special characters to input.
        'u' -> resultingCodePoint = '_'.toInt()
        'l' -> resultingCodePoint = '|'.toInt()

        // Function keys.
        '1', '2', '3', '4', '5', '6', '7', '8', '9' -> resultingKeyCode = codePoint - '1'.toInt() + KeyEvent.KEYCODE_F1
        '0' -> resultingKeyCode = KeyEvent.KEYCODE_F10

        // Other special keys.
        'e' -> resultingCodePoint = 27 /*Escape*/
        '.' -> resultingCodePoint = 28 /*^.*/

        'b' // alt+b, jumping backward in readline.
          , 'f' // alf+f, jumping forward in readline.
          , 'x' // alt+x, common in emacs.
        -> {
          resultingCodePoint = lowerCase
          altDown = true
        }

        // Volume control.
        'v' -> {
          resultingCodePoint = -1
          val audio = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
          audio.adjustSuggestedStreamVolume(
            AudioManager.ADJUST_SAME,
            AudioManager.USE_DEFAULT_STREAM_TYPE,
            AudioManager.FLAG_SHOW_UI
          )
        }
      }

      if (resultingKeyCode != -1) {
        if (session != null) {
          val term = session.emulator
          session.write(
            KeyHandler.getCode(
              resultingKeyCode,
              0,
              term.isCursorKeysApplicationMode,
              term.isKeypadApplicationMode
            )
          )
        }
      } else if (resultingCodePoint != -1) {
        session?.writeCodePoint(altDown, resultingCodePoint)
      }
      return true
    }
    return false
  }

  override fun onLongPress(event: MotionEvent?): Boolean {
    // TODO
    return false
  }

  private fun handleVirtualKeys(keyCode: Int, event: KeyEvent?, down: Boolean): Boolean {
    if (event == null) {
      return false
    }

    val shellSession = termSessionData?.termSession as ShellTermSession? ?: return false

    // Volume keys as special keys
    val volumeAsSpecialKeys = shellSession.shellProfile.enableSpecialVolumeKeys

    val inputDevice = event.device
    if (inputDevice != null && inputDevice.keyboardType == InputDevice.KEYBOARD_TYPE_ALPHABETIC) {
      return false
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_DOWN) {
      mVirtualControlKeyDown = down && volumeAsSpecialKeys
      return true
    } else if (keyCode == KeyEvent.KEYCODE_VOLUME_UP) {
      mVirtualFnKeyDown = down && volumeAsSpecialKeys
      return true
    }
    return false
  }

  fun updateExtraKeys(title: String?, force: Boolean = false) {
    val extraKeysView = termSessionData?.extraKeysView

    if (extraKeysView == null || title == null || title.isEmpty()) {
      return
    }

    if ((lastTitle != title || force)
      && updateExtraKeysVisibility()
    ) {
      removeExtraKeys()
      ComponentManager.getComponent<ExtraKeyComponent>().showShortcutKeys(title, extraKeysView)
      extraKeysView.updateButtons()
      lastTitle = title
    }
  }

  private fun updateExtraKeysVisibility(): Boolean {
    val extraKeysView = termSessionData?.extraKeysView ?: return false
    val shellSession = termSessionData?.termSession as ShellTermSession? ?: return false

    return if (shellSession.shellProfile.enableExtraKeys) {
      extraKeysView.visibility = View.VISIBLE
      true
    } else {
      extraKeysView.visibility = View.GONE
      false
    }
  }

  private fun removeExtraKeys() {
    val extraKeysView = termSessionData?.extraKeysView
    extraKeysView?.clearUserKeys()
  }

  private fun changeFontSize(increase: Boolean) {
    val termView = termSessionData?.termView
    if (termView != null) {
      val changedSize = (if (increase) 1 else -1) * 2
      val fontSize = NeoPreference.validateFontSize(termView.textSize + changedSize)
      termView.textSize = fontSize
      NeoPreference.store(NeoPreference.KEY_FONT_SIZE, fontSize)
    }
  }
}

/**
 * @author kiva
 */
class TermSessionCallback : TerminalSession.SessionChangedCallback {
  var termSessionData: TermSessionData? = null

  var bellController: BellController? = null

  override fun onTextChanged(changedSession: TerminalSession?) {
    termSessionData?.termView?.onScreenUpdated()
  }

  override fun onTitleChanged(changedSession: TerminalSession?) {
    if (changedSession?.title != null) {
      termSessionData?.termUI?.requireUpdateTitle(changedSession.title)
    }
  }

  override fun onSessionFinished(finishedSession: TerminalSession?) {
    termSessionData?.termUI?.requireOnSessionFinished()
  }

  override fun onClipboardText(session: TerminalSession?, text: String?) {
    val termView = termSessionData?.termView
    if (termView != null) {
      val clipboard = termView.context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
      clipboard.primaryClip = ClipData.newPlainText("", text)
    }
  }

  override fun onBell(session: TerminalSession?) {
    val termView = termSessionData?.termView ?: return
    val shellSession = session as ShellTermSession

    if (bellController == null) {
      bellController = BellController()
    }

    bellController?.bellOrVibrate(termView.context, shellSession)
  }

  override fun onColorsChanged(session: TerminalSession?) {
    val termView = termSessionData?.termView
    if (session != null && termView != null) {
      termView.onScreenUpdated()
    }
  }
}

class BellController {
  companion object {
    private val BELL_DELAY_MS = 100
  }

  private var bellId: Int = 0
  private var soundPool: SoundPool? = null
  private var lastBellTime = 0L

  fun bellOrVibrate(context: Context, session: ShellTermSession) {
    val currentTime = System.currentTimeMillis()
    if (currentTime - lastBellTime < BELL_DELAY_MS) {
      return
    }
    lastBellTime = currentTime

    if (session.shellProfile.enableBell) {
      if (soundPool == null) {
        soundPool = SoundPool.Builder().setMaxStreams(1).build()
        bellId = soundPool!!.load(context, R.raw.bell, 1)
      }
      soundPool?.play(bellId, 1f, 1f, 0, 0, 1f)
    }

    if (session.shellProfile.enableVibrate) {
      val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
      vibrator.vibrate(100)
    }
  }
}

class TermCompleteListener(var terminalView: TerminalView?) : OnAutoCompleteListener, OnCandidateSelectedListener {
  private val inputStack = Stack<Char>()
  private var popupWindow: CandidatePopupWindow? = null
  private var lastCompletedIndex = 0

  override fun onKeyCode(keyCode: Int, keyMod: Int) {
    when (keyCode) {
      KeyEvent.KEYCODE_DEL -> {
        popChar()
        fixLastCompletedIndex()
        triggerCompletion()
      }

      KeyEvent.KEYCODE_ENTER -> {
        clearChars()
        popupWindow?.dismiss()
      }
    }
  }

  private fun fixLastCompletedIndex() {
    val currentText = getCurrentEditingText()
    lastCompletedIndex = minOf(lastCompletedIndex, currentText.length - 1)
  }

  override fun onCompletionRequired(newText: String?) {
    if (newText == null || newText.isEmpty()) {
      return
    }
    pushString(newText)
    triggerCompletion()
  }

  override fun onCleanUp() {
    popupWindow?.dismiss()
    popupWindow?.cleanup()
    popupWindow = null
    terminalView = null
  }

  override fun onFinishCompletion(): Boolean {
    val popWindow = popupWindow ?: return false

    if (popWindow.isShowing()) {
      popWindow.dismiss()
      return true
    }
    return false
  }

  override fun onCandidateSelected(candidate: CompletionCandidate) {
    val session = terminalView?.currentSession ?: return
    val textNeedCompletion = getCurrentEditingText().substring(lastCompletedIndex + 1)
    val newText = candidate.completeString

    val deleteLength = newText.indexOf(textNeedCompletion) + textNeedCompletion.length
    if (deleteLength > 0) {
      for (i in 0 until deleteLength) {
        session.write("\b")
        popChar()
      }
    }

    if (BuildConfig.DEBUG) {
      Log.e(
        "NeoTerm-AC",
        "currentEditing: $textNeedCompletion, " +
          "deleteLength: $deleteLength, completeString: $newText"
      )
    }

    pushString(newText)
    session.write(newText)
    // Trigger next completion
    lastCompletedIndex = inputStack.size
    triggerCompletion()
  }

  private fun triggerCompletion() {
    val text = getCurrentEditingText()
    if (text.isEmpty()) {
      return
    }

    val result = CompletionManager.tryCompleteFor(text)
    if (!result.hasResult()) {
      // A provider accepted the task
      // But no candidates are provided
      // Give it zero angrily!
      result.markScore(0)
      onFinishCompletion()
      return
    }
    showAutoCompleteCandidates(result)
  }

  private fun showAutoCompleteCandidates(result: CompletionResult) {
    val termView = terminalView
    var popWindow = popupWindow

    if (termView == null) {
      return
    }

    if (popWindow == null) {
      popWindow = CandidatePopupWindow(termView.context)
      popWindow.onCandidateSelectedListener = this
      this.popupWindow = popWindow
    }

    popWindow.candidates = result.candidates
    popWindow.show(termView)
  }

  private fun getCurrentEditingText(): String {
    val builder = StringBuilder()
    val size = inputStack.size
    var start = inputStack.lastIndexOf(' ')
    if (start < 0) {
      // Yes, it is -1, we will do `start + 1` below.
      start = -1
    }

    IntRange(start + 1, size - 1)
      .map { inputStack[it] }
      .takeWhile { !(it == 0.toChar() || it == ' ') }
      .forEach { builder.append(it) }
    return builder.toString()
  }

  private fun clearChars() {
    inputStack.clear()
    lastCompletedIndex = 0
  }

  private fun popChar() {
    if (inputStack.isNotEmpty()) {
      inputStack.pop()
    }
  }

  private fun pushString(string: String) {
    string.toCharArray().forEach { pushChar(it) }
  }

  private fun pushChar(char: Char) {
    inputStack.push(char)
  }
}

```

`app/src/main/java/io/neoterm/frontend/session/view/GestureAndScaleRecognizer.kt`:

```kt
package io.neoterm.frontend.session.view

import android.content.Context
import android.view.GestureDetector
import android.view.InputDevice
import android.view.MotionEvent
import android.view.ScaleGestureDetector

/** A combination of [GestureDetector] and [ScaleGestureDetector].  */
internal class GestureAndScaleRecognizer(context: Context, val mListener: Listener) {

  interface Listener {
    fun onSingleTapUp(e: MotionEvent): Boolean

    fun onDoubleTap(e: MotionEvent): Boolean

    // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
    // e.g in vim, we can change window size with fingers moving.
    fun onDoubleTapEvent(e: MotionEvent): Boolean

    fun onScroll(e2: MotionEvent, dx: Float, dy: Float): Boolean

    fun onFling(e: MotionEvent, velocityX: Float, velocityY: Float): Boolean

    fun onScale(focusX: Float, focusY: Float, scale: Float): Boolean

    fun onDown(x: Float, y: Float): Boolean

    fun onUp(e: MotionEvent): Boolean

    fun onLongPress(e: MotionEvent)
  }

  private val mGestureDetector: GestureDetector
  private val mScaleDetector: ScaleGestureDetector
  var isAfterLongPress: Boolean = false

  init {

    mGestureDetector = GestureDetector(context, object : GestureDetector.SimpleOnGestureListener() {
      override fun onScroll(e1: MotionEvent, e2: MotionEvent, dx: Float, dy: Float): Boolean {
        return mListener.onScroll(e2, dx, dy)
      }

      override fun onFling(e1: MotionEvent, e2: MotionEvent, velocityX: Float, velocityY: Float): Boolean {
        return mListener.onFling(e2, velocityX, velocityY)
      }

      override fun onDown(e: MotionEvent): Boolean {
        return mListener.onDown(e.x, e.y)
      }

      override fun onLongPress(e: MotionEvent) {
        mListener.onLongPress(e)
        isAfterLongPress = true
      }
    }, null, true /* ignoreMultitouch */)

    mGestureDetector.setOnDoubleTapListener(object : GestureDetector.OnDoubleTapListener {
      override fun onSingleTapConfirmed(e: MotionEvent): Boolean {
        // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
        // e.g in vim, we can change window size with fingers moving.
        mListener.onUp(e)

        return mListener.onSingleTapUp(e)
      }

      override fun onDoubleTap(e: MotionEvent): Boolean {
        return mListener.onDoubleTap(e)
      }

      override fun onDoubleTapEvent(e: MotionEvent): Boolean {
        // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
        // e.g in vim, we can change window size with fingers moving.

        // Disable triggering long press which will prevent further double tap motion from
        // receiving, e.g. when you double tap and drag downwards slowly.
        if (!e.isFromSource(InputDevice.SOURCE_MOUSE)) {
          when (e.action) {
            MotionEvent.ACTION_DOWN ->
              mGestureDetector.setIsLongpressEnabled(false)
            MotionEvent.ACTION_UP ->
              mGestureDetector.setIsLongpressEnabled(true)
          }
          return mListener.onDoubleTapEvent(e)
        }
        return false
      }
    })

    mScaleDetector = ScaleGestureDetector(context, object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
      override fun onScaleBegin(detector: ScaleGestureDetector): Boolean {
        return true
      }

      override fun onScale(detector: ScaleGestureDetector): Boolean {
        return mListener.onScale(detector.focusX, detector.focusY, detector.scaleFactor)
      }
    })

    // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
    // e.g in vim, we can change window size with fingers moving.
    mScaleDetector.isQuickScaleEnabled = false;
  }

  fun onTouchEvent(event: MotionEvent) {
    mGestureDetector.onTouchEvent(event)
    mScaleDetector.onTouchEvent(event)

    // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
    // e.g in vim, we can change window size with fingers moving.
//        when (event.action) {
//            MotionEvent.ACTION_DOWN -> isAfterLongPress = false
//            MotionEvent.ACTION_UP -> if (!isAfterLongPress) {
//                // This behaviour is desired when in e.g. vim with mouse events, where we do not
//                // want to move the cursor when lifting finger after a long press.
//                mListener.onUp(event)
//            }
//        }
  }

  val isInProgress: Boolean
    get() = mScaleDetector.isInProgress

}

```

`app/src/main/java/io/neoterm/frontend/session/view/TerminalRenderer.java`:

```java
package io.neoterm.frontend.session.view;

import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.Typeface;
import io.neoterm.backend.*;

/**
 * Renderer of a {@link TerminalEmulator} into a {@link Canvas}.
 * <p/>
 * Saves font metrics, so needs to be recreated each time the typeface or font size changes.
 */
final class TerminalRenderer {

  final int mTextSize;
  final Typeface mTypeface;
  private final Paint mTextPaint = new Paint();

  /**
   * The width of a single mono spaced character obtained by {@link Paint#measureText(String)} on a single 'X'.
   */
  final float mFontWidth;
  /**
   * The {@link Paint#getFontSpacing()}. See http://www.fampennings.nl/maarten/android/08numgrid/font.png
   */
  final int mFontLineSpacing;
  /**
   * The {@link Paint#ascent()}. See http://www.fampennings.nl/maarten/android/08numgrid/font.png
   */
  private final int mFontAscent;
  /**
   * The {@link #mFontLineSpacing} + {@link #mFontAscent}.
   */
  final int mFontLineSpacingAndAscent;

  /**
   * AutoCompletion PopupWindow need them to show popup window
   */
  protected float savedLastDrawnLineX;
  protected float savedLastDrawnLineY;

  private final float[] asciiMeasures = new float[127];

  public TerminalRenderer(int textSize, Typeface typeface) {
    mTextSize = textSize;
    mTypeface = typeface;

    mTextPaint.setTypeface(typeface);
    mTextPaint.setAntiAlias(true);
    mTextPaint.setTextSize(textSize);

    mFontLineSpacing = (int) Math.ceil(mTextPaint.getFontSpacing());
    mFontAscent = (int) Math.ceil(mTextPaint.ascent());
    mFontLineSpacingAndAscent = mFontLineSpacing + mFontAscent;
    mFontWidth = mTextPaint.measureText("X");

    StringBuilder sb = new StringBuilder(" ");
    for (int i = 0; i < asciiMeasures.length; i++) {
      sb.setCharAt(0, (char) i);
      asciiMeasures[i] = mTextPaint.measureText(sb, 0, 1);
    }
  }

  /**
   * Render the terminal to a canvas with at a specified row scroll, and an optional rectangular selection.
   */
  public final void render(TerminalEmulator mEmulator, Canvas canvas, int topRow,
                           int selectionY1, int selectionY2, int selectionX1, int selectionX2) {
    final boolean reverseVideo = mEmulator.isReverseVideo();
    final int endRow = topRow + mEmulator.mRows;
    final int columns = mEmulator.mColumns;
    final int cursorCol = mEmulator.getCursorCol();
    final int cursorRow = mEmulator.getCursorRow();
    final boolean cursorVisible = mEmulator.isShowingCursor();
    final TerminalBuffer screen = mEmulator.getScreen();
    final int[] palette = mEmulator.mColors.mCurrentColors;
    final int cursorShape = mEmulator.getCursorStyle();

    if (reverseVideo)
      canvas.drawColor(palette[TextStyle.COLOR_INDEX_FOREGROUND], PorterDuff.Mode.SRC);

    float heightOffset = mFontLineSpacingAndAscent;
    for (int row = topRow; row < endRow; row++) {
      heightOffset += mFontLineSpacing;

      final int cursorX = (row == cursorRow && cursorVisible) ? cursorCol : -1;
      int selx1 = -1, selx2 = -1;
      if (row >= selectionY1 && row <= selectionY2) {
        if (row == selectionY1) selx1 = selectionX1;
        selx2 = (row == selectionY2) ? selectionX2 : mEmulator.mColumns;
      }

      TerminalRow lineObject = screen.allocateFullLineIfNecessary(screen.externalToInternalRow(row));
      final char[] line = lineObject.mText;
      final int charsUsedInLine = lineObject.getSpaceUsed();

      long lastRunStyle = 0;
      boolean lastRunInsideCursor = false;
      int lastRunStartColumn = -1;
      int lastRunStartIndex = 0;
      boolean lastRunFontWidthMismatch = false;
      int currentCharIndex = 0;
      float measuredWidthForRun = 0.f;

      for (int column = 0; column < columns; ) {
        final char charAtIndex = line[currentCharIndex];
        final boolean charIsHighsurrogate = Character.isHighSurrogate(charAtIndex);
        final int charsForCodePoint = charIsHighsurrogate ? 2 : 1;
        final int codePoint = charIsHighsurrogate ? Character.toCodePoint(charAtIndex, line[currentCharIndex + 1]) : charAtIndex;
        final int codePointWcWidth = WcWidth.width(codePoint);
        final boolean insideCursor = (column >= selx1 && column <= selx2) || (cursorX == column || (codePointWcWidth == 2 && cursorX == column + 1));
        final long style = lineObject.getStyle(column);

        // Check if the measured text width for this code point is not the same as that expected by wcwidth().
        // This could happen for some fonts which are not truly monospace, or for more exotic characters such as
        // smileys which android font renders as wide.
        // If this is detected, we draw this code point scaled to match what wcwidth() expects.
        final float measuredCodePointWidth = (codePoint < asciiMeasures.length) ? asciiMeasures[codePoint] : mTextPaint.measureText(line,
          currentCharIndex, charsForCodePoint);
        final boolean fontWidthMismatch = Math.abs(measuredCodePointWidth / mFontWidth - codePointWcWidth) > 0.01;

        if (style != lastRunStyle || insideCursor != lastRunInsideCursor || fontWidthMismatch || lastRunFontWidthMismatch) {
          if (column == 0) {
            // Skip first column as there is nothing to draw, just record the current style.
          } else {
            final int columnWidthSinceLastRun = column - lastRunStartColumn;
            final int charsSinceLastRun = currentCharIndex - lastRunStartIndex;
            int cursorColor = lastRunInsideCursor ? mEmulator.mColors.mCurrentColors[TextStyle.COLOR_INDEX_CURSOR] : 0;
            drawTextRun(canvas, line, palette, heightOffset, lastRunStartColumn, columnWidthSinceLastRun,
              lastRunStartIndex, charsSinceLastRun, measuredWidthForRun,
              cursorColor, cursorShape, lastRunStyle, reverseVideo);
          }
          measuredWidthForRun = 0.f;
          lastRunStyle = style;
          lastRunInsideCursor = insideCursor;
          lastRunStartColumn = column;
          lastRunStartIndex = currentCharIndex;
          lastRunFontWidthMismatch = fontWidthMismatch;
        }
        measuredWidthForRun += measuredCodePointWidth;
        column += codePointWcWidth;
        currentCharIndex += charsForCodePoint;
        while (currentCharIndex < charsUsedInLine && WcWidth.width(line, currentCharIndex) <= 0) {
          // Eat combining chars so that they are treated as part of the last non-combining code point,
          // instead of e.g. being considered inside the cursorColor in the next run.
          currentCharIndex += Character.isHighSurrogate(line[currentCharIndex]) ? 2 : 1;
        }
      }

      final int columnWidthSinceLastRun = columns - lastRunStartColumn;
      final int charsSinceLastRun = currentCharIndex - lastRunStartIndex;
      int cursorColor = lastRunInsideCursor ? mEmulator.mColors.mCurrentColors[TextStyle.COLOR_INDEX_CURSOR] : 0;
      drawTextRun(canvas, line, palette, heightOffset, lastRunStartColumn, columnWidthSinceLastRun, lastRunStartIndex, charsSinceLastRun,
        measuredWidthForRun, cursorColor, cursorShape, lastRunStyle, reverseVideo);
    }
  }

  private void drawTextRun(Canvas canvas, char[] text, int[] palette, float y, int startColumn, int runWidthColumns,
                           int startCharIndex, int runWidthChars, float mes, int cursor, int cursorStyle,
                           long textStyle, boolean reverseVideo) {
    int foreColor = TextStyle.decodeForeColor(textStyle);
    final int effect = TextStyle.decodeEffect(textStyle);
    int backColor = TextStyle.decodeBackColor(textStyle);
    final boolean bold = (effect & (TextStyle.CHARACTER_ATTRIBUTE_BOLD | TextStyle.CHARACTER_ATTRIBUTE_BLINK)) != 0;
    final boolean underline = (effect & TextStyle.CHARACTER_ATTRIBUTE_UNDERLINE) != 0;
    final boolean italic = (effect & TextStyle.CHARACTER_ATTRIBUTE_ITALIC) != 0;
    final boolean strikeThrough = (effect & TextStyle.CHARACTER_ATTRIBUTE_STRIKETHROUGH) != 0;
    final boolean dim = (effect & TextStyle.CHARACTER_ATTRIBUTE_DIM) != 0;

    if ((foreColor & 0xff000000) != 0xff000000) {
      // Let bold have bright colors if applicable (one of the first 8):
      if (bold && foreColor >= 0 && foreColor < 8) foreColor += 8;
      foreColor = palette[foreColor];
    }

    if ((backColor & 0xff000000) != 0xff000000) {
      backColor = palette[backColor];
    }

    // Reverse video here if _one and only one_ of the reverse flags are set:
    final boolean reverseVideoHere = reverseVideo ^ (effect & (TextStyle.CHARACTER_ATTRIBUTE_INVERSE)) != 0;
    if (reverseVideoHere) {
      int tmp = foreColor;
      foreColor = backColor;
      backColor = tmp;
    }

    float left = startColumn * mFontWidth;
    float right = left + runWidthColumns * mFontWidth;

    mes = mes / mFontWidth;
    boolean savedMatrix = false;
    if (Math.abs(mes - runWidthColumns) > 0.01) {
      canvas.save();
      canvas.scale(runWidthColumns / mes, 1.f);
      left *= mes / runWidthColumns;
      right *= mes / runWidthColumns;
      savedMatrix = true;
    }

    if (backColor != palette[TextStyle.COLOR_INDEX_BACKGROUND]) {
      // Only draw non-default backgroundColor.
      mTextPaint.setColor(backColor);
      canvas.drawRect(left, y - mFontLineSpacingAndAscent + mFontAscent, right, y, mTextPaint);
    }

    if (cursor != 0) {
      mTextPaint.setColor(cursor);
      float cursorHeight = mFontLineSpacingAndAscent - mFontAscent;
      if (cursorStyle == TerminalEmulator.CURSOR_STYLE_UNDERLINE) cursorHeight /= 4.;
      else if (cursorStyle == TerminalEmulator.CURSOR_STYLE_BAR) right -= ((right - left) * 3) / 4.;
      canvas.drawRect(left, y - cursorHeight, right, y, mTextPaint);
      savedLastDrawnLineX = left;
      savedLastDrawnLineY = y;
    }

    if ((effect & TextStyle.CHARACTER_ATTRIBUTE_INVISIBLE) == 0) {
      if (dim) {
        int red = (0xFF & (foreColor >> 16));
        int green = (0xFF & (foreColor >> 8));
        int blue = (0xFF & foreColor);
        // Dim color handling used by libvte which in turn took it from xterm
        // (https://bug735245.bugzilla-attachments.gnome.org/attachment.cgi?id=284267):
        red = red * 2 / 3;
        green = green * 2 / 3;
        blue = blue * 2 / 3;
        foreColor = 0xFF000000 + (red << 16) + (green << 8) + blue;
      }

      mTextPaint.setFakeBoldText(bold);
      mTextPaint.setUnderlineText(underline);
      mTextPaint.setTextSkewX(italic ? -0.35f : 0.f);
      mTextPaint.setStrikeThruText(strikeThrough);
      mTextPaint.setColor(foreColor);

      // The text alignment is the default Paint.Align.LEFT.
      canvas.drawText(text, startCharIndex, runWidthChars, left, y - mFontLineSpacingAndAscent, mTextPaint);
    }

    if (savedMatrix) canvas.restore();
  }

  float getCursorX() {
    return savedLastDrawnLineX;
  }

  float getCursorY() {
    return savedLastDrawnLineY;
  }
}

```

`app/src/main/java/io/neoterm/frontend/session/view/TerminalView.java`:

```java
package io.neoterm.frontend.session.view;

import android.annotation.SuppressLint;
import android.annotation.TargetApi;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.graphics.drawable.BitmapDrawable;
import android.os.Build;
import android.text.Editable;
import android.text.InputType;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.util.Log;
import android.view.*;
import android.view.accessibility.AccessibilityManager;
import android.view.inputmethod.BaseInputConnection;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputConnection;
import android.widget.Scroller;
import io.neoterm.R;
import io.neoterm.backend.*;
import io.neoterm.component.completion.OnAutoCompleteListener;

/**
 * View displaying and interacting with a {@link TerminalSession}.
 */
public final class TerminalView extends View {

  /**
   * Log view key and IME events.
   */
  private static final boolean LOG_KEY_EVENTS = false;

  /**
   * The currently displayed terminal session, whose emulator is {@link #mEmulator}.
   */
  TerminalSession mTermSession;

  /**
   * Our terminal emulator whose session is {@link #mTermSession}.
   */
  TerminalEmulator mEmulator;

  TerminalRenderer mRenderer;

  TerminalViewClient mClient;

  /**
   * The top row of text to display. Ranges from -activeTranscriptRows to 0.
   */
  int mTopRow;

  boolean mIsSelectingText = false, mIsDraggingLeftSelection, mInitialTextSelection;
  int mSelX1 = -1, mSelX2 = -1, mSelY1 = -1, mSelY2 = -1;
  float mSelectionDownX, mSelectionDownY;
  private ActionMode mActionMode;
  private BitmapDrawable mLeftSelectionHandle, mRightSelectionHandle;

  float mScaleFactor = 1.f;
  /* final */ GestureAndScaleRecognizer mGestureRecognizer;

  /**
   * Keep track of where mouse touch event started which we report as mouse scroll.
   */
  private int mMouseScrollStartX = -1, mMouseScrollStartY = -1;
  /**
   * Keep track of the time when a touch event leading to sending mouse scroll events started.
   */
  private long mMouseStartDownTime = -1;

  /* final */ Scroller mScroller;

  /**
   * What was left in from scrolling movement.
   */
  float mScrollRemainder;

  /**
   * If non-zero, this is the last unicode code point received if that was a combining character.
   */
  int mCombiningAccent;
  int mTextSize;

  /**
   * If true, IME will be word based instead of char based.
   */
  private boolean mEnableWordBasedIme = false;

  private boolean mAccessibilityEnabled;

  public TerminalView(Context context) {
    super(context);
    commonInit(context);
  }

  public TerminalView(Context context, AttributeSet attributeSet) { // NO_UCD (unused code)
    super(context, attributeSet);
    commonInit(context);
  }

  private void commonInit(Context context) {
    mGestureRecognizer = new GestureAndScaleRecognizer(context, new GestureAndScaleRecognizer.Listener() {

      private boolean scrolledWithFinger;

      // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
      // e.g in vim, we can change window size with fingers moving.
      private float doubleTapX, doubleTapY;
      private boolean draggedAfterDoubleTap;

      @Override
      public boolean onUp(MotionEvent e) {
        mScrollRemainder = 0.0f;
        // 只有在没有选中文字的时候可以发送鼠标事件： !isSelectingText
        if (mEmulator != null && mEmulator.isMouseTrackingActive() && !mIsSelectingText && !scrolledWithFinger) {
          // Quick event processing when mouse tracking is active - do not wait for check of double tapping
          // for zooming.
          sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON, true);
          sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON, false);
          return true;
        }
        scrolledWithFinger = false;
        return false;
      }

      @Override
      public boolean onSingleTapUp(MotionEvent e) {
        if (mEmulator == null) return true;
        if (mIsSelectingText) {
          toggleSelectingText(null);
          return true;
        }
        requestFocus();
        if (!mEmulator.isMouseTrackingActive()) {
          if (!e.isFromSource(InputDevice.SOURCE_MOUSE)) {
            mClient.onSingleTapUp(e);
            return true;
          }
        }
        return false;
      }

      @Override
      public boolean onScroll(MotionEvent e, float distanceX, float distanceY) {
        // 如果在选择文字时，不允许滑动屏幕，因为文字选择器需要滑动
        if (mEmulator == null || mIsSelectingText) return true;

        if (mEmulator.isMouseTrackingActive() && e.isFromSource(InputDevice.SOURCE_MOUSE)) {
          // If moving with mouse pointer while pressing button, report that instead of scroll.
          // This means that we never report moving with button press-events for touch input,
          // since we cannot just start sending these events without a starting press event,
          // which we do not do for touch input, only mouse in onTouchEvent().
          sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON_MOVED, true);
        } else {
          scrolledWithFinger = true;
          distanceY += mScrollRemainder;
          int deltaRows = (int) (distanceY / mRenderer.mFontLineSpacing);

          // 记住当前滑动到的位置
          mScrollRemainder = distanceY - deltaRows * mRenderer.mFontLineSpacing;
          doScroll(e, deltaRows);
        }
        return true;
      }

      @Override
      public boolean onScale(float focusX, float focusY, float scale) {
        if (mEmulator == null || mIsSelectingText) return true;
        mScaleFactor *= scale;
        // 这里一般是改变文字大小
        mScaleFactor = mClient.onScale(mScaleFactor);
        return true;
      }

      @Override
      public boolean onFling(final MotionEvent e2, float velocityX, float velocityY) {
        // 选择文字时，文字选择器会用到触摸操作，这里不管
        if (mEmulator == null || mIsSelectingText) return true;

        // Do not start scrolling until last fling has been taken care of:
        if (!mScroller.isFinished()) return true;

        final boolean mouseTrackingAtStartOfFling = mEmulator.isMouseTrackingActive();
        float SCALE = 0.25f;
        if (mouseTrackingAtStartOfFling) {
          mScroller.fling(0, 0, 0, -(int) (velocityY * SCALE), 0, 0, -mEmulator.mRows / 2, mEmulator.mRows / 2);
        } else {
          mScroller.fling(0, mTopRow, 0, -(int) (velocityY * SCALE), 0, 0, -mEmulator.getScreen().getActiveTranscriptRows(), 0);
        }

        post(new Runnable() {
          private int mLastY = 0;

          @Override
          public void run() {
            if (mouseTrackingAtStartOfFling != mEmulator.isMouseTrackingActive()) {
              mScroller.abortAnimation();
              return;
            }
            if (mScroller.isFinished()) return;
            boolean more = mScroller.computeScrollOffset();
            int newY = mScroller.getCurrY();
            int diff = mouseTrackingAtStartOfFling ? (newY - mLastY) : (newY - mTopRow);
            doScroll(e2, diff);
            mLastY = newY;
            if (more) post(this);
          }
        });

        return true;
      }

      @Override
      public boolean onDown(float x, float y) {
        return false;
      }

      @Override
      public boolean onDoubleTap(MotionEvent e) {
        // Old behavior: Do not treat is as a single confirmed tap - it may be followed by zoom.

        // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
        // e.g in vim, we can change window size with fingers moving.
        // Now double tap and drag has been treated as a MOUSE_LEFT_BUTTON_MOVED event.
        return true;
      }

      // For treating double tap as MOUSE_LEFT_BUTTON_MOVED event
      // e.g in vim, we can change window size with fingers moving.
      @Override
      public boolean onDoubleTapEvent(MotionEvent e) {
        if (mEmulator.isMouseTrackingActive() && !e.isFromSource(InputDevice.SOURCE_MOUSE)) {
          switch (e.getAction()) {
            case MotionEvent.ACTION_DOWN:
              doubleTapX = e.getX();
              doubleTapY = e.getY();
              draggedAfterDoubleTap = false;
              sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON, true);
              break;
            case MotionEvent.ACTION_UP:
              if (!draggedAfterDoubleTap) {
                sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON, false);
                sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON, true);
              }
              sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON, false);
              break;
            case MotionEvent.ACTION_MOVE:
              if (Math.abs(e.getX() - doubleTapX) >= mRenderer.mFontWidth
                || Math.abs(e.getY() - doubleTapY) >= mRenderer.mFontLineSpacing) {
                doubleTapX = e.getX();
                doubleTapY = e.getY();
                draggedAfterDoubleTap = true;
                sendMouseEventCode(e, TerminalEmulator.MOUSE_LEFT_BUTTON_MOVED, true);
              }
              break;
          }
        }
        return true;
      }

      @Override
      public void onLongPress(MotionEvent e) {
        if (mGestureRecognizer.isInProgress()) return;
        if (mClient.onLongPress(e)) return;
        if (!mIsSelectingText) {
          performHapticFeedback(HapticFeedbackConstants.LONG_PRESS);
          toggleSelectingText(e);
        }
      }
    });
    mScroller = new Scroller(context);
    AccessibilityManager am = (AccessibilityManager) context.getSystemService(Context.ACCESSIBILITY_SERVICE);
    mAccessibilityEnabled = am != null && am.isEnabled();
  }

  /**
   * @param client Listener for all kinds of key events, both hardware and IME (which makes it different from that
   *               available with {@link View#setOnKeyListener(OnKeyListener)}.
   */
  public void setTerminalViewClient(TerminalViewClient client) {
    this.mClient = client;
  }

  @Override
  public void setOnKeyListener(OnKeyListener l) {
    if (l instanceof TerminalViewClient) {
      setTerminalViewClient(((TerminalViewClient) l));
    }
  }

  /**
   * Attach a {@link TerminalSession} to this view.
   *
   * @param session The {@link TerminalSession} this view will be displaying.
   */
  public boolean attachSession(TerminalSession session) {
    if (session == mTermSession) return false;
    mTopRow = 0;

    mTermSession = session;
    mEmulator = null;
    mCombiningAccent = 0;

    updateSize();

    // Wait with enabling the scrollbar until we have a terminal to get scroll position from.
    setVerticalScrollBarEnabled(true);

    return true;
  }

  @Override
  public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
    // Using InputType.NULL is the most correct input type and avoids issues with other hacks.
    //
    // Previous keyboard issues:
    // https://github.com/termux/termux-packages/issues/25
    // https://github.com/termux/termux-app/issues/87.
    // https://github.com/termux/termux-app/issues/126.
    // https://github.com/termux/termux-app/issues/137 (japanese chars and TYPE_NULL).
    if (mEnableWordBasedIme) {
      // Workaround for Google Pinying cannot input Chinese
      outAttrs.inputType = InputType.TYPE_CLASS_TEXT;
    } else {
      outAttrs.inputType = InputType.TYPE_NULL;
    }

    // Note that IME_ACTION_NONE cannot be used as that makes it impossible to input newlines using the on-screen
    // keyboard on Android TV (see https://github.com/termux/termux-app/issues/221).
    outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_FULLSCREEN;

    return new BaseInputConnection(this, true) {
      @Override
      public boolean finishComposingText() {
        if (LOG_KEY_EVENTS) Log.i(EmulatorDebug.LOG_TAG, "IME: finishComposingText()");
        super.finishComposingText();

        sendTextToTerminal(getEditable());
        getEditable().clear();
        return true;
      }

      @Override
      public boolean commitText(CharSequence text, int newCursorPosition) {
        if (LOG_KEY_EVENTS) {
          Log.i(EmulatorDebug.LOG_TAG, "IME: commitText(\"" + text + "\", " + newCursorPosition + ")");
        }
        super.commitText(text, newCursorPosition);

        if (mEmulator == null) return true;

        Editable content = getEditable();
        sendTextToTerminal(content);
        if (onAutoCompleteListener != null) {
          onAutoCompleteListener.onCompletionRequired(content.toString());
        }
        content.clear();
        return true;
      }

      @Override
      public boolean deleteSurroundingText(int leftLength, int rightLength) {
        if (LOG_KEY_EVENTS) {
          Log.i(EmulatorDebug.LOG_TAG, "IME: deleteSurroundingText(" + leftLength + ", " + rightLength + ")");
        }
        // The stock Samsung keyboard with 'Auto check spelling' enabled sends leftLength > 1.
        KeyEvent deleteKey = new KeyEvent(KeyEvent.ACTION_DOWN, KeyEvent.KEYCODE_DEL);
        for (int i = 0; i < leftLength; i++) sendKeyEvent(deleteKey);
        return super.deleteSurroundingText(leftLength, rightLength);
      }

      void sendTextToTerminal(CharSequence text) {
        final int textLengthInChars = text.length();
        for (int i = 0; i < textLengthInChars; i++) {
          char firstChar = text.charAt(i);
          int codePoint;
          if (Character.isHighSurrogate(firstChar)) {
            if (++i < textLengthInChars) {
              codePoint = Character.toCodePoint(firstChar, text.charAt(i));
            } else {
              // At end of string, with no low surrogate following the high:
              codePoint = TerminalEmulator.UNICODE_REPLACEMENT_CHAR;
            }
          } else {
            codePoint = firstChar;
          }

          boolean ctrlHeld = false;
          if (codePoint <= 31 && codePoint != 27) {
            if (codePoint == '\n') {
              // The AOSP keyboard and descendants seems to send \n as text when the enter key is pressed,
              // instead of a key event like most other keyboard apps. A terminal expects \r for the enter
              // key (although when icrnl is enabled this doesn't make a difference - run 'stty -icrnl' to
              // check the behaviour).
              codePoint = '\r';
            }

            // E.g. penti keyboard for ctrl input.
            ctrlHeld = true;
            switch (codePoint) {
              case 31:
                codePoint = '_';
                break;
              case 30:
                codePoint = '^';
                break;
              case 29:
                codePoint = ']';
                break;
              case 28:
                codePoint = '\\';
                break;
              default:
                codePoint += 96;
                break;
            }
          }

          inputCodePoint(codePoint, ctrlHeld, false);
        }
      }

    };
  }

  @Override
  protected int computeVerticalScrollRange() {
    return mEmulator == null ? 1 : mEmulator.getScreen().getActiveRows();
  }

  @Override
  protected int computeVerticalScrollExtent() {
    return mEmulator == null ? 1 : mEmulator.mRows;
  }

  @Override
  protected int computeVerticalScrollOffset() {
    return mEmulator == null ? 1 : mEmulator.getScreen().getActiveRows() + mTopRow - mEmulator.mRows;
  }

  public void onScreenUpdated() {
    if (mEmulator == null) return;
    boolean skipScrolling = false;
    boolean isScreenHeld = false;

    // currentScroll 记录了当前滚动到的位置
    // expectedScroll 记录了假设一直跟随输出滚动在最底部时的滚动位置
    // 如果二者不一样，即 mTop != 0，则说明用户在脚本输出的时候滚动了屏幕
    // 很有可能时用户需要观察上面脚本的输出结果
    // 那么这个时候我们就不跟随输出滚动屏幕
    // int currentScroll = computeVerticalScrollOffset();
    // int expectedScroll = mEmulator.getScreen().getActiveRows() - mEmulator.mRows;

    if (mTopRow != 0) {
      isScreenHeld = true;
    }

    if (mIsSelectingText || isScreenHeld) {
      // Do not scroll when selecting text.
      int rowsInHistory = mEmulator.getScreen().getActiveTranscriptRows();
      int rowShift = mEmulator.getScrollCounter();
      if (-mTopRow + rowShift > rowsInHistory) {
        // .. unless we're hitting the end of history transcript, in which
        // case we abort text selection and scroll to end.

        // 只当是因为选择文字而停止滚动时才取消选择文字
        if (mIsSelectingText) {
          toggleSelectingText(null);
        }
      } else {
        skipScrolling = true;
        mTopRow -= rowShift;
        mSelY1 -= rowShift;
        mSelY2 -= rowShift;
      }

      // 不滚动屏幕，但要让滚动条显示来告诉用户脚本在输出
      if (isScreenHeld) {
        awakenScrollBars();
      }
    }

    if (!skipScrolling && mTopRow != 0) {
      // Scroll down if not already there.
      if (mTopRow < -3) {
        // Awaken scroll bars only if scrolling a noticeable amount
        // - we do not want visible scroll bars during normal typing
        // of one row at a time.
        awakenScrollBars();
      }
      mTopRow = 0;
    }

    mEmulator.clearScrollCounter();
    invalidate();

    // Basic accessibility service
    String contentText = mEmulator.getScreen()
      .getSelectedText(0, mTopRow, mEmulator.mColumns, mTopRow + mEmulator.mRows);
    if (mAccessibilityEnabled) {
      setContentDescription(contentText);
    }
  }

  public int getTextSize() {
    return mTextSize;
  }

  /**
   * Sets the text size, which in turn sets the number of rows and columns.
   *
   * @param textSize the new font size, in density-independent pixels.
   */
  public void setTextSize(int textSize) {
    this.mTextSize = textSize;
    mRenderer = new TerminalRenderer(textSize, mRenderer == null ? Typeface.MONOSPACE : mRenderer.mTypeface);
    updateSize();
  }

  public void setTypeface(Typeface newTypeface) {
    mRenderer = new TerminalRenderer(mRenderer.mTextSize, newTypeface);
    updateSize();
    invalidate();
  }

  @Override
  public boolean onCheckIsTextEditor() {
    return true;
  }

  @Override
  public boolean isOpaque() {
    return true;
  }

  /**
   * Send a single mouse event code to the terminal.
   */
  void sendMouseEventCode(MotionEvent e, int button, boolean pressed) {
    int x = (int) (e.getX() / mRenderer.mFontWidth) + 1;
    int y = (int) ((e.getY() - mRenderer.mFontLineSpacingAndAscent) / mRenderer.mFontLineSpacing) + 1;
    if (pressed && (button == TerminalEmulator.MOUSE_WHEELDOWN_BUTTON || button == TerminalEmulator.MOUSE_WHEELUP_BUTTON)) {
      if (mMouseStartDownTime == e.getDownTime()) {
        x = mMouseScrollStartX;
        y = mMouseScrollStartY;
      } else {
        mMouseStartDownTime = e.getDownTime();
        mMouseScrollStartX = x;
        mMouseScrollStartY = y;
      }
    }
    mEmulator.sendMouseEvent(button, x, y, pressed);
  }

  /**
   * Perform a scroll, either from dragging the screen or by scrolling a mouse wheel.
   */
  void doScroll(MotionEvent event, int rowsDown) {
    boolean up = rowsDown < 0;
    int amount = Math.abs(rowsDown);
    for (int i = 0; i < amount; i++) {
      if (mEmulator.isMouseTrackingActive()) {
        sendMouseEventCode(event, up ? TerminalEmulator.MOUSE_WHEELUP_BUTTON : TerminalEmulator.MOUSE_WHEELDOWN_BUTTON, true);
      } else if (mEmulator.isAlternateBufferActive()) {
        // Send up and down key events for scrolling, which is what some terminals do to make scroll work in
        // e.g. less, which shifts to the alt screen without mouse handling.
        handleKeyCode(up ? KeyEvent.KEYCODE_DPAD_UP : KeyEvent.KEYCODE_DPAD_DOWN, 0);
      } else {
        mTopRow = Math.min(0, Math.max(-(mEmulator.getScreen().getActiveTranscriptRows()), mTopRow + (up ? -1 : 1)));
        if (!awakenScrollBars()) invalidate();
      }
    }
  }

  /**
   * Overriding {@link View#onGenericMotionEvent(MotionEvent)}.
   */
  @Override
  public boolean onGenericMotionEvent(MotionEvent event) {
    if (mEmulator != null && event.isFromSource(InputDevice.SOURCE_MOUSE) && event.getAction() == MotionEvent.ACTION_SCROLL) {
      // Handle mouse wheel scrolling.
      boolean up = event.getAxisValue(MotionEvent.AXIS_VSCROLL) > 0.0f;
      doScroll(event, up ? -3 : 3);
      return true;
    }
    return false;
  }

  @SuppressLint("ClickableViewAccessibility")
  @Override
  @TargetApi(23)
  public boolean onTouchEvent(MotionEvent ev) {
    if (mEmulator == null) return true;
    final int action = ev.getAction();

    if (mIsSelectingText) {
      int cy = (int) (ev.getY() / mRenderer.mFontLineSpacing) + mTopRow;
      int cx = (int) (ev.getX() / mRenderer.mFontWidth);

      switch (action) {
        case MotionEvent.ACTION_UP:
          mInitialTextSelection = false;
          break;
        case MotionEvent.ACTION_DOWN:
          int distanceFromSel1 = Math.abs(cx - mSelX1) + Math.abs(cy - mSelY1);
          int distanceFromSel2 = Math.abs(cx - mSelX2) + Math.abs(cy - mSelY2);
          mIsDraggingLeftSelection = distanceFromSel1 <= distanceFromSel2;
          mSelectionDownX = ev.getX();
          mSelectionDownY = ev.getY();
          break;
        case MotionEvent.ACTION_MOVE:
          if (mInitialTextSelection) break;
          float deltaX = ev.getX() - mSelectionDownX;
          float deltaY = ev.getY() - mSelectionDownY;
          int deltaCols = (int) Math.ceil(deltaX / mRenderer.mFontWidth);
          int deltaRows = (int) Math.ceil(deltaY / mRenderer.mFontLineSpacing);
          mSelectionDownX += deltaCols * mRenderer.mFontWidth;
          mSelectionDownY += deltaRows * mRenderer.mFontLineSpacing;
          if (mIsDraggingLeftSelection) {
            mSelX1 += deltaCols;
            mSelY1 += deltaRows;
          } else {
            mSelX2 += deltaCols;
            mSelY2 += deltaRows;
          }

          mSelX1 = Math.min(mEmulator.mColumns, Math.max(0, mSelX1));
          mSelX2 = Math.min(mEmulator.mColumns, Math.max(0, mSelX2));

          if (mSelY1 == mSelY2 && mSelX1 > mSelX2 || mSelY1 > mSelY2) {
            // Switch handles.
            mIsDraggingLeftSelection = !mIsDraggingLeftSelection;
            int tmpX1 = mSelX1, tmpY1 = mSelY1;
            mSelX1 = mSelX2;
            mSelY1 = mSelY2;
            mSelX2 = tmpX1;
            mSelY2 = tmpY1;
          }

          if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M)
            mActionMode.invalidateContentRect();
          invalidate();
          break;
        default:
          break;
      }
      mGestureRecognizer.onTouchEvent(ev);
      return true;
    } else if (ev.isFromSource(InputDevice.SOURCE_MOUSE)) {
      if (ev.isButtonPressed(MotionEvent.BUTTON_SECONDARY)) {
        if (action == MotionEvent.ACTION_DOWN) showContextMenu();
        return true;
      } else if (ev.isButtonPressed(MotionEvent.BUTTON_TERTIARY)) {
        pasteFromClipboard();
      } else if (mEmulator.isMouseTrackingActive()) { // BUTTON_PRIMARY.
        switch (ev.getAction()) {
          case MotionEvent.ACTION_DOWN:
          case MotionEvent.ACTION_UP:
            sendMouseEventCode(ev, TerminalEmulator.MOUSE_LEFT_BUTTON, ev.getAction() == MotionEvent.ACTION_DOWN);
            break;
          case MotionEvent.ACTION_MOVE:
            sendMouseEventCode(ev, TerminalEmulator.MOUSE_LEFT_BUTTON_MOVED, true);
            break;
        }
        return true;
      }
    }

    mGestureRecognizer.onTouchEvent(ev);
    return true;
  }

  public void pasteFromClipboard() {
    ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
    if (clipboard == null) {
      return;
    }
    ClipData clipData = clipboard.getPrimaryClip();
    if (clipData != null) {
      CharSequence paste = clipData.getItemAt(0).coerceToText(getContext());
      if (!TextUtils.isEmpty(paste)) mEmulator.paste(paste.toString());
    }
  }

  @Override
  public boolean onKeyPreIme(int keyCode, KeyEvent event) {
    if (LOG_KEY_EVENTS)
      Log.i(EmulatorDebug.LOG_TAG, "onKeyPreIme(keyCode=" + keyCode + ", event=" + event + ")");
    if (keyCode == KeyEvent.KEYCODE_BACK) {
      if (mIsSelectingText) {
        toggleSelectingText(null);
        return true;
      } else if (mClient.shouldBackButtonBeMappedToEscape()) {
        // Intercept back button to treat it as escape:
        switch (event.getAction()) {
          case KeyEvent.ACTION_DOWN:
            return onKeyDown(keyCode, event);
          case KeyEvent.ACTION_UP:
            return onKeyUp(keyCode, event);
        }
      }
    }
    return super.onKeyPreIme(keyCode, event);
  }

  @Override
  public boolean onKeyDown(int keyCode, KeyEvent event) {
    if (LOG_KEY_EVENTS)
      Log.i(EmulatorDebug.LOG_TAG, "onKeyDown(keyCode=" + keyCode + ", isSystem()=" + event.isSystem() + ", event=" + event + ")");
    if (mEmulator == null) return true;

    if (mClient.onKeyDown(keyCode, event, mTermSession)) {
      invalidate();
      return true;
    } else if (event.isSystem() && (!mClient.shouldBackButtonBeMappedToEscape() || keyCode != KeyEvent.KEYCODE_BACK)) {
      return super.onKeyDown(keyCode, event);
    } else if (event.getAction() == KeyEvent.ACTION_MULTIPLE && keyCode == KeyEvent.KEYCODE_UNKNOWN) {
      mTermSession.write(event.getCharacters());
      return true;
    }

    final int metaState = event.getMetaState();
    final boolean controlDownFromEvent = event.isCtrlPressed();
    final boolean leftAltDownFromEvent = (metaState & KeyEvent.META_ALT_LEFT_ON) != 0;
    final boolean rightAltDownFromEvent = (metaState & KeyEvent.META_ALT_RIGHT_ON) != 0;

    int keyMod = 0;
    if (controlDownFromEvent) keyMod |= KeyHandler.KEYMOD_CTRL;
    if (event.isAltPressed()) keyMod |= KeyHandler.KEYMOD_ALT;
    if (event.isShiftPressed()) keyMod |= KeyHandler.KEYMOD_SHIFT;
    if (!event.isFunctionPressed() && handleKeyCode(keyCode, keyMod)) {
      if (LOG_KEY_EVENTS) Log.i(EmulatorDebug.LOG_TAG, "handleKeyCode() took key event");
      return true;
    }

    // Clear Ctrl since we handle that ourselves:
    int bitsToClear = KeyEvent.META_CTRL_MASK;
    if (rightAltDownFromEvent) {
      // Let right Alt/Alt Gr be used to compose characters.
    } else {
      // Use left alt to send to terminal (e.g. Left Alt+B to jump back a word), so remove:
      bitsToClear |= KeyEvent.META_ALT_ON | KeyEvent.META_ALT_LEFT_ON;
    }
    int effectiveMetaState = event.getMetaState() & ~bitsToClear;

    int result = event.getUnicodeChar(effectiveMetaState);
    if (LOG_KEY_EVENTS)
      Log.i(EmulatorDebug.LOG_TAG, "KeyEvent#getUnicodeChar(" + effectiveMetaState + ") returned: " + result);
    if (result == 0) {
      return false;
    }

    int oldCombiningAccent = mCombiningAccent;
    if ((result & KeyCharacterMap.COMBINING_ACCENT) != 0) {
      // If entered combining accent previously, write it out:
      if (mCombiningAccent != 0)
        inputCodePoint(mCombiningAccent, controlDownFromEvent, leftAltDownFromEvent);
      mCombiningAccent = result & KeyCharacterMap.COMBINING_ACCENT_MASK;
    } else {
      if (mCombiningAccent != 0) {
        int combinedChar = KeyCharacterMap.getDeadChar(mCombiningAccent, result);
        if (combinedChar > 0) result = combinedChar;
        mCombiningAccent = 0;
      }
      inputCodePoint(result, controlDownFromEvent, leftAltDownFromEvent);
    }

    if (mCombiningAccent != oldCombiningAccent) invalidate();

    if (onAutoCompleteListener != null) {
      if (event.isPrintingKey()) {
        char printingChar = (char) event.getUnicodeChar(metaState);
        if (printingChar != '\b') {
          // ASCII chars
          onAutoCompleteListener.onCompletionRequired(new String(new char[]{printingChar}));
        }
      }
    }

    return true;
  }

  void inputCodePoint(int codePoint, boolean controlDownFromEvent, boolean leftAltDownFromEvent) {
    if (LOG_KEY_EVENTS) {
      Log.i(EmulatorDebug.LOG_TAG, "inputCodePoint(codePoint=" + codePoint + ", controlDownFromEvent=" + controlDownFromEvent + ", leftAltDownFromEvent="
        + leftAltDownFromEvent + ")");
    }

    if (mTermSession == null) return;

    final boolean controlDown = controlDownFromEvent || mClient.readControlKey();
    final boolean altDown = leftAltDownFromEvent || mClient.readAltKey();

    if (mClient.onCodePoint(codePoint, controlDown, mTermSession)) return;

    if (controlDown) {
      if (codePoint >= 'a' && codePoint <= 'z') {
        codePoint = codePoint - 'a' + 1;
      } else if (codePoint >= 'A' && codePoint <= 'Z') {
        codePoint = codePoint - 'A' + 1;
      } else if (codePoint == ' ' || codePoint == '2') {
        codePoint = 0;
      } else if (codePoint == '[' || codePoint == '3') {
        codePoint = 27; // ^[ (Esc)
      } else if (codePoint == '\\' || codePoint == '4') {
        codePoint = 28;
      } else if (codePoint == ']' || codePoint == '5') {
        codePoint = 29;
      } else if (codePoint == '^' || codePoint == '6') {
        codePoint = 30; // control-^
      } else if (codePoint == '_' || codePoint == '7' || codePoint == '/') {
        // "Ctrl-/ sends 0x1f which is equivalent of Ctrl-_ since the days of VT102"
        // - http://apple.stackexchange.com/questions/24261/how-do-i-send-c-that-is-control-slash-to-the-terminal
        codePoint = 31;
      } else if (codePoint == '8') {
        codePoint = 127; // DEL
      }
    }

    if (codePoint > -1) {
      // Work around bluetooth keyboards sending funny unicode characters instead
      // of the more normal ones from ASCII that terminal programs expect - the
      // desire to input the original characters should be low.
      switch (codePoint) {
        case 0x02DC: // SMALL TILDE.
          codePoint = 0x007E; // TILDE (~).
          break;
        case 0x02CB: // MODIFIER LETTER GRAVE ACCENT.
          codePoint = 0x0060; // GRAVE ACCENT (`).
          break;
        case 0x02C6: // MODIFIER LETTER CIRCUMFLEX ACCENT.
          codePoint = 0x005E; // CIRCUMFLEX ACCENT (^).
          break;
      }

      // If left alt, send escape before the code point to make e.g. Alt+B and Alt+F work in readline:
      mTermSession.writeCodePoint(altDown, codePoint);
      scrollToBottomIfNeeded();
    }
  }

  /**
   * Input the specified keyCode if applicable and return if the input was consumed.
   */
  public boolean handleKeyCode(int keyCode, int keyMod) {
    TerminalEmulator term = mTermSession.getEmulator();
    String code = KeyHandler.getCode(keyCode, keyMod, term.isCursorKeysApplicationMode(), term.isKeypadApplicationMode());
    if (code == null) return false;
    mTermSession.write(code);
    scrollToBottomIfNeeded();
    if (onAutoCompleteListener != null) {
      onAutoCompleteListener.onKeyCode(keyCode, keyMod);
    }
    return true;
  }

  /**
   * Called when a key is released in the view.
   *
   * @param keyCode The keycode of the key which was released.
   * @param event   A {@link KeyEvent} describing the event.
   * @return Whether the event was handled.
   */
  @Override
  public boolean onKeyUp(int keyCode, KeyEvent event) {
    if (LOG_KEY_EVENTS)
      Log.i(EmulatorDebug.LOG_TAG, "onKeyUp(keyCode=" + keyCode + ", event=" + event + ")");
    if (mEmulator == null) return true;

    if (mClient.onKeyUp(keyCode, event)) {
      invalidate();
      return true;
    } else if (event.isSystem()) {
      // Let system key events through.
      return super.onKeyUp(keyCode, event);
    }

    return true;
  }

  /**
   * 每次处理用户按下对终端输出有影响的键时被调用
   * 如果当前屏幕不处于最底部，则自动滚动到最底部
   */
  void scrollToBottomIfNeeded() {
    if (mTopRow != 0) {
      mTopRow = 0;
      mEmulator.clearScrollCounter();
      invalidate();
    }
  }

  /**
   * This is called during layout when the size of this view has changed. If you were just added to the view
   * hierarchy, you're called with the old values of 0.
   */
  @Override
  protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    updateSize();
  }

  /**
   * Check if the terminal size in rows and columns should be updated.
   */
  public void updateSize() {
    int viewWidth = getWidth();
    int viewHeight = getHeight();
    if (viewWidth == 0 || viewHeight == 0 || mTermSession == null) return;

    // Set to 80 and 24 if you want to enable vttest.
    int newColumns = Math.max(4, (int) (viewWidth / mRenderer.mFontWidth));
    int newRows = Math.max(4, (viewHeight - mRenderer.mFontLineSpacingAndAscent) / mRenderer.mFontLineSpacing);

    if (mEmulator == null || (newColumns != mEmulator.mColumns || newRows != mEmulator.mRows)) {
      mTermSession.updateSize(newColumns, newRows);
      mEmulator = mTermSession.getEmulator();

      mTopRow = 0;
      scrollTo(0, 0);
      invalidate();
    }
  }

  @Override
  protected void onDraw(Canvas canvas) {
    if (mEmulator == null) {
      canvas.drawColor(0XFF000000);
    } else {
      mRenderer.render(mEmulator, canvas, mTopRow, mSelY1, mSelY2, mSelX1, mSelX2);

      if (mIsSelectingText) {
        final int gripHandleWidth = mLeftSelectionHandle.getIntrinsicWidth();
        final int gripHandleMargin = gripHandleWidth / 4; // See the png.

        int right = Math.round((mSelX1) * mRenderer.mFontWidth) + gripHandleMargin;
        int top = (mSelY1 + 1 - mTopRow) * mRenderer.mFontLineSpacing + mRenderer.mFontLineSpacingAndAscent;
        mLeftSelectionHandle.setBounds(right - gripHandleWidth, top, right, top + mLeftSelectionHandle.getIntrinsicHeight());
        mLeftSelectionHandle.draw(canvas);

        int left = Math.round((mSelX2 + 1) * mRenderer.mFontWidth) - gripHandleMargin;
        top = (mSelY2 + 1 - mTopRow) * mRenderer.mFontLineSpacing + mRenderer.mFontLineSpacingAndAscent;
        mRightSelectionHandle.setBounds(left, top, left + gripHandleWidth, top + mRightSelectionHandle.getIntrinsicHeight());
        mRightSelectionHandle.draw(canvas);
      }
    }
  }

  /**
   * Toggle text selection mode in the view.
   */
  @TargetApi(23)
  public void toggleSelectingText(MotionEvent ev) {
    mIsSelectingText = !mIsSelectingText;
    mClient.copyModeChanged(mIsSelectingText);

    if (mIsSelectingText) {
      if (mLeftSelectionHandle == null) {
        mLeftSelectionHandle = (BitmapDrawable) getContext().getDrawable(R.drawable.text_select_handle_left_material);
        mRightSelectionHandle = (BitmapDrawable) getContext().getDrawable(R.drawable.text_select_handle_right_material);
      }

      int cx = (int) (ev.getX() / mRenderer.mFontWidth);
      final boolean eventFromMouse = ev.isFromSource(InputDevice.SOURCE_MOUSE);
      // Offset for finger:
      final int SELECT_TEXT_OFFSET_Y = eventFromMouse ? 0 : -40;
      int cy = (int) ((ev.getY() + SELECT_TEXT_OFFSET_Y) / mRenderer.mFontLineSpacing) + mTopRow;

      mSelX1 = mSelX2 = cx;
      mSelY1 = mSelY2 = cy;

      TerminalBuffer screen = mEmulator.getScreen();
      if (!" ".equals(screen.getSelectedText(mSelX1, mSelY1, mSelX1, mSelY1))) {
        // Selecting something other than whitespace. Expand to word.
        while (mSelX1 > 0 && !"".equals(screen.getSelectedText(mSelX1 - 1, mSelY1, mSelX1 - 1, mSelY1))) {
          mSelX1--;
        }
        while (mSelX2 < mEmulator.mColumns - 1 && !"".equals(screen.getSelectedText(mSelX2 + 1, mSelY1, mSelX2 + 1, mSelY1))) {
          mSelX2++;
        }
      }

      mInitialTextSelection = true;
      mIsDraggingLeftSelection = true;
      mSelectionDownX = ev.getX();
      mSelectionDownY = ev.getY();

      final ActionMode.Callback callback = new ActionMode.Callback() {
        @Override
        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
          int show = MenuItem.SHOW_AS_ACTION_ALWAYS | MenuItem.SHOW_AS_ACTION_WITH_TEXT;

          ClipboardManager clipboard = (ClipboardManager) getContext().getSystemService(Context.CLIPBOARD_SERVICE);
          menu.add(Menu.NONE, 1, Menu.NONE, R.string.copy_text).setShowAsAction(show);
          menu.add(Menu.NONE, 2, Menu.NONE, R.string.paste_text).setEnabled(clipboard.hasPrimaryClip()).setShowAsAction(show);
          menu.add(Menu.NONE, 3, Menu.NONE, R.string.text_selection_more);

          return true;
        }

        @Override
        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
          return false;
        }

        @Override
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
          if (!mIsSelectingText) {
            // Fix issue where the dialog is pressed while being dismissed.
            return true;
          }

          switch (item.getItemId()) {
            case 1:
              String selectedText = mEmulator.getSelectedText(mSelX1, mSelY1, mSelX2, mSelY2).trim();
              mTermSession.clipboardText(selectedText);
              break;
            case 2:
              pasteFromClipboard();
              break;
            case 3:
              showContextMenu();
              break;
          }
          toggleSelectingText(null);
          return true;
        }

        @Override
        public void onDestroyActionMode(ActionMode mode) {
        }
      };

      mActionMode = startActionMode(new ActionMode.Callback2() {
        @Override
        public boolean onCreateActionMode(ActionMode mode, Menu menu) {
          return callback.onCreateActionMode(mode, menu);
        }

        @Override
        public boolean onPrepareActionMode(ActionMode mode, Menu menu) {
          return false;
        }

        @Override
        public boolean onActionItemClicked(ActionMode mode, MenuItem item) {
          return callback.onActionItemClicked(mode, item);
        }

        @Override
        public void onDestroyActionMode(ActionMode mode) {
          // Ignore.
        }

        @Override
        public void onGetContentRect(ActionMode mode, View view, Rect outRect) {
          int x1 = Math.round(mSelX1 * mRenderer.mFontWidth);
          int x2 = Math.round(mSelX2 * mRenderer.mFontWidth);
          int y1 = Math.round((mSelY1 - mTopRow) * mRenderer.mFontLineSpacing);
          int y2 = Math.round((mSelY2 + 1 - mTopRow) * mRenderer.mFontLineSpacing);
          outRect.set(Math.min(x1, x2), y1, Math.max(x1, x2), y2);
        }
      }, ActionMode.TYPE_FLOATING);
      invalidate();
    } else {
      mActionMode.finish();
      mSelX1 = mSelY1 = mSelX2 = mSelY2 = -1;
      invalidate();
    }
  }

  public TerminalSession getCurrentSession() {
    return mTermSession;
  }


  private OnAutoCompleteListener onAutoCompleteListener;

  public OnAutoCompleteListener getOnAutoCompleteListener() {
    return onAutoCompleteListener;
  }

  public void setOnAutoCompleteListener(OnAutoCompleteListener onAutoCompleteListener) {
    this.onAutoCompleteListener = onAutoCompleteListener;
  }

  public int getCursorAbsoluteX() {
    return (int) mRenderer.getCursorX();
  }

  public int getCursorAbsoluteY() {
    int[] locations = new int[2];
    getLocationOnScreen(locations);
    return (int) (mRenderer.getCursorY() + locations[1]);
  }

  public void setEnableWordBasedIme(boolean mEnableWordBasedIme) {
    this.mEnableWordBasedIme = mEnableWordBasedIme;
  }
}

```

`app/src/main/java/io/neoterm/frontend/session/view/TerminalViewClient.java`:

```java
package io.neoterm.frontend.session.view;

import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import io.neoterm.backend.TerminalSession;

/**
 * Input and scale listener which may be set on a {@link TerminalView} through
 * {@link TerminalView#setTerminalViewClient(TerminalViewClient)}.
 * <p/>
 */
public interface TerminalViewClient {
  /**
   * Callback function on scale events according to {@link ScaleGestureDetector#getScaleFactor()}.
   */
  float onScale(float scale);

  /**
   * On a single tap on the terminal if terminal mouse reporting not enabled.
   */
  void onSingleTapUp(MotionEvent e);

  boolean shouldBackButtonBeMappedToEscape();

  void copyModeChanged(boolean copyMode);

  boolean onKeyDown(int keyCode, KeyEvent e, TerminalSession session);

  boolean onKeyUp(int keyCode, KeyEvent e);

  boolean readControlKey();

  boolean readAltKey();

  boolean onCodePoint(int codePoint, boolean ctrlDown, TerminalSession session);

  boolean onLongPress(MotionEvent event);

}

```

`app/src/main/java/io/neoterm/frontend/session/view/extrakey/CombinedSequence.kt`:

```kt
package io.neoterm.frontend.session.view.extrakey

/**
 * <Ctrl> <Alt> <Delete>
 * <Ctrl> C
 * <Esc> :q <Enter>
 *
 * @author kiva
 */
class CombinedSequence private constructor() {
  val keys = mutableListOf<String>()

  companion object {
    fun solveString(keyString: String): CombinedSequence {
      val seq = CombinedSequence()
      keyString.split(' ').forEach {
        val key = if (it.startsWith('<') && it.endsWith('>')) {
          // is a sequence
          it.substring(1, it.length - 1)
        } else {
          // is a normal string
          it
        }
        seq.keys.add(key)
      }
      return seq
    }
  }
}

```

`app/src/main/java/io/neoterm/frontend/session/view/extrakey/ExtraKeysView.kt`:

```kt
package io.neoterm.frontend.session.view.extrakey

import android.content.Context
import android.graphics.Typeface
import android.util.AttributeSet
import android.view.*
import android.widget.GridLayout
import android.widget.LinearLayout
import io.neoterm.R
import io.neoterm.component.ComponentManager
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.config.NeoTermPath
import io.neoterm.component.extrakey.ExtraKeyComponent
import io.neoterm.frontend.session.terminal.ToggleImeEvent
import org.greenrobot.eventbus.EventBus
import java.io.File

class ExtraKeysView(context: Context, attrs: AttributeSet) : LinearLayout(context, attrs) {
  companion object {
    private val ESC = ControlButton(IExtraButton.KEY_ESC)
    private val TAB = ControlButton(IExtraButton.KEY_TAB)
    private val PAGE_UP = RepeatableButton(IExtraButton.KEY_PAGE_UP)
    private val PAGE_DOWN = RepeatableButton(IExtraButton.KEY_PAGE_DOWN)
    private val HOME = ControlButton(IExtraButton.KEY_HOME)
    private val END = ControlButton(IExtraButton.KEY_END)
    private val ARROW_UP = ArrowButton(IExtraButton.KEY_ARROW_UP)
    private val ARROW_DOWN = ArrowButton(IExtraButton.KEY_ARROW_DOWN)
    private val ARROW_LEFT = ArrowButton(IExtraButton.KEY_ARROW_LEFT)
    private val ARROW_RIGHT = ArrowButton(IExtraButton.KEY_ARROW_RIGHT)
    private val TOGGLE_IME = object : ControlButton(IExtraButton.KEY_TOGGLE_IME) {
      override fun onClick(view: View) {
        EventBus.getDefault().post(ToggleImeEvent())
      }
    }

    private val MAX_BUTTONS_PER_LINE = 7
    private val DEFAULT_ALPHA = 0.8f
    private val EXPANDED_ALPHA = 0.5f
    private val USER_KEYS_BUTTON_LINE_START = 2
  }

  private val builtinKeys = mutableListOf<IExtraButton>()
  private val userKeys = mutableListOf<IExtraButton>()

  private val buttonBars: MutableList<LinearLayout> = mutableListOf()
  private var typeface: Typeface? = null

  // Initialize StatedControlButton here
  // For avoid memory and context leak.
  private val CTRL = StatedControlButton(IExtraButton.KEY_CTRL)
  private val ALT = StatedControlButton(IExtraButton.KEY_ALT)

  private var buttonPanelExpanded = false
  private val EXPAND_BUTTONS = object : ControlButton(IExtraButton.KEY_SHOW_ALL_BUTTONS) {
    override fun onClick(view: View) {
      expandButtonPanel()
    }
  }

  private val extraKeyComponent: ExtraKeyComponent

  init {
    alpha = DEFAULT_ALPHA
    gravity = Gravity.TOP
    orientation = VERTICAL
    typeface = Typeface.createFromAsset(context.assets, "eks_font.ttf")
    extraKeyComponent = ComponentManager.getComponent<ExtraKeyComponent>()

    initBuiltinKeys()
    loadDefaultUserKeys()
    updateButtons()
    expandButtonPanel(false)
  }

  override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
    if (keyCode == KeyEvent.KEYCODE_BACK && event?.action == KeyEvent.ACTION_DOWN) {
      if (buttonPanelExpanded) {
        expandButtonPanel()
        return true
      }
      return false
    }
    return super.onKeyDown(keyCode, event)
  }

  fun setTextColor(textColor: Int) {
    IExtraButton.NORMAL_TEXT_COLOR = textColor
    updateButtons()
  }

  fun setTypeface(typeface: Typeface?) {
    this.typeface = typeface
    updateButtons()
  }

  fun readControlButton(): Boolean {
    return CTRL.readState()
  }

  fun readAltButton(): Boolean {
    return ALT.readState()
  }

  fun addUserKey(button: IExtraButton) {
    addKeyButton(userKeys, button)
  }

  fun addBuiltinKey(button: IExtraButton) {
    addKeyButton(builtinKeys, button)
  }

  fun clearUserKeys() {
    userKeys.clear()
  }

  fun loadDefaultUserKeys() {
    clearUserKeys()
    val defaultConfig = extraKeyComponent.loadConfigure(File(NeoTermPath.EKS_DEFAULT_FILE))
    if (defaultConfig != null) {
      userKeys.addAll(defaultConfig.shortcutKeys)
    }
  }

  fun updateButtons() {
    buttonBars.forEach { it.removeAllViews() }

    var targetButtonBarIndex = 0
    builtinKeys.plus(userKeys).forEachIndexed { index, button ->
      addKeyButton(getButtonBarOrNew(targetButtonBarIndex), button)
      targetButtonBarIndex = (index + 1) / MAX_BUTTONS_PER_LINE
    }
    updateButtonBars()
  }

  private fun updateButtonBars() {
    removeAllViews()

    buttonBars.asReversed()
      .forEach { addView(it) }
  }

  private fun expandButtonPanel(forceSetExpanded: Boolean? = null) {
    if (buttonBars.size <= 2) {
      return
    }

    buttonPanelExpanded = forceSetExpanded ?: !buttonPanelExpanded
    val visibility = if (buttonPanelExpanded) View.VISIBLE else View.GONE
    alpha = if (buttonPanelExpanded) EXPANDED_ALPHA else DEFAULT_ALPHA

    IntRange(USER_KEYS_BUTTON_LINE_START, buttonBars.size - 1)
      .map { buttonBars[it] }
      .forEach { it.visibility = visibility }
  }

  private fun createNewButtonBar(): LinearLayout {
    val line = LinearLayout(context)

    val layoutParams =
      if (NeoPreference.isExplicitExtraKeysWeightEnabled())
        LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, 0, 1f)
      else
        LinearLayout.LayoutParams(
          ViewGroup.LayoutParams.MATCH_PARENT,
          ViewGroup.LayoutParams.WRAP_CONTENT
        )

    layoutParams.setMargins(0, 0, 0, 0)
    line.setPadding(0, 0, 0, 0)
    line.gravity = Gravity.START
    line.orientation = LinearLayout.HORIZONTAL
    line.layoutParams = layoutParams
    return line
  }

  private fun getButtonBarOrNew(position: Int): LinearLayout {
    if (position >= buttonBars.size) {
      for (i in 0..(position - buttonBars.size + 1)) {
        buttonBars.add(createNewButtonBar())
      }
    }
    return buttonBars[position]
  }

  private fun addKeyButton(buttons: MutableList<IExtraButton>?, button: IExtraButton) {
    if (buttons != null && !buttons.contains(button)) {
      buttons.add(button)
    }
  }

  private fun addKeyButton(contentView: LinearLayout, extraButton: IExtraButton) {
    val outerButton = extraButton.makeButton(context, null, android.R.attr.buttonBarButtonStyle)

    val param = GridLayout.LayoutParams()
    param.setGravity(Gravity.CENTER)
    param.width = calculateButtonWidth()
    param.height = context.resources.getDimensionPixelSize(R.dimen.eks_height)
    param.setMargins(0, 0, 0, 0)

    outerButton.layoutParams = param
    outerButton.maxLines = 1
    outerButton.typeface = typeface
    outerButton.text = extraButton.displayText
    outerButton.setPadding(0, 0, 0, 0)
    outerButton.setTextColor(IExtraButton.NORMAL_TEXT_COLOR)
    outerButton.setAllCaps(false)

    outerButton.setOnClickListener {
      outerButton.performHapticFeedback(HapticFeedbackConstants.KEYBOARD_TAP)
      val root = rootView
      extraButton.onClick(root)
    }
    contentView.addView(outerButton)
  }

  private fun initBuiltinKeys() {
    addBuiltinKey(ESC)
    addBuiltinKey(TAB)
    addBuiltinKey(PAGE_DOWN)
    addBuiltinKey(ARROW_LEFT)
    addBuiltinKey(ARROW_DOWN)
    addBuiltinKey(ARROW_RIGHT)
    addBuiltinKey(TOGGLE_IME)

    addBuiltinKey(CTRL)
    addBuiltinKey(ALT)
    addBuiltinKey(PAGE_UP)
    addBuiltinKey(HOME)
    addBuiltinKey(ARROW_UP)
    addBuiltinKey(END)
    addBuiltinKey(EXPAND_BUTTONS)
  }

  private fun calculateButtonWidth(): Int {
    return context.resources.displayMetrics.widthPixels / ExtraKeysView.MAX_BUTTONS_PER_LINE
  }
}

```

`app/src/main/java/io/neoterm/frontend/session/view/extrakey/buttons.kt`:

```kt
package io.neoterm.frontend.session.view.extrakey

import android.content.Context
import android.os.Handler
import android.os.Looper
import android.util.AttributeSet
import android.view.KeyEvent
import android.view.MotionEvent
import android.view.View
import android.widget.Button
import android.widget.ToggleButton
import androidx.appcompat.widget.AppCompatButton
import io.neoterm.R
import io.neoterm.frontend.session.view.TerminalView

/**
 * @author kiva
 */

open class ControlButton(text: String) : TextButton(text, false)

/**
 * @author kiva
 */

abstract class IExtraButton : View.OnClickListener {

  var buttonKeys: CombinedSequence? = null
  var displayText: String? = null

  override fun toString(): String {
    return "${this.javaClass.simpleName} { display: $displayText, code: ${buttonKeys?.keys} }"
  }

  abstract override fun onClick(view: View)

  abstract fun makeButton(context: Context?, attrs: AttributeSet?, defStyleAttr: Int): Button

  companion object {
    const val KEY_ESC = "Esc"
    const val KEY_TAB = "Tab"
    const val KEY_CTRL = "Ctrl"
    const val KEY_ALT = "Alt"
    const val KEY_PAGE_UP = "PgUp"
    const val KEY_PAGE_DOWN = "PgDn"
    const val KEY_HOME = "Home"
    const val KEY_END = "End"
    const val KEY_ARROW_UP_TEXT = "Up"
    const val KEY_ARROW_DOWN_TEXT = "Down"
    const val KEY_ARROW_LEFT_TEXT = "Left"
    const val KEY_ARROW_RIGHT_TEXT = "Right"
    const val KEY_SHOW_ALL_BUTTONS = "···"
    const val KEY_TOGGLE_IME = "Im"

    const val KEY_ARROW_UP = "▲"
    const val KEY_ARROW_DOWN = "▼"
    const val KEY_ARROW_LEFT = "◀"
    const val KEY_ARROW_RIGHT = "▶"

    var NORMAL_TEXT_COLOR = 0xFFFFFFFF.toInt()
    var SELECTED_TEXT_COLOR = 0xFF80DEEA.toInt()

    fun sendKey(view: View, keyName: String) {
      var keyCode = 0
      var chars = ""
      when (keyName) {
        KEY_ESC -> keyCode = KeyEvent.KEYCODE_ESCAPE
        KEY_TAB -> keyCode = KeyEvent.KEYCODE_TAB
        KEY_ARROW_UP -> keyCode = KeyEvent.KEYCODE_DPAD_UP
        KEY_ARROW_LEFT -> keyCode = KeyEvent.KEYCODE_DPAD_LEFT
        KEY_ARROW_RIGHT -> keyCode = KeyEvent.KEYCODE_DPAD_RIGHT
        KEY_ARROW_DOWN -> keyCode = KeyEvent.KEYCODE_DPAD_DOWN
        KEY_ARROW_UP_TEXT -> keyCode = KeyEvent.KEYCODE_DPAD_UP
        KEY_ARROW_LEFT_TEXT -> keyCode = KeyEvent.KEYCODE_DPAD_LEFT
        KEY_ARROW_RIGHT_TEXT -> keyCode = KeyEvent.KEYCODE_DPAD_RIGHT
        KEY_ARROW_DOWN_TEXT -> keyCode = KeyEvent.KEYCODE_DPAD_DOWN
        KEY_PAGE_UP -> keyCode = KeyEvent.KEYCODE_PAGE_UP
        KEY_PAGE_DOWN -> keyCode = KeyEvent.KEYCODE_PAGE_DOWN
        KEY_HOME -> keyCode = KeyEvent.KEYCODE_MOVE_HOME
        KEY_END -> keyCode = KeyEvent.KEYCODE_MOVE_END
        "―" -> chars = "-"
        else -> chars = keyName
      }

      if (keyCode > 0) {
        view.dispatchKeyEvent(KeyEvent(KeyEvent.ACTION_DOWN, keyCode))
        view.dispatchKeyEvent(KeyEvent(KeyEvent.ACTION_UP, keyCode))
      } else if (chars.isNotEmpty()) {
        val terminalView = view.findViewById<TerminalView>(R.id.terminal_view)
        val session = terminalView.currentSession
        session?.write(chars)
      }
    }
  }
}

/**
 * @author kiva
 */
open class RepeatableButton(buttonText: String) : ControlButton(buttonText) {

  override fun makeButton(context: Context?, attrs: AttributeSet?, defStyleAttr: Int): Button {
    return RepeatableButtonWidget(context, attrs, defStyleAttr)
  }

  private class RepeatableButtonWidget(context: Context?, attrs: AttributeSet?, defStyleAttr: Int) :
    AppCompatButton(context!!, attrs, defStyleAttr) {

    /**
     * Milliseconds how long we trigger an action
     * when long pressing
     */
    private val LONG_CLICK_ACTION_INTERVAL = 100L

    private var isMotionEventUp = true

    var mHandler: Handler = object : Handler(Looper.getMainLooper()) {
      override fun handleMessage(msg: android.os.Message) {
        if (!isMotionEventUp && isEnabled) {
          performClick()
          this.sendEmptyMessageDelayed(0, LONG_CLICK_ACTION_INTERVAL)
        }
      }
    }

    init {
      this.setOnLongClickListener {
        isMotionEventUp = false
        mHandler.sendEmptyMessage(0)
        false
      }
      this.setOnTouchListener { _, event ->
        if (event.action == MotionEvent.ACTION_UP) {
          isMotionEventUp = true
        }
        false
      }
    }

    override fun performClick(): Boolean {
      return super.performClick()
    }
  }
}

/**
 * @author kiva
 */

open class StatedControlButton @JvmOverloads constructor(text: String, var initState: Boolean = false) :
  ControlButton(text) {
  var toggleButton: ToggleButton? = null

  override fun onClick(view: View) {
    setStatus(toggleButton?.isChecked)
  }

  override fun makeButton(context: Context?, attrs: AttributeSet?, defStyleAttr: Int): Button {
    val outerButton = ToggleButton(context, null, android.R.attr.buttonBarButtonStyle)

    outerButton.isClickable = true
    if (initState) {
      outerButton.isChecked = true
      outerButton.setTextColor(SELECTED_TEXT_COLOR)
    }

    this.toggleButton = outerButton
    return outerButton
  }

  private fun setStatus(status: Boolean?) {
    val button = toggleButton
    if (button != null && status != null) {
      button.isChecked = status
      button.setTextColor(
        if (status) SELECTED_TEXT_COLOR
        else NORMAL_TEXT_COLOR
      )
    }
  }

  fun readState(): Boolean {
    val button = toggleButton ?: return false

    if (button.isPressed) return true
    val result = button.isChecked
    if (result) {
      button.isChecked = false
      button.setTextColor(NORMAL_TEXT_COLOR)
    }
    return result
  }
}

/**
 * @author kiva
 */

open class TextButton constructor(text: String, val withEnter: Boolean = false) : IExtraButton() {
  init {
    this.buttonKeys = CombinedSequence.solveString(text)
    this.displayText = text
  }

  override fun onClick(view: View) {
    buttonKeys!!.keys.forEach {
      sendKey(view, it)
    }
    if (withEnter) {
      sendKey(view, "\n")
    }
  }

  override fun makeButton(context: Context?, attrs: AttributeSet?, defStyleAttr: Int): Button {
    return Button(context, attrs, defStyleAttr)
  }
}

/**
 * @author kiva
 */
class ArrowButton(arrowText: String) : RepeatableButton(arrowText)

```

`app/src/main/java/io/neoterm/services/NeoTermService.kt`:

```kt
package io.neoterm.services

import android.annotation.SuppressLint
import android.app.*
import android.content.Context
import android.content.Intent
import android.net.wifi.WifiManager
import android.os.Binder
import android.os.Build
import android.os.IBinder
import android.os.PowerManager
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.NotificationCompat
import io.neoterm.R
import io.neoterm.backend.EmulatorDebug
import io.neoterm.backend.TerminalSession
import io.neoterm.component.session.ShellParameter
import io.neoterm.component.session.XParameter
import io.neoterm.component.session.XSession
import io.neoterm.ui.term.NeoTermActivity
import io.neoterm.utils.NLog
import io.neoterm.utils.Terminals


/**
 * @author kiva
 */

class NeoTermService : Service() {
  inner class NeoTermBinder : Binder() {
    var service = this@NeoTermService
  }

  private val serviceBinder = NeoTermBinder()
  private val mTerminalSessions = ArrayList<TerminalSession>()
  private val mXSessions = ArrayList<XSession>()
  private var mWakeLock: PowerManager.WakeLock? = null
  private var mWifiLock: WifiManager.WifiLock? = null

  override fun onCreate() {
    super.onCreate()
    createNotificationChannel()
    startForeground(NOTIFICATION_ID, createNotification())
  }

  override fun onBind(intent: Intent): IBinder? {
    return serviceBinder
  }

  override fun onStartCommand(intent: Intent, flags: Int, startId: Int): Int {
    val action = intent.action
    when (action) {
      ACTION_SERVICE_STOP -> {
        for (i in mTerminalSessions.indices)
          mTerminalSessions[i].finishIfRunning()
        stopSelf()
      }

      ACTION_ACQUIRE_LOCK -> acquireLock()

      ACTION_RELEASE_LOCK -> releaseLock()
    }

    return Service.START_NOT_STICKY
  }

  override fun onDestroy() {
    stopForeground(true)

    for (i in mTerminalSessions.indices)
      mTerminalSessions[i].finishIfRunning()
    mTerminalSessions.clear()
  }

  val sessions: List<TerminalSession>
    get() = mTerminalSessions

  val xSessions: List<XSession>
    get() = mXSessions

  fun createTermSession(parameter: ShellParameter): TerminalSession {
    val session = createOrFindSession(parameter)
    updateNotification()
    return session
  }

  fun removeTermSession(sessionToRemove: TerminalSession): Int {
    val indexOfRemoved = mTerminalSessions.indexOf(sessionToRemove)
    if (indexOfRemoved >= 0) {
      mTerminalSessions.removeAt(indexOfRemoved)
      updateNotification()
    }
    return indexOfRemoved
  }

  fun createXSession(activity: AppCompatActivity, parameter: XParameter): XSession {
    val session = Terminals.createSession(activity, parameter)
    mXSessions.add(session)
    updateNotification()
    return session
  }

  fun removeXSession(sessionToRemove: XSession): Int {
    val indexOfRemoved = mXSessions.indexOf(sessionToRemove)
    if (indexOfRemoved >= 0) {
      mXSessions.removeAt(indexOfRemoved)
      updateNotification()
    }
    return indexOfRemoved
  }

  private fun createOrFindSession(parameter: ShellParameter): TerminalSession {
    if (parameter.willCreateNewSession()) {
      NLog.d("createOrFindSession: creating new session")
      val session = Terminals.createSession(this, parameter)
      mTerminalSessions.add(session)
      return session
    }

    val sessionId = parameter.sessionId!!
    NLog.d("createOrFindSession: find session by id $sessionId")

    val session = mTerminalSessions.find { it.mHandle == sessionId.sessionId }
      ?: throw IllegalArgumentException("cannot find session by given id")

    session.write(parameter.initialCommand + "\n")
    return session
  }

  private fun updateNotification() {
    val service = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    service.notify(NOTIFICATION_ID, createNotification())
  }

  private fun createNotification(): Notification {
    val notifyIntent = Intent(this, NeoTermActivity::class.java)
    notifyIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    val pendingIntent = PendingIntent.getActivity(this, 0, notifyIntent, 0)

    val sessionCount = mTerminalSessions.size
    val xSessionCount = mXSessions.size
    var contentText = getString(R.string.service_status_text, sessionCount, xSessionCount)

    val lockAcquired = mWakeLock != null
    if (lockAcquired) contentText += getString(R.string.service_lock_acquired)

    val builder = NotificationCompat.Builder(this, DEFAULT_CHANNEL_ID)
    builder.setContentTitle(getText(R.string.app_name))
    builder.setContentText(contentText)
    builder.setSmallIcon(R.drawable.ic_terminal_running)
    builder.setContentIntent(pendingIntent)
    builder.setOngoing(true)
    builder.setShowWhen(false)
    builder.color = 0xFF000000.toInt()

    builder.priority = if (lockAcquired) Notification.PRIORITY_HIGH else Notification.PRIORITY_LOW

    val exitIntent = Intent(this, NeoTermService::class.java).setAction(ACTION_SERVICE_STOP)
    builder.addAction(
      android.R.drawable.ic_delete,
      getString(R.string.exit),
      PendingIntent.getService(this, 0, exitIntent, 0)
    )

    val newWakeAction = if (lockAcquired) ACTION_RELEASE_LOCK else ACTION_ACQUIRE_LOCK
    val toggleWakeLockIntent = Intent(this, NeoTermService::class.java).setAction(newWakeAction)
    val actionTitle = getString(
      if (lockAcquired)
        R.string.service_release_lock
      else
        R.string.service_acquire_lock
    )
    val actionIcon = if (lockAcquired) android.R.drawable.ic_lock_idle_lock else android.R.drawable.ic_lock_lock
    builder.addAction(actionIcon, actionTitle, PendingIntent.getService(this, 0, toggleWakeLockIntent, 0))

    return builder.build()
  }

  private fun createNotificationChannel() {
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) return

    val channel = NotificationChannel(DEFAULT_CHANNEL_ID, "NeoTerm", NotificationManager.IMPORTANCE_LOW)
    channel.description = "NeoTerm notifications"
    val manager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
    manager.createNotificationChannel(channel)
  }

  @SuppressLint("WakelockTimeout")
  private fun acquireLock() {
    if (mWakeLock == null) {
      val pm = getSystemService(Context.POWER_SERVICE) as PowerManager
      mWakeLock = pm.newWakeLock(
        PowerManager.PARTIAL_WAKE_LOCK,
        EmulatorDebug.LOG_TAG + ":"
      )
      mWakeLock!!.acquire()

      val wm = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
      mWifiLock = wm.createWifiLock(WifiManager.WIFI_MODE_FULL_HIGH_PERF, EmulatorDebug.LOG_TAG)
      mWifiLock!!.acquire()

      updateNotification()
    }
  }

  private fun releaseLock() {
    if (mWakeLock != null) {
      mWakeLock!!.release()
      mWakeLock = null

      mWifiLock!!.release()
      mWifiLock = null

      updateNotification()
    }
  }

  companion object {
    val ACTION_SERVICE_STOP = "neoterm.action.service.stop"
    val ACTION_ACQUIRE_LOCK = "neoterm.action.service.lock.acquire"
    val ACTION_RELEASE_LOCK = "neoterm.action.service.lock.release"
    private val NOTIFICATION_ID = 52019

    val DEFAULT_CHANNEL_ID = "neoterm_notification_channel"
  }
}

```

`app/src/main/java/io/neoterm/setup/SetupThread.java`:

```java
package io.neoterm.setup;

import android.app.ProgressDialog;
import android.system.Os;
import android.util.Pair;
import androidx.appcompat.app.AppCompatActivity;
import io.neoterm.backend.EmulatorDebug;
import io.neoterm.component.config.NeoTermPath;
import io.neoterm.utils.NLog;

import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * @author kiva
 */

final class SetupThread extends Thread {
  private final SourceConnection sourceConnection;
  private final File prefixPath;
  private final AppCompatActivity activity;
  private final ResultListener resultListener;
  private final ProgressDialog progressDialog;

  public SetupThread(AppCompatActivity activity, SourceConnection sourceConnection,
                     File prefixPath, ResultListener resultListener,
                     ProgressDialog progressDialog) {
    this.activity = activity;
    this.sourceConnection = sourceConnection;
    this.prefixPath = prefixPath;
    this.resultListener = resultListener;
    this.progressDialog = progressDialog;
  }

  @Override
  public void run() {
    try {
      final String stagingPrefixPath = NeoTermPath.ROOT_PATH + "/usr-staging";
      final File stagingPrefixFile = new File(stagingPrefixPath);

      if (stagingPrefixFile.exists()) {
        deleteFolder(stagingPrefixFile);
      }

      int totalReadBytes = 0;
      final byte[] buffer = new byte[8096];
      final List<Pair<String, String>> symlinks = new ArrayList<>(50);


      try (ZipInputStream zipInput = new ZipInputStream(sourceConnection.getInputStream())) {
        ZipEntry zipEntry;

        int totalBytes = sourceConnection.getSize();

        while ((zipEntry = zipInput.getNextEntry()) != null) {
          totalReadBytes += zipEntry.getCompressedSize();

          final int totalReadBytesFinal = totalReadBytes;
          final int totalBytesFinal = totalBytes;

          activity.runOnUiThread(() -> {
            try {
              double progressFloat = ((double) totalReadBytesFinal) / ((double) totalBytesFinal) * 100.0;
              progressDialog.setProgress((int) progressFloat);
            } catch (RuntimeException ignore) {
              // activity dismissed
            }
          });

          if (zipEntry.getName().contains("SYMLINKS.txt")) {
            BufferedReader symlinksReader = new BufferedReader(new InputStreamReader(zipInput));
            String line;
            while ((line = symlinksReader.readLine()) != null) {
              if (line.isEmpty()) {
                continue;
              }
              String[] parts = line.split("←");
              if (parts.length != 2)
                throw new RuntimeException("Malformed symlink line: " + line);
              String oldPath = parts[0];
              String newPath = stagingPrefixPath + "/" + parts[1];
              symlinks.add(Pair.create(oldPath, newPath));
            }
          } else {
            String zipEntryName = zipEntry.getName();
            File targetFile = new File(stagingPrefixPath, zipEntryName);
            if (zipEntry.isDirectory()) {
              if (!targetFile.mkdirs())
                throw new RuntimeException("Failed to create directory: " + targetFile.getAbsolutePath());
            } else {
              try (FileOutputStream outStream = new FileOutputStream(targetFile)) {
                int readBytes;
                while ((readBytes = zipInput.read(buffer)) != -1) {
                  outStream.write(buffer, 0, readBytes);
                }
              }
              if (zipEntryName.startsWith("bin/") || zipEntryName.startsWith("libexec") || zipEntryName.startsWith("lib/apt/methods")) {
                //noinspection OctalInteger
                Os.chmod(targetFile.getAbsolutePath(), 0700);
              }
            }
          }
        }
      }

      sourceConnection.close();

      if (symlinks.isEmpty())
        throw new RuntimeException("No SYMLINKS.txt encountered");
      for (Pair<String, String> symlink : symlinks) {
        NLog.INSTANCE.e("Setup", "Linking " + symlink.first + " to " + symlink.second);
        Os.symlink(symlink.first, symlink.second);
      }

      if (!stagingPrefixFile.renameTo(prefixPath)) {
        throw new RuntimeException("Unable to rename staging folder");
      }

      activity.runOnUiThread(() -> resultListener.onResult(null));
    } catch (final Exception e) {
      NLog.INSTANCE.e(EmulatorDebug.LOG_TAG, "Bootstrap error", e);
      activity.runOnUiThread(() -> {
        try {
          resultListener.onResult(e);
        } catch (RuntimeException e1) {
          // Activity already dismissed - ignore.
        }
      });
    } finally {
      activity.runOnUiThread(() -> {
        try {
          progressDialog.dismiss();
        } catch (RuntimeException e) {
          // Activity already dismissed - ignore.
        }
      });
    }
  }

  private static void deleteFolder(File fileOrDirectory) throws IOException {
    if (fileOrDirectory.getCanonicalPath().equals(fileOrDirectory.getAbsolutePath()) && fileOrDirectory.isDirectory()) {
      File[] children = fileOrDirectory.listFiles();

      if (children != null) {
        for (File child : children) {
          deleteFolder(child);
        }
      }
    }

    if (!fileOrDirectory.delete()) {
      throw new RuntimeException("Unable to delete "
        + (fileOrDirectory.isDirectory() ? "directory " : "file ")
        + fileOrDirectory.getAbsolutePath());
    }
  }
}

```

`app/src/main/java/io/neoterm/setup/SourceConnection.java`:

```java
package io.neoterm.setup;

import java.io.IOException;
import java.io.InputStream;

/**
 * @author kiva
 */
public interface SourceConnection {
  InputStream getInputStream() throws IOException;
  int getSize();
  void close();
}

```

`app/src/main/java/io/neoterm/setup/connections.kt`:

```kt
package io.neoterm.setup

import android.content.Context
import android.net.Uri
import java.io.IOException
import java.io.InputStream
import java.net.HttpURLConnection
import java.net.URL

/**
 * @author kiva
 */

class BackupFileConnection(context: Context, uri: Uri) : LocalFileConnection(context, uri)

/**
 * @author kiva
 */

open class LocalFileConnection(context: Context, uri: Uri) : OfflineUriConnection(context, uri)

/**
 * @author kiva
 */

class NetworkConnection(private val sourceUrl: String) : SourceConnection {
  private var connection: HttpURLConnection? = null

  @Throws(IOException::class)
  override fun getInputStream(): InputStream {
    if (connection == null) {
      connection = openHttpConnection()
      connection!!.connectTimeout = 8000
      connection!!.readTimeout = 8000
    }
    return connection!!.inputStream
  }

  override fun getSize(): Int {
    return if (connection != null) {
      connection!!.contentLength
    } else 0

  }

  override fun close() {
    if (connection != null) {
      connection!!.disconnect()
    }
  }

  @Throws(IOException::class)
  private fun openHttpConnection(): HttpURLConnection {
    val arch = SetupHelper.determineArchName()

    return URL("$sourceUrl/boot/$arch.zip").openConnection() as HttpURLConnection
  }
}

/**
 * @author kiva
 */

abstract class OfflineConnection : SourceConnection {
  private var inputStream: InputStream? = null

  @Throws(IOException::class)
  protected abstract fun openInputStream(): InputStream

  @Throws(IOException::class)
  override fun getInputStream(): InputStream {
    if (inputStream == null) {
      inputStream = openInputStream()
    }
    return inputStream!!
  }

  override fun getSize(): Int {
    if (inputStream != null) {
      return try {
        inputStream!!.available()
      } catch (e: IOException) {
        e.printStackTrace()
        0
      }

    }
    return 0
  }

  override fun close() {
    if (inputStream != null) {
      try {
        inputStream!!.close()
      } catch (ignore: IOException) {
        ignore.printStackTrace()
      }

    }
  }
}

/**
 * @author kiva
 */

open class OfflineUriConnection(private val context: Context, private val uri: Uri) : OfflineConnection() {

  @Throws(IOException::class)
  override fun openInputStream(): InputStream {
    return context.contentResolver.openInputStream(uri)
  }
}

```

`app/src/main/java/io/neoterm/setup/setup.kt`:

```kt
package io.neoterm.setup

import android.app.ProgressDialog
import android.content.Context
import android.os.Build
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.App
import io.neoterm.R
import io.neoterm.component.config.NeoTermPath
import java.io.File
import java.util.*

/**
 * @author kiva
 */
interface ResultListener {
  fun onResult(error: Exception?)
}

/**
 * @author kiva
 */
object SetupHelper {
  fun needSetup(): Boolean {
    val PREFIX_FILE = File(NeoTermPath.USR_PATH)
    return !PREFIX_FILE.isDirectory
  }

  fun setup(
    activity: AppCompatActivity, connection: SourceConnection,
    resultListener: ResultListener
  ) {
    if (!needSetup()) {
      resultListener.onResult(null)
      return
    }

    val prefixFile = File(NeoTermPath.USR_PATH)

    val progress = makeProgressDialog(activity)
    progress.max = 100
    progress.show()

    SetupThread(activity, connection, prefixFile, resultListener, progress).start()
  }

  private fun makeProgressDialog(context: Context): ProgressDialog {
    return makeProgressDialog(context, context.getString(R.string.installer_message))
  }

  fun makeProgressDialog(context: Context, message: String): ProgressDialog {
    val dialog = ProgressDialog(context)
    dialog.setMessage(message)
    dialog.isIndeterminate = false
    dialog.setCancelable(false)
    dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL)
    return dialog
  }

  fun makeErrorDialog(context: Context, messageId: Int): AlertDialog {
    return makeErrorDialog(context, context.getString(messageId))
  }

  fun makeErrorDialog(context: Context, message: String): AlertDialog {
    return AlertDialog.Builder(context)
      .setTitle(R.string.error)
      .setMessage(message)
      .setPositiveButton(android.R.string.yes, null)
      .setNeutralButton(R.string.show_help) { _, _ -> App.get().openHelpLink() }
      .create()
  }

  fun determineArchName(): String {
    for (androidArch in Build.SUPPORTED_ABIS) {
      when (androidArch) {
        "arm64-v8a" -> return "aarch64"
        "armeabi-v7a" -> return "arm"
        "x86_64" -> return "x86_64"
      }
    }
    throw RuntimeException(
      "Unable to determine arch from Build.SUPPORTED_ABIS =  "
        + Arrays.toString(Build.SUPPORTED_ABIS)
    )
  }
}

```

`app/src/main/java/io/neoterm/ui/customize/BaseCustomizeActivity.kt`:

```kt
package io.neoterm.ui.customize

import android.annotation.SuppressLint
import android.view.MenuItem
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import io.neoterm.R
import io.neoterm.backend.TerminalSession
import io.neoterm.component.config.NeoTermPath
import io.neoterm.component.session.ShellParameter
import io.neoterm.frontend.session.terminal.BasicSessionCallback
import io.neoterm.frontend.session.terminal.BasicViewClient
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import io.neoterm.utils.Terminals

/**
 * @author kiva
 */
@SuppressLint("Registered")
open class BaseCustomizeActivity : AppCompatActivity() {
  lateinit var terminalView: TerminalView
  lateinit var viewClient: BasicViewClient
  lateinit var sessionCallback: BasicSessionCallback
  lateinit var session: TerminalSession
  lateinit var extraKeysView: ExtraKeysView

  fun initCustomizationComponent(layoutId: Int) {
    setContentView(layoutId)

    val toolbar = findViewById<Toolbar>(R.id.custom_toolbar)
    setSupportActionBar(toolbar)
    supportActionBar?.setDisplayHomeAsUpEnabled(true)

    terminalView = findViewById(R.id.terminal_view)
    extraKeysView = findViewById(R.id.custom_extra_keys)
    viewClient = BasicViewClient(terminalView)
    sessionCallback = BasicSessionCallback(terminalView)
    Terminals.setupTerminalView(terminalView, viewClient)
    Terminals.setupExtraKeysView(extraKeysView)

    val script = resources.getStringArray(R.array.custom_preview_script_colors)
    val parameter = ShellParameter()
      .executablePath("${NeoTermPath.USR_PATH}/bin/echo")
      .arguments(arrayOf("echo", "-e", *script))
      .callback(sessionCallback)
      .systemShell(false)

    session = Terminals.createSession(this, parameter)
    terminalView.attachSession(session)
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home -> finish()
    }
    return super.onOptionsItemSelected(item)
  }
}

```

`app/src/main/java/io/neoterm/ui/customize/ColorSchemeActivity.kt`:

```kt
package io.neoterm.ui.customize

import android.os.Bundle
import android.text.Editable
import android.text.TextWatcher
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.recyclerview.widget.LinearLayoutManager
import com.github.wrdlbrnft.sortedlistadapter.SortedListAdapter
import es.dmoral.coloromatic.ColorOMaticDialog
import es.dmoral.coloromatic.IndicatorMode
import es.dmoral.coloromatic.colormode.ColorMode
import io.neoterm.R
import io.neoterm.backend.TerminalColors
import io.neoterm.component.ComponentManager
import io.neoterm.component.colorscheme.ColorSchemeComponent
import io.neoterm.component.colorscheme.NeoColorScheme
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.utils.Terminals


/**
 * @author kiva
 */
class ColorSchemeActivity : BaseCustomizeActivity() {
  private val COMPARATOR = SortedListAdapter.ComparatorBuilder<ColorItem>()
    .setOrderForModel(ColorItem::class.java) { a, b ->
      a.colorType.compareTo(b.colorType)
    }
    .build()

  var changed = false
  private lateinit var editingColorScheme: NeoColorScheme
  lateinit var adapter: ColorItemAdapter

  private val colorSchemeComponent = ComponentManager.getComponent<ColorSchemeComponent>()

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    initCustomizationComponent(R.layout.ui_color_scheme)

    editingColorScheme = colorSchemeComponent.getCurrentColorScheme().copy()
    editingColorScheme.colorName = ""

    val terminalView = findViewById<TerminalView>(R.id.terminal_view)
    Terminals.setupTerminalView(terminalView, null)

    adapter = ColorItemAdapter(this, editingColorScheme, COMPARATOR, object : ColorItemAdapter.Listener {
      override fun onModelClicked(model: ColorItem) {
        showItemEditor(model)
      }
    })
    val recyclerView = findViewById<androidx.recyclerview.widget.RecyclerView>(R.id.custom_color_color_list)
    recyclerView.setHasFixedSize(true)
    recyclerView.layoutManager = LinearLayoutManager(this)
    recyclerView.adapter = adapter
  }

  override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    menuInflater.inflate(R.menu.menu_color_editor, menu)
    return true
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home -> finish()
      R.id.action_done -> applyColorScheme(editingColorScheme)
    }
    return super.onOptionsItemSelected(item)
  }

  override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
    if (keyCode == KeyEvent.KEYCODE_BACK && event!!.action == KeyEvent.ACTION_DOWN && changed) {
      AlertDialog.Builder(this)
        .setMessage(getString(R.string.discard_changes))
        .setPositiveButton(R.string.save) { _, _ ->
          applyColorScheme(editingColorScheme, true)
        }
        .setNegativeButton(android.R.string.no, null)
        .setNeutralButton(R.string.exit) { _, _ ->
          finish()
        }
        .show()
      return true
    }
    return super.onKeyDown(keyCode, event)
  }

  private fun showItemEditor(model: ColorItem) {
    val view = LayoutInflater.from(this).inflate(R.layout.dialog_edit_text, null, false)
    view.findViewById<TextView>(R.id.dialog_edit_text_info).text = getString(R.string.input_new_value)

    val edit = view.findViewById<EditText>(R.id.dialog_edit_text_editor)
    edit.setText(model.colorValue)
    if (model.colorValue.isNotEmpty()) {
      edit.setTextColor(TerminalColors.parse(model.colorValue))
    }
    edit.addTextChangedListener(object : TextWatcher {
      override fun afterTextChanged(editable: Editable?) {
        if (editable != null && editable.isNotEmpty()) {
          val color = TerminalColors.parse(editable.toString())
          if (color != 0) {
            edit.setTextColor(color)
          } else {
            edit.setTextColor(resources.getColor(R.color.textColor))
          }
        }
      }

      override fun beforeTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
      }

      override fun onTextChanged(p0: CharSequence?, p1: Int, p2: Int, p3: Int) {
      }
    })

    val applyColor: (newColor: String) -> Unit = { newColor ->
      model.colorValue = newColor
      adapter.notifyItemChanged(adapter.colorList.indexOf(model))

      editingColorScheme.setColor(model.colorType, model.colorValue)
      colorSchemeComponent.applyColorScheme(terminalView, null, editingColorScheme)
      changed = true
    }

    AlertDialog.Builder(this)
      .setTitle(model.colorName)
      .setView(view)
      .setNegativeButton(android.R.string.no, null)
      .setPositiveButton(android.R.string.yes) { _, _ ->
        applyColor(edit.text.toString());
      }
      .setNeutralButton(R.string.select_new_value) { _, _ ->
        ColorOMaticDialog.Builder()
          .initialColor(TerminalColors.parse(model.colorValue))
          .colorMode(ColorMode.RGB)
          .indicatorMode(IndicatorMode.HEX)
          .onColorSelected { newColor ->
            applyColor("#${Integer.toHexString(newColor).substring(2)}")
          }
          .showColorIndicator(true)
          .create()
          .show(supportFragmentManager, "ColorOMaticDialog")
      }
      .show()
  }

  private fun applyColorScheme(colorScheme: NeoColorScheme, finishAfter: Boolean = false) {
    if (colorScheme.colorName.isEmpty()) {
      val view = LayoutInflater.from(this).inflate(R.layout.dialog_edit_text, null, false)
      view.findViewById<TextView>(R.id.dialog_edit_text_info).text = getString(R.string.save_color_info)

      val edit = view.findViewById<EditText>(R.id.dialog_edit_text_editor)
      edit.setText(getString(R.string.save_color_scheme_name_template))

      AlertDialog.Builder(this)
        .setTitle(R.string.save_color)
        .setView(view)
        .setPositiveButton(android.R.string.yes) { _, _ ->
          colorScheme.colorName = edit.text.toString()
          applyColorScheme(colorScheme, finishAfter)
        }
        .setNegativeButton(android.R.string.no, null)
        .show()
    } else {
      try {
        colorSchemeComponent.saveColorScheme(colorScheme)
        colorSchemeComponent.reloadColorSchemes()
        colorSchemeComponent.setCurrentColorScheme(colorScheme)
        changed = false

        Toast.makeText(this, R.string.done, Toast.LENGTH_SHORT).show()
        if (finishAfter) {
          finish()
        }
      } catch (e: Exception) {
        Toast.makeText(this, getString(R.string.error) + ": ${e.localizedMessage}", Toast.LENGTH_LONG).show()
      }
    }
  }
}

```

`app/src/main/java/io/neoterm/ui/customize/CustomizeActivity.kt`:

```kt
package io.neoterm.ui.customize

import android.content.Intent
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Spinner
import android.widget.Toast
import io.neoterm.R
import io.neoterm.component.ComponentManager
import io.neoterm.component.colorscheme.ColorSchemeComponent
import io.neoterm.component.config.NeoTermPath
import io.neoterm.component.font.FontComponent
import io.neoterm.utils.getPathOfMediaUri
import java.io.File
import java.nio.file.Files
import java.nio.file.Paths

/**
 * @author kiva
 */
class CustomizeActivity : BaseCustomizeActivity() {
  private val REQUEST_SELECT_FONT = 22222
  private val REQUEST_SELECT_COLOR = 22223

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    initCustomizationComponent(R.layout.ui_customize)

    findViewById<View>(R.id.custom_install_font_button).setOnClickListener {
      val intent = Intent()
      intent.action = Intent.ACTION_GET_CONTENT
      intent.type = "*/*"
      startActivityForResult(Intent.createChooser(intent, getString(R.string.install_font)), REQUEST_SELECT_FONT)
    }

    findViewById<View>(R.id.custom_install_color_button).setOnClickListener {
      val intent = Intent()
      intent.action = Intent.ACTION_GET_CONTENT
      intent.type = "*/*"
      startActivityForResult(
        Intent.createChooser(intent, getString(R.string.install_color)),
        REQUEST_SELECT_COLOR
      )
    }
  }

  private fun setupSpinners() {
    val fontComponent = ComponentManager.getComponent<FontComponent>()
    val colorSchemeComponent = ComponentManager.getComponent<ColorSchemeComponent>()

    setupSpinner(R.id.custom_font_spinner, fontComponent.getFontNames(),
      fontComponent.getCurrentFontName(), object : AdapterView.OnItemSelectedListener {
        override fun onNothingSelected(parent: AdapterView<*>?) {
        }

        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
          val fontName = parent!!.adapter!!.getItem(position) as String
          val font = fontComponent.getFont(fontName)
          fontComponent.applyFont(terminalView, extraKeysView, font)
          fontComponent.setCurrentFont(fontName)
        }
      })

    val colorData = listOf(
      getString(R.string.new_color_scheme),
      *colorSchemeComponent.getColorSchemeNames().toTypedArray()
    )
    setupSpinner(R.id.custom_color_spinner, colorData,
      colorSchemeComponent.getCurrentColorSchemeName(), object : AdapterView.OnItemSelectedListener {
        override fun onNothingSelected(parent: AdapterView<*>?) {
        }

        override fun onItemSelected(parent: AdapterView<*>?, view: View?, position: Int, id: Long) {
          if (position == 0) {
            val intent = Intent(this@CustomizeActivity, ColorSchemeActivity::class.java)
            startActivity(intent)
            return
          }
          val colorName = parent!!.adapter!!.getItem(position) as String
          val color = colorSchemeComponent.getColorScheme(colorName)
          colorSchemeComponent.applyColorScheme(terminalView, extraKeysView, color)
          colorSchemeComponent.setCurrentColorScheme(colorName)
        }
      })
  }

  private fun setupSpinner(
    id: Int,
    data: List<String>,
    selected: String,
    listener: AdapterView.OnItemSelectedListener
  ): Spinner {
    val spinner = findViewById<Spinner>(id)
    val adapter = ArrayAdapter<String>(this, android.R.layout.simple_spinner_item, data)
    adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item)
    spinner.adapter = adapter
    spinner.onItemSelectedListener = listener
    spinner.setSelection(if (data.contains(selected)) data.indexOf(selected) else 0)
    return spinner
  }

  override fun onResume() {
    super.onResume()
    setupSpinners()
  }

  override fun onDestroy() {
    super.onDestroy()
    session.finishIfRunning()
  }

  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    if (resultCode == RESULT_OK && data != null) {
      val selected = this.getPathOfMediaUri( data.data)
      if (selected != null && selected.isNotEmpty()) {
        when (requestCode) {
          REQUEST_SELECT_FONT -> installFont(selected)
          REQUEST_SELECT_COLOR -> installColor(selected)
        }
      }
    }
    super.onActivityResult(requestCode, resultCode, data)
  }

  private fun installColor(selected: String) {
    installFileTo(selected, NeoTermPath.COLORS_PATH)
    setupSpinners()
  }

  private fun installFont(selected: String) {
    installFileTo(selected, NeoTermPath.FONT_PATH)
    setupSpinners()
  }

  private fun installFileTo(file: String, targetDir: String) {
    kotlin.runCatching {
      val source = File(file)
      Files.copy(source.toPath(), Paths.get(targetDir, source.name))
    }.onFailure {
      Toast.makeText(this, getString(R.string.error) + ": ${it.localizedMessage}", Toast.LENGTH_LONG).show()
    }
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home -> finish()
    }
    return super.onOptionsItemSelected(item)
  }
}

```

`app/src/main/java/io/neoterm/ui/customize/model.kt`:

```kt
package io.neoterm.ui.customize

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import com.github.wrdlbrnft.sortedlistadapter.SortedListAdapter
import com.simplecityapps.recyclerview_fastscroll.views.FastScrollRecyclerView
import io.neoterm.App
import io.neoterm.R
import io.neoterm.backend.TerminalColors
import io.neoterm.component.colorscheme.NeoColorScheme

/**
 * @author kiva
 */
class ColorItem(var colorType: Int, var colorValue: String) : SortedListAdapter.ViewModel {
  override fun <T> isSameModelAs(t: T): Boolean {
    if (t is ColorItem) {
      return t.colorName == colorName
        && t.colorValue == colorValue
        && t.colorType == colorType
    }
    return false
  }

  override fun <T> isContentTheSameAs(t: T): Boolean {
    return isSameModelAs(t)
  }

  var colorName = App.get().resources
    .getStringArray(R.array.color_item_names)[colorType - NeoColorScheme.COLOR_TYPE_BEGIN]
}

/**
 * @author kiva
 */
class ColorItemAdapter(
  context: Context,
  initColorScheme: NeoColorScheme,
  comparator: Comparator<ColorItem>,
  private val listener: ColorItemAdapter.Listener
) : SortedListAdapter<ColorItem>(context, ColorItem::class.java, comparator), FastScrollRecyclerView.SectionedAdapter {

  val colorList = mutableListOf<ColorItem>()

  init {
    (NeoColorScheme.COLOR_TYPE_BEGIN..NeoColorScheme.COLOR_TYPE_END)
      .forEach {
        colorList.add(ColorItem(it, initColorScheme.getColor(it) ?: ""))
      }
    edit().add(colorList).commit()
  }

  interface Listener {
    fun onModelClicked(model: ColorItem)
  }

  override fun getSectionName(position: Int): String {
    return colorList[position].colorName[0].toString()
  }

  override fun onCreateViewHolder(
    inflater: LayoutInflater,
    parent: ViewGroup,
    viewType: Int
  ): ViewHolder<out ColorItem> {
    val rootView = inflater.inflate(R.layout.item_color, parent, false)
    return ColorItemViewHolder(rootView, listener)
  }
}

class ColorItemViewHolder(private val rootView: View, private val listener: ColorItemAdapter.Listener) :
  SortedListAdapter.ViewHolder<ColorItem>(rootView) {
  private val colorItemName: TextView = rootView.findViewById(R.id.color_item_name)
  private val colorItemDesc: TextView = rootView.findViewById(R.id.color_item_description)
  private val colorView: View = rootView.findViewById(R.id.color_item_view)

  override fun performBind(item: ColorItem) {
    rootView.setOnClickListener { listener.onModelClicked(item) }
    colorItemName.text = item.colorName
    colorItemDesc.text = item.colorValue
    if (item.colorValue.isNotEmpty()) {
      val color = TerminalColors.parse(item.colorValue)
      colorView.setBackgroundColor(color)
      colorItemDesc.setTextColor(color)
    }
  }
}

```

`app/src/main/java/io/neoterm/ui/other/AboutActivity.kt`:

```kt
package io.neoterm.ui.other

import android.content.Intent
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.view.MenuItem
import android.view.View
import android.widget.TextView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import de.psdev.licensesdialog.LicensesDialog
import de.psdev.licensesdialog.licenses.ApacheSoftwareLicense20
import de.psdev.licensesdialog.licenses.GnuGeneralPublicLicense30
import de.psdev.licensesdialog.licenses.MITLicense
import de.psdev.licensesdialog.model.Notice
import de.psdev.licensesdialog.model.Notices
import io.neoterm.App
import io.neoterm.R


/**
 * @author kiva
 */
class AboutActivity : AppCompatActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.ui_about)
    setSupportActionBar(findViewById(R.id.about_toolbar))
    supportActionBar?.setDisplayHomeAsUpEnabled(true)

    try {
      val version = packageManager.getPackageInfo(packageName, 0).versionName
      (findViewById<TextView>(R.id.app_version)).text = version
    } catch (ignored: PackageManager.NameNotFoundException) {
    }

    findViewById<View>(R.id.about_licenses_view).setOnClickListener {
      val notices = Notices()
      notices.addNotice(
        Notice(
          "ADBToolkitInstaller",
          "https://github.com/Crixec/ADBToolKitsInstaller",
          "Copyright (c) 2017 Crixec",
          GnuGeneralPublicLicense30()
        )
      )
      notices.addNotice(
        Notice(
          "Android-Terminal-Emulator",
          "https://github.com/jackpal/Android-Terminal-Emulator",
          "Copyright (c) 2011-2016 Steven Luo",
          ApacheSoftwareLicense20()
        )
      )
      notices.addNotice(
        Notice(
          "ChromeLikeTabSwitcher",
          "https://github.com/michael-rapp/ChromeLikeTabSwitcher",
          "Copyright (c) 2016-2017 Michael Rapp",
          ApacheSoftwareLicense20()
        )
      )
      notices.addNotice(
        Notice(
          "Color-O-Matic",
          "https://github.com/GrenderG/Color-O-Matic",
          "Copyright 2016-2017 GrenderG",
          GnuGeneralPublicLicense30()
        )
      )
      notices.addNotice(
        Notice(
          "EventBus",
          "http://greenrobot.org",
          "Copyright (C) 2012-2016 Markus Junginger, greenrobot (http://greenrobot.org)",
          ApacheSoftwareLicense20()
        )
      )
      notices.addNotice(
        Notice(
          "ModularAdapter",
          "https://wrdlbrnft.github.io/ModularAdapter",
          "Copyright (c) 2017 Wrdlbrnft",
          MITLicense()
        )
      )
      notices.addNotice(
        Notice(
          "RecyclerTabLayout",
          "https://github.com/nshmura/RecyclerTabLayout",
          "Copyright (C) 2017 nshmura",
          ApacheSoftwareLicense20()
        )
      )
      notices.addNotice(
        Notice(
          "RecyclerView-FastScroll",
          "Copyright (c) 2016, Tim Malseed",
          "Copyright (c) 2016, Tim Malseed",
          ApacheSoftwareLicense20()
        )
      )
      notices.addNotice(
        Notice(
          "SortedListAdapter",
          "https://wrdlbrnft.github.io/SortedListAdapter/",
          "Copyright (c) 2017 Wrdlbrnft",
          MITLicense()
        )
      )
      notices.addNotice(
        Notice(
          "Termux",
          "https://termux.com",
          "Copyright 2016-2017 Fredrik Fornwall",
          GnuGeneralPublicLicense30()
        )
      )
      LicensesDialog.Builder(this)
        .setNotices(notices)
        .setIncludeOwnLicense(true)
        .build()
        .show()
    }

    findViewById<View>(R.id.about_version_view).setOnClickListener {
      App.get().easterEgg(this, "Emmmmmm...")
    }

    findViewById<View>(R.id.about_source_code_view).setOnClickListener {
      openUrl("https://github.com/NeoTerm/NeoTerm")
    }

    findViewById<View>(R.id.about_reset_app_view).setOnClickListener {
      AlertDialog.Builder(this)
        .setMessage(R.string.reset_app_warning)
        .setPositiveButton(R.string.yes) { _, _ ->
          resetApp()
        }
        .setNegativeButton(android.R.string.no, null)
        .show()
    }
  }

  private fun resetApp() {
    startActivity(Intent(this, SetupActivity::class.java))
  }

  private fun openUrl(url: String) {
    val intent = Intent(Intent.ACTION_VIEW)
    intent.data = Uri.parse(url)
    startActivity(intent)
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home ->
        finish()
    }
    return super.onOptionsItemSelected(item)
  }
}

```

`app/src/main/java/io/neoterm/ui/other/BonusActivity.kt`:

```kt
package io.neoterm.ui.other

import android.animation.ObjectAnimator
import android.content.res.ColorStateList
import android.graphics.Canvas
import android.graphics.Outline
import android.graphics.Paint
import android.graphics.Path
import android.graphics.drawable.Drawable
import android.graphics.drawable.GradientDrawable
import android.graphics.drawable.RippleDrawable
import android.graphics.drawable.ShapeDrawable
import android.graphics.drawable.shapes.OvalShape
import android.os.Bundle
import android.view.*
import android.view.animation.PathInterpolator
import android.widget.FrameLayout
import android.widget.ImageView
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.R

/**
 * @author kiva
 */

class BonusActivity : AppCompatActivity() {

  lateinit internal var mLayout: FrameLayout
  internal var mTapCount: Int = 0
  internal var mKeyCount: Int = 0
  internal var mInterpolator = PathInterpolator(0f, 0f, 0.5f, 1f)

  internal fun makeRipple(): Drawable {
    val idx = newColorIndex()
    val lollipopBackground = ShapeDrawable(OvalShape())
    lollipopBackground.paint.color = FLAVORS[idx]
    return RippleDrawable(
      ColorStateList.valueOf(FLAVORS[idx + 1]),
      lollipopBackground, null
    )
  }

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    mLayout = FrameLayout(this)
    window.setFlags(
      WindowManager.LayoutParams.FLAG_FULLSCREEN,
      WindowManager.LayoutParams.FLAG_FULLSCREEN
    )
    setContentView(mLayout)
  }

  override fun onAttachedToWindow() {
    val dm = resources.displayMetrics
    val dp = dm.density
    val size = (Math.min(Math.min(dm.widthPixels, dm.heightPixels).toFloat(), 600 * dp) - 100 * dp).toInt()
    val stick = object : View(this) {
      internal var mPaint = Paint()
      internal var mShadow = Path()

      public override fun onAttachedToWindow() {
        super.onAttachedToWindow()
        setWillNotDraw(false)
        outlineProvider = object : ViewOutlineProvider() {
          override fun getOutline(view: View, outline: Outline) {
            outline.setRect(0, height / 2, width, height)
          }
        }
      }

      public override fun onDraw(c: Canvas) {
        val w = c.width
        val h = c.height / 2
        c.translate(0f, h.toFloat())
        val g = GradientDrawable()
        g.orientation = GradientDrawable.Orientation.LEFT_RIGHT
        g.setGradientCenter(w * 0.75f, 0f)
        g.colors = intArrayOf(0xFFFFFFFF.toInt(), 0xFFAAAAAA.toInt())
        g.setBounds(0, 0, w, h)
        g.draw(c)
        mPaint.color = 0xFFAAAAAA.toInt()
        mShadow.reset()
        mShadow.moveTo(0f, 0f)
        mShadow.lineTo(w.toFloat(), 0f)
        mShadow.lineTo(w.toFloat(), size / 2 + 1.5f * w)
        mShadow.lineTo(0f, (size / 2).toFloat())
        mShadow.close()
        c.drawPath(mShadow, mPaint)
      }
    }
    mLayout.addView(
      stick, FrameLayout.LayoutParams(
        (32 * dp).toInt(),
        ViewGroup.LayoutParams.MATCH_PARENT, Gravity.CENTER_HORIZONTAL
      )
    )
    stick.alpha = 0f

    val im = ImageView(this)
    im.translationZ = 20f
    im.scaleX = 0f
    im.scaleY = 0f
    val platlogo = getDrawable(R.drawable.plat_logo)
    platlogo!!.alpha = 0
    im.setImageDrawable(platlogo)
    im.background = makeRipple()
    im.isClickable = true
    val highlight = ShapeDrawable(OvalShape())
    highlight.paint.color = 0x10FFFFFF
    highlight.setBounds(
      (size * .15f).toInt(), (size * .15f).toInt(),
      (size * .6f).toInt(), (size * .6f).toInt()
    )
    im.overlay.add(highlight)
    im.setOnClickListener {
      if (mTapCount == 0) {
        im.animate()
          .translationZ(40f)
          .scaleX(1f)
          .scaleY(1f)
          .setInterpolator(mInterpolator)
          .setDuration(700)
          .setStartDelay(500)
          .start()

        val a = ObjectAnimator.ofInt(platlogo, "alpha", 0, 255)
        a.interpolator = mInterpolator
        a.startDelay = 1000
        a.start()

        stick.animate()
          .translationZ(20f)
          .alpha(1f)
          .setInterpolator(mInterpolator)
          .setDuration(700)
          .setStartDelay(750)
          .start()
      } else {
        im.background = makeRipple()
      }
      mTapCount++
    }

    // Enable hardware keyboard input for TV compatibility.
    im.isFocusable = true
    im.requestFocus()
    im.setOnKeyListener { v, keyCode, event ->
      if (keyCode != KeyEvent.KEYCODE_BACK && event.action == KeyEvent.ACTION_DOWN) {
        ++mKeyCount
        if (mKeyCount > 2) {
          if (mTapCount > 5) {
            im.performLongClick()
          } else {
            im.performClick()
          }
        }
        true
      } else {
        false
      }
    }

    mLayout.addView(im, FrameLayout.LayoutParams(size, size, Gravity.CENTER))

    im.animate().scaleX(0.3f).scaleY(0.3f)
      .setInterpolator(mInterpolator)
      .setDuration(500)
      .setStartDelay(800)
      .start()
  }

  companion object {
    internal val FLAVORS = intArrayOf(
      0xFF9C27B0.toInt(), 0xFFBA68C8.toInt(), // grape
      0xFFFF9800.toInt(), 0xFFFFB74D.toInt(), // orange
      0xFFF06292.toInt(), 0xFFF8BBD0.toInt(), // bubblegum
      0xFFAFB42B.toInt(), 0xFFCDDC39.toInt(), // lime
      0xFF795548.toInt(), 0xFFA1887F.toInt()
    )// mystery flavor

    internal fun newColorIndex(): Int {
      return 2 * (Math.random() * FLAVORS.size / 2).toInt()
    }
  }
}

```

`app/src/main/java/io/neoterm/ui/other/CrashActivity.kt`:

```kt
package io.neoterm.ui.other

import android.os.Build
import android.os.Bundle
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.R
import java.io.ByteArrayOutputStream
import java.io.PrintStream

/**
 * @author kiva
 */
class CrashActivity : AppCompatActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.ui_crash)
    setSupportActionBar(findViewById(R.id.crash_toolbar))

    (findViewById<TextView>(R.id.crash_model)).text = getString(R.string.crash_model, collectModelInfo())
    (findViewById<TextView>(R.id.crash_app_version)).text = getString(R.string.crash_app, collectAppInfo())
    (findViewById<TextView>(R.id.crash_details)).text = collectExceptionInfo()
  }

  private fun collectExceptionInfo(): String {
    val extra = intent.getSerializableExtra("exception")
    if (extra != null && extra is Throwable) {
      val byteArrayOutput = ByteArrayOutputStream()
      val printStream = PrintStream(byteArrayOutput)
      (extra.cause ?: extra).printStackTrace(printStream)
      return byteArrayOutput.use {
        byteArrayOutput.toString("utf-8")
      }
    }
    return "are.you.kidding.me.NoExceptionFoundException: This is a bug, please contact developers!"
  }

  private fun collectAppInfo(): String {
    val pm = packageManager
    val info = pm.getPackageInfo(packageName, 0)
    return "${info.versionName} (${info.versionCode})"
  }

  private fun collectModelInfo(): String {
    return "${Build.MODEL} (Android ${Build.VERSION.RELEASE} ${determineArchName()})"
  }

  private fun determineArchName(): String {
    for (androidArch in Build.SUPPORTED_ABIS) {
      when (androidArch) {
        "arm64-v8a" -> return "aarch64"
        "armeabi-v7a" -> return "arm"
        "x86_64" -> return "x86_64"
        "x86" -> return "i686"
      }
    }
    return "Unknown Arch"
  }
}

```

`app/src/main/java/io/neoterm/ui/other/SetupActivity.kt`:

```kt
package io.neoterm.ui.other

import android.content.ActivityNotFoundException
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.view.LayoutInflater
import android.view.View
import android.widget.*
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.App
import io.neoterm.R
import io.neoterm.component.config.NeoTermPath
import io.neoterm.component.pm.SourceHelper
import io.neoterm.setup.*
import io.neoterm.utils.getPathOfMediaUri
import io.neoterm.utils.runApt
import java.io.File


/**
 * @author kiva
 */
class SetupActivity : AppCompatActivity(), View.OnClickListener, ResultListener {
  companion object {
    private const val REQUEST_SELECT_PARAMETER = 520;
  }

  private var setupParameter = ""
  private var setupParameterUri: Uri? = null

  private val hintMapping = arrayOf(
    R.id.setup_method_online, R.string.setup_hint_online,
    R.id.setup_method_local, R.string.setup_hint_local,
    R.id.setup_method_backup, R.string.setup_hint_backup
  )

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.ui_setup)

    val parameterEditor = findViewById<EditText>(R.id.setup_source_parameter)

    val tipText = findViewById<TextView>(R.id.setup_url_tip_text)

    val onCheckedChangeListener = CompoundButton.OnCheckedChangeListener { button, checked ->
      if (checked) {
        val id = button.id
        val index = hintMapping.indexOf(id)
        if (index < 0 || index % 2 != 0) {
          parameterEditor.setHint(R.string.setup_input_source_parameter)
          return@OnCheckedChangeListener
        }
        parameterEditor.setHint(hintMapping[index + 1])
        tipText.setText(hintMapping[index + 1])
        setDefaultValue(parameterEditor, id)
      }
    }

    findViewById<RadioButton>(R.id.setup_method_online).setOnCheckedChangeListener(onCheckedChangeListener)
    findViewById<RadioButton>(R.id.setup_method_local).setOnCheckedChangeListener(onCheckedChangeListener)
    findViewById<RadioButton>(R.id.setup_method_backup).setOnCheckedChangeListener(onCheckedChangeListener)

    findViewById<Button>(R.id.setup_next).setOnClickListener(this)
    findViewById<Button>(R.id.setup_source_parameter_select).setOnClickListener(this)
  }

  override fun onClick(view: View?) {
    val clickedId = view?.id ?: return
    when (clickedId) {
      R.id.setup_source_parameter_select -> doSelectParameter()
      R.id.setup_next -> doPrepareSetup()
    }
  }

  override fun onActivityResult(requestCode: Int, resultCode: Int, resultData: Intent?) {
    if (requestCode == REQUEST_SELECT_PARAMETER && resultCode == RESULT_OK) {
      if (resultData != null) {
        val path = this.getPathOfMediaUri(resultData.data)
        findViewById<EditText>(R.id.setup_source_parameter).setText(path)
        return
      }
    }
    super.onActivityResult(requestCode, resultCode, resultData)
  }

  private fun doPrepareSetup() {
    val id = findViewById<RadioGroup>(R.id.setup_method_group).checkedRadioButtonId
    val editor = findViewById<EditText>(R.id.setup_source_parameter)
    setupParameter = editor.text.toString()
    if (setupParameterUri == null) {
      when (id) {
        R.id.setup_method_backup,
        R.id.setup_method_local -> {
          SetupHelper.makeErrorDialog(this, R.string.setup_error_parameter_null).show()
          return
        }
      }
    }

    val dialog = SetupHelper.makeProgressDialog(this, getString(R.string.setup_preparing))
    dialog.show()

    Thread {
      val errorMessage = validateParameter(id, setupParameter)

      runOnUiThread {
        dialog.dismiss()
        editor.error = errorMessage
        if (errorMessage != null) {
          SetupHelper.makeErrorDialog(this, errorMessage).show()
          return@runOnUiThread
        }

        val connection = createSourceConnection(id, setupParameter, setupParameterUri)
        showConfirmDialog(connection)
      }
    }.start()
  }

  private fun doSelectParameter() {
    val id = findViewById<RadioGroup>(R.id.setup_method_group).checkedRadioButtonId
    when (id) {
      R.id.setup_method_backup,
      R.id.setup_method_local -> {
        val intent = Intent(Intent.ACTION_GET_CONTENT)
        intent.type = "*/*"
        try {
          startActivityForResult(
            Intent.createChooser(intent, getString(R.string.setup_local)),
            REQUEST_SELECT_PARAMETER
          )
        } catch (ignore: ActivityNotFoundException) {
          Toast.makeText(this, R.string.no_file_picker, Toast.LENGTH_SHORT).show()
        }
      }

      R.id.setup_method_online -> {
        val view = LayoutInflater.from(this).inflate(R.layout.dialog_edit_text, null, false)
        view.findViewById<TextView>(R.id.dialog_edit_text_info).text = getString(R.string.input_new_source_url)

        val edit = view.findViewById<EditText>(R.id.dialog_edit_text_editor)

        AlertDialog.Builder(this)
          .setTitle(R.string.new_source)
          .setView(view)
          .setPositiveButton(android.R.string.yes) { _, _ ->
            val newURL = edit.text.toString()
            val parameterEditor = findViewById<EditText>(R.id.setup_source_parameter)
            parameterEditor.setText(newURL)
          }
          .setNegativeButton(android.R.string.no, null)
          .show()
      }
    }
  }

  private fun createSourceConnection(id: Int, parameter: String, parameterUri: Uri?): SourceConnection {
    return when (id) {
      R.id.setup_method_local -> LocalFileConnection(this, parameterUri!!)
      R.id.setup_method_online -> NetworkConnection(parameter)
      R.id.setup_method_backup -> BackupFileConnection(this, parameterUri!!)
      else -> throw IllegalArgumentException("Unexpected setup method!")
    }
  }

  private fun validateParameter(id: Int, parameter: String): String? {
    return when (id) {
      R.id.setup_method_online -> try {
        java.net.URI.create(parameter)
        null
      } catch (e: IllegalArgumentException) {
        getString(R.string.setup_error_invalid_url)
      }
      R.id.setup_method_local,
      R.id.setup_method_backup -> if (File(parameter).exists()) null else getString(R.string.setup_error_file_not_found)
      else -> null
    }
  }

  private fun setDefaultValue(parameterEditor: EditText, id: Int) {
    setupParameter = when (id) {
      R.id.setup_method_online -> NeoTermPath.DEFAULT_MAIN_PACKAGE_SOURCE
      else -> ""
    }
    parameterEditor.setText(setupParameter)
  }

  private fun showConfirmDialog(connection: SourceConnection) {
    val needSetup = SetupHelper.needSetup()
    val titleId = if (needSetup) R.string.setup_confirm else R.string.setup_reset_confirm
    val messageId = if (needSetup) R.string.setup_confirm_text else R.string.setup_reset_confirm_text

    AlertDialog.Builder(this)
      .setTitle(titleId)
      .setMessage(messageId)
      .setPositiveButton(android.R.string.yes) { _, _ ->
        doSetup(connection)
      }
      .setNegativeButton(android.R.string.no, null)
      .show()
  }

  private fun doSetup(connection: SourceConnection) {
    SetupHelper.setup(this, connection, this)
  }

  override fun onResult(error: Exception?) {
    if (error == null) {
      setResult(RESULT_OK)
      SourceHelper.syncSource()
      executeAptUpdate()

    } else {
      AlertDialog.Builder(this)
        .setTitle(R.string.error)
        .setMessage(error.toString())
        .setNegativeButton(R.string.use_system_shell) { _, _ ->
          setResult(RESULT_CANCELED)
          finish()
        }
        .setNeutralButton(R.string.show_help) { _, _ ->
          App.get().openHelpLink()
        }
        .setPositiveButton(android.R.string.yes, null)
        .show()
    }
  }

  private fun executeAptUpdate() = runApt("update") {
    it.onSuccess { executeAptUpgrade() }
  }

  private fun executeAptUpgrade() = runApt("upgrade", "-y") {
    it.onSuccess { finish() }
  }
}

```

`app/src/main/java/io/neoterm/ui/pm/PackageManagerActivity.kt`:

```kt
package io.neoterm.ui.pm

import android.annotation.SuppressLint
import android.os.Bundle
import android.view.LayoutInflater
import android.view.Menu
import android.view.MenuItem
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.SearchView
import androidx.appcompat.widget.Toolbar
import androidx.core.view.MenuItemCompat
import androidx.recyclerview.widget.LinearLayoutManager
import com.github.wrdlbrnft.sortedlistadapter.SortedListAdapter
import io.neoterm.R
import io.neoterm.component.ComponentManager
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.pm.*
import io.neoterm.utils.StringDistance
import io.neoterm.utils.runApt
import java.util.*

/**
 * @author kiva
 */

class PackageManagerActivity : AppCompatActivity(), SearchView.OnQueryTextListener, SortedListAdapter.Callback {
  private val comparator = SortedListAdapter.ComparatorBuilder<PackageModel>()
    .setOrderForModel<PackageModel>(PackageModel::class.java) { a, b ->
      a.packageInfo.packageName!!.compareTo(b.packageInfo.packageName!!)
    }
    .build()

  lateinit var recyclerView: androidx.recyclerview.widget.RecyclerView
  lateinit var adapter: PackageAdapter
  var models = listOf<PackageModel>()

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.ui_pm_single_tab)
    val toolbar = findViewById<Toolbar>(R.id.pm_toolbar)
    setSupportActionBar(toolbar)
    supportActionBar?.setDisplayHomeAsUpEnabled(true)

    recyclerView = findViewById(R.id.pm_package_list)
    recyclerView.setHasFixedSize(true)
    adapter = PackageAdapter(this, comparator, object : PackageAdapter.Listener {
      override fun onModelClicked(model: PackageModel) {
        AlertDialog.Builder(this@PackageManagerActivity)
          .setTitle(model.packageInfo.packageName)
          .setMessage(model.getPackageDetails(this@PackageManagerActivity))
          .setPositiveButton(R.string.install) { _, _ ->
            installPackage(model.packageInfo.packageName)
          }
          .setNegativeButton(android.R.string.no, null)
          .show()
      }
    })
    adapter.addCallback(this)

    recyclerView.layoutManager = LinearLayoutManager(this)
    recyclerView.adapter = adapter
    refreshPackageList()
  }

  private fun installPackage(packageName: String?) = packageName?.let {
    runApt("install", "-y", it, autoClose = false) {
      it.onSuccess { it.setTitle(getString(R.string.done)) }
    }
  }

  override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    menuInflater.inflate(R.menu.menu_pm, menu)
    val searchItem = menu!!.findItem(R.id.action_search)
    val searchView = MenuItemCompat.getActionView(searchItem) as SearchView
    searchView.setOnQueryTextListener(this)
    return true
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home -> finish()
      R.id.action_source -> changeSource()
      R.id.action_update_and_refresh -> executeAptUpdate()
      R.id.action_refresh -> refreshPackageList()
      R.id.action_upgrade -> executeAptUpgrade()
    }
    return super.onOptionsItemSelected(item)
  }

  private fun changeSource() {
    val sourceManager = ComponentManager.getComponent<PackageComponent>().sourceManager
    val sourceList = sourceManager.getAllSources()

    val items = sourceList.map { "${it.url} :: ${it.repo}" }.toTypedArray()
    val selection = sourceList.map { it.enabled }.toBooleanArray()
    AlertDialog.Builder(this)
      .setTitle(R.string.pref_package_source)
      .setMultiChoiceItems(items, selection) { _, which, isChecked ->
        sourceList[which].enabled = isChecked
      }
      .setPositiveButton(android.R.string.yes) { _, _ -> changeSourceInternal(sourceManager, sourceList) }
      .setNeutralButton(R.string.new_source) { _, _ -> changeSourceToUserInput(sourceManager) }
      .setNegativeButton(android.R.string.no, null)
      .show()
  }

  @SuppressLint("SetTextI18n")
  private fun changeSourceToUserInput(sourceManager: SourceManager) {
    val view = LayoutInflater.from(this).inflate(R.layout.dialog_edit_two_text, null, false)
    view.findViewById<TextView>(R.id.dialog_edit_text_info).text = getString(R.string.input_new_source_url)
    view.findViewById<TextView>(R.id.dialog_edit_text2_info).text = getString(R.string.input_new_source_repo)

    val urlEditor = view.findViewById<EditText>(R.id.dialog_edit_text_editor)
    val repoEditor = view.findViewById<EditText>(R.id.dialog_edit_text2_editor)
    repoEditor.setText("stable main")

    AlertDialog.Builder(this)
      .setTitle(R.string.pref_package_source)
      .setView(view)
      .setNegativeButton(android.R.string.no, null)
      .setPositiveButton(android.R.string.yes) { _, _ ->
        val url = urlEditor.text.toString()
        val repo = repoEditor.text.toString()
        var errored = false
        if (url.trim().isEmpty()) {
          urlEditor.error = getString(R.string.error_new_source_url)
          errored = true
        }
        if (repo.trim().isEmpty()) {
          repoEditor.error = getString(R.string.error_new_source_repo)
          errored = true
        }
        if (errored) {
          return@setPositiveButton
        }
        val source = urlEditor.text.toString()
        sourceManager.addSource(source, repo, true)
        postChangeSource(sourceManager)
      }
      .show()
  }

  private fun changeSourceInternal(sourceManager: SourceManager, source: List<Source>) {
    sourceManager.updateAll(source)
    postChangeSource(sourceManager)
  }

  private fun postChangeSource(sourceManager: SourceManager) {
    sourceManager.applyChanges()
    NeoPreference.store(R.string.key_package_source, sourceManager.getMainPackageSource())
    SourceHelper.syncSource(sourceManager)
    executeAptUpdate()
  }

  private fun executeAptUpdate() = runApt("update") {
    it.onSuccess { refreshPackageList() }
  }

  private fun executeAptUpgrade() = runApt("update") { update ->
    update.onSuccess {
      runApt("upgrade", "-y") {
        it.onSuccess { Toast.makeText(this, R.string.apt_upgrade_ok, Toast.LENGTH_SHORT).show() }
      }
    }
  }

  private fun refreshPackageList() = Thread {
    val pm = ComponentManager.getComponent<PackageComponent>()
    val sourceFiles = SourceHelper.detectSourceFiles()

    pm.clearPackages()
    sourceFiles.forEach { pm.reloadPackages(it, false) }
    models = pm.packages.values.map { PackageModel(it) }.toList()

    this@PackageManagerActivity.runOnUiThread {
      adapter.edit().replaceAll(models).commit()
      if (models.isEmpty()) {
        Toast.makeText(this@PackageManagerActivity, R.string.package_list_empty, Toast.LENGTH_SHORT).show()
      }
    }
  }.start()

  private fun sortDistance(
    models: List<PackageModel>, query: String,
    mapper: (NeoPackageInfo) -> String
  ): List<Pair<PackageModel, Int>> {
    return models
      .map {
        it to StringDistance.distance(mapper(it.packageInfo).toLowerCase(Locale.ROOT), query.toLowerCase(Locale.ROOT))
      }
      .sortedWith { l, r -> r.second.compareTo(l.second) }
      .toList()
  }

  private fun filter(models: List<PackageModel>, query: String): List<PackageModel> {
    val prepared = models.filter {
      it.packageInfo.packageName!!.contains(query, true)
        || it.packageInfo.description!!.contains(query, true)
    }

    return sortDistance(prepared, query) { it.packageName!! }
      .plus(sortDistance(prepared, query) { it.description!! })
      .map { it.first }
      .toList()
  }

  override fun onQueryTextSubmit(text: String?) = false

  override fun onQueryTextChange(text: String?): Boolean {
    text?.let { adapter.edit().replaceAll(filter(models, it)).commit() }
    return true
  }

  override fun onEditStarted() {
    recyclerView.animate().alpha(0.5f)
  }

  override fun onEditFinished() {
    recyclerView.scrollToPosition(0)
    recyclerView.animate().alpha(1.0f)
  }
}

```

`app/src/main/java/io/neoterm/ui/pm/model.kt`:

```kt
package io.neoterm.ui.pm

import android.content.Context
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.TextView
import com.github.wrdlbrnft.sortedlistadapter.SortedListAdapter
import com.simplecityapps.recyclerview_fastscroll.views.FastScrollRecyclerView
import io.neoterm.R
import io.neoterm.component.pm.NeoPackageInfo
import io.neoterm.utils.formatSizeInKB

class PackageAdapter(
  context: Context,
  comparator: Comparator<PackageModel>,
  private val listener: PackageAdapter.Listener
) : SortedListAdapter<PackageModel>(context, PackageModel::class.java, comparator),
  FastScrollRecyclerView.SectionedAdapter {

  override fun getSectionName(position: Int): String {
    return getItem(position).packageInfo.packageName?.substring(0, 1) ?: "#"
  }

  interface Listener {
    fun onModelClicked(model: PackageModel)
  }

  override fun onCreateViewHolder(
    inflater: LayoutInflater,
    parent: ViewGroup,
    viewType: Int
  ): ViewHolder<out PackageModel> {
    val rootView = inflater.inflate(R.layout.item_package, parent, false)
    return PackageViewHolder(rootView, listener)
  }
}

class PackageViewHolder(private val rootView: View, private val listener: PackageAdapter.Listener) :
  SortedListAdapter.ViewHolder<PackageModel>(rootView) {
  private val packageNameView: TextView = rootView.findViewById(R.id.package_item_name)
  private val packageDescView: TextView = rootView.findViewById(R.id.package_item_desc)

  override fun performBind(item: PackageModel) {
    rootView.setOnClickListener { listener.onModelClicked(item) }
    packageNameView.text = item.packageInfo.packageName
    packageDescView.text = item.packageInfo.description
  }
}

/**
 * @author kiva
 */

class PackageModel(val packageInfo: NeoPackageInfo) : SortedListAdapter.ViewModel {
  override fun <T> isSameModelAs(t: T): Boolean {
    if (t is PackageModel) {
      return t.packageInfo.packageName == packageInfo.packageName
    }
    return false
  }

  override fun <T> isContentTheSameAs(t: T): Boolean {
    return isSameModelAs(t)
  }

  fun getPackageDetails(context: Context): String {
    return context.getString(
      R.string.package_details,
      packageInfo.packageName, packageInfo.version,
      packageInfo.dependenciesString,
      packageInfo.installedSizeInBytes.formatSizeInKB(),
      packageInfo.description, packageInfo.homePage
    )
  }
}

```

`app/src/main/java/io/neoterm/ui/pm/view/RecyclerTabLayout.java`:

```java
/**
 * Copyright (C) 2015 nshmura
 * Copyright (C) 2015 The Android Open Source Project
 * <p/>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p/>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p/>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.neoterm.ui.pm.view;

import android.animation.ValueAnimator;
import android.content.Context;
import android.content.res.ColorStateList;
import android.content.res.TypedArray;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.TextView;
import androidx.appcompat.content.res.AppCompatResources;
import androidx.appcompat.widget.AppCompatTextView;
import androidx.core.view.ViewCompat;
import androidx.recyclerview.widget.LinearLayoutManager;
import androidx.recyclerview.widget.RecyclerView;
import androidx.viewpager.widget.ViewPager;
import io.neoterm.R;

public class RecyclerTabLayout extends RecyclerView {

  protected static final long DEFAULT_SCROLL_DURATION = 200;
  protected static final float DEFAULT_POSITION_THRESHOLD = 0.6f;
  protected static final float POSITION_THRESHOLD_ALLOWABLE = 0.001f;

  protected Paint mIndicatorPaint;
  protected int mTabBackgroundResId;
  protected int mTabOnScreenLimit;
  protected int mTabMinWidth;
  protected int mTabMaxWidth;
  protected int mTabTextAppearance;
  protected int mTabSelectedTextColor;
  protected boolean mTabSelectedTextColorSet;
  protected int mTabPaddingStart;
  protected int mTabPaddingTop;
  protected int mTabPaddingEnd;
  protected int mTabPaddingBottom;
  protected int mIndicatorHeight;

  protected LinearLayoutManager mLinearLayoutManager;
  protected RecyclerOnScrollListener mRecyclerOnScrollListener;
  protected ViewPager mViewPager;
  protected Adapter<?> mAdapter;

  protected int mIndicatorPosition;
  protected int mIndicatorGap;
  protected int mIndicatorScroll;
  private int mOldPosition;
  private int mOldScrollOffset;
  protected float mOldPositionOffset;
  protected float mPositionThreshold;
  protected boolean mRequestScrollToTab;
  protected boolean mScrollEanbled;

  public RecyclerTabLayout(Context context) {
    this(context, null);
  }

  public RecyclerTabLayout(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
  }

  public RecyclerTabLayout(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    setWillNotDraw(false);
    mIndicatorPaint = new Paint();
    getAttributes(context, attrs, defStyle);
    mLinearLayoutManager = new LinearLayoutManager(getContext()) {
      @Override
      public boolean canScrollHorizontally() {
        return mScrollEanbled;
      }
    };
    mLinearLayoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);
    setLayoutManager(mLinearLayoutManager);
    setItemAnimator(null);
    mPositionThreshold = DEFAULT_POSITION_THRESHOLD;
  }

  private void getAttributes(Context context, AttributeSet attrs, int defStyle) {
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.rtl_RecyclerTabLayout,
      defStyle, R.style.rtl_RecyclerTabLayout);
    setIndicatorColor(a.getColor(R.styleable
      .rtl_RecyclerTabLayout_rtl_tabIndicatorColor, 0));
    setIndicatorHeight(a.getDimensionPixelSize(R.styleable
      .rtl_RecyclerTabLayout_rtl_tabIndicatorHeight, 0));

    mTabTextAppearance = a.getResourceId(R.styleable.rtl_RecyclerTabLayout_rtl_tabTextAppearance,
      R.style.rtl_RecyclerTabLayout_Tab);

    mTabPaddingStart = mTabPaddingTop = mTabPaddingEnd = mTabPaddingBottom = a
      .getDimensionPixelSize(R.styleable.rtl_RecyclerTabLayout_rtl_tabPadding, 0);
    mTabPaddingStart = a.getDimensionPixelSize(
      R.styleable.rtl_RecyclerTabLayout_rtl_tabPaddingStart, mTabPaddingStart);
    mTabPaddingTop = a.getDimensionPixelSize(
      R.styleable.rtl_RecyclerTabLayout_rtl_tabPaddingTop, mTabPaddingTop);
    mTabPaddingEnd = a.getDimensionPixelSize(
      R.styleable.rtl_RecyclerTabLayout_rtl_tabPaddingEnd, mTabPaddingEnd);
    mTabPaddingBottom = a.getDimensionPixelSize(
      R.styleable.rtl_RecyclerTabLayout_rtl_tabPaddingBottom, mTabPaddingBottom);

    if (a.hasValue(R.styleable.rtl_RecyclerTabLayout_rtl_tabSelectedTextColor)) {
      mTabSelectedTextColor = a
        .getColor(R.styleable.rtl_RecyclerTabLayout_rtl_tabSelectedTextColor, 0);
      mTabSelectedTextColorSet = true;
    }

    mTabOnScreenLimit = a.getInteger(
      R.styleable.rtl_RecyclerTabLayout_rtl_tabOnScreenLimit, 0);
    if (mTabOnScreenLimit == 0) {
      mTabMinWidth = a.getDimensionPixelSize(
        R.styleable.rtl_RecyclerTabLayout_rtl_tabMinWidth, 0);
      mTabMaxWidth = a.getDimensionPixelSize(
        R.styleable.rtl_RecyclerTabLayout_rtl_tabMaxWidth, 0);
    }

    mTabBackgroundResId = a
      .getResourceId(R.styleable.rtl_RecyclerTabLayout_rtl_tabBackground, 0);
    mScrollEanbled = a.getBoolean(R.styleable.rtl_RecyclerTabLayout_rtl_scrollEnabled, true);
    a.recycle();
  }

  @Override
  protected void onDetachedFromWindow() {
    if (mRecyclerOnScrollListener != null) {
      removeOnScrollListener(mRecyclerOnScrollListener);
      mRecyclerOnScrollListener = null;
    }
    super.onDetachedFromWindow();
  }


  public void setIndicatorColor(int color) {
    mIndicatorPaint.setColor(color);
  }

  public void setIndicatorHeight(int indicatorHeight) {
    mIndicatorHeight = indicatorHeight;
  }

  public void setAutoSelectionMode(boolean autoSelect) {
    if (mRecyclerOnScrollListener != null) {
      removeOnScrollListener(mRecyclerOnScrollListener);
      mRecyclerOnScrollListener = null;
    }
    if (autoSelect) {
      mRecyclerOnScrollListener = new RecyclerOnScrollListener(this, mLinearLayoutManager);
      addOnScrollListener(mRecyclerOnScrollListener);
    }
  }

  public void setPositionThreshold(float positionThreshold) {
    mPositionThreshold = positionThreshold;
  }

  public void setUpWithViewPager(ViewPager viewPager) {
    DefaultAdapter adapter = new DefaultAdapter(viewPager);
    adapter.setTabPadding(mTabPaddingStart, mTabPaddingTop, mTabPaddingEnd, mTabPaddingBottom);
    adapter.setTabTextAppearance(mTabTextAppearance);
    adapter.setTabSelectedTextColor(mTabSelectedTextColorSet, mTabSelectedTextColor);
    adapter.setTabMaxWidth(mTabMaxWidth);
    adapter.setTabMinWidth(mTabMinWidth);
    adapter.setTabBackgroundResId(mTabBackgroundResId);
    adapter.setTabOnScreenLimit(mTabOnScreenLimit);
    setUpWithAdapter(adapter);
  }

  public void setUpWithAdapter(RecyclerTabLayout.Adapter<?> adapter) {
    mAdapter = adapter;
    mViewPager = adapter.getViewPager();
    if (mViewPager.getAdapter() == null) {
      throw new IllegalArgumentException("ViewPager does not have a PagerAdapter set");
    }
    mViewPager.addOnPageChangeListener(new ViewPagerOnPageChangeListener(this));
    setAdapter(adapter);
    scrollToTab(mViewPager.getCurrentItem());
  }

  public void setCurrentItem(int position, boolean smoothScroll) {
    if (mViewPager != null) {
      mViewPager.setCurrentItem(position, smoothScroll);
      scrollToTab(mViewPager.getCurrentItem());
      return;
    }

    if (smoothScroll && position != mIndicatorPosition) {
      startAnimation(position);

    } else {
      scrollToTab(position);
    }
  }

  protected void startAnimation(final int position) {

    float distance = 1;

    View view = mLinearLayoutManager.findViewByPosition(position);
    if (view != null) {
      float currentX = view.getX() + view.getMeasuredWidth() / 2.f;
      float centerX = getMeasuredWidth() / 2.f;
      distance = Math.abs(centerX - currentX) / view.getMeasuredWidth();
    }

    ValueAnimator animator;
    if (position < mIndicatorPosition) {
      animator = ValueAnimator.ofFloat(distance, 0);
    } else {
      animator = ValueAnimator.ofFloat(-distance, 0);
    }
    animator.setDuration(DEFAULT_SCROLL_DURATION);
    animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
      @Override
      public void onAnimationUpdate(ValueAnimator animation) {
        scrollToTab(position, (float) animation.getAnimatedValue(), true);
      }
    });
    animator.start();
  }

  protected void scrollToTab(int position) {
    scrollToTab(position, 0, false);
    mAdapter.setCurrentIndicatorPosition(position);
    mAdapter.notifyDataSetChanged();
  }

  protected void scrollToTab(int position, float positionOffset, boolean fitIndicator) {
    int scrollOffset = 0;

    View selectedView = mLinearLayoutManager.findViewByPosition(position);
    View nextView = mLinearLayoutManager.findViewByPosition(position + 1);

    if (selectedView != null) {
      int width = getMeasuredWidth();
      float sLeft = (position == 0) ? 0 : width / 2.f - selectedView.getMeasuredWidth() / 2.f; // left edge of selected tab
      float sRight = sLeft + selectedView.getMeasuredWidth(); // right edge of selected tab

      if (nextView != null) {
        float nLeft = width / 2.f - nextView.getMeasuredWidth() / 2.f; // left edge of next tab
        float distance = sRight - nLeft; // total distance that is needed to distance to next tab
        float dx = distance * positionOffset;
        scrollOffset = (int) (sLeft - dx);

        if (position == 0) {
          float indicatorGap = (nextView.getMeasuredWidth() - selectedView.getMeasuredWidth()) / 2;
          mIndicatorGap = (int) (indicatorGap * positionOffset);
          mIndicatorScroll = (int) ((selectedView.getMeasuredWidth() + indicatorGap) * positionOffset);

        } else {
          float indicatorGap = (nextView.getMeasuredWidth() - selectedView.getMeasuredWidth()) / 2;
          mIndicatorGap = (int) (indicatorGap * positionOffset);
          mIndicatorScroll = (int) dx;
        }

      } else {
        scrollOffset = (int) sLeft;
        mIndicatorScroll = 0;
        mIndicatorGap = 0;
      }
      if (fitIndicator) {
        mIndicatorScroll = 0;
        mIndicatorGap = 0;
      }

    } else {
      if (getMeasuredWidth() > 0 && mTabMaxWidth > 0 && mTabMinWidth == mTabMaxWidth) { //fixed size
        int width = mTabMinWidth;
        int offset = (int) (positionOffset * -width);
        int leftOffset = (int) ((getMeasuredWidth() - width) / 2.f);
        scrollOffset = offset + leftOffset;
      }
      mRequestScrollToTab = true;
    }

    updateCurrentIndicatorPosition(position, positionOffset - mOldPositionOffset, positionOffset);
    mIndicatorPosition = position;

    stopScroll();

    if (position != mOldPosition || scrollOffset != mOldScrollOffset) {
      mLinearLayoutManager.scrollToPositionWithOffset(position, scrollOffset);
    }
    if (mIndicatorHeight > 0) {
      invalidate();
    }

    mOldPosition = position;
    mOldScrollOffset = scrollOffset;
    mOldPositionOffset = positionOffset;
  }

  protected void updateCurrentIndicatorPosition(int position, float dx, float positionOffset) {
    if (mAdapter == null) {
      return;
    }
    int indicatorPosition = -1;
    if (dx > 0 && positionOffset >= mPositionThreshold - POSITION_THRESHOLD_ALLOWABLE) {
      indicatorPosition = position + 1;

    } else if (dx < 0 && positionOffset <= 1 - mPositionThreshold + POSITION_THRESHOLD_ALLOWABLE) {
      indicatorPosition = position;
    }
    if (indicatorPosition >= 0 && indicatorPosition != mAdapter.getCurrentIndicatorPosition()) {
      mAdapter.setCurrentIndicatorPosition(indicatorPosition);
      mAdapter.notifyDataSetChanged();
    }
  }

  @Override
  public void onDraw(Canvas canvas) {
    View view = mLinearLayoutManager.findViewByPosition(mIndicatorPosition);
    if (view == null) {
      if (mRequestScrollToTab) {
        mRequestScrollToTab = false;
        scrollToTab(mViewPager.getCurrentItem());
      }
      return;
    }
    mRequestScrollToTab = false;

    int left;
    int right;
    if (isLayoutRtl()) {
      left = view.getLeft() - mIndicatorScroll - mIndicatorGap;
      right = view.getRight() - mIndicatorScroll + mIndicatorGap;
    } else {
      left = view.getLeft() + mIndicatorScroll - mIndicatorGap;
      right = view.getRight() + mIndicatorScroll + mIndicatorGap;
    }

    int top = getHeight() - mIndicatorHeight;
    int bottom = getHeight();

    canvas.drawRect(left, top, right, bottom, mIndicatorPaint);
  }

  protected boolean isLayoutRtl() {
    return ViewCompat.getLayoutDirection(this) == ViewCompat.LAYOUT_DIRECTION_RTL;
  }

  protected static class RecyclerOnScrollListener extends OnScrollListener {

    protected RecyclerTabLayout mRecyclerTabLayout;
    protected LinearLayoutManager mLinearLayoutManager;

    public RecyclerOnScrollListener(RecyclerTabLayout recyclerTabLayout,
                                    LinearLayoutManager linearLayoutManager) {
      mRecyclerTabLayout = recyclerTabLayout;
      mLinearLayoutManager = linearLayoutManager;
    }

    public int mDx;

    @Override
    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
      mDx += dx;
    }

    @Override
    public void onScrollStateChanged(RecyclerView recyclerView, int newState) {
      switch (newState) {
        case SCROLL_STATE_IDLE:
          if (mDx > 0) {
            selectCenterTabForRightScroll();
          } else {
            selectCenterTabForLeftScroll();
          }
          mDx = 0;
          break;
        case SCROLL_STATE_DRAGGING:
        case SCROLL_STATE_SETTLING:
      }
    }

    protected void selectCenterTabForRightScroll() {
      int first = mLinearLayoutManager.findFirstVisibleItemPosition();
      int last = mLinearLayoutManager.findLastVisibleItemPosition();
      int center = mRecyclerTabLayout.getWidth() / 2;
      for (int position = first; position <= last; position++) {
        View view = mLinearLayoutManager.findViewByPosition(position);
        if (view.getLeft() + view.getWidth() >= center) {
          mRecyclerTabLayout.setCurrentItem(position, false);
          break;
        }
      }
    }

    protected void selectCenterTabForLeftScroll() {
      int first = mLinearLayoutManager.findFirstVisibleItemPosition();
      int last = mLinearLayoutManager.findLastVisibleItemPosition();
      int center = mRecyclerTabLayout.getWidth() / 2;
      for (int position = last; position >= first; position--) {
        View view = mLinearLayoutManager.findViewByPosition(position);
        if (view.getLeft() <= center) {
          mRecyclerTabLayout.setCurrentItem(position, false);
          break;
        }
      }
    }
  }

  protected static class ViewPagerOnPageChangeListener implements ViewPager.OnPageChangeListener {

    private final RecyclerTabLayout mRecyclerTabLayout;
    private int mScrollState;

    public ViewPagerOnPageChangeListener(RecyclerTabLayout recyclerTabLayout) {
      mRecyclerTabLayout = recyclerTabLayout;
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
      mRecyclerTabLayout.scrollToTab(position, positionOffset, false);
    }

    @Override
    public void onPageScrollStateChanged(int state) {
      mScrollState = state;
    }

    @Override
    public void onPageSelected(int position) {
      if (mScrollState == ViewPager.SCROLL_STATE_IDLE) {
        if (mRecyclerTabLayout.mIndicatorPosition != position) {
          mRecyclerTabLayout.scrollToTab(position);
        }
      }
    }
  }

  public static abstract class Adapter<T extends RecyclerView.ViewHolder>
    extends RecyclerView.Adapter<T> {

    protected ViewPager mViewPager;
    protected int mIndicatorPosition;

    public Adapter(ViewPager viewPager) {
      mViewPager = viewPager;
    }

    public ViewPager getViewPager() {
      return mViewPager;
    }

    public void setCurrentIndicatorPosition(int indicatorPosition) {
      mIndicatorPosition = indicatorPosition;
    }

    public int getCurrentIndicatorPosition() {
      return mIndicatorPosition;
    }
  }

  public static class DefaultAdapter
    extends RecyclerTabLayout.Adapter<DefaultAdapter.ViewHolder> {

    protected static final int MAX_TAB_TEXT_LINES = 2;

    protected int mTabPaddingStart;
    protected int mTabPaddingTop;
    protected int mTabPaddingEnd;
    protected int mTabPaddingBottom;
    protected int mTabTextAppearance;
    protected boolean mTabSelectedTextColorSet;
    protected int mTabSelectedTextColor;
    private int mTabMaxWidth;
    private int mTabMinWidth;
    private int mTabBackgroundResId;
    private int mTabOnScreenLimit;

    public DefaultAdapter(ViewPager viewPager) {
      super(viewPager);
    }

    @SuppressWarnings("deprecation")
    @Override
    public DefaultAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
      TabTextView tabTextView = new TabTextView(parent.getContext());

      if (mTabSelectedTextColorSet) {
        tabTextView.setTextColor(tabTextView.createColorStateList(
          tabTextView.getCurrentTextColor(), mTabSelectedTextColor));
      }

      ViewCompat.setPaddingRelative(tabTextView, mTabPaddingStart, mTabPaddingTop,
        mTabPaddingEnd, mTabPaddingBottom);
      tabTextView.setTextAppearance(parent.getContext(), mTabTextAppearance);
      tabTextView.setGravity(Gravity.CENTER);
      tabTextView.setMaxLines(MAX_TAB_TEXT_LINES);
      tabTextView.setEllipsize(TextUtils.TruncateAt.END);

      if (mTabOnScreenLimit > 0) {
        int width = parent.getMeasuredWidth() / mTabOnScreenLimit;
        tabTextView.setMaxWidth(width);
        tabTextView.setMinWidth(width);

      } else {
        if (mTabMaxWidth > 0) {
          tabTextView.setMaxWidth(mTabMaxWidth);
        }
        tabTextView.setMinWidth(mTabMinWidth);
      }

      tabTextView.setTextAppearance(tabTextView.getContext(), mTabTextAppearance);
      if (mTabSelectedTextColorSet) {
        tabTextView.setTextColor(tabTextView.createColorStateList(
          tabTextView.getCurrentTextColor(), mTabSelectedTextColor));
      }
      if (mTabBackgroundResId != 0) {
        tabTextView.setBackgroundDrawable(
          AppCompatResources.getDrawable(tabTextView.getContext(), mTabBackgroundResId));
      }
      tabTextView.setLayoutParams(createLayoutParamsForTabs());
      return new ViewHolder(tabTextView);
    }

    @Override
    public void onBindViewHolder(DefaultAdapter.ViewHolder holder, int position) {
      CharSequence title = getViewPager().getAdapter().getPageTitle(position);
      holder.title.setText(title);
      holder.title.setSelected(getCurrentIndicatorPosition() == position);
    }

    @Override
    public int getItemCount() {
      return getViewPager().getAdapter().getCount();
    }

    public void setTabPadding(int tabPaddingStart, int tabPaddingTop, int tabPaddingEnd,
                              int tabPaddingBottom) {
      mTabPaddingStart = tabPaddingStart;
      mTabPaddingTop = tabPaddingTop;
      mTabPaddingEnd = tabPaddingEnd;
      mTabPaddingBottom = tabPaddingBottom;
    }

    public void setTabTextAppearance(int tabTextAppearance) {
      mTabTextAppearance = tabTextAppearance;
    }

    public void setTabSelectedTextColor(boolean tabSelectedTextColorSet,
                                        int tabSelectedTextColor) {
      mTabSelectedTextColorSet = tabSelectedTextColorSet;
      mTabSelectedTextColor = tabSelectedTextColor;
    }

    public void setTabMaxWidth(int tabMaxWidth) {
      mTabMaxWidth = tabMaxWidth;
    }

    public void setTabMinWidth(int tabMinWidth) {
      mTabMinWidth = tabMinWidth;
    }

    public void setTabBackgroundResId(int tabBackgroundResId) {
      mTabBackgroundResId = tabBackgroundResId;
    }

    public void setTabOnScreenLimit(int tabOnScreenLimit) {
      mTabOnScreenLimit = tabOnScreenLimit;
    }

    protected RecyclerView.LayoutParams createLayoutParamsForTabs() {
      return new RecyclerView.LayoutParams(
        LayoutParams.WRAP_CONTENT, LayoutParams.MATCH_PARENT);
    }

    public class ViewHolder extends RecyclerView.ViewHolder {

      public TextView title;

      public ViewHolder(View itemView) {
        super(itemView);
        title = (TextView) itemView;
        itemView.setOnClickListener(new View.OnClickListener() {
          @Override
          public void onClick(View v) {
            int pos = getAdapterPosition();
            if (pos != NO_POSITION) {
              getViewPager().setCurrentItem(pos, true);
            }
          }
        });
      }
    }
  }


  public static class TabTextView extends AppCompatTextView {

    public TabTextView(Context context) {
      super(context);
    }

    public ColorStateList createColorStateList(int defaultColor, int selectedColor) {
      final int[][] states = new int[2][];
      final int[] colors = new int[2];
      states[0] = SELECTED_STATE_SET;
      colors[0] = selectedColor;
      // Default enabled state
      states[1] = EMPTY_STATE_SET;
      colors[1] = defaultColor;
      return new ColorStateList(states, colors);
    }
  }
}
```

`app/src/main/java/io/neoterm/ui/settings/BasePreferenceActivity.kt`:

```kt
/*
 * Copyright (C) 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.neoterm.ui.settings

import android.content.res.Configuration
import android.os.Bundle
import android.preference.PreferenceActivity
import android.view.MenuInflater
import android.view.View
import android.view.ViewGroup
import androidx.annotation.LayoutRes
import androidx.appcompat.app.ActionBar
import androidx.appcompat.app.AppCompatDelegate

/**
 * A [android.preference.PreferenceActivity] which implements and proxies the necessary calls
 * to be used with AppCompat.
 *
 *
 * This technique can be used with an [android.app.Activity] class, not just
 * [android.preference.PreferenceActivity].
 */
abstract class BasePreferenceActivity : PreferenceActivity() {
  private var mDelegate: AppCompatDelegate? = null

  override fun onCreate(savedInstanceState: Bundle?) {
    delegate.installViewFactory()
    delegate.onCreate(savedInstanceState)
    super.onCreate(savedInstanceState)
  }

  override fun onPostCreate(savedInstanceState: Bundle?) {
    super.onPostCreate(savedInstanceState)
    delegate.onPostCreate(savedInstanceState)
  }

  val supportActionBar: ActionBar?
    get() = delegate.supportActionBar

  override fun getMenuInflater(): MenuInflater {
    return delegate.menuInflater
  }

  override fun setContentView(@LayoutRes layoutResID: Int) {
    delegate.setContentView(layoutResID)
  }

  override fun setContentView(view: View) {
    delegate.setContentView(view)
  }

  override fun setContentView(view: View, params: ViewGroup.LayoutParams) {
    delegate.setContentView(view, params)
  }

  override fun addContentView(view: View, params: ViewGroup.LayoutParams) {
    delegate.addContentView(view, params)
  }

  override fun onPostResume() {
    super.onPostResume()
    delegate.onPostResume()
  }

  override fun onTitleChanged(title: CharSequence, color: Int) {
    super.onTitleChanged(title, color)
    delegate.setTitle(title)
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    delegate.onConfigurationChanged(newConfig)
  }

  override fun onStop() {
    super.onStop()
    delegate.onStop()
  }

  override fun onDestroy() {
    super.onDestroy()
    delegate.onDestroy()
  }

  override fun invalidateOptionsMenu() {
    delegate.invalidateOptionsMenu()
  }

  private val delegate: AppCompatDelegate
    get() {
      if (mDelegate == null) {
        mDelegate = AppCompatDelegate.create(this, null)
      }
      return mDelegate!!
    }
}
```

`app/src/main/java/io/neoterm/ui/settings/GeneralSettingsActivity.kt`:

```kt
package io.neoterm.ui.settings

import android.os.Bundle
import android.view.MenuItem
import androidx.appcompat.app.AlertDialog
import io.neoterm.R
import io.neoterm.component.config.NeoPreference
import io.neoterm.utils.runApt

/**
 * @author kiva
 */
class GeneralSettingsActivity : BasePreferenceActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    supportActionBar?.title = getString(R.string.general_settings)
    supportActionBar?.setDisplayHomeAsUpEnabled(true)
    addPreferencesFromResource(R.xml.setting_general)

    val currentShell = NeoPreference.getLoginShellName()
    findPreference(getString(R.string.key_general_shell)).setOnPreferenceChangeListener { _, value ->
      val shellName = value.toString()
      val newShell = NeoPreference.findLoginProgram(shellName)
      if (newShell == null) {
        requestInstallShell(shellName, currentShell)
      } else {
        postChangeShell(shellName)
      }
      return@setOnPreferenceChangeListener true
    }
  }

  private fun postChangeShell(shellName: String) = NeoPreference.setLoginShellName(shellName)

  private fun requestInstallShell(shellName: String, currentShell: String) {
    AlertDialog.Builder(this)
      .setTitle(getString(R.string.shell_not_found, shellName))
      .setMessage(R.string.shell_not_found_message)
      .setPositiveButton(R.string.install) { _, _ ->
        runApt("install", "-y", shellName) {
          it.onSuccess { postChangeShell(shellName) }
        }
      }
      .setNegativeButton(android.R.string.no, null)
      .setOnDismissListener { postChangeShell(currentShell) }
      .show()
  }

  override fun onBuildHeaders(target: MutableList<Header>?) {
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home -> finish()
    }
    return super.onOptionsItemSelected(item)
  }
}

```

`app/src/main/java/io/neoterm/ui/settings/SettingActivity.kt`:

```kt
package io.neoterm.ui.settings

import android.os.Bundle
import android.view.MenuItem
import io.neoterm.R

/**
 * @author Lody
 */
class SettingActivity : BasePreferenceActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    supportActionBar?.title = getString(R.string.settings)
    supportActionBar?.setDisplayHomeAsUpEnabled(true)
    addPreferencesFromResource(R.xml.settings_main)
  }

  override fun onBuildHeaders(target: MutableList<Header>?) {
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home ->
        finish()
    }
    return super.onOptionsItemSelected(item)
  }
}
```

`app/src/main/java/io/neoterm/ui/settings/UISettingsActivity.kt`:

```kt
package io.neoterm.ui.settings

import android.os.Bundle
import android.view.MenuItem
import io.neoterm.R

/**
 * @author kiva
 */
class UISettingsActivity : BasePreferenceActivity() {

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    supportActionBar?.title = getString(R.string.ui_settings)
    supportActionBar?.setDisplayHomeAsUpEnabled(true)
    addPreferencesFromResource(R.xml.settings_ui)
  }

  override fun onBuildHeaders(target: MutableList<Header>?) {
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    when (item?.itemId) {
      android.R.id.home ->
        finish()
    }
    return super.onOptionsItemSelected(item)
  }
}
```

`app/src/main/java/io/neoterm/ui/term/NeoTermActivity.kt`:

```kt
package io.neoterm.ui.term

import android.Manifest
import android.content.*
import android.content.pm.PackageManager
import android.content.res.Configuration
import android.os.Bundle
import android.os.Handler
import android.os.IBinder
import android.preference.PreferenceManager
import android.view.*
import android.view.inputmethod.InputMethodManager
import android.widget.ImageButton
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.widget.Toolbar
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.core.view.OnApplyWindowInsetsListener
import androidx.core.view.ViewCompat
import de.mrapp.android.tabswitcher.*
import io.neoterm.App
import io.neoterm.BuildConfig
import io.neoterm.R
import io.neoterm.backend.TerminalSession
import io.neoterm.component.ComponentManager
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.profile.ProfileComponent
import io.neoterm.component.session.ShellParameter
import io.neoterm.component.session.ShellProfile
import io.neoterm.component.session.XParameter
import io.neoterm.component.session.XSession
import io.neoterm.frontend.session.terminal.*
import io.neoterm.services.NeoTermService
import io.neoterm.setup.SetupHelper
import io.neoterm.ui.other.SetupActivity
import io.neoterm.ui.pm.PackageManagerActivity
import io.neoterm.ui.settings.SettingActivity
import io.neoterm.utils.FullScreenHelper
import io.neoterm.utils.NeoPermission
import io.neoterm.utils.RangedInt
import org.greenrobot.eventbus.EventBus
import org.greenrobot.eventbus.Subscribe
import org.greenrobot.eventbus.ThreadMode


class NeoTermActivity : AppCompatActivity(), ServiceConnection, SharedPreferences.OnSharedPreferenceChangeListener {
  companion object {
    const val KEY_NO_RESTORE = "no_restore"
    const val REQUEST_SETUP = 22313
  }

  lateinit var tabSwitcher: TabSwitcher
  private lateinit var fullScreenHelper: FullScreenHelper
  lateinit var toolbar: Toolbar

  var addSessionListener = createAddSessionListener()
  private var termService: NeoTermService? = null

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    NeoPermission.initAppPermission(this, NeoPermission.REQUEST_APP_PERMISSION)

    val fullscreen = NeoPreference.isFullScreenEnabled()
    if (fullscreen) {
      window.setFlags(
        WindowManager.LayoutParams.FLAG_FULLSCREEN,
        WindowManager.LayoutParams.FLAG_FULLSCREEN
      )
    }

    val SDCARD_PERMISSIONS_REQUEST_WRITE_EXTERNAL_STORAGE = 1
    if (ContextCompat.checkSelfPermission(
        this,
        Manifest.permission.WRITE_EXTERNAL_STORAGE
      ) != PackageManager.PERMISSION_GRANTED
    ) {
      ActivityCompat.requestPermissions(
        this,
        arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE),
        SDCARD_PERMISSIONS_REQUEST_WRITE_EXTERNAL_STORAGE
      )
    }

    setContentView(R.layout.ui_main)

    toolbar = findViewById(R.id.terminal_toolbar)
    setSupportActionBar(toolbar)

    fullScreenHelper = FullScreenHelper.injectActivity(this, fullscreen, peekRecreating())
    fullScreenHelper.setKeyBoardListener(object : FullScreenHelper.KeyBoardListener {
      override fun onKeyboardChange(isShow: Boolean, keyboardHeight: Int) {
        if (tabSwitcher.selectedTab is TermTab) {
          val tab = tabSwitcher.selectedTab as TermTab
          // isShow -> toolbarHide
          toggleToolbar(tab.toolbar, !isShow)
        }
      }
    })

    tabSwitcher = findViewById(R.id.tab_switcher)
    tabSwitcher.decorator = NeoTabDecorator(this)
    ViewCompat.setOnApplyWindowInsetsListener(tabSwitcher, createWindowInsetsListener())
    tabSwitcher.showToolbars(false)

    val serviceIntent = Intent(this, NeoTermService::class.java)
    startService(serviceIntent)
    bindService(serviceIntent, this, 0)
  }

  private fun toggleToolbar(toolbar: Toolbar?, visible: Boolean) {
    if (toolbar == null) {
      return
    }

    if (NeoPreference.isFullScreenEnabled()
      || NeoPreference.isHideToolbarEnabled()
    ) {
      val toolbarHeight = toolbar.height.toFloat()
      val translationY = if (visible) 0.toFloat() else -toolbarHeight
      if (visible) {
        toolbar.visibility = View.VISIBLE
        toolbar.animate()
          .translationY(translationY)
          .start()
      } else {
        toolbar.animate()
          .translationY(translationY)
          .withEndAction {
            toolbar.visibility = View.GONE
          }
          .start()
      }
    }
  }

  override fun onCreateOptionsMenu(menu: Menu?): Boolean {
    menuInflater.inflate(R.menu.menu_main, menu)

    TabSwitcher.setupWithMenu(tabSwitcher, toolbar.menu, {
      if (!tabSwitcher.isSwitcherShown) {
        val imm = this@NeoTermActivity.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        if (imm.isActive && tabSwitcher.selectedTab is TermTab) {
          val tab = tabSwitcher.selectedTab as TermTab
          tab.requireHideIme()
        }
        toggleSwitcher(showSwitcher = true, easterEgg = true)
      } else {
        toggleSwitcher(showSwitcher = false, easterEgg = true)
      }
    })
    return true
  }

  override fun onOptionsItemSelected(item: MenuItem?): Boolean {
    return when (item?.itemId) {
      R.id.menu_item_settings -> {
        startActivity(Intent(this, SettingActivity::class.java))
        true
      }
      R.id.menu_item_package_settings -> {
        startActivity(Intent(this, PackageManagerActivity::class.java))
        true
      }
      R.id.menu_item_new_session -> {
        addNewSession()
        true
      }
      R.id.menu_item_new_session_with_profile -> {
        showProfileDialog()
        true
      }
      R.id.menu_item_new_system_session -> {
        forceAddSystemSession()
        true
      }
      R.id.menu_item_new_x_session -> {
        addXSession()
        true
      }
      else -> super.onOptionsItemSelected(item)
    }
  }

  override fun onPause() {
    super.onPause()
    val tab = tabSwitcher.selectedTab as NeoTab?
    tab?.onPause()
  }

  override fun onResume() {
    super.onResume()
    PreferenceManager.getDefaultSharedPreferences(this)
      .registerOnSharedPreferenceChangeListener(this)
    tabSwitcher.addListener(object : TabSwitcherListener {
      override fun onSwitcherShown(tabSwitcher: TabSwitcher) {
        toolbar.setNavigationIcon(R.drawable.ic_add_box_white_24dp)
        toolbar.setNavigationOnClickListener(addSessionListener)
        toolbar.setBackgroundResource(android.R.color.transparent)
        toolbar.animate().alpha(0f).setDuration(300).withEndAction {
          toolbar.alpha = 1f
        }.start()
      }

      override fun onSwitcherHidden(tabSwitcher: TabSwitcher) {
        toolbar.navigationIcon = null
        toolbar.setNavigationOnClickListener(null)
        toolbar.setBackgroundResource(R.color.colorPrimary)
      }

      override fun onSelectionChanged(tabSwitcher: TabSwitcher, selectedTabIndex: Int, selectedTab: Tab?) {
        if (selectedTab is TermTab && selectedTab.termData.termSession != null) {
          NeoPreference.storeCurrentSession(selectedTab.termData.termSession!!)
        }
      }

      override fun onTabAdded(tabSwitcher: TabSwitcher, index: Int, tab: Tab, animation: Animation) {
        update_colors()
      }

      override fun onTabRemoved(tabSwitcher: TabSwitcher, index: Int, tab: Tab, animation: Animation) {
        if (tab is TermTab) {
          SessionRemover.removeSession(termService, tab)
        } else if (tab is XSessionTab) {
          SessionRemover.removeXSession(termService, tab)
        }
      }

      override fun onAllTabsRemoved(tabSwitcher: TabSwitcher, tabs: Array<out Tab>, animation: Animation) {
      }
    })
    val tab = tabSwitcher.selectedTab as NeoTab?
    tab?.onResume()
  }

  override fun onStart() {
    super.onStart()
    EventBus.getDefault().register(this)
    val tab = tabSwitcher.selectedTab as NeoTab?
    tab?.onStart()
  }

  override fun onStop() {
    super.onStop()
    // After stopped, window locations may changed
    // Rebind it at next time.
    forEachTab<TermTab> { it.resetAutoCompleteStatus() }
    val tab = tabSwitcher.selectedTab as NeoTab?
    tab?.onStop()
    EventBus.getDefault().unregister(this)
  }

  override fun onDestroy() {
    super.onDestroy()
    val tab = tabSwitcher.selectedTab as NeoTab?
    tab?.onDestroy()
    PreferenceManager.getDefaultSharedPreferences(this)
      .unregisterOnSharedPreferenceChangeListener(this)

    if (termService != null) {
      if (termService!!.sessions.isEmpty()) {
        termService!!.stopSelf()
      }
      termService = null
    }
    unbindService(this)
  }

  override fun onWindowFocusChanged(hasFocus: Boolean) {
    super.onWindowFocusChanged(hasFocus)
    val tab = tabSwitcher.selectedTab as NeoTab?
    tab?.onWindowFocusChanged(hasFocus)
  }

  override fun onKeyDown(keyCode: Int, event: KeyEvent?): Boolean {
    when (keyCode) {
      KeyEvent.KEYCODE_BACK -> {
        if (event?.action == KeyEvent.ACTION_DOWN && tabSwitcher.isSwitcherShown && tabSwitcher.count > 0) {
          toggleSwitcher(showSwitcher = false, easterEgg = false)
          return true
        }
      }
      KeyEvent.KEYCODE_MENU -> {
        if (toolbar.isOverflowMenuShowing) {
          toolbar.hideOverflowMenu()
        } else {
          toolbar.showOverflowMenu()
        }
        return true
      }
    }
    return super.onKeyDown(keyCode, event)
  }

  override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
    when (requestCode) {
      NeoPermission.REQUEST_APP_PERMISSION -> {
        if (grantResults.isEmpty()
          || grantResults[0] != PackageManager.PERMISSION_GRANTED
        ) {
          AlertDialog.Builder(this).setMessage(R.string.permission_denied)
            .setPositiveButton(android.R.string.ok, { _: DialogInterface, _: Int ->
              finish()
            })
            .show()
        }
        return
      }
    }
  }

  override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences?, key: String?) {
    if (key == getString(R.string.key_ui_fullscreen)) {
      setFullScreenMode(NeoPreference.isFullScreenEnabled())
    } else if (key == getString(R.string.key_customization_color_scheme)) {
      if (tabSwitcher.count > 0) {
        val tab = tabSwitcher.selectedTab
        if (tab is TermTab) {
          tab.updateColorScheme()
        }
      }
    }
  }

  override fun onServiceDisconnected(name: ComponentName?) {
    if (termService != null) {
      finish()
    }
  }

  override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
    termService = (service as NeoTermService.NeoTermBinder).service
    if (termService == null) {
      finish()
      return
    }

    if (!isRecreating()) {
      if (SetupHelper.needSetup()) {
        val intent = Intent(this, SetupActivity::class.java)
        startActivityForResult(intent, REQUEST_SETUP)
        return
      }
      enterMain()
      update_colors()
    }
  }

  override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    when (requestCode) {
      REQUEST_SETUP -> {
        when (resultCode) {
          AppCompatActivity.RESULT_OK -> enterMain()
          AppCompatActivity.RESULT_CANCELED -> {
            setSystemShellMode(true)
            forceAddSystemSession()
          }
        }
      }
    }
    super.onActivityResult(requestCode, resultCode, data)
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    if (newConfig == null) {
      return
    }

    // When rotate the screen, extra keys may get updated.
    forEachTab<NeoTab> {
      it.onConfigurationChanged(newConfig)
      if (it is TermTab) {
        it.resetStatus()
      }
    }
  }

  private fun forceAddSystemSession() {
    if (!tabSwitcher.isSwitcherShown) {
      toggleSwitcher(showSwitcher = true, easterEgg = false)
    }

    // Fore system shell mode to be enabled.
    addNewSession(null, true, createRevealAnimation())
  }

  private fun enterMain() {
    setSystemShellMode(false)

    if (!termService!!.sessions.isEmpty()) {
      val lastSession = getStoredCurrentSessionOrLast()

      for (session in termService!!.sessions) {
        addNewSessionFromExisting(session)
      }

      for (session in termService!!.xSessions) {
        addXSession(session)
      }

      if (intent?.action == Intent.ACTION_RUN) {
        // app shortcuts
        addNewSession(
          null,
          false, createRevealAnimation()
        )
      } else {
        switchToSession(lastSession)
      }

    } else {
      toggleSwitcher(showSwitcher = true, easterEgg = false)
      // Fore system shell mode to be disabled.
      addNewSession(null, false, createRevealAnimation())
    }
  }

  override fun recreate() {
    NeoPreference.store(KEY_NO_RESTORE, true)
    saveCurrentStatus()
    super.recreate()
  }

  private fun isRecreating(): Boolean {
    val result = peekRecreating()
    if (result) {
      NeoPreference.store(KEY_NO_RESTORE, !result)
    }
    return result
  }

  private fun saveCurrentStatus() {
    setSystemShellMode(getSystemShellMode())
  }

  private fun peekRecreating(): Boolean {
    return NeoPreference.loadBoolean(KEY_NO_RESTORE, false)
  }

  private fun setFullScreenMode(fullScreen: Boolean) {
    fullScreenHelper.fullScreen = fullScreen
    if (tabSwitcher.selectedTab is TermTab) {
      val tab = tabSwitcher.selectedTab as TermTab
      tab.requireHideIme()
      tab.onFullScreenModeChanged(fullScreen)
    }
    NeoPreference.store(R.string.key_ui_fullscreen, fullScreen)
    this@NeoTermActivity.recreate()
  }

  private fun showProfileDialog() {
    val profileComponent = ComponentManager.getComponent<ProfileComponent>()
    val profiles = profileComponent.getProfiles(ShellProfile.PROFILE_META_NAME)
    val profilesShell = profiles.filterIsInstance<ShellProfile>()

    if (profiles.isEmpty()) {
      AlertDialog.Builder(this)
        .setTitle(R.string.error)
        .setMessage(R.string.no_profile_available)
        .setPositiveButton(android.R.string.yes, null)
        .show()
      return
    }

    AlertDialog.Builder(this)
      .setTitle(R.string.new_session_with_profile)
      .setItems(profiles.map { it.profileName }.toTypedArray(), { dialog, which ->
        val selectedProfile = profilesShell[which]
        addNewSessionWithProfile(selectedProfile)
      })
      .setPositiveButton(android.R.string.no, null)
      .show()
  }

  private fun addNewSession() = addNewSessionWithProfile(ShellProfile.create())

  private fun addNewSession(sessionName: String?, systemShell: Boolean, animation: Animation) =
    addNewSessionWithProfile(sessionName, systemShell, animation, ShellProfile.create())

  private fun addNewSessionWithProfile(profile: ShellProfile) {
    if (!tabSwitcher.isSwitcherShown) {
      toggleSwitcher(showSwitcher = true, easterEgg = false)
    }
    addNewSessionWithProfile(
      null, getSystemShellMode(),
      createRevealAnimation(), profile
    )
  }

  private fun addNewSessionWithProfile(
    sessionName: String?, systemShell: Boolean,
    animation: Animation, profile: ShellProfile
  ) {
    val sessionCallback = TermSessionCallback()
    val viewClient = TermViewClient(this)

    val parameter = ShellParameter()
      .callback(sessionCallback)
      .systemShell(systemShell)
      .profile(profile)
    val session = termService!!.createTermSession(parameter)

    session.mSessionName = sessionName ?: generateSessionName("NeoTerm")

    val tab = createTab(session.mSessionName) as TermTab
    tab.termData.initializeSessionWith(session, sessionCallback, viewClient)

    addNewTab(tab, animation)
    switchToSession(tab)
  }

  private fun addNewSessionFromExisting(session: TerminalSession?) {
    if (session == null) {
      return
    }

    // Do not add the same session again
    // Or app will crash when rotate
    val tabCount = tabSwitcher.count
    (0..(tabCount - 1))
      .map { tabSwitcher.getTab(it) }
      .filter { it is TermTab && it.termData.termSession == session }
      .forEach { return }

    val sessionCallback = session.sessionChangedCallback as TermSessionCallback
    val viewClient = TermViewClient(this)

    val tab = createTab(session.title) as TermTab
    tab.termData.initializeSessionWith(session, sessionCallback, viewClient)

    addNewTab(tab, createRevealAnimation())
    switchToSession(tab)
  }

  private fun addXSession() {
    if (!BuildConfig.DEBUG) {
      AlertDialog.Builder(this)
        .setTitle(R.string.error)
        .setMessage(R.string.sorry_for_development)
        .setPositiveButton(android.R.string.yes, null)
        .show()
      return
    }

    if (!tabSwitcher.isSwitcherShown) {
      toggleSwitcher(showSwitcher = true, easterEgg = false)
    }

    val parameter = XParameter()
    val session = termService!!.createXSession(this, parameter)

    session.mSessionName = generateXSessionName("X")
    val tab = createXTab(session.mSessionName) as XSessionTab
    tab.session = session

    addNewTab(tab, createRevealAnimation())
    switchToSession(tab)
  }

  private fun addXSession(session: XSession?) {
    if (session == null) {
      return
    }

    // Do not add the same session again
    // Or app will crash when rotate
    val tabCount = tabSwitcher.count
    (0..(tabCount - 1))
      .map { tabSwitcher.getTab(it) }
      .filter { it is XSessionTab && it.session == session }
      .forEach { return }

    val tab = createXTab(session.mSessionName) as XSessionTab

    addNewTab(tab, createRevealAnimation())
    switchToSession(tab)
  }

  private fun generateSessionName(prefix: String): String {
    return "$prefix #${termService!!.sessions.size}"
  }

  private fun generateXSessionName(prefix: String): String {
    return "$prefix #${termService!!.xSessions.size}"
  }

  private fun switchToSession(session: TerminalSession?) {
    if (session == null) {
      return
    }

    for (i in 0 until tabSwitcher.count) {
      val tab = tabSwitcher.getTab(i)
      if (tab is TermTab && tab.termData.termSession == session) {
        switchToSession(tab)
        break
      }
    }
  }

  private fun switchToSession(tab: Tab?) {
    if (tab == null) {
      return
    }
    tabSwitcher.selectTab(tab)
  }

  private fun addNewTab(tab: Tab, animation: Animation) {
    tabSwitcher.addTab(tab, 0, animation)
  }

  private fun getStoredCurrentSessionOrLast(): TerminalSession? {
    val stored = NeoPreference.getCurrentSession(termService)
    if (stored != null) return stored
    val numberOfSessions = termService!!.sessions.size
    if (numberOfSessions == 0) return null
    return termService!!.sessions[numberOfSessions - 1]
  }

  private fun createAddSessionListener(): View.OnClickListener {
    return View.OnClickListener {
      addNewSession()
    }
  }

  private fun createTab(tabTitle: String?): Tab {
    return postTabCreated(TermTab(tabTitle ?: "NeoTerm"))
  }

  private fun createXTab(tabTitle: String?): Tab {
    return postTabCreated(XSessionTab(tabTitle ?: "NeoTerm"))
  }

  private fun <T : NeoTab> postTabCreated(tab: T): T {
    // We must create a Bundle for each tab
    // tabs can use them to store status.
    tab.parameters = Bundle()

    tab.setBackgroundColor(ContextCompat.getColor(this, R.color.tab_background_color))
    tab.setTitleTextColor(ContextCompat.getColor(this, R.color.tab_title_text_color))
    return tab
  }

  private fun createRevealAnimation(): Animation {
    var x = 0f
    var y = 0f
    val view = getNavigationMenuItem()

    if (view != null) {
      val location = IntArray(2)
      view.getLocationInWindow(location)
      x = location[0] + view.width / 2f
      y = location[1] + view.height / 2f
    }

    return RevealAnimation.Builder().setX(x).setY(y).create()
  }

  private fun getNavigationMenuItem(): View? {
    val toolbars = tabSwitcher.toolbars

    if (toolbars != null) {
      val toolbar = if (toolbars.size > 1) toolbars[1] else toolbars[0]
      val size = toolbar.childCount

      (0 until size)
        .map { toolbar.getChildAt(it) }
        .filterIsInstance(ImageButton::class.java)
        .forEach { return it }
    }

    return null
  }

  private fun createWindowInsetsListener(): OnApplyWindowInsetsListener {
    return OnApplyWindowInsetsListener { _, insets ->
      tabSwitcher.setPadding(
        insets.systemWindowInsetLeft,
        insets.systemWindowInsetTop, insets.systemWindowInsetRight,
        insets.systemWindowInsetBottom
      )
      insets
    }
  }

  private fun toggleSwitcher(showSwitcher: Boolean, easterEgg: Boolean) {
    if (tabSwitcher.count == 0 && easterEgg) {
      App.get().easterEgg(this, "Stop! You don't know what you are doing!")
      return
    }

    if (showSwitcher) {
      tabSwitcher.showSwitcher()
    } else {
      tabSwitcher.hideSwitcher()
    }
  }

  private fun setSystemShellMode(systemShell: Boolean) {
    NeoPreference.store(NeoPreference.KEY_SYSTEM_SHELL, systemShell)
  }

  private fun getSystemShellMode(): Boolean {
    return NeoPreference.loadBoolean(NeoPreference.KEY_SYSTEM_SHELL, true)
  }

  private inline fun <reified T> forEachTab(callback: (T) -> Unit) {
    (0 until tabSwitcher.count)
      .map { tabSwitcher.getTab(it) }
      .filterIsInstance(T::class.java)
      .forEach(callback)
  }

  @Suppress("unused")
  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onTabCloseEvent(tabCloseEvent: TabCloseEvent) {
    val tab = tabCloseEvent.termTab
    toggleSwitcher(showSwitcher = true, easterEgg = false)
    tabSwitcher.removeTab(tab)

    if (tabSwitcher.count > 1) {
      var index = tabSwitcher.indexOf(tab)
      if (NeoPreference.isNextTabEnabled()) {
        // 关闭当前窗口后，向下一个窗口切换
        if (--index < 0) index = tabSwitcher.count - 1
      } else {
        // 关闭当前窗口后，向上一个窗口切换
        if (++index >= tabSwitcher.count) index = 0
      }
      switchToSession(tabSwitcher.getTab(index))
    }
  }

  @Suppress("unused", "UNUSED_PARAMETER")
  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onToggleFullScreenEvent(toggleFullScreenEvent: ToggleFullScreenEvent) {
    val fullScreen = fullScreenHelper.fullScreen
    setFullScreenMode(!fullScreen)
  }

  @Suppress("unused", "UNUSED_PARAMETER")
  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onToggleImeEvent(toggleImeEvent: ToggleImeEvent) {
    if (!tabSwitcher.isSwitcherShown) {
      val imm = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
      imm.toggleSoftInput(InputMethodManager.SHOW_IMPLICIT, 0)
    }
  }

  @Suppress("unused", "UNUSED_PARAMETER")
  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onTitleChangedEvent(titleChangedEvent: TitleChangedEvent) {
    if (!tabSwitcher.isSwitcherShown) {
      toolbar.title = titleChangedEvent.title
    }
  }

  @Suppress("unused", "UNUSED_PARAMETER")
  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onCreateNewSessionEvent(createNewSessionEvent: CreateNewSessionEvent) {
    addNewSession()
  }

  @Suppress("unused", "UNUSED_PARAMETER")
  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onSwitchSessionEvent(switchSessionEvent: SwitchSessionEvent) {
    if (tabSwitcher.count < 2) {
      return
    }

    val rangedInt = RangedInt(tabSwitcher.selectedTabIndex, (0 until tabSwitcher.count))
    val nextIndex = if (switchSessionEvent.toNext) rangedInt.inc() else rangedInt.dec()
    if (!tabSwitcher.isSwitcherShown) {
      tabSwitcher.showSwitcher()
    }
    switchToSession(tabSwitcher.getTab(nextIndex))
  }

  @Suppress("unused", "UNUSED_PARAMETER")
  @Subscribe(threadMode = ThreadMode.MAIN)
  fun onSwitchIndexedSessionEvent(switchIndexedSessionEvent: SwitchIndexedSessionEvent) {
    val nextIndex = switchIndexedSessionEvent.index - 1
    if (nextIndex in (0 until tabSwitcher.count) && nextIndex != tabSwitcher.selectedTabIndex) {
      // Do not show animation here, users may get tired
      switchToSession(tabSwitcher.getTab(nextIndex))
    }
  }

  fun update_colors() {
    // Simple fix to bug on custom color
    Handler().postDelayed({

      if (tabSwitcher.count > 0) {
        val tab = tabSwitcher.selectedTab
        if (tab is TermTab) {
          tab.updateColorScheme()
        }
      }

    }, 500)
  }

}

```

`app/src/main/java/io/neoterm/ui/term/NeoTermRemoteInterface.kt`:

```kt
package io.neoterm.ui.term

import android.content.ComponentName
import android.content.Intent
import android.content.ServiceConnection
import android.net.Uri
import android.os.Bundle
import android.os.IBinder
import android.widget.ArrayAdapter
import android.widget.ListView
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.App
import io.neoterm.R
import io.neoterm.bridge.Bridge.*
import io.neoterm.bridge.SessionId
import io.neoterm.component.ComponentManager
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.session.ShellParameter
import io.neoterm.component.userscript.UserScript
import io.neoterm.component.userscript.UserScriptComponent
import io.neoterm.frontend.session.terminal.TermSessionCallback
import io.neoterm.services.NeoTermService
import io.neoterm.utils.Terminals
import io.neoterm.utils.getPathOfMediaUri
import java.io.File

/**
 * @author kiva
 */
class NeoTermRemoteInterface : AppCompatActivity(), ServiceConnection {
  private var termService: NeoTermService? = null

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val serviceIntent = Intent(this, NeoTermService::class.java)
    startService(serviceIntent)
    if (!bindService(serviceIntent, this, 0)) {
      App.get().errorDialog(this, R.string.service_connection_failed, { finish() })
    }
  }

  override fun onDestroy() {
    super.onDestroy()
    if (termService != null) {
      if (termService!!.sessions.isEmpty()) {
        termService!!.stopSelf()
      }
      termService = null
      unbindService(this)
    }
  }

  override fun onServiceDisconnected(name: ComponentName?) {
    if (termService != null) {
      finish()
    }
  }

  override fun onServiceConnected(name: ComponentName?, service: IBinder?) {
    termService = (service as NeoTermService.NeoTermBinder).service
    if (termService == null) {
      finish()
      return
    }

    handleIntent()
  }

  private fun handleIntent() = when (intent.component?.className?.substringAfterLast('.')) {
    "TermHere" -> handleTermHere()
    "UserScript" -> handleUserScript()
    else -> handleNormal()
  }

  private fun handleNormal() {
    when (intent.action) {
      ACTION_EXECUTE -> {
        if (!intent.hasExtra(EXTRA_COMMAND)) {
          App.get().errorDialog(this, R.string.no_command_extra)
          { finish() }
          return
        }
        val command = intent.getStringExtra(EXTRA_COMMAND)
        val foreground = intent.getBooleanExtra(EXTRA_FOREGROUND, true)
        val session = intent.getStringExtra(EXTRA_SESSION_ID)

        openTerm(command, SessionId.of(session), foreground)
      }

      else -> openTerm(null, null)
    }
    finish()
  }

  private fun handleTermHere() {
    if (intent.hasExtra(Intent.EXTRA_STREAM)) {
      val extra = intent.extras?.get(Intent.EXTRA_STREAM)
      if (extra is Uri) {
        val path = this.getPathOfMediaUri(extra)
        val file = File(path)
        val dirPath = if (file.isDirectory) path else file.parent
        val command = "cd " + Terminals.escapeString(dirPath)
        openTerm(command, null)
      }
      finish()
    } else {
      App.get().errorDialog(
        this,
        getString(R.string.unsupported_term_here, intent?.toString())
      ) {
        finish()
      }
    }
  }

  private fun handleUserScript() {
    val filesToHandle = mutableListOf<String>()
    val comp = ComponentManager.getComponent<UserScriptComponent>()
    val userScripts = comp.userScripts
    if (userScripts.isEmpty()) {
      App.get().errorDialog(this, R.string.no_user_script_found, { finish() })
      return
    }

    if (intent.hasExtra(Intent.EXTRA_STREAM)) {
      // action send
      val extra = intent.extras?.get(Intent.EXTRA_STREAM)

      when (extra) {
        is ArrayList<*> -> {
          extra.takeWhile { it is Uri }
            .mapTo(filesToHandle) {
              val uri = it as Uri
              File(this.getPathOfMediaUri(uri)).absolutePath
            }
        }
        is Uri -> {
          filesToHandle.add(File(this.getPathOfMediaUri(extra)).absolutePath)
        }
      }
    } else if (intent.data != null) {
      // action view
      filesToHandle.add(File(intent.data?.path).absolutePath)
    }

    if (filesToHandle.isNotEmpty()) {
      setupUserScriptView(filesToHandle, userScripts)
    } else {
      App.get().errorDialog(
        this,
        getString(R.string.no_files_selected, intent?.toString())
      ) { finish() }
    }
  }

  private fun setupUserScriptView(filesToHandle: MutableList<String>, userScripts: List<UserScript>) {
    setContentView(R.layout.ui_user_script_list)
    val filesList = findViewById<ListView>(R.id.user_script_file_list)
    val filesAdapter = ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, filesToHandle)
    filesList.adapter = filesAdapter
    filesList.setOnItemClickListener { _, _, position, _ ->
      AlertDialog.Builder(this@NeoTermRemoteInterface)
        .setMessage(R.string.confirm_remove_file_from_list)
        .setPositiveButton(android.R.string.yes) { _, _ ->
          filesToHandle.removeAt(position)
          filesAdapter.notifyDataSetChanged()
        }
        .setNegativeButton(android.R.string.no, null)
        .show()
    }

    val scriptsList = findViewById<ListView>(R.id.user_script_script_list)
    val scriptsListItem = mutableListOf<String>()
    userScripts.mapTo(scriptsListItem, { it.scriptFile.nameWithoutExtension })

    val scriptsAdapter = ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, scriptsListItem)
    scriptsList.adapter = scriptsAdapter

    scriptsList.setOnItemClickListener { _, _, position, _ ->
      val userScript = userScripts[position]
      val userScriptPath = userScript.scriptFile.absolutePath
      val arguments = buildUserScriptArgument(userScriptPath, filesToHandle)

      openCustomExecTerm(userScriptPath, arguments, userScript.scriptFile.parent)
      finish()
    }
  }

  private fun buildUserScriptArgument(userScriptPath: String, files: List<String>): Array<String> {
    val arguments = mutableListOf(userScriptPath)
    arguments.addAll(files)
    return arguments.toTypedArray()
  }

  private fun openTerm(
    parameter: ShellParameter,
    foreground: Boolean = true
  ) {
    val session = termService!!.createTermSession(parameter)

    val data = Intent()
    data.putExtra(EXTRA_SESSION_ID, session.mHandle)
    setResult(AppCompatActivity.RESULT_OK, data)

    if (foreground) {
      // Set current session to our new one
      // In order to switch to it when entering NeoTermActivity
      NeoPreference.storeCurrentSession(session)

      val intent = Intent(this, NeoTermActivity::class.java)
      intent.addCategory(Intent.CATEGORY_DEFAULT)
      intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
      startActivity(intent)
    }
  }

  private fun openTerm(
    initialCommand: String?,
    sessionId: SessionId? = null,
    foreground: Boolean = true
  ) {
    val parameter = ShellParameter()
      .initialCommand(initialCommand)
      .callback(TermSessionCallback())
      .systemShell(detectSystemShell())
      .session(sessionId)
    openTerm(parameter, foreground)
  }

  private fun openCustomExecTerm(executablePath: String?, arguments: Array<String>?, cwd: String?) {
    val parameter = ShellParameter()
      .executablePath(executablePath)
      .arguments(arguments)
      .currentWorkingDirectory(cwd)
      .callback(TermSessionCallback())
      .systemShell(detectSystemShell())
    openTerm(parameter)
  }

  private fun detectSystemShell(): Boolean {
    return false
  }
}

```

`app/src/main/java/io/neoterm/ui/term/SessionRemover.kt`:

```kt
package io.neoterm.ui.term

import io.neoterm.backend.TerminalSession
import io.neoterm.component.session.XSession
import io.neoterm.services.NeoTermService

/**
 * @author kiva
 */
object SessionRemover {
  fun removeSession(termService: NeoTermService?, tab: TermTab) {
    tab.termData.termSession?.finishIfRunning()
    removeFinishedSession(termService, tab.termData.termSession)
    tab.cleanup()
  }

  fun removeXSession(termService: NeoTermService?, tab: XSessionTab?) {
    removeFinishedSession(termService, tab?.session)
  }

  private fun removeFinishedSession(termService: NeoTermService?, finishedSession: TerminalSession?) {
    if (termService == null || finishedSession == null) {
      return
    }

    termService.removeTermSession(finishedSession)
  }

  private fun removeFinishedSession(termService: NeoTermService?, finishedSession: XSession?) {
    if (termService == null || finishedSession == null) {
      return
    }

    termService.removeXSession(finishedSession)
  }
}

```

`app/src/main/java/io/neoterm/ui/term/tabs.kt`:

```kt
package io.neoterm.ui.term

import android.content.Context
import android.content.res.Configuration
import android.graphics.Rect
import android.os.Bundle
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.inputmethod.InputMethodManager
import android.widget.FrameLayout
import androidx.appcompat.widget.Toolbar
import de.mrapp.android.tabswitcher.Tab
import de.mrapp.android.tabswitcher.TabSwitcher
import de.mrapp.android.tabswitcher.TabSwitcherDecorator
import io.neoterm.NeoGLView
import io.neoterm.R
import io.neoterm.component.ComponentManager
import io.neoterm.component.colorscheme.ColorSchemeComponent
import io.neoterm.component.completion.OnAutoCompleteListener
import io.neoterm.component.config.DefaultValues
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.session.XSession
import io.neoterm.frontend.session.terminal.*
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView
import io.neoterm.utils.Terminals
import org.greenrobot.eventbus.EventBus

/**
 * @author kiva
 */
open class NeoTab(title: CharSequence) : Tab(title) {
  open fun onPause() {}
  open fun onResume() {}
  open fun onStart() {}
  open fun onStop() {}
  open fun onWindowFocusChanged(hasFocus: Boolean) {}
  open fun onDestroy() {}
  open fun onConfigurationChanged(newConfig: Configuration) {}
}

class NeoTabDecorator(val context: NeoTermActivity) : TabSwitcherDecorator() {
  companion object {
    private var VIEW_TYPE_COUNT = 0
    private val VIEW_TYPE_TERM = VIEW_TYPE_COUNT++
    private val VIEW_TYPE_X = VIEW_TYPE_COUNT++
  }

  private fun setViewLayerType(view: View?) = view?.setLayerType(View.LAYER_TYPE_NONE, null)

  override fun onInflateView(inflater: LayoutInflater, parent: ViewGroup?, viewType: Int): View {
    return when (viewType) {
      VIEW_TYPE_TERM -> {
        val view = inflater.inflate(R.layout.ui_term, parent, false)
        val terminalView = view.findViewById<TerminalView>(R.id.terminal_view)
        val extraKeysView = view.findViewById<ExtraKeysView>(R.id.extra_keys)
        Terminals.setupTerminalView(terminalView)
        Terminals.setupExtraKeysView(extraKeysView)

        val colorSchemeManager = ComponentManager.getComponent<ColorSchemeComponent>()
        colorSchemeManager.applyColorScheme(
          terminalView, extraKeysView,
          colorSchemeManager.getCurrentColorScheme()
        )
        view
      }

      VIEW_TYPE_X -> {
        inflater.inflate(R.layout.ui_xorg, parent, false)
      }

      else -> {
        throw RuntimeException("Unknown view type")
      }
    }
  }

  override fun onShowTab(
    context: Context, tabSwitcher: TabSwitcher,
    view: View, tab: Tab, index: Int, viewType: Int, savedInstanceState: Bundle?
  ) {
    // TODO: Improve

    val toolbar = this@NeoTabDecorator.context.toolbar
    toolbar.title = if (tabSwitcher.isSwitcherShown) null else tab.title

    val isQuickPreview = tabSwitcher.selectedTabIndex != index

    when (viewType) {
      VIEW_TYPE_TERM -> {
        val termTab = tab as TermTab
        termTab.toolbar = toolbar
        val terminalView = findViewById<TerminalView>(R.id.terminal_view)
        if (isQuickPreview) {
          bindTerminalView(termTab, terminalView, null)
        } else {
          val extraKeysView = findViewById<ExtraKeysView>(R.id.extra_keys)
          bindTerminalView(termTab, terminalView, extraKeysView)
          terminalView.requestFocus()
        }
      }

      VIEW_TYPE_X -> {
        toolbar.visibility = View.GONE
        bindXSessionView(tab as XSessionTab)
      }
    }
  }

  private fun bindXSessionView(tab: XSessionTab) {
    val sessionData = tab.sessionData ?: return

    if (sessionData.videoLayout == null) {
      val videoLayout = findViewById<FrameLayout>(R.id.xorg_video_layout)
      sessionData.videoLayout = videoLayout
      setViewLayerType(videoLayout)
    }

    val videoLayout = sessionData.videoLayout!!

    if (sessionData.glView == null) {
      Thread {
        sessionData.client?.runOnUiThread {
          sessionData.glView = NeoGLView(sessionData.client)
          sessionData.glView?.isFocusableInTouchMode = true
          sessionData.glView?.isFocusable = true
          sessionData.glView?.requestFocus()

          setViewLayerType(sessionData.glView)
          videoLayout.addView(
            sessionData.glView,
            FrameLayout.LayoutParams(
              FrameLayout.LayoutParams.MATCH_PARENT,
              FrameLayout.LayoutParams.MATCH_PARENT
            )
          )

          sessionData.glView?.pointerIcon =
            android.view.PointerIcon.getSystemIcon(
              context,
              android.view.PointerIcon.TYPE_NULL
            )

          val r = Rect()
          videoLayout.getWindowVisibleDisplayFrame(r)
          sessionData.glView?.callNativeScreenVisibleRect(r.left, r.top, r.right, r.bottom)
          videoLayout.viewTreeObserver.addOnGlobalLayoutListener {
            val r = Rect()
            videoLayout.getWindowVisibleDisplayFrame(r)
            val heightDiff = videoLayout.rootView.height - videoLayout.height // Take system bar into consideration
            val widthDiff = videoLayout.rootView.width - videoLayout.width // Nexus 5 has system bar at the right side
            Log.v(
              "SDL",
              "Main window visible region changed: " + r.left + ":" + r.top + ":" + r.width() + ":" + r.height()
            )
            videoLayout.postDelayed(
              {
                sessionData.glView?.callNativeScreenVisibleRect(
                  r.left + widthDiff,
                  r.top + heightDiff,
                  r.width(),
                  r.height()
                )
              },
              300
            )
            videoLayout.postDelayed(
              {
                sessionData.glView?.callNativeScreenVisibleRect(
                  r.left + widthDiff,
                  r.top + heightDiff,
                  r.width(),
                  r.height()
                )
              },
              600
            )
          }
        }
      }.start()
    }
  }

  private fun bindTerminalView(
    tab: TermTab, view: TerminalView?,
    extraKeysView: ExtraKeysView?
  ) {
    val termView = view ?: return
    val termData = tab.termData

    termData.initializeViewWith(tab, termView, extraKeysView)
    termView.setEnableWordBasedIme(termData.profile?.enableWordBasedIme ?: DefaultValues.enableWordBasedIme)
    termView.setTerminalViewClient(termData.viewClient)
    termView.attachSession(termData.termSession)

    if (NeoPreference.loadBoolean(R.string.key_general_auto_completion, false)) {
      if (termData.onAutoCompleteListener == null) {
        termData.onAutoCompleteListener = createAutoCompleteListener(termView)
      }
      termView.onAutoCompleteListener = termData.onAutoCompleteListener
    }

    if (termData.termSession != null) {
      termData.viewClient?.updateExtraKeys(termData.termSession?.title, true)
    }
  }

  private fun createAutoCompleteListener(view: TerminalView): OnAutoCompleteListener? {
    return TermCompleteListener(view)
  }

  override fun getViewTypeCount(): Int {
    return VIEW_TYPE_COUNT
  }

  override fun getViewType(tab: Tab, index: Int): Int {
    if (tab is TermTab) {
      return VIEW_TYPE_TERM
    } else if (tab is XSessionTab) {
      return VIEW_TYPE_X
    }
    return -1
  }
}

class XSessionTab(title: CharSequence) : NeoTab(title) {
  var session: XSession? = null
  val sessionData
    get() = session?.mSessionData

  override fun onWindowFocusChanged(hasFocus: Boolean) {
    super.onWindowFocusChanged(hasFocus)
    if (!hasFocus) {
      onPause()
    } else {
      onResume()
    }
  }

  override fun onConfigurationChanged(newConfig: Configuration) {
    super.onConfigurationChanged(newConfig)
    session?.updateScreenOrientation()
  }

  override fun onPause() {
    session?.onPause()
    super.onPause()
  }

  override fun onDestroy() {
    super.onDestroy()
    session?.onDestroy()
  }

  override fun onResume() {
    super.onResume()
    session?.onResume()
  }
}

class TermTab(title: CharSequence) : NeoTab(title), TermUiPresenter {
  companion object {
    val PARAMETER_SHOW_EKS = "show_eks"
  }

  var termData = TermSessionData()
  var toolbar: Toolbar? = null

  fun updateColorScheme() {
    val colorSchemeManager = ComponentManager.getComponent<ColorSchemeComponent>()
    colorSchemeManager.applyColorScheme(
      termData.termView, termData.extraKeysView,
      colorSchemeManager.getCurrentColorScheme()
    )
  }

  fun cleanup() {
    termData.cleanup()
    toolbar = null
  }

  fun onFullScreenModeChanged(fullScreen: Boolean) {
    // Window token changed, we need to recreate PopupWindow
    resetAutoCompleteStatus()
  }

  override fun requireHideIme() {
    val terminalView = termData.termView
    if (terminalView != null) {
      val imm = terminalView.context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
      if (imm.isActive) {
        imm.hideSoftInputFromWindow(terminalView.windowToken, InputMethodManager.HIDE_NOT_ALWAYS)
      }
    }
  }

  override fun requireFinishAutoCompletion(): Boolean {
    return termData.onAutoCompleteListener?.onFinishCompletion() ?: false
  }

  override fun requireToggleFullScreen() {
    EventBus.getDefault().post(ToggleFullScreenEvent())
  }

  override fun requirePaste() {
    termData.termView?.pasteFromClipboard()
  }

  override fun requireClose() {
    requireHideIme()
    EventBus.getDefault().post(TabCloseEvent(this))
  }

  override fun requireUpdateTitle(title: String?) {
    if (title != null && title.isNotEmpty()) {
      this.title = title
      EventBus.getDefault().post(TitleChangedEvent(title))
      termData.viewClient?.updateExtraKeys(title)
    }
  }

  override fun requireOnSessionFinished() {
    // do nothing
  }

  override fun requireCreateNew() {
    EventBus.getDefault().post(CreateNewSessionEvent())
  }

  override fun requireSwitchToPrevious() {
    EventBus.getDefault().post(SwitchSessionEvent(toNext = false))
  }

  override fun requireSwitchToNext() {
    EventBus.getDefault().post(SwitchSessionEvent(toNext = true))
  }

  override fun requireSwitchTo(index: Int) {
    EventBus.getDefault().post(SwitchIndexedSessionEvent(index))
  }

  fun resetAutoCompleteStatus() {
    termData.onAutoCompleteListener?.onCleanUp()
    termData.onAutoCompleteListener = null
  }

  fun resetStatus() {
    resetAutoCompleteStatus()
    termData.extraKeysView?.updateButtons()
    termData.termView?.updateSize()
    termData.termView?.onScreenUpdated()
  }
}

```

`app/src/main/java/io/neoterm/utils/CrashHandler.kt`:

```kt
package io.neoterm.utils

import android.content.Intent
import io.neoterm.App
import io.neoterm.ui.other.CrashActivity

/**
 * @author kiva
 */
object CrashHandler : Thread.UncaughtExceptionHandler {
  private lateinit var defaultHandler: Thread.UncaughtExceptionHandler

  fun init() {
    defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
    Thread.setDefaultUncaughtExceptionHandler(this)
  }

  override fun uncaughtException(t: Thread?, e: Throwable?) {
    e?.printStackTrace()

    val intent = Intent(App.get(), CrashActivity::class.java)
    intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
    intent.putExtra("exception", e)
    App.get().startActivity(intent)
    defaultHandler.uncaughtException(t, e)
  }
}

```

`app/src/main/java/io/neoterm/utils/FullScreenHelper.kt`:

```kt
package io.neoterm.utils

import android.graphics.Rect
import android.view.View
import android.widget.FrameLayout
import androidx.appcompat.app.AppCompatActivity

/**
 * Helper class to "adjustResize" Activity when we are in full screen mode and check IME status.
 * Android Bug 5497: https://code.google.com/p/android/issues/detail?id=5497
 */
class FullScreenHelper private constructor(
  activity: AppCompatActivity,
  var fullScreen: Boolean,
  private var shouldSkipFirst: Boolean
) {

  interface KeyBoardListener {
    /**
     * call back

     * @param isShow         true is show else hidden
     * *
     * @param keyboardHeight screenKeyboard height
     */
    fun onKeyboardChange(isShow: Boolean, keyboardHeight: Int)
  }

  private val mChildOfContent: View
  private var usableHeightPrevious: Int = 0
  private val frameLayoutParams: FrameLayout.LayoutParams

  private var mOriginHeight: Int = 0
  private var mPreHeight: Int = 0
  private var mKeyBoardListener: KeyBoardListener? = null

  fun setKeyBoardListener(mKeyBoardListener: KeyBoardListener) {
    this.mKeyBoardListener = mKeyBoardListener
  }

  init {
    val content = activity.findViewById<FrameLayout>(android.R.id.content)
    mChildOfContent = content.getChildAt(0)
    mChildOfContent.viewTreeObserver.addOnGlobalLayoutListener {
      if (this@FullScreenHelper.fullScreen) {
        possiblyResizeChildOfContent()
      }
      monitorImeStatus()
    }
    frameLayoutParams = mChildOfContent.layoutParams as FrameLayout.LayoutParams
  }

  private fun monitorImeStatus() {
    val currHeight = mChildOfContent.height
    if (currHeight == 0 && shouldSkipFirst) {
      // First time
      return
    }

    shouldSkipFirst = false
    var hasChange = false
    if (mPreHeight == 0) {
      mPreHeight = currHeight
      mOriginHeight = currHeight
    } else {
      if (mPreHeight != currHeight) {
        hasChange = true
        mPreHeight = currHeight
      } else {
        hasChange = false
      }
    }
    if (hasChange) {
      var keyboardHeight = 0
      val keyBoardIsShowing: Boolean
      if (Math.abs(mOriginHeight - currHeight) < 100) {
        //hidden
        keyBoardIsShowing = false
      } else {
        //show
        keyboardHeight = mOriginHeight - currHeight
        keyBoardIsShowing = true
      }

      if (mKeyBoardListener != null) {
        mKeyBoardListener!!.onKeyboardChange(keyBoardIsShowing, keyboardHeight)
      }
    }
  }

  private fun possiblyResizeChildOfContent() {
    val usableHeightNow = computeUsableHeight()
    val currentHeightLayoutHeight: Int

    if (usableHeightNow != usableHeightPrevious) {
      val usableHeightSansKeyboard = mChildOfContent.rootView.height
      val heightDifference = usableHeightSansKeyboard - usableHeightNow
      if (heightDifference > usableHeightSansKeyboard / 4) {
        // screenKeyboard probably just became visible
        currentHeightLayoutHeight = usableHeightSansKeyboard - heightDifference
      } else {
        // screenKeyboard probably just became hidden
        currentHeightLayoutHeight = usableHeightSansKeyboard
      }
      frameLayoutParams.height = currentHeightLayoutHeight
      mChildOfContent.requestLayout()
      usableHeightPrevious = usableHeightNow
    }
  }

  private fun computeUsableHeight(): Int {
    val r = Rect()
    mChildOfContent.getWindowVisibleDisplayFrame(r)
    return r.bottom - r.top
  }

  companion object {
    fun injectActivity(activity: AppCompatActivity, fullScreen: Boolean, recreate: Boolean): FullScreenHelper {
      return FullScreenHelper(activity, fullScreen, recreate)
    }

  }
}
```

`app/src/main/java/io/neoterm/utils/NLog.kt`:

```kt
package io.neoterm.utils

import android.content.Context
import android.util.Log
import androidx.annotation.IntDef
import java.io.*
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.zip.DataFormatException
import java.util.zip.Deflater
import java.util.zip.Inflater

object NLog {

  const val V = Log.VERBOSE
  const val D = Log.DEBUG
  const val I = Log.INFO
  const val W = Log.WARN
  const val E = Log.ERROR
  const val A = Log.ASSERT

  @IntDef(
    V.toLong().toInt(),
    D.toLong().toInt(),
    I.toLong().toInt(),
    W.toLong().toInt(),
    E.toLong().toInt(),
    A.toLong().toInt()
  )
  @Retention(AnnotationRetention.SOURCE)
  private annotation class TYPE

  private val T = charArrayOf('V', 'D', 'I', 'W', 'E', 'A')
  private val FILE = 0x10

  private var executor: ExecutorService? = null
  private var logDir: String? = null       // log存储目录

  private var sLogSwitch = true // log总开关，默认开
  private var sLog2ConsoleSwitch = true // logcat是否打印，默认打印
  private var sGlobalTag: String = "" // log标签
  private var sTagIsSpace = true // log标签是否为空白
  private var sLogHeadSwitch = true // log头部开关，默认开
  private var sLog2FileSwitch = false// log写入文件开关，默认关
  private var sConsoleFilter = V    // log控制台过滤器
  private var sFileFilter = V    // log文件过滤器

  private val LINE_SEP = System.getProperty("line.separator")
  private val MAX_LEN = 4000
  private val FORMAT = SimpleDateFormat("MM-dd HH:mm:ss.SSS ", Locale.getDefault())

  private val NULL_TIPS = "Log with null object."
  private val ARGS = "args"

  fun init(context: Context) {
    logDir = context.getDir("logs", Context.MODE_PRIVATE).absolutePath
    sGlobalTag = "NeoTerm"
  }

  fun v(contents: Any) {
    log(V, sGlobalTag, contents)
  }

  fun v(tag: String, vararg contents: Any) {
    log(V, tag, *contents)
  }

  fun d(contents: Any) {
    log(D, sGlobalTag, contents)
  }

  fun d(tag: String, vararg contents: Any) {
    log(D, tag, *contents)
  }

  fun i(contents: Any) {
    log(I, sGlobalTag, contents)
  }

  fun i(tag: String, vararg contents: Any) {
    log(I, tag, *contents)
  }

  fun w(contents: Any) {
    log(W, sGlobalTag, contents)
  }

  fun w(tag: String, vararg contents: Any) {
    log(W, tag, *contents)
  }

  fun e(contents: Any) {
    log(E, sGlobalTag, contents)
  }

  fun e(tag: String, vararg contents: Any) {
    log(E, tag, *contents)
  }

  fun a(contents: Any) {
    log(A, sGlobalTag, contents)
  }

  fun a(tag: String, vararg contents: Any) {
    log(A, tag, *contents)
  }

  fun file(contents: Any) {
    log(FILE or D, sGlobalTag, contents)
  }

  fun file(@TYPE type: Int, contents: Any) {
    log(FILE or type, sGlobalTag, contents)
  }

  fun file(tag: String, contents: Any) {
    log(FILE or D, tag, contents)
  }

  fun file(@TYPE type: Int, tag: String, contents: Any) {
    log(FILE or type, tag, contents)
  }

  private fun log(type: Int, tag: String, vararg contents: Any) {
    if (!sLogSwitch || !sLog2ConsoleSwitch && !sLog2FileSwitch) return
    val type_low = type and 0x0f
    val type_high = type and 0xf0
    if (type_low < sConsoleFilter && type_low < sFileFilter) return
    val tagAndHead = processTagAndHead(tag)
    val body = processBody(*contents)
    if (sLog2ConsoleSwitch && type_low >= sConsoleFilter) {
      printToConsole(type_low, tagAndHead[0], tagAndHead[1] + body)
    }
    if (sLog2FileSwitch || type_high == FILE) {
      if (type_low >= sFileFilter) printToFile(type_low, tagAndHead[0], tagAndHead[2] + body)
    }
  }

  private fun processTagAndHead(tag: String): Array<String> {
    var returnTag = tag
    if (!sTagIsSpace && !sLogHeadSwitch) {
      returnTag = sGlobalTag
    } else {
      returnTag = "$sGlobalTag-$returnTag"
      // DO NOT USE Thread.currentThread
      val targetElement = Throwable().stackTrace[3]
      var className = targetElement.className
      val classNameInfo = className.split("\\.".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
      if (classNameInfo.isNotEmpty()) {
        className = classNameInfo[classNameInfo.size - 1]
      }
      if (className.contains("$")) {
        className = className.split("\\$".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()[0]
      }
      if (sTagIsSpace) {
        returnTag = if (isSpace(returnTag)) className else returnTag
      }
      if (sLogHeadSwitch) {
        val head = Formatter()
          .format(
            "[Thread:%s], %s(%s:%d): ",
            Thread.currentThread().name,
            targetElement.methodName,
            targetElement.fileName,
            targetElement.lineNumber
          )
          .toString()
        return arrayOf(returnTag, head, head)
      }
    }
    return arrayOf(returnTag, "", ": ")
  }

  private fun processBody(vararg contents: Any): String {
    var body = NULL_TIPS
    if (contents.isNotEmpty()) {
      if (contents.size == 1) {
        body = contents[0].toString()
      } else {
        body = buildString {
          var index = 0
          contents.forEach {
            append(ARGS)
              .append("[")
              .append(index++)
              .append("]")
              .append(" = ")
              .append(it.toString())
              .append(LINE_SEP)
          }
        }
      }
    }
    return body
  }

  private fun printToConsole(type: Int, tag: String, msg: String) {
    val len = msg.length
    val countOfSub = len / MAX_LEN
    if (countOfSub > 0) {
      print(type, tag, msg.substring(0, MAX_LEN))
      var sub: String
      var index = MAX_LEN
      for (i in 1..countOfSub - 1) {
        sub = msg.substring(index, index + MAX_LEN)
        print(type, tag, sub)
        index += MAX_LEN
      }
      sub = msg.substring(index, len)
      print(type, tag, sub)
    } else {
      print(type, tag, msg)
    }
  }

  private fun print(type: Int, tag: String, msg: String) {
    Log.println(type, tag, msg)
  }

  private fun printToFile(type: Int, tag: String, msg: String) {
    val now = Date(System.currentTimeMillis())
    val format = FORMAT.format(now)
    val date = format.substring(0, 5)
    val time = format.substring(6)
    val fullPath = logDir + date + ".txt"
    if (!createOrExistsFile(fullPath)) {
      Log.e(tag, "log to $fullPath failed!")
      return
    }
    val sb = StringBuilder()
    sb.append(time)
      .append(T[type - V])
      .append("/")
      .append(tag)
      .append(msg)
      .append(LINE_SEP)
    val content = sb.toString()
    if (executor == null) {
      executor = Executors.newSingleThreadExecutor()
    }
    executor!!.execute {
      var bw: BufferedWriter? = null
      try {
        bw = BufferedWriter(FileWriter(fullPath, true))
        bw.write(content)
        Log.d(tag, "log to $fullPath success!")
      } catch (e: IOException) {
        e.printStackTrace()
        Log.e(tag, "log to $fullPath failed!")
      } finally {
        try {
          if (bw != null) {
            bw.close()
          }
        } catch (e: IOException) {
          e.printStackTrace()
        }

      }
    }
  }

  private fun createOrExistsFile(filePath: String): Boolean {
    val file = File(filePath)
    if (file.exists()) return file.isFile
    if (!createOrExistsDir(file.parentFile)) return false
    try {
      return file.createNewFile()
    } catch (e: IOException) {
      e.printStackTrace()
      return false
    }

  }

  private fun createOrExistsDir(file: File?): Boolean {
    return file != null && if (file.exists()) file.isDirectory else file.mkdirs()
  }

  private fun isSpace(s: String?): Boolean {
    return s?.isEmpty() ?: true
  }

  fun compress(input: ByteArray): ByteArray {
    val bos = ByteArrayOutputStream()
    val compressor = Deflater(1)
    try {
      compressor.setInput(input)
      compressor.finish()
      val buf = ByteArray(2048)
      while (!compressor.finished()) {
        val count = compressor.deflate(buf)
        bos.write(buf, 0, count)
      }
    } finally {
      compressor.end()
    }
    return bos.toByteArray()
  }

  fun uncompress(input: ByteArray): ByteArray {
    val bos = ByteArrayOutputStream()
    val inflater = Inflater()
    try {
      inflater.setInput(input)
      val buf = ByteArray(2048)
      while (!inflater.finished()) {
        var count = 0
        try {
          count = inflater.inflate(buf)
        } catch (e: DataFormatException) {
          e.printStackTrace()
        }

        bos.write(buf, 0, count)
      }
    } finally {
      inflater.end()
    }
    return bos.toByteArray()
  }

}

```

`app/src/main/java/io/neoterm/utils/NeoPermission.kt`:

```kt
package io.neoterm.utils

import android.Manifest
import android.content.ActivityNotFoundException
import android.content.DialogInterface
import android.content.pm.PackageManager
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat

/**
 * @author kiva
 */
object NeoPermission {
  const val REQUEST_APP_PERMISSION = 10086

  fun initAppPermission(context: AppCompatActivity, requestCode: Int) {
    if (ContextCompat.checkSelfPermission(
        context,
        Manifest.permission.READ_EXTERNAL_STORAGE
      )
      != PackageManager.PERMISSION_GRANTED
    ) {

      if (ActivityCompat.shouldShowRequestPermissionRationale(
          context,
          Manifest.permission.READ_EXTERNAL_STORAGE
        )
      ) {
        AlertDialog.Builder(context).setMessage("需要存储权限来访问存储设备上的文件")
          .setPositiveButton(android.R.string.ok, { _: DialogInterface, _: Int ->
            doRequestPermission(context, requestCode)
          })
          .show()

      } else {
        doRequestPermission(context, requestCode)
      }
    }
  }

  private fun doRequestPermission(context: AppCompatActivity, requestCode: Int) {
    try {
      ActivityCompat.requestPermissions(
        context,
        arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
        requestCode
      )
    } catch (ignore: ActivityNotFoundException) {
      // for MIUI, we ignore it.
    }
  }
}

```

`app/src/main/java/io/neoterm/utils/StringDistance.java`:

```java
package io.neoterm.utils;

/**
 * @author kiva
 */

public class StringDistance {
  public static int distance(String source, String target) {
    char[] sources = source.toCharArray();
    char[] targets = target.toCharArray();
    int sourceLen = sources.length;
    int targetLen = targets.length;

    int[][] d = new int[sourceLen + 1][targetLen + 1];
    for (int i = 0; i <= sourceLen; i++) {
      d[i][0] = i;
    }
    for (int i = 0; i <= targetLen; i++) {
      d[0][i] = i;
    }

    for (int i = 1; i <= sourceLen; i++) {
      for (int j = 1; j <= targetLen; j++) {
        if (sources[i - 1] == targets[j - 1]) {
          d[i][j] = d[i - 1][j - 1];
        } else {
          int insert = d[i][j - 1] + 1;
          int delete = d[i - 1][j] + 1;
          int replace = d[i - 1][j - 1] + 1;
          d[i][j] = Math.min(Math.min(insert, delete), Math.min(delete, replace));
        }
      }
    }
    return d[sourceLen][targetLen];
  }
}

```

`app/src/main/java/io/neoterm/utils/Terminals.kt`:

```kt
package io.neoterm.utils

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import io.neoterm.backend.TerminalSession
import io.neoterm.component.ComponentManager
import io.neoterm.component.config.NeoPreference
import io.neoterm.component.font.FontComponent
import io.neoterm.component.session.SessionComponent
import io.neoterm.component.session.ShellParameter
import io.neoterm.component.session.XParameter
import io.neoterm.component.session.XSession
import io.neoterm.frontend.session.view.TerminalView
import io.neoterm.frontend.session.view.TerminalViewClient
import io.neoterm.frontend.session.view.extrakey.ExtraKeysView

/**
 * @author kiva
 */
object Terminals {
  fun setupTerminalView(terminalView: TerminalView?, terminalViewClient: TerminalViewClient? = null) {
    terminalView?.textSize = NeoPreference.getFontSize();

    val fontComponent = ComponentManager.getComponent<FontComponent>()
    fontComponent.applyFont(terminalView, null, fontComponent.getCurrentFont())

    if (terminalViewClient != null) {
      terminalView?.setTerminalViewClient(terminalViewClient)
    }
  }

  fun setupExtraKeysView(extraKeysView: ExtraKeysView?) {
    val fontComponent = ComponentManager.getComponent<FontComponent>()
    val font = fontComponent.getCurrentFont()
    fontComponent.applyFont(null, extraKeysView, font)
  }

  fun createSession(context: Context, parameter: ShellParameter): TerminalSession {
    val sessionComponent = ComponentManager.getComponent<SessionComponent>()
    return sessionComponent.createSession(context, parameter)
  }

  fun createSession(activity: AppCompatActivity, parameter: XParameter): XSession {
    val sessionComponent = ComponentManager.getComponent<SessionComponent>()
    return sessionComponent.createSession(activity, parameter)
  }

  fun escapeString(s: String?): String {
    if (s == null) {
      return ""
    }

    val builder = StringBuilder()
    val specialChars = "\"\\$`!"
    builder.append('"')
    val length = s.length
    for (i in 0 until length) {
      val c = s[i]
      if (specialChars.indexOf(c) >= 0) {
        builder.append('\\')
      }
      builder.append(c)
    }
    builder.append('"')
    return builder.toString()
  }
}

```

`app/src/main/java/io/neoterm/utils/utils.kt`:

```kt
package io.neoterm.utils

import android.content.ContentUris
import android.content.Context
import android.net.Uri
import android.os.Environment
import android.provider.DocumentsContract
import android.provider.MediaStore
import io.neoterm.R
import io.neoterm.component.config.NeoTermPath
import io.neoterm.frontend.floating.TerminalDialog
import java.nio.file.Files
import java.nio.file.Paths
import java.text.DecimalFormat

class RangedInt(private val number: Int, private val range: IntRange) {
  fun inc() = (number + 1).takeIf { range.contains(it) } ?: 0
  fun dec() = (number - 1).takeIf { range.contains(it) } ?: range.last
}

fun Long.formatSizeInKB(): String {
  val decimalFormat = DecimalFormat("####.00");
  if (this < 1024) {
    return "$this KB"
  } else if (this < 1024 * 1024) {
    val parsedSize: Float = this / 1024f
    return decimalFormat.format(parsedSize) + " MB"
  } else if (this < 1024 * 1024 * 1024) {
    val parsedSize: Float = this / 1024f / 1024f
    return decimalFormat.format(parsedSize) + " GB"
  } else if (this < 1024L * 1024 * 1024 * 1024) {
    val parsedSize: Float = this / 1024f / 1024f / 1024f
    return decimalFormat.format(parsedSize) + " TB"
  } else {
    return "$this KB"
  }
}

fun Context.extractAssetsDir(assetDir: String, extractDir: String) = kotlin.runCatching {
  val targetDir = Paths.get(extractDir)
  Files.createDirectories(targetDir)
  val assets = this.assets
  assets.list(assetDir)?.let {
    it.map { targetDir.resolve(it) }
      .takeWhile { !Files.exists(it) }
      .forEach { targetPath ->
        assets.open("$assetDir/${targetPath.fileName}").use {
          Files.copy(it, targetPath)
        }
      }
  }
}

fun Context.runApt(
  subCommand: String, vararg extraArgs: String,
  autoClose: Boolean = true, block: (Result<TerminalDialog>) -> Unit
) = TerminalDialog(this)
  .execute(NeoTermPath.APT_BIN_PATH, arrayOf(NeoTermPath.APT_BIN_PATH, subCommand, *extraArgs))
  .imeEnabled(true)
  .onFinish { dialog, session ->
    val exit = session?.exitStatus ?: 1
    if (exit == 0) {
      if (autoClose) dialog.dismiss()
      block(Result.success(dialog))
    } else {
      dialog.setTitle(getString(R.string.error))
      block(Result.failure(RuntimeException()))
    }
  }
  .show("apt $subCommand")

/**
 * Get a file path from a Uri. This will get the the path for Storage Access
 * Framework Documents, as well as the _data field for the MediaStore and
 * other file-based ContentProviders.
 * @param context The context.
 * @param inUri     The Uri to query.
 */
fun Context.getPathOfMediaUri(inUri: Uri?) = inUri?.let {
  when {
    "content".equals(it.scheme, ignoreCase = true) -> getDataColumn(this, it, null, null)
    "file".equals(it.scheme, ignoreCase = true) -> it.path
    DocumentsContract.isDocumentUri(this, it) -> this.getPathOfDocumentUri(it)
    else -> null
  }
}

private fun Context.getPathOfDocumentUri(uri: Uri) = if (isExternalStorageDocument(uri)) {
  val docId = DocumentsContract.getDocumentId(uri)
  val split = docId.split(":".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
  val type = split[0]
  if ("primary".equals(type, ignoreCase = true)) Environment.getExternalStorageDirectory().toString() + "/" + split[1]
  else "/storage/$type/${split[1]}"  // Temporary workaround for non-primary volumes
} else if (isDownloadsDocument(uri)) {
  val id = DocumentsContract.getDocumentId(uri)
  val contentUri = ContentUris.withAppendedId(
    Uri.parse("content://downloads/public_downloads"), java.lang.Long.valueOf(id)
  )
  getDataColumn(this, contentUri, null, null)
} else if (isMediaDocument(uri)) {
  val docId = DocumentsContract.getDocumentId(uri)
  val split = docId.split(":".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
  val contentUri = when (split[0]) {
    "image" -> MediaStore.Images.Media.EXTERNAL_CONTENT_URI
    "video" -> MediaStore.Video.Media.EXTERNAL_CONTENT_URI
    "audio" -> MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
    else -> null
  }
  getDataColumn(this, contentUri!!, "_id=?", arrayOf(split[1]))
} else null

/**
 * Get the value of the data column for this Uri
 */
private fun getDataColumn(context: Context, uri: Uri, selection: String?, selectionArgs: Array<String>?) =
  context.contentResolver.query(uri, arrayOf("_data"), selection, selectionArgs, null)?.use {
    if (it.moveToFirst()) {
      val columnIndex = it.getColumnIndex("_data").takeIf { it != -1 } ?: return@use null
      it.getString(columnIndex)
    } else null
  }

private fun isExternalStorageDocument(uri: Uri) = "com.android.externalstorage.documents" == uri.authority
private fun isDownloadsDocument(uri: Uri) = "com.android.providers.downloads.documents" == uri.authority
private fun isMediaDocument(uri: Uri) = "com.android.providers.media.documents" == uri.authority

```

`app/src/main/res/drawable/ic_description.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportHeight="24.0"
        android:viewportWidth="24.0">
  <path
    android:fillColor="#757575"
    android:pathData="M14,2L6,2c-1.1,0 -1.99,0.9 -1.99,2L4,20c0,1.1 0.89,2 1.99,2L18,22c1.1,0 2,-0.9 2,-2L20,8l-6,-6zM16,18L8,18v-2h8v2zM16,14L8,14v-2h8v2zM13,9L13,3.5L18.5,9L13,9z"/>
</vector>
```

`app/src/main/res/drawable/ic_donate.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportHeight="24.0"
        android:viewportWidth="24.0">
  <path
    android:fillColor="#757575"
    android:pathData="M11.8,10.9c-2.27,-0.59 -3,-1.2 -3,-2.15 0,-1.09 1.01,-1.85 2.7,-1.85 1.78,0 2.44,0.85 2.5,2.1h2.21c-0.07,-1.72 -1.12,-3.3 -3.21,-3.81V3h-3v2.16c-1.94,0.42 -3.5,1.68 -3.5,3.61 0,2.31 1.91,3.46 4.7,4.13 2.5,0.6 3,1.48 3,2.41 0,0.69 -0.49,1.79 -2.7,1.79 -2.06,0 -2.87,-0.92 -2.98,-2.1h-2.2c0.12,2.19 1.76,3.42 3.68,3.83V21h3v-2.15c1.95,-0.37 3.5,-1.5 3.5,-3.55 0,-2.84 -2.43,-3.81 -4.7,-4.4z"/>
</vector>
```

`app/src/main/res/drawable/ic_github.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24.0dip"
        android:height="24.0dip"
        android:viewportHeight="24.0"
        android:viewportWidth="24.0">
  <path
    android:fillColor="#757575"
    android:pathData="M12,2A10,10 0 0,0 2,12C2,16.42 4.87,20.17 8.84,21.5C9.34,21.58 9.5,21.27 9.5,21C9.5,20.77 9.5,20.14 9.5,19.31C6.73,19.91 6.14,17.97 6.14,17.97C5.68,16.81 5.03,16.5 5.03,16.5C4.12,15.88 5.1,15.9 5.1,15.9C6.1,15.97 6.63,16.93 6.63,16.93C7.5,18.45 8.97,18 9.54,17.76C9.63,17.11 9.89,16.67 10.17,16.42C7.95,16.17 5.62,15.31 5.62,11.5C5.62,10.39 6,9.5 6.65,8.79C6.55,8.54 6.2,7.5 6.75,6.15C6.75,6.15 7.59,5.88 9.5,7.17C10.29,6.95 11.15,6.84 12,6.84C12.85,6.84 13.71,6.95 14.5,7.17C16.41,5.88 17.25,6.15 17.25,6.15C17.8,7.5 17.45,8.54 17.35,8.79C18,9.5 18.38,10.39 18.38,11.5C18.38,15.32 16.04,16.16 13.81,16.41C14.17,16.72 14.5,17.33 14.5,18.26C14.5,19.6 14.5,20.68 14.5,21C14.5,21.27 14.66,21.59 15.17,21.5C19.14,20.16 22,16.42 22,12A10,10 0 0,0 12,2Z"/>
</vector>
```

`app/src/main/res/drawable/ic_info.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportHeight="24.0"
        android:viewportWidth="24.0">
  <path
    android:fillColor="#757575"
    android:pathData="M11,17h2v-6h-2v6zM12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8zM11,9h2L13,7h-2v2z"/>
</vector>
```

`app/src/main/res/drawable/ic_neoterm.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="36dp"
        android:height="36dp"
        android:viewportWidth="36"
        android:viewportHeight="36">

  <path
    android:pathData="M -1 -1 H 37 V 37 H -1 V -1 Z"/>
  <path
    android:fillColor="#464646"
    android:strokeColor="#999999"
    android:strokeWidth="2"
    android:pathData="M 3 1 L 33 1 Q 35 1 35 3 L 35 33 Q 35 35 33 35 L 3 35 Q 1 35 1 33 L 1 3 Q 1 1 3 1 Z"/>
  <path
    android:fillColor="#fdfdfd"
    android:strokeWidth="1"
    android:pathData="M16.438998,20.296575c0,1.621066 -1.098842,2.900426
-2.694192,3.178495l0,1.390551c0,0.142958 -0.105333,0.254316
-0.240852,0.254316l-1.015976,0c-0.127827,0 -0.240852,-0.111218
-0.240852,-0.254316l0,-1.390551c-1.76113,-0.262217 -2.724254,-1.374792
-2.761863,-1.422512c-0.075282,-0.095264 -0.082791,-0.230374
-0.014991,-0.325768l0.775178,-1.072777c0.037673,-0.055542 0.105344,-0.087411
0.173009,-0.095253s0.135385,0.015824 0.180556,0.071506c0.01498,0.007842
1.06863,1.072771 2.40074,1.072771c0.737516,0 1.535241,-0.413184
1.535241,-1.311128c0,-0.762834 -0.888015,-1.136295
-1.904018,-1.565384c-1.354605,-0.56414 -3.040281,-1.279393
-3.040281,-3.273942c0,-1.462229 1.083723,-2.669982
2.656589,-2.987875l0,-1.430328c0,-0.142958 0.11289,-0.254316
0.240847,-0.254316l1.016003,0c0.13539,0 0.240852,0.111228
0.240852,0.254316l0,1.398544c1.527711,0.18267 2.340455,1.056834
2.370689,1.088542c0.075282,0.087416 0.090219,0.206616
0.037673,0.301956l-0.609607,1.160268c-0.037673,0.071506 -0.097781,0.119211
-0.173009,0.127187c-0.075271,0.015824 -0.142936,-0.007842
-0.203233,-0.055542c-0.007428,-0.007842 -0.918098,-0.858232
-2.04711,-0.858232c-0.955707,0 -1.618021,0.5006 -1.618021,1.223722c0,0.842289
0.918098,1.215783 1.986809,1.652822c1.384823,0.564167 2.950116,1.207962
2.950116,3.122813l-0.000285,0.000113l-0.000011,0z"/>
  <path
    android:fillColor="#fdfdfd"
    android:strokeWidth="1"
    android:pathData="M 17.278933 22.735568 H 25.080165 V 24.3851 H 17.278933 V 22.735568 Z"/>
</vector>
```

`app/src/main/res/drawable/ic_new_session.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportWidth="24.0"
        android:viewportHeight="24.0">

  <path
    android:fillColor="#FFF"
    android:pathData="M 12, 12
                          m -10.5, 0
                          a 10.5,10.5 0 1,0 21,0
                          a 10.5,10.5 0 1,0 -21,0"/>

  <path
    android:fillColor="#FF000000"
    android:pathData="M12,2C6.48,2 2,6.48 2,12s4.48,10 10,10 10,-4.48 10,-10S17.52,2 12,2zM17,13h-4v4h-2v-4L7,13v-2h4L11,7h2v4h4v2z"/>
</vector>
```

`app/src/main/res/drawable/ic_person.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="24dp"
        android:height="24dp"
        android:viewportHeight="24.0"
        android:viewportWidth="24.0">
  <path
    android:fillColor="#757575"
    android:pathData="M12,12c2.21,0 4,-1.79 4,-4s-1.79,-4 -4,-4 -4,1.79 -4,4 1.79,4 4,4zM12,14c-2.67,0 -8,1.34 -8,4v2h16v-2c0,-2.66 -5.33,-4 -8,-4z"/>
</vector>
```

`app/src/main/res/drawable/ic_terminal_running.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
        android:width="48dp"
        android:height="48dp"
        android:viewportHeight="48"
        android:viewportWidth="48">

  <path
    android:fillColor="#00000000"
    android:pathData="M -1 -1 H 49 V 49 H -1 V -1 Z"/>
  <path
    android:name="body"
    android:fillColor="#00000000"
    android:pathData="M 5.5 1.5 L 42.5 1.5 Q 46.5 1.5 46.5 5.5 L 46.5 42.5 Q 46.5 46.5 42.5 46.5 L 5.5 46.5 Q 1.5 46.5 1.5 42.5 L 1.5 5.5 Q 1.5 1.5 5.5 1.5 Z"
    android:strokeColor="#999999"
    android:strokeWidth="3"/>
  <path
    android:fillColor="#fdfdfd"
    android:pathData="M11,13
                            l5,0
                            l0,10
                            l-5,0"/>
</vector>

```

`app/src/main/res/drawable/text_select_handle_left_material.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
        android:src="@drawable/text_select_handle_left_mtrl_alpha"
        android:tint="#2196F3"/>

```

`app/src/main/res/drawable/text_select_handle_right_material.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<bitmap xmlns:android="http://schemas.android.com/apk/res/android"
        android:src="@drawable/text_select_handle_right_mtrl_alpha"
        android:tint="#2196F3"/>

```

`app/src/main/res/layout/dialog_edit_text.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical"
              android:padding="@dimen/text_margin">

  <TextView
    android:labelFor="@id/dialog_edit_text_editor"
    android:id="@+id/dialog_edit_text_info"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:textAppearance="@style/TextAppearance.AppCompat.Medium"/>

  <EditText
    android:id="@+id/dialog_edit_text_editor"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:inputType="text"
    android:maxLines="1"/>

</LinearLayout>
```

`app/src/main/res/layout/dialog_edit_two_text.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical"
              android:padding="@dimen/text_margin">

  <TextView
    android:id="@+id/dialog_edit_text_info"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:labelFor="@id/dialog_edit_text_editor"
    android:textAppearance="@style/TextAppearance.AppCompat.Medium"/>

  <EditText
    android:id="@+id/dialog_edit_text_editor"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:inputType="text"
    android:maxLines="1"/>

  <TextView
    android:id="@+id/dialog_edit_text2_info"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:labelFor="@id/dialog_edit_text2_editor"
    android:textAppearance="@style/TextAppearance.AppCompat.Medium"/>

  <EditText
    android:id="@+id/dialog_edit_text2_editor"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:inputType="text"
    android:maxLines="1"/>

</LinearLayout>
```

`app/src/main/res/layout/item_color.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:layout_gravity="center"
              android:background="?attr/selectableItemBackground"
              android:clickable="true"
              android:focusable="true"
              android:orientation="horizontal"
              android:padding="@dimen/package_item_padding">

  <View
    android:id="@+id/color_item_view"
    android:layout_width="@dimen/preview_layout_width"
    android:layout_height="@dimen/preview_layout_height"
    android:layout_gravity="center"/>

  <LinearLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginEnd="@dimen/preview_layout_margin_small"
    android:layout_marginLeft="@dimen/preview_layout_margin_small"
    android:layout_marginRight="@dimen/preview_layout_margin_small"
    android:layout_marginStart="@dimen/preview_layout_margin_small"
    android:orientation="vertical">

    <TextView
      android:id="@+id/color_item_name"
      style="@style/TextAppearance.AppCompat.Medium"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:maxLines="1"
      android:textColor="@color/textColor"
      tools:text="Color Item Name"/>

    <TextView
      android:id="@+id/color_item_description"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:maxLines="3"
      android:textColor="@color/textColorSecondary"
      tools:text="Color Item Description"/>

  </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/item_complete_candidate.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:minHeight="@dimen/min_popup_height"
              android:padding="@dimen/popup_padding"
              android:orientation="vertical">

  <TextView
    android:id="@+id/complete_display"
    style="@style/TextAppearance.AppCompat.Medium"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    tools:text="Display"/>

  <View
    android:id="@+id/complete_split"
    android:layout_width="match_parent"
    android:layout_height="1dp"
    android:background="@color/popup_split_background"/>

  <TextView
    android:id="@+id/complete_description"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginEnd="@dimen/text_margin"
    android:layout_marginStart="@dimen/text_margin"
    tools:text="Description"/>

</LinearLayout>
```

`app/src/main/res/layout/item_package.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:tools="http://schemas.android.com/tools"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:background="?attr/selectableItemBackground"
              android:clickable="true"
              android:focusable="true"
              android:orientation="vertical"
              android:padding="@dimen/package_item_padding">

  <TextView
    android:id="@+id/package_item_name"
    style="@style/TextAppearance.AppCompat.Large"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:maxLines="1"
    android:textColor="@color/textColor"
    tools:text="Package Name"/>

  <TextView
    android:id="@+id/package_item_desc"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_marginStart="@dimen/text_margin"
    android:maxLines="3"
    android:textColor="@color/textColorSecondary"
    tools:text="Package Description"/>

</LinearLayout>
```

`app/src/main/res/layout/layout_pm_package_list.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical">

  <com.simplecityapps.recyclerview_fastscroll.views.FastScrollRecyclerView
    android:id="@+id/pm_package_list"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:fastScrollAutoHide="true"
    app:fastScrollAutoHideDelay="1000"
    app:fastScrollPopupBgColor="@color/colorAccent"
    app:fastScrollPopupTextColor="@android:color/primary_text_dark"
    app:fastScrollThumbColor="@color/colorAccent"/>

</LinearLayout>
```

`app/src/main/res/layout/popup_auto_complete.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<io.neoterm.frontend.completion.MaxHeightView xmlns:android="http://schemas.android.com/apk/res/android"
                                              android:layout_width="match_parent"
                                              android:layout_height="match_parent"
                                              android:background="@color/popup_background"
                                              android:orientation="vertical">

  <ListView
    android:id="@+id/popup_complete_candidate_list"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"/>

</io.neoterm.frontend.completion.MaxHeightView>

```

`app/src/main/res/layout/ui_about.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              xmlns:tools="http://schemas.android.com/tools"
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:orientation="vertical"
              tools:ignore="UseCompoundDrawables,ContentDescription">

  <androidx.appcompat.widget.Toolbar
    android:id="@+id/about_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="@color/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>

  <ScrollView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="8dp">

    <LinearLayout
      android:id="@android:id/content"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:orientation="vertical">

      <androidx.cardview.widget.CardView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_marginBottom="8dp"
        app:cardBackgroundColor="@color/list_download_item_color_dark"
        app:cardUseCompatPadding="true">

        <LinearLayout
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:layout_marginBottom="8dp"
          android:orientation="vertical">

          <LinearLayout
            android:layout_width="fill_parent"
            android:layout_height="72dp"
            android:orientation="horizontal"
            android:padding="16dp">

            <ImageView
              android:layout_width="48dp"
              android:layout_height="48dp"
              android:layout_gravity="center_vertical"
              android:scaleType="centerCrop"
              app:srcCompat="@mipmap/about_logo"/>

            <TextView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_vertical"
              android:paddingLeft="16dp"
              android:paddingRight="16dp"
              android:text="@string/app_name"
              android:textAppearance="@style/TextAppearance.AppCompat.Headline"/>
          </LinearLayout>

          <LinearLayout
            android:id="@+id/about_version_view"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center_vertical"
            android:minHeight="48dp"
            android:orientation="horizontal"
            android:paddingLeft="16dp"
            android:paddingRight="16dp">

            <ImageView
              android:layout_width="24dp"
              android:layout_height="24dp"
              app:srcCompat="@drawable/ic_info"/>

            <LinearLayout
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:layout_marginLeft="32dp"
              android:layout_marginStart="32dp"
              android:orientation="vertical"
              android:paddingBottom="8dp"
              android:paddingTop="8dp">

              <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/about_version_label"
                android:textAppearance="@style/TextAppearance.AppCompat.Subhead"/>

              <TextView
                android:id="@+id/app_version"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text=""
                android:textAppearance="@style/TextAppearance.AppCompat.Caption"/>
            </LinearLayout>
          </LinearLayout>

          <LinearLayout
            android:id="@+id/about_licenses_view"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center_vertical"
            android:minHeight="@dimen/md_list_item_height"
            android:orientation="horizontal"
            android:paddingLeft="16dp"
            android:paddingRight="16dp">

            <ImageView
              android:layout_width="24dp"
              android:layout_height="24dp"
              app:srcCompat="@drawable/ic_description"/>

            <TextView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_marginLeft="32dp"
              android:layout_marginStart="32dp"
              android:paddingBottom="8dp"
              android:paddingTop="8dp"
              android:text="@string/about_libraries_label"
              android:textAppearance="@style/TextAppearance.AppCompat.Subhead"/>

          </LinearLayout>

          <LinearLayout
            android:id="@+id/about_source_code_view"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center_vertical"
            android:minHeight="48dp"
            android:orientation="horizontal"
            android:paddingLeft="16dp"
            android:paddingRight="16dp">

            <ImageView
              android:layout_width="24dp"
              android:layout_height="24dp"
              app:srcCompat="@drawable/ic_github"/>

            <LinearLayout
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:layout_marginLeft="32dp"
              android:layout_marginStart="32dp"
              android:orientation="vertical"
              android:paddingBottom="8dp"
              android:paddingTop="8dp">

              <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/about_source_label"
                android:textAppearance="@style/TextAppearance.AppCompat.Subhead"/>

            </LinearLayout>

          </LinearLayout>

        </LinearLayout>

      </androidx.cardview.widget.CardView>

      <androidx.cardview.widget.CardView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_marginBottom="8dp"
        app:cardBackgroundColor="@color/list_download_item_color_dark"
        app:cardUseCompatPadding="true">

        <LinearLayout
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:layout_marginBottom="8dp"
          android:orientation="vertical">

          <LinearLayout
            android:layout_width="fill_parent"
            android:layout_height="72dp"
            android:orientation="horizontal"
            android:padding="16dp">

            <ImageView
              android:layout_width="48dp"
              android:layout_height="48dp"
              android:layout_gravity="center_vertical"
              android:scaleType="centerCrop"
              app:srcCompat="@mipmap/ic_danger"/>

            <TextView
              android:layout_width="wrap_content"
              android:layout_height="wrap_content"
              android:layout_gravity="center_vertical"
              android:paddingLeft="16dp"
              android:paddingRight="16dp"
              android:text="@string/dangerous_zone"
              android:textAppearance="@style/TextAppearance.AppCompat.Headline"/>
          </LinearLayout>

          <LinearLayout
            android:id="@+id/about_reset_app_view"
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center_vertical"
            android:minHeight="48dp"
            android:orientation="horizontal"
            android:paddingLeft="16dp"
            android:paddingRight="16dp">

            <ImageView
              android:layout_width="24dp"
              android:layout_height="24dp"
              app:srcCompat="@drawable/ic_info"/>

            <LinearLayout
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:layout_marginLeft="32dp"
              android:layout_marginStart="32dp"
              android:orientation="vertical"
              android:paddingBottom="8dp"
              android:paddingTop="8dp">

              <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/about_reset_label"
                android:textAppearance="@style/TextAppearance.AppCompat.Subhead"/>

              <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="@string/about_reset_label_desc"
                android:textAppearance="@style/TextAppearance.AppCompat.Caption"/>

            </LinearLayout>

          </LinearLayout>
        </LinearLayout>

      </androidx.cardview.widget.CardView>

    </LinearLayout>
  </ScrollView>

</LinearLayout>

```

`app/src/main/res/layout/ui_color_scheme.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical">

  <androidx.appcompat.widget.Toolbar
    android:id="@+id/custom_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="@color/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark"
    android:visibility="visible"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>


  <LinearLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <RelativeLayout
      android:layout_width="match_parent"
      android:layout_height="0dp"
      android:layout_margin="@dimen/preview_layout_margin"
      android:layout_weight="1.0"
      android:background="@color/terminal_background">

      <io.neoterm.frontend.session.view.extrakey.ExtraKeysView
        android:id="@+id/custom_extra_keys"
        style="?android:buttonBarStyle"
        android:layout_width="match_parent"
        android:layout_height="@dimen/eks_height_two_line"
        android:layout_alignParentBottom="true"
        android:orientation="horizontal"
        android:visibility="gone"/>

      <io.neoterm.frontend.session.view.TerminalView
        android:id="@+id/terminal_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_above="@id/custom_extra_keys"
        android:fadeScrollbars="true"
        android:focusable="false"
        android:focusableInTouchMode="false"
        android:scrollbars="vertical"/>

    </RelativeLayout>

    <LinearLayout
      android:layout_width="match_parent"
      android:layout_height="0dp"
      android:layout_marginBottom="@dimen/preview_layout_margin_small"
      android:layout_marginEnd="@dimen/preview_layout_margin_small"
      android:layout_marginLeft="@dimen/preview_layout_margin_small"
      android:layout_marginRight="@dimen/preview_layout_margin_small"
      android:layout_marginStart="@dimen/preview_layout_margin_small"
      android:layout_marginTop="0dp"
      android:layout_weight="1.0"
      android:orientation="vertical">

      <com.simplecityapps.recyclerview_fastscroll.views.FastScrollRecyclerView
        android:id="@+id/custom_color_color_list"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:fastScrollAutoHide="true"
        app:fastScrollAutoHideDelay="1000"
        app:fastScrollPopupBgColor="@color/colorAccent"
        app:fastScrollPopupTextColor="@android:color/primary_text_dark"
        app:fastScrollThumbColor="@color/colorAccent"/>

    </LinearLayout>

  </LinearLayout>

</LinearLayout>

```

`app/src/main/res/layout/ui_command_shortcut.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
             android:layout_width="match_parent"
             android:layout_height="match_parent"
             android:orientation="vertical">

  <LinearLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_margin="@dimen/preview_layout_margin"
    android:orientation="vertical">

    <android.support.design.widget.TextInputLayout
      android:id="@+id/command_shortcut_display_title_layout"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:hint="@string/command_shortcut_display_title">

      <EditText
        android:id="@+id/command_shortcut_display_title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
    </android.support.design.widget.TextInputLayout>

    <android.support.design.widget.TextInputLayout
      android:id="@+id/command_shortcut_command_layout"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:hint="@string/command_shortcut_command">

      <EditText
        android:id="@+id/command_shortcut_command"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
    </android.support.design.widget.TextInputLayout>
  </LinearLayout>


  <android.support.design.widget.FloatingActionButton
    android:id="@+id/command_shortcut_create_fab"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:layout_gravity="end|bottom"
    android:layout_margin="@dimen/fab_margin"
    android:src="@drawable/ic_done"/>

</FrameLayout>
```

`app/src/main/res/layout/ui_crash.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:background="@color/terminal_background"
              android:orientation="vertical">

  <androidx.appcompat.widget.Toolbar
    android:id="@+id/crash_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="@color/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>

  <LinearLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_margin="@dimen/text_margin"
    android:orientation="vertical">

    <TextView
      android:id="@+id/crash_model"
      style="@style/TextAppearance.AppCompat.Medium"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:textColor="@color/textColorSecondary"/>

    <TextView
      android:id="@+id/crash_app_version"
      style="@style/TextAppearance.AppCompat.Medium"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:textColor="@color/textColorSecondary"/>

    <TextView
      style="@style/TextAppearance.AppCompat.Medium"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:layout_marginTop="@dimen/text_margin"
      android:gravity="start|top"
      android:text="@string/crash_stack_trace"
      android:textColor="@color/textColor"/>

    <ScrollView
      android:layout_width="match_parent"
      android:layout_height="match_parent">

      <TextView
        android:id="@+id/crash_details"
        style="@style/TextAppearance.AppCompat.Medium"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_marginEnd="@dimen/text_margin"
        android:layout_marginStart="@dimen/text_margin"
        android:gravity="start|top"
        android:textColor="@color/textColor"/>
    </ScrollView>

  </LinearLayout>


</LinearLayout>
```

`app/src/main/res/layout/ui_customize.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                xmlns:app="http://schemas.android.com/apk/res-auto"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

  <androidx.appcompat.widget.Toolbar
    android:id="@+id/custom_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="@color/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark"
    android:visibility="visible"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>

  <LinearLayout
    android:layout_marginBottom="@dimen/text_margin"
    android:id="@+id/custom_editor_layout"
    style="?buttonBarStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true"
    android:layout_margin="@dimen/text_margin"
    android:orientation="vertical">

    <RelativeLayout
      android:layout_width="match_parent"
      android:layout_height="@dimen/custom_editor_line_height"
      android:layout_gravity="center"
      android:gravity="center"
      android:orientation="horizontal">

      <ImageButton
        style="?buttonBarButtonStyle"
        android:id="@+id/custom_install_font_button"
        android:layout_width="@dimen/custom_install_icon_width"
        android:layout_height="@dimen/custom_editor_line_height"
        android:layout_alignParentEnd="true"
        app:srcCompat="@drawable/ic_install_white_36"/>

      <TextView
        android:gravity="center"
        android:id="@+id/custom_font_text"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_alignParentStart="true"
        android:text="@string/pref_customization_font"/>

      <Spinner
        android:id="@+id/custom_font_spinner"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginStart="@dimen/text_margin"
        android:layout_toEndOf="@id/custom_font_text"
        android:layout_toStartOf="@id/custom_install_font_button"/>

    </RelativeLayout>

    <RelativeLayout
      android:layout_width="match_parent"
      android:layout_height="@dimen/custom_editor_line_height"
      android:layout_gravity="center"
      android:gravity="center"
      android:orientation="horizontal">

      <ImageButton
        style="?buttonBarButtonStyle"
        android:id="@+id/custom_install_color_button"
        android:layout_width="@dimen/custom_install_icon_width"
        android:layout_height="@dimen/custom_editor_line_height"
        android:layout_alignParentEnd="true"
        app:srcCompat="@drawable/ic_install_white_36"/>

      <TextView
        android:gravity="center"
        android:id="@+id/custom_color_text"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:layout_alignParentStart="true"
        android:text="@string/pref_customization_color_scheme"/>

      <Spinner
        android:id="@+id/custom_color_spinner"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginStart="@dimen/text_margin"
        android:layout_toEndOf="@id/custom_color_text"
        android:layout_toStartOf="@id/custom_install_color_button"/>

    </RelativeLayout>
  </LinearLayout>

  <RelativeLayout
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_above="@id/custom_editor_layout"
    android:layout_below="@id/custom_toolbar"
    android:layout_margin="@dimen/preview_layout_margin">

    <io.neoterm.frontend.session.view.extrakey.ExtraKeysView
      android:id="@+id/custom_extra_keys"
      style="?android:buttonBarStyle"
      android:layout_width="match_parent"
      android:layout_height="@dimen/eks_height_two_line"
      android:layout_alignParentBottom="true"
      android:background="@color/terminal_background"
      android:orientation="horizontal"/>

    <io.neoterm.frontend.session.view.TerminalView
      android:id="@+id/terminal_view"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:layout_above="@id/custom_extra_keys"
      android:background="@color/terminal_background"
      android:fadeScrollbars="true"
      android:focusable="false"
      android:focusableInTouchMode="false"
      android:scrollbars="vertical"/>

  </RelativeLayout>

</RelativeLayout>

```

`app/src/main/res/layout/ui_faq.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              xmlns:tools="http://schemas.android.com/tools"
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:orientation="vertical"
              tools:ignore="UseCompoundDrawables,ContentDescription">

  <androidx.appcompat.widget.Toolbar
    android:id="@+id/faq_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="@color/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>

  <ScrollView
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="8dp">

    <LinearLayout
      android:id="@android:id/content"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:orientation="vertical">

      <androidx.appcompat.widget.CardView
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        android:layout_gravity="center"
        android:layout_marginBottom="8dp"
        app:cardBackgroundColor="@color/list_download_item_color_dark"
        app:cardUseCompatPadding="true">

        <LinearLayout
          android:layout_width="fill_parent"
          android:layout_height="wrap_content"
          android:layout_marginBottom="8dp"
          android:orientation="vertical">

          <LinearLayout
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center_vertical"
            android:minHeight="48dp"
            android:orientation="horizontal"
            android:paddingLeft="16dp"
            android:paddingRight="16dp">

            <LinearLayout
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:layout_marginLeft="32dp"
              android:layout_marginStart="32dp"
              android:orientation="vertical"
              android:paddingBottom="8dp"
              android:paddingTop="8dp">

              <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="FAQ1"
                android:textAppearance="@style/TextAppearance.AppCompat.Subhead"/>

            </LinearLayout>
          </LinearLayout>

          <LinearLayout
            android:layout_width="fill_parent"
            android:layout_height="wrap_content"
            android:background="?attr/selectableItemBackground"
            android:clickable="true"
            android:focusable="true"
            android:gravity="center_vertical"
            android:minHeight="48dp"
            android:orientation="horizontal"
            android:paddingLeft="16dp"
            android:paddingRight="16dp">

            <LinearLayout
              android:layout_width="fill_parent"
              android:layout_height="wrap_content"
              android:layout_marginLeft="32dp"
              android:layout_marginStart="32dp"
              android:orientation="vertical"
              android:paddingBottom="8dp"
              android:paddingTop="8dp">

              <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="FAQ2"
                android:textAppearance="@style/TextAppearance.AppCompat.Subhead"/>

            </LinearLayout>
          </LinearLayout>

        </LinearLayout>

      </androidx.appcompat.widget.CardView>

    </LinearLayout>
  </ScrollView>

</LinearLayout>

```

`app/src/main/res/layout/ui_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:background="@color/terminal_background"
              android:orientation="vertical">

  <androidx.appcompat.widget.Toolbar
    android:id="@+id/terminal_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="@color/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark"
    android:visibility="visible"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>


  <de.mrapp.android.tabswitcher.TabSwitcher
    android:id="@+id/tab_switcher"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    app:layoutPolicy="auto"
    app:tabBackgroundColor="@color/tab_background_color"
    app:tabCloseButtonIcon="@drawable/ic_close_tab_18dp"
    app:tabIcon="@drawable/ic_tab_icon"
    app:tabTitleTextColor="@color/tab_title_text_color"
    app:toolbarMenu="@menu/menu_main"
    app:toolbarNavigationIcon="@drawable/ic_add_box_white_24dp"/>

</LinearLayout>
```

`app/src/main/res/layout/ui_pm.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                xmlns:app="http://schemas.android.com/apk/res-auto"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:background="@color/terminal_background"
                android:orientation="vertical">

  <LinearLayout
    android:id="@+id/pm_tab_header"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <androidx.appcompat.widget.Toolbar
      android:id="@+id/pm_toolbar"
      android:layout_width="match_parent"
      android:layout_height="?attr/actionBarSize"
      android:background="@color/colorPrimary"
      android:theme="@style/ThemeOverlay.AppCompat.Dark"
      app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>

    <io.neoterm.ui.pm.view.RecyclerTabLayout
      android:id="@+id/pm_tab_layout"
      android:layout_width="match_parent"
      android:layout_height="@dimen/recycler_tab_height"
      android:background="@color/colorPrimary"/>
  </LinearLayout>

  <androidx.viewpager.widget.ViewPager
    android:id="@+id/pm_view_pager"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_below="@id/pm_tab_header"/>

</RelativeLayout>

```

`app/src/main/res/layout/ui_pm_single_tab.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:background="@color/terminal_background"
              android:orientation="vertical">

  <androidx.appcompat.widget.Toolbar
    android:id="@+id/pm_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?attr/actionBarSize"
    android:background="@color/colorPrimary"
    android:theme="@style/ThemeOverlay.AppCompat.Dark"
    app:popupTheme="@style/ThemeOverlay.AppCompat.Dark"/>

  <include layout="@layout/layout_pm_package_list"/>

</LinearLayout>

```

`app/src/main/res/layout/ui_setup.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:layout_margin="32dp"
                android:orientation="vertical">

  <TextView
    android:id="@+id/setup_title_text"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_gravity="center"
    android:layout_marginBottom="26dp"
    android:layout_marginTop="26dp"
    android:gravity="center"
    android:text="@string/setup_info"
    android:textColor="@color/colorAccent"
    android:textSize="32sp"/>

  <TextView
    android:id="@+id/select_method_tip_text"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_below="@id/setup_title_text"
    android:text="@string/setup_setup_method"/>

  <Button
    android:id="@+id/setup_next"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true"
    android:text="@string/setup_next"/>

  <LinearLayout
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_above="@+id/setup_next"
    android:layout_below="@id/select_method_tip_text"
    android:orientation="vertical">

    <RadioGroup
      android:id="@+id/setup_method_group"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:checkedButton="@id/setup_method_online">

      <RadioButton
        android:id="@+id/setup_method_online"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@string/setup_online"/>

      <RadioButton
        android:id="@+id/setup_method_local"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@string/setup_local"/>

      <RadioButton
        android:id="@+id/setup_method_backup"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="@string/setup_backup"/>

    </RadioGroup>

    <TextView
      android:id="@+id/setup_url_tip_text"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:layout_marginTop="8dp"
      android:text="@string/setup_source_parameter"/>

    <LinearLayout
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:orientation="horizontal">

      <EditText
        android:id="@+id/setup_source_parameter"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1.0"
        android:focusable="false"
        android:clickable="false"
        android:hint="@string/setup_hint_online"
        android:text="@string/default_source_url"/>

      <Button
        android:id="@+id/setup_source_parameter_select"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="0.2"
        android:text="@string/setup_dots"/>

    </LinearLayout>

    <ScrollView
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:layout_marginTop="8dp">

      <TextView
        android:id="@+id/setup_log_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"/>
    </ScrollView>

  </LinearLayout>

</RelativeLayout>
```

`app/src/main/res/layout/ui_term.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

  <io.neoterm.frontend.session.view.extrakey.ExtraKeysView
    android:id="@+id/extra_keys"
    style="?android:buttonBarStyle"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:layout_alignParentBottom="true"
    android:background="@color/terminal_background"
    android:orientation="horizontal"/>

  <io.neoterm.frontend.session.view.TerminalView
    android:id="@+id/terminal_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_above="@id/extra_keys"
    android:background="@color/terminal_background"
    android:fadeScrollbars="true"
    android:focusable="true"
    android:focusableInTouchMode="true"
    android:scrollbars="vertical"/>

</RelativeLayout>

```

`app/src/main/res/layout/ui_term_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

  <io.neoterm.frontend.session.view.TerminalView
    android:layout_margin="@dimen/text_margin"
    android:id="@+id/terminal_view_dialog"
    android:layout_width="match_parent"
    android:layout_height="@dimen/terminal_dialog_height"
    android:background="@color/terminal_background"
    android:fadeScrollbars="true"
    android:focusable="false"
    android:focusableInTouchMode="false"
    android:scrollbars="vertical"/>

</RelativeLayout>

```

`app/src/main/res/layout/ui_term_embedded.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

  <io.neoterm.frontend.session.view.TerminalView
    android:id="@+id/terminal_view"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/terminal_background"
    android:fadeScrollbars="true"
    android:focusable="true"
    android:focusableInTouchMode="true"
    android:scrollbars="vertical"/>

</RelativeLayout>

```

`app/src/main/res/layout/ui_user_script_list.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:layout_margin="@dimen/text_margin"
              android:baselineAligned="false"
              android:orientation="vertical">

  <LinearLayout
    android:layout_width="match_parent"
    android:layout_height="0dp"
    android:layout_weight="1.0"
    android:orientation="vertical">

    <TextView
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:text="@string/files_to_handle"/>

    <ListView
      android:id="@+id/user_script_file_list"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"/>

  </LinearLayout>

  <LinearLayout
    android:layout_width="match_parent"
    android:layout_height="0dp"
    android:layout_marginTop="@dimen/text_margin"
    android:layout_weight="1.0"
    android:orientation="vertical">

    <TextView
      android:layout_width="match_parent"
      android:layout_height="wrap_content"
      android:text="@string/available_user_scripts"/>

    <ListView
      android:id="@+id/user_script_script_list"
      android:layout_width="match_parent"
      android:layout_height="wrap_content"/>

  </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/ui_xorg.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
                android:layout_width="match_parent"
                android:layout_height="match_parent">

  <FrameLayout
    android:id="@+id/xorg_video_layout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:layout_centerInParent="true"/>

</RelativeLayout>

```

`app/src/main/res/menu/menu_color_editor.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto">
  <item
    android:id="@+id/action_done"
    android:icon="@drawable/ic_done"
    android:title="@string/done"
    app:showAsAction="always"/>
</menu>
```

`app/src/main/res/menu/menu_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto">

  <item
    android:id="@+id/toggle_tab_switcher_menu_item"
    android:title="@string/toggle_tab_switcher_menu_item"
    app:actionLayout="@layout/tab_switcher_menu_item"
    app:showAsAction="ifRoom"/>

  <item
    android:id="@+id/menu_item_new_session"
    android:title="@string/new_session"
    app:showAsAction="never"/>

  <item
    android:title="@string/new_session_more"
    app:showAsAction="never">
    <menu>
      <item
        android:id="@+id/menu_item_new_session_with_profile"
        android:title="@string/new_session_with_profile"
        app:showAsAction="never"/>

      <item
        android:id="@+id/menu_item_new_system_session"
        android:title="@string/new_system_session"
        app:showAsAction="never"/>

      <item
        android:id="@+id/menu_item_new_x_session"
        android:title="@string/new_x_session"
        android:visible="false"
        app:showAsAction="never"/>
    </menu>
  </item>

  <item
    android:id="@+id/menu_item_package_settings"
    android:title="@string/package_settings"
    app:showAsAction="never"/>

  <item
    android:id="@+id/menu_item_settings"
    android:title="@string/settings"
    app:showAsAction="never"/>

</menu>
```

`app/src/main/res/menu/menu_pm.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto">

  <item
    android:id="@+id/action_search"
    android:icon="@drawable/ic_search"
    android:title="@android:string/search_go"
    app:actionViewClass="androidx.appcompat.widget.SearchView"
    app:showAsAction="ifRoom|collapseActionView"/>

  <item
    android:id="@+id/action_refresh"
    android:title="@string/menu_refresh_list"
    app:showAsAction="never"/>

  <item
    android:id="@+id/action_update_and_refresh"
    android:title="@string/menu_update"
    app:showAsAction="never"/>

  <item
    android:id="@+id/action_upgrade"
    android:title="@string/menu_upgrade"
    app:showAsAction="never"/>

  <item
    android:id="@+id/action_source"
    android:title="@string/pref_package_source"
    app:showAsAction="never"/>

</menu>
```

`app/src/main/res/values-zh-rCN/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="app_name">NeoTerm</string>
  <string name="about">关于</string>
  <string name="copy_text">复制</string>
  <string name="general_settings">通用设置</string>
  <string name="new_session">新建会话</string>
  <string name="new_session_more">新建会话…</string>
  <string name="new_system_session">新建系统会话</string>
  <string name="package_settings">软件包</string>
  <string name="paste_text">粘贴</string>
  <string name="super_paste_text">高级粘贴</string>
  <string name="pref_general_backspace_map_to_esc">返回键发送ESC</string>
  <string name="pref_general_backspace_map_to_esc_desc">当返回键按下时，发送ESC而不是关闭窗口</string>
  <string name="pref_general_bell">响铃</string>
  <string name="pref_general_bell_desc">收到 \'\\a\' 时响铃</string>
  <string name="pref_general_shell">登录程序</string>
  <string name="pref_general_shell_desc">登录时使用指定的程序</string>
  <string name="pref_general_vibrate">振动</string>
  <string name="pref_general_vibrate_desc">收到 \'\\a\' 时振动</string>
  <string name="pref_general_initial_command">初始命令</string>
  <string name="pref_general_initial_command_desc">在新的会话创建时执行命令</string>
  <string name="pref_general_volume_as_control">将音量键作为特殊键</string>
  <string name="pref_general_volume_as_control_desc">音量下为 Ctrl\n音量上为 FN</string>
  <string name="pref_general_use_execve_wrapper">使用自定义的 execve()</string>
  <string name="pref_general_use_execve_wrapper_desc">接管 execve() 来兼容 linux 风格的 shebang</string>
  <string name="pref_general_enable_word_based_ime">启用基于单词的输入法</string>
  <string name="pref_general_enable_word_based_ime_desc">输入单位为单词而不是字母（谷歌输入法无法输入中文可以勾选此选项）</string>
  <string name="pref_package_source">软件源</string>
  <string name="pref_ui_close_tab_anim_next_tab">向下切换窗口</string>
  <string name="pref_ui_close_tab_anim_next_tab_desc">关闭当前窗口时切换到下一个窗口而不是上一个</string>
  <string name="customization_settings_desc">字体，主题</string>
  <string name="customization_settings">个性化</string>
  <string name="pref_ui_fullscreen">全屏</string>
  <string name="pref_ui_hide_toolbar">隐藏标题栏</string>
  <string name="pref_ui_hide_toolbar_desc">键盘显示时隐藏标题栏</string>
  <string name="pref_ui_eks_weight_explicit">为快捷键盘强制设置权重</string>
  <string name="pref_ui_eks_weight_explicit_desc">如果快捷键盘显示不正确，请勾选本项</string>
  <string name="pref_ui_eks_enabled">显示拓展键</string>
  <string name="pref_ui_eks_enabled_desc">屏幕下方出现一行有方向键，esc 键之类的按键</string>
  <string name="pref_customization_color_scheme">配色方案</string>
  <string name="pref_customization_font">字体</string>
  <string name="settings">设置</string>
  <string name="text_selection_more">更多</string>
  <string name="toggle_ime">切换键盘</string>
  <string name="toggle_tab_switcher_menu_item">切换窗口</string>
  <string name="ui_settings">界面设置</string>
  <string name="shell_not_found">登录程序 %s 未找到</string>
  <string name="shell_not_found_message">你想要安装它吗？</string>
  <string name="installer_message">正在安装</string>
  <string name="installer_install_zsh_required">将要安装 oh-my-zsh 并将您的登录程序切换到 zsh</string>
  <string name="fullscreen_mode_changed">全屏模式已改变，请重启 NeoTerm</string>
  <string name="permission_denied">NeoTerm 无法取得必需的权限，正在退出</string>
  <string name="error">还有这种操作？</string>
  <string name="use_system_shell">使用系统会话</string>
  <string name="retry">重试</string>
  <string name="source_changed">APT 源已更改，你可能需要执行 apt update 来更新</string>
  <string name="package_details">软件包: %s\n版本: %s\n依赖: %s\n占用空间: %s\n描述: %s\n主页: %s</string>
  <string name="package_list_empty">软件包列表为空，请检查你的软件源</string>
  <string name="menu_refresh_list">刷新</string>
  <string name="menu_update">更新并刷新</string>
  <string name="float_up">浮动窗口</string>

  <string name="done">完成</string>
  <string name="install">安装</string>

  <string name="pref_customization_eks">拓展键盘</string>
  <string name="general_settings_desc">响铃，振动，Shell，初始命令</string>
  <string name="ui_settings_desc">全屏，标题栏，切换动画</string>
  <string name="package_settings_desc">软件源，更新，升级</string>
  <string name="install_font">安装字体</string>
  <string name="install_color">安装配色方案</string>

  <string name="setup_info">你好，NeoTerm</string>
  <string name="setup_next">开始！</string>
  <string name="setup_setup_method">选择你的安装方式</string>
  <string name="setup_online">从软件源安装</string>
  <string name="setup_local">从本地 Zip 文件安装</string>
  <string name="setup_backup">从 NeoTerm 备份中恢复</string>
  <string name="setup_source_parameter">配置参数</string>
  <string name="setup_input_source_parameter">输入配置参数</string>
  <string name="setup_hint_online">含有启动文件的软件源地址</string>
  <string name="setup_hint_local">启动文件(*.zip)路径</string>
  <string name="setup_hint_backup">备份文件(*.neobackup) 路径</string>
  <string name="setup_error_file_not_found">文件不存在</string>
  <string name="setup_error_invalid_url">非法的 URL</string>
  <string name="setup_error_no_internet">无网络连接</string>
  <string name="setup_error_connection_failed">无法连接到服务器</string>
  <string name="setup_error_parameter_null">配置参数为空</string>
  <string name="setup_preparing">准备中…</string>
  <string name="setup_confirm">最后一步</string>
  <string name="setup_confirm_text">目前为止一切顺利，继续?</string>
  <string name="setup_reset_confirm">重置确认</string>
  <string name="setup_reset_confirm_text">这个操作会清空你的所有数据，是否继续？</string>

  <string name="crash_model">设备: %s</string>
  <string name="crash_app">应用: %s</string>
  <string name="crash_stack_trace">堆栈信息</string>
  <string name="service_status_text">%d 个会话, %d 个图形会话</string>
  <string name="service_lock_acquired">(永不休眠)</string>
  <string name="service_acquire_lock">取得休眠锁</string>
  <string name="service_release_lock">释放休眠锁</string>
  <string name="exit">退出</string>
  <string name="term_here">在此处打开终端</string>
  <string name="user_script">用户脚本</string>
  <string name="no_user_script_found">没有找到可用的用户脚本 (是否忘记设置可执行权限?)</string>
  <string name="no_files_selected">没有文件被选择\n\n(原始 Intent: %s)</string>
  <string name="unsupported_term_here">不支持在此处打开终端\n\n(原始 Intent: %s)</string>
  <string name="files_to_handle">处理的文件</string>
  <string name="available_user_scripts">可用的用户脚本</string>
  <string name="confirm_remove_file_from_list">从操作列表中移除文件？</string>
  <string name="confirm_remove">移除?</string>
  <string name="command_shortcut">命令快捷方式</string>
  <string name="command_shortcut_display_title">标题</string>
  <string name="command_shortcut_command">命令</string>
  <string name="no_command_extra">没有找到需要执行的命令，是否忘记了传递参数？</string>
  <string name="command_display_title_cannot_be_null">展示标题不可为空</string>
  <string name="pref_general_auto_completion">自动补全（实验性）</string>
  <string name="pref_general_auto_completion_desc">输入命令或者路径时提供补全。该功能还在开发中，有许多bug需要解决</string>
  <string name="menu_upgrade">升级</string>
  <string name="apt_update_ok">软件包列表成功更新</string>
  <string name="apt_upgrade_ok">软件包已成功升级</string>
  <string name="installing_topic">安装已开始，请注意屏幕上出现的提示</string>
  <string name="session_closed">会话已关闭</string>
  <string name="restore_session">取消</string>
  <string name="show_help">查看帮助</string>
  <string name="service_connection_failed">无法连接到服务</string>
  <string name="about_version_label">版本</string>
  <string name="about_developers_label">开发者 &amp; 贡献者</string>
  <string name="about_libraries_label">第三方库</string>
  <string name="about_source_label">源码</string>
  <string name="about_reset_label">重置 App</string>
  <string name="about_reset_label_desc">清除除用户家目录以外的所有文件</string>
  <string name="support_donate_label">捐赠</string>
  <string name="support_donate_description">如果你喜欢这个app，你可以考虑请作者喝杯咖啡</string>
  <string name="about_developers">Kiva 维护\nCrixec 图标设计\n酷安用户 @NimaQu 赞助服务器\nQQ用户 @My 提供免费网络</string>
  <string name="support_donate_dialog_text">这个app是我在课余时间制作的，一个人不仅要维护app，还要维护各种软件包和服务器，如果能得到你的支持，我将更有动力继续将app完善下去
  </string>
  <string name="support_donate_alipay">支付宝</string>
  <string name="new_color_scheme">新建配色方案</string>
  <string name="faq">常见问题</string>
  <string name="new_source">新建</string>
  <string name="process_exit_info">进程已结束</string>
  <string name="process_exit_code">状态 %d</string>
  <string name="process_exit_signal">信号 %d</string>
  <string name="process_exit_prompt">按回车关闭</string>
  <string name="process_exit_prompt_press_back">按返回关闭</string>
  <string name="save_color_info">输入新的配色方案名</string>
  <string name="save_color_scheme_name_template">新配色方案</string>
  <string name="save_color">保存配色方案</string>
  <string name="discard_changes">丢弃所有改动？</string>
  <string name="save">保存</string>
  <string name="select_new_value">选择</string>
  <string name="input_new_value">输入新颜色</string>
  <string name="toggle_eks">切换拓展键</string>
  <string name="new_x_session">新建图形会话</string>
  <string name="new_session_with_profile">新建 Profile 会话</string>
  <string name="no_profile_available">没有可用的个性化配置</string>
  <string name="no_file_picker">没有文件选择器</string>
  <string name="input_new_source_url">输入 URL</string>
  <string name="input_new_source_repo">输入仓库名</string>
  <string name="error_new_source_url">URL 不能为空</string>
  <string name="error_new_source_repo">仓库 不能为空</string>
  <string name="sorry_for_development">本功能仍在开发中，所以只能在 DEBUG 构建版本下使用。\n若想尝鲜，请尝试联系开发者来成为测试者。</string>
  <string name="dangerous_zone">危险区域</string>
  <string name="reset_app_warning">执行此操作后，下次启动时将要重新配置 NeoTerm，继续？</string>

  <string-array name="color_item_names">
    <item>背景色</item>
    <item>前景色</item>
    <item>光标颜色</item>
    <item>黑色</item>
    <item>红色</item>
    <item>绿色</item>
    <item>黄色</item>
    <item>蓝色</item>
    <item>洋红色</item>
    <item>青色</item>
    <item>白色</item>
    <item>亮黑色</item>
    <item>亮红色</item>
    <item>亮绿色</item>
    <item>亮黄色</item>
    <item>亮蓝色</item>
    <item>亮洋红色</item>
    <item>亮青色</item>
    <item>亮白色</item>
  </string-array>

  <string-array name="custom_preview_script_colors">
    <item>你好 NeoTerm\\n</item>
    <item>"\\e[30m 黑色 \\e[0m\\n"</item>
    <item>"\\e[31m 红色 \\e[0m\\n"</item>
    <item>"\\e[32m 绿色 \\e[0m\\n"</item>
    <item>"\\e[33m 黄色 \\e[0m\\n"</item>
    <item>"\\e[34m 蓝色 \\e[0m\\n"</item>
    <item>"\\e[35m 洋红色 \\e[0m\\n"</item>
    <item>"\\e[36m 青色 \\e[0m\\n"</item>
    <item>"\\e[37m 白色 \\e[0m\\n"</item>
    <item>"\\e[1;30m 亮黑色 \\e[0m\\n"</item>
    <item>"\\e[1;31m 亮红色 \\e[0m\\n"</item>
    <item>"\\e[1;32m 亮绿色 \\e[0m\\n"</item>
    <item>"\\e[1;33m 亮黄色 \\e[0m\\n"</item>
    <item>"\\e[1;34m 亮蓝色 \\e[0m\\n"</item>
    <item>"\\e[1;35m 亮洋红色\\e[0m\\n"</item>
    <item>"\\e[1;36m 亮青色 \\e[0m\\n"</item>
    <item>"\\e[1;37m 亮白色 \\e[0m\\n"</item>
  </string-array>
</resources>
```

`app/src/main/res/values-zh-rTW/strings.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="app_name">NeoTerm</string>
  <string name="about">關於</string>
  <string name="copy_text">複製</string>
  <string name="general_settings">一般設定</string>
  <string name="new_session">新增會話</string>
  <string name="new_session_more">新增會話…</string>
  <string name="new_system_session">新增系統會話</string>
  <string name="package_settings">軟件包</string>
  <string name="paste_text">貼上</string>
  <string name="pref_general_backspace_map_to_esc">返回鍵發送ESC</string>
  <string name="pref_general_backspace_map_to_esc_desc">按下返回鍵時，發送ESC而不關閉</string>
  <string name="pref_general_bell">響鈴</string>
  <string name="pref_general_bell_desc">收到 \'\\a\' 時響鈴</string>
  <string name="pref_general_shell">登入程式</string>
  <string name="pref_general_shell_desc">登入時使用指定的程式</string>
  <string name="pref_general_vibrate">震動</string>
  <string name="pref_general_vibrate_desc">收到 \'\\a\' 時震動</string>
  <string name="pref_general_initial_command">初始化指令</string>
  <string name="pref_general_initial_command_desc">在新的創建新的會話時執行指令</string>
  <string name="pref_general_volume_as_control">將音量鍵作為特殊鍵</string>
  <string name="pref_general_volume_as_control_desc">音量下為 Ctrl\n音量上為 FN</string>
  <string name="pref_package_source">軟體源</string>
  <string name="pref_ui_close_tab_anim_next_tab">向下切換窗口</string>
  <string name="pref_ui_close_tab_anim_next_tab_desc">關閉目前視窗時切換到下一個而不是上一個</string>
  <string name="customization_settings_desc">字體，主題</string>
  <string name="customization_settings">個人化</string>
  <string name="pref_ui_fullscreen">全螢幕</string>
  <string name="pref_ui_hide_toolbar">隱藏標題欄</string>
  <string name="pref_ui_hide_toolbar_desc">在鍵盤顯示時隱藏標題欄</string>
  <string name="pref_ui_eks_weight_explicit">為快捷鍵盤強制設定權重</string>
  <string name="pref_ui_eks_weight_explicit_desc">如果快捷鍵盤顯示錯誤，請勾選此項目</string>
  <string name="pref_customization_color_scheme">色彩主題</string>
  <string name="pref_customization_font">字體</string>
  <string name="settings">設定</string>
  <string name="text_selection_more">更多</string>
  <string name="toggle_ime">切換鍵盤</string>
  <string name="toggle_tab_switcher_menu_item">切換視窗</string>
  <string name="ui_settings">介面設定</string>
  <string name="shell_not_found">找不到 Shell %s, 請先安裝.</string>
  <string name="installer_message">正在安装</string>
  <string name="installer_install_zsh_required">將要安装 oh-my-zsh 並將登入程式切換到 zsh</string>
  <string name="fullscreen_mode_changed">全螢幕模式已改變，請重新開啟 NeoTerm</string>
  <string name="permission_denied">NeoTerm 無法取得必需的權限，正在退出</string>
  <string name="error">還有這種操作？</string>
  <string name="use_system_shell">使用系统Shell</string>
  <string name="retry">重試</string>
  <string name="source_changed">APT 源已改變，可能需要執行 apt update 來更新</string>
  <string name="package_details">軟體包: %s\n版本: %s\n依賴: %s\n使用空間: %s\n描述: %s\n首頁: %s</string>
  <string name="package_list_empty">軟體包列表為空，請檢查你的軟體源</string>
  <string name="menu_refresh_list">重新整理</string>
  <string name="menu_update">更新並重新整理</string>
  <string name="float_up">懸浮視窗</string>

  <string name="done">完成</string>
  <string name="install">安裝</string>

  <string name="pref_customization_eks">擴充鍵盤</string>
  <string name="general_settings_desc">響鈴，震動，Shell，初始化指令</string>
  <string name="ui_settings_desc">全螢幕，標題欄，切換動畫</string>
  <string name="package_settings_desc">軟體源，更新，升級</string>
  <string name="install_font">安裝字體</string>
  <string name="install_color">安裝色彩主題</string>
  <string name="setup_info">你好，NeoTerm</string>
  <string name="setup_next">GO</string>
  <string name="crash_model">裝置: %s</string>
  <string name="crash_app">程式: %s</string>
  <string name="crash_stack_trace">錯誤訊息</string>
  <string name="service_status_text">%d 個會話, %d 個图形會話</string>
  <string name="service_lock_acquired">(永不休眠)</string>
  <string name="service_acquire_lock">開啟休眠鎖</string>
  <string name="service_release_lock">關閉休眠鎖</string>
  <string name="exit">離開</string>
  <string name="term_here">在此處打開終端</string>
  <string name="user_script">使用者腳本</string>
  <string name="no_user_script_found">没有找到可用的使用者腳本</string>
  <string name="no_files_selected">沒有檔案被選擇\n\n(Intent: %s)</string>
  <string name="unsupported_term_here">不支持在此处打开终端\n\n(Intent: %s)</string>
  <string name="files_to_handle">處理的檔案</string>
  <string name="available_user_scripts">可用的使用者腳本</string>
  <string name="confirm_remove_file_from_list">從操作列表中中移除檔案？</string>
  <string name="confirm_remove">移除?</string>
  <string name="command_shortcut">命令快捷方式</string>
  <string name="no_command_extra">沒有找到需要執行的命令，是否忘記了傳遞參數？</string>
  <string name="command_display_title_cannot_be_null">展示標題不可為空</string>
  <string name="command_shortcut_display_title">"標題 "</string>
  <string name="command_shortcut_command">命令</string>
  <string name="pref_general_auto_completion">自動補全（實驗性）</string>
  <string name="pref_general_auto_completion_desc">"輸入命令或者路徑時提供補全。該功能還在開發中，有許多bug需要解决 "</string>
  <string name="menu_upgrade">陞級</string>
  <string name="apt_update_ok">套裝軟體清單成功更新</string>
  <string name="apt_upgrade_ok">套裝軟體已成功陞級</string>
  <string name="installing_topic">安裝已開始，請注意荧幕上出現的提示</string>
  <string name="session_closed">會話已關閉</string>
  <string name="restore_session">取消</string>
  <string name="show_help">查看幫助</string>
  <string name="service_connection_failed">無法連接到服務</string>
  <string name="about_version_label">版本</string>
  <string name="about_developers_label">開發者 &amp; 贡献者</string>
  <string name="about_libraries_label">協力廠商庫</string>
  <string name="about_source_label">源碼</string>
  <string name="support_donate_label">捐贈</string>
  <string name="support_donate_description">如果你喜歡這個app，你可以考慮請作者喝杯咖啡</string>
  <string name="about_developers">Kiva 維護\nCrixec 圖標設計\n酷安用戶 @NimaQu 贊助服務器\nQQ用戶 @My 提供免費網絡</string>
  <string name="support_donate_dialog_text">這個app是我在課餘時間製作的，一個人不僅要維護app，還要維護各種套裝軟體和服務器，如果能得到你的支持，我將更有動力繼續完善下去</string>
  <string name="support_donate_alipay">支付寶</string>
</resources>
```

`app/src/main/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <declare-styleable name="rtl_RecyclerTabLayout">
    <attr name="rtl_tabIndicatorColor" format="color"/>
    <attr name="rtl_tabIndicatorHeight" format="dimension"/>

    <attr name="rtl_tabBackground" format="reference"/>

    <attr name="rtl_tabTextAppearance" format="reference"/>
    <attr name="rtl_tabSelectedTextColor" format="color"/>

    <attr name="rtl_tabOnScreenLimit" format="integer"/>
    <attr name="rtl_tabMinWidth" format="dimension"/>
    <attr name="rtl_tabMaxWidth" format="dimension"/>

    <attr name="rtl_tabPaddingStart" format="dimension"/>
    <attr name="rtl_tabPaddingTop" format="dimension"/>
    <attr name="rtl_tabPaddingEnd" format="dimension"/>
    <attr name="rtl_tabPaddingBottom" format="dimension"/>
    <attr name="rtl_tabPadding" format="dimension"/>

    <attr name="rtl_scrollEnabled" format="boolean"/>

  </declare-styleable>
</resources>

```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <color name="colorPrimary">#607D8B</color>
  <color name="colorPrimaryDark">#455A64</color>
  <color name="colorAccent">#42a5f5</color>
  <color name="terminal_background">#ff14181c</color>
  <color name="textColor">#fefefe</color>
  <color name="textColorSecondary">#ced7db</color>

  <color name="popup_background">#7f000000</color>
  <color name="popup_split_background">#efefef</color>
  <color name="list_download_item_color_dark">#363636</color>
</resources>

```

`app/src/main/res/values/dimens.xml`:

```xml
<resources>
  <dimen name="app_bar_height">180dp</dimen>
  <dimen name="fab_margin">16dp</dimen>
  <dimen name="text_margin">16dp</dimen>
  <dimen name="preview_layout_margin_small">8dp</dimen>
  <dimen name="preview_layout_margin">32dp</dimen>
  <dimen name="preview_layout_height">32dp</dimen>
  <dimen name="preview_layout_width">32dp</dimen>
  <dimen name="eks_height">32dp</dimen>
  <dimen name="eks_height_two_line">72dp</dimen>
  <dimen name="eks_height_one_line">36dp</dimen>
  <dimen name="terminal_dialog_height">256dp</dimen>
  <dimen name="custom_editor_line_height">48dp</dimen>
  <dimen name="custom_install_icon_width">36dp</dimen>
  <dimen name="custom_install_icon_height">36dp</dimen>
  <dimen name="min_popup_height">24dp</dimen>
  <dimen name="popup_padding">4dp</dimen>
  <dimen name="md_list_item_height">48dp</dimen>
  <dimen name="recycler_tab_height">48dp</dimen>

  <dimen name="package_item_padding">16dp</dimen>
  <dimen name="color_item_padding">4dp</dimen>
</resources>

```

`app/src/main/res/values/preference_keys.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string name="key_general_bell" translatable="false">neoterm_general_bell</string>
  <string name="key_general_vibrate" translatable="false">neoterm_general_vibrate</string>
  <string name="key_generaL_backspace_map_to_esc" translatable="false">neoterm_general_backspace_map_to_esc</string>
  <string name="key_general_shell" translatable="false">neoterm_general_shell</string>
  <string name="key_general_initial_command" translatable="false">neoterm_general_initial_command</string>
  <string name="key_general_auto_completion" translatable="false">neoterm_general_auto_completion</string>
  <string name="key_general_volume_as_control" translatable="false">neoterm_general_volume_as_control</string>
  <string name="key_general_use_execve_wrapper" translatable="false">neoterm_general_use_execve_wrapper</string>
  <string name="key_general_enable_word_based_ime" translatable="false">neoterm_general_enable_word_based_ime</string>

  <string name="key_ui_fullscreen" translatable="false">neoterm_ui_fullscreen</string>
  <string name="key_ui_hide_toolbar" translatable="false">neoterm_ui_hide_toolbar</string>
  <string name="key_ui_next_tab_anim" translatable="false">neoterm_ui_next_tab_anim</string>
  <string name="key_ui_eks_weight_explicit" translatable="false">neoterm_ui_eks_weight_explicit</string>
  <string name="key_ui_eks_enabled" translatable="false">neoterm_ui_eks_enabled</string>

  <string name="key_package_source" translatable="false">neoterm_package_source</string>

  <string name="key_customization_font" translatable="false">neoterm_ui_font</string>
  <string name="key_customization_color_scheme" translatable="false">neoterm_ui_color_scheme</string>
</resources>
```

`app/src/main/res/values/shortcut_configs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
  <string translatable="false" name="id_shortcut_create_new_session">id_create_new_session</string>
</resources>
```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
  <string name="app_name">NeoTerm</string>
  <string name="copy_text">Copy</string>
  <string name="paste_text">Paste</string>
  <string name="super_paste_text">Super Paste</string>
  <string name="text_selection_more">More</string>

  <string name="toggle_tab_switcher_menu_item">Toggle Tabs</string>
  <string name="new_session">New Session</string>
  <string name="new_session_more">New Session…</string>
  <string name="new_system_session">New System Shell</string>
  <string name="service_status_text">%d session(s), %d X session(s)</string>
  <string name="service_lock_acquired">(Wake Locked)</string>
  <string name="service_acquire_lock">Acquire Lock</string>
  <string name="service_release_lock">Release Lock</string>

  <string name="setup_info">Hello, NeoTerm</string>
  <string name="setup_next">Let\'s Go!</string>
  <string name="setup_setup_method">Select your installation method</string>
  <string name="setup_online">Online Setup</string>
  <string name="setup_local">Local Zip File Setup</string>
  <string name="setup_backup">Restore from NeoTerm Backup</string>
  <string name="setup_source_parameter">Source Parameter</string>
  <string name="setup_input_source_parameter">Input source parameter…</string>
  <string name="setup_dots" translatable="false">…</string>
  <string name="setup_hint_online">URL of mirror that contains setup zip files</string>
  <string name="setup_hint_local">File path to showConfirmDialog zip files</string>
  <string name="setup_hint_backup">File path to backup file(*.neobackup)</string>
  <string name="setup_error_file_not_found">File not found</string>
  <string name="setup_error_invalid_url">Invalid URL</string>
  <string name="setup_error_no_internet">No Internet connection</string>
  <string name="setup_error_connection_failed">Failed to connect to server</string>
  <string name="setup_error_parameter_null">Setup parameter is null</string>
  <string name="setup_preparing">Preparing…</string>
  <string name="setup_confirm">Finish Setup</string>
  <string name="setup_confirm_text">Everything goes well till now, continue?</string>
  <string name="setup_reset_confirm">Reset Confirm</string>
  <string name="setup_reset_confirm_text">This operation will clear all your data! Continue?</string>

  <string name="about">About</string>
  <string name="settings">Settings</string>
  <string name="general_settings">General Settings</string>
  <string name="general_settings_desc">Bell, Vibrate, Shell, Initial Command</string>
  <string name="ui_settings">UI Settings</string>
  <string name="ui_settings_desc">FullScreen, Title Bar, Animation</string>
  <string name="package_settings">Package Settings</string>
  <string name="package_settings_desc">Source, Updates, Upgrades</string>
  <string name="customization_settings_desc">Font, ColorScheme</string>
  <string name="customization_settings">Customization</string>

  <string name="toggle_ime">Toggle Keyboard</string>
  <string name="float_up">Float Up</string>
  <string name="shell_not_found">Shell %s not found</string>
  <string name="shell_not_found_message">Would you like you install it?</string>
  <string name="fullscreen_mode_changed">FullScreen mode changed, please restart NeoTerm.</string>
  <string name="permission_denied">NeoTerm cannot get essential permissions, exiting.</string>
  <string name="error">Oops!</string>
  <string name="use_system_shell">System Shell</string>
  <string name="retry">Retry</string>
  <string name="source_changed">APT source changed, you may get it updated by executing: apt update</string>
  <string name="done">Done</string>
  <string name="install">Install</string>
  <string name="package_details">Package: %s\nVersion: %s\nDepends: %s\nInstalled Size: %s\nDescription: %s\nHome
    Page: %s
  </string>
  <string name="package_list_empty">Package list is empty, please check your source.</string>
  <string name="menu_refresh_list">Refresh</string>
  <string name="menu_update">Update and Refresh</string>
  <string name="install_font">Install Font</string>
  <string name="install_color">Install Color Scheme</string>

  <string name="crash_model">Model: %s</string>
  <string name="crash_app">App: %s</string>
  <string name="crash_stack_trace">Stack Trace</string>

  <string name="installer_message">Installing</string>
  <string name="installer_install_zsh_required">We will install oh-my-zsh and switch your login program to zsh
  </string>

  <string name="pref_general_bell">Bell</string>
  <string name="pref_general_bell_desc">Bell when receiving \'\\a\'</string>
  <string name="pref_general_vibrate">Vibrate</string>
  <string name="pref_general_vibrate_desc">Vibrate when receiving \'\\a\'</string>
  <string name="pref_general_backspace_map_to_esc">BackSpace Mapped to Esc</string>
  <string name="pref_general_backspace_map_to_esc_desc">Send esc when backspace is pressed</string>
  <string name="pref_general_shell">Login Program</string>
  <string name="pref_general_shell_desc">Which program should we use as shell when login</string>
  <string name="pref_general_initial_command">Initial Command</string>
  <string name="pref_general_initial_command_desc">Execute commands when a session is being created</string>
  <string name="pref_general_auto_completion">Auto Completion(Experimental)</string>
  <string name="pref_general_auto_completion_desc">Enable complete things when typing commands or path. This is still
    work in progress with lots of bugs to deal with
  </string>
  <string name="pref_general_volume_as_control">Use volume up and down as special keys</string>
  <string name="pref_general_volume_as_control_desc">Volume Down as Ctrl\nVolume Up as FN</string>
  <string name="pref_general_use_execve_wrapper">Use execve() wrapper</string>
  <string name="pref_general_use_execve_wrapper_desc">Hook execve() to avoid incorrect shebang</string>
  <string name="pref_general_enable_word_based_ime">Enable word based IME</string>
  <string name="pref_general_enable_word_based_ime_desc">Word based or char based IME</string>
  <string name="pref_ui_fullscreen">Full Screen</string>
  <string name="pref_ui_hide_toolbar">Hide Toolbar</string>
  <string name="pref_ui_hide_toolbar_desc">Hide toolbar when keyboard is showing</string>
  <string name="pref_ui_close_tab_anim_next_tab">Next tab animation</string>
  <string name="pref_ui_close_tab_anim_next_tab_desc">Switch to the next tab instead of the previous tab when closing
    tab
  </string>
  <string name="pref_ui_eks_weight_explicit">Use explicit weight for ExtraKeysView</string>
  <string name="pref_ui_eks_weight_explicit_desc">If ExtraKeysView shows incorrectly, please enable this</string>
  <string name="pref_ui_eks_enabled">Show extra keys</string>
  <string name="pref_ui_eks_enabled_desc">Some useful keys like arrow, esc, tab, etc.</string>
  <string name="pref_customization_font">Font</string>
  <string name="pref_customization_color_scheme">Color Scheme</string>
  <string name="pref_customization_eks">Extra Keys</string>
  <string name="pref_package_source">Source</string>

  <string name="exit">Exit</string>
  <string name="term_here">Term Here</string>
  <string name="user_script">User Script</string>
  <string name="command_shortcut">Command Shortcut</string>
  <string name="no_user_script_found">No user script found (Did you forget to set executable permissions?)</string>
  <string name="no_files_selected">No files selected\n\n(raw Intent: %s)</string>
  <string name="unsupported_term_here">Unsupported term here\n\n(raw Intent: %s)</string>
  <string name="files_to_handle">Files to Handle</string>
  <string name="available_user_scripts">Available User Scripts</string>
  <string name="confirm_remove_file_from_list">Remove file from list?</string>
  <string name="confirm_remove">Remove?</string>
  <string name="command_shortcut_display_title">Title</string>
  <string name="command_shortcut_command">Command</string>
  <string name="no_command_extra">No command provided, did you put extras?</string>
  <string name="command_display_title_cannot_be_null">Display title cannot be null</string>
  <string name="menu_upgrade">Upgrade</string>
  <string name="apt_update_ok">Package list successfully updated</string>
  <string name="apt_upgrade_ok">Package successfully upgraded</string>
  <string name="installing_topic">Installation started. Please pay attention to the prompt that appears on the
    screen
  </string>
  <string name="session_closed">Session was closed</string>
  <string name="restore_session">Cancel</string>
  <string name="show_help">Show Help</string>
  <string name="service_connection_failed">Failed to connect to service</string>
  <string name="about_version_label">Version</string>
  <string name="about_developers_label">Developers &amp; Contributors</string>
  <string name="about_libraries_label">Libraries</string>
  <string name="about_source_label">Source Code</string>
  <string name="about_reset_label">Reset App</string>
  <string name="about_reset_label_desc">Clear all files except user home directory</string>
  <string name="support_donate_label">Donate</string>
  <string name="support_donate_description">If you like this app, you can offer developers a cup of coffee</string>
  <string name="support_donate_dialog_text">This app is made in my spare time. Not only me needs to develop app, but
    also maintains various software packages and servers. If you can support me, I will be more motivated to improve
    this app.
  </string>
  <string name="support_donate_alipay">Alipay</string>
  <string name="about_developers">Kiva for Maintaining\nCrixec for Icon Design\nCoolApk User @NimaQu for providing
    server\nQQ User @My for providing free network
  </string>
  <string name="new_color_scheme">New Color Scheme</string>
  <string name="faq">FAQ</string>
  <string name="new_source">New</string>
  <string name="process_exit_info">Process completed</string>
  <string name="process_exit_code">code %d</string>
  <string name="process_exit_signal">signal %d</string>
  <string name="process_exit_prompt">press Enter</string>
  <string name="process_exit_prompt_press_back">Press Back</string>
  <string name="save_color_info">Enter new color scheme name</string>
  <string name="save_color_scheme_name_template">NewColorScheme</string>
  <string name="save_color">Save color scheme</string>
  <string name="discard_changes">Discard all changes?</string>
  <string name="save">Save</string>
  <string name="select_new_value">Select</string>
  <string name="input_new_value">Enter new color</string>
  <string name="toggle_eks">Toggle extra keys</string>
  <string name="new_x_session">New X Session</string>
  <string name="new_session_with_profile">New Session With Profile</string>
  <string name="no_profile_available">No profile available</string>
  <string name="no_file_picker">No file picker found</string>
  <string name="input_new_source_url">Enter new URL</string>
  <string name="input_new_source_repo">Enter new Repo</string>
  <string name="error_new_source_url">URL cannot be empty</string>
  <string name="error_new_source_repo">Repo cannot be empty</string>
  <string name="sorry_for_development">This feature is still under development so it is only available on DEBUG
    builds.\n
  </string>
  <string name="dangerous_zone">Dangerous Zone</string>
  <string name="reset_app_warning">You will have to re-setup later, confirm?</string>

  <string name="default_source_url" translatable="false">https://raw.githubusercontent.com/NeoTerm/NeoTerm-repo/main
  </string>

  <string-array name="pref_general_shell_entries" translatable="false">
    <item>sh</item>
    <item>zsh</item>
    <item>bash</item>
    <item>fish</item>
  </string-array>

  <string-array name="pref_package_source_values" translatable="false">
    <item>@string/default_source_url</item>
  </string-array>

  <string-array name="color_item_names">
    <item>Background color</item>
    <item>Foreground color</item>
    <item>Cursor color</item>
    <item>Dim black</item>
    <item>Dim red</item>
    <item>Dim green</item>
    <item>Dim yellow</item>
    <item>Dim blue</item>
    <item>Dim magenta</item>
    <item>Dim cyan</item>
    <item>Dim white</item>
    <item>Bright black</item>
    <item>Bright red</item>
    <item>Bright green</item>
    <item>Bright yellow</item>
    <item>Bright blue</item>
    <item>Bright magenta</item>
    <item>Bright cyan</item>
    <item>Bright white</item>
  </string-array>

  <string-array name="custom_preview_script_colors">
    <item>Hello NeoTerm\\n</item>
    <item>"\\e[30m Dim black \\e[0m\\n"</item>
    <item>"\\e[31m Dim red \\e[0m\\n"</item>
    <item>"\\e[32m Dim green \\e[0m\\n"</item>
    <item>"\\e[33m Dim yellow \\e[0m\\n"</item>
    <item>"\\e[34m Dim blue \\e[0m\\n"</item>
    <item>"\\e[35m Dim magenta \\e[0m\\n"</item>
    <item>"\\e[36m Dim cyan \\e[0m\\n"</item>
    <item>"\\e[37m Dim white \\e[0m\\n"</item>
    <item>"\\e[1;30m Bright black \\e[0m\\n"</item>
    <item>"\\e[1;31m Bright red \\e[0m\\n"</item>
    <item>"\\e[1;32m Bright green \\e[0m\\n"</item>
    <item>"\\e[1;33m Bright yellow \\e[0m\\n"</item>
    <item>"\\e[1;34m Bright blue \\e[0m\\n"</item>
    <item>"\\e[1;35m Bright magenta\\e[0m\\n"</item>
    <item>"\\e[1;36m Bright cyan \\e[0m\\n"</item>
    <item>"\\e[1;37m Bright white \\e[0m\\n"</item>
  </string-array>

</resources>

```

`app/src/main/res/values/styles.xml`:

```xml
<resources>

  <!-- Base application theme. -->
  <style name="AppTheme" parent="Theme.AppCompat.Light.DarkActionBar">
    <item name="colorAccent">@color/colorAccent</item>
    <item name="colorPrimary">@color/colorPrimary</item>
    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
    <item name="windowActionModeOverlay">true</item>
  </style>

  <style name="AppTheme.Dark" parent="Theme.AppCompat">
    <item name="colorAccent">@color/colorAccent</item>
    <item name="windowActionModeOverlay">true</item>
    <item name="colorPrimary">@color/colorPrimary</item>
    <item name="colorPrimaryDark">@color/colorPrimaryDark</item>
  </style>

  <style name="AppTheme.NoActionBar" parent="@style/AppTheme">
    <item name="windowActionBar">false</item>
    <item name="windowNoTitle">true</item>
  </style>

  <style name="AppTheme.NoActionBar.Dark" parent="@style/AppTheme.Dark">
    <item name="windowActionBar">false</item>
    <item name="windowNoTitle">true</item>
  </style>

  <style name="AppTheme.AppBarOverlay" parent="ThemeOverlay.AppCompat.Dark.ActionBar"/>

  <style name="AppTheme.PopupOverlay" parent="ThemeOverlay.AppCompat.Light"/>

  <style name="rtl_RecyclerTabLayout">
    <item name="rtl_tabMinWidth">72dp</item>
    <item name="rtl_tabMaxWidth">264dp</item>
    <item name="rtl_tabIndicatorColor">?attr/colorAccent</item>
    <item name="rtl_tabIndicatorHeight">2dp</item>
    <item name="rtl_tabPaddingStart">12dp</item>
    <item name="rtl_tabPaddingEnd">12dp</item>
    <item name="rtl_tabBackground">?attr/selectableItemBackground</item>
    <item name="rtl_tabTextAppearance">@style/rtl_RecyclerTabLayout.Tab</item>
    <item name="rtl_tabSelectedTextColor">?android:textColorPrimary</item>
  </style>

  <style name="rtl_RecyclerTabLayout.Tab">
    <item name="android:textSize">14sp</item>
    <item name="android:textColor">?android:textColorSecondary</item>
    <item name="textAllCaps">true</item>
  </style>

</resources>

```

`app/src/main/res/xml/app_shortcuts.xml`:

```xml
<shortcuts xmlns:tools="http://schemas.android.com/tools"
           xmlns:android="http://schemas.android.com/apk/res/android">
  <shortcut
    android:shortcutId="new_session"
    android:enabled="true"
    android:icon="@drawable/ic_new_session"
    android:shortcutShortLabel="@string/new_session"
    tools:targetApi="n_mr1">
    <intent
      android:action="android.intent.action.RUN"
      android:targetPackage="io.neoterm"
      android:targetClass="io.neoterm.ui.term.NeoTermActivity"/>
  </shortcut>
</shortcuts>

```

`app/src/main/res/xml/backup_config.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
  <!-- See https://developer.android.com/training/backup/autosyncapi.html -->
  <include domain="file" path="home/.neoterm"/>
</full-backup-content>
```

`app/src/main/res/xml/setting_general.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
  <ListPreference
    android:defaultValue="bash"
    android:entries="@array/pref_general_shell_entries"
    android:entryValues="@array/pref_general_shell_entries"
    android:key="@string/key_general_shell"
    android:summary="@string/pref_general_shell_desc"
    android:title="@string/pref_general_shell"/>

  <EditTextPreference
    android:key="@string/key_general_initial_command"
    android:summary="@string/pref_general_initial_command_desc"
    android:title="@string/pref_general_initial_command"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_general_bell"
    android:summary="@string/pref_general_bell_desc"
    android:title="@string/pref_general_bell"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_general_vibrate"
    android:summary="@string/pref_general_vibrate_desc"
    android:title="@string/pref_general_vibrate"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_generaL_backspace_map_to_esc"
    android:summary="@string/pref_general_backspace_map_to_esc_desc"
    android:title="@string/pref_general_backspace_map_to_esc"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_general_volume_as_control"
    android:summary="@string/pref_general_volume_as_control_desc"
    android:title="@string/pref_general_volume_as_control"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_general_use_execve_wrapper"
    android:summary="@string/pref_general_use_execve_wrapper_desc"
    android:title="@string/pref_general_use_execve_wrapper"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_general_enable_word_based_ime"
    android:summary="@string/pref_general_enable_word_based_ime_desc"
    android:title="@string/pref_general_enable_word_based_ime"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_general_auto_completion"
    android:summary="@string/pref_general_auto_completion_desc"
    android:title="@string/pref_general_auto_completion"/>

</PreferenceScreen>
```

`app/src/main/res/xml/settings_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">

  <Preference
    android:icon="@drawable/ic_general_white_36dp"
    android:summary="@string/general_settings_desc"
    android:title="@string/general_settings">
    <intent
      android:targetClass="io.neoterm.ui.settings.GeneralSettingsActivity"
      android:targetPackage="io.neoterm"/>
  </Preference>

  <Preference
    android:icon="@drawable/ic_ui_white_36dp"
    android:summary="@string/ui_settings_desc"
    android:title="@string/ui_settings">
    <intent
      android:targetClass="io.neoterm.ui.settings.UISettingsActivity"
      android:targetPackage="io.neoterm"/>
  </Preference>

  <Preference
    android:icon="@drawable/ic_customization_white_36dp"
    android:summary="@string/customization_settings_desc"
    android:title="@string/customization_settings">
    <intent
      android:targetClass="io.neoterm.ui.customize.CustomizeActivity"
      android:targetPackage="io.neoterm"/>
  </Preference>

  <Preference
    android:icon="@drawable/ic_apps_white_36dp"
    android:summary="@string/package_settings_desc"
    android:title="@string/package_settings">
    <intent
      android:targetClass="io.neoterm.ui.pm.PackageManagerActivity"
      android:targetPackage="io.neoterm"/>
  </Preference>

  <Preference
    android:icon="@drawable/ic_info_white_36dp"
    android:title="@string/about">
    <intent
      android:targetClass="io.neoterm.ui.other.AboutActivity"
      android:targetPackage="io.neoterm"/>
  </Preference>

</PreferenceScreen>

```

`app/src/main/res/xml/settings_ui.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<PreferenceScreen xmlns:android="http://schemas.android.com/apk/res/android">
  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_ui_fullscreen"
    android:title="@string/pref_ui_fullscreen"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_ui_hide_toolbar"
    android:summary="@string/pref_ui_hide_toolbar_desc"
    android:title="@string/pref_ui_hide_toolbar"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:key="@string/key_ui_next_tab_anim"
    android:summary="@string/pref_ui_close_tab_anim_next_tab_desc"
    android:title="@string/pref_ui_close_tab_anim_next_tab"/>

  <CheckBoxPreference
    android:defaultValue="true"
    android:key="@string/key_ui_eks_enabled"
    android:title="@string/pref_ui_eks_enabled"
    android:summary="@string/pref_ui_eks_enabled_desc"/>

  <CheckBoxPreference
    android:defaultValue="false"
    android:dependency="@string/key_ui_eks_enabled"
    android:key="@string/key_ui_eks_weight_explicit"
    android:summary="@string/pref_ui_eks_weight_explicit_desc"
    android:title="@string/pref_ui_eks_weight_explicit"/>
</PreferenceScreen>
```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
  ext.kotlin_version = '1.4.32'
  ext.android = [
    KOTLIN_VERSION     : '1.4.32',
    MIN_SDK_VERSION    : 26,
    COMPILE_SDK_VERSION: 28,
    TARGET_SDK_VERSION : 28,
    JUNIT_VERSION      : "4.12"
  ]

  ext.deps = [
    "annotations"         : "androidx.annotation:annotation:1.0.0",
    "appcompat-v7"        : "androidx.appcompat:appcompat:1.0.0",
    "design"              : "com.android.support:design:${ext.android.ANDROID_SUPPORT_VERSION}",
    "cardview-v7"         : "com.android.support:cardview-v7:${ext.android.ANDROID_SUPPORT_VERSION}",
    "kotlin-stdlib"       : "org.jetbrains.kotlin:kotlin-stdlib:${ext.android.KOTLIN_VERSION}",
    "kotlin-gradle-plugin": "org.jetbrains.kotlin:kotlin-gradle-plugin:${ext.android.KOTLIN_VERSION}",
    "junit"               : "junit:junit:${ext.android.JUNIT_VERSION}"
  ]

  repositories {
    maven { url 'https://dl.google.com/dl/android/maven2/' }
    jcenter()
    google()
  }

  dependencies {
    classpath 'com.android.tools.build:gradle:4.1.3'
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
    classpath rootProject.ext.deps["kotlin-gradle-plugin"]

    classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.2'
    classpath 'com.github.dcendents:android-maven-gradle-plugin:1.5'

    // NOTE: Do not place your application dependencies here; they belong
    // in the individual module build.gradle files
  }
}

allprojects {
  repositories {
    jcenter()
    maven { url 'https://dl.google.com/dl/android/maven2/' }
    mavenCentral()
    maven { url "https://jitpack.io" }
    google()
  }
}

task clean(type: Delete) {
  delete rootProject.buildDir
}

```

`chrome-tabs/build.gradle`:

```gradle
apply plugin: 'com.android.library'

android {
  compileSdkVersion rootProject.ext.android.COMPILE_SDK_VERSION

  defaultConfig {
    minSdkVersion rootProject.ext.android.MIN_SDK_VERSION
    targetSdkVersion rootProject.ext.android.TARGET_SDK_VERSION
    versionCode 1
    versionName "1.0"
  }
  buildTypes {
    release {
      minifyEnabled true
    }
  }
}

dependencies {
  api 'com.github.michael-rapp:android-util:1.15.0'
  implementation rootProject.ext.deps["annotations"]
  testImplementation rootProject.ext.deps["junit"]

  implementation 'androidx.appcompat:appcompat:1.2.0'
  implementation 'androidx.appcompat:appcompat-resources:1.2.0'
}

```

`chrome-tabs/gradle.properties`:

```properties
POM_NAME=ChromeLikeTabSwitcher
POM_ARTIFACT_ID=chrome-like-tab-switcher
POM_PACKAGING=aar
```

`chrome-tabs/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<manifest package="de.mrapp.android.tabswitcher"/>
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/Animation.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import android.view.animation.Interpolator;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import static de.mrapp.android.util.Condition.ensureAtLeast;

/**
 * An animation, which can be used to add or remove tabs to/from a {@link TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public abstract class Animation {

  /**
   * An abstract base class for all builders, which allow to configure and create instances of the
   * class {@link Animation}.
   *
   * @param <AnimationType> The type of the animations, which are created by the builder
   * @param <BuilderType>   The type of the builder
   */
  protected static abstract class Builder<AnimationType, BuilderType> {

    /**
     * The duration of the animations, which are created by the builder.
     */
    protected long duration;

    /**
     * The interpolator, which is used by the animations, which are created by the builder.
     */
    protected Interpolator interpolator;

    /**
     * Returns a reference to the builder.
     *
     * @return A reference to the builder, casted to the generic type BuilderType. The reference
     * may not be null
     */
    @NonNull
    @SuppressWarnings("unchecked")
    protected final BuilderType self() {
      return (BuilderType) this;
    }

    /**
     * Creates a new builder, which allows to configure and create instances of the class {@link
     * Animation}.
     */
    public Builder() {
      setDuration(-1);
      setInterpolator(null);
    }

    /**
     * Creates and returns the animation.
     *
     * @return The animation, which has been created, as an instance of the generic type
     * AnimationType. The animation may not be null
     */
    @NonNull
    public abstract AnimationType create();

    /**
     * Sets the duration of the animations, which are created by the builder.
     *
     * @param duration The duration, which should be set, in milliseconds as a {@link Long} value or -1,
     *                 if the default duration should be used
     * @return The builder, this method has be called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public final BuilderType setDuration(final long duration) {
      ensureAtLeast(duration, -1, "The duration must be at least -1");
      this.duration = duration;
      return self();
    }

    /**
     * Sets the interpolator, which should be used by the animations, which are created by the
     * builder.
     *
     * @param interpolator The interpolator, which should be set, as an instance of the type {@link
     *                     Interpolator} or null, if the default interpolator should be used
     * @return The builder, this method has be called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public final BuilderType setInterpolator(@Nullable final Interpolator interpolator) {
      this.interpolator = interpolator;
      return self();
    }

  }

  /**
   * The duration of the animation in milliseconds.
   */
  private final long duration;

  /**
   * The interpolator, which is used by the animation.
   */
  private final Interpolator interpolator;

  /**
   * Creates a new animation.
   *
   * @param duration     The duration of the animation in milliseconds as a {@link Long} value or -1, if the
   *                     default duration should be used
   * @param interpolator The interpolator, which should be used by the animation, as an instance of the type
   *                     {@link Interpolator} or null, if the default interpolator should be used
   */
  protected Animation(final long duration, @Nullable final Interpolator interpolator) {
    ensureAtLeast(duration, -1, "The duration must be at least -1");
    this.duration = duration;
    this.interpolator = interpolator;
  }

  /**
   * Returns the duration of the animation.
   *
   * @return The duration of the animation in milliseconds as a {@link Long} value or -1, if the
   * default duration is used
   */
  public final long getDuration() {
    return duration;
  }

  /**
   * Returns the interpolator, which is used by the animation.
   *
   * @return The interpolator, which is used by the animation, as an instance of the type {@link
   * Interpolator} or null, if the default interpolator is used
   */
  @Nullable
  public final Interpolator getInterpolator() {
    return interpolator;
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/Layout.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

/**
 * Contains all possible layouts of a {@link TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public enum Layout {

  /**
   * The layout, which is used on smartphones and phablet devices, when in portrait mode.
   */
  PHONE_PORTRAIT,

  /**
   * The layout, which is used on smartphones and phablet devices, when in landscape mode.
   */
  PHONE_LANDSCAPE,

  /**
   * The layout, which is used on tablets.
   */
  TABLET

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/LayoutPolicy.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

/**
 * Contains all possible layout policies of a {@link TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public enum LayoutPolicy {

  /**
   * If the layout should automatically adapted, depending on whether the device is a smartphone
   * or tablet.
   */
  AUTO(0),

  /**
   * If the smartphone layout should be used, regardless of the device.
   */
  PHONE(1),

  /**
   * If the tablet layout should be used, regardless of the device.
   */
  TABLET(2);

  /**
   * The value of the layout policy.
   */
  private int value;

  /**
   * Creates a new layout policy.
   *
   * @param value The value of the layout policy as an {@link Integer} value
   */
  LayoutPolicy(final int value) {
    this.value = value;
  }

  /**
   * Returns the value of the layout policy.
   *
   * @return The value of the layout policy as an {@link Integer} value
   */
  public final int getValue() {
    return value;
  }

  /**
   * Returns the layout policy, which corresponds to a specific value.
   *
   * @param value The value of the layout policy, which should be returned, as an {@link Integer}
   *              value
   * @return The layout policy, which corresponds to the given value, as a value of the enum
   * {@link LayoutPolicy}
   */
  public static LayoutPolicy fromValue(final int value) {
    for (LayoutPolicy layoutPolicy : values()) {
      if (layoutPolicy.getValue() == value) {
        return layoutPolicy;
      }
    }

    throw new IllegalArgumentException("Invalid enum value: " + value);
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/PeekAnimation.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import android.view.animation.Interpolator;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

/**
 * A peek animation, which animates the size of a tab starting at a specific position in order to
 * show the tab for a short time at the end of a {@link TabSwitcher}. Peek animations can be used to
 * add tabs while the tab switcher is not shown and when using the smartphone layout. They are meant
 * to be used when adding a tab without selecting it and enable the user to peek at the added tab
 * for a short moment.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class PeekAnimation extends Animation {

  /**
   * A builder, which allows to configure and create instances of the class {@link
   * PeekAnimation}.
   */
  public static class Builder extends Animation.Builder<PeekAnimation, Builder> {

    /**
     * The horizontal position, the animations, which are created by the builder, start at.
     */
    private float x;

    /**
     * The vertical position, the animations, which are created by the builder, start at.
     */
    private float y;

    /**
     * Creates a new builder, which allows to configure and create instances of the class {@link
     * PeekAnimation}.
     */
    public Builder() {
      setX(0);
      setY(0);
    }

    /**
     * Sets the horizontal position, the animations, which are created by the builder, should
     * start at.
     *
     * @param x The horizontal position, which should be set, in pixels as a {@link Float} value
     * @return The builder, this method has be called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public final Builder setX(final float x) {
      this.x = x;
      return self();
    }

    /**
     * Sets the vertical position, the animations, which are created by the builder, should
     * start at.
     *
     * @param y The vertical position, which should be set, in pixels as a {@link Float} value
     * @return The builder, this method has be called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public final Builder setY(final float y) {
      this.y = y;
      return self();
    }

    @NonNull
    @Override
    public final PeekAnimation create() {
      return new PeekAnimation(duration, interpolator, x, y);
    }

  }

  /**
   * The horizontal position, the animation starts at.
   */
  private final float x;

  /**
   * The vertical position, the animation starts at.
   */
  private final float y;

  /**
   * Creates a new reveal animation.
   *
   * @param x The horizontal position, the animation should start at, in pixels as a {@link Float}
   *          value
   * @param y The vertical position, the animation should start at, in pixels as a {@link Float}
   *          value
   */
  private PeekAnimation(final long duration, @Nullable final Interpolator interpolator,
                        final float x, final float y) {
    super(duration, interpolator);
    this.x = x;
    this.y = y;
  }

  /**
   * Returns the horizontal position, the animation starts at.
   *
   * @return The horizontal position, the animation starts at, in pixels as a {@link Float} value
   */
  public final float getX() {
    return x;
  }

  /**
   * Returns the vertical position, the animation starts at.
   *
   * @return The vertical position, the animation starts at, in pixels as a {@link Float} value
   */
  public final float getY() {
    return y;
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/RevealAnimation.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import android.view.animation.Interpolator;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

/**
 * A reveal animation, which animates the size of a tab starting at a specific position. Reveal
 * animations can be used to add tabs to a {@link TabSwitcher} when using the smartphone layout.
 * Tabs, which have been added by using a reveal animation, are selected automatically.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class RevealAnimation extends Animation {

  /**
   * A builder, which allows to configure and create instances of the class {@link
   * RevealAnimation}.
   */
  public static class Builder extends Animation.Builder<RevealAnimation, Builder> {

    /**
     * The horizontal position, the animations, which are created by the builder, start at.
     */
    private float x;

    /**
     * The vertical position, the animations, which are created by the builder, start at.
     */
    private float y;

    /**
     * Creates a new builder, which allows to configure and create instances of the class {@link
     * RevealAnimation}.
     */
    public Builder() {
      setX(0);
      setY(0);
    }

    /**
     * Sets the horizontal position, the animations, which are created by the builder, should
     * start at.
     *
     * @param x The horizontal position, which should be set, in pixels as a {@link Float} value
     * @return The builder, this method has be called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public final Builder setX(final float x) {
      this.x = x;
      return self();
    }

    /**
     * Sets the vertical position, the animations, which are created by the builder, should
     * start at.
     *
     * @param y The vertical position, which should be set, in pixels as a {@link Float} value
     * @return The builder, this method has be called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public final Builder setY(final float y) {
      this.y = y;
      return self();
    }

    @NonNull
    @Override
    public final RevealAnimation create() {
      return new RevealAnimation(duration, interpolator, x, y);
    }

  }

  /**
   * The horizontal position, the animation starts at.
   */
  private final float x;

  /**
   * The vertical position, the animation starts at.
   */
  private final float y;

  /**
   * Creates a new reveal animation.
   *
   * @param x The horizontal position, the animation should start at, in pixels as a {@link Float}
   *          value
   * @param y The vertical position, the animation should start at, in pixels as a {@link Float}
   *          value
   */
  private RevealAnimation(final long duration, @Nullable final Interpolator interpolator,
                          final float x, final float y) {
    super(duration, interpolator);
    this.x = x;
    this.y = y;
  }

  /**
   * Returns the horizontal position, the animation starts at.
   *
   * @return The horizontal position, the animation starts at, in pixels as a {@link Float} value
   */
  public final float getX() {
    return x;
  }

  /**
   * Returns the vertical position, the animation starts at.
   *
   * @return The vertical position, the animation starts at, in pixels as a {@link Float} value
   */
  public final float getY() {
    return y;
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/SwipeAnimation.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import android.view.animation.Interpolator;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A swipe animation, which moves tabs on the orthogonal axis, while animating their size and
 * opacity at the same time. Swipe animations can be used to add or remove tabs to a {@link
 * TabSwitcher} when using the smartphone layout.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class SwipeAnimation extends Animation {

  /**
   * Contains all possible directions of a swipe animation.
   */
  public enum SwipeDirection {

    /**
     * When the tab should be swiped in/out from/to the left, respectively the top, when
     * dragging horizontally.
     */
    LEFT,

    /**
     * When the tab should be swiped in/out from/to the right, respectively the bottom, when
     * dragging horizontally.
     */
    RIGHT

  }

  /**
   * A builder, which allows to configure and create instances of the class {@link
   * SwipeAnimation}.
   */
  public static class Builder extends Animation.Builder<SwipeAnimation, Builder> {

    /**
     * The direction of the animations, which are created by the builder.
     */
    private SwipeDirection direction;

    /**
     * Creates a new builder, which allows to configure and create instances of the class {@link
     * SwipeAnimation}.
     */
    public Builder() {
      setDirection(SwipeDirection.RIGHT);
    }

    /**
     * Sets the direction of the animations, which are created by the builder.
     *
     * @param direction The direction, which should be set, as a value of the enum {@link
     *                  SwipeDirection}. The direction may either be {@link SwipeDirection#LEFT} or
     *                  {@link SwipeDirection#RIGHT}
     * @return The builder, this method has be called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public final Builder setDirection(@NonNull final SwipeDirection direction) {
      ensureNotNull(direction, "The direction may not be null");
      this.direction = direction;
      return self();
    }

    @NonNull
    @Override
    public final SwipeAnimation create() {
      return new SwipeAnimation(duration, interpolator, direction);
    }

  }

  /**
   * The direction of the swipe animation.
   */
  private final SwipeDirection direction;

  /**
   * Creates a new swipe animation.
   *
   * @param duration     The duration of the animation in milliseconds as a {@link Long} value or -1, if the
   *                     default duration should be used
   * @param interpolator The interpolator, which should be used by the animation, as an instance of the type
   *                     {@link Interpolator} or null, if the default interpolator should be used
   * @param direction    The direction of the swipe animation as a value of the enum {@link SwipeDirection}.
   *                     The direction may not be null
   */
  private SwipeAnimation(final long duration, @Nullable final Interpolator interpolator,
                         @NonNull final SwipeDirection direction) {
    super(duration, interpolator);
    ensureNotNull(direction, "The direction may not be null");
    this.direction = direction;
  }

  /**
   * Returns the direction of the swipe animation.
   *
   * @return The direction of the swipe animation as a value of the enum {@link SwipeDirection}.
   * The direction may not be null
   */
  @NonNull
  public final SwipeDirection getDirection() {
    return direction;
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/Tab.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.text.TextUtils;
import androidx.annotation.*;
import androidx.core.content.ContextCompat;

import java.util.LinkedHashSet;
import java.util.Set;

import static de.mrapp.android.util.Condition.ensureNotEmpty;
import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A tab, which can be added to a {@link TabSwitcher} widget. It has a title, as well as an optional
 * icon. Furthermore, it is possible to set a custom color and to specify, whether the tab should be
 * closeable, or not.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class Tab implements Parcelable {

  /**
   * A creator, which allows to create instances of the class {@link Tab} from parcels.
   */
  public static final Creator<Tab> CREATOR = new Creator<Tab>() {

    @Override
    public Tab createFromParcel(final Parcel source) {
      return new Tab(source);
    }

    @Override
    public Tab[] newArray(final int size) {
      return new Tab[size];
    }

  };

  /**
   * Defines the interface, a class, which should be notified, when a tab's properties have been
   * changed, must implement.
   */
  public interface Callback {

    /**
     * The method, which is invoked, when the tab's title has been changed.
     *
     * @param tab The observed tab as an instance of the class {@link Tab}. The tab may not be
     *            null
     */
    void onTitleChanged(@NonNull Tab tab);

    /**
     * The method, which is invoked, when the tab's icon has been changed.
     *
     * @param tab The observed tab as an instance of the class {@link Tab}. The tab may not be
     *            null
     */
    void onIconChanged(@NonNull Tab tab);

    /**
     * The method, which is invoked, when it has been changed, whether the tab is closeable, or
     * not.
     *
     * @param tab The observed tab as an instance of the class {@link Tab}. The tab may not be
     *            null
     */
    void onCloseableChanged(@NonNull Tab tab);

    /**
     * The method, which is invoked, when the icon of the tab's close button has been changed.
     *
     * @param tab The observed tab as an instance of the class {@link Tab}. The tab may not be
     *            null
     */
    void onCloseButtonIconChanged(@NonNull Tab tab);

    /**
     * The method, which is invoked, when the tab's background color has been changed.
     *
     * @param tab The observed tab as an instance of the class {@link Tab}. The tab may not be
     *            null
     */
    void onBackgroundColorChanged(@NonNull Tab tab);

    /**
     * The method, which is invoked, when the text color of the tab's title has been changed.
     *
     * @param tab The observed tab as an instance of the class {@link Tab}. The tab may not be
     *            null
     */
    void onTitleTextColorChanged(@NonNull Tab tab);

  }

  /**
   * A set, which contains the callbacks, which have been registered to be notified, when the
   * tab's properties have been changed.
   */
  private final Set<Callback> callbacks = new LinkedHashSet<>();

  /**
   * The tab's title.
   */
  private CharSequence title;

  /**
   * The resource id of the tab's icon.
   */
  private int iconId;

  /**
   * The tab's icon as a bitmap.
   */
  private Bitmap iconBitmap;

  /**
   * True, if the tab is closeable, false otherwise.
   */
  private boolean closeable;

  /**
   * The resource id of the icon of the tab's close button.
   */
  private int closeButtonIconId;

  /**
   * The bitmap of the icon of the tab's close button.
   */
  private Bitmap closeButtonIconBitmap;

  /**
   * The background color of the tab.
   */
  private ColorStateList backgroundColor;

  /**
   * The text color of the tab's title.
   */
  private ColorStateList titleTextColor;

  /**
   * Optional parameters, which are associated with the tab.
   */
  private Bundle parameters;

  /**
   * Notifies all callbacks, that the tab's title has been changed.
   */
  private void notifyOnTitleChanged() {
    for (Callback callback : callbacks) {
      callback.onTitleChanged(this);
    }
  }

  /**
   * Notifies all callbacks, that the tab's icon has been changed.
   */
  private void notifyOnIconChanged() {
    for (Callback callback : callbacks) {
      callback.onIconChanged(this);
    }
  }

  /**
   * Notifies all callbacks, that it has been changed, whether the tab is closeable, or not.
   */
  private void notifyOnCloseableChanged() {
    for (Callback callback : callbacks) {
      callback.onCloseableChanged(this);
    }
  }

  /**
   * Notifies all callbacks, that the icon of the tab's close button has been changed.
   */
  private void notifyOnCloseButtonIconChanged() {
    for (Callback callback : callbacks) {
      callback.onCloseButtonIconChanged(this);
    }
  }

  /**
   * Notifies all callbacks, that the background color of the tab has been changed.
   */
  private void notifyOnBackgroundColorChanged() {
    for (Callback callback : callbacks) {
      callback.onBackgroundColorChanged(this);
    }
  }

  /**
   * Notifies all callbacks, that the text color of the tab has been changed.
   */
  private void notifyOnTitleTextColorChanged() {
    for (Callback callback : callbacks) {
      callback.onTitleTextColorChanged(this);
    }
  }

  /**
   * Creates a new tab, which can be added to a {@link TabSwitcher} widget.
   *
   * @param source The parcel, the tab should be created from, as an instance of the class {@link
   *               Parcel}. The parcel may not be null
   */
  protected Tab(@NonNull final Parcel source) {
    this.title = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(source);
    this.iconId = source.readInt();
    this.iconBitmap = source.readParcelable(getClass().getClassLoader());
    this.closeable = source.readInt() > 0;
    this.closeButtonIconId = source.readInt();
    this.closeButtonIconBitmap = source.readParcelable(getClass().getClassLoader());
    this.backgroundColor = source.readParcelable(getClass().getClassLoader());
    this.titleTextColor = source.readParcelable(getClass().getClassLoader());
    this.parameters = source.readBundle(getClass().getClassLoader());
  }

  /**
   * Creates a new tab, which can be added to a {@link TabSwitcher} widget.
   *
   * @param title The tab's title as an instance of the type {@link CharSequence}. The title may not be
   *              neither be null, nor empty
   */
  public Tab(@NonNull final CharSequence title) {
    setTitle(title);
    this.closeable = true;
    this.closeButtonIconId = -1;
    this.closeButtonIconBitmap = null;
    this.iconId = -1;
    this.iconBitmap = null;
    this.backgroundColor = null;
    this.titleTextColor = null;
    this.parameters = null;
  }

  /**
   * Creates a new tab, which can be added to a {@link TabSwitcher} widget.
   *
   * @param context    The context, which should be used, as an instance of the class {@link Context}. The
   *                   context may not be null
   * @param resourceId The resource id of the tab's title as an {@link Integer} value. The resource id must
   *                   correspond to a valid string resource
   */
  public Tab(@NonNull final Context context, @StringRes final int resourceId) {
    this(context.getString(resourceId));
  }

  /**
   * Returns the tab's title.
   *
   * @return The tab's title as an instance of the type {@link CharSequence}. The title may
   * neither be null, nor empty
   */
  @NonNull
  public final CharSequence getTitle() {
    return title;
  }

  /**
   * Sets the tab's title.
   *
   * @param title The title, which should be set, as an instance of the type {@link CharSequence}. The
   *              title may neither be null, nor empty
   */
  public final void setTitle(@NonNull final CharSequence title) {
    ensureNotNull(title, "The title may not be null");
    ensureNotEmpty(title, "The title may not be empty");
    this.title = title;
    notifyOnTitleChanged();
  }

  /**
   * Sets the tab's title.
   *
   * @param context    The context, which should be used, as an instance of the class {@link Context}. The
   *                   context may not be null
   * @param resourceId The resource id of the title, which should be set, as an {@link Integer} value. The
   *                   resource id must correspond to a valid string resource
   */
  public final void setTitle(@NonNull final Context context, @StringRes final int resourceId) {
    setTitle(context.getText(resourceId));
  }

  /**
   * Returns the tab's icon.
   *
   * @param context The context, which should be used, as an instance of the class {@link Context}. The
   *                context may not be null
   * @return The tab's icon as an instance of the class {@link Drawable} or null, if no custom
   * icon is set
   */
  @Nullable
  public final Drawable getIcon(@NonNull final Context context) {
    ensureNotNull(context, "The context may not be null");

    if (iconId != -1) {
      return ContextCompat.getDrawable(context, iconId);
    } else {
      return iconBitmap != null ? new BitmapDrawable(context.getResources(), iconBitmap) :
        null;
    }
  }

  /**
   * Sets the tab's icon.
   *
   * @param resourceId The resource id of the icon, which should be set, as an {@link Integer} value. The
   *                   resource id must correspond to a valid drawable resource
   */
  public final void setIcon(@DrawableRes final int resourceId) {
    this.iconId = resourceId;
    this.iconBitmap = null;
    notifyOnIconChanged();
  }

  /**
   * Sets the tab's icon.
   *
   * @param icon The icon, which should be set, as an instance of the class {@link Bitmap} or null, if
   *             no custom icon should be set
   */
  public final void setIcon(@Nullable final Bitmap icon) {
    this.iconId = -1;
    this.iconBitmap = icon;
    notifyOnIconChanged();
  }

  /**
   * Returns, whether the tab is closeable, or not.
   *
   * @return True, if the tab is closeable, false otherwise
   */
  public final boolean isCloseable() {
    return closeable;
  }

  /**
   * Sets, whether the tab should be closeable, or not.
   *
   * @param closeable True, if the tab should be closeable, false otherwise
   */
  public final void setCloseable(final boolean closeable) {
    this.closeable = closeable;
    notifyOnCloseableChanged();
  }

  /**
   * Returns the icon of the tab's close button.
   *
   * @param context The context, which should be used to retrieve the icon, as an instance of the class
   *                {@link Context}. The context may not be null
   * @return The icon of the tab's close button as an instance of the class {@link Drawable} or
   * null, if no custom icon is set
   */
  @Nullable
  public final Drawable getCloseButtonIcon(@NonNull final Context context) {
    ensureNotNull(context, "The context may not be null");

    if (closeButtonIconId != -1) {
      return ContextCompat.getDrawable(context, closeButtonIconId);
    } else {
      return closeButtonIconBitmap != null ?
        new BitmapDrawable(context.getResources(), closeButtonIconBitmap) : null;
    }
  }

  /**
   * Sets the icon of the tab's close button.
   *
   * @param resourceId The resource id of the icon, which should be set, as an {@link Integer} value. The
   *                   resource id must correspond to a valid drawable resource
   */
  public final void setCloseButtonIcon(@DrawableRes final int resourceId) {
    this.closeButtonIconId = resourceId;
    this.closeButtonIconBitmap = null;
    notifyOnCloseButtonIconChanged();
  }

  /**
   * Sets the icon of the tab's close button.
   *
   * @param icon The icon, which should be set, as an instance of the class {@link Bitmap} or null, if
   *             no custom icon should be set
   */
  public final void setCloseButtonIcon(@Nullable final Bitmap icon) {
    this.closeButtonIconId = -1;
    this.closeButtonIconBitmap = icon;
    notifyOnCloseButtonIconChanged();
  }

  /**
   * Returns the background color of the tab.
   *
   * @return The background color of the tab as an instance of the class {@link ColorStateList} or
   * -1, if no custom color is set
   */
  @Nullable
  public final ColorStateList getBackgroundColor() {
    return backgroundColor;
  }

  /**
   * Sets the tab's background color.
   *
   * @param color The color, which should be set, as an {@link Integer} value or -1, if no custom color
   *              should be set
   */
  public final void setBackgroundColor(@ColorInt final int color) {
    setBackgroundColor(color != -1 ? ColorStateList.valueOf(color) : null);
  }

  /**
   * Sets the tab's background color.
   *
   * @param colorStateList The color state list, which should be set, as an instance of the class {@link
   *                       ColorStateList} or null, if no custom color should be set
   */
  public final void setBackgroundColor(@Nullable final ColorStateList colorStateList) {
    this.backgroundColor = colorStateList;
    notifyOnBackgroundColorChanged();
  }

  /**
   * Returns the text color of the tab's title.
   *
   * @return The text color of the tab's title as an instance of the class {@link ColorStateList}
   * or null, if no custom color is set
   */
  @Nullable
  public final ColorStateList getTitleTextColor() {
    return titleTextColor;
  }

  /**
   * Sets the text color of the tab's title.
   *
   * @param color The color, which should be set, as an {@link Integer} value or -1, if no custom color
   *              should be set
   */
  public final void setTitleTextColor(@ColorInt final int color) {
    setTitleTextColor(color != -1 ? ColorStateList.valueOf(color) : null);
  }

  /**
   * Sets the text color of the tab's title.
   *
   * @param colorStateList The color state list, which should be set, as an instance of the class {@link
   *                       ColorStateList} or null, if no custom color should be set
   */
  public final void setTitleTextColor(@Nullable final ColorStateList colorStateList) {
    this.titleTextColor = colorStateList;
    notifyOnTitleTextColorChanged();
  }

  /**
   * Returns a bundle, which contains the optional parameters, which are associated with the tab.
   *
   * @return A bundle, which contains the optional parameters, which are associated with the tab,
   * as an instance of the class {@link Bundle} or null, if no parameters are associated with the
   * tab
   */
  @Nullable
  public final Bundle getParameters() {
    return parameters;
  }

  /**
   * Sets a bundle, which contains the optional parameters, which should be associated with the
   * tab.
   *
   * @param parameters The bundle, which should be set, as an instance of the class {@link Bundle} or null,
   *                   if no parameters should be associated with the tab
   */
  public final void setParameters(@Nullable final Bundle parameters) {
    this.parameters = parameters;
  }

  /**
   * Adds a new callback, which should be notified, when the tab's properties have been changed.
   *
   * @param callback The callback, which should be added, as an instance of the type {@link Callback}. The
   *                 callback may not be null
   */
  public final void addCallback(@NonNull final Callback callback) {
    ensureNotNull(callback, "The callback may not be null");
    this.callbacks.add(callback);
  }

  /**
   * Removes a specific callback, which should not be notified, when the tab's properties have
   * been changed, anymore.
   *
   * @param callback The callback, which should be removed, as an instance of the type {@link Callback}.
   *                 The callback may not be null
   */
  public final void removeCallback(@NonNull final Callback callback) {
    ensureNotNull(callback, "The callback may not be null");
    this.callbacks.remove(callback);
  }

  @Override
  public final int describeContents() {
    return 0;
  }

  @Override
  public final void writeToParcel(final Parcel parcel, final int flags) {
    TextUtils.writeToParcel(title, parcel, flags);
    parcel.writeInt(iconId);
    parcel.writeParcelable(iconBitmap, flags);
    parcel.writeInt(closeable ? 1 : 0);
    parcel.writeInt(closeButtonIconId);
    parcel.writeParcelable(closeButtonIconBitmap, flags);
    parcel.writeParcelable(backgroundColor, flags);
    parcel.writeParcelable(titleTextColor, flags);
    parcel.writeBundle(parameters);
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/TabCloseListener.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import androidx.annotation.NonNull;

/**
 * Defines the interface, a class, which should be notified, when a tab is about to be closed by
 * clicking its close button, must implement.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public interface TabCloseListener {

  /**
   * The method, which is invoked, when a tab is about to be closed by clicking its close button.
   *
   * @param tabSwitcher The tab switcher, the tab belongs to, as an instance of the class {@link
   *                    TabSwitcher}. The tab switcher may not be null
   * @param tab         The tab, which is about to be closed, as an instance of the class {@link Tab}. The
   *                    tab may not be null
   * @return True, if the tab should be closed, false otherwise
   */
  boolean onCloseTab(@NonNull TabSwitcher tabSwitcher, @NonNull Tab tab);

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/TabPreviewListener.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import androidx.annotation.NonNull;

/**
 * Defines the interface, a class, which should be notified, when the preview of a tab is about to
 * be loaded, must implement.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public interface TabPreviewListener {

  /**
   * The method, which is invoked, when the preview of a tab is about to be loaded.
   *
   * @param tabSwitcher The tab switcher, which contains the tab, whose preview is about to be loaded, as an
   *                    instance of the class {@link TabSwitcher}. The tab switcher may not be null
   * @param tab         The tab, whose preview is about to be loaded, as an instance of the class {@link
   *                    Tab}. The tab may not be null
   * @return True, if loading the preview should be proceeded, false otherwise. When returning
   * false, the method gets invoked repeatedly until true is returned.
   */
  boolean onLoadTabPreview(@NonNull TabSwitcher tabSwitcher, @NonNull Tab tab);

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/TabSwitcher.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.ColorStateList;
import android.content.res.TypedArray;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Bundle;
import android.os.Parcel;
import android.os.Parcelable;
import android.text.TextUtils;
import android.util.AttributeSet;
import android.view.*;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.widget.FrameLayout;
import androidx.annotation.*;
import androidx.appcompat.widget.Toolbar;
import androidx.appcompat.widget.Toolbar.OnMenuItemClickListener;
import androidx.core.content.ContextCompat;
import androidx.core.util.Pair;
import androidx.core.view.ViewCompat;
import de.mrapp.android.tabswitcher.layout.AbstractTabSwitcherLayout;
import de.mrapp.android.tabswitcher.layout.AbstractTabSwitcherLayout.LayoutListenerWrapper;
import de.mrapp.android.tabswitcher.layout.TabSwitcherLayout;
import de.mrapp.android.tabswitcher.layout.phone.PhoneArithmetics;
import de.mrapp.android.tabswitcher.layout.phone.PhoneTabSwitcherLayout;
import de.mrapp.android.tabswitcher.model.Model;
import de.mrapp.android.tabswitcher.model.TabSwitcherModel;
import de.mrapp.android.tabswitcher.view.TabSwitcherButton;
import de.mrapp.android.util.DisplayUtil.DeviceType;
import de.mrapp.android.util.DisplayUtil.Orientation;
import de.mrapp.android.util.ViewUtil;
import de.mrapp.android.util.logging.LogLevel;
import de.mrapp.android.util.view.AbstractSavedState;

import java.util.*;
import java.util.concurrent.CopyOnWriteArraySet;

import static de.mrapp.android.util.Condition.ensureNotNull;
import static de.mrapp.android.util.DisplayUtil.getDeviceType;
import static de.mrapp.android.util.DisplayUtil.getOrientation;

/**
 * A tab switcher, which allows to switch between multiple tabs. It it is designed similar to the
 * tab switcher of the Google Chrome Android app.
 * <p>
 * In order to specify the appearance of individual tabs, a class, which extends from the abstract
 * class {@link TabSwitcherDecorator}, must be implemented and set to the tab switcher via the
 * <code>setDecorator</code>-method.
 * <p>
 * The currently selected tab is shown fullscreen by default. When displaying the switcher via the
 * <code>showSwitcher-method</code>, an overview of all tabs is shown, allowing to select an other
 * tab by clicking it. By swiping a tab or by clicking its close button, it can be removed,
 * resulting in the selected tab to be altered automatically. The switcher can programmatically be
 * hidden by calling the <code>hideSwitcher</code>-method. By calling the
 * <code>setSelectedTab</code>-method programmatically, a tab is selected and shown fullscreen.
 * <p>
 * Individual tabs are represented by instances of the class {@link Tab}. Such tabs can dynamically
 * be added to the tab switcher by using the <code>addTab</code>-methods. In order to remove them
 * afterwards, the <code>removeTab</code> can be used. If the switcher is currently shown, calling
 * these methods results in the tabs being added or removed in an animated manner.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class TabSwitcher extends FrameLayout implements TabSwitcherLayout, Model {

  /**
   * A saved state, which allows to store the state of a {@link TabSwitcher}.
   */
  private static class TabSwitcherState extends AbstractSavedState {

    /**
     * A creator, which allows to create instances of the class {@link TabSwitcherState}.
     */
    public static Creator<TabSwitcherState> CREATOR = new Creator<TabSwitcherState>() {

      @Override
      public TabSwitcherState createFromParcel(final Parcel source) {
        return new TabSwitcherState(source);
      }

      @Override
      public TabSwitcherState[] newArray(final int size) {
        return new TabSwitcherState[size];
      }

    };

    /**
     * The saved layout policy, which is used by the tab switcher.
     */
    private LayoutPolicy layoutPolicy;

    /**
     * The saved state of the model, which is used by the tab switcher.
     */
    private Bundle modelState;

    /**
     * Creates a new saved state, which allows to store the state of a {@link TabSwitcher}.
     *
     * @param source The parcel to read read from as a instance of the class {@link Parcel}. The
     *               parcel may not be null
     */
    private TabSwitcherState(@NonNull final Parcel source) {
      super(source);
      layoutPolicy = (LayoutPolicy) source.readSerializable();
      modelState = source.readBundle(getClass().getClassLoader());
    }

    /**
     * Creates a new saved state, which allows to store the state of a {@link TabSwitcher}.
     *
     * @param superState The state of the superclass of the view, this saved state corresponds to, as an
     *                   instance of the type {@link Parcelable} or null if no state is available
     */
    TabSwitcherState(@Nullable final Parcelable superState) {
      super(superState);
    }

    @Override
    public void writeToParcel(final Parcel dest, final int flags) {
      super.writeToParcel(dest, flags);
      dest.writeSerializable(layoutPolicy);
      dest.writeBundle(modelState);
    }

  }

  /**
   * A queue, which contains all pending actions.
   */
  private Queue<Runnable> pendingActions;

  /**
   * A set, which contains the listeners, which should be notified about the tab switcher's
   * events.
   */
  private Set<TabSwitcherListener> listeners;

  /**
   * The layout policy, which is used by the tab switcher.
   */
  private LayoutPolicy layoutPolicy;

  /**
   * The model, which is used by the tab switcher.
   */
  private TabSwitcherModel model;

  /**
   * The layout, which is used by the tab switcher, depending on whether the device is a
   * smartphone or tablet and the set layout policy.
   */
  private AbstractTabSwitcherLayout layout;

  /**
   * Initializes the view.
   *
   * @param attributeSet         The attribute set, which should be used to initialize the view, as an instance of the
   *                             type {@link AttributeSet} or null, if no attributes should be obtained
   * @param defaultStyle         The default style to apply to this view. If 0, no style will be applied (beyond what
   *                             is included in the theme). This may either be an attribute resource, whose value will
   *                             be retrieved from the current theme, or an explicit style resource
   * @param defaultStyleResource A resource identifier of a style resource that supplies default values for the view,
   *                             used only if the default style is 0 or can not be found in the theme. Can be 0 to not
   *                             look for defaults
   */
  private void initialize(@Nullable final AttributeSet attributeSet,
                          @AttrRes final int defaultStyle,
                          @StyleRes final int defaultStyleResource) {
    pendingActions = new LinkedList<>();
//        listeners = new LinkedHashSet<>();
    listeners = new CopyOnWriteArraySet<>(new LinkedHashSet<TabSwitcherListener>());
    model = new TabSwitcherModel(this);
    model.addListener(createModelListener());
    getViewTreeObserver().addOnGlobalLayoutListener(
      new LayoutListenerWrapper(this, createGlobalLayoutListener(false)));
    setPadding(super.getPaddingLeft(), super.getPaddingTop(), super.getPaddingRight(),
      super.getPaddingBottom());
    obtainStyledAttributes(attributeSet, defaultStyle, defaultStyleResource);
  }

  /**
   * Initializes a specific layout.
   *
   * @param inflatedTabsOnly True, if only the tabs should be inflated, false otherwise
   * @param layout           The layout, which should be initialized, as a value of the enum {@link Layout}. The
   *                         layout may not be null
   */
  private void initializeLayout(@NonNull final Layout layout, final boolean inflatedTabsOnly) {
    if (layout == Layout.TABLET) {
      // TODO: Use tablet layout once implemented
      PhoneArithmetics arithmetics = new PhoneArithmetics(TabSwitcher.this);
      this.layout = new PhoneTabSwitcherLayout(TabSwitcher.this, model, arithmetics);
    } else {
      PhoneArithmetics arithmetics = new PhoneArithmetics(TabSwitcher.this);
      this.layout = new PhoneTabSwitcherLayout(TabSwitcher.this, model, arithmetics);
    }

    this.layout.setCallback(createLayoutCallback());
    this.model.addListener(this.layout);
    this.layout.inflateLayout(inflatedTabsOnly);
    final ViewGroup tabContainer = getTabContainer();
    assert tabContainer != null;

    if (ViewCompat.isLaidOut(tabContainer)) {
      this.layout.onGlobalLayout();
    } else {
      tabContainer.getViewTreeObserver()
        .addOnGlobalLayoutListener(new OnGlobalLayoutListener() {

          @Override
          public void onGlobalLayout() {
            ViewUtil.removeOnGlobalLayoutListener(
              tabContainer.getViewTreeObserver(), this);
            if (TabSwitcher.this.layout != null) {
              TabSwitcher.this.layout.onGlobalLayout();
            }
          }

        });
    }
  }

  /**
   * Obtains all attributes from a specific attribute set.
   *
   * @param attributeSet         The attribute set, the attributes should be obtained from, as an instance of the type
   *                             {@link AttributeSet} or null, if no attributes should be obtained
   * @param defaultStyle         The default style to apply to this view. If 0, no style will be applied (beyond what
   *                             is included in the theme). This may either be an attribute resource, whose value will
   *                             be retrieved from the current theme, or an explicit style resource
   * @param defaultStyleResource A resource identifier of a style resource that supplies default values for the view,
   *                             used only if the default style is 0 or can not be found in the theme. Can be 0 to not
   *                             look for defaults
   */
  private void obtainStyledAttributes(@Nullable final AttributeSet attributeSet,
                                      @AttrRes final int defaultStyle,
                                      @StyleRes final int defaultStyleResource) {
    TypedArray typedArray = getContext()
      .obtainStyledAttributes(attributeSet, R.styleable.TabSwitcher, defaultStyle,
        defaultStyleResource);

    try {
      obtainLayoutPolicy(typedArray);
      obtainBackground(typedArray);
      obtainTabIcon(typedArray);
      obtainTabBackgroundColor(typedArray);
      obtainTabTitleTextColor(typedArray);
      obtainTabCloseButtonIcon(typedArray);
      obtainToolbarTitle(typedArray);
      obtainToolbarNavigationIcon(typedArray);
      obtainToolbarMenu(typedArray);
    } finally {
      typedArray.recycle();
    }
  }

  /**
   * Obtains the layout policy from a specific typed array.
   *
   * @param typedArray The typed array, the layout policy should be obtained from, as an instance of the
   *                   class {@link TypedArray}. The typed array may not be null
   */
  private void obtainLayoutPolicy(@NonNull final TypedArray typedArray) {
    int defaultValue = LayoutPolicy.AUTO.getValue();
    int value = typedArray.getInt(R.styleable.TabSwitcher_layoutPolicy, defaultValue);
    setLayoutPolicy(LayoutPolicy.fromValue(value));
  }

  /**
   * Obtains the view's background from a specific typed array.
   *
   * @param typedArray The typed array, the background should be obtained from, as an instance of the class
   *                   {@link TypedArray}. The typed array may not be null
   */
  private void obtainBackground(@NonNull final TypedArray typedArray) {
    int resourceId = typedArray.getResourceId(R.styleable.TabSwitcher_android_background, 0);

    if (resourceId != 0) {
      ViewUtil.setBackground(this, ContextCompat.getDrawable(getContext(), resourceId));
    } else {
      int defaultValue =
        ContextCompat.getColor(getContext(), R.color.tab_switcher_background_color);
      int color =
        typedArray.getColor(R.styleable.TabSwitcher_android_background, defaultValue);
      setBackgroundColor(color);
    }
  }

  /**
   * Obtains the icon of a tab from a specific typed array.
   *
   * @param typedArray The typed array, the icon should be obtained from, as an instance of the class {@link
   *                   TypedArray}. The typed array may not be null
   */
  private void obtainTabIcon(@NonNull final TypedArray typedArray) {
    int resourceId = typedArray.getResourceId(R.styleable.TabSwitcher_tabIcon, -1);

    if (resourceId != -1) {
      setTabIcon(resourceId);
    }
  }

  /**
   * Obtains the background color of a tab from a specific typed array.
   *
   * @param typedArray The typed array, the background color should be obtained from, as an instance of the
   *                   class {@link TypedArray}. The typed array may not be null
   */
  private void obtainTabBackgroundColor(@NonNull final TypedArray typedArray) {
    ColorStateList colorStateList =
      typedArray.getColorStateList(R.styleable.TabSwitcher_tabBackgroundColor);

    if (colorStateList != null) {
      setTabBackgroundColor(colorStateList);
    }
  }

  /**
   * Obtains the text color of a tab's title from a specific typed array.
   *
   * @param typedArray The typed array, the text color should be obtained from, as an instance of the class
   *                   {@link TypedArray}. The typed array may not be null
   */
  private void obtainTabTitleTextColor(@NonNull final TypedArray typedArray) {
    ColorStateList colorStateList =
      typedArray.getColorStateList(R.styleable.TabSwitcher_tabTitleTextColor);

    if (colorStateList != null) {
      setTabTitleTextColor(colorStateList);
    }
  }

  /**
   * Obtains the icon of a tab's close button from a specific typed array.
   *
   * @param typedArray The typed array, the icon should be obtained from, as an instance of the class {@link
   *                   TypedArray}. The typed array may not be null
   */
  private void obtainTabCloseButtonIcon(@NonNull final TypedArray typedArray) {
    int resourceId = typedArray.getResourceId(R.styleable.TabSwitcher_tabCloseButtonIcon, -1);

    if (resourceId != -1) {
      setTabCloseButtonIcon(resourceId);
    }
  }

  /**
   * Obtains the title of the toolbar, which is shown, when the tab switcher is shown, from a
   * specific typed array.
   *
   * @param typedArray The typed array, the title should be obtained from, as an instance of the class
   *                   {@link TypedArray}. The typed array may not be null
   */
  private void obtainToolbarTitle(@NonNull final TypedArray typedArray) {
    CharSequence title = typedArray.getText(R.styleable.TabSwitcher_toolbarTitle);

    if (!TextUtils.isEmpty(title)) {
      setToolbarTitle(title);
    }
  }

  /**
   * Obtains the navigation icon of the toolbar, which is shown, when the tab switcher is shown,
   * from a specific typed array.
   *
   * @param typedArray The typed array, the navigation icon should be obtained from, as an instance of the
   *                   class {@link TypedArray}. The typed array may not be null
   */
  private void obtainToolbarNavigationIcon(@NonNull final TypedArray typedArray) {
    Drawable icon = typedArray.getDrawable(R.styleable.TabSwitcher_toolbarNavigationIcon);

    if (icon != null) {
      setToolbarNavigationIcon(icon, null);
    }
  }

  /**
   * Obtains the menu of the toolbar, which is shown, when the tab switcher is shown, from a
   * specific typed array.
   *
   * @param typedArray The typed array, the menu should be obtained from, as an instance of the class {@link
   *                   TypedArray}. The typed array may not be null
   */
  private void obtainToolbarMenu(@NonNull final TypedArray typedArray) {
    int resourceId = typedArray.getResourceId(R.styleable.TabSwitcher_toolbarMenu, -1);

    if (resourceId != -1) {
      inflateToolbarMenu(resourceId, null);
    }
  }

  /**
   * Enqueues a specific action to be executed, when no animation is running.
   *
   * @param action The action, which should be enqueued as an instance of the type {@link Runnable}. The
   *               action may not be null
   */
  private void enqueuePendingAction(@NonNull final Runnable action) {
    ensureNotNull(action, "The action may not be null");
    pendingActions.add(action);
    executePendingAction();
  }

  /**
   * Executes the next pending action.
   */
  private void executePendingAction() {
    if (!isAnimationRunning()) {
      final Runnable action = pendingActions.poll();

      if (action != null) {
        new Runnable() {

          @Override
          public void run() {
            action.run();
            executePendingAction();
          }

        }.run();
      }
    }
  }

  /**
   * Creates and returns a listener, which allows to observe, when the tab switcher's model is
   * modified.
   *
   * @return The listener, which has been created, as an instance of the type {@link
   * Model.Listener}. The listener may not be null
   */
  @NonNull
  private Model.Listener createModelListener() {
    return new Model.Listener() {

      @Override
      public void onLogLevelChanged(@NonNull final LogLevel logLevel) {

      }

      @Override
      public void onDecoratorChanged(@NonNull final TabSwitcherDecorator decorator) {

      }

      @Override
      public void onSwitcherShown() {
        notifyOnSwitcherShown();
      }

      @Override
      public void onSwitcherHidden() {
        notifyOnSwitcherHidden();
      }

      @Override
      public void onSelectionChanged(final int previousIndex, final int index,
                                     @Nullable final Tab selectedTab,
                                     final boolean switcherHidden) {
        notifyOnSelectionChanged(index, selectedTab);

        if (switcherHidden) {
          notifyOnSwitcherHidden();
        }
      }

      @Override
      public void onTabAdded(final int index, @NonNull final Tab tab,
                             final int previousSelectedTabIndex, final int selectedTabIndex,
                             final boolean switcherVisibilityChanged,
                             @NonNull final Animation animation) {
        notifyOnTabAdded(index, tab, animation);

        if (previousSelectedTabIndex != selectedTabIndex) {
          notifyOnSelectionChanged(selectedTabIndex,
            selectedTabIndex != -1 ? getTab(selectedTabIndex) : null);
        }

        if (switcherVisibilityChanged) {
          notifyOnSwitcherHidden();
        }
      }

      @Override
      public void onAllTabsAdded(final int index, @NonNull final Tab[] tabs,
                                 final int previousSelectedTabIndex,
                                 final int selectedTabIndex,
                                 @NonNull final Animation animation) {
        for (Tab tab : tabs) {
          notifyOnTabAdded(index, tab, animation);
        }

        if (previousSelectedTabIndex != selectedTabIndex) {
          notifyOnSelectionChanged(selectedTabIndex,
            selectedTabIndex != -1 ? getTab(selectedTabIndex) : null);
        }
      }

      @Override
      public void onTabRemoved(final int index, @NonNull final Tab tab,
                               final int previousSelectedTabIndex, final int selectedTabIndex,
                               @NonNull final Animation animation) {
        notifyOnTabRemoved(index, tab, animation);

        if (previousSelectedTabIndex != selectedTabIndex) {
          notifyOnSelectionChanged(selectedTabIndex,
            selectedTabIndex != -1 ? getTab(selectedTabIndex) : null);
        }
      }

      @Override
      public void onAllTabsRemoved(@NonNull final Tab[] tabs,
                                   @NonNull final Animation animation) {
        notifyOnAllTabsRemoved(tabs, animation);
        notifyOnSelectionChanged(-1, null);
      }

      @Override
      public void onPaddingChanged(final int left, final int top, final int right,
                                   final int bottom) {

      }

      @Override
      public void onTabIconChanged(@Nullable final Drawable icon) {

      }

      @Override
      public void onTabBackgroundColorChanged(@Nullable final ColorStateList colorStateList) {

      }

      @Override
      public void onTabTitleColorChanged(@Nullable final ColorStateList colorStateList) {

      }

      @Override
      public void onTabCloseButtonIconChanged(@Nullable final Drawable icon) {

      }

      @Override
      public void onToolbarVisibilityChanged(final boolean visible) {

      }

      @Override
      public void onToolbarTitleChanged(@Nullable final CharSequence title) {

      }

      @Override
      public void onToolbarNavigationIconChanged(@Nullable final Drawable icon,
                                                 @Nullable final OnClickListener listener) {

      }

      @Override
      public void onToolbarMenuInflated(@MenuRes final int resourceId,
                                        @Nullable final OnMenuItemClickListener listener) {

      }

    };
  }

  /**
   * Creates and returns a callback, which allows to observe, when all pending animations of a
   * layout have been ended.
   *
   * @return The callback, which has been created, as an instance of the type {@link
   * AbstractTabSwitcherLayout.Callback}. The callback may not be null
   */
  @NonNull
  private AbstractTabSwitcherLayout.Callback createLayoutCallback() {
    return new AbstractTabSwitcherLayout.Callback() {

      @Override
      public void onAnimationsEnded() {
        executePendingAction();
      }

    };
  }

  /**
   * Creates and returns a listener, which allows to inflate the view's layout once the view is
   * laid out.
   *
   * @param inflateTabsOnly True, if only the tabs should be inflated, false otherwise
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createGlobalLayoutListener(final boolean inflateTabsOnly) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        ensureNotNull(getDecorator(), "No decorator has been set",
          IllegalStateException.class);
        initializeLayout(getLayout(), inflateTabsOnly);
      }

    };
  }

  /**
   * Notifies all listeners, that the tab switcher has been shown.
   */
  private void notifyOnSwitcherShown() {
    for (TabSwitcherListener listener : listeners) {
      listener.onSwitcherShown(this);
    }
  }

  /**
   * Notifies all listeners, that the tab switcher has been hidden.
   */
  private void notifyOnSwitcherHidden() {
    for (TabSwitcherListener listener : listeners) {
      listener.onSwitcherHidden(this);
    }
  }

  /**
   * Notifies all listeners, that the selected tab has been changed.
   *
   * @param selectedTabIndex The index of the currently selected tab as an {@link Integer} value or -1, if no tab
   *                         is currently selected
   * @param selectedTab      The currently selected tab as an instance of the class {@link Tab} or null,  if no
   *                         tab is currently selected
   */
  private void notifyOnSelectionChanged(final int selectedTabIndex,
                                        @Nullable final Tab selectedTab) {
    for (TabSwitcherListener listener : listeners) {
      listener.onSelectionChanged(this, selectedTabIndex, selectedTab);
    }
  }

  /**
   * Notifies all listeners, that a specific tab has been added to the tab switcher.
   *
   * @param index     The index of the tab, which has been added, as an {@link Integer} value
   * @param tab       The tab, which has been added, as an instance of the class {@link Tab}. The tab may
   *                  not be null
   * @param animation The animation, which has been used to add the tab, as an instance of the class {@link
   *                  Animation}. The animation may not be null
   */
  private void notifyOnTabAdded(final int index, @NonNull final Tab tab,
                                @NonNull final Animation animation) {
    for (TabSwitcherListener listener : listeners) {
      listener.onTabAdded(this, index, tab, animation);
    }
  }

  /**
   * Notifies all listeners, that a specific tab has been removed from the tab switcher.
   *
   * @param index     The index of the tab, which has been removed, as an {@link Integer} value
   * @param tab       The tab, which has been removed, as an instance of the class {@link Tab}. The tab may
   *                  not be null
   * @param animation The animation, which has been used to remove the tab, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  private void notifyOnTabRemoved(final int index, @NonNull final Tab tab,
                                  @NonNull final Animation animation) {
    for (TabSwitcherListener listener : listeners) {
      listener.onTabRemoved(this, index, tab, animation);
    }
  }

  /**
   * Notifies all listeners, that all tabs have been removed from the tab switcher.
   *
   * @param tabs      An array, which contains the tabs, which have been removed, as an array of the type
   *                  {@link Tab} or an empty array, if no tabs have been removed
   * @param animation The animation, which has been used to remove the tabs, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  private void notifyOnAllTabsRemoved(@NonNull final Tab[] tabs,
                                      @NonNull final Animation animation) {
    for (TabSwitcherListener listener : listeners) {
      listener.onAllTabsRemoved(this, tabs, animation);
    }
  }

  /**
   * Creates a new tab switcher, which allows to switch between multiple tabs.
   *
   * @param context The context, which should be used by the view, as an instance of the class {@link
   *                Context}. The context may not be null
   */
  public TabSwitcher(@NonNull final Context context) {
    this(context, null);
  }

  /**
   * Creates a new tab switcher, which allows to switch between multiple tabs.
   *
   * @param context      The context, which should be used by the view, as an instance of the class {@link
   *                     Context}. The context may not be null
   * @param attributeSet The attribute set, the view's attributes should be obtained from, as an instance of
   *                     the type {@link AttributeSet} or null, if no attributes should be obtained
   */
  public TabSwitcher(@NonNull final Context context, @Nullable final AttributeSet attributeSet) {
    super(context, attributeSet);
    initialize(attributeSet, 0, 0);
  }

  /**
   * Creates a new tab switcher, which allows to switch between multiple tabs.
   *
   * @param context      The context, which should be used by the view, as an instance of the class {@link
   *                     Context}. The context may not be null
   * @param attributeSet The attribute set, the view's attributes should be obtained from, as an instance of
   *                     the type {@link AttributeSet} or null, if no attributes should be obtained
   * @param defaultStyle The default style to apply to this view. If 0, no style will be applied (beyond what
   *                     is included in the theme). This may either be an attribute resource, whose value will
   *                     be retrieved from the current theme, or an explicit style resource
   */
  public TabSwitcher(@NonNull final Context context, @Nullable final AttributeSet attributeSet,
                     @AttrRes final int defaultStyle) {
    super(context, attributeSet, defaultStyle);
    initialize(attributeSet, defaultStyle, 0);
  }

  /**
   * Creates a new tab switcher, which allows to switch between multiple tabs.
   *
   * @param context              The context, which should be used by the view, as an instance of the class {@link
   *                             Context}. The context may not be null
   * @param attributeSet         The attribute set, the view's attributes should be obtained from, as an instance of
   *                             the type {@link AttributeSet} or null, if no attributes should be obtained
   * @param defaultStyle         The default style to apply to this view. If 0, no style will be applied (beyond what
   *                             is included in the theme). This may either be an attribute resource, whose value will
   *                             be retrieved from the current theme, or an explicit style resource
   * @param defaultStyleResource A resource identifier of a style resource that supplies default values for the view,
   *                             used only if the default style is 0 or can not be found in the theme. Can be 0 to not
   *                             look for defaults
   */
  @TargetApi(Build.VERSION_CODES.LOLLIPOP)
  public TabSwitcher(@NonNull final Context context, @Nullable final AttributeSet attributeSet,
                     @AttrRes final int defaultStyle, @StyleRes final int defaultStyleResource) {
    super(context, attributeSet, defaultStyle, defaultStyleResource);
    initialize(attributeSet, defaultStyle, defaultStyleResource);
  }

  /**
   * Setups the tab switcher to be associated with those menu items of a specific menu, which use
   * a {@link TabSwitcherButton} as their action view. The icon of such menu items will
   * automatically be updated, when the number of tabs, which are contained by the tab switcher,
   * changes.
   *
   * @param tabSwitcher The tab switcher, which should become associated with the menu items, as an instance
   *                    of the class {@link TabSwitcher}. The tab switcher may not be null
   * @param menu        The menu, whose menu items should become associated with the given tab switcher, as
   *                    an instance of the type {@link Menu}. The menu may not be null
   * @param listener    The listener, which should be set to the menu items, which use a {@link
   *                    TabSwitcherButton} as their action view, as an instance of the type {@link
   *                    OnClickListener} or null, if no listener should be set
   */
  public static void setupWithMenu(@NonNull final TabSwitcher tabSwitcher,
                                   @NonNull final Menu menu,
                                   @Nullable final OnClickListener listener) {
    ensureNotNull(tabSwitcher, "The tab switcher may not be null");
    ensureNotNull(menu, "The menu may not be null");

    for (int i = 0; i < menu.size(); i++) {
      MenuItem menuItem = menu.getItem(i);
      View view = menuItem.getActionView();

      if (view instanceof TabSwitcherButton) {
        TabSwitcherButton tabSwitcherButton = (TabSwitcherButton) view;
        tabSwitcherButton.setOnClickListener(listener);
        tabSwitcherButton.setCount(tabSwitcher.getCount());
        tabSwitcher.addListener(tabSwitcherButton);
      }
    }
  }

  /**
   * Adds a listener, which should be notified about the tab switcher's events.
   *
   * @param listener The listener, which should be added, as an instance of the type {@link
   *                 TabSwitcherListener}. The listener may not be null
   */
  public final void addListener(@NonNull final TabSwitcherListener listener) {
    ensureNotNull(listener, "The listener may not be null");
    this.listeners.add(listener);
  }

  /**
   * Removes a specific listener, which should not be notified about the tab switcher's events,
   * anymore.
   *
   * @param listener The listener, which should be removed, as an instance of the type {@link
   *                 TabSwitcherListener}. The listener may not be null
   */
  public final void removeListener(@NonNull final TabSwitcherListener listener) {
    ensureNotNull(listener, "The listener may not be null");
    this.listeners.remove(listener);
  }

  /**
   * Returns the layout policy, which is used by the tab switcher.
   *
   * @return The layout policy, which is used by the tab switcher, as a value of the enum {@link
   * LayoutPolicy}. The layout policy may either be {@link LayoutPolicy#AUTO}, {@link
   * LayoutPolicy#PHONE} or {@link LayoutPolicy#TABLET}
   */
  @NonNull
  public final LayoutPolicy getLayoutPolicy() {
    return layoutPolicy;
  }

  /**
   * Sets the layout policy, which should be used by the tab switcher.
   * <p>
   * Changing the layout policy after the view has been laid out does not have any effect.
   *
   * @param layoutPolicy The layout policy, which should be set, as a value of the enum {@link LayoutPolicy}.
   *                     The layout policy may either be {@link LayoutPolicy#AUTO}, {@link LayoutPolicy#PHONE}
   *                     or {@link LayoutPolicy#TABLET}
   */
  public final void setLayoutPolicy(@NonNull final LayoutPolicy layoutPolicy) {
    ensureNotNull(layoutPolicy, "The layout policy may not be null");

    if (this.layoutPolicy != layoutPolicy) {
      Layout previousLayout = getLayout();
      this.layoutPolicy = layoutPolicy;

      if (layout != null) {
        Layout newLayout = getLayout();

        if (previousLayout != newLayout) {
          layout.detachLayout(false);
          model.removeListener(layout);
          initializeLayout(newLayout, false);
        }
      }
    }
  }

  /**
   * Returns the layout of the tab switcher.
   *
   * @return The layout of the tab switcher as a value of the enum {@link Layout}. The layout may
   * either be {@link Layout#PHONE_PORTRAIT}, {@link Layout#PHONE_LANDSCAPE} or {@link
   * Layout#TABLET}
   */
  @NonNull
  public final Layout getLayout() {
    if (layoutPolicy == LayoutPolicy.TABLET || (layoutPolicy == LayoutPolicy.AUTO &&
      getDeviceType(getContext()) == DeviceType.TABLET)) {
      return Layout.TABLET;
    } else {
      return getOrientation(getContext()) == Orientation.LANDSCAPE ? Layout.PHONE_LANDSCAPE :
        Layout.PHONE_PORTRAIT;
    }
  }

  @Override
  public final void addTab(@NonNull final Tab tab) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addTab(tab);
      }

    });
  }

  @Override
  public final void addTab(@NonNull final Tab tab, final int index) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addTab(tab, index);
      }

    });
  }

  @Override
  public final void addTab(@NonNull final Tab tab, final int index,
                           @NonNull final Animation animation) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addTab(tab, index, animation);
      }

    });
  }

  @Override
  public final void addAllTabs(@NonNull final Collection<? extends Tab> tabs) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addAllTabs(tabs);
      }

    });
  }

  @Override
  public final void addAllTabs(@NonNull final Collection<? extends Tab> tabs, final int index) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addAllTabs(tabs, index);
      }

    });
  }

  @Override
  public final void addAllTabs(@NonNull final Collection<? extends Tab> tabs, final int index,
                               @NonNull final Animation animation) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addAllTabs(tabs, index, animation);
      }

    });
  }

  @Override
  public final void addAllTabs(@NonNull final Tab[] tabs) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addAllTabs(tabs);
      }

    });
  }

  @Override
  public final void addAllTabs(@NonNull final Tab[] tabs, final int index) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addAllTabs(tabs, index);
      }

    });
  }

  @Override
  public final void addAllTabs(@NonNull final Tab[] tabs, final int index,
                               @NonNull final Animation animation) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.addAllTabs(tabs, index, animation);
      }

    });
  }

  @Override
  public final void removeTab(@NonNull final Tab tab) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.removeTab(tab);
      }

    });
  }

  @Override
  public final void removeTab(@NonNull final Tab tab, @NonNull final Animation animation) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.removeTab(tab, animation);
      }

    });
  }

  @Override
  public final void clear() {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.clear();
      }

    });
  }

  @Override
  public final void clear(@NonNull final Animation animationType) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.clear(animationType);
      }

    });
  }

  @Override
  public final void selectTab(@NonNull final Tab tab) {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.selectTab(tab);
      }

    });
  }

  @Nullable
  @Override
  public final Tab getSelectedTab() {
    return model.getSelectedTab();
  }

  @Override
  public final int getSelectedTabIndex() {
    return model.getSelectedTabIndex();
  }

  @Override
  public final Iterator<Tab> iterator() {
    return model.iterator();
  }

  @Override
  public final boolean isEmpty() {
    return model.isEmpty();
  }

  @Override
  public final int getCount() {
    return model.getCount();
  }

  @NonNull
  @Override
  public final Tab getTab(final int index) {
    return model.getTab(index);
  }

  @Override
  public final int indexOf(@NonNull final Tab tab) {
    return model.indexOf(tab);
  }

  @Override
  public final boolean isSwitcherShown() {
    return model.isSwitcherShown();
  }

  @Override
  public final void showSwitcher() {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.showSwitcher();
      }

    });
  }

  @Override
  public final void hideSwitcher() {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.hideSwitcher();
      }

    });
  }

  @Override
  public final void toggleSwitcherVisibility() {
    enqueuePendingAction(new Runnable() {

      @Override
      public void run() {
        model.toggleSwitcherVisibility();
      }

    });
  }

  @Override
  public final void setDecorator(@NonNull final TabSwitcherDecorator decorator) {
    model.setDecorator(decorator);
  }

  @Override
  public final TabSwitcherDecorator getDecorator() {
    return model.getDecorator();
  }

  @NonNull
  @Override
  public final LogLevel getLogLevel() {
    return model.getLogLevel();
  }

  @Override
  public final void setLogLevel(@NonNull final LogLevel logLevel) {
    model.setLogLevel(logLevel);
  }

  @Override
  public final void setPadding(final int left, final int top, final int right, final int bottom) {
    model.setPadding(left, top, right, bottom);
  }

  @Override
  public final int getPaddingLeft() {
    return model.getPaddingLeft();
  }

  @Override
  public final int getPaddingTop() {
    return model.getPaddingTop();
  }

  @Override
  public final int getPaddingRight() {
    return model.getPaddingRight();
  }

  @Override
  public final int getPaddingBottom() {
    return model.getPaddingBottom();
  }

  @Override
  public final int getPaddingStart() {
    return model.getPaddingStart();
  }

  @Override
  public final int getPaddingEnd() {
    return model.getPaddingEnd();
  }

  @Nullable
  @Override
  public final Drawable getTabIcon() {
    return model.getTabIcon();
  }

  @Override
  public final void setTabIcon(@DrawableRes final int resourceId) {
    model.setTabIcon(resourceId);
  }

  @Override
  public final void setTabIcon(@Nullable final Bitmap icon) {
    model.setTabIcon(icon);
  }

  @Nullable
  @Override
  public final ColorStateList getTabBackgroundColor() {
    return model.getTabBackgroundColor();
  }

  @Override
  public final void setTabBackgroundColor(@ColorInt final int color) {
    model.setTabBackgroundColor(color);
  }

  @Override
  public final void setTabBackgroundColor(@Nullable final ColorStateList colorStateList) {
    model.setTabBackgroundColor(colorStateList);
  }

  @Nullable
  @Override
  public final ColorStateList getTabTitleTextColor() {
    return model.getTabTitleTextColor();
  }

  @Override
  public final void setTabTitleTextColor(@ColorInt final int color) {
    model.setTabTitleTextColor(color);
  }

  @Override
  public final void setTabTitleTextColor(@Nullable final ColorStateList colorStateList) {
    model.setTabTitleTextColor(colorStateList);
  }

  @Nullable
  @Override
  public final Drawable getTabCloseButtonIcon() {
    return model.getTabCloseButtonIcon();
  }

  @Override
  public final void setTabCloseButtonIcon(@DrawableRes final int resourceId) {
    model.setTabCloseButtonIcon(resourceId);
  }

  @Override
  public final void setTabCloseButtonIcon(@Nullable final Bitmap icon) {
    model.setTabCloseButtonIcon(icon);
  }

  @Override
  public final boolean areToolbarsShown() {
    return model.areToolbarsShown();
  }

  @Override
  public final void showToolbars(final boolean show) {
    model.showToolbars(show);
  }

  @Nullable
  @Override
  public final CharSequence getToolbarTitle() {
    Toolbar[] toolbars = getToolbars();
    return toolbars != null ? toolbars[0].getTitle() : model.getToolbarTitle();
  }

  @Override
  public final void setToolbarTitle(@StringRes final int resourceId) {
    model.setToolbarTitle(resourceId);
  }

  @Override
  public final void setToolbarTitle(@Nullable final CharSequence title) {
    model.setToolbarTitle(title);
  }

  @Nullable
  @Override
  public final Drawable getToolbarNavigationIcon() {
    Toolbar[] toolbars = getToolbars();
    return toolbars != null ? toolbars[0].getNavigationIcon() :
      model.getToolbarNavigationIcon();
  }

  @Override
  public final void setToolbarNavigationIcon(@Nullable final Drawable icon,
                                             @Nullable final OnClickListener listener) {
    model.setToolbarNavigationIcon(icon, listener);
  }

  @Override
  public final void setToolbarNavigationIcon(@DrawableRes final int resourceId,
                                             @Nullable final OnClickListener listener) {
    model.setToolbarNavigationIcon(resourceId, listener);
  }

  @Override
  public final void inflateToolbarMenu(@MenuRes final int resourceId,
                                       @Nullable final OnMenuItemClickListener listener) {
    model.inflateToolbarMenu(resourceId, listener);
  }

  @Override
  public final void addCloseTabListener(@NonNull final TabCloseListener listener) {
    model.addCloseTabListener(listener);
  }

  @Override
  public final void removeCloseTabListener(@NonNull final TabCloseListener listener) {
    model.removeCloseTabListener(listener);
  }

  @Override
  public final void addTabPreviewListener(@NonNull final TabPreviewListener listener) {
    model.addTabPreviewListener(listener);
  }

  @Override
  public final void removeTabPreviewListener(@NonNull final TabPreviewListener listener) {
    model.removeTabPreviewListener(listener);
  }

  @Override
  public final boolean isAnimationRunning() {
    return layout != null && layout.isAnimationRunning();
  }

  @Nullable
  @Override
  public final ViewGroup getTabContainer() {
    return layout != null ? layout.getTabContainer() : null;
  }

  @Override
  public final Toolbar[] getToolbars() {
    return layout != null ? layout.getToolbars() : null;
  }

  @Nullable
  @Override
  public final Menu getToolbarMenu() {
    return layout != null ? layout.getToolbarMenu() : null;
  }

  @Override
  public final boolean onTouchEvent(final MotionEvent event) {
    return (layout != null && layout.handleTouchEvent(event)) || super.onTouchEvent(event);
  }

  @Override
  public final Parcelable onSaveInstanceState() {
    Parcelable superState = super.onSaveInstanceState();
    TabSwitcherState savedState = new TabSwitcherState(superState);
    savedState.layoutPolicy = layoutPolicy;
    savedState.modelState = new Bundle();

    Pair<Integer, Float> pair = null;
    if (getCount() > 0 && layout != null) {
      pair = layout.detachLayout(true);
    }

    if (pair != null) {
      savedState.modelState
        .putInt(TabSwitcherModel.FIRST_VISIBLE_TAB_INDEX_EXTRA, pair.first);
      savedState.modelState
        .putFloat(TabSwitcherModel.FIRST_VISIBLE_TAB_POSITION_EXTRA, pair.second);
      model.setFirstVisibleTabIndex(pair.first);
      model.setFirstVisibleTabPosition(pair.second);
    } else {
      model.setFirstVisibleTabPosition(-1);
      model.setFirstVisibleTabIndex(-1);
    }

    if (layout != null) {
      model.removeListener(layout);
      layout = null;
    }
    executePendingAction();
    getViewTreeObserver().addOnGlobalLayoutListener(
      new LayoutListenerWrapper(this, createGlobalLayoutListener(true)));
    model.saveInstanceState(savedState.modelState);
    return savedState;
  }

  @Override
  public final void onRestoreInstanceState(final Parcelable state) {
    if (state instanceof TabSwitcherState) {
      TabSwitcherState savedState = (TabSwitcherState) state;
      this.layoutPolicy = savedState.layoutPolicy;
      model.restoreInstanceState(savedState.modelState);
      super.onRestoreInstanceState(savedState.getSuperState());
    } else {
      super.onRestoreInstanceState(state);
    }
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/TabSwitcherDecorator.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import android.content.Context;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.SparseArray;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import de.mrapp.android.util.view.AbstractViewHolderAdapter;

/**
 * An abstract base class for all decorators, which  are responsible for inflating views, which
 * should be used to visualize the tabs of a {@link TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public abstract class TabSwitcherDecorator extends AbstractViewHolderAdapter {

  /**
   * The name of the extra, which is used to store the state of a view hierarchy within a bundle.
   */
  private static final String VIEW_HIERARCHY_STATE_EXTRA =
    TabSwitcherDecorator.class.getName() + "::ViewHierarchyState";

  /**
   * The method which is invoked, when a view, which is used to visualize a tab, should be
   * inflated.
   *
   * @param inflater The inflater, which should be used to inflate the view, as an instance of the class
   *                 {@link LayoutInflater}. The inflater may not be null
   * @param parent   The parent view of the view, which should be inflated, as an instance of the class
   *                 {@link ViewGroup} or null, if no parent view is available
   * @param viewType The view type of the tab, which should be visualized, as an {@link Integer} value
   * @return The view, which has been inflated, as an instance of the class {@link View}. The view
   * may not be null
   */
  @NonNull
  public abstract View onInflateView(@NonNull final LayoutInflater inflater,
                                     @Nullable final ViewGroup parent, final int viewType);

  /**
   * The method which is invoked, when the view, which is used to visualize a tab, should be
   * shown, respectively when it should be refreshed. The purpose of this method is to customize
   * the appearance of the view, which is used to visualize the corresponding tab, depending on
   * its state and whether the tab switcher is currently shown, or not.
   *
   * @param context            The context, the tab switcher belongs to, as an instance of the class {@link
   *                           Context}. The context may not be null
   * @param tabSwitcher        The tab switcher, whose tabs are visualized by the decorator, as an instance of the
   *                           type {@link TabSwitcher}. The tab switcher may not be null
   * @param view               The view, which is used to visualize the tab, as an instance of the class {@link
   *                           View}. The view may not be null
   * @param tab                The tab, which should be visualized, as an instance of the class {@link Tab}. The tab
   *                           may not be null
   * @param index              The index of the tab, which should be visualized, as an {@link Integer} value
   * @param viewType           The view type of the tab, which should be visualized, as an {@link Integer} value
   * @param savedInstanceState The bundle, which has previously been used to save the state of the view as an
   *                           instance of the class {@link Bundle} or null, if no saved state is available
   */
  public abstract void onShowTab(@NonNull final Context context,
                                 @NonNull final TabSwitcher tabSwitcher, @NonNull final View view,
                                 @NonNull final Tab tab, final int index, final int viewType,
                                 @Nullable final Bundle savedInstanceState);

  /**
   * The method, which is invoked, when the view, which is used to visualize a tab, is removed.
   * The purpose of this method is to save the current state of the tab in a bundle.
   *
   * @param view     The view, which is used to visualize the tab, as an instance of the class {@link
   *                 View}
   * @param tab      The tab, whose state should be saved, as an instance of the class {@link Tab}. The
   *                 tab may not be null
   * @param index    The index of the tab, whose state should be saved, as an {@link Integer} value
   * @param viewType The view type of the tab, whose state should be saved, as an {@link Integer} value
   * @param outState The bundle, the state of the tab should be saved to, as an instance of the class
   *                 {@link Bundle}. The bundle may not be null
   */
  public void onSaveInstanceState(@NonNull final View view, @NonNull final Tab tab,
                                  final int index, final int viewType,
                                  @NonNull final Bundle outState) {

  }

  /**
   * Returns the view type, which corresponds to a specific tab. For each layout, which is
   * inflated by the <code>onInflateView</code>-method, a distinct view type must be
   * returned.
   *
   * @param tab   The tab, whose view type should be returned, as an instance of the class {@link Tab}.
   *              The tab may not be null
   * @param index The index of the tab, whose view type should be returned, as an {@link Integer}
   *              value
   * @return The view type, which corresponds to the given tab, as an {@link Integer} value
   */
  public int getViewType(@NonNull final Tab tab, final int index) {
    return 0;
  }

  /**
   * Returns the number of view types, which are used by the decorator.
   *
   * @return The number of view types, which are used by the decorator, as an {@link Integer}
   * value. The number of view types must correspond to the number of distinct values, which are
   * returned by the <code>getViewType</code>-method
   */
  public int getViewTypeCount() {
    return 1;
  }

  /**
   * The method, which is invoked by a {@link TabSwitcher} to inflate the view, which should be
   * used to visualize a specific tab.
   *
   * @param inflater The inflater, which should be used to inflate the view, as an instance of the class
   *                 {@link LayoutInflater}. The inflater may not be null
   * @param parent   The parent view of the view, which should be inflated, as an instance of the class
   *                 {@link ViewGroup} or null, if no parent view is available
   * @param tab      The tab, which should be visualized, as an instance of the class {@link Tab}. The tab
   *                 may not be null
   * @param index    The index of the tab, which should be visualized, as an {@link Integer} value
   * @return The view, which has been inflated, as an instance of the class {@link View}. The view
   * may not be null
   */
  @NonNull
  public final View inflateView(@NonNull final LayoutInflater inflater,
                                @Nullable final ViewGroup parent, @NonNull final Tab tab,
                                final int index) {
    int viewType = getViewType(tab, index);
    return onInflateView(inflater, parent, viewType);
  }

  /**
   * The method, which is invoked by a {@link TabSwitcher} to apply the decorator. It initializes
   * the view holder pattern, which is provided by the decorator and then delegates the method
   * call to the decorator's custom implementation of the method <code>onShowTab(...):void</code>.
   *
   * @param context            The context, the tab switcher belongs to, as an instance of the class {@link
   *                           Context}. The context may not be null
   * @param tabSwitcher        The tab switcher, whose tabs are visualized by the decorator, as an instance of the
   *                           class {@link TabSwitcher}. The tab switcher may not be null
   * @param view               The view, which is used to visualize the tab, as an instance of the class {@link
   *                           View}. The view may not be null
   * @param tab                The tab, which should be visualized, as an instance of the class {@link Tab}. The tab
   *                           may not be null
   * @param index              The index of the tab, which should be visualized, as an {@link Integer} value
   * @param savedInstanceState The bundle, which has previously been used to save the state of the view as an
   *                           instance of the class {@link Bundle} or null, if no saved state is available
   */
  public final void applyDecorator(@NonNull final Context context,
                                   @NonNull final TabSwitcher tabSwitcher,
                                   @NonNull final View view, @NonNull final Tab tab,
                                   final int index, @Nullable final Bundle savedInstanceState) {
    setCurrentParentView(view);
    int viewType = getViewType(tab, index);

    if (savedInstanceState != null) {
      SparseArray<Parcelable> viewStates =
        savedInstanceState.getSparseParcelableArray(VIEW_HIERARCHY_STATE_EXTRA);

      if (viewStates != null) {
        view.restoreHierarchyState(viewStates);
      }
    }

    onShowTab(context, tabSwitcher, view, tab, index, viewType, savedInstanceState);
  }

  /**
   * The method, which is invoked by a {@link TabSwitcher} to save the current state of a tab. It
   * initializes the view holder pattern, which is provided by the decorator and then delegates
   * the method call to the decorator's custom implementation of the method
   * <code>onSaveInstanceState(...):void</code>.
   *
   * @param view  The view, which is used to visualize the tab, as an instance of the class {@link
   *              View}
   * @param tab   The tab, whose state should be saved, as an instance of the class {@link Tab}. The
   *              tab may not be null
   * @param index The index of the tab, whose state should be saved, as an {@link Integer} value
   * @return The bundle, which has been used to save the state, as an instance of the class {@link
   * Bundle}. The bundle may not be null
   */
  @NonNull
  public final Bundle saveInstanceState(@NonNull final View view, @NonNull final Tab tab,
                                        final int index) {
    setCurrentParentView(view);
    int viewType = getViewType(tab, index);
    Bundle outState = new Bundle();
    SparseArray<Parcelable> viewStates = new SparseArray<>();
    view.saveHierarchyState(viewStates);
    outState.putSparseParcelableArray(VIEW_HIERARCHY_STATE_EXTRA, viewStates);
    onSaveInstanceState(view, tab, index, viewType, outState);
    return outState;
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/TabSwitcherListener.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

/**
 * Defines the interface, a class, which should be notified about a tab switcher's events, must
 * implement.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public interface TabSwitcherListener {

  /**
   * The method, which is invoked, when the tab switcher has been shown.
   *
   * @param tabSwitcher The observed tab switcher as an instance of the class {@link TabSwitcher}. The tab
   *                    switcher may not be null
   */
  void onSwitcherShown(@NonNull TabSwitcher tabSwitcher);

  /**
   * The method, which is invoked, when the tab switcher has been hidden.
   *
   * @param tabSwitcher The observed tab switcher as an instance of the class {@link TabSwitcher}. The tab
   *                    switcher may not be null
   */
  void onSwitcherHidden(@NonNull TabSwitcher tabSwitcher);

  /**
   * The method, which is invoked, when the currently selected tab has been changed.
   *
   * @param tabSwitcher      The observed tab switcher as an instance of the class {@link TabSwitcher}. The tab
   *                         switcher may not be null
   * @param selectedTabIndex The index of the currently selected tab as an {@link Integer} value or -1, if the tab
   *                         switcher does not contain any tabs
   * @param selectedTab      The currently selected tab as an instance of the class {@link Tab} or null, if the
   *                         tab switcher does not contain any tabs
   */
  void onSelectionChanged(@NonNull TabSwitcher tabSwitcher, int selectedTabIndex,
                          @Nullable Tab selectedTab);

  /**
   * The method, which is invoked, when a tab has been added to the tab switcher.
   *
   * @param tabSwitcher The observed tab switcher as an instance of the class {@link TabSwitcher}. The tab
   *                    switcher may not be null
   * @param index       The index of the tab, which has been added, as an {@link Integer} value
   * @param tab         The tab, which has been added, as an instance of the class {@link Tab}. The tab may
   *                    not be null
   * @param animation   The animation, which has been used to add the tab, as an instance of the class {@link
   *                    Animation}. The animation may not be null
   */
  void onTabAdded(@NonNull TabSwitcher tabSwitcher, int index, @NonNull Tab tab,
                  @NonNull Animation animation);

  /**
   * The method, which is invoked, when a tab has been removed from the tab switcher.
   *
   * @param tabSwitcher The observed tab switcher as an instance of the class {@link TabSwitcher}. The tab
   *                    switcher may not be null
   * @param index       The index of the tab, which has been removed, as an {@link Integer} value
   * @param tab         The tab, which has been removed, as an instance of the class {@link Tab}. The tab may
   *                    not be null
   * @param animation   The animation, which has been used to remove the tab, as an instance of the class
   *                    {@link Animation}. The animation may not be null
   */
  void onTabRemoved(@NonNull TabSwitcher tabSwitcher, int index, @NonNull Tab tab,
                    @NonNull Animation animation);

  /**
   * The method, which is invoked, when all tabs have been removed from the tab switcher.
   *
   * @param tabSwitcher The observed tab switcher as an instance of the class {@link TabSwitcher}. The tab
   *                    switcher may not be null
   * @param tabs        An array, which contains the tabs, which have been removed, as an array of the type
   *                    {@link Tab} or an empty array, if no tabs have been removed
   * @param animation   The animation, which has been used to remove the tabs, as an instance of the class
   *                    {@link Animation}. The animation may not be null
   */
  void onAllTabsRemoved(@NonNull TabSwitcher tabSwitcher, @NonNull Tab[] tabs,
                        @NonNull Animation animation);

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/drawable/TabSwitcherDrawable.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.drawable;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.*;
import android.graphics.Paint.Align;
import android.graphics.drawable.Drawable;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;
import de.mrapp.android.tabswitcher.*;
import de.mrapp.android.util.ThemeUtil;

import static de.mrapp.android.util.Condition.ensureAtLeast;
import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A drawable, which allows to display the number of tabs, which are currently contained by a {@link
 * TabSwitcher}. It must be registered at a {@link TabSwitcher} instance in order to keep the
 * displayed label up to date. It therefore implements the interface {@link TabSwitcherListener}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class TabSwitcherDrawable extends Drawable implements TabSwitcherListener {

  /**
   * The size of the drawable in pixels.
   */
  private final int size;

  /**
   * The default text size of the displayed label in pixels.
   */
  private final int textSizeNormal;

  /**
   * The text size of the displayed label, which is used when displaying a value greater than 99,
   * in pixels.
   */
  private final int textSizeSmall;

  /**
   * The drawable, which is shown as the background.
   */
  private final Drawable background;

  /**
   * The paint, which is used to draw the drawable's label.
   */
  private final Paint paint;

  /**
   * The currently displayed label.
   */
  private String label;

  /**
   * Creates a new drawable, which allows to display the number of tabs, which are currently
   * contained by a {@link TabSwitcher}.
   *
   * @param context The context, which should be used by the drawable, as an instance of the class {@link
   *                Context}. The context may not be null
   */
  public TabSwitcherDrawable(@NonNull final Context context) {
    ensureNotNull(context, "The context may not be null");
    Resources resources = context.getResources();
    size = resources.getDimensionPixelSize(R.dimen.tab_switcher_drawable_size);
    textSizeNormal =
      resources.getDimensionPixelSize(R.dimen.tab_switcher_drawable_font_size_normal);
    textSizeSmall =
      resources.getDimensionPixelSize(R.dimen.tab_switcher_drawable_font_size_small);
    background =
      ContextCompat.getDrawable(context, R.drawable.tab_switcher_drawable_background)
        .mutate();
    paint = new Paint(Paint.ANTI_ALIAS_FLAG);
    paint.setColor(Color.WHITE);
    paint.setTextAlign(Align.CENTER);
    paint.setTextSize(textSizeNormal);
    paint.setTypeface(Typeface.create(Typeface.SANS_SERIF, Typeface.BOLD));
    label = Integer.toString(0);
    int tint = ThemeUtil.getColor(context, android.R.attr.textColorPrimary);
    setColorFilter(tint, PorterDuff.Mode.MULTIPLY);
  }

  /**
   * Updates the drawable to display a specific value.
   *
   * @param count The value, which should be displayed, as an {@link Integer} value. The value must be
   *              at least 0
   */
  public final void setCount(final int count) {
    ensureAtLeast(count, 0, "The count must be at least 0");
    label = Integer.toString(count);

    if (label.length() > 2) {
      label = "99+";
      paint.setTextSize(textSizeSmall);
    } else {
      paint.setTextSize(textSizeNormal);
    }

    invalidateSelf();
  }

  @Override
  public final void draw(@NonNull final Canvas canvas) {
    int width = canvas.getWidth();
    int height = canvas.getHeight();
    int intrinsicWidth = background.getIntrinsicWidth();
    int intrinsicHeight = background.getIntrinsicHeight();
    int left = (width / 2) - (intrinsicWidth / 2);
    int top = (height / 2) - (intrinsicHeight / 2);
    background.getIntrinsicWidth();
    background.setBounds(left, top, left + intrinsicWidth, top + intrinsicHeight);
    background.draw(canvas);
    float x = width / 2f;
    float y = (height / 2f) - ((paint.descent() + paint.ascent()) / 2f);
    canvas.drawText(label, x, y, paint);
  }

  @Override
  public final int getIntrinsicWidth() {
    return size;
  }

  @Override
  public final int getIntrinsicHeight() {
    return size;
  }

  @Override
  public final void setAlpha(final int alpha) {
    background.setAlpha(alpha);
    paint.setAlpha(alpha);
  }

  @Override
  public final void setColorFilter(@Nullable final ColorFilter colorFilter) {
    background.setColorFilter(colorFilter);
    paint.setColorFilter(colorFilter);
  }

  @Override
  public final int getOpacity() {
    return PixelFormat.TRANSLUCENT;
  }

  @Override
  public final void onSwitcherShown(@NonNull final TabSwitcher tabSwitcher) {

  }

  @Override
  public final void onSwitcherHidden(@NonNull final TabSwitcher tabSwitcher) {

  }

  @Override
  public final void onSelectionChanged(@NonNull final TabSwitcher tabSwitcher,
                                       final int selectedTabIndex,
                                       @Nullable final Tab selectedTab) {

  }

  @Override
  public final void onTabAdded(@NonNull final TabSwitcher tabSwitcher, final int index,
                               @NonNull final Tab tab, @NonNull final Animation animation) {
    setCount(tabSwitcher.getCount());
  }

  @Override
  public final void onTabRemoved(@NonNull final TabSwitcher tabSwitcher, final int index,
                                 @NonNull final Tab tab, @NonNull final Animation animation) {
    setCount(tabSwitcher.getCount());
  }

  @Override
  public final void onAllTabsRemoved(@NonNull final TabSwitcher tabSwitcher,
                                     @NonNull final Tab[] tab,
                                     @NonNull final Animation animation) {
    setCount(tabSwitcher.getCount());
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/iterator/AbstractTabItemIterator.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.iterator;

import androidx.annotation.NonNull;
import de.mrapp.android.tabswitcher.model.TabItem;

import static de.mrapp.android.util.Condition.ensureAtLeast;

/**
 * An abstract base class for all iterators, which allow to iterate items of the type {@link
 * TabItem}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public abstract class AbstractTabItemIterator implements java.util.Iterator<TabItem> {

  /**
   * An abstract base class of all builders, which allows to configure and create instances of the
   * class {@link AbstractTabItemIterator}.
   */
  public static abstract class AbstractBuilder<BuilderType extends AbstractBuilder<?, ProductType>, ProductType extends AbstractTabItemIterator> {

    /**
     * True, if the tabs should be iterated in reverse order, false otherwise.
     */
    protected boolean reverse;

    /**
     * The index of the first tab, which should be iterated.
     */
    protected int start;

    /**
     * Returns a reference to the builder itself. It is implicitly cast to the generic type
     * BuilderType.
     *
     * @return The builder as an instance of the generic type BuilderType
     */
    @SuppressWarnings("unchecked")
    private BuilderType self() {
      return (BuilderType) this;
    }

    /**
     * Creates a new builder, which allows to configure and create instances of the class {@link
     * AbstractTabItemIterator}.
     */
    protected AbstractBuilder() {
      reverse(false);
      start(-1);
    }

    /**
     * Creates the iterator, which has been configured by using the builder.
     *
     * @return The iterator, which has been created, as an instance of the class {@link
     * TabItemIterator}. The iterator may not be null
     */
    @NonNull
    public abstract ProductType create();

    /**
     * Sets, whether the tabs should be iterated in reverse order, or not.
     *
     * @param reverse True, if the tabs should be iterated in reverse order, false otherwise
     * @return The builder, this method has been called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public BuilderType reverse(final boolean reverse) {
      this.reverse = reverse;
      return self();
    }

    /**
     * Sets the index of the first tab, which should be iterated.
     *
     * @param start The index, which should be set, as an {@link Integer} value or -1, if all tabs
     *              should be iterated Builder}. The builder may not be null
     * @return The builder, this method has been called upon, as an instance of the generic type
     * BuilderType. The builder may not be null
     */
    @NonNull
    public BuilderType start(final int start) {
      ensureAtLeast(start, -1, "The start must be at least -1");
      this.start = start;
      return self();
    }

  }

  /**
   * True, if the tabs should be iterated in reverse order, false otherwise.
   */
  private boolean reverse;

  /**
   * The index of the next tab.
   */
  private int index;

  /**
   * The current tab item.
   */
  private TabItem current;

  /**
   * The previous tab item.
   */
  private TabItem previous;

  /**
   * The first tab item.
   */
  private TabItem first;

  /**
   * The method, which is invoked on subclasses in order to retrieve the total number of available
   * items.
   *
   * @return The total number of available items as an {@link Integer} value
   */
  public abstract int getCount();

  /**
   * The method, which is invoked on subclasses in order to retrieve the item, which corresponds
   * to a specific index.
   *
   * @param index The index of the item, which should be returned, as an {@link Integer} value
   * @return The item, which corresponds to the given index, as an instance of the class {@link
   * TabItem}. The tab item may not be null
   */
  @NonNull
  public abstract TabItem getItem(final int index);

  /**
   * Initializes the iterator.
   *
   * @param reverse True, if the tabs should be iterated in reverse order, false otherwise
   * @param start   The index of the first tab, which should be iterated, as an {@link Integer} value or
   *                -1, if all tabs should be iterated
   */
  protected final void initialize(final boolean reverse, final int start) {
    ensureAtLeast(start, -1, "The start must be at least -1");
    this.reverse = reverse;
    this.previous = null;
    this.index = start != -1 ? start : (reverse ? getCount() - 1 : 0);
    int previousIndex = reverse ? this.index + 1 : this.index - 1;

    if (previousIndex >= 0 && previousIndex < getCount()) {
      this.current = getItem(previousIndex);
    } else {
      this.current = null;
    }
  }

  /**
   * Returns the tab item, which corresponds to the first tab.
   *
   * @return The tab item, which corresponds to the first tab, as an instance of the class {@link
   * TabItem} or null, if no tabs are available
   */
  public final TabItem first() {
    return first;
  }

  /**
   * Returns the tab item, which corresponds to the previous tab.
   *
   * @return The tab item, which corresponds to the previous tab, as an instance of the class
   * {@link TabItem} or null, if no previous tab is available
   */
  public final TabItem previous() {
    return previous;
  }

  /**
   * Returns the tab item, which corresponds to the next tab.
   *
   * @return The tab item, which corresponds to the next tab, as an instance of the class {@link
   * TabItem} or null, if no next tab is available
   */
  public final TabItem peek() {
    return index >= 0 && index < getCount() ? getItem(index) : null;
  }

  @Override
  public final boolean hasNext() {
    if (reverse) {
      return index >= 0;
    } else {
      return getCount() - index >= 1;
    }
  }

  @Override
  public final TabItem next() {
    if (hasNext()) {
      previous = current;

      if (first == null) {
        first = current;
      }

      current = getItem(index);
      index += reverse ? -1 : 1;
      return current;
    }

    return null;
  }

}

```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/iterator/ArrayTabItemIterator.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.iterator;

import androidx.annotation.NonNull;
import de.mrapp.android.tabswitcher.Tab;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.util.view.AttachedViewRecycler;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * An iterator, which allows to iterate the tab items, which correspond to the tabs, which are
 * contained by an array.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class ArrayTabItemIterator extends AbstractTabItemIterator {

  /**
   * A builder, which allows to configure an create instances of the class {@link
   * ArrayTabItemIterator}.
   */
  public static class Builder extends AbstractBuilder<Builder, ArrayTabItemIterator> {

    /**
     * The view recycler, which allows to inflate the views, which are used to visualize the
     * tabs, which are iterated by the iterator, which is created by the builder.
     */
    private final AttachedViewRecycler<TabItem, ?> viewRecycler;

    /**
     * The array, which contains the tabs, which are iterated by the iterator, which is created
     * by the builder.
     */
    private final Tab[] array;

    /**
     * Creates a new builder, which allows to configure and create instances of the class {@link
     * ArrayTabItemIterator}.
     *
     * @param viewRecycler The view recycler, which allows to inflate the views, which are used to visualize
     *                     the tabs, which should be iterated by the iterator, as an instance of the class
     *                     AttachedViewRecycler. The view recycler may not be null
     * @param array        The array, which contains the tabs, which should be iterated by the iterator, as
     *                     an array of the type {@link Tab}. The array may not be null
     */
    public Builder(@NonNull final AttachedViewRecycler<TabItem, ?> viewRecycler,
                   @NonNull final Tab[] array) {
      ensureNotNull(viewRecycler, "The view recycler may not be null");
      ensureNotNull(array, "The array may not be null");
      this.viewRecycler = viewRecycler;
      this.array = array;
    }

    @NonNull
    @Override
    public ArrayTabItemIterator create() {
      return new ArrayTabItemIterator(viewRecycler, array, reverse, start);
    }

  }

  /**
   * The view recycler, which allows to inflate the views, which are used to visualize the
   * iterated tabs.
   */
  private final AttachedViewRecycler<TabItem, ?> viewRecycler;

  /**
   * The array, which contains the tabs, which are iterated by the iterator.
   */
  private final Tab[] array;

  /**
   * Creates a new iterator, which allows to iterate the tab items, whcih correspond to the tabs,
   * which are contained by an array.
   *
   * @param viewRecycler The view recycler, which allows to inflate the views, which are used to visualize the
   *                     iterated tabs, as an instance of the class AttachedViewRecycler. The view recycler
   *                     may not be null
   * @param array        The array, which contains the tabs, which should be iterated by the iterator, as an
   *                     array of the type {@link Tab}. The array may not be null
   * @param reverse      True, if the tabs should be iterated in reverse order, false otherwise
   * @param start        The index of the first tab, which should be iterated, as an {@link Integer} value or
   *                     -1, if all tabs should be iterated
   */
  private ArrayTabItemIterator(@NonNull final AttachedViewRecycler<TabItem, ?> viewRecycler,
                               @NonNull final Tab[] array, final boolean reverse,
                               final int start) {
    ensureNotNull(viewRecycler, "The view recycler may not be null");
    ensureNotNull(array, "The array may not be null");
    this.viewRecycler = viewRecycler;
    this.array = array;
    initialize(reverse, start);
  }

  @Override
  public final int getCount() {
    return array.length;
  }

  @NonNull
  @Override
  public final TabItem getItem(final int index) {
    return TabItem.create(viewRecycler, index, array[index]);
  }

}

```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/iterator/TabItemIterator.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.iterator;

import androidx.annotation.NonNull;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.model.Model;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.util.view.AttachedViewRecycler;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * An iterator, which allows to iterate the tab items, which correspond to the tabs of a {@link
 * TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class TabItemIterator extends AbstractTabItemIterator {

  /**
   * A builder, which allows to configure and create instances of the class {@link
   * TabItemIterator}.
   */
  public static class Builder extends AbstractBuilder<Builder, TabItemIterator> {

    /**
     * The model, which belongs to the tab switcher, whose tabs should be iterated by the
     * iterator, which is created by the builder.
     */
    private final Model model;

    /**
     * The view recycler, which allows to inflate the views, which are used to visualize the
     * tabs, which are iterated by the iterator, which is created by the builder.
     */
    private final AttachedViewRecycler<TabItem, ?> viewRecycler;

    /**
     * Creates a new builder, which allows to configure and create instances of the class {@link
     * TabItemIterator}.
     *
     * @param model        The model, which belongs to the tab switcher, whose tabs should be iterated by
     *                     the iterator, which is created by the builder, as an instance of the type {@link
     *                     Model}. The model may not be null
     * @param viewRecycler The view recycler, which allows to inflate the views, which are used to visualize
     *                     the tabs, which are iterated by the iterator, which is created by the builder, as
     *                     an instance of the class AttachedViewRecycler. The view recycler may not be null
     */
    public Builder(@NonNull final Model model,
                   @NonNull final AttachedViewRecycler<TabItem, ?> viewRecycler) {
      ensureNotNull(model, "The model may not be null");
      ensureNotNull(viewRecycler, "The view recycler may not be null");
      this.model = model;
      this.viewRecycler = viewRecycler;
    }

    @NonNull
    @Override
    public TabItemIterator create() {
      return new TabItemIterator(model, viewRecycler, reverse, start);
    }

  }

  /**
   * The model, which belongs to the tab switcher, whose tabs are iterated.
   */
  private final Model model;

  /**
   * The view recycler, which allows to inflated the views, which are used to visualize the
   * iterated tabs.
   */
  private final AttachedViewRecycler<TabItem, ?> viewRecycler;

  /**
   * Creates a new iterator, which allows to iterate the tab items, which correspond to the tabs
   * of a {@link TabSwitcher}.
   *
   * @param model        The model, which belongs to the tab switcher, whose tabs should be iterated, as an
   *                     instance of the type {@link Model}. The model may not be null
   * @param viewRecycler The view recycler, which allows to inflate the views, which are used to visualize the
   *                     iterated tabs, as an instance of the class AttachedViewRecycler. The view recycler
   *                     may not be null
   * @param reverse      True, if the tabs should be iterated in reverse order, false otherwise
   * @param start        The index of the first tab, which should be iterated, as an {@link Integer} value or
   *                     -1, if all tabs should be iterated
   */
  private TabItemIterator(@NonNull final Model model,
                          @NonNull final AttachedViewRecycler<TabItem, ?> viewRecycler,
                          final boolean reverse, final int start) {
    ensureNotNull(model, "The model may not be null");
    ensureNotNull(viewRecycler, "The view recycler may not be null");
    this.model = model;
    this.viewRecycler = viewRecycler;
    initialize(reverse, start);
  }

  @Override
  public final int getCount() {
    return model.getCount();
  }

  @NonNull
  @Override
  public final TabItem getItem(final int index) {
    return TabItem.create(model, viewRecycler, index);
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/AbstractDragHandler.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout;

import android.content.res.Resources;
import android.view.MotionEvent;
import android.view.VelocityTracker;
import android.view.ViewConfiguration;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import de.mrapp.android.tabswitcher.R;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.layout.Arithmetics.Axis;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.util.gesture.DragHelper;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * An abstract base class for all drag handlers, which allow to calculate the position and state of
 * tabs on touch events.
 *
 * @param <CallbackType> The type of the drag handler's callback
 * @author Michael Rapp
 * @since 0.1.0
 */
public abstract class AbstractDragHandler<CallbackType extends AbstractDragHandler.Callback> {

  /**
   * Contains all possible states of dragging gestures, which can be performed on a {@link
   * TabSwitcher}.
   */
  public enum DragState {

    /**
     * When no dragging gesture is being performed.
     */
    NONE,

    /**
     * When the tabs are dragged towards the start.
     */
    DRAG_TO_START,

    /**
     * When the tabs are dragged towards the end.
     */
    DRAG_TO_END,

    /**
     * When an overshoot at the start is being performed.
     */
    OVERSHOOT_START,

    /**
     * When an overshoot at the end is being performed.
     */
    OVERSHOOT_END,

    /**
     * When a tab is swiped.
     */
    SWIPE

  }

  /**
   * Defines the interface, a class, which should be notified about the events of a drag handler,
   * must implement.
   */
  public interface Callback {

    /**
     * The method, which is invoked in order to calculate the positions of all tabs, depending
     * on the current drag distance.
     *
     * @param dragState    The current drag state as a value of the enum {@link DragState}. The drag state
     *                     must either be {@link DragState#DRAG_TO_END} or {@link DragState#DRAG_TO_START}
     * @param dragDistance The current drag distance in pixels as a {@link Float} value
     * @return A drag state, which specifies whether the tabs are overshooting, or not. If the
     * tabs are overshooting, the drag state must be {@link DragState#OVERSHOOT_START} or {@link
     * DragState#OVERSHOOT_END}, null otherwise
     */
    @Nullable
    DragState onDrag(@NonNull DragState dragState, float dragDistance);

    /**
     * The method, which is invoked, when a tab has been clicked.
     *
     * @param tabItem The tab item, which corresponds to the tab, which has been clicked, as an
     *                instance of the class {@link TabItem}. The tab item may not be null
     */
    void onClick(@NonNull TabItem tabItem);

    /**
     * The method, which is invoked, when a fling has been triggered.
     *
     * @param distance The distance of the fling in pixels as a {@link Float} value
     * @param duration The duration of the fling in milliseconds as a {@link Long} value
     */
    void onFling(float distance, long duration);

    /**
     * The method, which is invoked, when a fling has been cancelled.
     */
    void onCancelFling();

    /**
     * The method, which is invoked, when an overshoot at the start should be reverted.
     */
    void onRevertStartOvershoot();

    /**
     * The method, which is invoked, when an overshoot at the end should be reverted.
     */
    void onRevertEndOvershoot();

    /**
     * The method, which is invoked, when a tab is swiped.
     *
     * @param tabItem  The tab item, which corresponds to the swiped tab, as an instance of the class
     *                 {@link TabItem}. The tab item may not be null
     * @param distance The distance, the tab is swiped by, in pixels as a {@link Float} value
     */
    void onSwipe(@NonNull TabItem tabItem, float distance);

    /**
     * The method, which is invoked, when swiping a tab ended.
     *
     * @param tabItem  The tab item, which corresponds to the swiped tab, as an instance of the class
     *                 {@link TabItem}. The tab item may not be null
     * @param remove   True, if the tab should be removed, false otherwise
     * @param velocity The velocity of the swipe gesture in pixels per second as a {@link Float} value
     */
    void onSwipeEnded(@NonNull TabItem tabItem, boolean remove, float velocity);

  }

  /**
   * The tab switcher, whose tabs' positions and states are calculated by the drag handler.
   */
  private final TabSwitcher tabSwitcher;

  /**
   * The arithmetics, which are used to calculate the positions, size and rotation of tabs.
   */
  private final Arithmetics arithmetics;

  /**
   * True, if tabs can be swiped on the orthogonal axis, false otherwise.
   */
  private final boolean swipeEnabled;

  /**
   * The drag helper, which is used to recognize drag gestures on the dragging axis.
   */
  private final DragHelper dragHelper;

  /**
   * The drag helper, which is used to recognize swipe gestures on the orthogonal axis.
   */
  private final DragHelper swipeDragHelper;

  /**
   * The minimum velocity, which must be reached by a drag gesture to start a fling animation.
   */
  private final float minFlingVelocity;

  /**
   * The velocity, which may be reached by a drag gesture at maximum to start a fling animation.
   */
  private final float maxFlingVelocity;

  /**
   * The velocity, which must be reached by a drag gesture in order to start a swipe animation.
   */
  private final float minSwipeVelocity;

  /**
   * The threshold, which must be reached until tabs are dragged, in pixels.
   */
  private int dragThreshold;

  /**
   * The velocity tracker, which is used to measure the velocity of dragging gestures.
   */
  private VelocityTracker velocityTracker;

  /**
   * The id of the pointer, which has been used to start the current drag gesture.
   */
  private int pointerId;

  /**
   * The currently swiped tab item.
   */
  private TabItem swipedTabItem;

  /**
   * The state of the currently performed drag gesture.
   */
  private DragState dragState;

  /**
   * The distance of the current drag gesture in pixels.
   */
  private float dragDistance;

  /**
   * The drag distance at which the start overshoot begins.
   */
  private float startOvershootThreshold;

  /**
   * The drag distance at which the end overshoot begins.
   */
  private float endOvershootThreshold;

  /**
   * The callback, which is notified about the drag handler's events.
   */
  private CallbackType callback;

  /**
   * Resets the drag handler to its previous state, when a drag gesture has ended.
   *
   * @param dragThreshold The drag threshold, which should be used to recognize drag gestures, in pixels as an
   *                      {@link Integer} value
   */
  private void resetDragging(final int dragThreshold) {
    if (this.velocityTracker != null) {
      this.velocityTracker.recycle();
      this.velocityTracker = null;
    }

    this.pointerId = -1;
    this.dragState = DragState.NONE;
    this.swipedTabItem = null;
    this.dragDistance = 0;
    this.startOvershootThreshold = -Float.MAX_VALUE;
    this.endOvershootThreshold = Float.MAX_VALUE;
    this.dragThreshold = dragThreshold;
    this.dragHelper.reset(dragThreshold);
    this.swipeDragHelper.reset();
  }

  /**
   * Handles, when a drag gesture has been started.
   *
   * @param event The motion event, which started the drag gesture, as an instance of the class {@link
   *              MotionEvent}. The motion event may not be null
   */
  private void handleDown(@NonNull final MotionEvent event) {
    pointerId = event.getPointerId(0);

    if (velocityTracker == null) {
      velocityTracker = VelocityTracker.obtain();
    } else {
      velocityTracker.clear();
    }

    velocityTracker.addMovement(event);
  }

  /**
   * Handles a click.
   *
   * @param event The motion event, which triggered the click, as an instance of the class {@link
   *              MotionEvent}. The motion event may not be null
   */
  private void handleClick(@NonNull final MotionEvent event) {
    TabItem tabItem = getFocusedTab(arithmetics.getPosition(Axis.DRAGGING_AXIS, event));

    if (tabItem != null) {
      notifyOnClick(tabItem);
    }
  }

  /**
   * Handles a fling gesture.
   *
   * @param event     The motion event, which triggered the fling gesture, as an instance of the class
   *                  {@link MotionEvent}. The motion event may not be null
   * @param dragState The current drag state, which determines the fling direction, as a value of the enum
   *                  {@link DragState}. The drag state may not be null
   */
  private void handleFling(@NonNull final MotionEvent event, @NonNull final DragState dragState) {
    int pointerId = event.getPointerId(0);
    velocityTracker.computeCurrentVelocity(1000, maxFlingVelocity);
    float flingVelocity = Math.abs(velocityTracker.getYVelocity(pointerId));

    if (flingVelocity > minFlingVelocity) {
      float flingDistance = 0.25f * flingVelocity;

      if (dragState == DragState.DRAG_TO_START) {
        flingDistance = -1 * flingDistance;
      }

      long duration = Math.round(Math.abs(flingDistance) / flingVelocity * 3000);
      notifyOnFling(flingDistance, duration);
    }
  }

  /**
   * Handles, when the tabs are overshooting.
   */
  private void handleOvershoot() {
    if (!dragHelper.isReset()) {
      dragHelper.reset(0);
      dragDistance = 0;
    }
  }

  /**
   * Notifies the callback in order to calculate the positions of all tabs, depending on the
   * current drag distance.
   *
   * @param dragState    The current drag state as a value of the enum {@link DragState}. The drag state must
   *                     either be {@link DragState#DRAG_TO_END} or {@link DragState#DRAG_TO_START}
   * @param dragDistance The current drag distance in pixels as a {@link Float} value
   * @return A drag state, which specifies whether the tabs are overshooting, or not. If the tabs
   * are overshooting, the drag state must be {@link DragState#OVERSHOOT_START} or {@link
   * DragState#OVERSHOOT_END}, null otherwise
   */
  private DragState notifyOnDrag(@NonNull final DragState dragState, final float dragDistance) {
    if (callback != null) {
      return callback.onDrag(dragState, dragDistance);
    }

    return null;
  }

  /**
   * Notifies the callback, that a tab has been clicked.
   *
   * @param tabItem The tab item, which corresponds to the tab, which has been clicked, as an instance of
   *                the class {@link TabItem}. The tab item may not be null
   */
  private void notifyOnClick(@NonNull final TabItem tabItem) {
    if (callback != null) {
      callback.onClick(tabItem);
    }
  }

  /**
   * Notifies the callback, that a fling has been triggered.
   *
   * @param distance The distance of the fling in pixels as a {@link Float} value
   * @param duration The duration of the fling in milliseconds as a {@link Long} value
   */
  private void notifyOnFling(final float distance, final long duration) {
    if (callback != null) {
      callback.onFling(distance, duration);
    }
  }

  /**
   * Notifies the callback, that a fling has been cancelled.
   */
  private void notifyOnCancelFling() {
    if (callback != null) {
      callback.onCancelFling();
    }
  }

  /**
   * Notifies the callback, that an overshoot at the start should be reverted.
   */
  private void notifyOnRevertStartOvershoot() {
    if (callback != null) {
      callback.onRevertStartOvershoot();
    }
  }

  /**
   * Notifies the callback, that an overshoot at the end should be reverted.
   */
  private void notifyOnRevertEndOvershoot() {
    if (callback != null) {
      callback.onRevertEndOvershoot();
    }
  }

  /**
   * Notifies the callback, that a tab is swiped.
   *
   * @param tabItem  The tab item, which corresponds to the swiped tab, as an instance of the class {@link
   *                 TabItem}. The tab item may not be null
   * @param distance The distance, the tab is swiped by, in pixels as a {@link Float} value
   */
  private void notifyOnSwipe(@NonNull final TabItem tabItem, final float distance) {
    if (callback != null) {
      callback.onSwipe(tabItem, distance);
    }
  }

  /**
   * Notifies the callback, that swiping a tab ended.
   *
   * @param tabItem  The tab item, which corresponds to the swiped tab, as an instance of the class {@link
   *                 TabItem}. The tab item may not be null
   * @param remove   True, if the tab should be removed, false otherwise
   * @param velocity The velocity of the swipe gesture in pixels per second as a {@link Float} value
   */
  private void notifyOnSwipeEnded(@NonNull final TabItem tabItem, final boolean remove,
                                  final float velocity) {
    if (callback != null) {
      callback.onSwipeEnded(tabItem, remove, velocity);
    }
  }

  /**
   * Returns the tab switcher, whose tabs' positions and states are calculated by the drag
   * handler.
   *
   * @return The tab switcher, whose tabs' positions and states are calculated by the drag
   * handler, as an instance of the class {@link TabSwitcher}. The tab switcher may not be null
   */
  @NonNull
  protected TabSwitcher getTabSwitcher() {
    return tabSwitcher;
  }

  /**
   * Returns the arithmetics, which are used to calculate the positions, size and rotation of
   * tabs.
   *
   * @return The arithmetics, which are used to calculate the positions, size and rotation of
   * tabs, as an instance of the type {@link Arithmetics}. The arithmetics may not be null
   */
  @NonNull
  protected Arithmetics getArithmetics() {
    return arithmetics;
  }

  /**
   * Returns the callback, which should be notified about the drag handler's events.
   *
   * @return The callback, which should be notified about the drag handler's events, as an
   * instance of the generic type CallbackType or null, if no callback should be notified
   */
  @Nullable
  protected CallbackType getCallback() {
    return callback;
  }

  /**
   * Creates a new drag handler, which allows to calculate the position and state of tabs on touch
   * events.
   *
   * @param tabSwitcher  The tab switcher, whose tabs' positions and states should be calculated by the drag
   *                     handler, as an instance of the class {@link TabSwitcher}. The tab switcher may not be
   *                     null
   * @param arithmetics  The arithmetics, which should be used to calculate the position, size and rotation of
   *                     tabs, as an instance of the type {@link Arithmetics}. The arithmetics may not be
   *                     null
   * @param swipeEnabled True, if tabs can be swiped on the orthogonal axis, false otherwise
   */
  public AbstractDragHandler(@NonNull final TabSwitcher tabSwitcher,
                             @NonNull final Arithmetics arithmetics, final boolean swipeEnabled) {
    ensureNotNull(tabSwitcher, "The tab switcher may not be null");
    ensureNotNull(arithmetics, "The arithmetics may not be null");
    this.tabSwitcher = tabSwitcher;
    this.arithmetics = arithmetics;
    this.swipeEnabled = swipeEnabled;
    this.dragHelper = new DragHelper(0);
    Resources resources = tabSwitcher.getResources();
    this.swipeDragHelper =
      new DragHelper(resources.getDimensionPixelSize(R.dimen.swipe_threshold));
    this.callback = null;
    ViewConfiguration configuration = ViewConfiguration.get(tabSwitcher.getContext());
    this.minFlingVelocity = configuration.getScaledMinimumFlingVelocity();
    this.maxFlingVelocity = configuration.getScaledMaximumFlingVelocity();
    this.minSwipeVelocity = resources.getDimensionPixelSize(R.dimen.min_swipe_velocity);
    resetDragging(resources.getDimensionPixelSize(R.dimen.drag_threshold));
  }

  /**
   * The method, which is invoked on implementing subclasses in order to retrieve the tab item,
   * which corresponds to the tab, which is focused when clicking/dragging at a specific position.
   *
   * @param position The position on the dragging axis in pixels as a {@link Float} value
   * @return The tab item, which corresponds to the focused tab, as an instance of the class
   * {@link TabItem} or null, if no tab is focused
   */
  protected abstract TabItem getFocusedTab(final float position);

  /**
   * The method, which is invoked on implementing subclasses, when the tabs are overshooting at
   * the start.
   *
   * @param dragPosition       The position of the pointer on the dragging axis in pixels as a {@link Float} value
   * @param overshootThreshold The position on the dragging axis, an overshoot at the start currently starts at, in
   *                           pixels as a {@link Float} value
   * @return The updated position on the dragging axis, an overshoot at the start starts at, in
   * pixels as a {@link Float} value
   */
  protected float onOvershootStart(final float dragPosition, final float overshootThreshold) {
    return overshootThreshold;
  }

  /**
   * The method, which is invoked on implementing subclasses, when the tabs are overshooting at
   * the end.
   *
   * @param dragPosition       The position of the pointer on the dragging axis in pixels as a {@link Float} value
   * @param overshootThreshold The position on the dragging axis, an overshoot at the end currently starts at, in
   *                           pixels as a {@link Float} value
   * @return The updated position on the dragging axis, an overshoot at the end starts at, in
   * pixels as a {@link Float} value
   */
  protected float onOvershootEnd(final float dragPosition, final float overshootThreshold) {
    return overshootThreshold;
  }

  /**
   * The method, which is invoked on implementing subclasses, when an overshoot has been reverted.
   */
  protected void onOvershootReverted() {

  }

  /**
   * The method, which invoked on implementing subclasses, when the drag handler has been reset.
   */
  protected void onReset() {

  }

  /**
   * Returns, whether the threshold of a swiped tab item, which causes the corresponding tab to be
   * removed, has been reached, or not.
   *
   * @param swipedTabItem The swiped tab item as an instance of the class {@link TabItem}. The tab item may not
   *                      be null
   * @return True, if the threshold has been reached, false otherwise
   */
  protected boolean isSwipeThresholdReached(@NonNull final TabItem swipedTabItem) {
    return false;
  }

  /**
   * Sets the callback, which should be notified about the drag handler's events.
   *
   * @param callback The callback, which should be set, as an instance of the generic type CallbackType or
   *                 null, if no callback should be notified
   */
  public final void setCallback(@Nullable final CallbackType callback) {
    this.callback = callback;
  }

  /**
   * Handles a touch event.
   *
   * @param event The event, which should be handled, as an instance of the class {@link MotionEvent}.
   *              The event may be not null
   * @return True, if the event has been handled, false otherwise
   */
  public final boolean handleTouchEvent(@NonNull final MotionEvent event) {
    ensureNotNull(event, "The motion event may not be null");

    if (tabSwitcher.isSwitcherShown() && !tabSwitcher.isEmpty()) {
      notifyOnCancelFling();

      switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
          handleDown(event);
          return true;
        case MotionEvent.ACTION_MOVE:
          if (!tabSwitcher.isAnimationRunning() && event.getPointerId(0) == pointerId) {
            if (velocityTracker == null) {
              velocityTracker = VelocityTracker.obtain();
            }

            velocityTracker.addMovement(event);
            handleDrag(arithmetics.getPosition(Axis.DRAGGING_AXIS, event),
              arithmetics.getPosition(Axis.ORTHOGONAL_AXIS, event));
          } else {
            handleRelease(null, dragThreshold);
            handleDown(event);
          }

          return true;
        case MotionEvent.ACTION_UP:
          if (!tabSwitcher.isAnimationRunning() && event.getPointerId(0) == pointerId) {
            handleRelease(event, dragThreshold);
          }

          return true;
        default:
          break;
      }
    }

    return false;
  }

  /**
   * Handles drag gestures.
   *
   * @param dragPosition       The position of the pointer on the dragging axis in pixels as a {@link Float} value
   * @param orthogonalPosition The position of the pointer of the orthogonal axis in pixels as a {@link Float}
   *                           value
   * @return True, if any tabs have been moved, false otherwise
   */
  public final boolean handleDrag(final float dragPosition, final float orthogonalPosition) {
    if (dragPosition <= startOvershootThreshold) {
      handleOvershoot();
      dragState = DragState.OVERSHOOT_START;
      startOvershootThreshold = onOvershootStart(dragPosition, startOvershootThreshold);
    } else if (dragPosition >= endOvershootThreshold) {
      handleOvershoot();
      dragState = DragState.OVERSHOOT_END;
      endOvershootThreshold = onOvershootEnd(dragPosition, endOvershootThreshold);
    } else {
      onOvershootReverted();
      float previousDistance = dragHelper.isReset() ? 0 : dragHelper.getDragDistance();
      dragHelper.update(dragPosition);

      if (swipeEnabled) {
        swipeDragHelper.update(orthogonalPosition);

        if (dragState == DragState.NONE && swipeDragHelper.hasThresholdBeenReached()) {
          TabItem tabItem = getFocusedTab(dragHelper.getDragStartPosition());

          if (tabItem != null) {
            dragState = DragState.SWIPE;
            swipedTabItem = tabItem;
          }
        }
      }

      if (dragState != DragState.SWIPE && dragHelper.hasThresholdBeenReached()) {
        if (dragState == DragState.OVERSHOOT_START) {
          dragState = DragState.DRAG_TO_END;
        } else if (dragState == DragState.OVERSHOOT_END) {
          dragState = DragState.DRAG_TO_START;
        } else {
          float dragDistance = dragHelper.getDragDistance();

          if (dragDistance == 0) {
            dragState = DragState.NONE;
          } else {
            dragState = previousDistance - dragDistance < 0 ? DragState.DRAG_TO_END :
              DragState.DRAG_TO_START;
          }
        }
      }

      if (dragState == DragState.SWIPE) {
        notifyOnSwipe(swipedTabItem, swipeDragHelper.getDragDistance());
      } else if (dragState != DragState.NONE) {
        float currentDragDistance = dragHelper.getDragDistance();
        float distance = currentDragDistance - dragDistance;
        dragDistance = currentDragDistance;
        DragState overshoot = notifyOnDrag(dragState, distance);

        if (overshoot == DragState.OVERSHOOT_END && (dragState == DragState.DRAG_TO_END ||
          dragState == DragState.OVERSHOOT_END)) {
          endOvershootThreshold = dragPosition;
          dragState = DragState.OVERSHOOT_END;
        } else if (overshoot == DragState.OVERSHOOT_START &&
          (dragState == DragState.DRAG_TO_START ||
            dragState == DragState.OVERSHOOT_START)) {
          startOvershootThreshold = dragPosition;
          dragState = DragState.OVERSHOOT_START;
        }

        return true;
      }
    }

    return false;
  }

  /**
   * Handles, when a drag gesture has been ended.
   *
   * @param event         The motion event, which ended the drag gesture, as an instance of the class {@link
   *                      MotionEvent} or null, if no fling animation should be triggered
   * @param dragThreshold The drag threshold, which should be used to recognize drag gestures, in pixels as an
   *                      {@link Integer} value
   */
  public final void handleRelease(@Nullable final MotionEvent event, final int dragThreshold) {
    if (dragState == DragState.SWIPE) {
      float swipeVelocity = 0;

      if (event != null && velocityTracker != null) {
        int pointerId = event.getPointerId(0);
        velocityTracker.computeCurrentVelocity(1000, maxFlingVelocity);
        swipeVelocity = Math.abs(velocityTracker.getXVelocity(pointerId));
      }

      boolean remove = swipedTabItem.getTab().isCloseable() &&
        (swipeVelocity >= minSwipeVelocity || isSwipeThresholdReached(swipedTabItem));
      notifyOnSwipeEnded(swipedTabItem, remove,
        swipeVelocity >= minSwipeVelocity ? swipeVelocity : 0);
    } else if (dragState == DragState.DRAG_TO_START || dragState == DragState.DRAG_TO_END) {
      if (event != null && velocityTracker != null && dragHelper.hasThresholdBeenReached()) {
        handleFling(event, dragState);
      }
    } else if (dragState == DragState.OVERSHOOT_END) {
      notifyOnRevertEndOvershoot();
    } else if (dragState == DragState.OVERSHOOT_START) {
      notifyOnRevertStartOvershoot();
    } else if (event != null) {
      handleClick(event);
    }

    resetDragging(dragThreshold);
  }

  /**
   * Resets the drag handler to its initial state.
   *
   * @param dragThreshold The drag threshold, which should be used to recognize drag gestures, in pixels as an
   *                      {@link Integer} value
   */
  public final void reset(final int dragThreshold) {
    resetDragging(dragThreshold);
    onReset();
  }

}

```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/AbstractTabSwitcherLayout.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout;

import android.animation.Animator;
import android.animation.Animator.AnimatorListener;
import android.animation.AnimatorListenerAdapter;
import android.content.Context;
import android.graphics.drawable.Drawable;
import android.view.Menu;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.view.animation.Animation;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Transformation;
import androidx.annotation.CallSuper;
import androidx.annotation.MenuRes;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.Toolbar;
import androidx.appcompat.widget.Toolbar.OnMenuItemClickListener;
import androidx.core.util.Pair;
import de.mrapp.android.tabswitcher.R;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.TabSwitcherDecorator;
import de.mrapp.android.tabswitcher.model.Model;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.tabswitcher.model.TabSwitcherModel;
import de.mrapp.android.util.ViewUtil;
import de.mrapp.android.util.logging.Logger;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * An abstract base class for all layouts, which implement the functionality of a {@link
 * TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public abstract class AbstractTabSwitcherLayout
  implements TabSwitcherLayout, OnGlobalLayoutListener, Model.Listener,
  AbstractDragHandler.Callback {

  /**
   * Defines the interface, a class, which should be notified about the events of a tab switcher
   * layout, must implement.
   */
  public interface Callback {

    /*
     * The method, which is invoked, when all animations have been ended.
     */
    void onAnimationsEnded();

  }

  /**
   * A layout listener, which unregisters itself from the observed view, when invoked. The
   * listener allows to encapsulate another listener, which is notified, when the listener is
   * invoked.
   */
  public static class LayoutListenerWrapper implements OnGlobalLayoutListener {

    /**
     * The observed view.
     */
    private final View view;

    /**
     * The encapsulated listener.
     */
    private final OnGlobalLayoutListener listener;

    /**
     * Creates a new layout listener, which unregisters itself from the observed view, when
     * invoked.
     *
     * @param view     The observed view as an instance of the class {@link View}. The view may not be
     *                 null
     * @param listener The listener, which should be encapsulated, as an instance of the type {@link
     *                 OnGlobalLayoutListener} or null, if no listener should be encapsulated
     */
    public LayoutListenerWrapper(@NonNull final View view,
                                 @Nullable final OnGlobalLayoutListener listener) {
      ensureNotNull(view, "The view may not be null");
      this.view = view;
      this.listener = listener;
    }

    @Override
    public void onGlobalLayout() {
      ViewUtil.removeOnGlobalLayoutListener(view.getViewTreeObserver(), this);

      if (listener != null) {
        listener.onGlobalLayout();
      }
    }

  }

  /**
   * A animation listener, which increases the number of running animations, when the observed
   * animation is started, and decreases the number of accordingly, when the animation is
   * finished. The listener allows to encapsulate another animation listener, which is notified
   * when the animation has been started, canceled or ended.
   */
  protected class AnimationListenerWrapper extends AnimatorListenerAdapter {

    /**
     * The encapsulated listener.
     */
    private final AnimatorListener listener;

    /**
     * Decreases the number of running animations and executes the next pending action, if no
     * running animations remain.
     */
    private void endAnimation() {
      if (--runningAnimations == 0) {
        notifyOnAnimationsEnded();
      }
    }

    /**
     * Creates a new animation listener, which increases the number of running animations, when
     * the observed animation is started, and decreases the number of accordingly, when the
     * animation is finished.
     *
     * @param listener The listener, which should be encapsulated, as an instance of the type {@link
     *                 AnimatorListener} or null, if no listener should be encapsulated
     */
    public AnimationListenerWrapper(@Nullable final AnimatorListener listener) {
      this.listener = listener;
    }

    @Override
    public void onAnimationStart(final Animator animation) {
      super.onAnimationStart(animation);
      runningAnimations++;

      if (listener != null) {
        listener.onAnimationStart(animation);
      }
    }

    @Override
    public void onAnimationEnd(final Animator animation) {
      super.onAnimationEnd(animation);

      if (listener != null) {
        listener.onAnimationEnd(animation);
      }

      endAnimation();
    }

    @Override
    public void onAnimationCancel(final Animator animation) {
      super.onAnimationCancel(animation);

      if (listener != null) {
        listener.onAnimationCancel(animation);
      }

      endAnimation();
    }

  }

  /**
   * An animation, which allows to fling the tabs.
   */
  private class FlingAnimation extends android.view.animation.Animation {

    /**
     * The distance, the tabs should be moved.
     */
    private final float distance;

    /**
     * Creates a new fling animation.
     *
     * @param distance The distance, the tabs should be moved, in pixels as a {@link Float} value
     */
    FlingAnimation(final float distance) {
      this.distance = distance;
    }

    @Override
    protected void applyTransformation(final float interpolatedTime, final Transformation t) {
      if (flingAnimation != null) {
        dragHandler.handleDrag(distance * interpolatedTime, 0);
      }
    }

  }

  /**
   * The tab switcher, the layout belongs to.
   */
  private final TabSwitcher tabSwitcher;

  /**
   * The model of the tab switcher, the layout belongs to.
   */
  private final TabSwitcherModel model;

  /**
   * The arithmetics, which are used by the layout.
   */
  private final Arithmetics arithmetics;

  /**
   * The threshold, which must be reached until tabs are dragged, in pixels.
   */
  private final int dragThreshold;

  /**
   * The logger, which is used for logging.
   */
  private final Logger logger;

  /**
   * The callback, which is notified about the layout's events.
   */
  private Callback callback;

  /**
   * The number of animations, which are currently running.
   */
  private int runningAnimations;

  /**
   * The animation, which is used to fling the tabs.
   */
  private android.view.animation.Animation flingAnimation;

  /**
   * The drag handler, which is used by the layout.
   */
  private AbstractDragHandler<?> dragHandler;

  /**
   * Adapts the visibility of the toolbars, which are shown, when the tab switcher is shown.
   */
  private void adaptToolbarVisibility() {
    Toolbar[] toolbars = getToolbars();

    if (toolbars != null) {
      for (Toolbar toolbar : toolbars) {
        toolbar.setVisibility(
          getModel().areToolbarsShown() ? View.VISIBLE : View.INVISIBLE);
      }
    }
  }

  /**
   * Adapts the title of the toolbar, which is shown, when the tab switcher is shown.
   */
  private void adaptToolbarTitle() {
    Toolbar[] toolbars = getToolbars();

    if (toolbars != null) {
      toolbars[0].setTitle(getModel().getToolbarTitle());
    }
  }

  /**
   * Adapts the navigation icon of the toolbar, which is shown, when the tab switcher is shown.
   */
  private void adaptToolbarNavigationIcon() {
    Toolbar[] toolbars = getToolbars();

    if (toolbars != null) {
      Toolbar toolbar = toolbars[0];
      toolbar.setNavigationIcon(getModel().getToolbarNavigationIcon());
      toolbar.setNavigationOnClickListener(getModel().getToolbarNavigationIconListener());
    }
  }

  /**
   * Inflates the menu of the toolbar, which is shown, when the tab switcher is shown.
   */
  private void inflateToolbarMenu() {
    Toolbar[] toolbars = getToolbars();
    int menuId = getModel().getToolbarMenuId();

    if (toolbars != null && menuId != -1) {
      Toolbar toolbar = toolbars.length > 1 ? toolbars[1] : toolbars[0];
      toolbar.inflateMenu(menuId);
      toolbar.setOnMenuItemClickListener(getModel().getToolbarMenuItemListener());
    }
  }

  /**
   * Creates and returns an animation listener, which allows to handle, when a fling animation
   * ended.
   *
   * @return The listener, which has been created, as an instance of the class {@link
   * Animation.AnimationListener}. The listener may not be null
   */
  @NonNull
  private Animation.AnimationListener createFlingAnimationListener() {
    return new Animation.AnimationListener() {

      @Override
      public void onAnimationStart(final android.view.animation.Animation animation) {

      }

      @Override
      public void onAnimationEnd(final android.view.animation.Animation animation) {
        dragHandler.handleRelease(null, dragThreshold);
        flingAnimation = null;
        notifyOnAnimationsEnded();
      }

      @Override
      public void onAnimationRepeat(final android.view.animation.Animation animation) {

      }

    };
  }

  /**
   * Notifies the callback, that all animations have been ended.
   */
  private void notifyOnAnimationsEnded() {
    if (callback != null) {
      callback.onAnimationsEnded();
    }
  }

  /**
   * Returns the tab switcher, the layout belongs to.
   *
   * @return The tab switcher, the layout belongs to, as an instance of the class {@link
   * TabSwitcher}. The tab switcher may not be null
   */
  @NonNull
  protected final TabSwitcher getTabSwitcher() {
    return tabSwitcher;
  }

  /**
   * Returns the model of the tab switcher, the layout belongs to.
   *
   * @return The model of the tab switcher, the layout belongs to, as an instance of the class
   * {@link TabSwitcherModel}. The model may not be null
   */
  @NonNull
  protected final TabSwitcherModel getModel() {
    return model;
  }

  /**
   * Returns the arithmetics, which are used by the layout.
   *
   * @return The arithmetics, which are used by the layout, as an instance of the type {@link
   * Arithmetics}. The arithmetics may not be null
   */
  @NonNull
  protected final Arithmetics getArithmetics() {
    return arithmetics;
  }

  /**
   * Returns the threshold, which must be reached until tabs are dragged.
   *
   * @return The threshold, which must be reached until tabs are dragged, in pixels as an {@link
   * Integer} value
   */
  protected final int getDragThreshold() {
    return dragThreshold;
  }

  /**
   * Returns the logger, which is used for logging.
   *
   * @return The logger, which is used for logging, as an instance of the class Logger. The logger
   * may not be null
   */
  @NonNull
  protected final Logger getLogger() {
    return logger;
  }

  /**
   * Returns the context, which is used by the layout.
   *
   * @return The context, which is used by the layout, as an instance of the class {@link
   * Context}. The context may not be null
   */
  @NonNull
  protected final Context getContext() {
    return tabSwitcher.getContext();
  }

  /**
   * Creates a new layout, which implements the functionality of a {@link TabSwitcher}.
   *
   * @param tabSwitcher The tab switcher, the layout belongs to, as an instance of the class {@link
   *                    TabSwitcher}. The tab switcher may not be null
   * @param model       The model of the tab switcher, the layout belongs to, as an instance of the class
   *                    {@link TabSwitcherModel}. The model may not be null
   * @param arithmetics The arithmetics, which should be used by the layout, as an instance of the type
   *                    {@link Arithmetics}. The arithmetics may not be null
   */
  public AbstractTabSwitcherLayout(@NonNull final TabSwitcher tabSwitcher,
                                   @NonNull final TabSwitcherModel model,
                                   @NonNull final Arithmetics arithmetics) {
    ensureNotNull(tabSwitcher, "The tab switcher may not be null");
    ensureNotNull(model, "The model may not be null");
    ensureNotNull(arithmetics, "The arithmetics may not be null");
    this.tabSwitcher = tabSwitcher;
    this.model = model;
    this.arithmetics = arithmetics;
    this.dragThreshold =
      getTabSwitcher().getResources().getDimensionPixelSize(R.dimen.drag_threshold);
    this.logger = new Logger(model.getLogLevel());
    this.callback = null;
    this.runningAnimations = 0;
    this.flingAnimation = null;
    this.dragHandler = null;
  }

  /**
   * The method, which is invoked on implementing subclasses in order to inflate the layout.
   *
   * @param tabsOnly True, if only the tabs should be inflated, false otherwise
   * @return The drag handler, which is used by the layout, as an instance of the class {@link
   * AbstractDragHandler} or null, if no drag handler is used
   */
  @Nullable
  protected abstract AbstractDragHandler<?> onInflateLayout(final boolean tabsOnly);

  /**
   * The method, which is invoked on implementing subclasses in order to detach the layout.
   *
   * @param tabsOnly True, if only the tabs should be detached, false otherwise
   * @return A pair, which contains the index of the first visible tab, as well as its current
   * position, as an instance of the class Pair or null, if the tab switcher is not shown
   */
  @Nullable
  protected abstract Pair<Integer, Float> onDetachLayout(final boolean tabsOnly);

  /**
   * Handles a touch event.
   *
   * @param event The touch event as an instance of the class {@link MotionEvent}. The touch event may
   *              not be null
   * @return True, if the event has been handled, false otherwise
   */
  public abstract boolean handleTouchEvent(@NonNull final MotionEvent event);

  /**
   * Inflates the layout.
   *
   * @param tabsOnly True, if only the tabs should be inflated, false otherwise
   */
  public final void inflateLayout(final boolean tabsOnly) {
    dragHandler = onInflateLayout(tabsOnly);

    if (!tabsOnly) {
      adaptToolbarVisibility();
      adaptToolbarTitle();
      adaptToolbarNavigationIcon();
      inflateToolbarMenu();
    }
  }

  /**
   * Detaches the layout.
   *
   * @param tabsOnly True, if only the tabs should be detached, false otherwise
   * @return A pair, which contains the index of the first visible tab, as well as its current
   * position, as an instance of the class Pair or null, if the tab switcher is not shown
   */
  @Nullable
  public final Pair<Integer, Float> detachLayout(final boolean tabsOnly) {
    return onDetachLayout(tabsOnly);
  }

  /**
   * Sets the callback, which should be notified about the layout's events.
   *
   * @param callback The callback, which should be set, as an instance of the type {@link Callback} or
   *                 null, if no callback should be notified
   */
  public final void setCallback(@Nullable final Callback callback) {
    this.callback = callback;
  }

  @Override
  public final boolean isAnimationRunning() {
    return runningAnimations > 0 || flingAnimation != null;
  }

  @Nullable
  @Override
  public final Menu getToolbarMenu() {
    Toolbar[] toolbars = getToolbars();

    if (toolbars != null) {
      Toolbar toolbar = toolbars.length > 1 ? toolbars[1] : toolbars[0];
      return toolbar.getMenu();
    }

    return null;
  }

  @CallSuper
  @Override
  public void onDecoratorChanged(@NonNull final TabSwitcherDecorator decorator) {
    detachLayout(true);
    onGlobalLayout();
  }

  @Override
  public final void onToolbarVisibilityChanged(final boolean visible) {
    adaptToolbarVisibility();
  }

  @Override
  public final void onToolbarTitleChanged(@Nullable final CharSequence title) {
    adaptToolbarTitle();
  }

  @Override
  public final void onToolbarNavigationIconChanged(@Nullable final Drawable icon,
                                                   @Nullable final OnClickListener listener) {
    adaptToolbarNavigationIcon();
  }

  @Override
  public final void onToolbarMenuInflated(@MenuRes final int resourceId,
                                          @Nullable final OnMenuItemClickListener listener) {
    inflateToolbarMenu();
  }

  @Override
  public final void onFling(final float distance, final long duration) {
    if (dragHandler != null) {
      flingAnimation = new FlingAnimation(distance);
      flingAnimation.setFillAfter(true);
      flingAnimation.setAnimationListener(createFlingAnimationListener());
      flingAnimation.setDuration(duration);
      flingAnimation.setInterpolator(new DecelerateInterpolator());
      getTabSwitcher().startAnimation(flingAnimation);
      logger.logVerbose(getClass(),
        "Started fling animation using a distance of " + distance +
          " pixels and a duration of " + duration + " milliseconds");
    }
  }

  @Override
  public final void onCancelFling() {
    if (flingAnimation != null) {
      flingAnimation.cancel();
      flingAnimation = null;
      dragHandler.handleRelease(null, dragThreshold);
      logger.logVerbose(getClass(), "Canceled fling animation");
    }
  }

  @Override
  public void onRevertStartOvershoot() {

  }

  @Override
  public void onRevertEndOvershoot() {

  }

  @Override
  public void onSwipe(@NonNull final TabItem tabItem, final float distance) {

  }

  @Override
  public void onSwipeEnded(@NonNull final TabItem tabItem, final boolean remove,
                           final float velocity) {

  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/AbstractTabViewHolder.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout;

import android.widget.ImageButton;
import android.widget.TextView;
import de.mrapp.android.tabswitcher.TabSwitcher;

/**
 * An abstract base class for all view holders, which allow to store references to the views, a tab
 * of a {@link TabSwitcher} consists of.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public abstract class AbstractTabViewHolder {

  /**
   * The text view, which is used to display the title of a tab.
   */
  public TextView titleTextView;

  /**
   * The close button of a tab.
   */
  public ImageButton closeButton;

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/Arithmetics.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */

package de.mrapp.android.tabswitcher.layout;

import android.view.MotionEvent;
import android.view.View;
import android.view.ViewPropertyAnimator;
import androidx.annotation.NonNull;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.layout.AbstractDragHandler.DragState;

/**
 * Defines the interface, a class, which provides methods, which allow to calculate the position,
 * size and rotation of a {@link TabSwitcher}'s children, must implement.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public interface Arithmetics {

  /**
   * Contains all axes on which the tabs of a {@link TabSwitcher} can be moved.
   */
  enum Axis {

    /**
     * The axis on which a tab is moved when dragging it.
     */
    DRAGGING_AXIS,

    /**
     * The axis on which a tab is moved, when it is added to or removed from the switcher.
     */
    ORTHOGONAL_AXIS,

    /**
     * The horizontal axis.
     */
    X_AXIS,

    /**
     * The vertical axis.
     */
    Y_AXIS

  }

  /**
   * Returns the position of a motion event on a specific axis.
   *
   * @param axis  The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param event The motion event, whose position should be returned, as an instance of the class
   *              {@link MotionEvent}. The motion event may not be null
   * @return The position of the given motion event on the given axis as a {@link Float} value
   */
  float getPosition(@NonNull Axis axis, @NonNull MotionEvent event);

  /**
   * Returns the position of a view on a specific axis.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view The view, whose position should be returned, as an instance of the class {@link
   *             View}. The view may not be null
   * @return The position of the given view on the given axis as a {@link Float} value
   */
  float getPosition(@NonNull Axis axis, @NonNull View view);

  /**
   * Sets the position of a view on a specific axis.
   *
   * @param axis     The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view     The view, whose position should be set, as an instance of the class {@link View}. The
   *                 view may not be null
   * @param position The position, which should be set, as a {@link Float} value
   */
  void setPosition(@NonNull Axis axis, @NonNull View view, float position);

  /**
   * Animates the position of a view on a specific axis.
   *
   * @param axis           The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param animator       The animator, which should be used to animate the position, as an instance of the
   *                       class {@link ViewPropertyAnimator}. The animator may not be null
   * @param view           The view, whose position should be animated, as an instance of the class {@link
   *                       View}. The view may not be null
   * @param position       The position, which should be set by the animation, as a {@link Float} value
   * @param includePadding True, if the view's padding should be taken into account, false otherwise
   */
  void animatePosition(@NonNull Axis axis, @NonNull ViewPropertyAnimator animator,
                       @NonNull View view, float position, boolean includePadding);

  /**
   * Returns the padding of a view on a specific axis and using a specific gravity.
   *
   * @param axis    The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param gravity The gravity as an {@link Integer} value. The gravity must be
   *                <code>Gravity.START</code> or <code>Gravity.END</code>
   * @param view    The view, whose padding should be returned, as an instance of the class {@link View}.
   *                The view may not be null
   * @return The padding of the given view on the given axis and using the given gravity as an
   * {@link Integer} value
   */
  int getPadding(@NonNull Axis axis, int gravity, @NonNull View view);

  /**
   * Returns the scale of a view, depending on its margin.
   *
   * @param view           The view, whose scale should be returned, as an instance of the class {@link View}.
   *                       The view may not be null
   * @param includePadding True, if the view's padding should be taken into account as well, false otherwise
   * @return The scale of the given view as a {@link Float} value
   */
  float getScale(@NonNull final View view, final boolean includePadding);

  /**
   * Sets the scale of a view on a specific axis.
   *
   * @param axis  The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view  The view, whose scale should be set, as an instance of the class {@link View}. The
   *              view may not be null
   * @param scale The scale, which should be set, as a {@link Float} value
   */
  void setScale(@NonNull Axis axis, @NonNull View view, float scale);

  /**
   * Animates the scale of a view on a specific axis.
   *
   * @param axis     The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param animator The animator, which should be used to animate the scale, as an instance of the class
   *                 {@link ViewPropertyAnimator}. The animator may not be null
   * @param scale    The scale, which should be set by the animation, as a {@link Float} value
   */
  void animateScale(@NonNull Axis axis, @NonNull ViewPropertyAnimator animator, float scale);

  /**
   * Returns the size of a view on a specific axis.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view The view, whose size should be returned, as an instance of the class {@link View}.
   *             The view may not be null
   * @return The size of the given view on the given axis as a {@link Float} value
   */
  float getSize(@NonNull Axis axis, @NonNull View view);

  /**
   * Returns the size of the container, which contains the tab switcher's tabs, on a specific
   * axis. By default, the padding and the size of the toolbars are included.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @return The size of the container, which contains the tab switcher's tabs, on the given axis
   * as a {@link Float} value
   */
  float getTabContainerSize(@NonNull Axis axis);

  /**
   * Returns the size of the container, which contains the tab switcher's tabs, on a specific
   * axis.
   *
   * @param axis           The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param includePadding True, if the padding and the size of the toolbars should be included, false
   *                       otherwise
   * @return The size of the container, which contains the tab switcher's tabs, on the given axis
   * as a {@link Float} value
   */
  float getTabContainerSize(@NonNull Axis axis, boolean includePadding);

  /**
   * Returns the pivot of a view on a specific axis, depending on the current drag state.
   *
   * @param axis      The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view      The view, whose pivot should be returned, as an instance of the class {@link View}.
   *                  The view may not be null
   * @param dragState The current drag state as a value of the enum {@link DragState}. The drag state may
   *                  not be null
   * @return The pivot of the given view on the given axis as a {@link Float} value
   */
  float getPivot(@NonNull Axis axis, @NonNull View view, @NonNull DragState dragState);

  /**
   * Sets the pivot of a view on a specific axis.
   *
   * @param axis  The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view  The view, whose pivot should be set, as an instance of the class {@link View}. The
   *              view may not be null
   * @param pivot The pivot, which should be set, as a {@link Float} value
   */
  void setPivot(@NonNull Axis axis, @NonNull View view, float pivot);

  /**
   * Returns the rotation of a view on a specific axis.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view The view, whose rotation should be returned, as an instance of the class {@link
   *             View}. The view may not be null
   * @return The rotation of the given view on the given axis as a {@link Float} value
   */
  float getRotation(@NonNull Axis axis, @NonNull View view);

  /**
   * Sets the rotation of a view on a specific axis.
   *
   * @param axis  The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view  The view, whose rotation should be set, as an instance of the class {@link View}. The
   *              view may not be null
   * @param angle The rotation, which should be set, as a {@link Float} value
   */
  void setRotation(@NonNull Axis axis, @NonNull View view, float angle);

  /**
   * Animates the rotation of a view on a specific axis.
   *
   * @param axis     The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param animator The animator, should be used to animate the rotation, as an instance of the class
   *                 {@link ViewPropertyAnimator}. The animator may not be null
   * @param angle    The rotation, which should be set by the animation, as a {@link Float} value
   */
  void animateRotation(@NonNull Axis axis, @NonNull ViewPropertyAnimator animator, float angle);

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/ChildRecyclerAdapter.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout;

import android.content.Context;
import android.os.Bundle;
import android.util.SparseArray;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import de.mrapp.android.tabswitcher.Tab;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.TabSwitcherDecorator;
import de.mrapp.android.tabswitcher.model.Restorable;
import de.mrapp.android.util.view.AbstractViewRecycler;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A view recycler adapter, which allows to inflate the views, which are used to visualize the child
 * views of the tabs of a {@link TabSwitcher}, by encapsulating a {@link TabSwitcherDecorator}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class ChildRecyclerAdapter extends AbstractViewRecycler.Adapter<Tab, Void>
  implements Restorable {

  /**
   * The name of the extra, which is used to store the saved instance states of previously removed
   * child views within a bundle.
   */
  private static final String SAVED_INSTANCE_STATES_EXTRA =
    ChildRecyclerAdapter.class.getName() + "::SavedInstanceStates";

  /**
   * The tab switcher, which contains the tabs, the child views, which are inflated by the
   * adapter, correspond to.
   */
  private final TabSwitcher tabSwitcher;

  /**
   * The decorator, which is used to inflate the child views.
   */
  private final TabSwitcherDecorator decorator;

  /**
   * A sparse array, which manages the saved instance states of previously removed child views.
   */
  private SparseArray<Bundle> savedInstanceStates;

  /**
   * Creates a new view recycler adapter, which allows to inflate the views, which are used to
   * visualize the child views of the tabs of a {@link TabSwitcher}, by encapsulating a {@link
   * TabSwitcherDecorator}.
   *
   * @param tabSwitcher The tab switcher, which contains the tabs, the child views, which are inflated by the
   *                    adapter, correspond to, as an instance of the class {@link TabSwitcher}. The tab
   *                    switcher may not be null
   * @param decorator   The decorator, which should be used to inflate the child views, as an instance of the
   *                    class {@link TabSwitcherDecorator}. The decorator may not be null
   */
  public ChildRecyclerAdapter(@NonNull final TabSwitcher tabSwitcher,
                              @NonNull final TabSwitcherDecorator decorator) {
    ensureNotNull(tabSwitcher, "The tab switcher may not be null");
    ensureNotNull(decorator, "The decorator may not be null");
    this.tabSwitcher = tabSwitcher;
    this.decorator = decorator;
    this.savedInstanceStates = new SparseArray<>();
  }

  @NonNull
  @Override
  public final View onInflateView(@NonNull final LayoutInflater inflater,
                                  @Nullable final ViewGroup parent, @NonNull final Tab item,
                                  final int viewType, @NonNull final Void... params) {
    int index = tabSwitcher.indexOf(item);
    return decorator.inflateView(inflater, parent, item, index);
  }

  @Override
  public final void onShowView(@NonNull final Context context, @NonNull final View view,
                               @NonNull final Tab item, final boolean inflated,
                               @NonNull final Void... params) {
    int index = tabSwitcher.indexOf(item);
    Bundle savedInstanceState = savedInstanceStates.get(item.hashCode());
    decorator.applyDecorator(context, tabSwitcher, view, item, index, savedInstanceState);
  }

  @Override
  public final void onRemoveView(@NonNull final View view, @NonNull final Tab item) {
    int index = tabSwitcher.indexOf(item);
    Bundle outState = decorator.saveInstanceState(view, item, index);
    savedInstanceStates.put(item.hashCode(), outState);
  }

  @Override
  public final int getViewTypeCount() {
    return decorator.getViewTypeCount();
  }

  @Override
  public final int getViewType(@NonNull final Tab item) {
    int index = tabSwitcher.indexOf(item);
    return decorator.getViewType(item, index);
  }

  @Override
  public final void saveInstanceState(@NonNull final Bundle outState) {
    outState.putSparseParcelableArray(SAVED_INSTANCE_STATES_EXTRA, savedInstanceStates);
  }

  @Override
  public final void restoreInstanceState(@Nullable final Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      savedInstanceStates =
        savedInstanceState.getSparseParcelableArray(SAVED_INSTANCE_STATES_EXTRA);
    }
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/TabSwitcherLayout.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout;

import android.view.Menu;
import android.view.ViewGroup;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.Toolbar;
import de.mrapp.android.tabswitcher.TabSwitcher;

/**
 * Defines the interface, a layout, which implements the functionality of a {@link TabSwitcher},
 * must implement.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public interface TabSwitcherLayout {

  /**
   * Returns, whether an animation is currently running, or not.
   *
   * @return True, if an animation is currently running, false otherwise
   */
  boolean isAnimationRunning();

  /**
   * Returns the view group, which contains the tab switcher's tabs.
   *
   * @return The view group, which contains the tab switcher's tabs, as an instance of the class
   * {@link ViewGroup} or null, if the view has not been laid out yet
   */
  @Nullable
  ViewGroup getTabContainer();

  /**
   * Returns the toolbars, which are shown, when the tab switcher is shown. When using the
   * smartphone layout, only one toolbar is shown. When using the tablet layout, a primary and
   * secondary toolbar is shown. In such case, the first index of the returned array corresponds
   * to the primary toolbar.
   *
   * @return An array, which contains the toolbars, which are shown, when the tab switcher is
   * shown, as an array of the type Toolbar or null, if the view has not been laid out yet
   */
  @Nullable
  Toolbar[] getToolbars();

  /**
   * Returns the menu of the toolbar, which is shown, when the tab switcher is shown. When using
   * the tablet layout, the menu corresponds to the secondary toolbar.
   *
   * @return The menu of the toolbar as an instance of the type {@link Menu} or null, if the view
   * has not been laid out yet
   */
  @Nullable
  Menu getToolbarMenu();

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/phone/PhoneArithmetics.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout.phone;

import android.content.res.Resources;
import android.view.*;
import android.widget.FrameLayout;
import androidx.annotation.NonNull;
import androidx.appcompat.widget.Toolbar;
import de.mrapp.android.tabswitcher.Layout;
import de.mrapp.android.tabswitcher.R;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.layout.AbstractDragHandler.DragState;
import de.mrapp.android.tabswitcher.layout.Arithmetics;

import static de.mrapp.android.util.Condition.ensureNotNull;
import static de.mrapp.android.util.Condition.ensureTrue;

/**
 * Provides methods, which allow to calculate the position, size and rotation of a {@link
 * TabSwitcher}'s children, when using the smartphone layout.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class PhoneArithmetics implements Arithmetics {

  /**
   * The tab switcher, the arithmetics are calculated for.
   */
  private final TabSwitcher tabSwitcher;

  /**
   * The height of a tab's title container in pixels.
   */
  private final int tabTitleContainerHeight;

  /**
   * The inset of tabs in pixels.
   */
  private final int tabInset;

  /**
   * The number of tabs, which are contained by a stack.
   */
  private final int stackedTabCount;

  /**
   * The space between tabs, which are part of a stack, in pixels.
   */
  private final float stackedTabSpacing;

  /**
   * The pivot when overshooting at the end.
   */
  private final float endOvershootPivot;

  /**
   * Modifies a specific axis depending on the orientation of the tab switcher.
   *
   * @param axis The original axis as a value of the enum {@link Axis}. The axis may not be null
   * @return The orientation invariant axis as a value of the enum {@link Axis}. The orientation
   * invariant axis may not be null
   */
  @NonNull
  private Axis getOrientationInvariantAxis(@NonNull final Axis axis) {
    if (axis == Axis.Y_AXIS) {
      return Axis.DRAGGING_AXIS;
    } else if (axis == Axis.X_AXIS) {
      return Axis.ORTHOGONAL_AXIS;
    } else if (tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE) {
      return axis == Axis.DRAGGING_AXIS ? Axis.ORTHOGONAL_AXIS : Axis.DRAGGING_AXIS;
    } else {
      return axis;
    }
  }

  /**
   * Returns the default pivot of a view on a specific axis.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view The view, whose pivot should be returned, as an instance of the class {@link View}.
   *             The view may not be null
   * @return The pivot of the given view on the given axis as a {@link Float} value
   */
  private float getDefaultPivot(@NonNull final Axis axis, @NonNull final View view) {
    if (axis == Axis.DRAGGING_AXIS || axis == Axis.Y_AXIS) {
      return tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE ? getSize(axis, view) / 2f : 0;
    } else {
      return tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE ? 0 : getSize(axis, view) / 2f;
    }
  }

  /**
   * Returns the pivot of a view on a specific axis, when it is swiped.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view The view, whose pivot should be returned, as an instance of the class {@link View}.
   *             The view may not be null
   * @return The pivot of the given view on the given axis as a {@link Float} value
   */
  private float getPivotWhenSwiping(@NonNull final Axis axis, @NonNull final View view) {
    if (axis == Axis.DRAGGING_AXIS || axis == Axis.Y_AXIS) {
      return endOvershootPivot;
    } else {
      return getDefaultPivot(axis, view);
    }
  }

  /**
   * Returns the pivot of a view on a specific axis, when overshooting at the start.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view The view, whose pivot should be returned, as an instance of the class {@link View}.
   *             The view may not be null
   * @return The pivot of the given view on the given axis as a {@link Float} value
   */
  private float getPivotWhenOvershootingAtStart(@NonNull final Axis axis,
                                                @NonNull final View view) {
    return getSize(axis, view) / 2f;
  }

  /**
   * Returns the pivot of a view on a specific axis, when overshooting at the end.
   *
   * @param axis The axis as a value of the enum {@link Axis}. The axis may not be null
   * @param view The view, whose pivot should be returned, as an instance of the class {@link View}.
   *             The view may not be null
   * @return The pivot of the given view on the given axis as a {@link Float} value
   */
  private float getPivotWhenOvershootingAtEnd(@NonNull final Axis axis,
                                              @NonNull final View view) {
    if (axis == Axis.DRAGGING_AXIS || axis == Axis.Y_AXIS) {
      return tabSwitcher.getCount() > 1 ? endOvershootPivot : getSize(axis, view) / 2f;
    } else {
      return getSize(axis, view) / 2f;
    }
  }

  /**
   * Creates a new class, which provides methods, which allow to calculate the position, size and
   * rotation of a {@link TabSwitcher}'s children.
   *
   * @param tabSwitcher The tab switcher, the arithmetics should be calculated for, as an instance of the
   *                    class {@link TabSwitcher}. The tab switcher may not be null
   */
  public PhoneArithmetics(@NonNull final TabSwitcher tabSwitcher) {
    ensureNotNull(tabSwitcher, "The tab switcher may not be null");
    this.tabSwitcher = tabSwitcher;
    Resources resources = tabSwitcher.getResources();
    this.tabTitleContainerHeight =
      resources.getDimensionPixelSize(R.dimen.tab_title_container_height);
    this.tabInset = resources.getDimensionPixelSize(R.dimen.tab_inset);
    this.stackedTabCount = resources.getInteger(R.integer.stacked_tab_count);
    this.stackedTabSpacing = resources.getDimensionPixelSize(R.dimen.stacked_tab_spacing);
    this.endOvershootPivot = resources.getDimensionPixelSize(R.dimen.end_overshoot_pivot);
  }

  @Override
  public final float getPosition(@NonNull final Axis axis, @NonNull final MotionEvent event) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(event, "The motion event may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      return event.getY();
    } else {
      return event.getX();
    }
  }

  @Override
  public final float getPosition(@NonNull final Axis axis, @NonNull final View view) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      Toolbar[] toolbars = tabSwitcher.getToolbars();
      return view.getY() - (tabSwitcher.areToolbarsShown() && tabSwitcher.isSwitcherShown() &&
        toolbars != null ? toolbars[0].getHeight() - tabInset : 0) -
        getPadding(axis, Gravity.START, tabSwitcher);
    } else {
      FrameLayout.LayoutParams layoutParams =
        (FrameLayout.LayoutParams) view.getLayoutParams();
      return view.getX() - layoutParams.leftMargin - tabSwitcher.getPaddingLeft() / 2f +
        tabSwitcher.getPaddingRight() / 2f +
        (tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE &&
          tabSwitcher.isSwitcherShown() ?
          stackedTabCount * stackedTabSpacing / 2f : 0);
    }
  }

  @Override
  public final void setPosition(@NonNull final Axis axis, @NonNull final View view,
                                final float position) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      Toolbar[] toolbars = tabSwitcher.getToolbars();
      view.setY((tabSwitcher.areToolbarsShown() && tabSwitcher.isSwitcherShown() &&
        toolbars != null ? toolbars[0].getHeight() - tabInset : 0) +
        getPadding(axis, Gravity.START, tabSwitcher) + position);
    } else {
      FrameLayout.LayoutParams layoutParams =
        (FrameLayout.LayoutParams) view.getLayoutParams();
      view.setX(position + layoutParams.leftMargin + tabSwitcher.getPaddingLeft() / 2f -
        tabSwitcher.getPaddingRight() / 2f -
        (tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE &&
          tabSwitcher.isSwitcherShown() ?
          stackedTabCount * stackedTabSpacing / 2f : 0));
    }
  }

  @Override
  public final void animatePosition(@NonNull final Axis axis,
                                    @NonNull final ViewPropertyAnimator animator,
                                    @NonNull final View view, final float position,
                                    final boolean includePadding) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(animator, "The animator may not be null");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      Toolbar[] toolbars = tabSwitcher.getToolbars();
      animator.y((tabSwitcher.areToolbarsShown() && tabSwitcher.isSwitcherShown() &&
        toolbars != null ? toolbars[0].getHeight() - tabInset : 0) +
        (includePadding ? getPadding(axis, Gravity.START, tabSwitcher) : 0) + position);
    } else {
      FrameLayout.LayoutParams layoutParams =
        (FrameLayout.LayoutParams) view.getLayoutParams();
      animator.x(position + layoutParams.leftMargin + (includePadding ?
        tabSwitcher.getPaddingLeft() / 2f - tabSwitcher.getPaddingRight() / 2f : 0) -
        (tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE &&
          tabSwitcher.isSwitcherShown() ?
          stackedTabCount * stackedTabSpacing / 2f : 0));
    }
  }

  @Override
  public final int getPadding(@NonNull final Axis axis, final int gravity,
                              @NonNull final View view) {
    ensureNotNull(axis, "The axis may not be null");
    ensureTrue(gravity == Gravity.START || gravity == Gravity.END, "Invalid gravity");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      return gravity == Gravity.START ? view.getPaddingTop() : view.getPaddingBottom();
    } else {
      return gravity == Gravity.START ? view.getPaddingLeft() : view.getPaddingRight();
    }
  }

  @Override
  public final float getScale(@NonNull final View view, final boolean includePadding) {
    ensureNotNull(view, "The view may not be null");
    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams();
    float width = view.getWidth();
    float targetWidth = width + layoutParams.leftMargin + layoutParams.rightMargin -
      (includePadding ? tabSwitcher.getPaddingLeft() + tabSwitcher.getPaddingRight() :
        0) - (tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE ?
      stackedTabCount * stackedTabSpacing : 0);
    return targetWidth / width;
  }

  @Override
  public final void setScale(@NonNull final Axis axis, @NonNull final View view,
                             final float scale) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      view.setScaleY(scale);
    } else {
      view.setScaleX(scale);
    }
  }

  @Override
  public final void animateScale(@NonNull final Axis axis,
                                 @NonNull final ViewPropertyAnimator animator,
                                 final float scale) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(animator, "The animator may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      animator.scaleY(scale);
    } else {
      animator.scaleX(scale);
    }
  }

  @Override
  public final float getSize(@NonNull final Axis axis, @NonNull final View view) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      return view.getHeight() * getScale(view, false);
    } else {
      return view.getWidth() * getScale(view, false);
    }
  }

  @Override
  public final float getTabContainerSize(@NonNull final Axis axis) {
    return getTabContainerSize(axis, true);
  }

  @Override
  public final float getTabContainerSize(@NonNull final Axis axis, final boolean includePadding) {
    ensureNotNull(axis, "The axis may not be null");
    ViewGroup tabContainer = tabSwitcher.getTabContainer();
    assert tabContainer != null;
    FrameLayout.LayoutParams layoutParams =
      (FrameLayout.LayoutParams) tabContainer.getLayoutParams();
    int padding = !includePadding ? (getPadding(axis, Gravity.START, tabSwitcher) +
      getPadding(axis, Gravity.END, tabSwitcher)) : 0;
    Toolbar[] toolbars = tabSwitcher.getToolbars();

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      int toolbarSize =
        !includePadding && tabSwitcher.areToolbarsShown() && toolbars != null ?
          toolbars[0].getHeight() - tabInset : 0;
      return tabContainer.getHeight() - layoutParams.topMargin - layoutParams.bottomMargin -
        padding - toolbarSize;
    } else {
      return tabContainer.getWidth() - layoutParams.leftMargin - layoutParams.rightMargin -
        padding;
    }
  }

  @Override
  public final float getPivot(@NonNull final Axis axis, @NonNull final View view,
                              @NonNull final DragState dragState) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");
    ensureNotNull(dragState, "The drag state may not be null");

    if (dragState == DragState.SWIPE) {
      return getPivotWhenSwiping(axis, view);
    } else if (dragState == DragState.OVERSHOOT_START) {
      return getPivotWhenOvershootingAtStart(axis, view);
    } else if (dragState == DragState.OVERSHOOT_END) {
      return getPivotWhenOvershootingAtEnd(axis, view);
    } else {
      return getDefaultPivot(axis, view);
    }
  }

  @Override
  public final void setPivot(@NonNull final Axis axis, @NonNull final View view,
                             final float pivot) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");
    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams();

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      float newPivot = pivot - layoutParams.topMargin - tabTitleContainerHeight;
      view.setTranslationY(view.getTranslationY() +
        (view.getPivotY() - newPivot) * (1 - view.getScaleY()));
      view.setPivotY(newPivot);
    } else {
      float newPivot = pivot - layoutParams.leftMargin;
      view.setTranslationX(view.getTranslationX() +
        (view.getPivotX() - newPivot) * (1 - view.getScaleX()));
      view.setPivotX(newPivot);
    }
  }

  @Override
  public final float getRotation(@NonNull final Axis axis, @NonNull final View view) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      return view.getRotationY();
    } else {
      return view.getRotationX();
    }
  }

  @Override
  public final void setRotation(@NonNull final Axis axis, @NonNull final View view,
                                final float angle) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(view, "The view may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      view.setRotationY(
        tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE ? -1 * angle : angle);
    } else {
      view.setRotationX(
        tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE ? -1 * angle : angle);
    }
  }

  @Override
  public final void animateRotation(@NonNull final Axis axis,
                                    @NonNull final ViewPropertyAnimator animator,
                                    final float angle) {
    ensureNotNull(axis, "The axis may not be null");
    ensureNotNull(animator, "The animator may not be null");

    if (getOrientationInvariantAxis(axis) == Axis.DRAGGING_AXIS) {
      animator.rotationY(
        tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE ? -1 * angle : angle);
    } else {
      animator.rotationX(
        tabSwitcher.getLayout() == Layout.PHONE_LANDSCAPE ? -1 * angle : angle);
    }
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/phone/PhoneDragHandler.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout.phone;

import android.content.res.Resources;
import android.view.Gravity;
import android.view.View;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.Toolbar;
import de.mrapp.android.tabswitcher.Layout;
import de.mrapp.android.tabswitcher.R;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.iterator.AbstractTabItemIterator;
import de.mrapp.android.tabswitcher.iterator.TabItemIterator;
import de.mrapp.android.tabswitcher.layout.AbstractDragHandler;
import de.mrapp.android.tabswitcher.layout.Arithmetics;
import de.mrapp.android.tabswitcher.layout.Arithmetics.Axis;
import de.mrapp.android.tabswitcher.model.State;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.util.gesture.DragHelper;
import de.mrapp.android.util.view.AttachedViewRecycler;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A drag handler, which allows to calculate the position and state of tabs on touch events, when
 * using the smartphone layout.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class PhoneDragHandler extends AbstractDragHandler<PhoneDragHandler.Callback> {

  /**
   * Defines the interface, a class, which should be notified about the events of a drag handler,
   * must implement.
   */
  public interface Callback extends AbstractDragHandler.Callback {

    /**
     * The method, which is invoked, when tabs are overshooting at the start.
     *
     * @param position The position of the first tab in pixels as a {@link Float} value
     */
    void onStartOvershoot(float position);

    /**
     * The method, which is invoked, when the tabs should be tilted when overshooting at the
     * start.
     *
     * @param angle The angle, the tabs should be tilted by, in degrees as a {@link Float} value
     */
    void onTiltOnStartOvershoot(float angle);

    /**
     * The method, which is invoked, when the tabs should be tilted when overshooting at the
     * end.
     *
     * @param angle The angle, the tabs should be tilted by, in degrees as a {@link Float} value
     */
    void onTiltOnEndOvershoot(float angle);

  }

  /**
   * The view recycler, which allows to inflate the views, which are used to visualize the tabs,
   * whose positions and states are calculated by the drag handler.
   */
  private final AttachedViewRecycler<TabItem, ?> viewRecycler;

  /**
   * The drag helper, which is used to recognize drag gestures when overshooting.
   */
  private final DragHelper overshootDragHelper;

  /**
   * The maximum overshoot distance in pixels.
   */
  private final int maxOvershootDistance;

  /**
   * The maximum angle, tabs can be rotated by, when overshooting at the start, in degrees.
   */
  private final float maxStartOvershootAngle;

  /**
   * The maximum angle, tabs can be rotated by, when overshooting at the end, in degrees.
   */
  private final float maxEndOvershootAngle;

  /**
   * The number of tabs, which are contained by a stack.
   */
  private final int stackedTabCount;

  /**
   * The inset of tabs in pixels.
   */
  private final int tabInset;

  /**
   * Notifies the callback, that tabs are overshooting at the start.
   *
   * @param position The position of the first tab in pixels as a {@link Float} value
   */
  private void notifyOnStartOvershoot(final float position) {
    if (getCallback() != null) {
      getCallback().onStartOvershoot(position);
    }
  }

  /**
   * Notifies the callback, that the tabs should be tilted when overshooting at the start.
   *
   * @param angle The angle, the tabs should be tilted by, in degrees as a {@link Float} value
   */
  private void notifyOnTiltOnStartOvershoot(final float angle) {
    if (getCallback() != null) {
      getCallback().onTiltOnStartOvershoot(angle);
    }
  }

  /**
   * Notifies the callback, that the tabs should be titled when overshooting at the end.
   *
   * @param angle The angle, the tabs should be tilted by, in degrees as a {@link Float} value
   */
  private void notifyOnTiltOnEndOvershoot(final float angle) {
    if (getCallback() != null) {
      getCallback().onTiltOnEndOvershoot(angle);
    }
  }

  /**
   * Creates a new drag handler, which allows to calculate the position and state of tabs on touch
   * events, when using the smartphone layout.
   *
   * @param tabSwitcher  The tab switcher, whose tabs' positions and states should be calculated by the drag
   *                     handler, as an instance of the class {@link TabSwitcher}. The tab switcher may not be
   *                     null
   * @param arithmetics  The arithmetics, which should be used to calculate the position, size and rotation of
   *                     tabs, as an instance of the type {@link Arithmetics}. The arithmetics may not be
   *                     null
   * @param viewRecycler The view recycler, which allows to inflate the views, which are used to visualize the
   *                     tabs, whose positions and states should be calculated by the tab switcher, as an
   *                     instance of the class AttachedViewRecycler. The view recycler may not be null
   */
  public PhoneDragHandler(@NonNull final TabSwitcher tabSwitcher,
                          @NonNull final Arithmetics arithmetics,
                          @NonNull final AttachedViewRecycler<TabItem, ?> viewRecycler) {
    super(tabSwitcher, arithmetics, true);
    ensureNotNull(viewRecycler, "The view recycler may not be null");
    this.viewRecycler = viewRecycler;
    this.overshootDragHelper = new DragHelper(0);
    Resources resources = tabSwitcher.getResources();
    this.tabInset = resources.getDimensionPixelSize(R.dimen.tab_inset);
    this.stackedTabCount = resources.getInteger(R.integer.stacked_tab_count);
    this.maxOvershootDistance = resources.getDimensionPixelSize(R.dimen.max_overshoot_distance);
    this.maxStartOvershootAngle = resources.getInteger(R.integer.max_start_overshoot_angle);
    this.maxEndOvershootAngle = resources.getInteger(R.integer.max_end_overshoot_angle);
  }

  @Override
  @Nullable
  protected final TabItem getFocusedTab(final float position) {
    AbstractTabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.getTag().getState() == State.FLOATING ||
        tabItem.getTag().getState() == State.STACKED_START_ATOP ||
        tabItem.getTag().getState() == State.STACKED_START) {
        View view = tabItem.getView();
        Toolbar[] toolbars = getTabSwitcher().getToolbars();
        float toolbarHeight = getTabSwitcher().getLayout() != Layout.PHONE_LANDSCAPE &&
          getTabSwitcher().areToolbarsShown() && toolbars != null ?
          toolbars[0].getHeight() - tabInset : 0;
        float viewPosition =
          getArithmetics().getPosition(Axis.DRAGGING_AXIS, view) + toolbarHeight +
            getArithmetics().getPadding(Axis.DRAGGING_AXIS, Gravity.START,
              getTabSwitcher());

        if (viewPosition <= position) {
          return tabItem;
        }
      }
    }

    return null;
  }

  @Override
  protected final float onOvershootStart(final float dragPosition,
                                         final float overshootThreshold) {
    float result = overshootThreshold;
    overshootDragHelper.update(dragPosition);
    float overshootDistance = overshootDragHelper.getDragDistance();

    if (overshootDistance < 0) {
      float absOvershootDistance = Math.abs(overshootDistance);
      float startOvershootDistance =
        getTabSwitcher().getCount() >= stackedTabCount ? maxOvershootDistance :
          (getTabSwitcher().getCount() > 1 ? (float) maxOvershootDistance /
            (float) getTabSwitcher().getCount() : 0);

      if (absOvershootDistance <= startOvershootDistance) {
        float ratio =
          Math.max(0, Math.min(1, absOvershootDistance / startOvershootDistance));
        AbstractTabItemIterator iterator =
          new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
        TabItem tabItem = iterator.getItem(0);
        float currentPosition = tabItem.getTag().getPosition();
        float position = currentPosition - (currentPosition * ratio);
        notifyOnStartOvershoot(position);
      } else {
        float ratio =
          (absOvershootDistance - startOvershootDistance) / maxOvershootDistance;

        if (ratio >= 1) {
          overshootDragHelper.setMinDragDistance(overshootDistance);
          result = dragPosition + maxOvershootDistance + startOvershootDistance;
        }

        notifyOnTiltOnStartOvershoot(
          Math.max(0, Math.min(1, ratio)) * maxStartOvershootAngle);
      }
    }

    return result;
  }

  @Override
  protected final float onOvershootEnd(final float dragPosition, final float overshootThreshold) {
    float result = overshootThreshold;
    overshootDragHelper.update(dragPosition);
    float overshootDistance = overshootDragHelper.getDragDistance();
    float ratio = overshootDistance / maxOvershootDistance;

    if (ratio >= 1) {
      overshootDragHelper.setMaxDragDistance(overshootDistance);
      result = dragPosition - maxOvershootDistance;
    }

    notifyOnTiltOnEndOvershoot(Math.max(0, Math.min(1, ratio)) *
      -(getTabSwitcher().getCount() > 1 ? maxEndOvershootAngle : maxStartOvershootAngle));
    return result;
  }

  @Override
  protected final void onOvershootReverted() {
    overshootDragHelper.reset();
  }

  @Override
  protected final void onReset() {
    overshootDragHelper.reset();
  }

  @Override
  protected final boolean isSwipeThresholdReached(@NonNull final TabItem swipedTabItem) {
    View view = swipedTabItem.getView();
    return Math.abs(getArithmetics().getPosition(Axis.ORTHOGONAL_AXIS, view)) >
      getArithmetics().getTabContainerSize(Axis.ORTHOGONAL_AXIS) / 2f;
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/phone/PhoneRecyclerAdapter.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout.phone;

import android.content.Context;
import android.content.res.ColorStateList;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.PorterDuff;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import android.widget.FrameLayout.LayoutParams;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.TextView;
import androidx.annotation.MenuRes;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.Toolbar.OnMenuItemClickListener;
import androidx.core.content.ContextCompat;
import androidx.core.util.Pair;
import de.mrapp.android.tabswitcher.*;
import de.mrapp.android.tabswitcher.iterator.AbstractTabItemIterator;
import de.mrapp.android.tabswitcher.iterator.TabItemIterator;
import de.mrapp.android.tabswitcher.model.Model;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.tabswitcher.model.TabSwitcherModel;
import de.mrapp.android.util.ViewUtil;
import de.mrapp.android.util.logging.LogLevel;
import de.mrapp.android.util.multithreading.AbstractDataBinder;
import de.mrapp.android.util.view.AbstractViewRecycler;
import de.mrapp.android.util.view.AttachedViewRecycler;
import de.mrapp.android.util.view.ViewRecycler;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A view recycler adapter, which allows to inflate the views, which are used to visualize the tabs
 * of a {@link TabSwitcher}, when using the smartphone layout.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class PhoneRecyclerAdapter extends AbstractViewRecycler.Adapter<TabItem, Integer>
  implements Tab.Callback, Model.Listener,
  AbstractDataBinder.Listener<Bitmap, Tab, ImageView, TabItem> {

  /**
   * The tab switcher, the tabs belong to.
   */
  private final TabSwitcher tabSwitcher;

  /**
   * The model, which belongs to the tab switcher.
   */
  private final TabSwitcherModel model;

  /**
   * The view recycler, which allows to inflate the child views of tabs.
   */
  private final ViewRecycler<Tab, Void> childViewRecycler;

  /**
   * The data binder, which allows to render previews of tabs.
   */
  private final AbstractDataBinder<Bitmap, Tab, ImageView, TabItem> dataBinder;

  /**
   * The inset of tabs in pixels.
   */
  private final int tabInset;

  /**
   * The width of the border, which is shown around the preview of tabs, in pixels.
   */
  private final int tabBorderWidth;

  /**
   * The height of the view group, which contains a tab's title and close button, in pixels.
   */
  private final int tabTitleContainerHeight;

  /**
   * The default background color of tabs.
   */
  private final int tabBackgroundColor;

  /**
   * The default text color of a tab's title.
   */
  private final int tabTitleTextColor;

  /**
   * The view recycler, the adapter is bound to.
   */
  private AttachedViewRecycler<TabItem, Integer> viewRecycler;

  /**
   * Inflates the child view of a tab and adds it to the view hierarchy.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose child view should be inflated, as
   *                an instance of the class {@link TabItem}. The tab item may not be null
   */
  private void addChildView(@NonNull final TabItem tabItem) {
    PhoneTabViewHolder viewHolder = tabItem.getViewHolder();
    View view = viewHolder.child;
    Tab tab = tabItem.getTab();

    if (view == null) {
      ViewGroup parent = viewHolder.childContainer;
      Pair<View, ?> pair = childViewRecycler.inflate(tab, parent);
      view = pair.first;
      LayoutParams layoutParams =
        new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
      layoutParams.setMargins(model.getPaddingLeft(), model.getPaddingTop(),
        model.getPaddingRight(), model.getPaddingBottom());
      parent.addView(view, 0, layoutParams);
      viewHolder.child = view;
    } else {
      childViewRecycler.getAdapter().onShowView(model.getContext(), view, tab, false);
    }

    viewHolder.previewImageView.setVisibility(View.GONE);
    viewHolder.previewImageView.setImageBitmap(null);
    viewHolder.borderView.setVisibility(View.GONE);
  }

  /**
   * Renders and displays the child view of a tab.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose preview should be rendered, as an
   *                instance of the class {@link TabItem}. The tab item may not be null
   */
  private void renderChildView(@NonNull final TabItem tabItem) {
    Tab tab = tabItem.getTab();
    PhoneTabViewHolder viewHolder = tabItem.getViewHolder();
    viewHolder.borderView.setVisibility(View.VISIBLE);

    if (viewHolder.child != null) {
      childViewRecycler.getAdapter().onRemoveView(viewHolder.child, tab);
      dataBinder.load(tab, viewHolder.previewImageView, false, tabItem);
      removeChildView(viewHolder, tab);
    } else {
      dataBinder.load(tab, viewHolder.previewImageView, tabItem);
    }
  }

  /**
   * Removes the child of a tab from its parent.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The tab, whose child should be removed, as an instance of the class {@link Tab}. The
   *                   tab may not be null
   */
  private void removeChildView(@NonNull final PhoneTabViewHolder viewHolder,
                               @NonNull final Tab tab) {
    if (viewHolder.childContainer.getChildCount() > 2) {
      viewHolder.childContainer.removeViewAt(0);
    }

    viewHolder.child = null;
    childViewRecycler.remove(tab);
  }

  /**
   * Adapts the log level.
   */
  private void adaptLogLevel() {
    dataBinder.setLogLevel(model.getLogLevel());
  }

  /**
   * Adapts the title of a tab.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The tab, whose title should be adapted, as an instance of the class {@link Tab}. The
   *                   tab may not be null
   */
  private void adaptTitle(@NonNull final PhoneTabViewHolder viewHolder, @NonNull final Tab tab) {
    viewHolder.titleTextView.setText(tab.getTitle());
  }

  /**
   * Adapts the icon of a tab.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The icon, whose icon should be adapted, as an instance of the class {@link Tab}. The
   *                   tab may not be null
   */
  private void adaptIcon(@NonNull final PhoneTabViewHolder viewHolder, @NonNull final Tab tab) {
    Drawable icon = tab.getIcon(model.getContext());
    viewHolder.titleTextView
      .setCompoundDrawablesWithIntrinsicBounds(icon != null ? icon : model.getTabIcon(),
        null, null, null);
  }

  /**
   * Adapts the visibility of a tab's close button.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The icon, whose close button should be adapted, as an instance of the class {@link
   *                   Tab}. The tab may not be null
   */
  private void adaptCloseButton(@NonNull final PhoneTabViewHolder viewHolder,
                                @NonNull final Tab tab) {
    viewHolder.closeButton.setVisibility(tab.isCloseable() ? View.VISIBLE : View.GONE);
    viewHolder.closeButton.setOnClickListener(
      tab.isCloseable() ? createCloseButtonClickListener(viewHolder.closeButton, tab) :
        null);
  }

  /**
   * Adapts the icon of a tab's close button.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The icon, whose icon hould be adapted, as an instance of the class {@link Tab}. The
   *                   tab may not be null
   */
  private void adaptCloseButtonIcon(@NonNull final PhoneTabViewHolder viewHolder,
                                    @NonNull final Tab tab) {
    Drawable icon = tab.getCloseButtonIcon(model.getContext());

    if (icon == null) {
      icon = model.getTabCloseButtonIcon();
    }

    if (icon != null) {
      viewHolder.closeButton.setImageDrawable(icon);
    } else {
      viewHolder.closeButton.setImageResource(R.drawable.ic_close_tab_18dp);
    }
  }

  /**
   * Creates and returns a listener, which allows to close a specific tab, when its close button
   * is clicked.
   *
   * @param closeButton The tab's close button as an instance of the class {@link ImageButton}. The button
   *                    may not be null
   * @param tab         The tab, which should be closed, as an instance of the class {@link Tab}. The tab may
   *                    not be null
   * @return The listener, which has been created, as an instance of the class {@link
   * OnClickListener}. The listener may not be null
   */
  @NonNull
  private OnClickListener createCloseButtonClickListener(@NonNull final ImageButton closeButton,
                                                         @NonNull final Tab tab) {
    return new OnClickListener() {

      @Override
      public void onClick(final View v) {
        if (notifyOnCloseTab(tab)) {
          closeButton.setOnClickListener(null);
          tabSwitcher.removeTab(tab);
        }
      }

    };
  }

  /**
   * Notifies all listeners, that a tab is about to be closed by clicking its close button.
   *
   * @param tab The tab, which is about to be closed, as an instance of the class {@link Tab}. The
   *            tab may not be null
   * @return True, if the tab should be closed, false otherwise
   */
  private boolean notifyOnCloseTab(@NonNull final Tab tab) {
    boolean result = true;

    for (TabCloseListener listener : model.getTabCloseListeners()) {
      result &= listener.onCloseTab(tabSwitcher, tab);
    }

    return result;
  }

  /**
   * Adapts the background color of a tab.
   *
   * @param view       The view, which is used to visualize the tab, as an instance of the class {@link
   *                   View}. The view may not be null
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The tab, whose background color should be adapted, as an instance of the class {@link
   *                   Tab}. The tab may not be null
   */
  private void adaptBackgroundColor(@NonNull final View view,
                                    @NonNull final PhoneTabViewHolder viewHolder,
                                    @NonNull final Tab tab) {
    ColorStateList colorStateList =
      tab.getBackgroundColor() != null ? tab.getBackgroundColor() :
        model.getTabBackgroundColor();
    int color = tabBackgroundColor;

    if (colorStateList != null) {
      int[] stateSet =
        model.getSelectedTab() == tab ? new int[]{android.R.attr.state_selected} :
          new int[]{};
      color = colorStateList.getColorForState(stateSet, colorStateList.getDefaultColor());
    }

    Drawable background = view.getBackground();
    background.setColorFilter(color, PorterDuff.Mode.MULTIPLY);
    Drawable border = viewHolder.borderView.getBackground();
    border.setColorFilter(color, PorterDuff.Mode.MULTIPLY);
  }

  /**
   * Adapts the text color of a tab's title.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The tab, whose text color should be adapted, as an instance of the class {@link Tab}.
   *                   The tab may not be null
   */
  private void adaptTitleTextColor(@NonNull final PhoneTabViewHolder viewHolder,
                                   @NonNull final Tab tab) {
    ColorStateList colorStateList = tab.getTitleTextColor() != null ? tab.getTitleTextColor() :
      model.getTabTitleTextColor();

    if (colorStateList != null) {
      viewHolder.titleTextView.setTextColor(colorStateList);
    } else {
      viewHolder.titleTextView.setTextColor(tabTitleTextColor);
    }
  }

  /**
   * Adapts the selection state of a tab's views.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   * @param tab        The tab, whose selection state should be adapted, as an instance of the class {@link
   *                   Tab}. The tab may not be null
   */
  private void adaptSelectionState(@NonNull final PhoneTabViewHolder viewHolder,
                                   @NonNull final Tab tab) {
    boolean selected = model.getSelectedTab() == tab;
    viewHolder.titleTextView.setSelected(selected);
    viewHolder.closeButton.setSelected(selected);
  }

  /**
   * Adapts the appearance of all currently inflated tabs, depending on whether they are currently
   * selected, or not.
   */
  private void adaptAllSelectionStates() {
    AbstractTabItemIterator iterator =
      new TabItemIterator.Builder(model, viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        Tab tab = tabItem.getTab();
        PhoneTabViewHolder viewHolder = tabItem.getViewHolder();
        adaptSelectionState(viewHolder, tab);
        adaptBackgroundColor(tabItem.getView(), viewHolder, tab);
      }
    }
  }

  /**
   * Adapts the padding of a tab.
   *
   * @param viewHolder The view holder, which stores references to the tab's views, as an instance of the
   *                   class {@link PhoneTabViewHolder}. The view holder may not be null
   */
  private void adaptPadding(@NonNull final PhoneTabViewHolder viewHolder) {
    if (viewHolder.child != null) {
      LayoutParams childLayoutParams = (LayoutParams) viewHolder.child.getLayoutParams();
      childLayoutParams.setMargins(model.getPaddingLeft(), model.getPaddingTop(),
        model.getPaddingRight(), model.getPaddingBottom());
    }

    LayoutParams previewLayoutParams =
      (LayoutParams) viewHolder.previewImageView.getLayoutParams();
    previewLayoutParams
      .setMargins(model.getPaddingLeft(), model.getPaddingTop(), model.getPaddingRight(),
        model.getPaddingBottom());
  }

  /**
   * Returns the tab item, which corresponds to a specific tab.
   *
   * @param tab The tab, whose tab item should be returned, as an instance of the class {@link Tab}.
   *            The tab may not be null
   * @return The tab item, which corresponds to the given tab, as an instance of the class {@link
   * TabItem} or null, if no view, which visualizes the tab, is currently inflated
   */
  @Nullable
  private TabItem getTabItem(@NonNull final Tab tab) {
    ensureNotNull(viewRecycler, "No view recycler has been set", IllegalStateException.class);
    int index = model.indexOf(tab);

    if (index != -1) {
      TabItem tabItem = TabItem.create(model, viewRecycler, index);

      if (tabItem.isInflated()) {
        return tabItem;
      }
    }

    return null;
  }

  /**
   * Creates a new view recycler adapter, which allows to inflate the views, which are used to
   * visualize the tabs of a {@link TabSwitcher}.
   *
   * @param tabSwitcher       The tab switcher as an instance of the class {@link TabSwitcher}. The tab switcher
   *                          may not be null
   * @param model             The model, which belongs to the tab switcher, as an instance of the class {@link
   *                          TabSwitcherModel}. The model may not be null
   * @param childViewRecycler The view recycler, which allows to inflate the child views of tabs, as an instance of
   *                          the class ViewRecycler. The view recycler may not be null
   */
  public PhoneRecyclerAdapter(@NonNull final TabSwitcher tabSwitcher,
                              @NonNull final TabSwitcherModel model,
                              @NonNull final ViewRecycler<Tab, Void> childViewRecycler) {
    ensureNotNull(tabSwitcher, "The tab switcher may not be null");
    ensureNotNull(model, "The model may not be null");
    ensureNotNull(childViewRecycler, "The child view recycler may not be null");
    this.tabSwitcher = tabSwitcher;
    this.model = model;
    this.childViewRecycler = childViewRecycler;
    this.dataBinder = new PreviewDataBinder(tabSwitcher, childViewRecycler);
    this.dataBinder.addListener(this);
    Resources resources = tabSwitcher.getResources();
    this.tabInset = resources.getDimensionPixelSize(R.dimen.tab_inset);
    this.tabBorderWidth = resources.getDimensionPixelSize(R.dimen.tab_border_width);
    this.tabTitleContainerHeight =
      resources.getDimensionPixelSize(R.dimen.tab_title_container_height);
    this.tabBackgroundColor =
      ContextCompat.getColor(tabSwitcher.getContext(), R.color.tab_background_color);
    this.tabTitleTextColor =
      ContextCompat.getColor(tabSwitcher.getContext(), R.color.tab_title_text_color);
    this.viewRecycler = null;
    adaptLogLevel();
  }

  /**
   * Sets the view recycler, which allows to inflate the views, which are used to visualize tabs.
   *
   * @param viewRecycler The view recycler, which should be set, as an instance of the class
   *                     AttachedViewRecycler. The view recycler may not be null
   */
  public final void setViewRecycler(
    @NonNull final AttachedViewRecycler<TabItem, Integer> viewRecycler) {
    ensureNotNull(viewRecycler, "The view recycler may not be null");
    this.viewRecycler = viewRecycler;
  }

  /**
   * Removes all previously rendered previews from the cache.
   */
  public final void clearCachedPreviews() {
    dataBinder.clearCache();
  }

  @NonNull
  @Override
  public final View onInflateView(@NonNull final LayoutInflater inflater,
                                  @Nullable final ViewGroup parent,
                                  @NonNull final TabItem tabItem, final int viewType,
                                  @NonNull final Integer... params) {
    PhoneTabViewHolder viewHolder = new PhoneTabViewHolder();
    View view = inflater.inflate(R.layout.phone_tab, tabSwitcher.getTabContainer(), false);
    Drawable backgroundDrawable =
      ContextCompat.getDrawable(model.getContext(), R.drawable.phone_tab_background);
    ViewUtil.setBackground(view, backgroundDrawable);
    int padding = tabInset + tabBorderWidth;
    view.setPadding(padding, tabInset, padding, padding);
    viewHolder.titleContainer = (ViewGroup) view.findViewById(R.id.tab_title_container);
    viewHolder.titleTextView = (TextView) view.findViewById(R.id.tab_title_text_view);
    viewHolder.closeButton = (ImageButton) view.findViewById(R.id.close_tab_button);
    viewHolder.childContainer = (ViewGroup) view.findViewById(R.id.child_container);
    viewHolder.previewImageView = (ImageView) view.findViewById(R.id.preview_image_view);
    adaptPadding(viewHolder);
    viewHolder.borderView = view.findViewById(R.id.border_view);
    Drawable borderDrawable =
      ContextCompat.getDrawable(model.getContext(), R.drawable.phone_tab_border);
    ViewUtil.setBackground(viewHolder.borderView, borderDrawable);
    view.setTag(R.id.tag_view_holder, viewHolder);
    tabItem.setView(view);
    tabItem.setViewHolder(viewHolder);
    view.setTag(R.id.tag_properties, tabItem.getTag());
    return view;
  }

  @Override
  public final void onShowView(@NonNull final Context context, @NonNull final View view,
                               @NonNull final TabItem tabItem, final boolean inflated,
                               @NonNull final Integer... params) {
    PhoneTabViewHolder viewHolder = (PhoneTabViewHolder) view.getTag(R.id.tag_view_holder);

    if (!tabItem.isInflated()) {
      tabItem.setView(view);
      tabItem.setViewHolder(viewHolder);
      view.setTag(R.id.tag_properties, tabItem.getTag());
    }

    LayoutParams layoutParams =
      new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
    int borderMargin = -(tabInset + tabBorderWidth);
    int bottomMargin = params.length > 0 && params[0] != -1 ? params[0] : borderMargin;
    layoutParams.leftMargin = borderMargin;
    layoutParams.topMargin = -(tabInset + tabTitleContainerHeight);
    layoutParams.rightMargin = borderMargin;
    layoutParams.bottomMargin = bottomMargin;
    view.setLayoutParams(layoutParams);
    Tab tab = tabItem.getTab();
    tab.addCallback(this);
    adaptTitle(viewHolder, tab);
    adaptIcon(viewHolder, tab);
    adaptCloseButton(viewHolder, tab);
    adaptCloseButtonIcon(viewHolder, tab);
    adaptBackgroundColor(view, viewHolder, tab);
    adaptTitleTextColor(viewHolder, tab);
    adaptSelectionState(viewHolder, tab);

    if (!model.isSwitcherShown()) {
      if (tab == model.getSelectedTab()) {
        addChildView(tabItem);
      }
    } else {
      renderChildView(tabItem);
    }
  }

  @Override
  public final void onRemoveView(@NonNull final View view, @NonNull final TabItem tabItem) {
    PhoneTabViewHolder viewHolder = (PhoneTabViewHolder) view.getTag(R.id.tag_view_holder);
    Tab tab = tabItem.getTab();
    tab.removeCallback(this);
    removeChildView(viewHolder, tab);

    if (!dataBinder.isCached(tab)) {
      Drawable drawable = viewHolder.previewImageView.getDrawable();
      viewHolder.previewImageView.setImageBitmap(null);

      if (drawable instanceof BitmapDrawable) {
        Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();

        if (bitmap != null && !bitmap.isRecycled()) {
          bitmap.recycle();
        }
      }
    } else {
      viewHolder.previewImageView.setImageBitmap(null);
    }

    view.setTag(R.id.tag_properties, null);
  }

  @Override
  public final void onTitleChanged(@NonNull final Tab tab) {
    TabItem tabItem = getTabItem(tab);

    if (tabItem != null) {
      adaptTitle(tabItem.getViewHolder(), tabItem.getTab());
    }
  }

  @Override
  public final void onIconChanged(@NonNull final Tab tab) {
    TabItem tabItem = getTabItem(tab);

    if (tabItem != null) {
      adaptIcon(tabItem.getViewHolder(), tabItem.getTab());
    }
  }

  @Override
  public final void onCloseableChanged(@NonNull final Tab tab) {
    TabItem tabItem = getTabItem(tab);

    if (tabItem != null) {
      adaptCloseButton(tabItem.getViewHolder(), tabItem.getTab());
    }
  }

  @Override
  public final void onCloseButtonIconChanged(@NonNull final Tab tab) {
    TabItem tabItem = getTabItem(tab);

    if (tabItem != null) {
      adaptCloseButtonIcon(tabItem.getViewHolder(), tabItem.getTab());
    }
  }

  @Override
  public final void onBackgroundColorChanged(@NonNull final Tab tab) {
    TabItem tabItem = getTabItem(tab);

    if (tabItem != null) {
      adaptBackgroundColor(tabItem.getView(), tabItem.getViewHolder(), tabItem.getTab());
    }
  }

  @Override
  public final void onTitleTextColorChanged(@NonNull final Tab tab) {
    TabItem tabItem = getTabItem(tab);

    if (tabItem != null) {
      adaptTitleTextColor(tabItem.getViewHolder(), tabItem.getTab());
    }
  }

  @Override
  public final void onLogLevelChanged(@NonNull final LogLevel logLevel) {
    adaptLogLevel();
  }

  @Override
  public final void onDecoratorChanged(@NonNull final TabSwitcherDecorator decorator) {

  }

  @Override
  public final void onSwitcherShown() {

  }

  @Override
  public final void onSwitcherHidden() {

  }

  @Override
  public final void onSelectionChanged(final int previousIndex, final int index,
                                       @Nullable final Tab selectedTab,
                                       final boolean switcherHidden) {
    adaptAllSelectionStates();
  }

  @Override
  public final void onTabAdded(final int index, @NonNull final Tab tab,
                               final int previousSelectedTabIndex, final int selectedTabIndex,
                               final boolean switcherVisibilityChanged,
                               @NonNull final Animation animation) {
    if (previousSelectedTabIndex != selectedTabIndex) {
      adaptAllSelectionStates();
    }
  }

  @Override
  public final void onAllTabsAdded(final int index, @NonNull final Tab[] tabs,
                                   final int previousSelectedTabIndex, final int selectedTabIndex,
                                   @NonNull final Animation animation) {
    if (previousSelectedTabIndex != selectedTabIndex) {
      adaptAllSelectionStates();
    }
  }

  @Override
  public final void onTabRemoved(final int index, @NonNull final Tab tab,
                                 final int previousSelectedTabIndex, final int selectedTabIndex,
                                 @NonNull final Animation animation) {
    if (previousSelectedTabIndex != selectedTabIndex) {
      adaptAllSelectionStates();
    }
  }

  @Override
  public final void onAllTabsRemoved(@NonNull final Tab[] tabs,
                                     @NonNull final Animation animation) {

  }

  @Override
  public final void onPaddingChanged(final int left, final int top, final int right,
                                     final int bottom) {
    TabItemIterator iterator = new TabItemIterator.Builder(model, viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        adaptPadding(tabItem.getViewHolder());
      }
    }
  }

  @Override
  public final void onTabIconChanged(@Nullable final Drawable icon) {
    TabItemIterator iterator = new TabItemIterator.Builder(model, viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        adaptIcon(tabItem.getViewHolder(), tabItem.getTab());
      }
    }
  }

  @Override
  public final void onTabBackgroundColorChanged(@Nullable final ColorStateList colorStateList) {
    TabItemIterator iterator = new TabItemIterator.Builder(model, viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        adaptBackgroundColor(tabItem.getView(), tabItem.getViewHolder(), tabItem.getTab());
      }
    }
  }

  @Override
  public final void onTabTitleColorChanged(@Nullable final ColorStateList colorStateList) {
    TabItemIterator iterator = new TabItemIterator.Builder(model, viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        adaptTitleTextColor(tabItem.getViewHolder(), tabItem.getTab());
      }
    }
  }

  @Override
  public final void onTabCloseButtonIconChanged(@Nullable final Drawable icon) {
    TabItemIterator iterator = new TabItemIterator.Builder(model, viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        adaptCloseButtonIcon(tabItem.getViewHolder(), tabItem.getTab());
      }
    }
  }

  @Override
  public final void onToolbarVisibilityChanged(final boolean visible) {

  }

  @Override
  public final void onToolbarTitleChanged(@Nullable final CharSequence title) {

  }

  @Override
  public final void onToolbarNavigationIconChanged(@Nullable final Drawable icon,
                                                   @Nullable final OnClickListener listener) {

  }

  @Override
  public final void onToolbarMenuInflated(@MenuRes final int resourceId,
                                          @Nullable final OnMenuItemClickListener listener) {

  }

  @Override
  public final boolean onLoadData(
    @NonNull final AbstractDataBinder<Bitmap, Tab, ImageView, TabItem> dataBinder,
    @NonNull final Tab key, @NonNull final TabItem... params) {
    boolean result = true;

    for (TabPreviewListener listener : model.getTabPreviewListeners()) {
      result &= listener.onLoadTabPreview(tabSwitcher, key);
    }

    return result;
  }

  @Override
  public final void onFinished(
    @NonNull final AbstractDataBinder<Bitmap, Tab, ImageView, TabItem> dataBinder,
    @NonNull final Tab key, @Nullable final Bitmap data, @NonNull final ImageView view,
    @NonNull final TabItem... params) {

  }

  @Override
  public final void onCanceled(
    @NonNull final AbstractDataBinder<Bitmap, Tab, ImageView, TabItem> dataBinder) {

  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/phone/PhoneTabSwitcherLayout.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout.phone;

import android.animation.Animator;
import android.animation.Animator.AnimatorListener;
import android.animation.AnimatorListenerAdapter;
import android.animation.ValueAnimator;
import android.content.res.ColorStateList;
import android.content.res.Resources;
import android.graphics.drawable.Drawable;
import android.util.TypedValue;
import android.view.*;
import android.view.ViewTreeObserver.OnGlobalLayoutListener;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.DecelerateInterpolator;
import android.view.animation.Interpolator;
import android.widget.FrameLayout;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.Toolbar;
import androidx.core.util.Pair;
import androidx.core.view.ViewCompat;
import de.mrapp.android.tabswitcher.*;
import de.mrapp.android.tabswitcher.SwipeAnimation.SwipeDirection;
import de.mrapp.android.tabswitcher.iterator.AbstractTabItemIterator;
import de.mrapp.android.tabswitcher.iterator.ArrayTabItemIterator;
import de.mrapp.android.tabswitcher.iterator.TabItemIterator;
import de.mrapp.android.tabswitcher.layout.AbstractDragHandler;
import de.mrapp.android.tabswitcher.layout.AbstractDragHandler.DragState;
import de.mrapp.android.tabswitcher.layout.AbstractTabSwitcherLayout;
import de.mrapp.android.tabswitcher.layout.Arithmetics.Axis;
import de.mrapp.android.tabswitcher.model.State;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.tabswitcher.model.TabSwitcherModel;
import de.mrapp.android.tabswitcher.model.Tag;
import de.mrapp.android.util.logging.LogLevel;
import de.mrapp.android.util.view.AttachedViewRecycler;
import de.mrapp.android.util.view.ViewRecycler;

import java.util.Collections;

import static de.mrapp.android.util.Condition.*;

/**
 * A layout, which implements the functionality of a {@link TabSwitcher} on smartphones.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class PhoneTabSwitcherLayout extends AbstractTabSwitcherLayout
  implements PhoneDragHandler.Callback {

  /**
   * An iterator, which allows to iterate the tab items, which correspond to the tabs of a {@link
   * TabSwitcher}. When a tab item is referenced for the first time, its initial position and
   * state is calculated and the tab item is stored in a backing array. When the tab item is
   * iterated again, it is retrieved from the backing array.
   */
  private class InitialTabItemIterator extends AbstractTabItemIterator {

    /**
     * The backing array, which is used to store tab items, once their initial position and
     * state has been calculated.
     */
    private final TabItem[] array;

    /**
     * Calculates the initial position and state of a specific tab item.
     *
     * @param tabItem     The tab item, whose position and state should be calculated, as an instance of
     *                    the class {@link TabItem}. The tab item may not be null
     * @param predecessor The predecessor of the given tab item as an instance of the class {@link TabItem}
     *                    or null, if the tab item does not have a predecessor
     */
    private void calculateAndClipStartPosition(@NonNull final TabItem tabItem,
                                               @Nullable final TabItem predecessor) {
      float position = calculateStartPosition(tabItem);
      Pair<Float, State> pair =
        clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
          predecessor);
      tabItem.getTag().setPosition(pair.first);
      tabItem.getTag().setState(pair.second);
    }

    /**
     * Calculates and returns the initial position of a specific tab item.
     *
     * @param tabItem The tab item, whose position should be calculated, as an instance of the class
     *                {@link TabItem}. The tab item may not be null
     * @return The position, which has been calculated, as a {@link Float} value
     */
    private float calculateStartPosition(@NonNull final TabItem tabItem) {
      if (tabItem.getIndex() == 0) {
        return getCount() > stackedTabCount ? stackedTabCount * stackedTabSpacing :
          (getCount() - 1) * stackedTabSpacing;

      } else {
        return -1;
      }
    }

    /**
     * Creates a new iterator, which allows to iterate the tab items, which corresponds to the
     * tabs of a {@link TabSwitcher}.
     *
     * @param array   The backing array, which should be used to store tab items, once their initial
     *                position and state has been calculated, as an array of the type {@link TabItem}.
     *                The array may not be null and the array's length must be equal to the number of
     *                tabs, which are contained by the given tab switcher
     * @param reverse True, if the tabs should be iterated in reverse order, false otherwise
     * @param start   The index of the first tab, which should be iterated, as an {@link Integer} value
     *                or -1, if all tabs should be iterated
     */
    private InitialTabItemIterator(@NonNull final TabItem[] array, final boolean reverse,
                                   final int start) {
      ensureNotNull(array, "The array may not be null");
      ensureEqual(array.length, getModel().getCount(),
        "The array's length must be " + getModel().getCount());
      this.array = array;
      initialize(reverse, start);
    }

    @Override
    public final int getCount() {
      return array.length;
    }

    @NonNull
    @Override
    public final TabItem getItem(final int index) {
      TabItem tabItem = array[index];

      if (tabItem == null) {
        tabItem = TabItem.create(getModel(), viewRecycler, index);
        calculateAndClipStartPosition(tabItem, index > 0 ? getItem(index - 1) : null);
        array[index] = tabItem;
      }

      return tabItem;
    }

  }

  /**
   * A layout listener, which encapsulates another listener, which is notified, when the listener
   * has been invoked a specific number of times.
   */
  private class CompoundLayoutListener implements OnGlobalLayoutListener {

    /**
     * The number of times, the listener must still be invoked, until the encapsulated listener
     * is notified.
     */
    private int count;

    /**
     * The encapsulated listener;
     */
    private final OnGlobalLayoutListener listener;

    /**
     * Creates a new layout listener, which encapsulates another listener, which is notified,
     * when the listener has been invoked a specific number of times.
     *
     * @param count    The number of times, the listener should be invoked until the encapsulated
     *                 listener is notified, as an {@link Integer} value. The count must be greater than
     *                 0
     * @param listener The encapsulated listener, which should be notified, when the listener has been
     *                 notified the given number of times, as an instance of the type {@link
     *                 OnGlobalLayoutListener} or null, if no listener should be notified
     */
    CompoundLayoutListener(final int count, @Nullable final OnGlobalLayoutListener listener) {
      ensureGreater(count, 0, "The count must be greater than 0");
      this.count = count;
      this.listener = listener;
    }

    @Override
    public void onGlobalLayout() {
      if (--count == 0) {
        if (listener != null) {
          listener.onGlobalLayout();
        }
      }
    }

  }

  /**
   * The ratio, which specifies the maximum space between the currently selected tab and its
   * predecessor in relation to the default space.
   */
  private static final float SELECTED_TAB_SPACING_RATIO = 1.5f;

  /**
   * The ratio, which specifies the minimum space between two neighboring tabs in relation to the
   * maximum space.
   */
  private static final float MIN_TAB_SPACING_RATIO = 0.375f;

  /**
   * The inset of tabs in pixels.
   */
  private final int tabInset;

  /**
   * The width of the border, which is drawn around the preview of tabs.
   */
  private final int tabBorderWidth;

  /**
   * The height of a tab's title container in pixels.
   */
  private final int tabTitleContainerHeight;

  /**
   * The number of tabs, which are contained by a stack.
   */
  private final int stackedTabCount;

  /**
   * The space between tabs, which are part of a stack, in pixels.
   */
  private final int stackedTabSpacing;

  /**
   * The maximum camera distance, when tilting a tab, in pixels.
   */
  private final int maxCameraDistance;

  /**
   * The alpha of a tab, when it is swiped.
   */
  private final float swipedTabAlpha;

  /**
   * The scale of a tab, when it is swiped.
   */
  private final float swipedTabScale;

  /**
   * The duration of the animation, which is used to show the switcher.
   */
  private final long showSwitcherAnimationDuration;

  /**
   * The duration of the animation, which is used to hide the switcher.
   */
  private final long hideSwitcherAnimationDuration;

  /**
   * The duration of the animation, which is used to show or hide the toolbar.
   */
  private final long toolbarVisibilityAnimationDuration;

  /**
   * The delay of the animation, which is used to show or hide the toolbar.
   */
  private final long toolbarVisibilityAnimationDelay;

  /**
   * The duration of the animation, which is used to swipe tabs.
   */
  private final long swipeAnimationDuration;

  /**
   * The delay of the animation, which is used to remove all tabs.
   */
  private final long clearAnimationDelay;

  /**
   * The duration of the animation, which is used to relocate tabs.
   */
  private final long relocateAnimationDuration;

  /**
   * The delay of the animation, which is used to relocate tabs.
   */
  private final long relocateAnimationDelay;

  /**
   * The duration of the animation, which is used to revert overshoots.
   */
  private final long revertOvershootAnimationDuration;

  /**
   * The duration of a reveal animation.
   */
  private final long revealAnimationDuration;

  /**
   * The duration of a peek animation.
   */
  private final long peekAnimationDuration;

  /**
   * The maximum angle, tabs can be rotated by, when overshooting at the start, in degrees.
   */
  private final float maxStartOvershootAngle;

  /**
   * The maximum angle, tabs can be rotated by, when overshooting at the end, in degrees.
   */
  private final float maxEndOvershootAngle;

  /**
   * The drag handler, which is used by the layout.
   */
  private PhoneDragHandler dragHandler;

  /**
   * The view recycler, which allows to recycler the child views of tabs.
   */
  private ViewRecycler<Tab, Void> childViewRecycler;

  /**
   * The adapter, which allows to inflate the views, which are used to visualize tabs.
   */
  private PhoneRecyclerAdapter recyclerAdapter;

  /**
   * The view recycler, which allows to recycle the views, which are used to visualize tabs.
   */
  private AttachedViewRecycler<TabItem, Integer> viewRecycler;

  /**
   * The view group, which contains the tab switcher's tabs.
   */
  private ViewGroup tabContainer;

  /**
   * The toolbar, which is shown, when the tab switcher is shown.
   */
  private Toolbar toolbar;

  /**
   * The bottom margin of a view, which visualizes a tab.
   */
  private int tabViewBottomMargin;

  /**
   * The animation, which is used to show or hide the toolbar.
   */
  private ViewPropertyAnimator toolbarAnimation;

  /**
   * The index of the first visible tab.
   */
  private int firstVisibleIndex;

  /**
   * Adapts the log level.
   */
  private void adaptLogLevel() {
    viewRecycler.setLogLevel(getModel().getLogLevel());
    childViewRecycler.setLogLevel(getModel().getLogLevel());
  }

  /**
   * Adapts the decorator.
   */
  private void adaptDecorator() {
    childViewRecycler.setAdapter(getModel().getChildRecyclerAdapter());
    recyclerAdapter.clearCachedPreviews();
  }

  /**
   * Adapts the margin of the toolbar, which is shown, when the tab switcher is shown.
   */
  private void adaptToolbarMargin() {
    FrameLayout.LayoutParams layoutParams =
      (FrameLayout.LayoutParams) toolbar.getLayoutParams();
    layoutParams.setMargins(getModel().getPaddingLeft(), getModel().getPaddingTop(),
      getModel().getPaddingRight(), 0);
  }

  /**
   * Calculates the positions of all tabs, when dragging towards the start.
   *
   * @param dragDistance The current drag distance in pixels as a {@link Float} value
   */
  private void calculatePositionsWhenDraggingToEnd(final float dragDistance) {
    firstVisibleIndex = -1;
    AbstractTabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler)
        .start(Math.max(0, firstVisibleIndex)).create();
    TabItem tabItem;
    boolean abort = false;

    while ((tabItem = iterator.next()) != null && !abort) {
      if (getTabSwitcher().getCount() - tabItem.getIndex() > 1) {
        abort = calculatePositionWhenDraggingToEnd(dragDistance, tabItem,
          iterator.previous());

        if (firstVisibleIndex == -1 && tabItem.getTag().getState() == State.FLOATING) {
          firstVisibleIndex = tabItem.getIndex();
        }
      } else {
        Pair<Float, State> pair =
          clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(),
            tabItem.getTag().getPosition(), iterator.previous());
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);
      }

      inflateOrRemoveView(tabItem);
    }
  }

  /**
   * Calculates the position of a specific tab, when dragging towards the end.
   *
   * @param dragDistance The current drag distance in pixels as a {@link Float} value
   * @param tabItem      The tab item, which corresponds to the tab, whose position should be calculated, as
   *                     an instance of the class {@link TabItem}. The tab item may not be null
   * @param predecessor  The predecessor of the given tab item as an instance of the class {@link TabItem} or
   *                     null, if the tab item does not have a predecessor
   * @return True, if calculating the position of subsequent tabs can be omitted, false otherwise
   */
  private boolean calculatePositionWhenDraggingToEnd(final float dragDistance,
                                                     @NonNull final TabItem tabItem,
                                                     @Nullable final TabItem predecessor) {
    if (predecessor == null || predecessor.getTag().getState() != State.FLOATING) {
      if ((tabItem.getTag().getState() == State.STACKED_START_ATOP &&
        tabItem.getIndex() == 0) || tabItem.getTag().getState() == State.FLOATING) {
        float currentPosition = tabItem.getTag().getPosition();
        float thresholdPosition = calculateEndPosition(tabItem.getIndex());
        float newPosition = Math.min(currentPosition + dragDistance, thresholdPosition);
        Pair<Float, State> pair =
          clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(),
            newPosition, predecessor);
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);
      } else if (tabItem.getTag().getState() == State.STACKED_START_ATOP) {
        return true;
      }
    } else {
      float thresholdPosition = calculateEndPosition(tabItem.getIndex());
      float newPosition =
        Math.min(calculateNonLinearPosition(tabItem, predecessor), thresholdPosition);
      Pair<Float, State> pair =
        clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(), newPosition,
          predecessor);
      tabItem.getTag().setPosition(pair.first);
      tabItem.getTag().setState(pair.second);
    }

    return false;
  }

  /**
   * Calculates the positions of all tabs, when dragging towards the end.
   *
   * @param dragDistance The current drag distance in pixels as a {@link Float} value
   */
  private void calculatePositionsWhenDraggingToStart(final float dragDistance) {
    AbstractTabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler)
        .start(Math.max(0, firstVisibleIndex)).create();
    TabItem tabItem;
    boolean abort = false;

    while ((tabItem = iterator.next()) != null && !abort) {
      if (getTabSwitcher().getCount() - tabItem.getIndex() > 1) {
        abort = calculatePositionWhenDraggingToStart(dragDistance, tabItem,
          iterator.previous());
      } else {
        Pair<Float, State> pair =
          clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(),
            tabItem.getTag().getPosition(), iterator.previous());
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);
      }

      inflateOrRemoveView(tabItem);
    }

    if (firstVisibleIndex > 0) {
      int start = firstVisibleIndex - 1;
      iterator = new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).reverse(true)
        .start(start).create();

      while ((tabItem = iterator.next()) != null) {
        TabItem predecessor = iterator.previous();
        float predecessorPosition = predecessor.getTag().getPosition();

        if (tabItem.getIndex() < start) {
          Pair<Float, State> pair =
            clipTabPosition(getTabSwitcher().getCount(), predecessor.getIndex(),
              predecessorPosition, tabItem);
          predecessor.getTag().setPosition(pair.first);
          predecessor.getTag().setState(pair.second);
          inflateOrRemoveView(predecessor);

          if (predecessor.getTag().getState() == State.FLOATING) {
            firstVisibleIndex = predecessor.getIndex();
          } else {
            break;
          }
        }

        float newPosition = predecessorPosition +
          calculateMaxTabSpacing(getTabSwitcher().getCount(), predecessor);
        tabItem.getTag().setPosition(newPosition);

        if (!iterator.hasNext()) {
          Pair<Float, State> pair =
            clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(),
              newPosition, (TabItem) null);
          tabItem.getTag().setPosition(pair.first);
          tabItem.getTag().setState(pair.second);
          inflateOrRemoveView(tabItem);

          if (tabItem.getTag().getState() == State.FLOATING) {
            firstVisibleIndex = tabItem.getIndex();
          }
        }
      }
    }
  }

  /**
   * Calculates the position of a specific tab, when dragging towards the start.
   *
   * @param dragDistance The current drag distance in pixels as a {@link Float} value
   * @param tabItem      The tab item, which corresponds to the tab, whose position should be calculated, as
   *                     an instance of the class {@link TabItem}. The tab item may not be null
   * @param predecessor  The predecessor of the given tab item as an instance of the class {@link TabItem} or
   *                     null, if the tab item does not have a predecessor
   * @return True, if calculating the position of subsequent tabs can be omitted, false otherwise
   */
  private boolean calculatePositionWhenDraggingToStart(final float dragDistance,
                                                       @NonNull final TabItem tabItem,
                                                       @Nullable final TabItem predecessor) {
    if (predecessor == null || predecessor.getTag().getState() != State.FLOATING ||
      predecessor.getTag().getPosition() >
        calculateAttachedPosition(getTabSwitcher().getCount())) {
      if (tabItem.getTag().getState() == State.FLOATING) {
        float currentPosition = tabItem.getTag().getPosition();
        float newPosition = currentPosition + dragDistance;
        Pair<Float, State> pair =
          clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(),
            newPosition, predecessor);
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);
      } else if (tabItem.getTag().getState() == State.STACKED_START_ATOP) {
        float currentPosition = tabItem.getTag().getPosition();
        Pair<Float, State> pair =
          clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(),
            currentPosition, predecessor);
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);
        return true;
      } else if (tabItem.getTag().getState() == State.HIDDEN ||
        tabItem.getTag().getState() == State.STACKED_START) {
        return true;
      }
    } else {
      float newPosition = calculateNonLinearPosition(tabItem, predecessor);
      Pair<Float, State> pair =
        clipTabPosition(getTabSwitcher().getCount(), tabItem.getIndex(), newPosition,
          predecessor);
      tabItem.getTag().setPosition(pair.first);
      tabItem.getTag().setState(pair.second);
    }

    return false;
  }

  /**
   * Calculates the non-linear position of a tab in relation to the position of its predecessor.
   *
   * @param tabItem     The tab item, which corresponds to the tab, whose non-linear position should be
   *                    calculated, as an instance of the class {@link TabItem}. The tab item may not be
   *                    null
   * @param predecessor The predecessor as an instance of the class {@link TabItem}. The predecessor may not
   *                    be null
   * @return The position, which has been calculated, as a {@link Float} value
   */
  private float calculateNonLinearPosition(@NonNull final TabItem tabItem,
                                           @NonNull final TabItem predecessor) {
    float predecessorPosition = predecessor.getTag().getPosition();
    float maxTabSpacing = calculateMaxTabSpacing(getTabSwitcher().getCount(), tabItem);
    return calculateNonLinearPosition(predecessorPosition, maxTabSpacing);
  }

  /**
   * Calculates the non-linear position of a tab in relation to the position of its predecessor.
   *
   * @param predecessorPosition The position of the predecessor in pixels as a {@link Float} value
   * @param maxTabSpacing       The maximum space between two neighboring tabs in pixels as a {@link Float} value
   * @return The position, which has been calculated, as a {@link Float} value
   */
  private float calculateNonLinearPosition(final float predecessorPosition,
                                           final float maxTabSpacing) {
    float ratio = Math.min(1,
      predecessorPosition / calculateAttachedPosition(getTabSwitcher().getCount()));
    float minTabSpacing = calculateMinTabSpacing(getTabSwitcher().getCount());
    return predecessorPosition - minTabSpacing - (ratio * (maxTabSpacing - minTabSpacing));
  }

  /**
   * Calculates and returns the position of a specific tab, when located at the end.
   *
   * @param index The index of the tab, whose position should be calculated, as an {@link Integer}
   *              value
   * @return The position, which has been calculated, as a {@link Float} value
   */
  private float calculateEndPosition(final int index) {
    float defaultMaxTabSpacing = calculateMaxTabSpacing(getTabSwitcher().getCount(), null);
    int selectedTabIndex = getTabSwitcher().getSelectedTabIndex();

    if (selectedTabIndex > index) {
      AbstractTabItemIterator iterator =
        new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
      TabItem selectedTabItem = iterator.getItem(selectedTabIndex);
      float selectedTabSpacing =
        calculateMaxTabSpacing(getTabSwitcher().getCount(), selectedTabItem);
      return (getTabSwitcher().getCount() - 2 - index) * defaultMaxTabSpacing +
        selectedTabSpacing;
    }

    return (getTabSwitcher().getCount() - 1 - index) * defaultMaxTabSpacing;
  }

  /**
   * Calculates and returns the position of a tab, when it is swiped.
   *
   * @return The position, which has been calculated, in pixels as an {@link Float} value
   */
  private float calculateSwipePosition() {
    return getArithmetics().getTabContainerSize(Axis.ORTHOGONAL_AXIS, true);
  }

  /**
   * Calculates and returns the maximum space between a specific tab and its predecessor. The
   * maximum space is greater for the currently selected tab.
   *
   * @param count   The total number of tabs, which are contained by the tabs switcher, as an {@link
   *                Integer} value
   * @param tabItem The tab item, which corresponds to the tab, the maximum space should be returned for,
   *                as an instance of the class {@link TabItem} or null, if the default maximum space
   *                should be returned
   * @return The maximum space between the given tab and its predecessor in pixels as a {@link
   * Float} value
   */
  private float calculateMaxTabSpacing(final int count, @Nullable final TabItem tabItem) {
    float totalSpace = getArithmetics().getTabContainerSize(Axis.DRAGGING_AXIS, false);
    float maxTabSpacing;

    if (count <= 2) {
      maxTabSpacing = totalSpace * 0.66f;
    } else if (count == 3) {
      maxTabSpacing = totalSpace * 0.33f;
    } else if (count == 4) {
      maxTabSpacing = totalSpace * 0.3f;
    } else {
      maxTabSpacing = totalSpace * 0.25f;
    }

    return count > 4 && tabItem != null &&
      tabItem.getTab() == getTabSwitcher().getSelectedTab() ?
      maxTabSpacing * SELECTED_TAB_SPACING_RATIO : maxTabSpacing;
  }

  /**
   * Calculates and returns the minimum space between two neighboring tabs.
   *
   * @param count The total number of tabs, which are contained by the tabs switcher, as an {@link
   *              Integer} value
   * @return The minimum space between two neighboring tabs in pixels as a {@link Float} value
   */
  private float calculateMinTabSpacing(final int count) {
    return calculateMaxTabSpacing(count, null) * MIN_TAB_SPACING_RATIO;
  }

  /**
   * Calculates and returns the position on the dragging axis, where the distance between a tab
   * and its predecessor should have reached the maximum.
   *
   * @param count The total number of tabs, which are contained by the tabs switcher, as an {@link
   *              Integer} value
   * @return The position, which has been calculated, in pixels as an {@link Float} value
   */
  private float calculateAttachedPosition(final int count) {
    float totalSpace = getArithmetics().getTabContainerSize(Axis.DRAGGING_AXIS, false);
    float attachedPosition;

    if (count == 3) {
      attachedPosition = totalSpace * 0.66f;
    } else if (count == 4) {
      attachedPosition = totalSpace * 0.6f;
    } else {
      attachedPosition = totalSpace * 0.5f;
    }

    return attachedPosition;
  }

  /**
   * Clips the position of a specific tab.
   *
   * @param count       The total number of tabs, which are currently contained by the tab switcher, as an
   *                    {@link Integer} value
   * @param index       The index of the tab, whose position should be clipped, as an {@link Integer} value
   * @param position    The position, which should be clipped, in pixels as a {@link Float} value
   * @param predecessor The predecessor of the given tab item as an instance of the class {@link TabItem} or
   *                    null, if the tab item does not have a predecessor
   * @return A pair, which contains the position and state of the tab item, as an instance of the
   * class {@link Pair}. The pair may not be null
   */
  @NonNull
  private Pair<Float, State> clipTabPosition(final int count, final int index,
                                             final float position,
                                             @Nullable final TabItem predecessor) {
    return clipTabPosition(count, index, position,
      predecessor != null ? predecessor.getTag().getState() : null);
  }

  /**
   * Clips the position of a specific tab.
   *
   * @param count            The total number of tabs, which are currently contained by the tab switcher, as an
   *                         {@link Integer} value
   * @param index            The index of the tab, whose position should be clipped, as an {@link Integer} value
   * @param position         The position, which should be clipped, in pixels as a {@link Float} value
   * @param predecessorState The state of the predecessor of the given tab item as a value of the enum {@link
   *                         State} or null, if the tab item does not have a predecessor
   * @return A pair, which contains the position and state of the tab item, as an instance of the
   * class {@link Pair}. The pair may not be null
   */
  private Pair<Float, State> clipTabPosition(final int count, final int index,
                                             final float position,
                                             @Nullable final State predecessorState) {
    Pair<Float, State> startPair =
      calculatePositionAndStateWhenStackedAtStart(count, index, predecessorState);
    float startPosition = startPair.first;

    if (position <= startPosition) {
      State state = startPair.second;
      return Pair.create(startPosition, state);
    } else {
      Pair<Float, State> endPair = calculatePositionAndStateWhenStackedAtEnd(index);
      float endPosition = endPair.first;

      if (position >= endPosition) {
        State state = endPair.second;
        return Pair.create(endPosition, state);
      } else {
        State state = State.FLOATING;
        return Pair.create(position, state);
      }
    }
  }

  /**
   * Calculates and returns the position and state of a specific tab, when stacked at the start.
   *
   * @param count       The total number of tabs, which are currently contained by the tab switcher, as an
   *                    {@link Integer} value
   * @param index       The index of the tab, whose position and state should be returned, as an {@link
   *                    Integer} value
   * @param predecessor The predecessor of the given tab item as an instance of the class {@link TabItem} or
   *                    null, if the tab item does not have a predecessor
   * @return A pair, which contains the position and state of the given tab item, when stacked at
   * the start, as an instance of the class {@link Pair}. The pair may not be null
   */
  @NonNull
  private Pair<Float, State> calculatePositionAndStateWhenStackedAtStart(final int count,
                                                                         final int index,
                                                                         @Nullable final TabItem predecessor) {
    return calculatePositionAndStateWhenStackedAtStart(count, index,
      predecessor != null ? predecessor.getTag().getState() : null);
  }

  /**
   * Calculates and returns the position and state of a specific tab, when stacked at the start.
   *
   * @param count            The total number of tabs, which are currently contained by the tab switcher, as an
   *                         {@link Integer} value
   * @param index            The index of the tab, whose position and state should be returned, as an {@link
   *                         Integer} value
   * @param predecessorState The state of the predecessor of the given tab item as a value of the enum {@link
   *                         State} or null, if the tab item does not have a predecessor
   * @return A pair, which contains the position and state of the given tab item, when stacked at
   * the start, as an instance of the class {@link Pair}. The pair may not be null
   */
  @NonNull
  private Pair<Float, State> calculatePositionAndStateWhenStackedAtStart(final int count,
                                                                         final int index,
                                                                         @Nullable final State predecessorState) {
    if ((count - index) <= stackedTabCount) {
      float position = stackedTabSpacing * (count - (index + 1));
      return Pair.create(position,
        (predecessorState == null || predecessorState == State.FLOATING) ?
          State.STACKED_START_ATOP : State.STACKED_START);
    } else {
      float position = stackedTabSpacing * stackedTabCount;
      return Pair.create(position,
        (predecessorState == null || predecessorState == State.FLOATING) ?
          State.STACKED_START_ATOP : State.HIDDEN);
    }
  }

  /**
   * Calculates and returns the position and state of a specific tab, when stacked at the end.
   *
   * @param index The index of the tab, whose position and state should be returned, as an {@link
   *              Integer} value
   * @return A pair, which contains the position and state of the given tab item, when stacked at
   * the end, as an instance of the class {@link Pair}. The pair may not be null
   */
  @NonNull
  private Pair<Float, State> calculatePositionAndStateWhenStackedAtEnd(final int index) {
    float size = getArithmetics().getTabContainerSize(Axis.DRAGGING_AXIS, false);

    if (index < stackedTabCount) {
      float position = size - tabInset - (stackedTabSpacing * (index + 1));
      return Pair.create(position, State.STACKED_END);
    } else {
      float position = size - tabInset - (stackedTabSpacing * stackedTabCount);
      return Pair.create(position, State.HIDDEN);
    }
  }

  /**
   * The method, which is invoked on implementing subclasses in order to retrieve, whether the
   * tabs are overshooting at the start.
   *
   * @return True, if the tabs are overshooting at the start, false otherwise
   */
  private boolean isOvershootingAtStart() {
    if (getTabSwitcher().getCount() <= 1) {
      return true;
    } else {
      AbstractTabItemIterator iterator =
        new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
      TabItem tabItem = iterator.getItem(0);
      return tabItem.getTag().getState() == State.STACKED_START_ATOP;
    }
  }

  /**
   * The method, which is invoked on implementing subclasses in order to retrieve, whether the
   * tabs are overshooting at the end.
   *
   * @param iterator An iterator, which allows to iterate the tabs, which are contained by the tab
   *                 switcher, as an instance of the class {@link AbstractTabItemIterator}. The iterator
   *                 may not be null
   * @return True, if the tabs are overshooting at the end, false otherwise
   */
  private boolean isOvershootingAtEnd(@NonNull final AbstractTabItemIterator iterator) {
    if (getTabSwitcher().getCount() <= 1) {
      return true;
    } else {
      TabItem lastTabItem = iterator.getItem(getTabSwitcher().getCount() - 1);
      TabItem predecessor = iterator.getItem(getTabSwitcher().getCount() - 2);
      return Math.round(predecessor.getTag().getPosition()) >=
        Math.round(calculateMaxTabSpacing(getTabSwitcher().getCount(), lastTabItem));
    }
  }

  /**
   * Calculates and returns the bottom margin of a view, which visualizes a tab.
   *
   * @param view The view, whose bottom margin should be calculated, as an instance of the class
   *             {@link View}. The view may not be null
   * @return The bottom margin, which has been calculated, in pixels as an {@link Integer} value
   */
  private int calculateBottomMargin(@NonNull final View view) {
    float tabHeight = (view.getHeight() - 2 * tabInset) * getArithmetics().getScale(view, true);
    float containerHeight = getArithmetics().getTabContainerSize(Axis.Y_AXIS, false);
    int stackHeight = getTabSwitcher().getLayout() == Layout.PHONE_LANDSCAPE ? 0 :
      stackedTabCount * stackedTabSpacing;
    return Math.round(tabHeight + tabInset + stackHeight - containerHeight);
  }

  /**
   * Animates the bottom margin of a specific view.
   *
   * @param view     The view, whose bottom margin should be animated, as an instance of the class {@link
   *                 View}. The view may not be null
   * @param margin   The bottom margin, which should be set by the animation, as an {@link Integer} value
   * @param duration The duration of the animation in milliseconds as a {@link Long} value
   * @param delay    The delay of the animation in milliseconds as a {@link Long} value
   */
  private void animateBottomMargin(@NonNull final View view, final int margin,
                                   final long duration, final long delay) {
    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams();
    final int initialMargin = layoutParams.bottomMargin;
    ValueAnimator animation = ValueAnimator.ofInt(margin - initialMargin);
    animation.setDuration(duration);
    animation.addListener(new AnimationListenerWrapper(null));
    animation.setInterpolator(new AccelerateDecelerateInterpolator());
    animation.setStartDelay(delay);
    animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

      @Override
      public void onAnimationUpdate(ValueAnimator animation) {
        FrameLayout.LayoutParams layoutParams =
          (FrameLayout.LayoutParams) view.getLayoutParams();
        layoutParams.bottomMargin = initialMargin + (int) animation.getAnimatedValue();
        view.setLayoutParams(layoutParams);
      }

    });

    animation.start();
  }

  /**
   * Animates the visibility of the toolbar, which is shown, when the tab switcher is shown.
   *
   * @param visible True, if the toolbar should become visible, false otherwise
   * @param delay   The delay of the animation in milliseconds as a {@link Long} value
   */
  private void animateToolbarVisibility(final boolean visible, final long delay) {
    if (toolbarAnimation != null) {
      toolbarAnimation.cancel();
    }

    float targetAlpha = visible ? 1 : 0;

    if (toolbar.getAlpha() != targetAlpha) {
      toolbarAnimation = toolbar.animate();
      toolbarAnimation.setInterpolator(new AccelerateDecelerateInterpolator());
      toolbarAnimation.setDuration(toolbarVisibilityAnimationDuration);
      toolbarAnimation.setStartDelay(delay);
      toolbarAnimation.alpha(targetAlpha);
      toolbarAnimation.start();
    }
  }

  /**
   * Shows the tab switcher in an animated manner.
   */
  private void animateShowSwitcher() {
    TabItem[] tabItems = calculateInitialTabItems(-1, -1);
    AbstractTabItemIterator iterator = new InitialTabItemIterator(tabItems, false, 0);
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.getTab() == getModel().getSelectedTab() || tabItem.isVisible()) {
        viewRecycler.inflate(tabItem);
        View view = tabItem.getView();

        if (!ViewCompat.isLaidOut(view)) {
          view.getViewTreeObserver().addOnGlobalLayoutListener(
            new LayoutListenerWrapper(view,
              createShowSwitcherLayoutListener(tabItem)));
        } else {
          animateShowSwitcher(tabItem, createUpdateViewAnimationListener(tabItem));
        }
      }
    }

    animateToolbarVisibility(getModel().areToolbarsShown(), toolbarVisibilityAnimationDelay);
  }

  /**
   * Calculates and returns the tab items, which correspond to the tabs, when the tab switcher is
   * shown initially.
   *
   * @param firstVisibleTabIndex    The index of the first visible tab as an {@link Integer} value or -1, if the index is
   *                                unknown
   * @param firstVisibleTabPosition The position of the first visible tab in pixels as a {@link Float} value or -1, if
   *                                the position is unknown
   * @return An array, which contains the tab items, as an array of the type {@link TabItem}. The
   * array may not be null
   */
  @NonNull
  private TabItem[] calculateInitialTabItems(final int firstVisibleTabIndex,
                                             final float firstVisibleTabPosition) {
    dragHandler.reset(getDragThreshold());
    firstVisibleIndex = -1;
    TabItem[] tabItems = new TabItem[getModel().getCount()];

    if (!getModel().isEmpty()) {
      int selectedTabIndex = getModel().getSelectedTabIndex();
      float attachedPosition = calculateAttachedPosition(getModel().getCount());
      int referenceIndex = firstVisibleTabIndex != -1 && firstVisibleTabPosition != -1 ?
        firstVisibleTabIndex : selectedTabIndex;
      float referencePosition = firstVisibleTabIndex != -1 && firstVisibleTabPosition != -1 ?
        firstVisibleTabPosition : attachedPosition;
      referencePosition = Math.min(calculateEndPosition(referenceIndex), referencePosition);
      AbstractTabItemIterator iterator =
        new InitialTabItemIterator(tabItems, false, referenceIndex);
      TabItem tabItem;

      while ((tabItem = iterator.next()) != null) {
        TabItem predecessor = iterator.previous();
        float position;

        if (tabItem.getIndex() == getModel().getCount() - 1) {
          position = 0;
        } else if (tabItem.getIndex() == referenceIndex) {
          position = referencePosition;
        } else {
          position = calculateNonLinearPosition(tabItem, predecessor);
        }

        Pair<Float, State> pair =
          clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
            predecessor);
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);

        if (firstVisibleIndex == -1 && pair.second != State.STACKED_END &&
          pair.second != State.HIDDEN) {
          firstVisibleIndex = tabItem.getIndex();
        }

        if (pair.second == State.STACKED_START || pair.second == State.STACKED_START_ATOP) {
          break;
        }
      }

      boolean overshooting =
        referenceIndex == getModel().getCount() - 1 || isOvershootingAtEnd(iterator);
      iterator = new InitialTabItemIterator(tabItems, true, referenceIndex - 1);
      float minTabSpacing = calculateMinTabSpacing(getModel().getCount());
      float defaultTabSpacing = calculateMaxTabSpacing(getModel().getCount(), null);
      TabItem selectedTabItem =
        TabItem.create(getTabSwitcher(), viewRecycler, selectedTabIndex);
      float maxTabSpacing = calculateMaxTabSpacing(getModel().getCount(), selectedTabItem);
      TabItem currentReferenceTabItem = iterator.getItem(referenceIndex);

      while ((tabItem = iterator.next()) != null &&
        (overshooting || tabItem.getIndex() < referenceIndex)) {
        float currentTabSpacing =
          calculateMaxTabSpacing(getModel().getCount(), currentReferenceTabItem);
        TabItem predecessor = iterator.peek();
        Pair<Float, State> pair;

        if (overshooting) {
          float position;

          if (referenceIndex > tabItem.getIndex()) {
            position = maxTabSpacing +
              ((getModel().getCount() - 1 - tabItem.getIndex() - 1) *
                defaultTabSpacing);
          } else {
            position = (getModel().getCount() - 1 - tabItem.getIndex()) *
              defaultTabSpacing;
          }

          pair = clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
            predecessor);
        } else if (referencePosition >= attachedPosition - currentTabSpacing) {
          float position;

          if (selectedTabIndex > tabItem.getIndex() &&
            selectedTabIndex <= referenceIndex) {
            position = referencePosition + maxTabSpacing +
              ((referenceIndex - tabItem.getIndex() - 1) * defaultTabSpacing);
          } else {
            position = referencePosition +
              ((referenceIndex - tabItem.getIndex()) * defaultTabSpacing);
          }

          pair = clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
            predecessor);
        } else {
          TabItem successor = iterator.previous();
          float successorPosition = successor.getTag().getPosition();
          float position = (attachedPosition * (successorPosition + minTabSpacing)) /
            (minTabSpacing + attachedPosition - currentTabSpacing);
          pair = clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
            predecessor);

          if (pair.first >= attachedPosition - currentTabSpacing) {
            currentReferenceTabItem = tabItem;
            referencePosition = pair.first;
            referenceIndex = tabItem.getIndex();
          }
        }

        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);

        if ((firstVisibleIndex == -1 || firstVisibleIndex > tabItem.getIndex()) &&
          pair.second == State.FLOATING) {
          firstVisibleIndex = tabItem.getIndex();
        }
      }
    }

    dragHandler.setCallback(this);
    return tabItems;
  }

  /**
   * Adds all tabs, which are contained by an array, to the tab switcher.
   *
   * @param index     The index, the first tab should be added at, as an {@link Integer} value
   * @param tabs      The array, which contains the tabs, which should be added, as an array of the type
   *                  {@link Tab}. The array may not be null
   * @param animation The animation, which should be used to add the tabs, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  private void addAllTabs(final int index, @NonNull final Tab[] tabs,
                          @NonNull final Animation animation) {
    if (tabs.length > 0) {
      if (getModel().isSwitcherShown()) {
        SwipeAnimation swipeAnimation =
          animation instanceof SwipeAnimation ? (SwipeAnimation) animation :
            new SwipeAnimation.Builder().create();
        TabItem[] tabItems = new TabItem[tabs.length];
        OnGlobalLayoutListener compoundListener = new CompoundLayoutListener(tabs.length,
          createSwipeLayoutListener(tabItems, swipeAnimation));

        for (int i = 0; i < tabs.length; i++) {
          Tab tab = tabs[i];
          TabItem tabItem = new TabItem(index + i, tab);
          tabItems[i] = tabItem;
          inflateView(tabItem, compoundListener);
        }
      } else if (!getModel().isSwitcherShown()) {
        toolbar.setAlpha(0);

        if (getModel().getSelectedTab() == tabs[0]) {
          TabItem tabItem = TabItem.create(getTabSwitcher(), viewRecycler, index);
          inflateView(tabItem, createAddSelectedTabLayoutListener(tabItem));
        }
      }
    }
  }

  /**
   * Animates the position and size of a specific tab item in order to show the tab switcher.
   *
   * @param tabItem  The tab item, which should be animated, as an instance of the class {@link TabItem}.
   *                 The tab item may not be null
   * @param listener The listener, which should be notified about the animation's progress, as an instance
   *                 of the type {@link AnimatorListener} or null, if no listener should be notified
   */
  private void animateShowSwitcher(@NonNull final TabItem tabItem,
                                   @Nullable final AnimatorListener listener) {
    animateShowSwitcher(tabItem, showSwitcherAnimationDuration,
      new AccelerateDecelerateInterpolator(), listener);
  }

  /**
   * Animates the position and size of a specific tab in order to show the tab switcher.
   *
   * @param tabItem      The tab item, which should be animated, as an instance of the class {@link TabItem}.
   *                     The tab item may not be null
   * @param duration     The duration of the animation in milliseconds as a {@link Long} value
   * @param interpolator The interpolator, which should be used by the animation, as an instance of the type
   *                     {@link Interpolator}. The interpolator may not be null
   * @param listener     The listener, which should be notified about the animation's progress, as an instance
   *                     of the type {@link AnimatorListener} or null, if no listener should be notified
   */
  private void animateShowSwitcher(@NonNull final TabItem tabItem, final long duration,
                                   @NonNull final Interpolator interpolator,
                                   @Nullable final AnimatorListener listener) {
    View view = tabItem.getView();
    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams();
    view.setX(layoutParams.leftMargin);
    view.setY(layoutParams.topMargin);
    getArithmetics().setScale(Axis.DRAGGING_AXIS, view, 1);
    getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, 1);
    getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
      getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
    getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
      getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.NONE));
    float scale = getArithmetics().getScale(view, true);
    int selectedTabIndex = getModel().getSelectedTabIndex();

    if (tabItem.getIndex() < selectedTabIndex) {
      getArithmetics().setPosition(Axis.DRAGGING_AXIS, view,
        getArithmetics().getTabContainerSize(Axis.DRAGGING_AXIS));
    } else if (tabItem.getIndex() > selectedTabIndex) {
      getArithmetics().setPosition(Axis.DRAGGING_AXIS, view,
        getTabSwitcher().getLayout() == Layout.PHONE_LANDSCAPE ? 0 :
          layoutParams.topMargin);
    }

    if (tabViewBottomMargin == -1) {
      tabViewBottomMargin = calculateBottomMargin(view);
    }

    animateBottomMargin(view, tabViewBottomMargin, duration, 0);
    ViewPropertyAnimator animation = view.animate();
    animation.setDuration(duration);
    animation.setInterpolator(interpolator);
    animation.setListener(new AnimationListenerWrapper(listener));
    getArithmetics().animateScale(Axis.DRAGGING_AXIS, animation, scale);
    getArithmetics().animateScale(Axis.ORTHOGONAL_AXIS, animation, scale);
    getArithmetics().animatePosition(Axis.DRAGGING_AXIS, animation, view,
      tabItem.getTag().getPosition(), true);
    getArithmetics().animatePosition(Axis.ORTHOGONAL_AXIS, animation, view, 0, true);
    animation.setStartDelay(0);
    animation.start();
  }

  /**
   * Hides the tab switcher in an animated manner.
   */
  private void animateHideSwitcher() {
    dragHandler.setCallback(null);
    TabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        animateHideSwitcher(tabItem,
          tabItem.getIndex() == getModel().getSelectedTabIndex() ?
            createHideSwitcherAnimationListener() : null);
      } else if (tabItem.getTab() == getModel().getSelectedTab()) {
        inflateAndUpdateView(tabItem, createHideSwitcherLayoutListener(tabItem));
      }
    }

    animateToolbarVisibility(getModel().areToolbarsShown() && getModel().isEmpty(), 0);
  }

  /**
   * Animates the position and size of a specific tab item in order to hide the tab switcher.
   *
   * @param tabItem  The tab item, which should be animated, as an instance of the class {@link TabItem}.
   *                 The tab item may not be null
   * @param listener The listener, which should be notified about the animation's progress, as an instance
   *                 of the type {@link AnimatorListener} or null, if no listener should be notified
   */
  private void animateHideSwitcher(@NonNull final TabItem tabItem,
                                   @Nullable final AnimatorListener listener) {
    animateHideSwitcher(tabItem, hideSwitcherAnimationDuration,
      new AccelerateDecelerateInterpolator(), 0, listener);
  }

  /**
   * Animates the position and size of a specific tab item in order to hide the tab switcher.
   *
   * @param tabItem      The tab item, which should be animated, as an instance of the class {@link TabItem}.
   *                     The tab item may not be null
   * @param duration     The duration of the animation in milliseconds as a {@link Long} value
   * @param interpolator The interpolator, which should be used by the animation, as an instance of the class
   *                     {@link Interpolator}. The interpolator may not be null
   * @param delay        The delay of the animation in milliseconds as a {@link Long} value
   * @param listener     The listener, which should be notified about the animation's progress, as an instance
   *                     of the type {@link AnimatorListener} or null, if no listener should be notified
   */
  private void animateHideSwitcher(@NonNull final TabItem tabItem, final long duration,
                                   @NonNull final Interpolator interpolator, final long delay,
                                   @Nullable final AnimatorListener listener) {
    View view = tabItem.getView();
    animateBottomMargin(view, -(tabInset + tabBorderWidth), duration, delay);
    ViewPropertyAnimator animation = view.animate();
    animation.setDuration(duration);
    animation.setInterpolator(interpolator);
    animation.setListener(new AnimationListenerWrapper(listener));
    getArithmetics().animateScale(Axis.DRAGGING_AXIS, animation, 1);
    getArithmetics().animateScale(Axis.ORTHOGONAL_AXIS, animation, 1);
    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams();
    getArithmetics().animatePosition(Axis.ORTHOGONAL_AXIS, animation, view,
      getTabSwitcher().getLayout() == Layout.PHONE_LANDSCAPE ? layoutParams.topMargin : 0,
      false);
    int selectedTabIndex = getModel().getSelectedTabIndex();

    if (tabItem.getIndex() < selectedTabIndex) {
      getArithmetics().animatePosition(Axis.DRAGGING_AXIS, animation, view,
        getArithmetics().getTabContainerSize(Axis.DRAGGING_AXIS), false);
    } else if (tabItem.getIndex() > selectedTabIndex) {
      getArithmetics().animatePosition(Axis.DRAGGING_AXIS, animation, view,
        getTabSwitcher().getLayout() == Layout.PHONE_LANDSCAPE ? 0 :
          layoutParams.topMargin, false);
    } else {
      getArithmetics().animatePosition(Axis.DRAGGING_AXIS, animation, view,
        getTabSwitcher().getLayout() == Layout.PHONE_LANDSCAPE ? 0 :
          layoutParams.topMargin, false);
    }

    animation.setStartDelay(delay);
    animation.start();
  }

  /**
   * Animates the position, size and alpha of a specific tab item in order to swipe it
   * orthogonally.
   *
   * @param tabItem        The tab item, which should be animated, as an instance of the class {@link TabItem}.
   *                       The tab item may not be null
   * @param remove         True, if the tab should be removed after the animation has finished, false otherwise
   * @param delay          The delay after which the animation should be started in milliseconds as a {@link
   *                       Long} value
   * @param swipeAnimation The animation, which should be used, as an instance of the class {@link
   *                       SwipeAnimation}. The animation may not be null
   * @param listener       The listener, which should be notified about the progress of the animation, as an
   *                       instance of the type {@link AnimatorListener} or null, if no listener should be
   *                       notified
   */
  private void animateSwipe(@NonNull final TabItem tabItem, final boolean remove,
                            final long delay, @NonNull final SwipeAnimation swipeAnimation,
                            @Nullable final AnimatorListener listener) {
    View view = tabItem.getView();
    float currentScale = getArithmetics().getScale(view, true);
    float swipePosition = calculateSwipePosition();
    float targetPosition = remove ?
      (swipeAnimation.getDirection() == SwipeDirection.LEFT ? -1 * swipePosition :
        swipePosition) : 0;
    float currentPosition = getArithmetics().getPosition(Axis.ORTHOGONAL_AXIS, view);
    float distance = Math.abs(targetPosition - currentPosition);
    long animationDuration = swipeAnimation.getDuration() != -1 ? swipeAnimation.getDuration() :
      Math.round(swipeAnimationDuration * (distance / swipePosition));
    ViewPropertyAnimator animation = view.animate();
    animation.setInterpolator(
      swipeAnimation.getInterpolator() != null ? swipeAnimation.getInterpolator() :
        new AccelerateDecelerateInterpolator());
    animation.setListener(new AnimationListenerWrapper(listener));
    animation.setDuration(animationDuration);
    getArithmetics()
      .animatePosition(Axis.ORTHOGONAL_AXIS, animation, view, targetPosition, true);
    getArithmetics().animateScale(Axis.ORTHOGONAL_AXIS, animation,
      remove ? swipedTabScale * currentScale : currentScale);
    getArithmetics().animateScale(Axis.DRAGGING_AXIS, animation,
      remove ? swipedTabScale * currentScale : currentScale);
    animation.alpha(remove ? swipedTabAlpha : 1);
    animation.setStartDelay(delay);
    animation.start();
  }

  /**
   * Animates the removal of a specific tab item.
   *
   * @param removedTabItem The tab item, which should be animated, as an instance of the class {@link TabItem}.
   *                       The tab item may not be null
   * @param swipeAnimation The animation, which should be used, as an instance of the class {@link
   *                       SwipeAnimation}. The animation may not be null
   */
  private void animateRemove(@NonNull final TabItem removedTabItem,
                             @NonNull final SwipeAnimation swipeAnimation) {
    View view = removedTabItem.getView();
    getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
      getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.SWIPE));
    getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
      getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.SWIPE));
    animateSwipe(removedTabItem, true, 0, swipeAnimation,
      createRemoveAnimationListener(removedTabItem));
  }

  /**
   * Animates the position of a specific tab item in order to relocate it.
   *
   * @param tabItem  The tab item, which should be animated, as an instance of the class {@link TabItem}.
   *                 The tab item may not be null
   * @param position The position, the tab should be relocated to, in pixels as a {@link Float} value
   * @param tag      The tag, which should be applied to the given tab item, as an instance of the class
   *                 {@link Tag} or null, if no tag should be applied
   * @param delay    The delay of the relocate animation in milliseconds as a {@link Long} value
   * @param listener The listener, which should be notified about the progress of the relocate animation,
   *                 as an instance of the type {@link AnimatorListener} or null, if no listener should be
   *                 notified
   */
  private void animateRelocate(@NonNull final TabItem tabItem, final float position,
                               @Nullable final Tag tag, final long delay,
                               @Nullable final AnimatorListener listener) {
    if (tag != null) {
      tabItem.getView().setTag(R.id.tag_properties, tag);
      tabItem.setTag(tag);
    }

    View view = tabItem.getView();
    ViewPropertyAnimator animation = view.animate();
    animation.setListener(new AnimationListenerWrapper(listener));
    animation.setInterpolator(new AccelerateDecelerateInterpolator());
    animation.setDuration(relocateAnimationDuration);
    getArithmetics().animatePosition(Axis.DRAGGING_AXIS, animation, view, position, true);
    animation.setStartDelay(delay);
    animation.start();
  }

  /**
   * Animates reverting an overshoot at the start.
   */
  private void animateRevertStartOvershoot() {
    boolean tilted = animateTilt(new AccelerateInterpolator(), maxStartOvershootAngle,
      createRevertStartOvershootAnimationListener());

    if (!tilted) {
      animateRevertStartOvershoot(new AccelerateDecelerateInterpolator());
    }
  }

  /**
   * Animates reverting an overshoot at the start using a specific interpolator.
   *
   * @param interpolator The interpolator, which should be used by the animation, as an instance of the type
   *                     {@link Interpolator}. The interpolator may not be null
   */
  private void animateRevertStartOvershoot(@NonNull final Interpolator interpolator) {
    TabItem tabItem = TabItem.create(getTabSwitcher(), viewRecycler, 0);
    View view = tabItem.getView();
    getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
      getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
    getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
      getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.NONE));
    float position = getArithmetics().getPosition(Axis.DRAGGING_AXIS, view);
    float targetPosition = tabItem.getTag().getPosition();
    final float startPosition = getArithmetics().getPosition(Axis.DRAGGING_AXIS, view);
    ValueAnimator animation = ValueAnimator.ofFloat(targetPosition - position);
    animation.setDuration(Math.round(revertOvershootAnimationDuration * Math.abs(
      (targetPosition - position) / (float) (stackedTabCount * stackedTabSpacing))));
    animation.addListener(new AnimationListenerWrapper(null));
    animation.setInterpolator(interpolator);
    animation.setStartDelay(0);
    animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {

      @Override
      public void onAnimationUpdate(final ValueAnimator animation) {
        TabItemIterator iterator =
          new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
        TabItem tabItem;

        while ((tabItem = iterator.next()) != null) {
          if (tabItem.getIndex() == 0) {
            View view = tabItem.getView();
            getArithmetics().setPosition(Axis.DRAGGING_AXIS, view,
              startPosition + (float) animation.getAnimatedValue());
          } else if (tabItem.isInflated()) {
            View firstView = iterator.first().getView();
            View view = tabItem.getView();
            view.setVisibility(
              getArithmetics().getPosition(Axis.DRAGGING_AXIS, firstView) <=
                getArithmetics().getPosition(Axis.DRAGGING_AXIS, view) ?
                View.INVISIBLE : View.VISIBLE);
          }
        }
      }

    });

    animation.start();
  }

  /**
   * Animates reverting an overshoot at the end.
   */
  private void animateRevertEndOvershoot() {
    animateTilt(new AccelerateDecelerateInterpolator(), maxEndOvershootAngle, null);
  }

  /**
   * Animates to rotation of all tabs to be reset to normal.
   *
   * @param interpolator The interpolator, which should be used by the animation, as an instance of the type
   *                     {@link Interpolator}. The interpolator may not be null
   * @param maxAngle     The angle, the tabs may be rotated by at maximum, in degrees as a {@link Float}
   *                     value
   * @param listener     The listener, which should be notified about the animation's progress, as an instance
   *                     of the type {@link AnimatorListener} or null, if no listener should be notified
   * @return True, if at least one tab was animated, false otherwise
   */
  private boolean animateTilt(@NonNull final Interpolator interpolator, final float maxAngle,
                              @Nullable final AnimatorListener listener) {
    TabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).reverse(true).create();
    TabItem tabItem;
    boolean result = false;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        View view = tabItem.getView();

        if (getArithmetics().getRotation(Axis.ORTHOGONAL_AXIS, view) != 0) {
          ViewPropertyAnimator animation = view.animate();
          animation.setListener(new AnimationListenerWrapper(
            createRevertOvershootAnimationListener(view,
              !result ? listener : null)));
          animation.setDuration(Math.round(revertOvershootAnimationDuration *
            (Math.abs(getArithmetics().getRotation(Axis.ORTHOGONAL_AXIS, view)) /
              maxAngle)));
          animation.setInterpolator(interpolator);
          getArithmetics().animateRotation(Axis.ORTHOGONAL_AXIS, animation, 0);
          animation.setStartDelay(0);
          animation.start();
          result = true;
        }
      }
    }

    return result;
  }

  /**
   * Starts a reveal animation to add a specific tab.
   *
   * @param tabItem         The tab item, which corresponds to the tab, which should be added, as an instance of
   *                        the class {@link TabItem}. The tab item may not be null
   * @param revealAnimation The reveal animation, which should be started, as an instance of the class {@link
   *                        RevealAnimation}. The reveal animation may not be null
   */
  private void animateReveal(@NonNull final TabItem tabItem,
                             @NonNull final RevealAnimation revealAnimation) {
    tabViewBottomMargin = -1;
    recyclerAdapter.clearCachedPreviews();
    dragHandler.setCallback(null);
    View view = tabItem.getView();
    ViewPropertyAnimator animation = view.animate();
    animation.setInterpolator(
      revealAnimation.getInterpolator() != null ? revealAnimation.getInterpolator() :
        new AccelerateDecelerateInterpolator());
    animation.setListener(new AnimationListenerWrapper(createHideSwitcherAnimationListener()));
    animation.setStartDelay(0);
    animation.setDuration(revealAnimation.getDuration() != -1 ? revealAnimation.getDuration() :
      revealAnimationDuration);
    getArithmetics().animateScale(Axis.DRAGGING_AXIS, animation, 1);
    getArithmetics().animateScale(Axis.ORTHOGONAL_AXIS, animation, 1);
    animation.start();
    animateToolbarVisibility(getModel().areToolbarsShown() && getModel().isEmpty(), 0);
  }

  /**
   * Starts a peek animation to add a specific tab.
   *
   * @param tabItem       The tab item, which corresponds to the tab, which should be added, as an instance of
   *                      the class {@link TabItem}. The tab item may not be null
   * @param duration      The duration of the animation in milliseconds as a {@link Long} value
   * @param interpolator  The interpolator, which should be used by the animation, as an instance of the type
   *                      {@link Interpolator}. The interpolator may not be null
   * @param peekPosition  The position on the dragging axis, the tab should be moved to, in pixels as a {@link
   *                      Float} value
   * @param peekAnimation The peek animation, which has been used to add the tab, as an instance of the class
   *                      {@link PeekAnimation}. The peek animation may not be null
   */
  private void animatePeek(@NonNull final TabItem tabItem, final long duration,
                           @NonNull final Interpolator interpolator, final float peekPosition,
                           @NonNull final PeekAnimation peekAnimation) {
    PhoneTabViewHolder viewHolder = tabItem.getViewHolder();
    viewHolder.closeButton.setVisibility(View.GONE);
    View view = tabItem.getView();
    float x = peekAnimation.getX();
    float y = peekAnimation.getY() + tabTitleContainerHeight;
    FrameLayout.LayoutParams layoutParams = (FrameLayout.LayoutParams) view.getLayoutParams();
    view.setAlpha(1f);
    getArithmetics().setPivot(Axis.X_AXIS, view, x);
    getArithmetics().setPivot(Axis.Y_AXIS, view, y);
    view.setX(layoutParams.leftMargin);
    view.setY(layoutParams.topMargin);
    getArithmetics().setScale(Axis.DRAGGING_AXIS, view, 0);
    getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, 0);
    ViewPropertyAnimator animation = view.animate();
    animation.setInterpolator(interpolator);
    animation.setListener(
      new AnimationListenerWrapper(createPeekAnimationListener(tabItem, peekAnimation)));
    animation.setStartDelay(0);
    animation.setDuration(duration);
    getArithmetics().animateScale(Axis.DRAGGING_AXIS, animation, 1);
    getArithmetics().animateScale(Axis.ORTHOGONAL_AXIS, animation, 1);
    getArithmetics().animatePosition(Axis.DRAGGING_AXIS, animation, view, peekPosition, true);
    animation.start();
    int selectedTabIndex = getModel().getSelectedTabIndex();
    TabItem selectedTabItem = TabItem.create(getModel(), viewRecycler, selectedTabIndex);
    viewRecycler.inflate(selectedTabItem);
    selectedTabItem.getTag().setPosition(0);
    PhoneTabViewHolder selectedTabViewHolder = selectedTabItem.getViewHolder();
    selectedTabViewHolder.closeButton.setVisibility(View.GONE);
    animateShowSwitcher(selectedTabItem, duration, interpolator,
      createZoomOutAnimationListener(selectedTabItem, peekAnimation));
  }

  /**
   * Creates and returns a layout listener, which allows to animate the position and size of a tab
   * in order to show the tab switcher, once its view has been inflated.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose view should be animated, as an
   *                instance of the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createShowSwitcherLayoutListener(
    @NonNull final TabItem tabItem) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        animateShowSwitcher(tabItem, createUpdateViewAnimationListener(tabItem));
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to animate the position and size of a tab
   * in order to hide the tab switcher, once its view has been inflated.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose view should be animated, as an
   *                instance of the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createHideSwitcherLayoutListener(
    @NonNull final TabItem tabItem) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        animateHideSwitcher(tabItem,
          tabItem.getIndex() == getModel().getSelectedTabIndex() ?
            createHideSwitcherAnimationListener() : null);
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to remove a tab, once its view has been
   * inflated.
   *
   * @param tabItem        The tab item, which corresponds to the tab, which should be removed, as an instance
   *                       of the class {@link TabItem}. The tab item may not be null
   * @param swipeAnimation The animation, which should be used, as an instance of the class {@link
   *                       SwipeAnimation}. The animation may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createRemoveLayoutListener(@NonNull final TabItem tabItem,
                                                            @NonNull final SwipeAnimation swipeAnimation) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        animateRemove(tabItem, swipeAnimation);
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to relocate a tab, once its view has been
   * inflated.
   *
   * @param tabItem  The tab item, which corresponds to the tab, which should be relocated, as an instance
   *                 of the class {@link TabItem}. The tab item may not be null
   * @param position The position, the tab should be relocated to, in pixels as a {@link Float} value
   * @param tag      The tag, which should be applied to the given tab item, as an instance of the class
   *                 {@link Tag} or null, if no tag should be applied
   * @param delay    The delay of the relocate animation in milliseconds as a {@link Long} value
   * @param listener The listener, which should be notified about the progress of the relocate animation,
   *                 as an instance of the type {@link AnimatorListener} or null, if no listener should be
   *                 notified
   * @return The listener, which has been created, as an instance of the class {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createRelocateLayoutListener(@NonNull final TabItem tabItem,
                                                              final float position,
                                                              @Nullable final Tag tag,
                                                              final long delay,
                                                              @Nullable final AnimatorListener listener) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        animateRelocate(tabItem, position, tag, delay, listener);
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to show a tab as the currently selected
   * one, once it view has been inflated.
   *
   * @param tabItem The tab item, which corresponds to the tab, which has been added, as an instance of
   *                the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createAddSelectedTabLayoutListener(
    @NonNull final TabItem tabItem) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        View view = tabItem.getView();
        FrameLayout.LayoutParams layoutParams =
          (FrameLayout.LayoutParams) view.getLayoutParams();
        view.setAlpha(1f);
        getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
          getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
        getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
          getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.NONE));
        view.setX(layoutParams.leftMargin);
        view.setY(layoutParams.topMargin);
        getArithmetics().setScale(Axis.DRAGGING_AXIS, view, 1);
        getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, 1);
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to start a reveal animation to add a tab,
   * once its view has been inflated.
   *
   * @param tabItem         The tab item, which corresponds to the tab, which should be added, as an instance of
   *                        the class {@link TabItem}. The tab item may not be null
   * @param revealAnimation The reveal animation, which should be started, as an instance of the class {@link
   *                        RevealAnimation}. The reveal animation may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createRevealLayoutListener(@NonNull final TabItem tabItem,
                                                            @NonNull final RevealAnimation revealAnimation) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        View view = tabItem.getView();
        float x = revealAnimation.getX();
        float y = revealAnimation.getY() + tabTitleContainerHeight;
        FrameLayout.LayoutParams layoutParams =
          (FrameLayout.LayoutParams) view.getLayoutParams();
        view.setAlpha(1f);
        getArithmetics().setPivot(Axis.X_AXIS, view, x);
        getArithmetics().setPivot(Axis.Y_AXIS, view, y);
        view.setX(layoutParams.leftMargin);
        view.setY(layoutParams.topMargin);
        getArithmetics().setScale(Axis.DRAGGING_AXIS, view, 0);
        getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, 0);
        animateReveal(tabItem, revealAnimation);
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to start a peek animation to add a tab,
   * once its view has been inflated.
   *
   * @param tabItem       The tab item, which corresponds to the tab, which should be added, as an instance of
   *                      the class {@link TabItem}. The tab item may not be null
   * @param peekAnimation The peek animation, which should be started, as an instance of the class {@link
   *                      PeekAnimation}. The peek animation may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  private OnGlobalLayoutListener createPeekLayoutListener(@NonNull final TabItem tabItem,
                                                          @NonNull final PeekAnimation peekAnimation) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        long totalDuration =
          peekAnimation.getDuration() != -1 ? peekAnimation.getDuration() :
            peekAnimationDuration;
        long duration = totalDuration / 3;
        Interpolator interpolator =
          peekAnimation.getInterpolator() != null ? peekAnimation.getInterpolator() :
            new AccelerateDecelerateInterpolator();
        float peekPosition =
          getArithmetics().getTabContainerSize(Axis.DRAGGING_AXIS, false) * 0.66f;
        animatePeek(tabItem, duration, interpolator, peekPosition, peekAnimation);
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to start a swipe animations to add
   * several tabs, once their views have been inflated.
   *
   * @param addedTabItems  An array, which contains the tab items, which correspond to the tabs, which should be
   *                       added, as an array of the type {@link TabItem}. The array may not be null
   * @param swipeAnimation The swipe animation, which should be started, as an instance of the class {@link
   *                       SwipeAnimation}. The swipe animation may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createSwipeLayoutListener(@NonNull final TabItem[] addedTabItems,
                                                           @NonNull final SwipeAnimation swipeAnimation) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        int count = getModel().getCount();
        float previousAttachedPosition =
          calculateAttachedPosition(count - addedTabItems.length);
        float attachedPosition = calculateAttachedPosition(count);
        TabItem[] tabItems;

        if (count - addedTabItems.length == 0) {
          tabItems = calculateInitialTabItems(-1, -1);
        } else {
          TabItem firstAddedTabItem = addedTabItems[0];
          int index = firstAddedTabItem.getIndex();
          boolean isReferencingPredecessor = index > 0;
          int referenceIndex = isReferencingPredecessor ? index - 1 :
            (index + addedTabItems.length - 1 < count - 1 ?
              index + addedTabItems.length : -1);
          TabItem referenceTabItem = referenceIndex != -1 ?
            TabItem.create(getTabSwitcher(), viewRecycler, referenceIndex) : null;
          State state =
            referenceTabItem != null ? referenceTabItem.getTag().getState() : null;

          if (state == null || state == State.STACKED_START) {
            tabItems = relocateWhenAddingStackedTabs(true, addedTabItems);
          } else if (state == State.STACKED_END) {
            tabItems = relocateWhenAddingStackedTabs(false, addedTabItems);
          } else if (state == State.FLOATING ||
            (state == State.STACKED_START_ATOP && (index > 0 || count <= 2))) {
            tabItems = relocateWhenAddingFloatingTabs(addedTabItems, referenceTabItem,
              isReferencingPredecessor, attachedPosition,
              attachedPosition != previousAttachedPosition);
          } else {
            tabItems = relocateWhenAddingHiddenTabs(addedTabItems, referenceTabItem);
          }
        }

        Tag previousTag = null;

        for (TabItem tabItem : tabItems) {
          Tag tag = tabItem.getTag();

          if (previousTag == null || tag.getPosition() != previousTag.getPosition()) {
            createBottomMarginLayoutListener(tabItem).onGlobalLayout();
            View view = tabItem.getView();
            view.setTag(R.id.tag_properties, tag);
            view.setAlpha(swipedTabAlpha);
            float swipePosition = calculateSwipePosition();
            float scale = getArithmetics().getScale(view, true);
            getArithmetics().setPivot(Axis.DRAGGING_AXIS, view, getArithmetics()
              .getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
            getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view, getArithmetics()
              .getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.NONE));
            getArithmetics().setPosition(Axis.DRAGGING_AXIS, view, tag.getPosition());
            getArithmetics().setPosition(Axis.ORTHOGONAL_AXIS, view,
              swipeAnimation.getDirection() == SwipeDirection.LEFT ?
                -1 * swipePosition : swipePosition);
            getArithmetics().setScale(Axis.DRAGGING_AXIS, view, scale);
            getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, scale);
            getArithmetics().setPivot(Axis.DRAGGING_AXIS, view, getArithmetics()
              .getPivot(Axis.DRAGGING_AXIS, view, DragState.SWIPE));
            getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view, getArithmetics()
              .getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.SWIPE));
            getArithmetics().setScale(Axis.DRAGGING_AXIS, view, swipedTabScale * scale);
            getArithmetics()
              .setScale(Axis.ORTHOGONAL_AXIS, view, swipedTabScale * scale);
            animateSwipe(tabItem, false, 0, swipeAnimation,
              createSwipeAnimationListener(tabItem));
          } else {
            viewRecycler.remove(tabItem);
          }

          previousTag = tag;
        }
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to adapt the bottom margin of a tab, once
   * its view has been inflated.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose view should be adapted, as an
   *                instance of the class {@link TabItem}. The tab item may not be null
   * @return The layout listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The layout listener may not be null
   */
  private OnGlobalLayoutListener createBottomMarginLayoutListener(
    @NonNull final TabItem tabItem) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        View view = tabItem.getView();

        if (tabViewBottomMargin == -1) {
          tabViewBottomMargin = calculateBottomMargin(view);
        }

        FrameLayout.LayoutParams layoutParams =
          (FrameLayout.LayoutParams) view.getLayoutParams();
        layoutParams.bottomMargin = tabViewBottomMargin;
        view.setLayoutParams(layoutParams);
      }

    };
  }

  /**
   * Creates and returns a layout listener, which allows to adapt the size and position of a tab,
   * once its view has been inflated.
   *
   * @param tabItem        The tab item, which corresponds to the tab, whose view should be adapted, as an
   *                       instance of the class {@link TabItem}. The tab item may not be null
   * @param layoutListener The layout lister, which should be notified, when the created listener is invoked, as
   *                       an instance of the type {@link OnGlobalLayoutListener} or null, if no listener should
   *                       be notified
   * @return The layout listener, which has been created, as an instance of the type {@link
   * OnGlobalLayoutListener}. The layout listener may not be null
   */
  @NonNull
  private OnGlobalLayoutListener createInflateViewLayoutListener(@NonNull final TabItem tabItem,
                                                                 @Nullable final OnGlobalLayoutListener layoutListener) {
    return new OnGlobalLayoutListener() {

      @Override
      public void onGlobalLayout() {
        adaptViewSize(tabItem);
        updateView(tabItem);

        if (layoutListener != null) {
          layoutListener.onGlobalLayout();
        }
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to update the view, which is used to
   * visualize a specific tab, when an animation has been finished.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose view should be updated, as an
   *                instance of the class {@link TabItem}. The tab item may not be null
   * @return The animation listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createUpdateViewAnimationListener(@NonNull final TabItem tabItem) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        inflateOrRemoveView(tabItem);
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to inflate or remove the views, which
   * are used to visualize tabs, when an animation, which is used to hide the tab switcher,
   * has been finished.
   *
   * @return The animation listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createHideSwitcherAnimationListener() {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        AbstractTabItemIterator iterator =
          new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
        TabItem tabItem;

        while ((tabItem = iterator.next()) != null) {
          if (tabItem.getTab() == getModel().getSelectedTab()) {
            Pair<View, Boolean> pair = viewRecycler.inflate(tabItem);
            View view = pair.first;
            FrameLayout.LayoutParams layoutParams =
              (FrameLayout.LayoutParams) view.getLayoutParams();
            view.setAlpha(1f);
            getArithmetics().setScale(Axis.DRAGGING_AXIS, view, 1);
            getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, 1);
            view.setX(layoutParams.leftMargin);
            view.setY(layoutParams.topMargin);
          } else {
            viewRecycler.remove(tabItem);
          }
        }

        viewRecycler.clearCache();
        recyclerAdapter.clearCachedPreviews();
        tabViewBottomMargin = -1;
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to remove all tabs, when the
   * animation, which is used to swipe all tabs, has been finished.
   *
   * @return The animation listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createClearAnimationListener() {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        viewRecycler.removeAll();
        animateToolbarVisibility(getModel().areToolbarsShown(), 0);
      }

    };
  }

  /**
   * Creates and returns a listener, which allows to handle, when a tab has been swiped, but was
   * not removed.
   *
   * @param tabItem The tab item, which corresponds to the tab, which has been swiped, as an instance of
   *                the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createSwipeAnimationListener(@NonNull final TabItem tabItem) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        inflateOrRemoveView(tabItem);
        View view = tabItem.getView();
        adaptStackOnSwipeAborted(tabItem, tabItem.getIndex() + 1);
        tabItem.getTag().setClosing(false);
        getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
          getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
        animateToolbarVisibility(true, 0);
      }

    };
  }

  /**
   * Creates and returns a listener, which allows to relocate all previous tabs, when a tab has
   * been removed.
   *
   * @param removedTabItem The tab item, which corresponds to the tab, which has been removed, as an instance of
   *                       the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createRemoveAnimationListener(@NonNull final TabItem removedTabItem) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationStart(final Animator animation) {
        super.onAnimationStart(animation);

        if (getModel().isEmpty()) {
          animateToolbarVisibility(getModel().areToolbarsShown(), 0);
        }

        float previousAttachedPosition =
          calculateAttachedPosition(getModel().getCount() + 1);
        float attachedPosition = calculateAttachedPosition(getModel().getCount());
        State state = removedTabItem.getTag().getState();

        if (state == State.STACKED_END) {
          relocateWhenRemovingStackedTab(removedTabItem, false);
        } else if (state == State.STACKED_START) {
          relocateWhenRemovingStackedTab(removedTabItem, true);
        } else if (state == State.FLOATING || state == State.STACKED_START_ATOP) {
          relocateWhenRemovingFloatingTab(removedTabItem, attachedPosition,
            previousAttachedPosition != attachedPosition);
        }
      }

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        viewRecycler.remove(removedTabItem);
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to update or remove the view, which
   * is used to visualize a tab, when the animation, which has been used to relocate it, has been
   * ended.
   *
   * @param tabItem The tab item, which corresponds to the tab, which has been relocated, as an instance
   *                of the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createRelocateAnimationListener(@NonNull final TabItem tabItem) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationStart(final Animator animation) {
        super.onAnimationStart(animation);
        tabItem.getView().setVisibility(View.VISIBLE);
      }

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);

        if (tabItem.getTag().getState() == State.STACKED_START_ATOP) {
          adaptStackOnSwipeAborted(tabItem, tabItem.getIndex() + 1);
        }

        if (tabItem.isVisible()) {
          updateView(tabItem);
        } else {
          viewRecycler.remove(tabItem);
        }
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to adapt the pivot of a specific
   * view, when an animation, which reverted an overshoot, has been ended.
   *
   * @param view     The view, whose pivot should be adapted, as an instance of the class {@link View}.
   *                 The view may not be null
   * @param listener The listener, which should be notified about the animation's progress, as an instance
   *                 of the type {@link AnimatorListener} or null, if no listener should be notified
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createRevertOvershootAnimationListener(@NonNull final View view,
                                                                  @Nullable final AnimatorListener listener) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
          getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
        getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
          getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));

        if (listener != null) {
          listener.onAnimationEnd(animation);
        }
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to revert an overshoot at the start,
   * when an animation has been ended.
   *
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createRevertStartOvershootAnimationListener() {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        animateRevertStartOvershoot(new DecelerateInterpolator());
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to hide a tab, which has been added
   * by using a peek animation, when the animation has been ended.
   *
   * @param tabItem       The tab item, which corresponds to the tab, which has been added by using the peek
   *                      animation, as an instance of the class {@link TabItem}. The tab item may not be null
   * @param peekAnimation The peek animation as an instance of the class {@link PeekAnimation}. The peek
   *                      animation may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createPeekAnimationListener(@NonNull final TabItem tabItem,
                                                       @NonNull final PeekAnimation peekAnimation) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        long totalDuration =
          peekAnimation.getDuration() != -1 ? peekAnimation.getDuration() :
            peekAnimationDuration;
        long duration = totalDuration / 3;
        Interpolator interpolator =
          peekAnimation.getInterpolator() != null ? peekAnimation.getInterpolator() :
            new AccelerateDecelerateInterpolator();
        View view = tabItem.getView();
        getArithmetics().setPivot(Axis.DRAGGING_AXIS, view, tabTitleContainerHeight);
        getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
          getArithmetics().getSize(Axis.ORTHOGONAL_AXIS, view) / 2f);
        ViewPropertyAnimator animator = view.animate();
        animator.setDuration(duration);
        animator.setStartDelay(duration);
        animator.setInterpolator(interpolator);
        animator.setListener(
          new AnimationListenerWrapper(createRevertPeekAnimationListener(tabItem)));
        animator.alpha(0);
        getArithmetics().animatePosition(Axis.DRAGGING_AXIS, animator, view,
          getArithmetics().getPosition(Axis.DRAGGING_AXIS, view) * 1.5f, false);
        getArithmetics().animateScale(Axis.DRAGGING_AXIS, animator, 0);
        getArithmetics().animateScale(Axis.ORTHOGONAL_AXIS, animator, 0);
        animator.start();
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to remove the view of a tab, which
   * has been added by using a peek animation, when the animation, which reverts the peek
   * animation, has been ended.
   *
   * @param tabItem The tab item, which corresponds to the tab, which has been added by using the peek
   *                animation, as an instance of the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createRevertPeekAnimationListener(@NonNull final TabItem tabItem) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        viewRecycler.remove(tabItem);
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to zoom in the currently selected
   * tab, when a peek animation has been ended.
   *
   * @param selectedTabItem The tab item, which corresponds to the currently selected tab, as an instance of the
   *                        class {@link TabItem}. The tab item may not be null
   * @param peekAnimation   The peek animation as an instance of the class {@link PeekAnimation}. The peek
   *                        animation may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  @NonNull
  private AnimatorListener createZoomOutAnimationListener(@NonNull final TabItem selectedTabItem,
                                                          @NonNull final PeekAnimation peekAnimation) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        getModel().removeListener(PhoneTabSwitcherLayout.this);
        getModel().hideSwitcher();
        long totalDuration =
          peekAnimation.getDuration() != -1 ? peekAnimation.getDuration() :
            peekAnimationDuration;
        long duration = totalDuration / 3;
        Interpolator interpolator =
          peekAnimation.getInterpolator() != null ? peekAnimation.getInterpolator() :
            new AccelerateDecelerateInterpolator();
        animateHideSwitcher(selectedTabItem, duration, interpolator, duration,
          createZoomInAnimationListener(selectedTabItem));
      }

    };
  }

  /**
   * Creates and returns an animation listener, which allows to restore the original state of a
   * tab, when an animation, which zooms in the tab, has been ended.
   *
   * @param tabItem The tab item, which corresponds to the tab, which has been zoomed in, as an instance
   *                of the class {@link TabItem}. The tab item may not be null
   * @return The listener, which has been created, as an instance of the type {@link
   * AnimatorListener}. The listener may not be null
   */
  private AnimatorListener createZoomInAnimationListener(@NonNull final TabItem tabItem) {
    return new AnimatorListenerAdapter() {

      @Override
      public void onAnimationEnd(final Animator animation) {
        super.onAnimationEnd(animation);
        getModel().addListener(PhoneTabSwitcherLayout.this);
        viewRecycler.inflate(tabItem);
        viewRecycler.clearCache();
        recyclerAdapter.clearCachedPreviews();
        tabViewBottomMargin = -1;
      }

    };
  }

  /**
   * Adapts the stack, which is located at the start, when swiping a tab.
   *
   * @param swipedTabItem  The tab item, which corresponds to the swiped tab, as an instance of the class {@link
   *                       TabItem}. The tab item may not be null
   * @param successorIndex The index of the tab, which is located after the swiped tab, as an {@link Integer}
   *                       value
   * @param count          The number of tabs, which are contained by the tab switcher, excluding the swiped
   *                       tab, as an {@link Integer} value
   */
  private void adaptStackOnSwipe(@NonNull final TabItem swipedTabItem, final int successorIndex,
                                 final int count) {
    if (swipedTabItem.getTag().getState() == State.STACKED_START_ATOP &&
      successorIndex < getModel().getCount()) {
      TabItem tabItem = TabItem.create(getTabSwitcher(), viewRecycler, successorIndex);
      State state = tabItem.getTag().getState();

      if (state == State.HIDDEN || state == State.STACKED_START) {
        Pair<Float, State> pair =
          calculatePositionAndStateWhenStackedAtStart(count, swipedTabItem.getIndex(),
            (TabItem) null);
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);
        inflateOrRemoveView(tabItem);
      }
    }
  }

  /**
   * Adapts the stack, which located at the start, when swiping a tab has been aborted.
   *
   * @param swipedTabItem  The tab item, which corresponds to the swiped tab, as an instance of the class {@link
   *                       TabItem}. The tab item may not be null
   * @param successorIndex The index of the the tab, which is located after the swiped tab, as an {@link
   *                       Integer} value
   */
  private void adaptStackOnSwipeAborted(@NonNull final TabItem swipedTabItem,
                                        final int successorIndex) {
    if (swipedTabItem.getTag().getState() == State.STACKED_START_ATOP &&
      successorIndex < getModel().getCount()) {
      TabItem tabItem = TabItem.create(getTabSwitcher(), viewRecycler, successorIndex);

      if (tabItem.getTag().getState() == State.STACKED_START_ATOP) {
        Pair<Float, State> pair =
          calculatePositionAndStateWhenStackedAtStart(getTabSwitcher().getCount(),
            tabItem.getIndex(), swipedTabItem);
        tabItem.getTag().setPosition(pair.first);
        tabItem.getTag().setState(pair.second);
        inflateOrRemoveView(tabItem);
      }
    }
  }

  /**
   * Inflates or removes the view, which is used to visualize a specific tab, depending on the
   * tab's current state.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose view should be inflated or removed,
   *                as an instance of the class {@link TabItem}. The tab item may not be null
   */
  private void inflateOrRemoveView(@NonNull final TabItem tabItem) {
    if (tabItem.isInflated() && !tabItem.isVisible()) {
      viewRecycler.remove(tabItem);
    } else if (tabItem.isVisible()) {
      if (!tabItem.isInflated()) {
        inflateAndUpdateView(tabItem, null);
      } else {
        updateView(tabItem);
      }
    }
  }

  /**
   * Inflates and updates the view, which is used to visualize a specific tab.
   *
   * @param tabItem  The tab item, which corresponds to the tab, whose view should be inflated, as an
   *                 instance of the class {@link TabItem}. The tab item may not be null
   * @param listener The layout listener, which should be notified, when the view has been inflated, as an
   *                 instance of the type {@link OnGlobalLayoutListener} or null, if no listener should be
   *                 notified
   */
  private void inflateAndUpdateView(@NonNull final TabItem tabItem,
                                    @Nullable final OnGlobalLayoutListener listener) {
    inflateView(tabItem, createInflateViewLayoutListener(tabItem, listener),
      tabViewBottomMargin);
  }

  /**
   * Inflates the view, which is used to visualize a specific tab.
   *
   * @param tabItem  The tab item, which corresponds to the tab, whose view should be inflated, as an
   *                 instance of the class {@link TabItem}. The tab item may not be null
   * @param listener The layout listener, which should be notified, when the view has been inflated, as an
   *                 instance of the type {@link OnGlobalLayoutListener} or null, if no listener should be
   *                 notified
   * @param params   An array, which contains optional parameters, which should be passed to the view
   *                 recycler, which is used to inflate the view, as an array of the type {@link Integer}.
   *                 The array may not be null
   */
  private void inflateView(@NonNull final TabItem tabItem,
                           @Nullable final OnGlobalLayoutListener listener,
                           @NonNull final Integer... params) {
    Pair<View, Boolean> pair = viewRecycler.inflate(tabItem, params);

    if (listener != null) {
      boolean inflated = pair.second;

      if (inflated) {
        View view = pair.first;
        view.getViewTreeObserver()
          .addOnGlobalLayoutListener(new LayoutListenerWrapper(view, listener));
      } else {
        listener.onGlobalLayout();
      }
    }
  }

  /**
   * Adapts the size of the view, which is used to visualize a specific tab.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose view should be adapted, as an
   *                instance of the class {@link TabItem}. The tab item may not be null
   */
  private void adaptViewSize(@NonNull final TabItem tabItem) {
    View view = tabItem.getView();
    getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
      getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
    getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
      getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.NONE));
    float scale = getArithmetics().getScale(view, true);
    getArithmetics().setScale(Axis.DRAGGING_AXIS, view, scale);
    getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, scale);
  }

  /**
   * Updates the view, which is used to visualize a specific tab.
   *
   * @param tabItem The tab item, which corresponds to the tab, whose view should be updated, as an
   *                instance of the class {@link TabItem}. The tab item may not be null
   */
  private void updateView(@NonNull final TabItem tabItem) {
    float position = tabItem.getTag().getPosition();
    View view = tabItem.getView();
    view.setAlpha(1f);
    view.setVisibility(View.VISIBLE);
    getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
      getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
    getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
      getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.NONE));
    getArithmetics().setPosition(Axis.DRAGGING_AXIS, view, position);
    getArithmetics().setPosition(Axis.ORTHOGONAL_AXIS, view, 0);
    getArithmetics().setRotation(Axis.ORTHOGONAL_AXIS, view, 0);
  }

  /**
   * Relocates all previous tabs, when a floating tab has been removed from the tab switcher.
   *
   * @param removedTabItem          The tab item, which corresponds to the tab, which has been removed, as an instance of
   *                                the class {@link TabItem}. The tab item may not be null
   * @param attachedPositionChanged True, if removing the tab caused the attached position to be changed, false
   *                                otherwise
   */
  private void relocateWhenRemovingFloatingTab(@NonNull final TabItem removedTabItem,
                                               final float attachedPosition,
                                               boolean attachedPositionChanged) {
    AbstractTabItemIterator iterator;
    TabItem tabItem;
    float defaultTabSpacing = calculateMaxTabSpacing(getModel().getCount(), null);
    float minTabSpacing = calculateMinTabSpacing(getModel().getCount());
    int referenceIndex = removedTabItem.getIndex();
    TabItem currentReferenceTabItem = removedTabItem;
    float referencePosition = removedTabItem.getTag().getPosition();

    if (attachedPositionChanged && getModel().getCount() > 0) {
      int neighboringIndex =
        removedTabItem.getIndex() > 0 ? referenceIndex - 1 : referenceIndex;
      referencePosition += Math.abs(
        TabItem.create(getTabSwitcher(), viewRecycler, neighboringIndex).getTag()
          .getPosition() - referencePosition) / 2f;
    }

    referencePosition =
      Math.min(calculateEndPosition(removedTabItem.getIndex() - 1), referencePosition);
    float initialReferencePosition = referencePosition;

    if (removedTabItem.getIndex() > 0) {
      int selectedTabIndex = getModel().getSelectedTabIndex();
      TabItem selectedTabItem =
        TabItem.create(getTabSwitcher(), viewRecycler, selectedTabIndex);
      float maxTabSpacing = calculateMaxTabSpacing(getModel().getCount(), selectedTabItem);
      iterator = new TabItemIterator.Builder(getTabSwitcher(), viewRecycler)
        .start(removedTabItem.getIndex() - 1).reverse(true).create();

      while ((tabItem = iterator.next()) != null) {
        TabItem predecessor = iterator.peek();
        float currentTabSpacing =
          calculateMaxTabSpacing(getModel().getCount(), currentReferenceTabItem);
        Pair<Float, State> pair;

        if (tabItem.getIndex() == removedTabItem.getIndex() - 1) {
          pair = clipTabPosition(getModel().getCount(), tabItem.getIndex(),
            referencePosition, predecessor);
          currentReferenceTabItem = tabItem;
          referencePosition = pair.first;
          referenceIndex = tabItem.getIndex();
        } else if (referencePosition >= attachedPosition - currentTabSpacing) {
          float position;

          if (selectedTabIndex > tabItem.getIndex() &&
            selectedTabIndex <= referenceIndex) {
            position = referencePosition + maxTabSpacing +
              ((referenceIndex - tabItem.getIndex() - 1) * defaultTabSpacing);
          } else {
            position = referencePosition +
              ((referenceIndex - tabItem.getIndex()) * defaultTabSpacing);
          }

          pair = clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
            predecessor);
        } else {
          TabItem successor = iterator.previous();
          float successorPosition = successor.getTag().getPosition();
          float position = (attachedPosition * (successorPosition + minTabSpacing)) /
            (minTabSpacing + attachedPosition - currentTabSpacing);
          pair = clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
            predecessor);

          if (pair.first >= attachedPosition - currentTabSpacing) {
            currentReferenceTabItem = tabItem;
            referencePosition = pair.first;
            referenceIndex = tabItem.getIndex();
          }
        }

        Tag tag = tabItem.getTag().clone();
        tag.setPosition(pair.first);
        tag.setState(pair.second);

        if (tag.getState() != State.HIDDEN) {
          long startDelay = Math.abs(removedTabItem.getIndex() - tabItem.getIndex()) *
            relocateAnimationDelay;

          if (!tabItem.isInflated()) {
            Pair<Float, State> pair2 =
              calculatePositionAndStateWhenStackedAtEnd(tabItem.getIndex());
            tabItem.getTag().setPosition(pair2.first);
            tabItem.getTag().setState(pair2.second);
          }

          relocate(tabItem, tag.getPosition(), tag, startDelay);
        } else {
          break;
        }
      }
    }

    if (attachedPositionChanged && getModel().getCount() > 2 &&
      removedTabItem.getTag().getState() != State.STACKED_START_ATOP) {
      iterator = new TabItemIterator.Builder(getTabSwitcher(), viewRecycler)
        .start(removedTabItem.getIndex()).create();
      float previousPosition = initialReferencePosition;
      Tag previousTag = removedTabItem.getTag();

      while ((tabItem = iterator.next()) != null &&
        tabItem.getIndex() < getModel().getCount() - 1) {
        float position = calculateNonLinearPosition(previousPosition,
          calculateMaxTabSpacing(getModel().getCount(), tabItem));
        Pair<Float, State> pair =
          clipTabPosition(getModel().getCount(), tabItem.getIndex(), position,
            previousTag.getState());
        Tag tag = tabItem.getTag().clone();
        tag.setPosition(pair.first);
        tag.setState(pair.second);
        long startDelay = (Math.abs(removedTabItem.getIndex() - tabItem.getIndex()) + 1) *
          relocateAnimationDelay;

        if (!tabItem.isInflated()) {
          Pair<Float, State> pair2 =
            calculatePositionAndStateWhenStackedAtStart(getModel().getCount(),
              tabItem.getIndex(), iterator.previous());
          tabItem.getTag().setPosition(pair2.first);
          tabItem.getTag().setState(pair2.second);
        }

        relocate(tabItem, tag.getPosition(), tag, startDelay);
        previousPosition = pair.first;
        previousTag = tag;

        if (pair.second == State.HIDDEN || pair.second == State.STACKED_START) {
          break;
        }
      }
    }
  }

  /**
   * Relocates all neighboring tabs, when a stacked tab has been removed from the tab switcher.
   *
   * @param removedTabItem The tab item, which corresponds to the tab, which has been removed, as an instance of
   *                       the class {@link TabItem}. The tab item may not be null
   * @param start          True, if the removed tab was part of the stack, which is located at the start, false,
   *                       if it was part of the stack, which is located at the end
   */
  private void relocateWhenRemovingStackedTab(@NonNull final TabItem removedTabItem,
                                              final boolean start) {
    int startIndex = removedTabItem.getIndex() + (start ? -1 : 0);
    TabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).reverse(start)
        .start(startIndex).create();
    TabItem tabItem;
    float previousProjectedPosition = removedTabItem.getTag().getPosition();

    while ((tabItem = iterator.next()) != null &&
      (tabItem.getTag().getState() == State.HIDDEN ||
        tabItem.getTag().getState() == State.STACKED_START ||
        tabItem.getTag().getState() == State.STACKED_START_ATOP ||
        tabItem.getTag().getState() == State.STACKED_END)) {
      float projectedPosition = tabItem.getTag().getPosition();

      if (tabItem.getTag().getState() == State.HIDDEN) {
        TabItem previous = iterator.previous();
        tabItem.getTag().setState(previous.getTag().getState());

        if (tabItem.isVisible()) {
          Pair<Float, State> pair = start ?
            calculatePositionAndStateWhenStackedAtStart(getTabSwitcher().getCount(),
              tabItem.getIndex(), tabItem) :
            calculatePositionAndStateWhenStackedAtEnd(tabItem.getIndex());
          tabItem.getTag().setPosition(pair.first);
          tabItem.getTag().setState(pair.second);
          inflateAndUpdateView(tabItem, null);
        }

        break;
      } else {
        tabItem.getTag().setPosition(previousProjectedPosition);
        long startDelay =
          (Math.abs(startIndex - tabItem.getIndex()) + 1) * relocateAnimationDelay;
        animateRelocate(tabItem, previousProjectedPosition, null, startDelay,
          createRelocateAnimationListener(tabItem));
      }

      previousProjectedPosition = projectedPosition;
    }
  }

  /**
   * Relocates all previous tabs, when floating tabs have been added to the tab switcher.
   *
   * @param addedTabItems            An array, which contains the tab items, which correspond to the tabs, which have been
   *                                 added, as an array of the type {@link TabItem}. The array may not be null
   * @param referenceTabItem         The tab item, which corresponds to the tab, which is used as a reference, as an
   *                                 instance of the class {@link TabItem}. The tab item may not be null
   * @param isReferencingPredecessor True, if the tab, which is used as a reference, is the predecessor of the added tab,
   *                                 false if it is the successor
   * @param attachedPosition         The current attached position in pixels as a {@link Float} value
   * @param attachedPositionChanged  True, if adding the tab caused the attached position to be changed, false otherwise
   * @return An array, which contains the tab items, which correspond to the tabs, which have been
   * added, as an array of the type {@link TabItem}. The array may not be null
   */
  @NonNull
  private TabItem[] relocateWhenAddingFloatingTabs(@NonNull final TabItem[] addedTabItems,
                                                   @NonNull final TabItem referenceTabItem,
                                                   final boolean isReferencingPredecessor,
                                                   final float attachedPosition,
                                                   final boolean attachedPositionChanged) {
    int count = getTabSwitcher().getCount();
    TabItem firstAddedTabItem = addedTabItems[0];
    TabItem lastAddedTabItem = addedTabItems[addedTabItems.length - 1];

    float referencePosition = referenceTabItem.getTag().getPosition();

    if (isReferencingPredecessor && attachedPositionChanged &&
      lastAddedTabItem.getIndex() < count - 1) {
      int neighboringIndex = lastAddedTabItem.getIndex() + 1;
      referencePosition -= Math.abs(referencePosition -
        TabItem.create(getTabSwitcher(), viewRecycler, neighboringIndex).getTag()
          .getPosition()) / 2f;
    }

    float initialReferencePosition = referencePosition;
    int selectedTabIndex = getModel().getSelectedTabIndex();
    TabItem selectedTabItem = TabItem.create(getTabSwitcher(), viewRecycler, selectedTabIndex);
    float defaultTabSpacing = calculateMaxTabSpacing(count, null);
    float maxTabSpacing = calculateMaxTabSpacing(count, selectedTabItem);
    float minTabSpacing = calculateMinTabSpacing(count);
    TabItem currentReferenceTabItem = referenceTabItem;
    int referenceIndex = referenceTabItem.getIndex();

    AbstractTabItemIterator.AbstractBuilder builder =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler);

    for (TabItem addedTabItem : addedTabItems) {
      int iterationReferenceIndex = referenceIndex;
      float iterationReferencePosition = referencePosition;
      TabItem iterationReferenceTabItem = currentReferenceTabItem;
      AbstractTabItemIterator iterator =
        builder.start(addedTabItem.getIndex()).reverse(true).create();
      TabItem tabItem;

      while ((tabItem = iterator.next()) != null) {
        TabItem predecessor = iterator.peek();
        Pair<Float, State> pair;
        float currentTabSpacing = calculateMaxTabSpacing(count, iterationReferenceTabItem);

        if (isReferencingPredecessor && tabItem.getIndex() == addedTabItem.getIndex()) {
          State predecessorState =
            predecessor != null ? predecessor.getTag().getState() : null;
          pair = clipTabPosition(count, tabItem.getIndex(), iterationReferencePosition,
            predecessorState == State.STACKED_START_ATOP ? State.FLOATING :
              predecessorState);
          currentReferenceTabItem = iterationReferenceTabItem = tabItem;
          initialReferencePosition =
            referencePosition = iterationReferencePosition = pair.first;
          referenceIndex = iterationReferenceIndex = tabItem.getIndex();
        } else if (iterationReferencePosition >= attachedPosition - currentTabSpacing) {
          float position;

          if (selectedTabIndex > tabItem.getIndex() &&
            selectedTabIndex <= iterationReferenceIndex) {
            position = iterationReferencePosition + maxTabSpacing +
              ((iterationReferenceIndex - tabItem.getIndex() - 1) *
                defaultTabSpacing);
          } else {
            position = iterationReferencePosition +
              ((iterationReferenceIndex - tabItem.getIndex()) *
                defaultTabSpacing);
          }

          pair = clipTabPosition(count, tabItem.getIndex(), position, predecessor);
        } else {
          TabItem successor = iterator.previous();
          float successorPosition = successor.getTag().getPosition();
          float position = (attachedPosition * (successorPosition + minTabSpacing)) /
            (minTabSpacing + attachedPosition - currentTabSpacing);
          pair = clipTabPosition(count, tabItem.getIndex(), position, predecessor);

          if (pair.first >= attachedPosition - currentTabSpacing) {
            iterationReferenceTabItem = tabItem;
            iterationReferencePosition = pair.first;
            iterationReferenceIndex = tabItem.getIndex();
          }
        }

        if (tabItem.getIndex() >= firstAddedTabItem.getIndex() &&
          tabItem.getIndex() <= lastAddedTabItem.getIndex()) {
          if (!isReferencingPredecessor && attachedPositionChanged && count > 3) {
            TabItem successor = iterator.previous();
            float successorPosition = successor.getTag().getPosition();
            float position = pair.first - Math.abs(pair.first - successorPosition) / 2f;
            pair = clipTabPosition(count, tabItem.getIndex(), position, predecessor);
            initialReferencePosition = pair.first;
          }

          Tag tag = addedTabItems[tabItem.getIndex() - firstAddedTabItem.getIndex()]
            .getTag();
          tag.setPosition(pair.first);
          tag.setState(pair.second);
        } else {
          Tag tag = tabItem.getTag().clone();
          tag.setPosition(pair.first);
          tag.setState(pair.second);

          if (!tabItem.isInflated()) {
            Pair<Float, State> pair2 =
              calculatePositionAndStateWhenStackedAtEnd(tabItem.getIndex());
            tabItem.getTag().setPosition(pair2.first);
            tabItem.getTag().setState(pair2.second);
          }

          relocate(tabItem, tag.getPosition(), tag, 0);
        }

        if (pair.second == State.HIDDEN || pair.second == State.STACKED_END) {
          firstVisibleIndex++;
          break;
        }
      }
    }

    if (attachedPositionChanged && count > 3) {
      AbstractTabItemIterator iterator =
        builder.start(lastAddedTabItem.getIndex() + 1).reverse(false).create();
      TabItem tabItem;
      float previousPosition = initialReferencePosition;
      Tag previousTag = lastAddedTabItem.getTag();

      while ((tabItem = iterator.next()) != null && tabItem.getIndex() < count - 1) {
        float position = calculateNonLinearPosition(previousPosition,
          calculateMaxTabSpacing(count, tabItem));
        Pair<Float, State> pair = clipTabPosition(count, tabItem.getIndex(), position,
          previousTag.getState());
        Tag tag = tabItem.getTag().clone();
        tag.setPosition(pair.first);
        tag.setState(pair.second);

        if (!tabItem.isInflated()) {
          Pair<Float, State> pair2 =
            calculatePositionAndStateWhenStackedAtStart(count, tabItem.getIndex(),
              iterator.previous());
          tabItem.getTag().setPosition(pair2.first);
          tabItem.getTag().setState(pair2.second);
        }

        relocate(tabItem, tag.getPosition(), tag, 0);
        previousPosition = pair.first;
        previousTag = tag;

        if (pair.second == State.HIDDEN || pair.second == State.STACKED_START) {
          break;
        }
      }
    }

    return addedTabItems;
  }

  /**
   * Relocates all neighboring tabs, when stacked tabs have been added to the tab switcher.
   *
   * @param start         True, if the added tab was part of the stack, which is located at the start, false,
   *                      if it was part of the stack, which is located at the end
   * @param addedTabItems An array, which contains the tab items, which correspond to the tabs, which have been
   *                      added, as an array of the type {@link TabItem}. The array may not be null
   * @return An array, which contains the tab items, which correspond to the tabs, which have been
   * added, as an array of the type {@link TabItem}. The array may not be null
   */
  @NonNull
  private TabItem[] relocateWhenAddingStackedTabs(final boolean start,
                                                  @NonNull final TabItem[] addedTabItems) {
    if (!start) {
      firstVisibleIndex += addedTabItems.length;
    }

    int count = getTabSwitcher().getCount();
    TabItem firstAddedTabItem = addedTabItems[0];
    TabItem lastAddedTabItem = addedTabItems[addedTabItems.length - 1];
    AbstractTabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler)
        .start(start ? lastAddedTabItem.getIndex() : firstAddedTabItem.getIndex())
        .reverse(start).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null &&
      (tabItem.getTag().getState() == State.STACKED_START ||
        tabItem.getTag().getState() == State.STACKED_START_ATOP ||
        tabItem.getTag().getState() == State.STACKED_END ||
        tabItem.getTag().getState() == State.HIDDEN)) {
      TabItem predecessor = start ? iterator.peek() : iterator.previous();
      Pair<Float, State> pair = start ?
        calculatePositionAndStateWhenStackedAtStart(count, tabItem.getIndex(),
          predecessor) :
        calculatePositionAndStateWhenStackedAtEnd(tabItem.getIndex());

      if (start && predecessor != null && predecessor.getTag().getState() == State.FLOATING) {
        float predecessorPosition = predecessor.getTag().getPosition();
        float distance = predecessorPosition - pair.first;

        if (distance > calculateMinTabSpacing(count)) {
          float position = calculateNonLinearPosition(tabItem, predecessor);
          pair = clipTabPosition(count, tabItem.getIndex(), position, predecessor);
        }
      }

      if (tabItem.getIndex() >= firstAddedTabItem.getIndex() &&
        tabItem.getIndex() <= lastAddedTabItem.getIndex()) {
        Tag tag = addedTabItems[tabItem.getIndex() - firstAddedTabItem.getIndex()].getTag();
        tag.setPosition(pair.first);
        tag.setState(pair.second);
      } else if (tabItem.isInflated()) {
        Tag tag = tabItem.getTag().clone();
        tag.setPosition(pair.first);
        tag.setState(pair.second);
        animateRelocate(tabItem, tag.getPosition(), tag, 0,
          createRelocateAnimationListener(tabItem));
      } else {
        break;
      }
    }

    return addedTabItems;
  }

  /**
   * Calculates the position and state of hidden tabs, which have been added to the tab switcher.
   *
   * @param addedTabItems    An array, which contains the tab items, which correspond to the tabs, which have been
   *                         added, as an array of the type {@link TabItem}. The array may not be null
   * @param referenceTabItem The tab item, which corresponds to the tab, which is used as a reference, as an
   *                         instance of the class {@link TabItem}. The tab item may not be null
   * @return An array, which contains the tab items, which correspond to the tabs, which have been
   * added, as an array of the type {@link TabItem}. The array may not be null
   */
  @NonNull
  private TabItem[] relocateWhenAddingHiddenTabs(@NonNull final TabItem[] addedTabItems,
                                                 @NonNull final TabItem referenceTabItem) {
    boolean stackedAtStart = isStackedAtStart(referenceTabItem.getIndex());

    for (TabItem tabItem : addedTabItems) {
      Pair<Float, State> pair;

      if (stackedAtStart) {
        TabItem predecessor = tabItem.getIndex() > 0 ?
          TabItem.create(getTabSwitcher(), viewRecycler, tabItem.getIndex() - 1) :
          null;
        pair = calculatePositionAndStateWhenStackedAtStart(getModel().getCount(),
          tabItem.getIndex(), predecessor);
      } else {
        pair = calculatePositionAndStateWhenStackedAtEnd(tabItem.getIndex());
      }

      Tag tag = tabItem.getTag();
      tag.setPosition(pair.first);
      tag.setState(pair.second);
    }

    return addedTabItems;
  }

  /**
   * Relocates a specific tab. If its view is now yet inflated, it is inflated first.
   *
   * @param tabItem          The tab item, which corresponds to the tab, which should be relocated, as an instance
   *                         of the class {@link TabItem}. The tab item may not be null
   * @param relocatePosition The position, the tab should be moved to, in pixels as an {@link Float} value
   * @param tag              The tag, which should be applied to the tab, once it has been relocated, as an
   *                         instance of the class {@link Tag} or null, if no tag should be applied
   * @param startDelay       The start delay of the relocate animation in milliseconds as a {@link Long} value
   */
  private void relocate(@NonNull final TabItem tabItem, final float relocatePosition,
                        @Nullable final Tag tag, final long startDelay) {
    if (tabItem.isInflated()) {
      animateRelocate(tabItem, relocatePosition, tag, startDelay,
        createRelocateAnimationListener(tabItem));
    } else {
      inflateAndUpdateView(tabItem,
        createRelocateLayoutListener(tabItem, relocatePosition, tag, startDelay,
          createRelocateAnimationListener(tabItem)));
      tabItem.getView().setVisibility(View.INVISIBLE);
    }
  }

  /**
   * Swipes a specific tab.
   *
   * @param tabItem  The tab item, which corresponds to the tab, which should be swiped, as an instance of
   *                 the class {@link TabItem}. The tab item may not be null
   * @param distance The distance, the tab should be swiped by, in pixels as a {@link Float} value
   */
  private void swipe(@NonNull final TabItem tabItem, final float distance) {
    View view = tabItem.getView();

    if (!tabItem.getTag().isClosing()) {
      adaptStackOnSwipe(tabItem, tabItem.getIndex() + 1, getModel().getCount() - 1);
    }

    tabItem.getTag().setClosing(true);
    float dragDistance = distance;

    if (!tabItem.getTab().isCloseable()) {
      dragDistance = (float) Math.pow(Math.abs(distance), 0.75);
      dragDistance = distance < 0 ? dragDistance * -1 : dragDistance;
    }

    getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
      getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.SWIPE));
    getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
      getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.SWIPE));
    float scale = getArithmetics().getScale(view, true);
    float ratio = 1 - (Math.abs(dragDistance) / calculateSwipePosition());
    float scaledClosedTabScale = swipedTabScale * scale;
    float targetScale = scaledClosedTabScale + ratio * (scale - scaledClosedTabScale);
    getArithmetics().setScale(Axis.DRAGGING_AXIS, view, targetScale);
    getArithmetics().setScale(Axis.ORTHOGONAL_AXIS, view, targetScale);
    view.setAlpha(swipedTabAlpha + ratio * (1 - swipedTabAlpha));
    getArithmetics().setPosition(Axis.ORTHOGONAL_AXIS, view, dragDistance);
  }

  /**
   * Moves the first tab to overlap the other tabs, when overshooting at the start.
   *
   * @param position The position of the first tab in pixels as a {@link Float} value
   */
  private void startOvershoot(final float position) {
    TabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.getIndex() == 0) {
        View view = tabItem.getView();
        getArithmetics().setPivot(Axis.DRAGGING_AXIS, view,
          getArithmetics().getPivot(Axis.DRAGGING_AXIS, view, DragState.NONE));
        getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view,
          getArithmetics().getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.NONE));
        getArithmetics().setPosition(Axis.DRAGGING_AXIS, view, position);
      } else if (tabItem.isInflated()) {
        View firstView = iterator.first().getView();
        View view = tabItem.getView();
        view.setVisibility(getArithmetics().getPosition(Axis.DRAGGING_AXIS, firstView) <=
          getArithmetics().getPosition(Axis.DRAGGING_AXIS, view) ? View.INVISIBLE :
          View.VISIBLE);
      }
    }
  }

  /**
   * Tilts the tabs, when overshooting at the start.
   *
   * @param angle The angle, the tabs should be rotated by, in degrees as a {@link Float} value
   */
  private void tiltOnStartOvershoot(final float angle) {
    TabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      View view = tabItem.getView();

      if (tabItem.getIndex() == 0) {
        view.setCameraDistance(maxCameraDistance);
        getArithmetics().setPivot(Axis.DRAGGING_AXIS, view, getArithmetics()
          .getPivot(Axis.DRAGGING_AXIS, view, DragState.OVERSHOOT_START));
        getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view, getArithmetics()
          .getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.OVERSHOOT_START));
        getArithmetics().setRotation(Axis.ORTHOGONAL_AXIS, view, angle);
      } else if (tabItem.isInflated()) {
        tabItem.getView().setVisibility(View.INVISIBLE);
      }
    }
  }

  /**
   * Tilts the tabs, when overshooting at the end.
   *
   * @param angle The angle, the tabs should be rotated by, in degrees as a {@link Float} value
   */
  private void tiltOnEndOvershoot(final float angle) {
    float minCameraDistance = maxCameraDistance / 2f;
    int firstVisibleIndex = -1;
    TabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      if (tabItem.isInflated()) {
        View view = tabItem.getView();

        if (!iterator.hasNext()) {
          view.setCameraDistance(maxCameraDistance);
        } else if (firstVisibleIndex == -1) {
          view.setCameraDistance(minCameraDistance);

          if (tabItem.getTag().getState() == State.FLOATING) {
            firstVisibleIndex = tabItem.getIndex();
          }
        } else {
          int diff = tabItem.getIndex() - firstVisibleIndex;
          float ratio =
            (float) diff / (float) (getModel().getCount() - firstVisibleIndex);
          view.setCameraDistance(
            minCameraDistance + (maxCameraDistance - minCameraDistance) * ratio);
        }

        getArithmetics().setPivot(Axis.DRAGGING_AXIS, view, getArithmetics()
          .getPivot(Axis.DRAGGING_AXIS, view, DragState.OVERSHOOT_END));
        getArithmetics().setPivot(Axis.ORTHOGONAL_AXIS, view, getArithmetics()
          .getPivot(Axis.ORTHOGONAL_AXIS, view, DragState.OVERSHOOT_END));
        getArithmetics().setRotation(Axis.ORTHOGONAL_AXIS, view, angle);
      }
    }
  }

  /**
   * Returns, whether a hidden tab at a specific index, is part of the stack, which is located at
   * the start, or not.
   *
   * @param index The index of the hidden tab, as an {@link Integer} value
   * @return True, if the hidden tab is part of the stack, which is located at the start, false
   * otherwise
   */
  private boolean isStackedAtStart(final int index) {
    boolean start = true;
    AbstractTabItemIterator iterator =
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).start(index + 1)
        .create();
    TabItem tabItem;

    while ((tabItem = iterator.next()) != null) {
      State state = tabItem.getTag().getState();

      if (state == State.STACKED_START) {
        start = true;
        break;
      } else if (state == State.FLOATING) {
        start = false;
        break;
      }
    }

    return start;
  }

  /**
   * Creates a new layout, which implements the functionality of a {@link TabSwitcher} on
   * smartphones.
   *
   * @param tabSwitcher The tab switcher, the layout belongs to, as an instance of the class {@link
   *                    TabSwitcher}. The tab switcher may not be null
   * @param model       The model of the tab switcher, the layout belongs to, as an instance of the class
   *                    {@link TabSwitcherModel}. The model may not be null
   * @param arithmetics The arithmetics, which should be used by the layout, as an instance of the class
   *                    {@link PhoneArithmetics}. The arithmetics may not be null
   */
  public PhoneTabSwitcherLayout(@NonNull final TabSwitcher tabSwitcher,
                                @NonNull final TabSwitcherModel model,
                                @NonNull final PhoneArithmetics arithmetics) {
    super(tabSwitcher, model, arithmetics);
    Resources resources = tabSwitcher.getResources();
    tabInset = resources.getDimensionPixelSize(R.dimen.tab_inset);
    tabBorderWidth = resources.getDimensionPixelSize(R.dimen.tab_border_width);
    tabTitleContainerHeight =
      resources.getDimensionPixelSize(R.dimen.tab_title_container_height);
    stackedTabCount = resources.getInteger(R.integer.stacked_tab_count);
    stackedTabSpacing = resources.getDimensionPixelSize(R.dimen.stacked_tab_spacing);
    maxCameraDistance = resources.getDimensionPixelSize(R.dimen.max_camera_distance);
    TypedValue typedValue = new TypedValue();
    resources.getValue(R.dimen.swiped_tab_scale, typedValue, true);
    swipedTabScale = typedValue.getFloat();
    resources.getValue(R.dimen.swiped_tab_alpha, typedValue, true);
    swipedTabAlpha = typedValue.getFloat();
    showSwitcherAnimationDuration =
      resources.getInteger(R.integer.show_switcher_animation_duration);
    hideSwitcherAnimationDuration =
      resources.getInteger(R.integer.hide_switcher_animation_duration);
    toolbarVisibilityAnimationDuration =
      resources.getInteger(R.integer.toolbar_visibility_animation_duration);
    toolbarVisibilityAnimationDelay =
      resources.getInteger(R.integer.toolbar_visibility_animation_delay);
    swipeAnimationDuration = resources.getInteger(R.integer.swipe_animation_duration);
    clearAnimationDelay = resources.getInteger(R.integer.clear_animation_delay);
    relocateAnimationDuration = resources.getInteger(R.integer.relocate_animation_duration);
    relocateAnimationDelay = resources.getInteger(R.integer.relocate_animation_delay);
    revertOvershootAnimationDuration =
      resources.getInteger(R.integer.revert_overshoot_animation_duration);
    revealAnimationDuration = resources.getInteger(R.integer.reveal_animation_duration);
    peekAnimationDuration = resources.getInteger(R.integer.peek_animation_duration);
    maxStartOvershootAngle = resources.getInteger(R.integer.max_start_overshoot_angle);
    maxEndOvershootAngle = resources.getInteger(R.integer.max_end_overshoot_angle);
    tabViewBottomMargin = -1;
    toolbarAnimation = null;
  }

  @NonNull
  @Override
  protected final AbstractDragHandler<?> onInflateLayout(final boolean tabsOnly) {
    LayoutInflater inflater = LayoutInflater.from(getContext());

    if (tabsOnly) {
      toolbar = (Toolbar) getTabSwitcher().findViewById(R.id.primary_toolbar);
    } else {
      toolbar = (Toolbar) inflater.inflate(R.layout.phone_toolbar, getTabSwitcher(), false);
      toolbar.setVisibility(getModel().areToolbarsShown() ? View.VISIBLE : View.INVISIBLE);
      getTabSwitcher().addView(toolbar);
    }

    tabContainer = new FrameLayout(getContext());
    getTabSwitcher().addView(tabContainer, FrameLayout.LayoutParams.MATCH_PARENT,
      FrameLayout.LayoutParams.MATCH_PARENT);
    childViewRecycler = new ViewRecycler<>(inflater);
    recyclerAdapter = new PhoneRecyclerAdapter(getTabSwitcher(), getModel(), childViewRecycler);
    getModel().addListener(recyclerAdapter);
    viewRecycler = new AttachedViewRecycler<>(tabContainer, inflater,
      Collections.reverseOrder(new TabItem.Comparator(getTabSwitcher())));
    viewRecycler.setAdapter(recyclerAdapter);
    recyclerAdapter.setViewRecycler(viewRecycler);
    dragHandler = new PhoneDragHandler(getTabSwitcher(), getArithmetics(), viewRecycler);
    adaptLogLevel();
    adaptDecorator();
    adaptToolbarMargin();
    return dragHandler;
  }

  @Nullable
  @Override
  protected final Pair<Integer, Float> onDetachLayout(final boolean tabsOnly) {
    Pair<Integer, Float> result = null;

    if (getModel().isSwitcherShown() && firstVisibleIndex != -1) {
      TabItem tabItem = TabItem.create(getModel(), viewRecycler, firstVisibleIndex);
      Tag tag = tabItem.getTag();

      if (tag.getState() != State.HIDDEN) {
        float firstVisibleTabPosition = tabItem.getTag().getPosition();
        result = Pair.create(firstVisibleIndex, firstVisibleTabPosition);
      }
    }

    childViewRecycler.removeAll();
    childViewRecycler.clearCache();
    viewRecycler.removeAll();
    viewRecycler.clearCache();
    recyclerAdapter.clearCachedPreviews();

    if (!tabsOnly) {
      getModel().removeListener(recyclerAdapter);
      getTabSwitcher().removeView(toolbar);
      getTabSwitcher().removeView(tabContainer);
    }

    return result;
  }

  @Override
  public final boolean handleTouchEvent(@NonNull final MotionEvent event) {
    return dragHandler.handleTouchEvent(event);
  }

  @Nullable
  @Override
  public final ViewGroup getTabContainer() {
    return tabContainer;
  }

  @Nullable
  @Override
  public final Toolbar[] getToolbars() {
    return new Toolbar[]{toolbar};
  }

  @Override
  public final void onLogLevelChanged(@NonNull final LogLevel logLevel) {
    adaptLogLevel();
  }

  @Override
  public final void onDecoratorChanged(@NonNull final TabSwitcherDecorator decorator) {
    adaptDecorator();
    super.onDecoratorChanged(decorator);
  }

  @Override
  public final void onSwitcherShown() {
    getLogger().logInfo(getClass(), "Showed tab switcher");
    animateShowSwitcher();
  }

  @Override
  public final void onSwitcherHidden() {
    getLogger().logInfo(getClass(), "Hid tab switcher");
    animateHideSwitcher();
  }

  @Override
  public final void onSelectionChanged(final int previousIndex, final int index,
                                       @Nullable final Tab selectedTab,
                                       final boolean switcherHidden) {
    getLogger().logInfo(getClass(), "Selected tab at index " + index);

    if (switcherHidden) {
      animateHideSwitcher();
    } else {
      viewRecycler.remove(TabItem.create(getTabSwitcher(), viewRecycler, previousIndex));
      viewRecycler.inflate(TabItem.create(getTabSwitcher(), viewRecycler, index));
    }
  }

  @Override
  public final void onTabAdded(final int index, @NonNull final Tab tab,
                               final int previousSelectedTabIndex, final int selectedTabIndex,
                               final boolean switcherVisibilityChanged,
                               @NonNull final Animation animation) {
    getLogger().logInfo(getClass(),
      "Added tab at index " + index + " using a " + animation.getClass().getSimpleName());

    if (animation instanceof PeekAnimation && !getModel().isEmpty()) {
      ensureTrue(switcherVisibilityChanged, animation.getClass().getSimpleName() +
        " not supported when the tab switcher is shown");
      PeekAnimation peekAnimation = (PeekAnimation) animation;
      TabItem tabItem = new TabItem(0, tab);
      inflateView(tabItem, createPeekLayoutListener(tabItem, peekAnimation));
    } else if (animation instanceof RevealAnimation && switcherVisibilityChanged) {
      TabItem tabItem = new TabItem(0, tab);
      RevealAnimation revealAnimation = (RevealAnimation) animation;
      inflateView(tabItem, createRevealLayoutListener(tabItem, revealAnimation));
    } else {
      addAllTabs(index, new Tab[]{tab}, animation);
    }
  }

  @Override
  public final void onAllTabsAdded(final int index, @NonNull final Tab[] tabs,
                                   final int previousSelectedTabIndex, final int selectedTabIndex,
                                   @NonNull final Animation animation) {
    ensureTrue(animation instanceof SwipeAnimation,
      animation.getClass().getSimpleName() + " not supported for adding multiple tabs");
    getLogger().logInfo(getClass(),
      "Added " + tabs.length + " tabs at index " + index + " using a " +
        animation.getClass().getSimpleName());
    addAllTabs(index, tabs, animation);
  }

  @Override
  public final void onTabRemoved(final int index, @NonNull final Tab tab,
                                 final int previousSelectedTabIndex, final int selectedTabIndex,
                                 @NonNull final Animation animation) {
    ensureTrue(animation instanceof SwipeAnimation,
      animation.getClass().getSimpleName() + " not supported for removing tabs");
    getLogger().logInfo(getClass(), "Removed tab at index " + index + " using a " +
      animation.getClass().getSimpleName());
    TabItem removedTabItem = TabItem.create(viewRecycler, index, tab);

    if (!getModel().isSwitcherShown()) {
      viewRecycler.remove(removedTabItem);

      if (getModel().isEmpty()) {
        toolbar.setAlpha(getModel().areToolbarsShown() ? 1 : 0);
      } else if (selectedTabIndex != previousSelectedTabIndex) {
        viewRecycler
          .inflate(TabItem.create(getTabSwitcher(), viewRecycler, selectedTabIndex));
      }
    } else {
      adaptStackOnSwipe(removedTabItem, removedTabItem.getIndex(), getModel().getCount());
      removedTabItem.getTag().setClosing(true);
      SwipeAnimation swipeAnimation =
        animation instanceof SwipeAnimation ? (SwipeAnimation) animation :
          new SwipeAnimation.Builder().create();

      if (removedTabItem.isInflated()) {
        animateRemove(removedTabItem, swipeAnimation);
      } else {
        boolean start = isStackedAtStart(index);
        TabItem predecessor = TabItem.create(getTabSwitcher(), viewRecycler, index - 1);
        Pair<Float, State> pair = start ?
          calculatePositionAndStateWhenStackedAtStart(getModel().getCount(), index,
            predecessor) : calculatePositionAndStateWhenStackedAtEnd(index);
        removedTabItem.getTag().setPosition(pair.first);
        removedTabItem.getTag().setState(pair.second);
        inflateAndUpdateView(removedTabItem,
          createRemoveLayoutListener(removedTabItem, swipeAnimation));
      }
    }
  }

  @Override
  public final void onAllTabsRemoved(@NonNull final Tab[] tabs,
                                     @NonNull final Animation animation) {
    ensureTrue(animation instanceof SwipeAnimation,
      animation.getClass().getSimpleName() + " not supported for removing tabs ");
    getLogger().logInfo(getClass(),
      "Removed all tabs using a " + animation.getClass().getSimpleName());

    if (!getModel().isSwitcherShown()) {
      viewRecycler.removeAll();
      toolbar.setAlpha(getModel().areToolbarsShown() ? 1 : 0);
    } else {
      SwipeAnimation swipeAnimation =
        animation instanceof SwipeAnimation ? (SwipeAnimation) animation :
          new SwipeAnimation.Builder().create();
      AbstractTabItemIterator iterator =
        new ArrayTabItemIterator.Builder(viewRecycler, tabs).reverse(true).create();
      TabItem tabItem;
      int startDelay = 0;

      while ((tabItem = iterator.next()) != null) {
        TabItem previous = iterator.previous();

        if (tabItem.getTag().getState() == State.FLOATING ||
          (previous != null && previous.getTag().getState() == State.FLOATING)) {
          startDelay += clearAnimationDelay;
        }

        if (tabItem.isInflated()) {
          animateSwipe(tabItem, true, startDelay, swipeAnimation,
            !iterator.hasNext() ? createClearAnimationListener() : null);
        }
      }
    }
  }

  @Override
  public final void onPaddingChanged(final int left, final int top, final int right,
                                     final int bottom) {
    adaptToolbarMargin();
  }

  @Override
  public final void onTabIconChanged(@Nullable final Drawable icon) {

  }

  @Override
  public final void onTabBackgroundColorChanged(@Nullable final ColorStateList colorStateList) {

  }

  @Override
  public final void onTabTitleColorChanged(@Nullable final ColorStateList colorStateList) {

  }

  @Override
  public final void onTabCloseButtonIconChanged(@Nullable final Drawable icon) {

  }

  @Override
  public final void onGlobalLayout() {
    if (getModel().isSwitcherShown()) {
      TabItem[] tabItems = calculateInitialTabItems(getModel().getFirstVisibleTabIndex(),
        getModel().getFirstVisibleTabPosition());
      AbstractTabItemIterator iterator = new InitialTabItemIterator(tabItems, false, 0);
      TabItem tabItem;

      while ((tabItem = iterator.next()) != null) {
        if (tabItem.isVisible()) {
          inflateAndUpdateView(tabItem, createBottomMarginLayoutListener(tabItem));
        }
      }

      toolbar.setAlpha(getModel().areToolbarsShown() ? 1 : 0);
    } else if (getModel().getSelectedTab() != null) {
      TabItem tabItem = TabItem.create(getTabSwitcher(), viewRecycler,
        getModel().getSelectedTabIndex());
      viewRecycler.inflate(tabItem);
    }
  }

  @Nullable
  @Override
  public final DragState onDrag(@NonNull final DragState dragState, final float dragDistance) {
    if (dragDistance != 0) {
      if (dragState == DragState.DRAG_TO_END) {
        calculatePositionsWhenDraggingToEnd(dragDistance);
      } else {
        calculatePositionsWhenDraggingToStart(dragDistance);
      }
    }

    DragState overshoot = isOvershootingAtEnd(
      new TabItemIterator.Builder(getTabSwitcher(), viewRecycler).create()) ?
      DragState.OVERSHOOT_END :
      (isOvershootingAtStart() ? DragState.OVERSHOOT_START : null);
    getLogger().logVerbose(getClass(),
      "Dragging using a distance of " + dragDistance + " pixels. Drag state is " +
        dragState + ", overshoot is " + overshoot);
    return overshoot;
  }

  @Override
  public final void onClick(@NonNull final TabItem tabItem) {
    getModel().selectTab(tabItem.getTab());
    getLogger().logVerbose(getClass(), "Clicked tab at index " + tabItem.getIndex());
  }

  @Override
  public final void onRevertStartOvershoot() {
    animateRevertStartOvershoot();
    getLogger().logVerbose(getClass(), "Reverting overshoot at the start");
  }

  @Override
  public final void onRevertEndOvershoot() {
    animateRevertEndOvershoot();
    getLogger().logVerbose(getClass(), "Reverting overshoot at the end");
  }

  public final void onStartOvershoot(final float position) {
    startOvershoot(position);
    getLogger().logVerbose(getClass(),
      "Overshooting at the start using a position of " + position + " pixels");
  }

  @Override
  public final void onTiltOnStartOvershoot(final float angle) {
    tiltOnStartOvershoot(angle);
    getLogger().logVerbose(getClass(),
      "Tilting on start overshoot using an angle of " + angle + " degrees");
  }

  @Override
  public final void onTiltOnEndOvershoot(final float angle) {
    tiltOnEndOvershoot(angle);
    getLogger().logVerbose(getClass(),
      "Tilting on end overshoot using an angle of " + angle + " degrees");
  }

  @Override
  public final void onSwipe(@NonNull final TabItem tabItem, final float distance) {
    swipe(tabItem, distance);
    getLogger().logVerbose(getClass(),
      "Swiping tab at index " + tabItem.getIndex() + ". Current swipe distance is " +
        distance + " pixels");
  }

  @Override
  public final void onSwipeEnded(@NonNull final TabItem tabItem, final boolean remove,
                                 final float velocity) {
    if (remove) {
      View view = tabItem.getView();
      SwipeDirection direction =
        getArithmetics().getPosition(Axis.ORTHOGONAL_AXIS, view) < 0 ?
          SwipeDirection.LEFT : SwipeDirection.RIGHT;
      long animationDuration =
        velocity > 0 ? Math.round((calculateSwipePosition() / velocity) * 1000) : -1;
      Animation animation = new SwipeAnimation.Builder().setDirection(direction)
        .setDuration(animationDuration).create();
      getModel().removeTab(tabItem.getTab(), animation);
    } else {
      animateSwipe(tabItem, false, 0, new SwipeAnimation.Builder().create(),
        createSwipeAnimationListener(tabItem));
    }

    getLogger().logVerbose(getClass(),
      "Ended swiping tab at index " + tabItem.getIndex() + ". Tab will " +
        (remove ? "" : "not ") + "be removed");
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/phone/PhoneTabViewHolder.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout.phone;

import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.layout.AbstractTabViewHolder;

/**
 * A view holder, which allows to store references to the views, a tab of a {@link TabSwitcher}
 * consists of, when using the smartphone layout.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class PhoneTabViewHolder extends AbstractTabViewHolder {

  /**
   * The view group, which contains the title and close button of a tab.
   */
  public ViewGroup titleContainer;

  /**
   * The view group, which contains the child view of a tab.
   */
  public ViewGroup childContainer;

  /**
   * The child view, which contains the tab's content.
   */
  public View child;

  /**
   * The image view, which is used to display the preview of a tab.
   */
  public ImageView previewImageView;

  /**
   * The view, which is used to display a border around the preview of a tab.
   */
  public View borderView;

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/layout/phone/PreviewDataBinder.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.layout.phone;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.view.View;
import android.view.View.MeasureSpec;
import android.view.ViewGroup;
import android.widget.ImageView;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.collection.LruCache;
import androidx.core.util.Pair;
import de.mrapp.android.tabswitcher.Tab;
import de.mrapp.android.tabswitcher.model.TabItem;
import de.mrapp.android.util.multithreading.AbstractDataBinder;
import de.mrapp.android.util.view.ViewRecycler;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A data binder, which allows to asynchronously render preview images of tabs and display them
 * afterwards.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class PreviewDataBinder extends AbstractDataBinder<Bitmap, Tab, ImageView, TabItem> {

  /**
   * The parent view of the tab switcher, the tabs belong to.
   */
  private final ViewGroup parent;

  /**
   * The view recycler, which is used to inflate child views.
   */
  private final ViewRecycler<Tab, Void> childViewRecycler;

  /**
   * Creates a new data binder, which allows to asynchronously render preview images of tabs and
   * display them afterwards.
   *
   * @param parent            The parent view of the tab switcher, the tabs belong to, as an instance of the class
   *                          {@link ViewGroup}. The parent may not be null
   * @param childViewRecycler The view recycler, which should be used to inflate child views, as an instance of the
   *                          class ViewRecycler. The view recycler may not be null
   */
  public PreviewDataBinder(@NonNull final ViewGroup parent,
                           @NonNull final ViewRecycler<Tab, Void> childViewRecycler) {
    super(parent.getContext(), new LruCache<Tab, Bitmap>(7));
    ensureNotNull(parent, "The parent may not be null");
    ensureNotNull(childViewRecycler, "The child view recycler may not be null");
    this.parent = parent;
    this.childViewRecycler = childViewRecycler;
  }

  @Override
  protected final void onPreExecute(@NonNull final ImageView view,
                                    @NonNull final TabItem... params) {
    TabItem tabItem = params[0];
    PhoneTabViewHolder viewHolder = tabItem.getViewHolder();
    View child = viewHolder.child;
    Tab tab = tabItem.getTab();

    if (child == null) {
      Pair<View, ?> pair = childViewRecycler.inflate(tab, viewHolder.childContainer);
      child = pair.first;
    } else {
      childViewRecycler.getAdapter().onShowView(getContext(), child, tab, false);
    }

    viewHolder.child = child;
  }

  @Nullable
  @Override
  protected final Bitmap doInBackground(@NonNull final Tab key,
                                        @NonNull final TabItem... params) {
    TabItem tabItem = params[0];
    PhoneTabViewHolder viewHolder = tabItem.getViewHolder();
    View child = viewHolder.child;
    viewHolder.child = null;
    int width = parent.getWidth();
    int height = parent.getHeight();
    child.measure(MeasureSpec.makeMeasureSpec(width, MeasureSpec.EXACTLY),
      MeasureSpec.makeMeasureSpec(height, MeasureSpec.EXACTLY));
    child.layout(0, 0, child.getMeasuredWidth(), child.getMeasuredHeight());
    Bitmap bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
    Canvas canvas = new Canvas(bitmap);
    child.draw(canvas);
    return bitmap;
  }

  @Override
  protected final void onPostExecute(@NonNull final ImageView view, @Nullable final Bitmap data,
                                     @NonNull final TabItem... params) {
    view.setImageBitmap(data);
    view.setVisibility(data != null ? View.VISIBLE : View.GONE);
    TabItem tabItem = params[0];
    childViewRecycler.remove(tabItem.getTab());
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/model/Model.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.model;

import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.Bitmap;
import android.graphics.drawable.Drawable;
import android.view.View.OnClickListener;
import androidx.annotation.*;
import androidx.appcompat.widget.Toolbar.OnMenuItemClickListener;
import de.mrapp.android.tabswitcher.*;
import de.mrapp.android.tabswitcher.SwipeAnimation.SwipeDirection;
import de.mrapp.android.util.logging.LogLevel;

import java.util.Collection;
import java.util.NoSuchElementException;

/**
 * Defines the interface, a class, which implements the model of a {@link TabSwitcher} must
 * implement.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public interface Model extends Iterable<Tab> {

  /**
   * Defines the interface, a class, which should be notified about the model's events, must
   * implement.
   */
  interface Listener {

    /**
     * The method, which is invoked, when the log level has been changed.
     *
     * @param logLevel The log level, which has been set, as a value of the enum LogLevel. The log level
     *                 may not be null
     */
    void onLogLevelChanged(@NonNull LogLevel logLevel);

    /**
     * The method, which is invoked, when the decorator has been changed.
     *
     * @param decorator The decorator, which has been set, as an instance of the class {@link
     *                  TabSwitcherDecorator}. The decorator may not be null
     */
    void onDecoratorChanged(@NonNull TabSwitcherDecorator decorator);

    /**
     * The method, which is invoked, when the tab switcher has been shown.
     */
    void onSwitcherShown();

    /**
     * The method, which is invoked, when the tab switcher has been hidden.
     */
    void onSwitcherHidden();

    /**
     * The method, which is invoked, when the currently selected tab has been changed.
     *
     * @param previousIndex  The index of the previously selected tab as an {@link Integer} value or -1, if no
     *                       tab was previously selected
     * @param index          The index of the currently selected tab as an {@link Integer} value or -1, if the
     *                       tab switcher does not contain any tabs
     * @param selectedTab    The currently selected tab as an instance of the class {@link Tab} or null, if
     *                       the tab switcher does not contain any tabs
     * @param switcherHidden True, if selecting the tab caused the tab switcher to be hidden, false otherwise
     */
    void onSelectionChanged(int previousIndex, int index, @Nullable Tab selectedTab,
                            boolean switcherHidden);

    /**
     * The method, which is invoked, when a tab has been added to the model.
     *
     * @param index                     The index of the tab, which has been added, as an {@link Integer} value
     * @param tab                       The tab, which has been added, as an instance of the class {@link Tab}. The tab
     *                                  may not be null
     * @param previousSelectedTabIndex  The index of the previously selected tab as an {@link Integer} value or -1, if no
     *                                  tab was selected
     * @param selectedTabIndex          The index of the currently selected tab as an {@link Integer} value or -1, if the
     *                                  tab switcher does not contain any tabs
     * @param switcherVisibilityChanged True, if adding the tab caused the visibility of the tab switcher to be changed,
     *                                  false otherwise
     * @param animation                 The animation, which has been used to add the tab, as an instance of the class
     *                                  {@link Animation}. The animation may not be null
     */
    void onTabAdded(int index, @NonNull Tab tab, int previousSelectedTabIndex,
                    int selectedTabIndex, boolean switcherVisibilityChanged,
                    @NonNull Animation animation);

    /**
     * The method, which is invoked, when multiple tabs have been added to the model.
     *
     * @param index                    The index of the first tab, which has been added, as an {@link Integer} value
     * @param tabs                     An array, which contains the tabs, which have been added, as an array of the type
     *                                 {@link Tab} or an empty array, if no tabs have been added
     * @param previousSelectedTabIndex The index of the previously selected tab as an {@link Integer} value or -1, if no
     *                                 tab was selected
     * @param selectedTabIndex         The index of the currently selected tab as an {@link Integer} value or -1, if the
     *                                 tab switcher does not contain any tabs
     * @param animation                The animation, which has been used to add the tabs, as an instance of the class
     *                                 {@link Animation}. The animation may not be null
     */
    void onAllTabsAdded(int index, @NonNull Tab[] tabs, int previousSelectedTabIndex,
                        int selectedTabIndex, @NonNull Animation animation);

    /**
     * The method, which is invoked, when a tab has been removed from the model.
     *
     * @param index                    The index of the tab, which has been removed, as an {@link Integer} value
     * @param tab                      The tab, which has been removed, as an instance of the class {@link Tab}. The tab
     *                                 may not be null
     * @param previousSelectedTabIndex The index of the previously selected tab as an {@link Integer} value or -1, if no
     *                                 tab was selected
     * @param selectedTabIndex         The index of the currently selected tab as an {@link Integer} value or -1, if the
     *                                 tab switcher does not contain any tabs
     * @param animation                The animation, which has been used to remove the tab, as an instance of the class
     *                                 {@link Animation}. The animation may not be null
     */
    void onTabRemoved(int index, @NonNull Tab tab, int previousSelectedTabIndex,
                      int selectedTabIndex, @NonNull Animation animation);

    /**
     * The method, which is invoked, when all tabs have been removed from the tab switcher.
     *
     * @param tabs      An array, which contains the tabs, which have been removed, as an array of the
     *                  type {@link Tab} or an empty array, if no tabs have been removed
     * @param animation The animation, which has been used to remove the tabs, as an instance of the
     *                  class {@link Animation}. The animation may not be null
     */
    void onAllTabsRemoved(@NonNull Tab[] tabs, @NonNull Animation animation);

    /**
     * The method, which is invoked, when the padding has been changed.
     *
     * @param left   The left padding, which has been set, in pixels as an {@link Integer} value
     * @param top    The top padding, which has been set, in pixels as an {@link Integer} value
     * @param right  The right padding, which has been set, in pixels as an {@link Integer} value
     * @param bottom The bottom padding, which has been set, in pixels as an {@link Integer} value
     */
    void onPaddingChanged(int left, int top, int right, int bottom);

    /**
     * The method, which is invoked, when the default icon of a tab has been changed.
     *
     * @param icon The icon, which has been set, as an instance of the class {@link Drawable} or
     *             null, if no icon is set
     */
    void onTabIconChanged(@Nullable Drawable icon);

    /**
     * The method, which is invoked, when the background color of a tab has been changed.
     *
     * @param colorStateList The color state list, which has been set, as an instance of the class {@link
     *                       ColorStateList} or null, if the default color should be used
     */
    void onTabBackgroundColorChanged(@Nullable ColorStateList colorStateList);

    /**
     * The method, which is invoked, when the text color of a tab's title has been changed.
     *
     * @param colorStateList The color state list, which has been set, as an instance of the class {@link
     *                       ColorStateList} or null, if the default color should be used
     */
    void onTabTitleColorChanged(@Nullable ColorStateList colorStateList);

    /**
     * The method, which is invoked, when the icon of a tab's close button has been changed.
     *
     * @param icon The icon, which has been set, as an instance of the class {@link Drawable} or
     *             null, if the default icon should be used
     */
    void onTabCloseButtonIconChanged(@Nullable Drawable icon);

    /**
     * The method, which is invoked, when it has been changed, whether the toolbars should be
     * shown, when the tab switcher is shown, or not.
     *
     * @param visible True, if the toolbars should be shown, when the tab switcher is shown, false
     *                otherwise
     */
    void onToolbarVisibilityChanged(boolean visible);

    /**
     * The method, which is invoked, when the title of the toolbar, which is shown, when the tab
     * switcher is shown, has been changed.
     *
     * @param title The title, which has been set, as an instance of the type {@link CharSequence} or
     *              null, if no title is set
     */
    void onToolbarTitleChanged(@Nullable CharSequence title);

    /**
     * The method, which is invoked, when the navigation icon of the toolbar, which is shown,
     * when the tab switcher is shown, has been changed.
     *
     * @param icon     The navigation icon, which has been set, as an instance of the class {@link
     *                 Drawable} or null, if no navigation icon is set
     * @param listener The listener, which should be notified, when the navigation item has been
     *                 clicked, as an instance of the type {@link OnClickListener} or null, if no
     *                 listener should be notified
     */
    void onToolbarNavigationIconChanged(@Nullable Drawable icon,
                                        @Nullable OnClickListener listener);

    /**
     * The method, which is invoked, when the menu of the toolbar, which is shown, when the tab
     * switcher is shown, has been inflated.
     *
     * @param resourceId The resource id of the menu, which has been inflated, as an {@link Integer}
     *                   value. The resource id must correspond to a valid menu resource
     * @param listener   The listener, which has been registered to be notified, when an item of the menu
     *                   has been clicked, as an instance of the type OnMenuItemClickListener or null, if
     *                   no listener should be notified
     */
    void onToolbarMenuInflated(@MenuRes int resourceId,
                               @Nullable OnMenuItemClickListener listener);

  }

  /**
   * Returns the context, which is used by the tab switcher.
   *
   * @return The context, which is used by the tab switcher, as an instance of the class {@link
   * Context}. The context may not be null
   */
  @NonNull
  Context getContext();

  /**
   * Sets the decorator, which allows to inflate the views, which correspond to the tabs of the
   * tab switcher.
   *
   * @param decorator The decorator, which should be set, as an instance of the class {@link
   *                  TabSwitcherDecorator}. The decorator may not be null
   */
  void setDecorator(@NonNull TabSwitcherDecorator decorator);

  /**
   * Returns the decorator, which allows to inflate the views, which correspond to the tabs of the
   * tab switcher.
   *
   * @return The decorator as an instance of the class {@link TabSwitcherDecorator} or null, if no
   * decorator has been set
   */
  TabSwitcherDecorator getDecorator();

  /**
   * Returns the log level, which is used for logging.
   *
   * @return The log level, which is used for logging, as a value of the enum LogLevel. The log
   * level may not be null
   */
  @NonNull
  LogLevel getLogLevel();

  /**
   * Sets the log level, which should be used for logging.
   *
   * @param logLevel The log level, which should be set, as a value of the enum LogLevel. The log level
   *                 may not be null
   */
  void setLogLevel(@NonNull LogLevel logLevel);

  /**
   * Returns, whether the tab switcher is empty, or not.
   *
   * @return True, if the tab switcher is empty, false otherwise
   */
  boolean isEmpty();

  /**
   * Returns the number of tabs, which are contained by the tab switcher.
   *
   * @return The number of tabs, which are contained by the tab switcher, as an {@link Integer}
   * value
   */
  int getCount();

  /**
   * Returns the tab at a specific index.
   *
   * @param index The index of the tab, which should be returned, as an {@link Integer} value. The
   *              index must be at least 0 and at maximum <code>getCount() - 1</code>, otherwise a
   *              {@link IndexOutOfBoundsException} will be thrown
   * @return The tab, which corresponds to the given index, as an instance of the class {@link
   * Tab}. The tab may not be null
   */
  @NonNull
  Tab getTab(int index);

  /**
   * Returns the index of a specific tab.
   *
   * @param tab The tab, whose index should be returned, as an instance of the class {@link Tab}. The
   *            tab may not be null
   * @return The index of the given tab as an {@link Integer} value or -1, if the given tab is not
   * contained by the tab switcher
   */
  int indexOf(@NonNull Tab tab);

  /**
   * Adds a new tab to the tab switcher. By default, the tab is added at the end. If the switcher
   * is currently shown, the tab is added by using an animation. By default, a {@link
   * SwipeAnimation} with direction {@link SwipeDirection#RIGHT} is used. If
   * an animation is currently running, the tab will be added once all previously started
   * animations have been finished.
   *
   * @param tab The tab, which should be added, as an instance of the class {@link Tab}. The tab may
   *            not be null
   */
  void addTab(@NonNull Tab tab);

  /**
   * Adds a new tab to the tab switcher at a specific index. If the switcher is currently shown,
   * the tab is added by using an animation. By default, a {@link SwipeAnimation} with
   * direction {@link SwipeDirection#RIGHT} is used. If an animation is currently
   * running, the tab will be added once all previously started animations have been finished.
   *
   * @param tab   The tab, which should be added, as an instance of the class {@link Tab}. The tab may
   *              not be null
   * @param index The index, the tab should be added at, as an {@link Integer} value. The index must be
   *              at least 0 and at maximum <code>getCount()</code>, otherwise an {@link
   *              IndexOutOfBoundsException} will be thrown
   */
  void addTab(@NonNull Tab tab, int index);

  /**
   * Adds a new tab to the tab switcher at a specific index. If the switcher is currently shown,
   * the tab is added by using a specific animation. If an animation is currently
   * running, the tab will be added once all previously started animations have been finished.
   *
   * @param tab       The tab, which should be added, as an instance of the class {@link Tab}. The tab may
   *                  not be null
   * @param index     The index, the tab should be added at, as an {@link Integer} value. The index must be
   *                  at least 0 and at maximum <code>getCount()</code>, otherwise an {@link
   *                  IndexOutOfBoundsException} will be thrown
   * @param animation The animation, which should be used to add the tab, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  void addTab(@NonNull Tab tab, int index, @NonNull Animation animation);

  /**
   * Adds all tabs, which are contained by a collection, to the tab switcher. By default, the tabs
   * are added at the end. If the switcher is currently shown, the tabs are added by using an
   * animation. By default, a {@link SwipeAnimation} with direction {@link
   * SwipeDirection#RIGHT} is used. If an animation is currently running, the tabs will
   * be added once all previously started animations have been finished.
   *
   * @param tabs A collection, which contains the tabs, which should be added, as an instance of the
   *             type {@link Collection} or an empty collection, if no tabs should be added
   */
  void addAllTabs(@NonNull Collection<? extends Tab> tabs);

  /**
   * Adds all tabs, which are contained by a collection, to the tab switcher, starting at a
   * specific index. If the switcher is currently shown, the tabs are added by using an animation.
   * By default, a {@link SwipeAnimation} with direction {@link
   * SwipeDirection#RIGHT} is used. If an animation is currently running, the tabs will
   * be added once all previously started animations have been finished.
   *
   * @param tabs  A collection, which contains the tabs, which should be added, as an instance of the
   *              type {@link Collection} or an empty collection, if no tabs should be added
   * @param index The index, the first tab should be started at, as an {@link Integer} value. The index
   *              must be at least 0 and at maximum <code>getCount()</code>, otherwise an {@link
   *              IndexOutOfBoundsException} will be thrown
   */
  void addAllTabs(@NonNull Collection<? extends Tab> tabs, int index);

  /**
   * Adds all tabs, which are contained by a collection, to the tab switcher, starting at a
   * specific index. If the switcher is currently shown, the tabs are added by using a specific
   * animation. If an animation is currently running, the tabs will be added once all previously
   * started animations have been finished.
   *
   * @param tabs      A collection, which contains the tabs, which should be added, as an instance of the
   *                  type {@link Collection} or an empty collection, if no tabs should be added
   * @param index     The index, the first tab should be started at, as an {@link Integer} value. The index
   *                  must be at least 0 and at maximum <code>getCount()</code>, otherwise an {@link
   *                  IndexOutOfBoundsException} will be thrown
   * @param animation The animation, which should be used to add the tabs, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  void addAllTabs(@NonNull Collection<? extends Tab> tabs, int index,
                  @NonNull Animation animation);

  /**
   * Adds all tabs, which are contained by an array, to the tab switcher. By default, the tabs are
   * added at the end. If the switcher is currently shown, the tabs are added by using an
   * animation. By default, a {@link SwipeAnimation} with direction {@link
   * SwipeDirection#RIGHT} is used. If an animation is currently running, the tabs will
   * be added once all previously started animations have been finished.
   *
   * @param tabs An array, which contains the tabs, which should be added, as an array of the type
   *             {@link Tab} or an empty array, if no tabs should be added
   */
  void addAllTabs(@NonNull Tab[] tabs);

  /**
   * Adds all tabs, which are contained by an array, to the tab switcher, starting at a specific
   * index. If the switcher is currently shown, the tabs are added by using an animation. By
   * default, a {@link SwipeAnimation} with direction {@link
   * SwipeDirection#RIGHT} is used. If an animation is currently running, the tabs will
   * be added once all previously started animations have been finished.
   *
   * @param tabs  An array, which contains the tabs, which should be added, as an array of the type
   *              {@link Tab} or an empty array, if no tabs should be added
   * @param index The index, the first tab should be started at, as an {@link Integer} value. The index
   *              must be at least 0 and at maximum <code>getCount()</code>, otherwise an {@link
   *              IndexOutOfBoundsException} will be thrown
   */
  void addAllTabs(@NonNull Tab[] tabs, int index);

  /**
   * Adds all tabs, which are contained by an array, to the tab switcher, starting at a
   * specific index. If the switcher is currently shown, the tabs are added by using a specific
   * animation. If an animation is currently running, the tabs will be added once all previously
   * started animations have been finished.
   *
   * @param tabs      An array, which contains the tabs, which should be added, as an array of the type
   *                  {@link Tab} or an empty array, if no tabs should be added
   * @param index     The index, the first tab should be started at, as an {@link Integer} value. The index
   *                  must be at least 0 and at maximum <code>getCount()</code>, otherwise an {@link
   *                  IndexOutOfBoundsException} will be thrown
   * @param animation The animation, which should be used to add the tabs, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  void addAllTabs(@NonNull Tab[] tabs, int index, @NonNull Animation animation);

  /**
   * Removes a specific tab from the tab switcher. If the switcher is currently shown, the tab is
   * removed by using an animation. By default, a {@link SwipeAnimation} with direction
   * {@link SwipeDirection#RIGHT} is used. If an animation is currently running, the tab
   * will be removed once all previously started animations have been finished.
   *
   * @param tab The tab, which should be removed, as an instance of the class {@link Tab}. The tab
   *            may not be null
   */
  void removeTab(@NonNull Tab tab);

  /**
   * Removes a specific tab from the tab switcher. If the switcher is currently shown, the tab is
   * removed by using a specific animation. If an animation is currently running, the
   * tab will be removed once all previously started animations have been finished.
   *
   * @param tab       The tab, which should be removed, as an instance of the class {@link Tab}. The tab
   *                  may not be null
   * @param animation The animation, which should be used to remove the tabs, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  void removeTab(@NonNull Tab tab, @NonNull Animation animation);

  /**
   * Removes all tabs from the tab switcher. If the switcher is currently shown, the tabs are
   * removed by using an animation. By default, a {@link SwipeAnimation} with direction
   * {@link SwipeDirection#RIGHT} is used. If an animation is currently running, the
   * tabs will be removed once all previously started animations have been finished.
   */
  void clear();

  /**
   * Removes all tabs from the tab switcher. If the switcher is currently shown, the tabs are
   * removed by using a specific animation. If an animation is currently running, the
   * tabs will be removed once all previously started animations have been finished.
   *
   * @param animation The animation, which should be used to remove the tabs, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  void clear(@NonNull Animation animation);

  /**
   * Returns, whether the tab switcher is currently shown.
   *
   * @return True, if the tab switcher is currently shown, false otherwise
   */
  boolean isSwitcherShown();

  /**
   * Shows the tab switcher by using an animation, if it is not already shown.
   */
  void showSwitcher();

  /**
   * Hides the tab switcher by using an animation, if it is currently shown.
   */
  void hideSwitcher();

  /**
   * Toggles the visibility of the tab switcher by using an animation, i.e. if the switcher is
   * currently shown, it is hidden, otherwise it is shown.
   */
  void toggleSwitcherVisibility();

  /**
   * Returns the currently selected tab.
   *
   * @return The currently selected tab as an instance of the class {@link Tab} or null, if no tab
   * is currently selected
   */
  @Nullable
  Tab getSelectedTab();

  /**
   * Returns the index of the currently selected tab.
   *
   * @return The index of the currently selected tab as an {@link Integer} value or -1, if no tab
   * is currently selected
   */
  int getSelectedTabIndex();

  /**
   * Selects a specific tab.
   *
   * @param tab The tab, which should be selected, as an instance of the class {@link Tab}. The tab
   *            may not be null. If the tab is not contained by the tab switcher, a {@link
   *            NoSuchElementException} will be thrown
   */
  void selectTab(@NonNull Tab tab);

  /**
   * Sets the padding of the tab switcher.
   *
   * @param left   The left padding, which should be set, in pixels as an {@link Integer} value
   * @param top    The top padding, which should be set, in pixels as an {@link Integer} value
   * @param right  The right padding, which should be set, in pixels as an {@link Integer} value
   * @param bottom The bottom padding, which should be set, in pixels as an {@link Integer} value
   */
  void setPadding(int left, int top, int right, int bottom);

  /**
   * Returns the left padding of the tab switcher.
   *
   * @return The left padding of the tab switcher in pixels as an {@link Integer} value
   */
  int getPaddingLeft();

  /**
   * Returns the top padding of the tab switcher.
   *
   * @return The top padding of the tab switcher in pixels as an {@link Integer} value
   */
  int getPaddingTop();

  /**
   * Returns the right padding of the tab switcher.
   *
   * @return The right padding of the tab switcher in pixels as an {@link Integer} value
   */
  int getPaddingRight();

  /**
   * Returns the bottom padding of the tab switcher.
   *
   * @return The bottom padding of the tab switcher in pixels as an {@link Integer} value
   */
  int getPaddingBottom();

  /**
   * Returns the start padding of the tab switcher. This corresponds to the right padding, if a
   * right-to-left layout is used, or to the left padding otherwise.
   *
   * @return The start padding of the tab switcher in pixels as an {@link Integer} value
   */
  int getPaddingStart();

  /**
   * Returns the end padding of the tab switcher. This corresponds ot the left padding, if a
   * right-to-left layout is used, or to the right padding otherwise.
   *
   * @return The end padding of the tab switcher in pixels as an {@link Integer} value
   */
  int getPaddingEnd();

  /**
   * Returns the default icon of a tab.
   *
   * @return The default icon of a tab as an instance of the class {@link Drawable} or null, if no
   * icon is set
   */
  @Nullable
  Drawable getTabIcon();

  /**
   * Sets the default icon of a tab.
   *
   * @param resourceId The resource id of the icon, which should be set, as an {@link Integer} value. The
   *                   resource id must correspond to a valid drawable resource
   */
  void setTabIcon(@DrawableRes int resourceId);

  /**
   * Sets the default icon of a tab.
   *
   * @param icon The icon, which should be set, as an instance of the class {@link Bitmap} or null, if
   *             no icon should be set
   */
  void setTabIcon(@Nullable Bitmap icon);

  /**
   * Returns the default background color of a tab.
   *
   * @return The default background color of a tab as an instance of the class {@link
   * ColorStateList} or null, if the default color is used
   */
  @Nullable
  ColorStateList getTabBackgroundColor();

  /**
   * Sets the default background color of a tab.
   *
   * @param color The color, which should be set, as an {@link Integer} value or -1, if the default
   *              color should be used
   */
  void setTabBackgroundColor(@ColorInt int color);

  /**
   * Sets the default background color of a tab.
   *
   * @param colorStateList The color, which should be set, as an instance of the class {@link ColorStateList} or
   *                       null, if the default color should be used
   */
  void setTabBackgroundColor(@Nullable ColorStateList colorStateList);

  /**
   * Returns the default text color of a tab's title.
   *
   * @return The default text color of a tab's title as an instance of the class {@link
   * ColorStateList} or null, if the default color is used
   */
  @Nullable
  ColorStateList getTabTitleTextColor();

  /**
   * Sets the default text color of a tab's title.
   *
   * @param color The color, which should be set, as an {@link Integer} value or -1, if the default
   *              color should be used
   */
  void setTabTitleTextColor(@ColorInt int color);

  /**
   * Sets the default text color of a tab's title.
   *
   * @param colorStateList The color state list, which should be set, as an instance of the class {@link
   *                       ColorStateList} or null, if the default color should be used
   */
  void setTabTitleTextColor(@Nullable ColorStateList colorStateList);

  /**
   * Returns the default icon of a tab's close button.
   *
   * @return The default icon of a tab's close button as an instance of the class {@link Drawable}
   * or null, if the default icon is used
   */
  @Nullable
  Drawable getTabCloseButtonIcon();

  /**
   * Sets the default icon of a tab's close button.
   *
   * @param resourceId The resource id of the icon, which should be set, as an {@link Integer} value. The
   *                   resource id must correspond to a valid drawable resource
   */
  void setTabCloseButtonIcon(@DrawableRes int resourceId);

  /**
   * Sets the default icon of a tab's close button.
   *
   * @param icon The icon, which should be set, as an instance of the class {@link Bitmap} or null, if
   *             the default icon should be used
   */
  void setTabCloseButtonIcon(@Nullable final Bitmap icon);

  /**
   * Returns, whether the toolbars are shown, when the tab switcher is shown, or not. When using
   * the tablet layout, the toolbars are always shown.
   *
   * @return True, if the toolbars are shown, false otherwise
   */
  boolean areToolbarsShown();

  /**
   * Sets, whether the toolbars should be shown, when the tab switcher is shown, or not. This
   * method does not have any effect when using the tablet layout.
   *
   * @param show True, if the toolbars should be shown, false otherwise
   */
  void showToolbars(boolean show);

  /**
   * Returns the title of the toolbar, which is shown, when the tab switcher is shown. When using
   * the tablet layout, the title corresponds to the primary toolbar.
   *
   * @return The title of the toolbar, which is shown, when the tab switcher is shown, as an
   * instance of the type {@link CharSequence} or null, if no title is set
   */
  @Nullable
  CharSequence getToolbarTitle();

  /**
   * Sets the title of the toolbar, which is shown, when the tab switcher is shown. When using the
   * tablet layout, the title is set to the primary toolbar.
   *
   * @param resourceId The resource id of the title, which should be set, as an {@link Integer} value. The
   *                   resource id must correspond to a valid string resource
   */
  void setToolbarTitle(@StringRes int resourceId);

  /**
   * Sets the title of the toolbar, which is shown, when the tab switcher is shown. When using the
   * tablet layout, the title is set to the primary toolbar.
   *
   * @param title The title, which should be set, as an instance of the type {@link CharSequence} or
   *              null, if no title should be set
   */
  void setToolbarTitle(@Nullable CharSequence title);

  /**
   * Returns the navigation icon of the toolbar, which is shown, when the tab switcher is shown.
   * When using the tablet layout, the icon corresponds to the primary toolbar.
   *
   * @return The icon of the toolbar, which is shown, when the tab switcher is shown, as an
   * instance of the class {@link Drawable} or null, if no icon is set
   */
  @Nullable
  Drawable getToolbarNavigationIcon();

  /**
   * Sets the navigation icon of the toolbar, which is shown, when the tab switcher is shown. When
   * using the tablet layout, the icon is set to the primary toolbar.
   *
   * @param resourceId The resource id of the icon, which should be set, as an {@link Integer} value. The
   *                   resource id must correspond to a valid drawable resource
   * @param listener   The listener, which should be notified, when the navigation item has been clicked, as
   *                   an instance of the type {@link OnClickListener} or null, if no listener should be
   *                   notified
   */
  void setToolbarNavigationIcon(@DrawableRes int resourceId, @Nullable OnClickListener listener);

  /**
   * Sets the navigation icon of the toolbar, which is shown, when the tab switcher is shown. When
   * using the tablet layout, the icon is set to the primary toolbar.
   *
   * @param icon     The icon, which should be set, as an instance of the class {@link Drawable} or null,
   *                 if no icon should be set
   * @param listener The listener, which should be notified, when the navigation item has been clicked, as
   *                 an instance of the type {@link OnClickListener} or null, if no listener should be
   *                 notified
   */
  void setToolbarNavigationIcon(@Nullable Drawable icon, @Nullable OnClickListener listener);

  /**
   * Inflates the menu of the toolbar, which is shown, when the tab switcher is shown. When using
   * the tablet layout, the menu is inflated into the secondary toolbar.
   *
   * @param resourceId The resource id of the menu, which should be inflated, as an {@link Integer} value.
   *                   The resource id must correspond to a valid menu resource
   * @param listener   The listener, which should be notified, when an menu item has been clicked, as an
   *                   instance of the type OnMenuItemClickListener or null, if no listener should be
   *                   notified
   */
  void inflateToolbarMenu(@MenuRes int resourceId, @Nullable OnMenuItemClickListener listener);

  /**
   * Adds a new listener, which should be notified, when a tab is about to be closed by clicking
   * its close button.
   *
   * @param listener The listener, which should be added, as an instance of the type {@link
   *                 TabCloseListener}. The listener may not be null
   */
  void addCloseTabListener(@NonNull TabCloseListener listener);

  /**
   * Removes a specific listener, which should not be notified, when a tab is about to be closed
   * by clicking its close button, anymore.
   *
   * @param listener The listener, which should be removed, as an instance of the type {@link
   *                 TabCloseListener}. The listener may not be null
   */
  void removeCloseTabListener(@NonNull TabCloseListener listener);

  /**
   * Adds a new listener, which should be notified, when the preview of a tab is about to be
   * loaded. Previews are only loaded when using the smartphone layout.
   *
   * @param listener The listener, which should be added, as an instance of the type {@link
   *                 TabPreviewListener}. The listener may not be null
   */
  void addTabPreviewListener(@NonNull TabPreviewListener listener);

  /**
   * Removes a specific listener, which should not be notified, when the preview of a tab is about
   * to be loaded.
   *
   * @param listener The listener, which should be removed, as an instance of the type {@link
   *                 TabPreviewListener}. The listener may not be null
   */
  void removeTabPreviewListener(@NonNull TabPreviewListener listener);

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/model/Restorable.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.model;

import android.os.Bundle;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

/**
 * Defines the interface, a class, whose state should be stored and restored, must implement.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public interface Restorable {

  /**
   * Saves the current state.
   *
   * @param outState The bundle, which should be used to store the saved state, as an instance of the
   *                 class {@link Bundle}. The bundle may not be null
   */
  void saveInstanceState(@NonNull Bundle outState);

  /**
   * Restores a previously saved state.
   *
   * @param savedInstanceState The saved state as an instance of the class {@link Bundle} or null, if no saved state
   *                           is available
   */
  void restoreInstanceState(@Nullable Bundle savedInstanceState);

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/model/State.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.model;

/**
 * Contains all possible states of a tab, while the switcher is shown.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public enum State {

  /**
   * When the tab is part of the stack, which is located at the start of the switcher.
   */
  STACKED_START,

  /**
   * When the tab is displayed atop of the stack, which is located at the start of the switcher.
   */
  STACKED_START_ATOP,

  /**
   * When the tab is floating and freely movable.
   */
  FLOATING,

  /**
   * When the tab is part of the stack, which is located at the end of the switcher.
   */
  STACKED_END,

  /**
   * When the tab is currently not visible, i.e. if no view is inflated to visualize it.
   */
  HIDDEN

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/model/TabItem.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.model;

import android.view.View;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import de.mrapp.android.tabswitcher.R;
import de.mrapp.android.tabswitcher.Tab;
import de.mrapp.android.tabswitcher.TabSwitcher;
import de.mrapp.android.tabswitcher.layout.phone.PhoneTabViewHolder;
import de.mrapp.android.util.view.AttachedViewRecycler;

import static de.mrapp.android.util.Condition.ensureAtLeast;
import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * An item, which contains information about a tab of a {@link TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class TabItem {

  /**
   * A comparator, which allows to compare two instances of the class {@link TabItem}.
   */
  public static class Comparator implements java.util.Comparator<TabItem> {

    /**
     * The tab switcher, the tab items, which are compared by the comparator, belong to.
     */
    private final TabSwitcher tabSwitcher;

    /**
     * Creates a new comparator, which allows to compare two instances of the class {@link
     * TabItem}.
     *
     * @param tabSwitcher The tab switcher, the tab items, which should be compared by the comparator,
     *                    belong to, as a instance of the class {@link TabSwitcher}. The tab switcher may
     *                    not be null
     */
    public Comparator(@NonNull final TabSwitcher tabSwitcher) {
      ensureNotNull(tabSwitcher, "The tab switcher may not be null");
      this.tabSwitcher = tabSwitcher;
    }

    @Override
    public int compare(final TabItem o1, final TabItem o2) {
      Tab tab1 = o1.getTab();
      Tab tab2 = o2.getTab();
      int index1 = tabSwitcher.indexOf(tab1);
      int index2 = tabSwitcher.indexOf(tab2);

      if (index2 == -1) {
        index2 = o2.getIndex();
      }

      if (index1 == -1 || index2 == -1) {
        throw new RuntimeException("Tab not contained by tab switcher");
      }

      return index1 < index2 ? -1 : 1;
    }

  }

  /**
   * The index of the tab.
   */
  private final int index;

  /**
   * The tab.
   */
  private final Tab tab;

  /**
   * The view, which is used to visualize the tab.
   */
  private View view;

  /**
   * The view holder, which stores references the views, which belong to the tab.
   */
  private PhoneTabViewHolder viewHolder;

  /**
   * The tag, which is associated with the tab.
   */
  private Tag tag;

  /**
   * Creates a new item, which contains information about a tab of a {@link TabSwitcher}. By
   * default, the item is neither associated with a view, nor with a view holder.
   *
   * @param index The index of the tab as an {@link Integer} value. The index must be at least 0
   * @param tab   The tab as an instance of the class {@link Tab}. The tab may not be null
   */
  public TabItem(final int index, @NonNull final Tab tab) {
    ensureAtLeast(index, 0, "The index must be at least 0");
    ensureNotNull(tab, "The tab may not be null");
    this.index = index;
    this.tab = tab;
    this.view = null;
    this.viewHolder = null;
    this.tag = new Tag();
  }

  /**
   * Creates a new item, which contains information about a tab of a tab switcher. By
   * default, the item is neither associated with a view, nor with a view holder.
   *
   * @param model        The model, the tab belongs to, as an instance of the type {@link Model}. The model
   *                     may not be null
   * @param viewRecycler The view recycler, which is used to reuse the views, which are used to visualize
   *                     tabs, as an instance of the class AttachedViewRecycler. The view recycler may not be
   *                     null
   * @param index        The index of the tab as an {@link Integer} value. The index must be at least 0
   * @return The item, which has been created, as an instance of the class {@link TabItem}. The
   * item may not be null
   */
  @NonNull
  public static TabItem create(@NonNull final Model model,
                               @NonNull final AttachedViewRecycler<TabItem, ?> viewRecycler,
                               final int index) {
    Tab tab = model.getTab(index);
    return create(viewRecycler, index, tab);
  }

  /**
   * Creates a new item, which contains information about a specific tab. By default, the item is
   * neither associated with a view, nor with a view holder.
   *
   * @param viewRecycler The view recycler, which is used to reuse the views, which are used to visualize
   *                     tabs, as an instance of the class AttachedViewRecycler. The view recycler may not be
   *                     null
   * @param index        The index of the tab as an {@link Integer} value. The index must be at least 0
   * @param tab          The tab as an instance of the class {@link Tab}. The tab may not be null
   * @return The item, which has been created, as an instance of the class {@link TabItem}. The
   * item may not be null
   */
  @NonNull
  public static TabItem create(@NonNull final AttachedViewRecycler<TabItem, ?> viewRecycler,
                               final int index, @NonNull final Tab tab) {
    TabItem tabItem = new TabItem(index, tab);
    View view = viewRecycler.getView(tabItem);

    if (view != null) {
      tabItem.setView(view);
      tabItem.setViewHolder((PhoneTabViewHolder) view.getTag(R.id.tag_view_holder));
      Tag tag = (Tag) view.getTag(R.id.tag_properties);

      if (tag != null) {
        tabItem.setTag(tag);
      }
    }

    return tabItem;
  }

  /**
   * Returns the index of the tab.
   *
   * @return The index of the tab as an {@link Integer} value. The index must be at least 0
   */
  public final int getIndex() {
    return index;
  }

  /**
   * Returns the tab.
   *
   * @return The tab as an instance of the class {@link Tab}. The tab may not be null
   */
  @NonNull
  public final Tab getTab() {
    return tab;
  }

  /**
   * Returns the view, which is used to visualize the tab.
   *
   * @return The view, which is used to visualize the tab, as an instance of the class {@link
   * View} or null, if no such view is currently inflated
   */
  public final View getView() {
    return view;
  }

  /**
   * Sets the view, which is used to visualize the tab.
   *
   * @param view The view, which should be set, as an instance of the class {@link View} or null, if
   *             no view should be set
   */
  public final void setView(@Nullable final View view) {
    this.view = view;
  }

  /**
   * Returns the view holder, which stores references to the views, which belong to the tab.
   *
   * @return The view holder as an instance of the class {@link PhoneTabViewHolder} or null, if no
   * view is is currently inflated to visualize the tab
   */
  public final PhoneTabViewHolder getViewHolder() {
    return viewHolder;
  }

  /**
   * Sets the view holder, which stores references to the views, which belong to the tab.
   *
   * @param viewHolder The view holder, which should be set, as an instance of the class {@link
   *                   PhoneTabViewHolder} or null, if no view holder should be set
   */
  public final void setViewHolder(@Nullable final PhoneTabViewHolder viewHolder) {
    this.viewHolder = viewHolder;
  }

  /**
   * Returns the tag, which is associated with the tab.
   *
   * @return The tag as an instance of the class {@link Tag}. The tag may not be null
   */
  @NonNull
  public final Tag getTag() {
    return tag;
  }

  /**
   * Sets the tag, which is associated with the tab.
   *
   * @param tag The tag, which should be set, as an instance of the class {@link Tag}. The tag may
   *            not be null
   */
  public final void setTag(@NonNull final Tag tag) {
    ensureNotNull(tag, "The tag may not be null");
    this.tag = tag;
  }

  /**
   * Returns, whether a view, which is used to visualize the tab, is currently inflated, or not.
   *
   * @return True, if a view, which is used to visualize the tab, is currently inflated, false
   * otherwise
   */
  public final boolean isInflated() {
    return view != null && viewHolder != null;
  }

  /**
   * Returns, whether the tab is currently visible, or not.
   *
   * @return True, if the tab is currently visible, false otherwise
   */
  public final boolean isVisible() {
    return tag.getState() != State.HIDDEN || tag.isClosing();
  }

  @Override
  public final String toString() {
    return "TabItem [index = " + index + "]";
  }

  @Override
  public final int hashCode() {
    return tab.hashCode();
  }

  @Override
  public final boolean equals(final Object obj) {
    if (obj == null)
      return false;
    if (obj.getClass() != getClass())
      return false;
    TabItem other = (TabItem) obj;
    return tab.equals(other.tab);
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/model/TabSwitcherModel.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.model;

import android.content.Context;
import android.content.res.ColorStateList;
import android.graphics.Bitmap;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.os.Build;
import android.os.Bundle;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.ViewGroup;
import androidx.annotation.*;
import androidx.appcompat.widget.Toolbar.OnMenuItemClickListener;
import androidx.core.content.ContextCompat;
import de.mrapp.android.tabswitcher.*;
import de.mrapp.android.tabswitcher.layout.ChildRecyclerAdapter;
import de.mrapp.android.util.logging.LogLevel;

import java.util.*;

import static de.mrapp.android.util.Condition.ensureNotEqual;
import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * The model of a {@link TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class TabSwitcherModel implements Model, Restorable {

  /**
   * The name of the extra, which is used to store the index of the first visible tab within a
   * bundle.
   */
  public static final String FIRST_VISIBLE_TAB_INDEX_EXTRA =
    TabSwitcherModel.class.getName() + "::FirstVisibleIndex";

  /**
   * The name of the extra, which is used to store the position of the first visible tab within a
   * bundle.
   */
  public static final String FIRST_VISIBLE_TAB_POSITION_EXTRA =
    TabSwitcherModel.class.getName() + "::FirstVisiblePosition";

  /**
   * The name of the extra, which is used to store the log level within a bundle.
   */
  private static final String LOG_LEVEL_EXTRA = TabSwitcherModel.class.getName() + "::LogLevel";

  /**
   * The name of the extra, which is used to store the tabs within a bundle.
   */
  private static final String TABS_EXTRA = TabSwitcherModel.class.getName() + "::Tabs";

  /**
   * The name of the extra, which is used to store, whether the tab switcher is shown, or not,
   * within a bundle.
   */
  private static final String SWITCHER_SHOWN_EXTRA =
    TabSwitcherModel.class.getName() + "::SwitcherShown";

  /**
   * The name of the extra, which is used to store the selected tab within a bundle.
   */
  private static final String SELECTED_TAB_EXTRA =
    TabSwitcherModel.class.getName() + "::SelectedTab";

  /**
   * The name of the extra, which is used to store the padding within a bundle.
   */
  private static final String PADDING_EXTRA = TabSwitcherModel.class.getName() + "::Padding";

  /**
   * The name of the extra, which is used to store the resource id of a tab's icon within a
   * bundle.
   */
  private static final String TAB_ICON_ID_EXTRA =
    TabSwitcherModel.class.getName() + "::TabIconId";

  /**
   * The name of the extra, which is used to store the bitmap of a tab's icon within a bundle.
   */
  private static final String TAB_ICON_BITMAP_EXTRA =
    TabSwitcherModel.class.getName() + "::TabIconBitmap";

  /**
   * The name of the extra, which is used to store the background color of a tab within a bundle.
   */
  private static final String TAB_BACKGROUND_COLOR_EXTRA =
    TabSwitcherModel.class.getName() + "::TabBackgroundColor";

  /**
   * The name of the extra, which is used to store the text color of a tab's title within a
   * bundle.
   */
  private static final String TAB_TITLE_TEXT_COLOR_EXTRA =
    TabSwitcherModel.class.getName() + "::TabTitleTextColor";

  /**
   * The name of the extra, which is used to store the resource id of a tab's icon within a
   * bundle.
   */
  private static final String TAB_CLOSE_BUTTON_ICON_ID_EXTRA =
    TabSwitcherModel.class.getName() + "::TabCloseButtonIconId";

  /**
   * The name of the extra, which is used to store the bitmap of a tab's icon within a bundle.
   */
  private static final String TAB_CLOSE_BUTTON_ICON_BITMAP_EXTRA =
    TabSwitcher.class.getName() + "::TabCloseButtonIconBitmap";

  /**
   * The name of the extra, which is used to store, whether the toolbars are shown, or not, within
   * a bundle.
   */
  private static final String SHOW_TOOLBARS_EXTRA =
    TabSwitcher.class.getName() + "::ShowToolbars";

  /**
   * The name of the extra, which is used to store the title of the toolbar within a bundle.
   */
  private static final String TOOLBAR_TITLE_EXTRA =
    TabSwitcher.class.getName() + "::ToolbarTitle";

  /**
   * The tab switcher, the model belongs to.
   */
  private final TabSwitcher tabSwitcher;

  /**
   * A set, which contains the listeners, which are notified about the model's events.
   */
  private final Set<Listener> listeners;

  /**
   * The index of the first visible tab.
   */
  private int firstVisibleTabIndex;

  /**
   * The position of the first visible tab.
   */
  private float firstVisibleTabPosition;

  /**
   * The log level, which is used for logging.
   */
  private LogLevel logLevel;

  /**
   * A list, which contains the tabs, which are contained by the tab switcher.
   */
  private ArrayList<Tab> tabs;

  /**
   * True, if the tab switcher is currently shown, false otherwise.
   */
  private boolean switcherShown;

  /**
   * The currently selected tab.
   */
  private Tab selectedTab;

  /**
   * The decorator, which allows to inflate the views, which correspond to the tab switcher's
   * tabs.
   */
  private TabSwitcherDecorator decorator;

  /**
   * The adapter, which allows to inflate the child views of tabs.
   */
  private ChildRecyclerAdapter childRecyclerAdapter;

  /**
   * An array, which contains the left, top, right and bottom padding of the tab switcher.
   */
  private int[] padding;

  /**
   * The resource id of a tab's icon.
   */
  private int tabIconId;

  /**
   * The bitmap of a tab's icon.
   */
  private Bitmap tabIconBitmap;

  /**
   * The background color of a tab;
   */
  private ColorStateList tabBackgroundColor;

  /**
   * The text color of a tab's title.
   */
  private ColorStateList tabTitleTextColor;

  /**
   * The resource id of the icon of a tab's close button.
   */
  private int tabCloseButtonIconId;

  /**
   * The bitmap of the icon of a tab's close button.
   */
  private Bitmap tabCloseButtonIconBitmap;

  /**
   * True, if the toolbars should be shown, when the tab switcher is shown, false otherwise.
   */
  private boolean showToolbars;

  /**
   * The title of the toolbar, which is shown, when the tab switcher is shown.
   */
  private CharSequence toolbarTitle;

  /**
   * The navigation icon of the toolbar, which is shown, when the tab switcher is shown.
   */
  private Drawable toolbarNavigationIcon;

  /**
   * The listener, which is notified, when the navigation icon of the toolbar, which is shown,
   * when the tab switcher is shown, has been clicked.
   */
  private OnClickListener toolbarNavigationIconListener;

  /**
   * The resource id of the menu of the toolbar, which is shown, when the tab switcher is shown.
   */
  private int toolbarMenuId;

  /**
   * The listener, which is notified, when an item of the menu of the toolbar, which is shown,
   * when the tab switcher is shown, is clicked.
   */
  private OnMenuItemClickListener toolbarMenuItemListener;

  /**
   * A set, which contains the listeners, which should be notified, when a tab is about to be
   * closed by clicking its close button.
   */
  private final Set<TabCloseListener> tabCloseListeners;

  /**
   * A set, which contains the listeners, which should be notified, when the previews of tabs are
   * about to be loaded.
   */
  private final Set<TabPreviewListener> tabPreviewListeners;

  /**
   * Returns the index of a specific tab or throws a {@link NoSuchElementException}, if the model
   * does not contain the given tab.
   *
   * @param tab The tab, whose index should be returned, as an instance of the class {@link Tab}. The
   *            tab may not be null
   * @return The index of the given tab as an {@link Integer} value
   */
  private int indexOfOrThrowException(@NonNull final Tab tab) {
    int index = indexOf(tab);
    ensureNotEqual(index, -1, "No such tab: " + tab, NoSuchElementException.class);
    return index;
  }

  /**
   * Sets, whether the tab switcher is currently shown, or not.
   *
   * @param shown True, if the tab switcher is currently shown, false otherwise
   * @return True, if the visibility of the tab switcher has been changed, false otherwise
   */
  private boolean setSwitcherShown(final boolean shown) {
    if (switcherShown != shown) {
      switcherShown = shown;
      return true;
    }

    return false;
  }

  /**
   * Notifies the listeners, that the log level has been changed.
   *
   * @param logLevel The log level, which has been set, as a value of the enum {@link LogLevel}. The log
   *                 level may not be null
   */
  private void notifyOnLogLevelChanged(@NonNull final LogLevel logLevel) {
    for (Listener listener : listeners) {
      listener.onLogLevelChanged(logLevel);
    }
  }

  /**
   * Notifies the listeners, that the decorator has been changed.
   *
   * @param decorator The decorator, which has been set, as an instance of the class {@link
   *                  TabSwitcherDecorator}. The decorator may not be null
   */
  private void notifyOnDecoratorChanged(@NonNull final TabSwitcherDecorator decorator) {
    for (Listener listener : listeners) {
      listener.onDecoratorChanged(decorator);
    }
  }

  /**
   * Notifies the listeners, that the tab switcher has been shown.
   */
  private void notifyOnSwitcherShown() {
    for (Listener listener : listeners) {
      listener.onSwitcherShown();
    }
  }

  /**
   * Notifies the listeners, that the tab switcher has been shown.
   */
  private void notifyOnSwitcherHidden() {
    for (Listener listener : listeners) {
      listener.onSwitcherHidden();
    }
  }

  /**
   * Notifies the listeners, that the currently selected tab has been changed.
   *
   * @param previousIndex  The index of the previously selected tab as an {@link Integer} value or -1, if no tab
   *                       was selected
   * @param index          The index of the tab, which has been selected, as an {@link Integer} value or -1, if
   *                       no tab has been selected
   * @param tab            The tab, which has been selected, as an instance of the class {@link Tab} or null, if
   *                       no tab has been selected
   * @param switcherHidden True, if selecting the tab caused the tab switcher to be hidden, false otherwise
   */
  private void notifyOnSelectionChanged(final int previousIndex, final int index,
                                        @Nullable final Tab tab, final boolean switcherHidden) {
    for (Listener listener : listeners) {
      listener.onSelectionChanged(previousIndex, index, tab, switcherHidden);
    }
  }

  /**
   * Notifies the listeners, that a specific tab has been added to the model.
   *
   * @param index                     The index, the tab has been added at, as an {@link Integer} value
   * @param tab                       The tab, which has been added, as an instance of the class {@link Tab}. The tab may
   *                                  not be null
   * @param previousSelectedTabIndex  The index of the previously selected tab as an {@link Integer} value or -1, if no tab
   *                                  was selected
   * @param selectedTabIndex          The index of the currently selected tab as an {@link Integer} value or -1, if the tab
   *                                  switcher does not contain any tabs
   * @param switcherVisibilityChanged True, if adding the tab caused the visibility of the tab switcher to be changed,
   *                                  false otherwise
   * @param animation                 The animation, which has been used to add the tab, as an instance of the class {@link
   *                                  Animation}. The animation may not be null
   */
  private void notifyOnTabAdded(final int index, @NonNull final Tab tab,
                                final int previousSelectedTabIndex, final int selectedTabIndex,
                                final boolean switcherVisibilityChanged,
                                @NonNull final Animation animation) {
    for (Listener listener : listeners) {
      listener.onTabAdded(index, tab, previousSelectedTabIndex, selectedTabIndex,
        switcherVisibilityChanged, animation);
    }
  }

  /**
   * Notifies the listeners, that multiple tabs have been added to the model.
   *
   * @param index                    The index of the tab, which has been added, as an {@link Integer} value
   * @param tabs                     An array, which contains the tabs, which have been added, as an array of the type
   *                                 {@link Tab}. The array may not be null
   * @param previousSelectedTabIndex The index of the previously selected tab as an {@link Integer} value or -1, if no tab
   *                                 was selected
   * @param selectedTabIndex         The index of the currently selected tab as an {@link Integer} value or -1, if the tab
   *                                 switcher does not contain any tabs
   * @param animation                The animation, which has been used to add the tabs, as an instance of the class
   *                                 {@link Animation}. The animation may not be null
   */
  private void notifyOnAllTabsAdded(final int index, @NonNull final Tab[] tabs,
                                    final int previousSelectedTabIndex,
                                    final int selectedTabIndex,
                                    @NonNull final Animation animation) {
    for (Listener listener : listeners) {
      listener.onAllTabsAdded(index, tabs, previousSelectedTabIndex, selectedTabIndex,
        animation);
    }
  }

  /**
   * Notifies the listeners, that a tab has been removed from the model.
   *
   * @param index                    The index of the tab, which has been removed, as an {@link Integer} value
   * @param tab                      The tab, which has been removed, as an instance of the class {@link Tab}. The tab may
   *                                 not be null
   * @param previousSelectedTabIndex The index of the previously selected tab as an {@link Integer} value or -1, if no tab
   *                                 was selected
   * @param selectedTabIndex         The index of the currently selected tab as an {@link Integer} value or -1, if the tab
   *                                 switcher does not contain any tabs
   * @param animation                The animation, which has been used to remove the tab, as an instance of the class
   *                                 {@link Animation}. The animation may not be null
   */
  private void notifyOnTabRemoved(final int index, @NonNull final Tab tab,
                                  final int previousSelectedTabIndex, final int selectedTabIndex,
                                  @NonNull final Animation animation) {
    for (Listener listener : listeners) {
      listener.onTabRemoved(index, tab, previousSelectedTabIndex, selectedTabIndex,
        animation);
    }
  }

  /**
   * Notifies the listeners, that all tabs have been removed.
   *
   * @param tabs      An array, which contains the tabs, which have been removed, as an array of the type
   *                  {@link Tab} or an empty array, if no tabs have been removed
   * @param animation The animation, which has been used to remove the tabs, as an instance of the class
   *                  {@link Animation}. The animation may not be null
   */
  private void notifyOnAllTabsRemoved(@NonNull final Tab[] tabs,
                                      @NonNull final Animation animation) {
    for (Listener listener : listeners) {
      listener.onAllTabsRemoved(tabs, animation);
    }
  }

  /**
   * Notifies the listeners, that the padding has been changed.
   *
   * @param left   The left padding, which has been set, in pixels as an {@link Integer} value
   * @param top    The top padding, which has been set, in pixels as an {@link Integer} value
   * @param right  The right padding, which has been set, in pixels as an {@link Integer} value
   * @param bottom The bottom padding, which has been set, in pixels as an {@link Integer} value
   */
  private void notifyOnPaddingChanged(final int left, final int top, final int right,
                                      final int bottom) {
    for (Listener listener : listeners) {
      listener.onPaddingChanged(left, top, right, bottom);
    }
  }

  /**
   * Notifies the listeners, that the default icon of a tab has been changed.
   *
   * @param icon The icon, which has been set, as an instance of the class {@link Drawable} or null,
   *             if no icon is set
   */
  private void notifyOnTabIconChanged(@Nullable final Drawable icon) {
    for (Listener listener : listeners) {
      listener.onTabIconChanged(icon);
    }
  }

  /**
   * Notifies the listeners, that the default background color of a tab has been changed.
   *
   * @param colorStateList The color state list, which has been set, as an instance of the class {@link
   *                       ColorStateList} or null, if the default color should be used
   */
  private void notifyOnTabBackgroundColorChanged(@Nullable final ColorStateList colorStateList) {
    for (Listener listener : listeners) {
      listener.onTabBackgroundColorChanged(colorStateList);
    }
  }

  /**
   * Notifies the listeners, that the default text color of a tab's title has been changed.
   *
   * @param colorStateList The color state list, which has been set, as an instance of the class {@link
   *                       ColorStateList} or null, if the default color should be used
   */
  private void notifyOnTabTitleColorChanged(@Nullable final ColorStateList colorStateList) {
    for (Listener listener : listeners) {
      listener.onTabTitleColorChanged(colorStateList);
    }
  }

  /**
   * Notifies the listeners, that the icon of a tab's close button has been changed.
   *
   * @param icon The icon, which has been set, as an instance of the class {@link Drawable} or null,
   *             if the default icon should be used
   */
  private void notifyOnTabCloseButtonIconChanged(@Nullable final Drawable icon) {
    for (Listener listener : listeners) {
      listener.onTabCloseButtonIconChanged(icon);
    }
  }

  /**
   * Notifies the listeners, that it has been changed, whether the toolbars should be shown, when
   * the tab switcher is shown, or not.
   *
   * @param visible True, if the toolbars should be shown, when the tab switcher is shown, false
   *                otherwise
   */
  private void notifyOnToolbarVisibilityChanged(final boolean visible) {
    for (Listener listener : listeners) {
      listener.onToolbarVisibilityChanged(visible);
    }
  }

  /**
   * Notifies the listeners, that the title of the toolbar, which is shown, when the tab switcher
   * is shown, has been changed.
   *
   * @param title The title, which has been set, as an instance of the type {@link CharSequence} or
   *              null, if no title is set
   */
  private void notifyOnToolbarTitleChanged(@Nullable final CharSequence title) {
    for (Listener listener : listeners) {
      listener.onToolbarTitleChanged(title);
    }
  }

  /**
   * Notifies the listeners, that the menu of the toolbar, which is shown, when the tab switcher
   * is shown, has been inflated.
   *
   * @param resourceId            The resource id of the menu, which has been inflated, as an {@link Integer} value.
   *                              The resource id must correspond to a valid menu resource
   * @param menuItemClickListener The listener, which has been registered to be notified, when an item of the menu has
   *                              been clicked, as an instance of the type OnMenuItemClickListener or null, if no
   *                              listener should be notified
   */
  private void notifyOnToolbarMenuInflated(@MenuRes final int resourceId,
                                           @Nullable final OnMenuItemClickListener menuItemClickListener) {
    for (Listener listener : listeners) {
      listener.onToolbarMenuInflated(resourceId, menuItemClickListener);
    }
  }

  /**
   * Notifies the listeners, that the navigation icon of the toolbar, which is shown, when the tab
   * switcher is shown, has been changed.
   *
   * @param icon          The navigation icon, which has been set, as an instance of the class {@link Drawable}
   *                      or null, if no navigation icon is set
   * @param clickListener The listener, which should be notified, when the navigation item has been clicked, as
   *                      an instance of the type {@link OnClickListener} or null, if no listener should be
   *                      notified
   */
  private void notifyOnToolbarNavigationIconChanged(@Nullable final Drawable icon,
                                                    @Nullable final OnClickListener clickListener) {
    for (Listener listener : listeners) {
      listener.onToolbarNavigationIconChanged(icon, clickListener);
    }
  }

  /**
   * Creates a new model of a {@link TabSwitcher}.
   *
   * @param tabSwitcher The tab switcher, the model belongs to, as an instance of the class {@link
   *                    ViewGroup}. The parent may not be null
   */
  public TabSwitcherModel(@NonNull final TabSwitcher tabSwitcher) {
    ensureNotNull(tabSwitcher, "The tab switcher may not be null");
    this.tabSwitcher = tabSwitcher;
    this.listeners = new LinkedHashSet<>();
    this.firstVisibleTabIndex = -1;
    this.firstVisibleTabPosition = -1;
    this.logLevel = LogLevel.INFO;
    this.tabs = new ArrayList<>();
    this.switcherShown = false;
    this.selectedTab = null;
    this.decorator = null;
    this.childRecyclerAdapter = null;
    this.padding = new int[]{0, 0, 0, 0};
    this.tabIconId = -1;
    this.tabIconBitmap = null;
    this.tabBackgroundColor = null;
    this.tabTitleTextColor = null;
    this.tabCloseButtonIconId = -1;
    this.tabCloseButtonIconBitmap = null;
    this.showToolbars = false;
    this.toolbarTitle = null;
    this.toolbarNavigationIcon = null;
    this.toolbarNavigationIconListener = null;
    this.toolbarMenuId = -1;
    this.toolbarMenuItemListener = null;
    this.tabCloseListeners = new LinkedHashSet<>();
    this.tabPreviewListeners = new LinkedHashSet<>();
  }

  /**
   * Adds a new listener, which should be notified about the model's events.
   *
   * @param listener The listener, which should be added, as an instance of the type {@link Listener}. The
   *                 listener may not be null
   */
  public final void addListener(@NonNull final Listener listener) {
    ensureNotNull(listener, "The listener may not be null");
    listeners.add(listener);
  }

  /**
   * Removes a specific listener, which should not be notified about the model's events, anymore.
   *
   * @param listener The listener, which should be removed, as an instance of the type {@link Listener}.
   *                 The listener may not be null
   */
  public final void removeListener(@NonNull final Listener listener) {
    ensureNotNull(listener, "The listener may not be null");
    listeners.remove(listener);
  }

  /**
   * Returns the index of the first visible tab.
   *
   * @return The index of the first visible tab as an {@link Integer} value or -1, if the index is
   * unknown
   */
  public final int getFirstVisibleTabIndex() {
    return firstVisibleTabIndex;
  }

  /**
   * Sets the index of the first visible tab.
   *
   * @param firstVisibleTabIndex The index of the first visible tab, which should be set, as an {@link Integer} value
   *                             or -1, if the index is unknown
   */
  public final void setFirstVisibleTabIndex(final int firstVisibleTabIndex) {
    this.firstVisibleTabIndex = firstVisibleTabIndex;
  }

  /**
   * Returns the position of the first visible tab.
   *
   * @return The position of the first visible tab as a {@link Float} value or -1, if the position
   * is unknown
   */
  public final float getFirstVisibleTabPosition() {
    return firstVisibleTabPosition;
  }

  /**
   * Sets the position of the first visible tab.
   *
   * @param firstVisibleTabPosition The position of the first visible tab, which should be set, as a {@link Float} value
   *                                or -1, if the position is unknown
   */
  public final void setFirstVisibleTabPosition(final float firstVisibleTabPosition) {
    this.firstVisibleTabPosition = firstVisibleTabPosition;
  }

  /**
   * Returns the listener, which is notified, when the navigation icon of the toolbar, which is
   * shown, when the tab switcher is shown, has been clicked.
   *
   * @return The listener, which is notified, when the navigation icon of the toolbar, which is
   * shown, when the tab switcher is shown, has been clicked as an instance of the type {@link
   * OnClickListener} or null, if no listener should be notified
   */
  @Nullable
  public final OnClickListener getToolbarNavigationIconListener() {
    return toolbarNavigationIconListener;
  }

  /**
   * Returns the resource id of the menu of the toolbar, which is shown, when the tab switcher is
   * shown.
   *
   * @return The resource id of the menu of the toolbar, which is shown, when the tab switcher is
   * shown, as an {@link Integer} value. The resource id must correspond to a valid menu resource
   */
  @MenuRes
  public final int getToolbarMenuId() {
    return toolbarMenuId;
  }

  /**
   * Returns the listener, which is notified, when an item of the menu of the toolbar, which is
   * shown, when the tab switcher is shown, has been clicked.
   *
   * @return The listener, which is notified, when an item of the menu of the toolbar, which is
   * shown, when the tab switcher is shown, has been clicked as an instance of the type
   * OnMenuItemClickListener or null, if no listener should be notified
   */
  @Nullable
  public final OnMenuItemClickListener getToolbarMenuItemListener() {
    return toolbarMenuItemListener;
  }

  /**
   * Returns the listeners, which should be notified, when a tab is about to be closed by clicking
   * its close button.
   *
   * @return A set, which contains the listeners, which should be notified, when a tab is about to
   * be closed by clicking its close button, as an instance of the type {@link Set} or an empty
   * set, if no listeners should be notified
   */
  @NonNull
  public final Set<TabCloseListener> getTabCloseListeners() {
    return tabCloseListeners;
  }

  /**
   * Returns the listeners, which should be notified, when the previews of tabs are about to be
   * loaded.
   *
   * @return A set, which contains the listeners, which should be notified, when the previews of
   * tabs are about to be loaded, as an instance of the type {@link Set} or an empty set, if no
   * listeners should be notified
   */
  @NonNull
  public final Set<TabPreviewListener> getTabPreviewListeners() {
    return tabPreviewListeners;
  }

  /**
   * Returns the adapter, which allows to inflate the child views of tabs.
   *
   * @return The adapter, which allows to inflate the child views of tabs, as an instance of the
   * class {@link ChildRecyclerAdapter}
   */
  public final ChildRecyclerAdapter getChildRecyclerAdapter() {
    return childRecyclerAdapter;
  }

  @NonNull
  @Override
  public final Context getContext() {
    return tabSwitcher.getContext();
  }

  @Override
  public final void setDecorator(@NonNull final TabSwitcherDecorator decorator) {
    ensureNotNull(decorator, "The decorator may not be null");
    this.decorator = decorator;
    this.childRecyclerAdapter = new ChildRecyclerAdapter(tabSwitcher, decorator);
    notifyOnDecoratorChanged(decorator);
  }

  @Override
  public final TabSwitcherDecorator getDecorator() {
    return decorator;
  }

  @NonNull
  @Override
  public final LogLevel getLogLevel() {
    return logLevel;
  }

  @Override
  public final void setLogLevel(@NonNull final LogLevel logLevel) {
    ensureNotNull(logLevel, "The log level may not be null");
    this.logLevel = logLevel;
    notifyOnLogLevelChanged(logLevel);
  }

  @Override
  public final boolean isEmpty() {
    return tabs.isEmpty();
  }

  @Override
  public final int getCount() {
    return tabs.size();
  }

  @NonNull
  @Override
  public final Tab getTab(final int index) {
    return tabs.get(index);
  }

  @Override
  public final int indexOf(@NonNull final Tab tab) {
    ensureNotNull(tab, "The tab may not be null");
    return tabs.indexOf(tab);
  }

  @Override
  public final void addTab(@NonNull Tab tab) {
    addTab(tab, getCount());
  }

  @Override
  public final void addTab(@NonNull final Tab tab, final int index) {
    addTab(tab, index, new SwipeAnimation.Builder().create());
  }

  @Override
  public final void addTab(@NonNull final Tab tab, final int index,
                           @NonNull final Animation animation) {
    ensureNotNull(tab, "The tab may not be null");
    ensureNotNull(animation, "The animation may not be null");
    tabs.add(index, tab);
    int previousSelectedTabIndex = getSelectedTabIndex();
    int selectedTabIndex = previousSelectedTabIndex;
    boolean switcherVisibilityChanged = false;

    if (previousSelectedTabIndex == -1) {
      selectedTab = tab;
      selectedTabIndex = index;
    }

    if (animation instanceof RevealAnimation) {
      selectedTab = tab;
      selectedTabIndex = index;
      switcherVisibilityChanged = setSwitcherShown(false);
    }

    if (animation instanceof PeekAnimation) {
      switcherVisibilityChanged = setSwitcherShown(true);
    }

    notifyOnTabAdded(index, tab, previousSelectedTabIndex, selectedTabIndex,
      switcherVisibilityChanged, animation);
  }

  @Override
  public final void addAllTabs(@NonNull final Collection<? extends Tab> tabs) {
    addAllTabs(tabs, getCount());
  }

  @Override
  public final void addAllTabs(@NonNull final Collection<? extends Tab> tabs, final int index) {
    addAllTabs(tabs, index, new SwipeAnimation.Builder().create());
  }

  @Override
  public final void addAllTabs(@NonNull final Collection<? extends Tab> tabs, final int index,
                               @NonNull final Animation animation) {
    ensureNotNull(tabs, "The collection may not be null");
    Tab[] array = new Tab[tabs.size()];
    tabs.toArray(array);
    addAllTabs(array, index, animation);
  }

  @Override
  public final void addAllTabs(@NonNull final Tab[] tabs) {
    addAllTabs(tabs, getCount());
  }

  @Override
  public final void addAllTabs(@NonNull final Tab[] tabs, final int index) {
    addAllTabs(tabs, index, new SwipeAnimation.Builder().create());
  }

  @Override
  public final void addAllTabs(@NonNull final Tab[] tabs, final int index,
                               @NonNull final Animation animation) {
    ensureNotNull(tabs, "The array may not be null");
    ensureNotNull(animation, "The animation may not be null");

    if (tabs.length > 0) {
      int previousSelectedTabIndex = getSelectedTabIndex();
      int selectedTabIndex = previousSelectedTabIndex;

      for (int i = 0; i < tabs.length; i++) {
        Tab tab = tabs[i];
        this.tabs.add(index + i, tab);
      }

      if (previousSelectedTabIndex == -1) {
        selectedTabIndex = 0;
        selectedTab = tabs[selectedTabIndex];
      }

      notifyOnAllTabsAdded(index, tabs, previousSelectedTabIndex, selectedTabIndex,
        animation);
    }
  }

  @Override
  public final void removeTab(@NonNull final Tab tab) {
    removeTab(tab, new SwipeAnimation.Builder().create());
  }

  @Override
  public final void removeTab(@NonNull final Tab tab, @NonNull final Animation animation) {
    ensureNotNull(tab, "The tab may not be null");
    ensureNotNull(animation, "The animation may not be null");
    int index = indexOfOrThrowException(tab);
    int previousSelectedTabIndex = getSelectedTabIndex();
    int selectedTabIndex = previousSelectedTabIndex;
    tabs.remove(index);

    if (isEmpty()) {
      selectedTabIndex = -1;
      selectedTab = null;
    } else if (index == previousSelectedTabIndex) {
      if (index > 0) {
        selectedTabIndex = index - 1;
      }

      selectedTab = getTab(selectedTabIndex);
    }

    notifyOnTabRemoved(index, tab, previousSelectedTabIndex, selectedTabIndex, animation);

  }

  @Override
  public final void clear() {
    clear(new SwipeAnimation.Builder().create());
  }

  @Override
  public final void clear(@NonNull final Animation animation) {
    ensureNotNull(animation, "The animation may not be null");
    Tab[] result = new Tab[tabs.size()];
    tabs.toArray(result);
    tabs.clear();
    notifyOnAllTabsRemoved(result, animation);
    selectedTab = null;
  }

  @Override
  public final boolean isSwitcherShown() {
    return switcherShown;
  }

  @Override
  public final void showSwitcher() {
    setSwitcherShown(true);
    notifyOnSwitcherShown();
  }

  @Override
  public final void hideSwitcher() {
    setSwitcherShown(false);
    notifyOnSwitcherHidden();
  }

  @Override
  public final void toggleSwitcherVisibility() {
    if (isSwitcherShown()) {
      hideSwitcher();
    } else {
      showSwitcher();
    }
  }

  @Nullable
  @Override
  public final Tab getSelectedTab() {
    return selectedTab;
  }

  @Override
  public final int getSelectedTabIndex() {
    return selectedTab != null ? indexOf(selectedTab) : -1;
  }

  @Override
  public final void selectTab(@NonNull final Tab tab) {
    ensureNotNull(tab, "The tab may not be null");
    int previousIndex = getSelectedTabIndex();
    int index = indexOfOrThrowException(tab);
    selectedTab = tab;
    boolean switcherHidden = setSwitcherShown(false);
    notifyOnSelectionChanged(previousIndex, index, tab, switcherHidden);
  }

  @Override
  public final Iterator<Tab> iterator() {
    return tabs.iterator();
  }

  @Override
  public final void setPadding(final int left, final int top, final int right, final int bottom) {
    padding = new int[]{left, top, right, bottom};
    notifyOnPaddingChanged(left, top, right, bottom);
  }

  @Override
  public final int getPaddingLeft() {
    return padding[0];
  }

  @Override
  public final int getPaddingTop() {
    return padding[1];
  }

  @Override
  public final int getPaddingRight() {
    return padding[2];
  }

  @Override
  public final int getPaddingBottom() {
    return padding[3];
  }

  @Override
  public final int getPaddingStart() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
      return tabSwitcher.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL ?
        getPaddingRight() : getPaddingLeft();
    }

    return getPaddingLeft();
  }

  @Override
  public final int getPaddingEnd() {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {
      return tabSwitcher.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL ?
        getPaddingLeft() : getPaddingRight();
    }

    return getPaddingRight();
  }

  @Nullable
  @Override
  public final Drawable getTabIcon() {
    if (tabIconId != -1) {
      return ContextCompat.getDrawable(getContext(), tabIconId);
    } else {
      return tabIconBitmap != null ?
        new BitmapDrawable(getContext().getResources(), tabIconBitmap) : null;
    }
  }

  @Override
  public final void setTabIcon(@DrawableRes final int resourceId) {
    this.tabIconId = resourceId;
    this.tabIconBitmap = null;
    notifyOnTabIconChanged(getTabIcon());
  }

  @Override
  public final void setTabIcon(@Nullable final Bitmap icon) {
    this.tabIconId = -1;
    this.tabIconBitmap = icon;
    notifyOnTabIconChanged(getTabIcon());
  }

  @Nullable
  @Override
  public final ColorStateList getTabBackgroundColor() {
    return tabBackgroundColor;
  }

  @Override
  public final void setTabBackgroundColor(@ColorInt final int color) {
    setTabBackgroundColor(color != -1 ? ColorStateList.valueOf(color) : null);
  }

  @Override
  public final void setTabBackgroundColor(@Nullable final ColorStateList colorStateList) {
    this.tabBackgroundColor = colorStateList;
    notifyOnTabBackgroundColorChanged(colorStateList);
  }

  @Nullable
  @Override
  public final ColorStateList getTabTitleTextColor() {
    return tabTitleTextColor;
  }

  @Override
  public final void setTabTitleTextColor(@ColorInt final int color) {
    setTabTitleTextColor(color != -1 ? ColorStateList.valueOf(color) : null);
  }

  @Override
  public final void setTabTitleTextColor(@Nullable final ColorStateList colorStateList) {
    this.tabTitleTextColor = colorStateList;
    notifyOnTabTitleColorChanged(colorStateList);
  }

  @Nullable
  @Override
  public final Drawable getTabCloseButtonIcon() {
    if (tabCloseButtonIconId != -1) {
      return ContextCompat.getDrawable(getContext(), tabCloseButtonIconId);
    } else {
      return tabCloseButtonIconBitmap != null ?
        new BitmapDrawable(getContext().getResources(), tabCloseButtonIconBitmap) :
        null;
    }
  }

  @Override
  public final void setTabCloseButtonIcon(@DrawableRes final int resourceId) {
    tabCloseButtonIconId = resourceId;
    tabCloseButtonIconBitmap = null;
    notifyOnTabCloseButtonIconChanged(getTabCloseButtonIcon());
  }

  @Override
  public final void setTabCloseButtonIcon(@Nullable final Bitmap icon) {
    tabCloseButtonIconId = -1;
    tabCloseButtonIconBitmap = icon;
    notifyOnTabCloseButtonIconChanged(getTabCloseButtonIcon());
  }

  @Override
  public final boolean areToolbarsShown() {
    return showToolbars;
  }

  @Override
  public final void showToolbars(final boolean show) {
    this.showToolbars = show;
    notifyOnToolbarVisibilityChanged(show);
  }

  @Nullable
  @Override
  public final CharSequence getToolbarTitle() {
    return toolbarTitle;
  }

  @Override
  public void setToolbarTitle(@StringRes final int resourceId) {
    setToolbarTitle(getContext().getText(resourceId));
  }

  @Override
  public final void setToolbarTitle(@Nullable final CharSequence title) {
    this.toolbarTitle = title;
    notifyOnToolbarTitleChanged(title);
  }

  @Nullable
  @Override
  public final Drawable getToolbarNavigationIcon() {
    return toolbarNavigationIcon;
  }

  @Override
  public final void setToolbarNavigationIcon(@DrawableRes final int resourceId,
                                             @Nullable final OnClickListener listener) {
    setToolbarNavigationIcon(ContextCompat.getDrawable(getContext(), resourceId), listener);
  }

  @Override
  public final void setToolbarNavigationIcon(@Nullable final Drawable icon,
                                             @Nullable final OnClickListener listener) {
    this.toolbarNavigationIcon = icon;
    this.toolbarNavigationIconListener = listener;
    notifyOnToolbarNavigationIconChanged(icon, listener);
  }

  @Override
  public final void inflateToolbarMenu(@MenuRes final int resourceId,
                                       @Nullable final OnMenuItemClickListener listener) {
    this.toolbarMenuId = resourceId;
    this.toolbarMenuItemListener = listener;
    notifyOnToolbarMenuInflated(resourceId, listener);
  }

  @Override
  public final void addCloseTabListener(@NonNull final TabCloseListener listener) {
    ensureNotNull(listener, "The listener may not be null");
    tabCloseListeners.add(listener);
  }

  @Override
  public final void removeCloseTabListener(@NonNull final TabCloseListener listener) {
    ensureNotNull(listener, "The listener may not be null");
    tabCloseListeners.remove(listener);
  }

  @Override
  public final void addTabPreviewListener(@NonNull final TabPreviewListener listener) {
    ensureNotNull(listener, "The listener may not be null");
    tabPreviewListeners.add(listener);
  }

  @Override
  public final void removeTabPreviewListener(@NonNull final TabPreviewListener listener) {
    ensureNotNull(listener, "The listener may not be null");
    tabPreviewListeners.remove(listener);
  }

  @Override
  public final void saveInstanceState(@NonNull final Bundle outState) {
    outState.putSerializable(LOG_LEVEL_EXTRA, logLevel);
    outState.putParcelableArrayList(TABS_EXTRA, tabs);
    outState.putBoolean(SWITCHER_SHOWN_EXTRA, switcherShown);
    outState.putParcelable(SELECTED_TAB_EXTRA, selectedTab);
    outState.putIntArray(PADDING_EXTRA, padding);
    outState.putInt(TAB_ICON_ID_EXTRA, tabIconId);
    outState.putParcelable(TAB_ICON_BITMAP_EXTRA, tabIconBitmap);
    outState.putParcelable(TAB_BACKGROUND_COLOR_EXTRA, tabBackgroundColor);
    outState.putParcelable(TAB_TITLE_TEXT_COLOR_EXTRA, tabTitleTextColor);
    outState.putInt(TAB_CLOSE_BUTTON_ICON_ID_EXTRA, tabCloseButtonIconId);
    outState.putParcelable(TAB_CLOSE_BUTTON_ICON_BITMAP_EXTRA, tabCloseButtonIconBitmap);
    outState.putBoolean(SHOW_TOOLBARS_EXTRA, showToolbars);
    outState.putCharSequence(TOOLBAR_TITLE_EXTRA, toolbarTitle);
    childRecyclerAdapter.saveInstanceState(outState);
  }

  @Override
  public final void restoreInstanceState(@Nullable final Bundle savedInstanceState) {
    if (savedInstanceState != null) {
      firstVisibleTabIndex = savedInstanceState.getInt(FIRST_VISIBLE_TAB_INDEX_EXTRA, -1);
      firstVisibleTabPosition =
        savedInstanceState.getFloat(FIRST_VISIBLE_TAB_POSITION_EXTRA, -1);
      logLevel = (LogLevel) savedInstanceState.getSerializable(LOG_LEVEL_EXTRA);
      tabs = savedInstanceState.getParcelableArrayList(TABS_EXTRA);
      switcherShown = savedInstanceState.getBoolean(SWITCHER_SHOWN_EXTRA);
      selectedTab = savedInstanceState.getParcelable(SELECTED_TAB_EXTRA);
      padding = savedInstanceState.getIntArray(PADDING_EXTRA);
      tabIconId = savedInstanceState.getInt(TAB_ICON_ID_EXTRA);
      tabIconBitmap = savedInstanceState.getParcelable(TAB_ICON_BITMAP_EXTRA);
      tabBackgroundColor = savedInstanceState.getParcelable(TAB_BACKGROUND_COLOR_EXTRA);
      tabTitleTextColor = savedInstanceState.getParcelable(TAB_TITLE_TEXT_COLOR_EXTRA);
      tabCloseButtonIconId = savedInstanceState.getInt(TAB_CLOSE_BUTTON_ICON_ID_EXTRA);
      tabCloseButtonIconBitmap =
        savedInstanceState.getParcelable(TAB_CLOSE_BUTTON_ICON_BITMAP_EXTRA);
      showToolbars = savedInstanceState.getBoolean(SHOW_TOOLBARS_EXTRA);
      toolbarTitle = savedInstanceState.getCharSequence(TOOLBAR_TITLE_EXTRA);
      childRecyclerAdapter.restoreInstanceState(savedInstanceState);
    }
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/model/Tag.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.model;

import androidx.annotation.NonNull;
import de.mrapp.android.tabswitcher.TabSwitcher;

import static de.mrapp.android.util.Condition.ensureNotNull;

/**
 * A tag, which allows to store the properties of the tabs of a {@link TabSwitcher}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class Tag implements Cloneable {

  /**
   * The position of the tab on the dragging axis.
   */
  private float position;

  /**
   * The state of the tab.
   */
  private State state;

  /**
   * True, if the tab is currently being closed, false otherwise
   */
  private boolean closing;

  /**
   * Creates a new tag, which allows to store the properties of the tabs of a {@link
   * TabSwitcher}.
   */
  public Tag() {
    setPosition(Float.NaN);
    setState(State.HIDDEN);
    setClosing(false);
  }

  /**
   * Returns the position of the tab on the dragging axis.
   *
   * @return The position of the tab as a {@link Float} value
   */
  public final float getPosition() {
    return position;
  }

  /**
   * Sets the position of the tab on the dragging axis.
   *
   * @param position The position, which should be set, as a {@link Float} value
   */
  public final void setPosition(final float position) {
    this.position = position;
  }

  /**
   * Returns the state of the tab.
   *
   * @return The state of the tab as a value of the enum {@link State}. The state may not be null
   */
  @NonNull
  public final State getState() {
    return state;
  }

  /**
   * Sets the state of the tab.
   *
   * @param state The state, which should be set, as a value of the enum {@link State}. The state may
   *              not be null
   */
  public final void setState(@NonNull final State state) {
    ensureNotNull(state, "The state may not be null");
    this.state = state;
  }

  /**
   * Returns, whether the tab is currently being closed, or not.
   *
   * @return True, if the tab is currently being closed, false otherwise
   */
  public final boolean isClosing() {
    return closing;
  }

  /**
   * Sets, whether the tab is currently being closed, or not.
   *
   * @param closing True, if the tab is currently being closed, false otherwise
   */
  public final void setClosing(final boolean closing) {
    this.closing = closing;
  }

  @Override
  public final Tag clone() {
    Tag clone;

    try {
      clone = (Tag) super.clone();
    } catch (ClassCastException | CloneNotSupportedException e) {
      clone = new Tag();
    }

    clone.position = position;
    clone.state = state;
    clone.closing = closing;
    return clone;
  }

}
```

`chrome-tabs/src/main/java/de/mrapp/android/tabswitcher/view/TabSwitcherButton.java`:

```java
/*
 * Copyright 2016 - 2017 Michael Rapp
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 */
package de.mrapp.android.tabswitcher.view;

import android.content.Context;
import android.util.AttributeSet;
import androidx.annotation.AttrRes;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import androidx.appcompat.widget.AppCompatImageButton;
import de.mrapp.android.tabswitcher.*;
import de.mrapp.android.tabswitcher.drawable.TabSwitcherDrawable;
import de.mrapp.android.util.ThemeUtil;
import de.mrapp.android.util.ViewUtil;

/**
 * An image button, which allows to display the number of tabs, which are currently contained by a
 * {@link TabSwitcher} by using a {@link TabSwitcherDrawable}. It must be registered at a {@link
 * TabSwitcher} instance in order to keep the displayed count up to date. It therefore implements
 * the interface {@link TabSwitcherListener}.
 *
 * @author Michael Rapp
 * @since 0.1.0
 */
public class TabSwitcherButton extends AppCompatImageButton implements TabSwitcherListener {

  /**
   * The drawable, which is used by the image button.
   */
  private TabSwitcherDrawable drawable;

  /**
   * Initializes the view.
   */
  private void initialize() {
    drawable = new TabSwitcherDrawable(getContext());
    setImageDrawable(drawable);
    ViewUtil.setBackground(this,
      ThemeUtil.getDrawable(getContext(), R.attr.selectableItemBackgroundBorderless));
    setContentDescription(null);
    setClickable(true);
    setFocusable(true);
  }

  /**
   * Creates a new image button, which allows to display the number of tabs, which are currently
   * contained by a {@link TabSwitcher}.
   *
   * @param context The context, which should be used by the view, as an instance of the class {@link
   *                Context}. The context may not be null
   */
  public TabSwitcherButton(@NonNull final Context context) {
    this(context, null);
  }

  /**
   * Creates a new image button, which allows to display the number of tabs, which are currently
   * contained by a {@link TabSwitcher}.
   *
   * @param context      The context, which should be used by the view, as an instance of the class {@link
   *                     Context}. The context may not be null
   * @param attributeSet The attribute set, the view's attributes should be obtained from, as an instance of
   *                     the type {@link AttributeSet} or null, if no attributes should be obtained
   */
  public TabSwitcherButton(@NonNull final Context context,
                           @Nullable final AttributeSet attributeSet) {
    super(context, attributeSet);
    initialize();
  }

  /**
   * Creates a new image button, which allows to display the number of tabs, which are currently
   * contained by a {@link TabSwitcher}.
   *
   * @param context      The context, which should be used by the view, as an instance of the class {@link
   *                     Context}. The context may not be null
   * @param attributeSet The attribute set, the view's attributes should be obtained from, as an instance of
   *                     the type {@link AttributeSet} or null, if no attributes should be obtained
   * @param defaultStyle The default style to apply to this view. If 0, no style will be applied (beyond what
   *                     is included in the theme). This may either be an attribute resource, whose value will
   *                     be retrieved from the current theme, or an explicit style resource
   */
  public TabSwitcherButton(@NonNull final Context context,
                           @Nullable final AttributeSet attributeSet,
                           @AttrRes final int defaultStyle) {
    super(context, attributeSet, defaultStyle);
    initialize();
  }

  /**
   * Updates the image button to display a specific value.
   *
   * @param count The value, which should be displayed, as an {@link Integer} value. The value must be
   *              at least 0
   */
  public final void setCount(final int count) {
    drawable.setCount(count);
  }

  @Override
  public final void onSwitcherShown(@NonNull final TabSwitcher tabSwitcher) {
    drawable.onSwitcherShown(tabSwitcher);
  }

  @Override
  public final void onSwitcherHidden(@NonNull final TabSwitcher tabSwitcher) {
    drawable.onSwitcherHidden(tabSwitcher);
  }

  @Override
  public final void onSelectionChanged(@NonNull final TabSwitcher tabSwitcher,
                                       final int selectedTabIndex,
                                       @Nullable final Tab selectedTab) {
    drawable.onSelectionChanged(tabSwitcher, selectedTabIndex, selectedTab);
  }

  @Override
  public final void onTabAdded(@NonNull final TabSwitcher tabSwitcher, final int index,
                               @NonNull final Tab tab, @NonNull final Animation animation) {
    drawable.onTabAdded(tabSwitcher, index, tab, animation);
  }

  @Override
  public final void onTabRemoved(@NonNull final TabSwitcher tabSwitcher, final int index,
                                 @NonNull final Tab tab, @NonNull final Animation animation) {
    drawable.onTabRemoved(tabSwitcher, index, tab, animation);
  }

  @Override
  public final void onAllTabsRemoved(@NonNull final TabSwitcher tabSwitcher,
                                     @NonNull final Tab[] tabs,
                                     @NonNull final Animation animation) {
    drawable.onAllTabsRemoved(tabSwitcher, tabs, animation);
  }

}
```

`chrome-tabs/src/main/res/layout-land/phone_tab.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical">

  <LinearLayout
    android:id="@+id/tab_title_container"
    android:layout_width="match_parent"
    android:layout_height="@dimen/tab_title_container_height"
    android:orientation="horizontal">

    <ImageButton
      android:id="@+id/close_tab_button"
      android:layout_width="@dimen/tab_title_container_height"
      android:layout_height="match_parent"
      android:layout_gravity="center_vertical"
      android:background="?attr/selectableItemBackgroundBorderless"
      android:contentDescription="@null"
      app:srcCompat="@drawable/phone_close_tab_icon"/>

    <TextView
      android:id="@+id/tab_title_text_view"
      style="@style/Tab.Title"
      android:layout_width="0dp"
      android:layout_height="wrap_content"
      android:layout_gravity="center_vertical"
      android:layout_weight="1"
      android:paddingLeft="@dimen/tab_title_padding"
      android:paddingRight="@dimen/tab_title_padding"/>

  </LinearLayout>

  <FrameLayout
    android:id="@+id/child_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?android:attr/windowBackground">

    <ImageView
      android:id="@+id/preview_image_view"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:contentDescription="@null"
      android:scaleType="matrix"
      android:visibility="gone"/>

    <View
      android:id="@+id/border_view"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:visibility="gone"/>

  </FrameLayout>

</LinearLayout>
```

`chrome-tabs/src/main/res/layout/phone_tab.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<LinearLayout
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  android:layout_width="match_parent"
  android:layout_height="match_parent"
  android:orientation="vertical">

  <LinearLayout
    android:id="@+id/tab_title_container"
    android:layout_width="match_parent"
    android:layout_height="@dimen/tab_title_container_height"
    android:orientation="horizontal">

    <TextView
      android:id="@+id/tab_title_text_view"
      style="@style/Tab.Title"
      android:layout_width="0dp"
      android:layout_height="wrap_content"
      android:layout_gravity="center_vertical"
      android:layout_weight="1"
      android:paddingLeft="@dimen/tab_title_padding"
      android:paddingRight="@dimen/tab_title_padding"/>

    <ImageButton
      android:id="@+id/close_tab_button"
      android:layout_width="@dimen/tab_title_container_height"
      android:layout_height="match_parent"
      android:layout_gravity="center_vertical"
      android:background="?attr/selectableItemBackgroundBorderless"
      android:contentDescription="@null"
      app:srcCompat="@drawable/phone_close_tab_icon"/>

  </LinearLayout>

  <FrameLayout
    android:id="@+id/child_container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="?android:attr/windowBackground">

    <ImageView
      android:id="@+id/preview_image_view"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:contentDescription="@null"
      android:scaleType="matrix"
      android:visibility="gone"/>

    <View
      android:id="@+id/border_view"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      android:visibility="gone"/>

  </FrameLayout>

</LinearLayout>
```

`chrome-tabs/src/main/res/layout/phone_toolbar.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<androidx.appcompat.widget.Toolbar
  android:id="@+id/primary_toolbar"
  xmlns:android="http://schemas.android.com/apk/res/android"
  xmlns:app="http://schemas.android.com/apk/res-auto"
  android:layout_width="match_parent"
  android:layout_height="?attr/actionBarSize"
  android:background="@android:color/transparent"
  android:theme="@style/ThemeOverlay.AppCompat.Dark"
  android:visibility="invisible"
  app:popupTheme="@style/ThemeOverlay.AppCompat.Light"/>
```

`chrome-tabs/src/main/res/layout/tab_switcher_menu_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<de.mrapp.android.tabswitcher.view.TabSwitcherButton
  xmlns:android="http://schemas.android.com/apk/res/android"
  android:layout_width="@dimen/tab_switcher_drawable_size"
  android:layout_height="@dimen/tab_switcher_drawable_size"/>
```

`chrome-tabs/src/main/res/values-v21/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<resources>

  <style name="Tab.Title" parent="@style/TextAppearance.AppCompat.Small">
    <item name="android:drawablePadding">@dimen/tab_title_drawable_padding</item>
    <item name="android:ellipsize">marquee</item>
    <item name="android:maxLines">1</item>
    <item name="fontFamily">sans-serif-medium</item>
    <item name="android:textColor">@color/tab_title_text_color</item>
  </style>

</resources>
```

`chrome-tabs/src/main/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<resources>

  <declare-styleable name="TabSwitcher">
    <attr name="android:background"/>
    <attr name="layoutPolicy" format="enum">
      <enum name="auto" value="0"/>
      <enum name="phone" value="1"/>
      <enum name="tablet" value="2"/>
    </attr>
    <attr name="tabIcon" format="reference"/>
    <attr name="tabBackgroundColor" format="color"/>
    <attr name="tabTitleTextColor" format="color"/>
    <attr name="tabCloseButtonIcon" format="reference"/>
    <attr name="toolbarTitle" format="string"/>
    <attr name="toolbarMenu" format="reference"/>
    <attr name="toolbarNavigationIcon" format="reference"/>
  </declare-styleable>

</resources>
```

`chrome-tabs/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<resources>

  <color name="tab_switcher_background_color">#ff14181c</color>
  <color name="tab_background_color">#fff2f2f2</color>
  <color name="tab_title_text_color">#a8000000</color>

</resources>
```

`chrome-tabs/src/main/res/values/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<resources>

  <dimen name="tab_inset">16dp</dimen>
  <dimen name="tab_border_width">4dp</dimen>
  <dimen name="tab_title_container_height">48dp</dimen>
  <dimen name="tab_title_padding">12dp</dimen>
  <dimen name="tab_title_drawable_padding">8dp</dimen>
  <dimen name="end_overshoot_pivot">128dp</dimen>
  <dimen name="stacked_tab_spacing">4dp</dimen>
  <dimen name="max_overshoot_distance">48dp</dimen>
  <dimen name="max_camera_distance">1280dp</dimen>
  <dimen name="min_swipe_velocity">2048dp</dimen>
  <dimen name="drag_threshold">8dp</dimen>
  <dimen name="swipe_threshold">24dp</dimen>
  <dimen name="tab_switcher_drawable_size">32dp</dimen>
  <dimen name="tab_switcher_drawable_font_size_normal">10sp</dimen>
  <dimen name="tab_switcher_drawable_font_size_small">7sp</dimen>
  <item name="swiped_tab_scale" format="float" type="dimen">0.5</item>
  <item name="swiped_tab_alpha" format="float" type="dimen">0</item>

</resources>
```

`chrome-tabs/src/main/res/values/ids.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<resources>

  <item name="tag_view_holder" type="id"/>
  <item name="tag_properties" type="id"/>

</resources>
```

`chrome-tabs/src/main/res/values/integers.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<resources>

  <integer name="stacked_tab_count">3</integer>
  <integer name="max_start_overshoot_angle">2</integer>
  <integer name="max_end_overshoot_angle">3</integer>
  <integer name="show_switcher_animation_duration">@android:integer/config_shortAnimTime</integer>
  <integer name="hide_switcher_animation_duration">@android:integer/config_shortAnimTime</integer>
  <integer name="toolbar_visibility_animation_duration">@android:integer/config_mediumAnimTime</integer>
  <integer name="toolbar_visibility_animation_delay">@android:integer/config_shortAnimTime</integer>
  <integer name="swipe_animation_duration">@android:integer/config_longAnimTime</integer>
  <integer name="clear_animation_delay">@android:integer/config_shortAnimTime</integer>
  <integer name="relocate_animation_duration">@android:integer/config_mediumAnimTime</integer>
  <integer name="relocate_animation_delay">@android:integer/config_shortAnimTime</integer>
  <integer name="revert_overshoot_animation_duration">@android:integer/config_shortAnimTime</integer>
  <integer name="reveal_animation_duration">@android:integer/config_shortAnimTime</integer>
  <integer name="peek_animation_duration">1200</integer>

</resources>
```

`chrome-tabs/src/main/res/values/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<!--
Copyright 2016 - 2017 Michael Rapp

Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in
compliance with the License. You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is
distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
implied. See the License for the specific language governing permissions and limitations under the
License.
-->
<resources>

  <style name="Tab.Title" parent="@style/TextAppearance.AppCompat.Small">
    <item name="android:drawablePadding">@dimen/tab_title_drawable_padding</item>
    <item name="android:ellipsize">marquee</item>
    <item name="android:maxLines">1</item>
    <item name="android:textStyle">normal</item>
    <item name="android:textColor">@color/tab_title_text_color</item>
  </style>

</resources>
```

`gradle.properties`:

```properties
# Project-wide Gradle settings.
# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.
# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html
# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
android.enableJetifier=true
android.useAndroidX=true
org.gradle.jvmargs=-Xmx1536m
# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
#Tue Apr 20 22:03:06 EEST 2021
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.0-bin.zip

```

`gradlew`:

```
#!/usr/bin/env bash

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT executablePath
if "%OS%"=="Windows_NT" setlocal

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windowz variants

if not "%OS%" == "Windows_NT" goto win9xME_args
if "%@eval[2+2]" == "4" goto 4NT_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*
goto execute

:4NT_args
@rem Get arguments from the 4NT Shell from JP Software
set CMD_LINE_ARGS=%$

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT executablePath
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
include ':app', ':chrome-tabs', ':NeoLang', ':Xorg', ':NeoTermBridge'

```