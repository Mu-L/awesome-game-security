Project Path: arc_pgp_XFiles_c_pq0t9o

Source Tree:

```txt
arc_pgp_XFiles_c_pq0t9o
├── LICENSE
├── LICENSE_UNRAR
├── README.md
├── app
│   ├── build.gradle
│   ├── dictionary.txt
│   ├── proguard-rules.pro
│   └── src
│       └── main
│           ├── AndroidManifest.xml
│           ├── java
│           │   ├── com
│           │   │   ├── davemorrissey
│           │   │   │   └── labs
│           │   │   │       └── subscaleview
│           │   │   │           ├── ImageSource.java
│           │   │   │           ├── ImageViewState.java
│           │   │   │           ├── SubsamplingScaleImageView.java
│           │   │   │           └── decoder
│           │   │   │               ├── CompatDecoderFactory.java
│           │   │   │               ├── DecoderFactory.java
│           │   │   │               ├── ImageDecoder.java
│           │   │   │               ├── ImageRegionDecoder.java
│           │   │   │               ├── SkiaImageDecoder.java
│           │   │   │               ├── SkiaImageRegionDecoder.java
│           │   │   │               └── SkiaPooledImageRegionDecoder.java
│           │   │   └── tomclaw
│           │   │       └── imageloader
│           │   │           ├── SimpleImageLoader.java
│           │   │           ├── core
│           │   │           │   ├── Decoder.java
│           │   │           │   ├── DiskCache.java
│           │   │           │   ├── DiskCacheImpl.java
│           │   │           │   ├── FileProvider.java
│           │   │           │   ├── FileProviderImpl.java
│           │   │           │   ├── Handlers.java
│           │   │           │   ├── ImageLoader.java
│           │   │           │   ├── ImageLoaderImpl.java
│           │   │           │   ├── Loader.java
│           │   │           │   ├── MainExecutorImpl.java
│           │   │           │   ├── MemoryCache.java
│           │   │           │   ├── MemoryCacheImpl.java
│           │   │           │   ├── Result.java
│           │   │           │   ├── ViewHolder.java
│           │   │           │   └── ViewSize.java
│           │   │           └── util
│           │   │               ├── BitmapDecoder.java
│           │   │               ├── ImageViewHandlers.java
│           │   │               ├── ImageViewHolder.java
│           │   │               ├── ImageViews.java
│           │   │               └── loader
│           │   │                   ├── ContentLoader.java
│           │   │                   ├── FileLoader.java
│           │   │                   └── UrlLoader.java
│           │   └── it
│           │       └── pgp
│           │           ├── Native.java
│           │           └── xfiles
│           │               ├── BrowserItem.java
│           │               ├── BrowserViewPager.java
│           │               ├── CopyListUris.java
│           │               ├── CopyMoveListPathContent.java
│           │               ├── EffectActivity.java
│           │               ├── FavoritesActivity.java
│           │               ├── FindActivity.java
│           │               ├── GalleryViewPager.java
│           │               ├── MainActivity.java
│           │               ├── MediaGallery.java
│           │               ├── MediaGalleryActivity.java
│           │               ├── PermissionManagementActivity.java
│           │               ├── RestarterActivity.java
│           │               ├── SettingsLauncherActivity.java
│           │               ├── SortingItem.java
│           │               ├── SwipeRefreshLayoutChildCanScroll.java
│           │               ├── XREDirectShareActivity.java
│           │               ├── XRE_RHSS_Widget.java
│           │               ├── adapters
│           │               │   ├── BrowserAdapter.java
│           │               │   ├── BrowserGridAdapter.java
│           │               │   ├── BrowserListAdapter.java
│           │               │   ├── BrowserPagerAdapter.java
│           │               │   ├── ContinuousSelectionAdapter.java
│           │               │   ├── ExtendedSimpleAdapter.java
│           │               │   ├── ExtractResultsAdapter.java
│           │               │   ├── FavoritesPagerAdapter.java
│           │               │   ├── FindResultsAdapter.java
│           │               │   ├── GalleryPagerAdapter.java
│           │               │   ├── HashAlgorithmsAdapter.java
│           │               │   ├── HorizontalListAdapter.java
│           │               │   ├── LocalFavoritesAdapter.java
│           │               │   ├── OperationalPagerAdapter.java
│           │               │   ├── QuickPathsAdapter.java
│           │               │   ├── RecentPositionsAdapter.java
│           │               │   ├── SftpFavoritesAdapter.java
│           │               │   ├── SmbFavoritesAdapter.java
│           │               │   ├── XFilesRemoteEndpointAdapter.java
│           │               │   ├── XreAnnouncesAdapter.java
│           │               │   ├── XreFavoritesAdapter.java
│           │               │   └── continuousselection
│           │               │       ├── CSCheckboxes.java
│           │               │       ├── ContSelHandlingLayout.java
│           │               │       ├── ContSelListener.java
│           │               │       ├── ContSelListenerGrid.java
│           │               │       └── ContSelListenerList.java
│           │               ├── comparators
│           │               │   ├── AdvancedComparator.java
│           │               │   ├── AdvancedComparatorStrategy.java
│           │               │   └── FilenameComparator.java
│           │               ├── dialogs
│           │               │   ├── AdvancedSortingDialog.java
│           │               │   ├── BaseDialog.java
│           │               │   ├── BulkRenameDialog.java
│           │               │   ├── ChecksumActivity.java
│           │               │   ├── CloseActiveServersDialog.java
│           │               │   ├── ConflictDialog.java
│           │               │   ├── CreateFileOrDirectoryDialog.java
│           │               │   ├── CreateLinkDialog.java
│           │               │   ├── FilterSelectionDialog.java
│           │               │   ├── GenericChangeDirectoryDialog.java
│           │               │   ├── ImmersiveModeDialog.java
│           │               │   ├── InsertEditLocalFavoritesDialog.java
│           │               │   ├── InsertEditSftpFavoritesDialog.java
│           │               │   ├── InsertEditXreFavoritesDialog.java
│           │               │   ├── OpenAsDialog.java
│           │               │   ├── PropertiesDialog.java
│           │               │   ├── RamdiskDialog.java
│           │               │   ├── RemoteRHServerManagementDialog.java
│           │               │   ├── RenameDialog.java
│           │               │   ├── SSHAlreadyInKnownHostsDialog.java
│           │               │   ├── SSHKnownHostsBaseDialog.java
│           │               │   ├── SSHNotInKnownHostsDialog.java
│           │               │   ├── UpdateCheckDialog.java
│           │               │   ├── XFilesRemoteSessionsManagementActivity.java
│           │               │   └── compress
│           │               │       ├── AskPasswordDialogOnExtract.java
│           │               │       ├── AskPasswordDialogOnListing.java
│           │               │       ├── CompressActivity.java
│           │               │       └── ExtractActivity.java
│           │               ├── dragdroplist
│           │               │   ├── DragDropItemTouchHelperCallback.java
│           │               │   └── DragNDropAdapter.java
│           │               ├── enums
│           │               │   ├── ArchiveType.java
│           │               │   ├── BrowserViewMode.java
│           │               │   ├── ComparatorField.java
│           │               │   ├── CopyMoveMode.java
│           │               │   ├── FileIOMode.java
│           │               │   ├── FileMode.java
│           │               │   ├── FileOpsAction.java
│           │               │   ├── FileOpsErrorCodes.java
│           │               │   ├── ForegroundServiceType.java
│           │               │   ├── OutputArchiveType.java
│           │               │   ├── ProviderType.java
│           │               │   ├── ServiceStatus.java
│           │               │   ├── SshKeyType.java
│           │               │   ├── WIFI_AP_STATE.java
│           │               │   └── conflicthandling
│           │               │       ├── ConflictDecision.java
│           │               │       ├── ConflictType.java
│           │               │       └── ErrorDecision.java
│           │               ├── exceptions
│           │               │   ├── DirCommanderException.java
│           │               │   └── InterruptedTransferAsIOException.java
│           │               ├── fileservers
│           │               │   ├── FileServer.java
│           │               │   ├── HTTPSessionThread.java
│           │               │   ├── SimpleFTPServer.java
│           │               │   ├── SimpleFileServer.java
│           │               │   └── SimpleHTTPServer.java
│           │               ├── io
│           │               │   ├── FlushingBufferedOutputStream.java
│           │               │   ├── RobustLocalFileInputStream.java
│           │               │   └── RobustLocalFileOutputStream.java
│           │               ├── items
│           │               │   ├── BulkRenameItem.java
│           │               │   ├── FileCreationAdvancedOptions.java
│           │               │   ├── FolderStatsItem.java
│           │               │   ├── MultiStatsItem.java
│           │               │   └── SingleStatsItem.java
│           │               ├── roothelperclient
│           │               │   ├── ControlCodes.java
│           │               │   ├── FindInArchiveThread.java
│           │               │   ├── FindManager.java
│           │               │   ├── FindUpdatesThread.java
│           │               │   ├── HashRequestCodes.java
│           │               │   ├── RHSSServerStatus.java
│           │               │   ├── RelativeExtractEntries.java
│           │               │   ├── RemoteClientManager.java
│           │               │   ├── RemoteManager.java
│           │               │   ├── RemoteServerManager.java
│           │               │   ├── ResponseCodes.java
│           │               │   ├── RootHandler.java
│           │               │   ├── RootHelperClient.java
│           │               │   ├── StreamCiphers.java
│           │               │   ├── reqs
│           │               │   │   ├── BaseRHRequest.java
│           │               │   │   ├── ListOfPathPairs_rq.java
│           │               │   │   ├── PairOfPaths_rq.java
│           │               │   │   ├── SinglePath_rq.java
│           │               │   │   ├── compress_rq.java
│           │               │   │   ├── compress_rq_options.java
│           │               │   │   ├── copylist_rq.java
│           │               │   │   ├── create_rq.java
│           │               │   │   ├── del_rq.java
│           │               │   │   ├── exists_rq.java
│           │               │   │   ├── extract_rq.java
│           │               │   │   ├── fileio_rq.java
│           │               │   │   ├── find_rq.java
│           │               │   │   ├── hash_rq.java
│           │               │   │   ├── link_rq.java
│           │               │   │   ├── ls_archive_rq.java
│           │               │   │   ├── ls_rq.java
│           │               │   │   ├── movelist_rq.java
│           │               │   │   ├── multiStats_rq.java
│           │               │   │   ├── multi_extract_rq.java
│           │               │   │   ├── openssh_ed25519_keygen_rq.java
│           │               │   │   ├── openssl_rsa_pem_keygen_rq.java
│           │               │   │   ├── retrieveHomePath_rq.java
│           │               │   │   ├── setAttributes_rq.java
│           │               │   │   ├── setDates_rq.java
│           │               │   │   ├── setOwnership_rq.java
│           │               │   │   ├── setPermission_rq.java
│           │               │   │   ├── singleStats_rq.java
│           │               │   │   └── test_rq.java
│           │               │   └── resps
│           │               │       ├── exists_resp.java
│           │               │       ├── find_resp.java
│           │               │       ├── folderStats_resp.java
│           │               │       ├── ls_resp.java
│           │               │       ├── singleStats_resp.java
│           │               │       └── ssh_keygen_resp.java
│           │               ├── service
│           │               │   ├── BaseBackgroundService.java
│           │               │   ├── BaseBackgroundTask.java
│           │               │   ├── CompressService.java
│           │               │   ├── CompressTask.java
│           │               │   ├── CopyMoveService.java
│           │               │   ├── CopyMoveTask.java
│           │               │   ├── CreateFileService.java
│           │               │   ├── CreateFileTask.java
│           │               │   ├── ExtractService.java
│           │               │   ├── ExtractTask.java
│           │               │   ├── FindService.java
│           │               │   ├── FindTask.java
│           │               │   ├── HTTPDownloadService.java
│           │               │   ├── HTTPDownloadTask.java
│           │               │   ├── HTTPUploadService.java
│           │               │   ├── HTTPUploadTask.java
│           │               │   ├── IndeterminateAsyncTask.java
│           │               │   ├── NonInteractiveSftpService.java
│           │               │   ├── NonInteractiveSftpTask.java
│           │               │   ├── NonInteractiveSmbService.java
│           │               │   ├── NonInteractiveSmbTask.java
│           │               │   ├── NonInteractiveXFilesRemoteTransferService.java
│           │               │   ├── NonInteractiveXFilesRemoteTransferTask.java
│           │               │   ├── RootHelperClientTask.java
│           │               │   ├── SocketNames.java
│           │               │   ├── TestService.java
│           │               │   ├── params
│           │               │   │   ├── CompressParams.java
│           │               │   │   ├── CopyMoveParams.java
│           │               │   │   ├── CreateFileParams.java
│           │               │   │   ├── DownloadParams.java
│           │               │   │   ├── ExtractParams.java
│           │               │   │   ├── FindParams.java
│           │               │   │   └── TestParams.java
│           │               │   └── visualization
│           │               │       ├── MovingRibbon.java
│           │               │       ├── MovingRibbonTwoBars.java
│           │               │       ├── ProgressIndicator.java
│           │               │       ├── ViewOverlay.java
│           │               │       └── ViewType.java
│           │               ├── sftpclient
│           │               │   ├── AuthData.java
│           │               │   ├── CustomizedAndroidCipherSuiteConfig.java
│           │               │   ├── IdentitiesVaultAdapter.java
│           │               │   ├── InsertEditDialog.java
│           │               │   ├── InsertFailedException.java
│           │               │   ├── InteractiveHostKeyVerifier.java
│           │               │   ├── SFTPProvider.java
│           │               │   ├── SSHKeyInfoDialog.java
│           │               │   ├── SSHKeygenDialog.java
│           │               │   ├── VaultActivity.java
│           │               │   ├── VaultAdapter.java
│           │               │   ├── XFileSystemFile.java
│           │               │   ├── XProgress.java
│           │               │   ├── XSFTPClient.java
│           │               │   ├── XSFTPFileTransfer.java
│           │               │   ├── XSSHClient.java
│           │               │   └── XTransferListener.java
│           │               ├── smbclient
│           │               │   ├── SmbAuthData.java
│           │               │   ├── SmbProvider.java
│           │               │   ├── SmbVaultActivity.java
│           │               │   └── SmbVaultAdapter.java
│           │               ├── utils
│           │               │   ├── ArchiveVMap.java
│           │               │   ├── ArrayTextView.java
│           │               │   ├── BidirectionalMap.java
│           │               │   ├── CheckableSingleExecutor.java
│           │               │   ├── Checksums.java
│           │               │   ├── ContentProviderUtils.java
│           │               │   ├── DirCommander.java
│           │               │   ├── DirTreeWalker.java
│           │               │   ├── DirTreeWalkerRel.java
│           │               │   ├── DiskHelper.java
│           │               │   ├── FavoritesList.java
│           │               │   ├── FileOperationHelper.java
│           │               │   ├── FileSaveFragment.java
│           │               │   ├── FileSelectFragment.java
│           │               │   ├── GenericDBHelper.java
│           │               │   ├── GenericMRU.java
│           │               │   ├── HashView.java
│           │               │   ├── IntentUtil.java
│           │               │   ├── MRUArray.java
│           │               │   ├── Misc.java
│           │               │   ├── NetworkUtils.java
│           │               │   ├── Pair.java
│           │               │   ├── Predicate.java
│           │               │   ├── ProgressConflictHandler.java
│           │               │   ├── SelectImageButtonListener.java
│           │               │   ├── StreamsPair.java
│           │               │   ├── VMap.java
│           │               │   ├── XFilesUtils.java
│           │               │   ├── dircontent
│           │               │   │   ├── ArchiveSubDirWithContent.java
│           │               │   │   ├── GenericDirWithContent.java
│           │               │   │   ├── LocalDirWithContent.java
│           │               │   │   ├── SftpDirWithContent.java
│           │               │   │   ├── SmbDirWithContent.java
│           │               │   │   └── XFilesRemoteDirWithContent.java
│           │               │   ├── iterators
│           │               │   │   ├── VMapAbstractIterable.java
│           │               │   │   ├── VMapChildParentIterable.java
│           │               │   │   ├── VMapFullTreeIterable.java
│           │               │   │   └── VMapSubTreeIterable.java
│           │               │   ├── oreoap
│           │               │   │   ├── MyOnStartTetheringCallback.java
│           │               │   │   ├── MyOreoWifiManager.java
│           │               │   │   └── PreOreoWifiManager.java
│           │               │   ├── pathcontent
│           │               │   │   ├── ArchivePathContent.java
│           │               │   │   ├── BasePathContent.java
│           │               │   │   ├── LocalPathContent.java
│           │               │   │   ├── SFTPPathContent.java
│           │               │   │   ├── SMBPathContent.java
│           │               │   │   └── XREPathContent.java
│           │               │   ├── popupwindow
│           │               │   │   ├── MovablePopupWindowWithAutoClose.java
│           │               │   │   └── PopupWindowUtils.java
│           │               │   └── wifi
│           │               │       ├── OreoWifiAPManager.java
│           │               │       ├── WifiApManager.java
│           │               │       └── WifiButtonsLayout.java
│           │               └── viewmodels
│           │                   ├── PasteableEditText.java
│           │                   ├── TouchImageView.java
│           │                   └── XREDirectoryViewModel.java
│           └── res
│               ├── anim
│               │   ├── fade_in.xml
│               │   └── fade_out.xml
│               ├── drawable
│               │   ├── about_background.xml
│               │   ├── hashview_window_background.xml
│               │   ├── ic_image.xml
│               │   ├── ic_image_remove.xml
│               │   ├── media_gallery_placeholder.xml
│               │   ├── root_background.xml
│               │   └── xf_widget_thumbnail.png
│               ├── drawable-hdpi
│               │   ├── ic_notification_ime_default.png
│               │   ├── xf_arrow_left.png
│               │   ├── xf_arrow_right.png
│               │   ├── xf_copy.png
│               │   ├── xf_dir_blu.png
│               │   ├── xf_new_dir.png
│               │   ├── xf_new_file.png
│               │   ├── xf_recycle_bin.png
│               │   ├── xf_share.png
│               │   ├── xf_up_dir.png
│               │   ├── xf_view_mode.png
│               │   ├── xf_xre_server_down.png
│               │   ├── xf_xre_server_up.png
│               │   ├── xfiles_anytype.png
│               │   ├── xfiles_archive.png
│               │   ├── xfiles_archive_7z.png
│               │   ├── xfiles_archive_apk.png
│               │   ├── xfiles_archive_bz2.png
│               │   ├── xfiles_archive_cab.png
│               │   ├── xfiles_archive_gz.png
│               │   ├── xfiles_archive_rar.png
│               │   ├── xfiles_archive_tar.png
│               │   ├── xfiles_archive_xz.png
│               │   ├── xfiles_archive_zip.png
│               │   ├── xfiles_audio.png
│               │   ├── xfiles_cut.png
│               │   ├── xfiles_extract.png
│               │   ├── xfiles_favorites.png
│               │   ├── xfiles_file_icon.png
│               │   ├── xfiles_find.png
│               │   ├── xfiles_hotspot_off.png
│               │   ├── xfiles_hotspot_on.png
│               │   ├── xfiles_hotspot_unavailable.png
│               │   ├── xfiles_image.png
│               │   ├── xfiles_link_icon.png
│               │   ├── xfiles_new_app_icon.png
│               │   ├── xfiles_paste.png
│               │   ├── xfiles_root_off.png
│               │   ├── xfiles_root_on.png
│               │   ├── xfiles_sort_icon.png
│               │   ├── xfiles_sort_special.png
│               │   ├── xfiles_switch_operation_buttons_blue.png
│               │   ├── xfiles_switch_operation_buttons_green.png
│               │   ├── xfiles_system_back.png
│               │   ├── xfiles_system_home.png
│               │   ├── xfiles_system_recent.png
│               │   ├── xfiles_test.png
│               │   ├── xfiles_text.png
│               │   ├── xfiles_video.png
│               │   ├── xfiles_wifi_enabled_not_connected.png
│               │   ├── xfiles_wifi_off.png
│               │   ├── xfiles_wifi_on.png
│               │   └── xfiles_wifi_unavailable.png
│               ├── drawable-ldpi
│               │   ├── xf_arrow_left.png
│               │   ├── xf_arrow_right.png
│               │   ├── xf_copy.png
│               │   ├── xf_dir_blu.png
│               │   ├── xf_new_dir.png
│               │   ├── xf_new_file.png
│               │   ├── xf_recycle_bin.png
│               │   ├── xf_share.png
│               │   ├── xf_up_dir.png
│               │   ├── xf_view_mode.png
│               │   ├── xf_xre_server_down.png
│               │   ├── xf_xre_server_up.png
│               │   ├── xfiles_anytype.png
│               │   ├── xfiles_archive.png
│               │   ├── xfiles_archive_7z.png
│               │   ├── xfiles_archive_apk.png
│               │   ├── xfiles_archive_bz2.png
│               │   ├── xfiles_archive_cab.png
│               │   ├── xfiles_archive_gz.png
│               │   ├── xfiles_archive_rar.png
│               │   ├── xfiles_archive_tar.png
│               │   ├── xfiles_archive_xz.png
│               │   ├── xfiles_archive_zip.png
│               │   ├── xfiles_audio.png
│               │   ├── xfiles_cut.png
│               │   ├── xfiles_extract.png
│               │   ├── xfiles_favorites.png
│               │   ├── xfiles_file_icon.png
│               │   ├── xfiles_find.png
│               │   ├── xfiles_hotspot_off.png
│               │   ├── xfiles_hotspot_on.png
│               │   ├── xfiles_hotspot_unavailable.png
│               │   ├── xfiles_image.png
│               │   ├── xfiles_link_icon.png
│               │   ├── xfiles_new_app_icon.png
│               │   ├── xfiles_paste.png
│               │   ├── xfiles_root_off.png
│               │   ├── xfiles_root_on.png
│               │   ├── xfiles_switch_operation_buttons_blue.png
│               │   ├── xfiles_switch_operation_buttons_green.png
│               │   ├── xfiles_system_back.png
│               │   ├── xfiles_system_home.png
│               │   ├── xfiles_system_recent.png
│               │   ├── xfiles_test.png
│               │   ├── xfiles_text.png
│               │   ├── xfiles_video.png
│               │   ├── xfiles_wifi_enabled_not_connected.png
│               │   ├── xfiles_wifi_off.png
│               │   ├── xfiles_wifi_on.png
│               │   └── xfiles_wifi_unavailable.png
│               ├── drawable-mdpi
│               │   ├── ic_media_stop.png
│               │   ├── xf_arrow_left.png
│               │   ├── xf_arrow_right.png
│               │   ├── xf_copy.png
│               │   ├── xf_dir_blu.png
│               │   ├── xf_new_dir.png
│               │   ├── xf_new_file.png
│               │   ├── xf_recycle_bin.png
│               │   ├── xf_share.png
│               │   ├── xf_up_dir.png
│               │   ├── xf_view_mode.png
│               │   ├── xf_xre_server_down.png
│               │   ├── xf_xre_server_up.png
│               │   ├── xfiles_anytype.png
│               │   ├── xfiles_archive.png
│               │   ├── xfiles_archive_7z.png
│               │   ├── xfiles_archive_apk.png
│               │   ├── xfiles_archive_bz2.png
│               │   ├── xfiles_archive_cab.png
│               │   ├── xfiles_archive_gz.png
│               │   ├── xfiles_archive_rar.png
│               │   ├── xfiles_archive_tar.png
│               │   ├── xfiles_archive_xz.png
│               │   ├── xfiles_archive_zip.png
│               │   ├── xfiles_audio.png
│               │   ├── xfiles_cut.png
│               │   ├── xfiles_extract.png
│               │   ├── xfiles_favorites.png
│               │   ├── xfiles_file_icon.png
│               │   ├── xfiles_find.png
│               │   ├── xfiles_hotspot_off.png
│               │   ├── xfiles_hotspot_on.png
│               │   ├── xfiles_hotspot_unavailable.png
│               │   ├── xfiles_image.png
│               │   ├── xfiles_link_icon.png
│               │   ├── xfiles_new_app_icon.png
│               │   ├── xfiles_paste.png
│               │   ├── xfiles_root_off.png
│               │   ├── xfiles_root_on.png
│               │   ├── xfiles_sort_icon.png
│               │   ├── xfiles_sort_special.png
│               │   ├── xfiles_switch_operation_buttons_blue.png
│               │   ├── xfiles_switch_operation_buttons_green.png
│               │   ├── xfiles_system_back.png
│               │   ├── xfiles_system_home.png
│               │   ├── xfiles_system_recent.png
│               │   ├── xfiles_test.png
│               │   ├── xfiles_text.png
│               │   ├── xfiles_video.png
│               │   ├── xfiles_wifi_enabled_not_connected.png
│               │   ├── xfiles_wifi_off.png
│               │   ├── xfiles_wifi_on.png
│               │   └── xfiles_wifi_unavailable.png
│               ├── drawable-xhdpi
│               │   ├── xf_arrow_left.png
│               │   ├── xf_arrow_right.png
│               │   ├── xf_copy.png
│               │   ├── xf_dir_blu.png
│               │   ├── xf_new_dir.png
│               │   ├── xf_new_file.png
│               │   ├── xf_recycle_bin.png
│               │   ├── xf_share.png
│               │   ├── xf_up_dir.png
│               │   ├── xf_view_mode.png
│               │   ├── xf_xre_server_down.png
│               │   ├── xf_xre_server_up.png
│               │   ├── xfiles_anytype.png
│               │   ├── xfiles_archive.png
│               │   ├── xfiles_archive_7z.png
│               │   ├── xfiles_archive_apk.png
│               │   ├── xfiles_archive_bz2.png
│               │   ├── xfiles_archive_cab.png
│               │   ├── xfiles_archive_gz.png
│               │   ├── xfiles_archive_rar.png
│               │   ├── xfiles_archive_tar.png
│               │   ├── xfiles_archive_xz.png
│               │   ├── xfiles_archive_zip.png
│               │   ├── xfiles_audio.png
│               │   ├── xfiles_cut.png
│               │   ├── xfiles_extract.png
│               │   ├── xfiles_favorites.png
│               │   ├── xfiles_file_icon.png
│               │   ├── xfiles_find.png
│               │   ├── xfiles_hotspot_off.png
│               │   ├── xfiles_hotspot_on.png
│               │   ├── xfiles_hotspot_unavailable.png
│               │   ├── xfiles_image.png
│               │   ├── xfiles_link_icon.png
│               │   ├── xfiles_new_app_icon.png
│               │   ├── xfiles_paste.png
│               │   ├── xfiles_root_off.png
│               │   ├── xfiles_root_on.png
│               │   ├── xfiles_sort_icon.png
│               │   ├── xfiles_sort_special.png
│               │   ├── xfiles_switch_operation_buttons_blue.png
│               │   ├── xfiles_switch_operation_buttons_green.png
│               │   ├── xfiles_system_back.png
│               │   ├── xfiles_system_home.png
│               │   ├── xfiles_system_recent.png
│               │   ├── xfiles_test.png
│               │   ├── xfiles_text.png
│               │   ├── xfiles_video.png
│               │   ├── xfiles_wifi_enabled_not_connected.png
│               │   ├── xfiles_wifi_off.png
│               │   ├── xfiles_wifi_on.png
│               │   └── xfiles_wifi_unavailable.png
│               ├── drawable-xxhdpi
│               │   ├── xf_arrow_left.png
│               │   ├── xf_arrow_right.png
│               │   ├── xf_copy.png
│               │   ├── xf_dir_blu.png
│               │   ├── xf_new_dir.png
│               │   ├── xf_new_file.png
│               │   ├── xf_recycle_bin.png
│               │   ├── xf_share.png
│               │   ├── xf_up_dir.png
│               │   ├── xf_view_mode.png
│               │   ├── xf_xre_server_down.png
│               │   ├── xf_xre_server_up.png
│               │   ├── xfiles_anytype.png
│               │   ├── xfiles_archive.png
│               │   ├── xfiles_archive_7z.png
│               │   ├── xfiles_archive_apk.png
│               │   ├── xfiles_archive_bz2.png
│               │   ├── xfiles_archive_cab.png
│               │   ├── xfiles_archive_gz.png
│               │   ├── xfiles_archive_rar.png
│               │   ├── xfiles_archive_tar.png
│               │   ├── xfiles_archive_xz.png
│               │   ├── xfiles_archive_zip.png
│               │   ├── xfiles_audio.png
│               │   ├── xfiles_cut.png
│               │   ├── xfiles_extract.png
│               │   ├── xfiles_favorites.png
│               │   ├── xfiles_file_icon.png
│               │   ├── xfiles_hotspot_off.png
│               │   ├── xfiles_hotspot_on.png
│               │   ├── xfiles_hotspot_unavailable.png
│               │   ├── xfiles_image.png
│               │   ├── xfiles_link_icon.png
│               │   ├── xfiles_new_app_icon.png
│               │   ├── xfiles_root_off.png
│               │   ├── xfiles_root_on.png
│               │   ├── xfiles_sort_icon.png
│               │   ├── xfiles_sort_special.png
│               │   ├── xfiles_switch_operation_buttons_blue.png
│               │   ├── xfiles_switch_operation_buttons_green.png
│               │   ├── xfiles_system_back.png
│               │   ├── xfiles_system_home.png
│               │   ├── xfiles_system_recent.png
│               │   ├── xfiles_test.png
│               │   ├── xfiles_text.png
│               │   ├── xfiles_video.png
│               │   ├── xfiles_wifi_enabled_not_connected.png
│               │   ├── xfiles_wifi_off.png
│               │   ├── xfiles_wifi_on.png
│               │   └── xfiles_wifi_unavailable.png
│               ├── drawable-xxxhdpi
│               │   ├── xf_arrow_left.png
│               │   ├── xf_arrow_right.png
│               │   ├── xf_copy.png
│               │   ├── xf_dir_blu.png
│               │   ├── xf_new_dir.png
│               │   ├── xf_new_file.png
│               │   ├── xf_recycle_bin.png
│               │   ├── xf_share.png
│               │   ├── xf_up_dir.png
│               │   ├── xf_view_mode.png
│               │   ├── xf_xre_server_down.png
│               │   ├── xf_xre_server_up.png
│               │   ├── xfiles_anytype.png
│               │   ├── xfiles_archive.png
│               │   ├── xfiles_archive_7z.png
│               │   ├── xfiles_archive_apk.png
│               │   ├── xfiles_archive_bz2.png
│               │   ├── xfiles_archive_cab.png
│               │   ├── xfiles_archive_gz.png
│               │   ├── xfiles_archive_rar.png
│               │   ├── xfiles_archive_tar.png
│               │   ├── xfiles_archive_xz.png
│               │   ├── xfiles_archive_zip.png
│               │   ├── xfiles_audio.png
│               │   ├── xfiles_cut.png
│               │   ├── xfiles_extract.png
│               │   ├── xfiles_favorites.png
│               │   ├── xfiles_file_icon.png
│               │   ├── xfiles_hotspot_off.png
│               │   ├── xfiles_hotspot_on.png
│               │   ├── xfiles_hotspot_unavailable.png
│               │   ├── xfiles_image.png
│               │   ├── xfiles_link_icon.png
│               │   ├── xfiles_new_app_icon.png
│               │   ├── xfiles_root_off.png
│               │   ├── xfiles_root_on.png
│               │   ├── xfiles_switch_operation_buttons_blue.png
│               │   ├── xfiles_switch_operation_buttons_green.png
│               │   ├── xfiles_system_back.png
│               │   ├── xfiles_system_home.png
│               │   ├── xfiles_system_recent.png
│               │   ├── xfiles_test.png
│               │   ├── xfiles_text.png
│               │   ├── xfiles_video.png
│               │   ├── xfiles_wifi_enabled_not_connected.png
│               │   ├── xfiles_wifi_off.png
│               │   ├── xfiles_wifi_on.png
│               │   └── xfiles_wifi_unavailable.png
│               ├── layout
│               │   ├── about_dialog.xml
│               │   ├── active_remote_servers_layout.xml
│               │   ├── activity_find.xml
│               │   ├── activity_gallery.xml
│               │   ├── activity_main_with_pager.xml
│               │   ├── activity_permission_management.xml
│               │   ├── activity_xre_direct_share.xml
│               │   ├── advanced_sorting_dialog.xml
│               │   ├── ask_password_dialog.xml
│               │   ├── browser_item.xml
│               │   ├── browser_item_grid.xml
│               │   ├── browser_page.xml
│               │   ├── bulk_rename_dialog.xml
│               │   ├── change_directory_dialog_frame_archive.xml
│               │   ├── change_directory_dialog_frame_http.xml
│               │   ├── change_directory_dialog_frame_local.xml
│               │   ├── change_directory_dialog_frame_sftp.xml
│               │   ├── change_directory_dialog_frame_smb.xml
│               │   ├── change_directory_dialog_frame_xre.xml
│               │   ├── change_directory_generic_dialog.xml
│               │   ├── checksum_base_dialog.xml
│               │   ├── checksum_label_item.xml
│               │   ├── compress_layout.xml
│               │   ├── conflict_dialog.xml
│               │   ├── cont_sel.xml
│               │   ├── create_file_dir_dialog.xml
│               │   ├── create_link_dialog.xml
│               │   ├── dircommander_popup_window.xml
│               │   ├── dragitem.xml
│               │   ├── empty.xml
│               │   ├── extract_layout.xml
│               │   ├── extract_results_dialog.xml
│               │   ├── extract_results_item.xml
│               │   ├── favorites.xml
│               │   ├── favorites_local.xml
│               │   ├── favorites_local_list_item.xml
│               │   ├── favorites_sftp.xml
│               │   ├── favorites_smb.xml
│               │   ├── favorites_xfiles_remote.xml
│               │   ├── favorites_xre_list_item.xml
│               │   ├── filter_selection_dialog.xml
│               │   ├── find_results.xml
│               │   ├── gridview_layout.xml
│               │   ├── hash_labels_legend.xml
│               │   ├── hashview_dialog.xml
│               │   ├── hashview_popup_window.xml
│               │   ├── horizontal_operational_layout.xml
│               │   ├── item_image.xml
│               │   ├── item_image_horizontal.xml
│               │   ├── jsimpleimageloader_main.xml
│               │   ├── listview_layout.xml
│               │   ├── multiselect_buttons_layout.xml
│               │   ├── open_as_dialog.xml
│               │   ├── open_as_dialog_item.xml
│               │   ├── overriding_home_buttons_operational_layout.xml
│               │   ├── pager_item.xml
│               │   ├── pasteable_edittext.xml
│               │   ├── properties_aggragates_dialog.xml
│               │   ├── properties_base_dialog.xml
│               │   ├── properties_file_dialog.xml
│               │   ├── quickfind_edittext_layout.xml
│               │   ├── recycler_item.xml
│               │   ├── remote_rh_server_management_dialog.xml
│               │   ├── rhss_server_sessions_item.xml
│               │   ├── ribbon_one.xml
│               │   ├── ribbon_two.xml
│               │   ├── sftp_dialog_insert_item.xml
│               │   ├── sftp_id_list_item.xml
│               │   ├── sftp_list_header_item.xml
│               │   ├── sftp_list_item.xml
│               │   ├── sftp_vault_list_layout.xml
│               │   ├── single_filename_dialog.xml
│               │   ├── smb_list_header_item.xml
│               │   ├── smb_list_item.xml
│               │   ├── smb_vault_list_layout.xml
│               │   ├── sorting_dialog_header_view.xml
│               │   ├── ssh_already_in_known_hosts_dialog.xml
│               │   ├── ssh_key_info_dialog.xml
│               │   ├── ssh_keygen_dialog.xml
│               │   ├── ssh_not_in_known_hosts_dialog.xml
│               │   ├── standard_operational_layout.xml
│               │   ├── update_check_dialog.xml
│               │   ├── xfiles_remote_sessions_management.xml
│               │   ├── xre_path_dialog.xml
│               │   ├── xre_rhss_button_and_active_ips.xml
│               │   └── xre_rhss_widget.xml
│               ├── layout-television
│               │   ├── activity_main_with_pager.xml
│               │   └── horizontal_operational_layout.xml
│               ├── menu
│               │   ├── menu_2ndlevel_share.xml
│               │   ├── menu_2ndlevel_share_local_folder.xml
│               │   ├── menu_browserview.xml
│               │   ├── menu_checkbox.xml
│               │   ├── menu_checksum.xml
│               │   ├── menu_credentials_favorites.xml
│               │   ├── menu_fast_changedir.xml
│               │   ├── menu_find.xml
│               │   ├── menu_find_multi.xml
│               │   ├── menu_multi.xml
│               │   ├── menu_multi_remote.xml
│               │   ├── menu_multi_within_archive.xml
│               │   ├── menu_new.xml
│               │   ├── menu_single.xml
│               │   ├── menu_single_local_folder.xml
│               │   ├── menu_single_remote.xml
│               │   ├── menu_single_remote_folder.xml
│               │   ├── menu_single_within_archive.xml
│               │   └── menu_sort.xml
│               ├── values
│               │   ├── attrs.xml
│               │   ├── colors.xml
│               │   ├── dimens.xml
│               │   ├── strings.xml
│               │   └── styles.xml
│               ├── values-v14
│               │   └── dimens.xml
│               ├── values-v21
│               │   └── styles.xml
│               ├── values-v24
│               │   └── styles.xml
│               ├── values-w820dp
│               │   └── dimens.xml
│               └── xml
│                   ├── provider_paths.xml
│                   └── xre_rhss_widget_info.xml
├── build.gradle
├── buildRootHelpersAndroid.bat
├── buildRootHelpersAndroid.sh
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradle.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

```

`LICENSE`:

```
                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.

```

`LICENSE_UNRAR`:

```
 ******    *****   ******   unRAR - free utility for RAR archives
 **   **  **   **  **   **  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 ******   *******  ******    License for use and distribution of
 **   **  **   **  **   **   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 **   **  **   **  **   **         FREE portable version
                                   ~~~~~~~~~~~~~~~~~~~~~

      The source code of unRAR utility is freeware. This means:

   1. All copyrights to RAR and the utility unRAR are exclusively
      owned by the author - Alexander Roshal.

   2. The unRAR sources may be used in any software to handle RAR
      archives without limitations free of charge, but cannot be used
      to re-create the RAR compression algorithm, which is proprietary.
      Distribution of modified unRAR sources in separate form or as a
      part of other software is permitted, provided that it is clearly
      stated in the documentation and source comments that the code may
      not be used to develop a RAR (WinRAR) compatible archiver.

   3. The unRAR utility may be freely distributed. No person or company 
      may charge a fee for the distribution of unRAR without written
      permission from the copyright holder.

   4. THE RAR ARCHIVER AND THE UNRAR UTILITY ARE DISTRIBUTED "AS IS".
      NO WARRANTY OF ANY KIND IS EXPRESSED OR IMPLIED.  YOU USE AT 
      YOUR OWN RISK. THE AUTHOR WILL NOT BE LIABLE FOR DATA LOSS, 
      DAMAGES, LOSS OF PROFITS OR ANY OTHER KIND OF LOSS WHILE USING
      OR MISUSING THIS SOFTWARE.

   5. Installing and using the unRAR utility signifies acceptance of
      these terms and conditions of the license.

   6. If you don't agree with terms of the license you must remove
      unRAR files from your storage devices and cease to use the
      utility.

      Thank you for your interest in RAR and unRAR.


                                            Alexander L. Roshal

```

`README.md`:

```md
# XFiles

A general-purpose file explorer for (rooted) Android, with support for compressed archives, remote file servers, device-to-device file transfers, checksums, etc...

[![API](https://img.shields.io/badge/API-19%2B-brightgreen.svg?style=flat)](https://android-arsenal.com/api?level=19)
[![Cirrus Build Status](https://api.cirrus-ci.com/github/pgp/XFiles.svg)](https://cirrus-ci.com/github/pgp/XFiles)

[<img src="https://i.ibb.co/74VcyM3/00mainview.jpg" alt="00mainview" width="120" border="0">](https://ibb.co/wsCH6Gn)
[<img src="https://i.ibb.co/HG8Fz6r/00mainviewgrid.jpg" alt="00mainviewgrid" width="120" border="0">](https://ibb.co/nQJgc9D)
[<img src="https://i.ibb.co/tDDGPZH/001quicksearch.jpg" alt="001quicksearch" width="120" border="0">](https://ibb.co/899C4zm)
[<img src="https://i.ibb.co/nDDWbKL/002xreserver.jpg" alt="002xreserver" width="120" border="0">](https://ibb.co/LCCG8sZ)
[<img src="https://i.ibb.co/58qddy6/003advancedsort.jpg" alt="003advancedsort" width="120" border="0">](https://ibb.co/bBpxxZP)
[<img src="https://i.ibb.co/wJDhJzj/004compress.jpg" alt="004compress" width="120" border="0">](https://ibb.co/jV7kVrs)
[<img src="https://i.ibb.co/566G6H4/005compressbrowse.jpg" alt="005compressbrowse" width="120" border="0">](https://ibb.co/pxxbxFw)
[<img src="https://i.ibb.co/sHYmZjx/006contsel.jpg" alt="006contsel" width="120" border="0">](https://ibb.co/ySjfr0v)
[<img src="https://i.ibb.co/XjFMPtv/007contselgrid.jpg" alt="007contselgrid" width="120" border="0">](https://ibb.co/gmth8JB)
[<img src="https://i.ibb.co/6RX3Zvq/008advancedsearch.jpg" alt="008advancedsearch" width="120" border="0">](https://ibb.co/5WKN9YJ)
[<img src="https://i.ibb.co/JHLMnKS/009checksum.jpg" alt="009checksum" width="120" border="0">](https://ibb.co/M7T3nsJ)
[<img src="https://i.ibb.co/7YrwsnB/010godir.jpg" alt="010godir" width="120" border="0">](https://ibb.co/SsVhFtH)

## Getting Started

Two main components:
- XFiles application (that will be built as APK)
- Roothelper native executable (which gets cloned from [here](https://github.com/pgp/XFilesRootHelper) and built automatically by the Android gradle script)

### Releases
Prebuilt APKs are available in the [Releases](https://github.com/pgp/XFiles/releases) section of this repo. RootHelper standalone binaries are available [here](https://github.com/pgp/XFilesRootHelper/releases) as well.

### Demos
Usage demos are available [here](https://github.com/pgp/XFilesDemos).

## Building
### Prerequisites

0. A computer with at least 16 Gb of RAM
1. Windows, Linux or MacOS with git preinstalled;
2. [Android Studio 4.1+](https://developer.android.com/studio/index.html) with CMake and NDK plugins (it is recommended to install them from SDK Manager BEFORE importing the project).

### Build instructions

#### Roothelper
0. The build script for RootHelper is invoked automatically as inner task of the Android gradle build script, and the library binaries are put in the lib folder of the project, in order to be packed into the APK. Follow the below steps if you want to perform a manual build instead.
1. Clone the [Roothelper](https://github.com/pgp/XFilesRootHelper) repository, or change dir into the automatically cloned repo from this project's root.
2. Botan amalgamated source code files for all needed target platforms are already provided in the botanAm folder, however if you want to regenerate them after having downloaded/cloned the official source from [here](https://github.com/randombit/botan): just run the script **_genBotanAmalgamations.sh_** ( or **_genBotanAmalgamations.bat_** for Windows ) after having set the variables $BOTAN_SRC_DIR to the Botan source dir
3. Point a terminal to the roothelper source base dir, then run the **_genRootHelpersAndroid.sh_** / **_genRootHelpersAndroid.bat_** script, after having set the $NDKDIR variable to the extracted path (the default should already be fine under Linux), and the $XFILES_ASSET_DIR one to the root path of the XFiles project
4. If you want instead to build RootHelper for your desktop platform (Windows/Mac/Linux/BSD), just run **_genRootHelperDesktopFull.sh_** / **_genRootHelperDesktopFull.bat_** which starts a CMake configure+build, or **_genRootHelperDesktop.sh_** / **_genRootHelperDesktop.bat_** which rebuilds a preconfigured CMake project

#### XFiles
1. Open Android Studio, and then the SDK Manager
2. Install latest NDK and CMake
3. Open the project (the first sync will last a few minutes, due to the native library build step)
4. Build the project/Build APK from the IDE


## Development tools used

* [Android Studio](https://developer.android.com/studio/index.html) - Main IDE
* [PyCharm](https://www.jetbrains.com/) - For miscellaneous test cases, especially for RootHelper
* [Geany](https://geany.org) - My favourite text editor on non-Windows systems
* [Notepad++](https://notepad-plus-plus.org) - My favourite text editor on Windows
* [Meld](http://meldmerge.org) - An advanced DIFF tool
* [Irfanview](https://www.irfanview.com),[Paint.NET](https://www.getpaint.net),[Inkscape](https://inkscape.org),[ImageMagick](https://www.imagemagick.org/script/index.php) for icon design and processing

## Contributing
* Suggestions, bugfixes, pull-requests are welcome

## License
Both XFiles and RootHelper are released under the LGPL license, with unRAR clause for some files of p7zip source in RootHelper. See the [LICENSE](LICENSE) and [LICENSE_UNRAR](LICENSE_UNRAR) files for further details.

```

`app/build.gradle`:

```gradle
apply plugin: 'com.android.application'

android {
    compileSdkVersion 33
    ndkVersion '21.3.6528147'
    defaultConfig {
        applicationId "it.pgp.xfiles"
        minSdkVersion 19
        targetSdkVersion 33
        multiDexEnabled true
        versionCode 198250912
        versionName "1.9.8"
        externalNativeBuild {
            cmake {
                cppFlags "-std=c++11 -pthread -frtti -fexceptions"
            }
        }
    }
    splits {
        abi {
            enable true
            reset()
            // include "x86", "x86_64", "armeabi-v7a", "arm64-v8a"
            include "armeabi-v7a", "arm64-v8a"
            universalApk true
        }
    }
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'

            packagingOptions {
                doNotStrip '**/libdummy*.so'
                exclude 'META-INF/DEPENDENCIES'
                exclude 'mozilla/public-suffix-list.txt'
            }
        }

        debug {
            minifyEnabled false

            packagingOptions {
                doNotStrip '**/libdummy*.so'
                exclude 'META-INF/DEPENDENCIES'
                exclude 'mozilla/public-suffix-list.txt'
            }
        }
    }

    repositories {
        mavenCentral()
        maven { url "https://jitpack.io" }
    }

    lintOptions {
        abortOnError false
    }

    task rhTask {
        println("Cloning and building XFilesRootHelper native library for Android")
        def lp = System.getenv("LOWPERF") // used only for Travis CI, used to discriminate against explicit PATH import as well
        def path = "PATH="+System.getenv("PATH")
        def lparg = lp?"LOWPERF="+lp:""
        def workingDir = new File(".")
		def proc = lp?
                ((System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows'))?"buildRootHelpersAndroid.bat":"./buildRootHelpersAndroid.sh").execute([path,lparg],workingDir)
                :((System.getProperty('os.name').toLowerCase(Locale.ROOT).contains('windows'))?"buildRootHelpersAndroid.bat":"./buildRootHelpersAndroid.sh").execute()
			
        proc.consumeProcessOutput(System.out, System.err)
        proc.waitFor()
    }

    project.afterEvaluate {
        build.dependsOn rhTask
    }

    sourceSets {
        main {
            // let gradle pack the shared libraries (lib7z.so and libr.so) into apk
            jni.srcDirs = []
            jniLibs.srcDirs = ['../libs']
        }
    }
    compileOptions {
        targetCompatibility 1.8
        sourceCompatibility 1.8
    }
}

dependencies {
    implementation fileTree(dir: 'libs', include: ['*.jar'])
    implementation 'com.android.support:recyclerview-v7:28.0.0'
    implementation 'com.android.support:swiperefreshlayout:28.0.0'
    implementation 'com.android.support:support-annotations:28.0.0'
    implementation 'com.android.support:viewpager:28.0.0'
    implementation 'com.github.solkin:disk-lru-cache:1.5'
    implementation 'com.android.support:multidex:1.0.3'
    implementation group: 'org.bouncycastle', name: 'bcprov-jdk15on', version: '1.65'
    implementation group: 'org.slf4j', name: 'slf4j-android', version: '1.7.30'
    implementation group: 'com.hierynomus', name: 'sshj', version: '0.29.0'
    implementation group: 'org.apache.ftpserver', name: 'ftpserver-core', version: '1.1.0'
    // newest version of ftpserver.core causes manifest merge error
    implementation group: 'eu.agno3.jcifs', name: 'jcifs-ng', version: '2.1.1'
    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-core', version: '2.11.1'
    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.11.1'
    implementation 'com.linkedin.dexmaker:dexmaker:2.28.3'
}

```

`app/dictionary.txt`:

```txt
q
w
e
r
t
y
u
i
o
p
a
s
d
f
g
h
j
k
l
z
x
c
v
b
n
m
Q
W
E
R
T
Y
U
I
O
P
A
S
D
F
G
H
J
K
L
Z
X
C
V
B
N
M
_
$

```

`app/proguard-rules.pro`:

```pro
# Add project specific ProGuard rules here.
# By default, the flags in this file are appended to flags specified
# in /media/pgp/Data/android-sdk/tools/proguard/proguard-android.txt
# You can edit the include path and order by changing the proguardFiles
# directive in build.gradle.
#
# For more details, see
#   http://developer.android.com/guide/developing/tools/proguard.html

# Add any project specific keep options here:

# If your project uses WebView with JS, uncomment the following
# and specify the fully qualified class name to the JavaScript interface
# class:
#-keepclassmembers class fqcn.of.javascript.interface.for.webview {
#   public *;
#}
# -dontobfuscate
-optimizationpasses 5

#-obfuscationdictionary dictionary.txt
#-classobfuscationdictionary dictionary.txt
#-packageobfuscationdictionary dictionary.txt
#-flattenpackagehierarchy

# Remove Log.d messages
-assumenosideeffects class android.util.Log {
    public static int d(...);
}

# Apache Commons
-keep class org.apache.http.**
-keep interface org.apache.http.**

-dontwarn org.apache.commons.**

# Apache mina
-dontwarn javax.security.sasl.*
-dontwarn org.ietf.jgss.*
-dontwarn org.apache.mina.core.session.DefaultIoSessionDataStructureFactory$DefaultIoSessionAttributeMap #Java 8 not implememnted
-dontwarn org.apache.mina.util.ExpiringMap #Java 8 not implememnted
-keepclassmembers class * implements org.apache.mina.core.service.IoProcessor {
    public <init>(java.util.concurrent.ExecutorService);
    public <init>(java.util.concurrent.Executor);
    public <init>();
}

# jcifs
-dontwarn javax.servlet.**
-dontwarn jcifs.http.NetworkExplorer

-keep,allowoptimization,allowobfuscation class eu.masconsult.android_ntlm.* {*;}

# Apache ftpsever
-dontwarn org.apache.ftpserver.**

#From here BouncyCastle
-keep class org.bouncycastle.crypto.* {*;}
-keep class org.bouncycastle.crypto.agreement.** {*;}
-keep class org.bouncycastle.crypto.digests.* {*;}
-keep class org.bouncycastle.crypto.ec.* {*;}
-keep class org.bouncycastle.crypto.encodings.* {*;}
-keep class org.bouncycastle.crypto.engines.* {*;}
-keep class org.bouncycastle.crypto.macs.* {*;}
-keep class org.bouncycastle.crypto.modes.* {*;}
-keep class org.bouncycastle.crypto.paddings.* {*;}
-keep class org.bouncycastle.crypto.params.* {*;}
-keep class org.bouncycastle.crypto.prng.* {*;}
-keep class org.bouncycastle.crypto.signers.* {*;}

-keep class org.bouncycastle.jcajce.provider.asymmetric.* {*;}
-keep class org.bouncycastle.jcajce.provider.asymmetric.util.* {*;}
-keep class org.bouncycastle.jcajce.provider.asymmetric.dh.* {*;}
-keep class org.bouncycastle.jcajce.provider.asymmetric.ec.* {*;}
-keep class org.bouncycastle.jcajce.provider.asymmetric.rsa.* {*;}

-keep class org.bouncycastle.jcajce.provider.digest.** {*;}
-keep class org.bouncycastle.jcajce.provider.keystore.** {*;}
-keep class org.bouncycastle.jcajce.provider.symmetric.** {*;}
-keep class org.bouncycastle.jcajce.spec.* {*;}
-keep class org.bouncycastle.jce.** {*;}

-dontwarn javax.naming.**

# SSHJ
-keep class net.schmizz.sshj.** {*;}

# avoid issues with Gradle Plugin >= 4.0.0 (static init block was optimized out from ViewType)
-keep class it.pgp.xfiles.service.visualization.** { *; }

```

`app/src/main/AndroidManifest.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    package="it.pgp.xfiles">

    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_MULTICAST_STATE"/>
    <uses-permission android:name="android.permission.SYSTEM_ALERT_WINDOW" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.MANAGE_EXTERNAL_STORAGE" tools:ignore="ScopedStorage"/>
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.REQUEST_INSTALL_PACKAGES" />
    <uses-permission android:name="android.permission.QUERY_ALL_PACKAGES"/>
    <uses-permission android:name="android.permission.WRITE_SETTINGS" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.TETHER_PRIVILEGED" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" /> <!-- API 33 -->

    <!-- <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /> -->
    <!-- for (local) wifi hotspot toggle from Android O onwards -->
    <application
        android:allowBackup="true"
        android:usesCleartextTraffic="true"
        android:icon="@drawable/xfiles_new_app_icon"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        android:requestLegacyExternalStorage="true">

        <provider
            android:name="android.support.v4.content.FileProvider"
            android:authorities="${applicationId}.provider"
            android:exported="false"
            android:grantUriPermissions="true" >
            <meta-data
                android:name="android.support.FILE_PROVIDER_PATHS"
                android:resource="@xml/provider_paths" />
        </provider>

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize|keyboardHidden"
            android:launchMode="singleTask"
            android:windowSoftInputMode="stateAlwaysHidden|adjustPan">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
                <category android:name="android.intent.category.LEANBACK_LAUNCHER" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data
                    android:host="*"
                    android:mimeType="*/*" />
                <data android:mimeType="application/rar" />
                <data android:mimeType="application/x-rar-compressed" />
                <data android:mimeType="application/zip" />
                <data android:mimeType="application/x-zip" />
                <data android:mimeType="application/x-zip-compressed" />
                <data android:mimeType="application/x-7z-compressed" />
                <data android:mimeType="application/x-tar" />
                <data android:mimeType="application/x-bzip2" />
                <data android:mimeType="application/x-gzip" />
                <data android:mimeType="application/x-xz" />
                <data android:mimeType="application/octet-stream" />
                <data android:mimeType="application/x-compress" />
                <data android:mimeType="application/x-compressed" />
                <data android:mimeType="text/html" />
                <data android:mimeType="text/plain" />
                <data android:mimeType="application/xhtml+xml" />
                <data android:scheme="file" />
                <data android:scheme="content" />
                <data android:scheme="http" />
                <data android:scheme="https" />
            </intent-filter>
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />

                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />

                <data android:scheme="file" />
                <data android:scheme="content" />
                <data
                    android:host="*"
                    android:mimeType="*/*" />
                <data android:pathPattern=".*\.RAR" />
                <data android:pathPattern=".*\..*\.RAR" />
                <data android:pathPattern=".*\..*\..*\.RAR" />
                <data android:pathPattern=".*\..*\..*\..*\.RAR" />
                <data android:pathPattern=".*\.rar" />
                <data android:pathPattern=".*\..*\.rar" />
                <data android:pathPattern=".*\..*\..*\.rar" />
                <data android:pathPattern=".*\..*\..*\..*\.rar" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.rar" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.rar" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.rar" />
                <data android:pathPattern=".*\.ZIP" />
                <data android:pathPattern=".*\..*\.ZIP" />
                <data android:pathPattern=".*\..*\..*\.ZIP" />
                <data android:pathPattern=".*\..*\..*\..*\.ZIP" />
                <data android:pathPattern=".*\.zip" />
                <data android:pathPattern=".*\..*\.zip" />
                <data android:pathPattern=".*\..*\..*\.zip" />
                <data android:pathPattern=".*\..*\..*\..*\.zip" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.zip" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.zip" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.zip" />
                <data android:pathPattern=".*\.CAB" />
                <data android:pathPattern=".*\..*\.CAB" />
                <data android:pathPattern=".*\..*\..*\.CAB" />
                <data android:pathPattern=".*\..*\..*\..*\.CAB" />
                <data android:pathPattern=".*\.cab" />
                <data android:pathPattern=".*\..*\.cab" />
                <data android:pathPattern=".*\..*\..*\.cab" />
                <data android:pathPattern=".*\..*\..*\..*\.cab" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.cab" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.cab" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.cab" />
                <data android:pathPattern=".*\.7Z" />
                <data android:pathPattern=".*\..*\.7Z" />
                <data android:pathPattern=".*\..*\..*\.7Z" />
                <data android:pathPattern=".*\..*\..*\..*\.7Z" />
                <data android:pathPattern=".*\.7z" />
                <data android:pathPattern=".*\..*\.7z" />
                <data android:pathPattern=".*\..*\..*\.7z" />
                <data android:pathPattern=".*\..*\..*\..*\.7z" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.7z" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.7z" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.7z" />
                <data android:pathPattern=".*\.BZ2" />
                <data android:pathPattern=".*\..*\.BZ2" />
                <data android:pathPattern=".*\..*\..*\.BZ2" />
                <data android:pathPattern=".*\..*\..*\..*\.BZ2" />
                <data android:pathPattern=".*\.bz2" />
                <data android:pathPattern=".*\..*\.bz2" />
                <data android:pathPattern=".*\..*\..*\.bz2" />
                <data android:pathPattern=".*\..*\..*\..*\.bz2" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.bz2" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.bz2" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.bz2" />
                <data android:pathPattern=".*\.GZ" />
                <data android:pathPattern=".*\..*\.GZ" />
                <data android:pathPattern=".*\..*\..*\.GZ" />
                <data android:pathPattern=".*\..*\..*\..*\.GZ" />
                <data android:pathPattern=".*\.gz" />
                <data android:pathPattern=".*\..*\.gz" />
                <data android:pathPattern=".*\..*\..*\.gz" />
                <data android:pathPattern=".*\..*\..*\..*\.gz" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.gz" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.gz" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.gz" />
                <data android:pathPattern=".*\.TAR" />
                <data android:pathPattern=".*\..*\.TAR" />
                <data android:pathPattern=".*\..*\..*\.TAR" />
                <data android:pathPattern=".*\..*\..*\..*\.TAR" />
                <data android:pathPattern=".*\.tar" />
                <data android:pathPattern=".*\..*\.tar" />
                <data android:pathPattern=".*\..*\..*\.tar" />
                <data android:pathPattern=".*\..*\..*\..*\.tar" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.tar" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.tar" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.tar" />
                <data android:pathPattern=".*\.XZ" />
                <data android:pathPattern=".*\..*\.XZ" />
                <data android:pathPattern=".*\..*\..*\.XZ" />
                <data android:pathPattern=".*\..*\..*\..*\.XZ" />
                <data android:pathPattern=".*\.xz" />
                <data android:pathPattern=".*\..*\.xz" />
                <data android:pathPattern=".*\..*\..*\.xz" />
                <data android:pathPattern=".*\..*\..*\..*\.xz" />
                <data android:pathPattern=".*\..*\..*\..*\..*\.xz" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\.xz" />
                <data android:pathPattern=".*\..*\..*\..*\..*\..*\..*\.xz" />
            </intent-filter>
        </activity>
        <activity
            android:name=".RestarterActivity"
            android:process=":anotherProcess" />
        <activity android:name=".SettingsLauncherActivity" />
        <activity
            android:name=".sftpclient.VaultActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
        <activity
            android:name=".smbclient.SmbVaultActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
        <activity
            android:name=".FavoritesActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
<!--        <activity-->
<!--            android:name="com.tomclaw.imageloader.demo.DemoActivity"-->
<!--            android:configChanges="orientation|screenSize|keyboardHidden" />-->
        <activity
            android:name=".XREDirectShareActivity"
            android:exported="true"
            android:launchMode="singleTask"
            android:configChanges="orientation|screenSize|keyboardHidden">
            <intent-filter
                android:icon="@drawable/xf_share"
                android:label="Share with XFiles">
                <action android:name="android.intent.action.SEND" />
                <action android:name="android.intent.action.SEND_MULTIPLE" />

                <category android:name="android.intent.category.DEFAULT" />

                <data android:mimeType="*/*" />
            </intent-filter>
        </activity>
        <activity
            android:name=".dialogs.compress.CompressActivity"
            android:exported="true"
            android:configChanges="orientation|screenSize|keyboardHidden">
            <intent-filter
                android:icon="@drawable/xfiles_archive"
                android:label="Compress with XFiles">
                <action android:name="android.intent.action.SEND" />
                <action android:name="android.intent.action.SEND_MULTIPLE" />

                <category android:name="android.intent.category.DEFAULT" />

                <data android:mimeType="*/*" />
            </intent-filter>
        </activity>
        <activity
            android:name=".dialogs.compress.ExtractActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
        <activity
            android:name=".dialogs.XFilesRemoteSessionsManagementActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
        <activity
            android:name=".FindActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
        <activity
            android:name=".dialogs.ChecksumActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
        <activity
            android:name=".PermissionManagementActivity"
            android:configChanges="orientation|screenSize|keyboardHidden" />
        <activity
            android:name=".MediaGalleryActivity"
            android:launchMode="singleTask"
            android:configChanges="orientation|screenSize|keyboardHidden" />

        <service
            android:name=".service.NonInteractiveXFilesRemoteTransferService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.FindService"
            android:enabled="true"
            android:exported="true" />

        <!-- TODO before using standalone processes for service classes, need to remove dependency from static fields and/or activity methods (e.g. access dirCommander and browserAdapter) -->

        <service
            android:name=".service.CopyMoveService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.CompressService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.ExtractService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.TestService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.NonInteractiveSftpService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.NonInteractiveSmbService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.HTTPDownloadService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.HTTPUploadService"
            android:enabled="true"
            android:exported="true" />
        <service
            android:name=".service.CreateFileService"
            android:enabled="true"
            android:exported="true" />

        <receiver android:name=".XRE_RHSS_Widget" android:exported="true">
            <intent-filter>
                <action android:name="android.appwidget.action.APPWIDGET_UPDATE" />
                <action android:name="it.pgp.xfiles.appwidget.action.STANDARD_UPDATE" />
                <action android:name="it.pgp.xfiles.appwidget.action.ON_DEMAND_UPDATE" />
            </intent-filter>

            <meta-data
                android:name="android.appwidget.provider"
                android:resource="@xml/xre_rhss_widget_info" />
        </receiver>
    </application>

</manifest>
```

`app/src/main/java/com/davemorrissey/labs/subscaleview/ImageSource.java`:

```java
package com.davemorrissey.labs.subscaleview;

import android.graphics.Bitmap;
import android.graphics.Rect;
import android.net.Uri;
import android.support.annotation.NonNull;

import java.io.File;
import java.io.UnsupportedEncodingException;
import java.net.URLDecoder;

/**
 * Helper class used to set the source and additional attributes from a variety of sources. Supports
 * use of a bitmap, asset, resource, external file or any other URI.
 *
 * When you are using a preview image, you must set the dimensions of the full size image on the
 * ImageSource object for the full size image using the {@link #dimensions(int, int)} method.
 */
@SuppressWarnings({"unused", "WeakerAccess"})
public final class ImageSource {

    static final String FILE_SCHEME = "file:///";
    static final String ASSET_SCHEME = "file:///android_asset/";

    private final Uri uri;
    private final Bitmap bitmap;
    private final Integer resource;
    private boolean tile;
    private int sWidth;
    private int sHeight;
    private Rect sRegion;
    private boolean cached;

    private ImageSource(Bitmap bitmap, boolean cached) {
        this.bitmap = bitmap;
        this.uri = null;
        this.resource = null;
        this.tile = false;
        this.sWidth = bitmap.getWidth();
        this.sHeight = bitmap.getHeight();
        this.cached = cached;
    }

    private ImageSource(@NonNull Uri uri) {
        // #114 If file doesn't exist, attempt to url decode the URI and try again
        String uriString = uri.toString();
        if (uriString.startsWith(FILE_SCHEME)) {
            File uriFile = new File(uriString.substring(FILE_SCHEME.length() - 1));
            if (!uriFile.exists()) {
                try {
                    uri = Uri.parse(URLDecoder.decode(uriString, "UTF-8"));
                } catch (UnsupportedEncodingException e) {
                    // Fallback to encoded URI. This exception is not expected.
                }
            }
        }
        this.bitmap = null;
        this.uri = uri;
        this.resource = null;
        this.tile = true;
    }

    private ImageSource(int resource) {
        this.bitmap = null;
        this.uri = null;
        this.resource = resource;
        this.tile = true;
    }

    /**
     * Create an instance from a resource. The correct resource for the device screen resolution will be used.
     * @param resId resource ID.
     * @return an {@link ImageSource} instance.
     */
    @NonNull
    public static ImageSource resource(int resId) {
        return new ImageSource(resId);
    }

    /**
     * Create an instance from an asset name.
     * @param assetName asset name.
     * @return an {@link ImageSource} instance.
     */
    @NonNull
    public static ImageSource asset(@NonNull String assetName) {
        //noinspection ConstantConditions
        if (assetName == null) {
            throw new NullPointerException("Asset name must not be null");
        }
        return uri(ASSET_SCHEME + assetName);
    }

    /**
     * Create an instance from a URI. If the URI does not start with a scheme, it's assumed to be the URI
     * of a file.
     * @param uri image URI.
     * @return an {@link ImageSource} instance.
     */
    @NonNull
    public static ImageSource uri(@NonNull String uri) {
        //noinspection ConstantConditions
        if (uri == null) {
            throw new NullPointerException("Uri must not be null");
        }
        if (!uri.contains("://")) {
            if (uri.startsWith("/")) {
                uri = uri.substring(1);
            }
            uri = FILE_SCHEME + uri;
        }
        return new ImageSource(Uri.parse(uri));
    }

    /**
     * Create an instance from a URI.
     * @param uri image URI.
     * @return an {@link ImageSource} instance.
     */
    @NonNull
    public static ImageSource uri(@NonNull Uri uri) {
        //noinspection ConstantConditions
        if (uri == null) {
            throw new NullPointerException("Uri must not be null");
        }
        return new ImageSource(uri);
    }

    /**
     * Provide a loaded bitmap for display.
     * @param bitmap bitmap to be displayed.
     * @return an {@link ImageSource} instance.
     */
    @NonNull
    public static ImageSource bitmap(@NonNull Bitmap bitmap) {
        //noinspection ConstantConditions
        if (bitmap == null) {
            throw new NullPointerException("Bitmap must not be null");
        }
        return new ImageSource(bitmap, false);
    }

    /**
     * Provide a loaded and cached bitmap for display. This bitmap will not be recycled when it is no
     * longer needed. Use this method if you loaded the bitmap with an image loader such as Picasso
     * or Volley.
     * @param bitmap bitmap to be displayed.
     * @return an {@link ImageSource} instance.
     */
    @NonNull
    public static ImageSource cachedBitmap(@NonNull Bitmap bitmap) {
        //noinspection ConstantConditions
        if (bitmap == null) {
            throw new NullPointerException("Bitmap must not be null");
        }
        return new ImageSource(bitmap, true);
    }

    /**
     * Enable tiling of the image. This does not apply to preview images which are always loaded as a single bitmap.,
     * and tiling cannot be disabled when displaying a region of the source image.
     * @return this instance for chaining.
     */
    @NonNull
    public ImageSource tilingEnabled() {
        return tiling(true);
    }

    /**
     * Disable tiling of the image. This does not apply to preview images which are always loaded as a single bitmap,
     * and tiling cannot be disabled when displaying a region of the source image.
     * @return this instance for chaining.
     */
    @NonNull
    public ImageSource tilingDisabled() {
        return tiling(false);
    }

    /**
     * Enable or disable tiling of the image. This does not apply to preview images which are always loaded as a single bitmap,
     * and tiling cannot be disabled when displaying a region of the source image.
     * @param tile whether tiling should be enabled.
     * @return this instance for chaining.
     */
    @NonNull
    public ImageSource tiling(boolean tile) {
        this.tile = tile;
        return this;
    }

    /**
     * Use a region of the source image. Region must be set independently for the full size image and the preview if
     * you are using one.
     * @param sRegion the region of the source image to be displayed.
     * @return this instance for chaining.
     */
    @NonNull
    public ImageSource region(Rect sRegion) {
        this.sRegion = sRegion;
        setInvariants();
        return this;
    }

    /**
     * Declare the dimensions of the image. This is only required for a full size image, when you are specifying a URI
     * and also a preview image. When displaying a bitmap object, or not using a preview, you do not need to declare
     * the image dimensions. Note if the declared dimensions are found to be incorrect, the view will reset.
     * @param sWidth width of the source image.
     * @param sHeight height of the source image.
     * @return this instance for chaining.
     */
    @NonNull
    public ImageSource dimensions(int sWidth, int sHeight) {
        if (bitmap == null) {
            this.sWidth = sWidth;
            this.sHeight = sHeight;
        }
        setInvariants();
        return this;
    }

    private void setInvariants() {
        if (this.sRegion != null) {
            this.tile = true;
            this.sWidth = this.sRegion.width();
            this.sHeight = this.sRegion.height();
        }
    }

    protected final Uri getUri() {
        return uri;
    }

    protected final Bitmap getBitmap() {
        return bitmap;
    }

    protected final Integer getResource() {
        return resource;
    }

    protected final boolean getTile() {
        return tile;
    }

    protected final int getSWidth() {
        return sWidth;
    }

    protected final int getSHeight() {
        return sHeight;
    }

    protected final Rect getSRegion() {
        return sRegion;
    }

    protected final boolean isCached() {
        return cached;
    }
}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/ImageViewState.java`:

```java
package com.davemorrissey.labs.subscaleview;

import android.graphics.PointF;
import android.support.annotation.NonNull;

import java.io.Serializable;

/**
 * Wraps the scale, center and orientation of a displayed image for easy restoration on screen rotate.
 */
@SuppressWarnings("WeakerAccess")
public class ImageViewState implements Serializable {

    private final float scale;

    private final float centerX;

    private final float centerY;

    private final int orientation;

    public ImageViewState(float scale, @NonNull PointF center, int orientation) {
        this.scale = scale;
        this.centerX = center.x;
        this.centerY = center.y;
        this.orientation = orientation;
    }

    public float getScale() {
        return scale;
    }

    @NonNull public PointF getCenter() {
        return new PointF(centerX, centerY);
    }

    public int getOrientation() {
        return orientation;
    }

}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/SubsamplingScaleImageView.java`:

```java
package com.davemorrissey.labs.subscaleview;

import android.content.ContentResolver;
import android.content.Context;
import android.content.res.TypedArray;
import android.database.Cursor;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.Paint.Style;
import android.graphics.Point;
import android.graphics.PointF;
import android.graphics.Rect;
import android.graphics.RectF;
import android.support.annotation.Nullable;
import android.media.ExifInterface;
import android.net.Uri;
import android.os.AsyncTask;
import android.os.Handler;
import android.os.Message;
import android.provider.MediaStore;
import android.support.annotation.AnyThread;
import android.support.annotation.NonNull;
import android.util.AttributeSet;
import android.util.DisplayMetrics;
import android.util.Log;
import android.util.TypedValue;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewParent;

import com.davemorrissey.labs.subscaleview.decoder.CompatDecoderFactory;
import com.davemorrissey.labs.subscaleview.decoder.DecoderFactory;
import com.davemorrissey.labs.subscaleview.decoder.ImageDecoder;
import com.davemorrissey.labs.subscaleview.decoder.ImageRegionDecoder;
import com.davemorrissey.labs.subscaleview.decoder.SkiaImageDecoder;
import com.davemorrissey.labs.subscaleview.decoder.SkiaImageRegionDecoder;

import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import it.pgp.xfiles.R;

/**
 * <p>
 * Displays an image subsampled as necessary to avoid loading too much image data into memory. After zooming in,
 * a set of image tiles subsampled at higher resolution are loaded and displayed over the base layer. During pan and
 * zoom, tiles off screen or higher/lower resolution than required are discarded from memory.
 * </p><p>
 * Tiles are no larger than the max supported bitmap size, so with large images tiling may be used even when zoomed out.
 * </p><p>
 * v prefixes - coordinates, translations and distances measured in screen (view) pixels
 * <br>
 * s prefixes - coordinates, translations and distances measured in rotated and cropped source image pixels (scaled)
 * <br>
 * f prefixes - coordinates, translations and distances measured in original unrotated, uncropped source file pixels
 * </p><p>
 * <a href="https://github.com/davemorrissey/subsampling-scale-image-view">View project on GitHub</a>
 * </p>
 */
@SuppressWarnings("unused")
public class SubsamplingScaleImageView extends View {

    private static final String TAG = SubsamplingScaleImageView.class.getSimpleName();

    /** Attempt to use EXIF information on the image to rotate it. Works for external files only. */
    public static final int ORIENTATION_USE_EXIF = -1;
    /** Display the image file in its native orientation. */
    public static final int ORIENTATION_0 = 0;
    /** Rotate the image 90 degrees clockwise. */
    public static final int ORIENTATION_90 = 90;
    /** Rotate the image 180 degrees. */
    public static final int ORIENTATION_180 = 180;
    /** Rotate the image 270 degrees clockwise. */
    public static final int ORIENTATION_270 = 270;

    private static final List<Integer> VALID_ORIENTATIONS = Arrays.asList(ORIENTATION_0, ORIENTATION_90, ORIENTATION_180, ORIENTATION_270, ORIENTATION_USE_EXIF);

    /** During zoom animation, keep the point of the image that was tapped in the same place, and scale the image around it. */
    public static final int ZOOM_FOCUS_FIXED = 1;
    /** During zoom animation, move the point of the image that was tapped to the center of the screen. */
    public static final int ZOOM_FOCUS_CENTER = 2;
    /** Zoom in to and center the tapped point immediately without animating. */
    public static final int ZOOM_FOCUS_CENTER_IMMEDIATE = 3;

    private static final List<Integer> VALID_ZOOM_STYLES = Arrays.asList(ZOOM_FOCUS_FIXED, ZOOM_FOCUS_CENTER, ZOOM_FOCUS_CENTER_IMMEDIATE);

    /** Quadratic ease out. Not recommended for scale animation, but good for panning. */
    public static final int EASE_OUT_QUAD = 1;
    /** Quadratic ease in and out. */
    public static final int EASE_IN_OUT_QUAD = 2;

    private static final List<Integer> VALID_EASING_STYLES = Arrays.asList(EASE_IN_OUT_QUAD, EASE_OUT_QUAD);

    /** Don't allow the image to be panned off screen. As much of the image as possible is always displayed, centered in the view when it is smaller. This is the best option for galleries. */
    public static final int PAN_LIMIT_INSIDE = 1;
    /** Allows the image to be panned until it is just off screen, but no further. The edge of the image will stop when it is flush with the screen edge. */
    public static final int PAN_LIMIT_OUTSIDE = 2;
    /** Allows the image to be panned until a corner reaches the center of the screen but no further. Useful when you want to pan any spot on the image to the exact center of the screen. */
    public static final int PAN_LIMIT_CENTER = 3;

    private static final List<Integer> VALID_PAN_LIMITS = Arrays.asList(PAN_LIMIT_INSIDE, PAN_LIMIT_OUTSIDE, PAN_LIMIT_CENTER);

    /** Scale the image so that both dimensions of the image will be equal to or less than the corresponding dimension of the view. The image is then centered in the view. This is the default behaviour and best for galleries. */
    public static final int SCALE_TYPE_CENTER_INSIDE = 1;
    /** Scale the image uniformly so that both dimensions of the image will be equal to or larger than the corresponding dimension of the view. The image is then centered in the view. */
    public static final int SCALE_TYPE_CENTER_CROP = 2;
    /** Scale the image so that both dimensions of the image will be equal to or less than the maxScale and equal to or larger than minScale. The image is then centered in the view. */
    public static final int SCALE_TYPE_CUSTOM = 3;
    /** Scale the image so that both dimensions of the image will be equal to or larger than the corresponding dimension of the view. The top left is shown. */
    public static final int SCALE_TYPE_START = 4;

    private static final List<Integer> VALID_SCALE_TYPES = Arrays.asList(SCALE_TYPE_CENTER_CROP, SCALE_TYPE_CENTER_INSIDE, SCALE_TYPE_CUSTOM, SCALE_TYPE_START);

    /** State change originated from animation. */
    public static final int ORIGIN_ANIM = 1;
    /** State change originated from touch gesture. */
    public static final int ORIGIN_TOUCH = 2;
    /** State change originated from a fling momentum anim. */
    public static final int ORIGIN_FLING = 3;
    /** State change originated from a double tap zoom anim. */
    public static final int ORIGIN_DOUBLE_TAP_ZOOM = 4;

    // Bitmap (preview or full image)
    private Bitmap bitmap;

    // Whether the bitmap is a preview image
    private boolean bitmapIsPreview;

    // Specifies if a cache handler is also referencing the bitmap. Do not recycle if so.
    private boolean bitmapIsCached;

    // Uri of full size image
    private Uri uri;

    // Sample size used to display the whole image when fully zoomed out
    private int fullImageSampleSize;

    // Map of zoom level to tile grid
    private Map<Integer, List<Tile>> tileMap;

    // Overlay tile boundaries and other info
    private boolean debug;

    // Image orientation setting
    private int orientation = ORIENTATION_0;

    // Max scale allowed (prevent infinite zoom)
    private float maxScale = 2F;

    // Min scale allowed (prevent infinite zoom)
    private float minScale = minScale();

    // Density to reach before loading higher resolution tiles
    private int minimumTileDpi = -1;

    // Pan limiting style
    private int panLimit = PAN_LIMIT_INSIDE;

    // Minimum scale type
    private int minimumScaleType = SCALE_TYPE_CENTER_INSIDE;

    // overrides for the dimensions of the generated tiles
    public static final int TILE_SIZE_AUTO = Integer.MAX_VALUE;
    private int maxTileWidth = TILE_SIZE_AUTO;
    private int maxTileHeight = TILE_SIZE_AUTO;

    // An executor service for loading of images
    private Executor executor = AsyncTask.THREAD_POOL_EXECUTOR;

    // Whether tiles should be loaded while gestures and animations are still in progress
    private boolean eagerLoadingEnabled = true;

    // Gesture detection settings
    private boolean panEnabled = true;
    private boolean zoomEnabled = true;
    private boolean quickScaleEnabled = true;

    // Double tap zoom behaviour
    private float doubleTapZoomScale = 1F;
    private int doubleTapZoomStyle = ZOOM_FOCUS_FIXED;
    private int doubleTapZoomDuration = 500;

    // Current scale and scale at start of zoom
    private float scale;
    private float scaleStart;

    // Screen coordinate of top-left corner of source image
    private PointF vTranslate;
    private PointF vTranslateStart;
    private PointF vTranslateBefore;

    // Source coordinate to center on, used when new position is set externally before view is ready
    private Float pendingScale;
    private PointF sPendingCenter;
    private PointF sRequestedCenter;

    // Source image dimensions and orientation - dimensions relate to the unrotated image
    private int sWidth;
    private int sHeight;
    private int sOrientation;
    private Rect sRegion;
    private Rect pRegion;

    // Is two-finger zooming in progress
    private boolean isZooming;
    // Is one-finger panning in progress
    private boolean isPanning;
    // Is quick-scale gesture in progress
    private boolean isQuickScaling;
    // Max touches used in current gesture
    private int maxTouchCount;

    // Fling detector
    private GestureDetector detector;
    private GestureDetector singleDetector;

    // Tile and image decoding
    private ImageRegionDecoder decoder;
    private final ReadWriteLock decoderLock = new ReentrantReadWriteLock(true);
    private DecoderFactory<? extends ImageDecoder> bitmapDecoderFactory = new CompatDecoderFactory<ImageDecoder>(SkiaImageDecoder.class);
    private DecoderFactory<? extends ImageRegionDecoder> regionDecoderFactory = new CompatDecoderFactory<ImageRegionDecoder>(SkiaImageRegionDecoder.class);

    // Debug values
    private PointF vCenterStart;
    private float vDistStart;

    // Current quickscale state
    private final float quickScaleThreshold;
    private float quickScaleLastDistance;
    private boolean quickScaleMoved;
    private PointF quickScaleVLastPoint;
    private PointF quickScaleSCenter;
    private PointF quickScaleVStart;

    // Scale and center animation tracking
    private Anim anim;

    // Whether a ready notification has been sent to subclasses
    private boolean readySent;
    // Whether a base layer loaded notification has been sent to subclasses
    private boolean imageLoadedSent;

    // Event listener
    private OnImageEventListener onImageEventListener;

    // Scale and center listener
    private OnStateChangedListener onStateChangedListener;

    // Long click listener
    private OnLongClickListener onLongClickListener;

    // Long click handler
    private final Handler handler;
    private static final int MESSAGE_LONG_CLICK = 1;

    // Paint objects created once and reused for efficiency
    private Paint bitmapPaint;
    private Paint debugTextPaint;
    private Paint debugLinePaint;
    private Paint tileBgPaint;

    // Volatile fields used to reduce object creation
    private ScaleAndTranslate satTemp;
    private Matrix matrix;
    private RectF sRect;
    private final float[] srcArray = new float[8];
    private final float[] dstArray = new float[8];

    //The logical density of the display
    private final float density;

    // A global preference for bitmap format, available to decoder classes that respect it
    private static Bitmap.Config preferredBitmapConfig;

    public SubsamplingScaleImageView(Context context, AttributeSet attr) {
        super(context, attr);
        density = getResources().getDisplayMetrics().density;
        setMinimumDpi(160);
        setDoubleTapZoomDpi(160);
        setMinimumTileDpi(320);
        setGestureDetector(context);
        this.handler = new Handler(new Handler.Callback() {
            public boolean handleMessage(Message message) {
                if (message.what == MESSAGE_LONG_CLICK && onLongClickListener != null) {
                    maxTouchCount = 0;
                    SubsamplingScaleImageView.super.setOnLongClickListener(onLongClickListener);
                    performLongClick();
                    SubsamplingScaleImageView.super.setOnLongClickListener(null);
                }
                return true;
            }
        });
        // Handle XML attributes
        if (attr != null) {
            TypedArray typedAttr = getContext().obtainStyledAttributes(attr, R.styleable.SubsamplingScaleImageView);
            if (typedAttr.hasValue(R.styleable.SubsamplingScaleImageView_assetName)) {
                String assetName = typedAttr.getString(R.styleable.SubsamplingScaleImageView_assetName);
                if (assetName != null && assetName.length() > 0) {
                    setImage(ImageSource.asset(assetName).tilingEnabled());
                }
            }
            if (typedAttr.hasValue(R.styleable.SubsamplingScaleImageView_src)) {
                int resId = typedAttr.getResourceId(R.styleable.SubsamplingScaleImageView_src, 0);
                if (resId > 0) {
                    setImage(ImageSource.resource(resId).tilingEnabled());
                }
            }
            if (typedAttr.hasValue(R.styleable.SubsamplingScaleImageView_panEnabled)) {
                setPanEnabled(typedAttr.getBoolean(R.styleable.SubsamplingScaleImageView_panEnabled, true));
            }
            if (typedAttr.hasValue(R.styleable.SubsamplingScaleImageView_zoomEnabled)) {
                setZoomEnabled(typedAttr.getBoolean(R.styleable.SubsamplingScaleImageView_zoomEnabled, true));
            }
            if (typedAttr.hasValue(R.styleable.SubsamplingScaleImageView_quickScaleEnabled)) {
                setQuickScaleEnabled(typedAttr.getBoolean(R.styleable.SubsamplingScaleImageView_quickScaleEnabled, true));
            }
            if (typedAttr.hasValue(R.styleable.SubsamplingScaleImageView_tileBackgroundColor)) {
                setTileBackgroundColor(typedAttr.getColor(R.styleable.SubsamplingScaleImageView_tileBackgroundColor, Color.argb(0, 0, 0, 0)));
            }
            typedAttr.recycle();
        }

        quickScaleThreshold = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 20, context.getResources().getDisplayMetrics());
    }

    public SubsamplingScaleImageView(Context context) {
        this(context, null);
    }

    /**
     * Get the current preferred configuration for decoding bitmaps. {@link ImageDecoder} and {@link ImageRegionDecoder}
     * instances can read this and use it when decoding images.
     * @return the preferred bitmap configuration, or null if none has been set.
     */
    public static Bitmap.Config getPreferredBitmapConfig() {
        return preferredBitmapConfig;
    }

    /**
     * Set a global preferred bitmap config shared by all view instances and applied to new instances
     * initialised after the call is made. This is a hint only; the bundled {@link ImageDecoder} and
     * {@link ImageRegionDecoder} classes all respect this (except when they were constructed with
     * an instance-specific config) but custom decoder classes will not.
     * @param preferredBitmapConfig the bitmap configuration to be used by future instances of the view. Pass null to restore the default.
     */
    public static void setPreferredBitmapConfig(Bitmap.Config preferredBitmapConfig) {
        SubsamplingScaleImageView.preferredBitmapConfig = preferredBitmapConfig;
    }

    /**
     * Sets the image orientation. It's best to call this before setting the image file or asset, because it may waste
     * loading of tiles. However, this can be freely called at any time.
     * @param orientation orientation to be set. See ORIENTATION_ static fields for valid values.
     */
    public final void setOrientation(int orientation) {
        if (!VALID_ORIENTATIONS.contains(orientation)) {
            throw new IllegalArgumentException("Invalid orientation: " + orientation);
        }
        this.orientation = orientation;
        reset(false);
        invalidate();
        requestLayout();
    }

    /**
     * Set the image source from a bitmap, resource, asset, file or other URI.
     * @param imageSource Image source.
     */
    public final void setImage(@NonNull ImageSource imageSource) {
        setImage(imageSource, null, null);
    }

    /**
     * Set the image source from a bitmap, resource, asset, file or other URI, starting with a given orientation
     * setting, scale and center. This is the best method to use when you want scale and center to be restored
     * after screen orientation change; it avoids any redundant loading of tiles in the wrong orientation.
     * @param imageSource Image source.
     * @param state State to be restored. Nullable.
     */
    public final void setImage(@NonNull ImageSource imageSource, ImageViewState state) {
        setImage(imageSource, null, state);
    }

    /**
     * Set the image source from a bitmap, resource, asset, file or other URI, providing a preview image to be
     * displayed until the full size image is loaded.
     *
     * You must declare the dimensions of the full size image by calling {@link ImageSource#dimensions(int, int)}
     * on the imageSource object. The preview source will be ignored if you don't provide dimensions,
     * and if you provide a bitmap for the full size image.
     * @param imageSource Image source. Dimensions must be declared.
     * @param previewSource Optional source for a preview image to be displayed and allow interaction while the full size image loads.
     */
    public final void setImage(@NonNull ImageSource imageSource, ImageSource previewSource) {
        setImage(imageSource, previewSource, null);
    }

    /**
     * Set the image source from a bitmap, resource, asset, file or other URI, providing a preview image to be
     * displayed until the full size image is loaded, starting with a given orientation setting, scale and center.
     * This is the best method to use when you want scale and center to be restored after screen orientation change;
     * it avoids any redundant loading of tiles in the wrong orientation.
     *
     * You must declare the dimensions of the full size image by calling {@link ImageSource#dimensions(int, int)}
     * on the imageSource object. The preview source will be ignored if you don't provide dimensions,
     * and if you provide a bitmap for the full size image.
     * @param imageSource Image source. Dimensions must be declared.
     * @param previewSource Optional source for a preview image to be displayed and allow interaction while the full size image loads.
     * @param state State to be restored. Nullable.
     */
    public final void setImage(@NonNull ImageSource imageSource, ImageSource previewSource, ImageViewState state) {
        //noinspection ConstantConditions
        if (imageSource == null) {
            throw new NullPointerException("imageSource must not be null");
        }

        reset(true);
        if (state != null) { restoreState(state); }

        if (previewSource != null) {
            if (imageSource.getBitmap() != null) {
                throw new IllegalArgumentException("Preview image cannot be used when a bitmap is provided for the main image");
            }
            if (imageSource.getSWidth() <= 0 || imageSource.getSHeight() <= 0) {
                throw new IllegalArgumentException("Preview image cannot be used unless dimensions are provided for the main image");
            }
            this.sWidth = imageSource.getSWidth();
            this.sHeight = imageSource.getSHeight();
            this.pRegion = previewSource.getSRegion();
            if (previewSource.getBitmap() != null) {
                this.bitmapIsCached = previewSource.isCached();
                onPreviewLoaded(previewSource.getBitmap());
            } else {
                Uri uri = previewSource.getUri();
                if (uri == null && previewSource.getResource() != null) {
                    uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getContext().getPackageName() + "/" + previewSource.getResource());
                }
                BitmapLoadTask task = new BitmapLoadTask(this, getContext(), bitmapDecoderFactory, uri, true);
                execute(task);
            }
        }

        if (imageSource.getBitmap() != null && imageSource.getSRegion() != null) {
            onImageLoaded(Bitmap.createBitmap(imageSource.getBitmap(), imageSource.getSRegion().left, imageSource.getSRegion().top, imageSource.getSRegion().width(), imageSource.getSRegion().height()), ORIENTATION_0, false);
        } else if (imageSource.getBitmap() != null) {
            onImageLoaded(imageSource.getBitmap(), ORIENTATION_0, imageSource.isCached());
        } else {
            sRegion = imageSource.getSRegion();
            uri = imageSource.getUri();
            if (uri == null && imageSource.getResource() != null) {
                uri = Uri.parse(ContentResolver.SCHEME_ANDROID_RESOURCE + "://" + getContext().getPackageName() + "/" + imageSource.getResource());
            }
            if (imageSource.getTile() || sRegion != null) {
                // Load the bitmap using tile decoding.
                TilesInitTask task = new TilesInitTask(this, getContext(), regionDecoderFactory, uri);
                execute(task);
            } else {
                // Load the bitmap as a single image.
                BitmapLoadTask task = new BitmapLoadTask(this, getContext(), bitmapDecoderFactory, uri, false);
                execute(task);
            }
        }
    }

    /**
     * Reset all state before setting/changing image or setting new rotation.
     */
    private void reset(boolean newImage) {
        debug("reset newImage=" + newImage);
        scale = 0f;
        scaleStart = 0f;
        vTranslate = null;
        vTranslateStart = null;
        vTranslateBefore = null;
        pendingScale = 0f;
        sPendingCenter = null;
        sRequestedCenter = null;
        isZooming = false;
        isPanning = false;
        isQuickScaling = false;
        maxTouchCount = 0;
        fullImageSampleSize = 0;
        vCenterStart = null;
        vDistStart = 0;
        quickScaleLastDistance = 0f;
        quickScaleMoved = false;
        quickScaleSCenter = null;
        quickScaleVLastPoint = null;
        quickScaleVStart = null;
        anim = null;
        satTemp = null;
        matrix = null;
        sRect = null;
        if (newImage) {
            uri = null;
            decoderLock.writeLock().lock();
            try {
                if (decoder != null) {
                    decoder.recycle();
                    decoder = null;
                }
            } finally {
                decoderLock.writeLock().unlock();
            }
            if (bitmap != null && !bitmapIsCached) {
                bitmap.recycle();
            }
            if (bitmap != null && bitmapIsCached && onImageEventListener != null) {
                onImageEventListener.onPreviewReleased();
            }
            sWidth = 0;
            sHeight = 0;
            sOrientation = 0;
            sRegion = null;
            pRegion = null;
            readySent = false;
            imageLoadedSent = false;
            bitmap = null;
            bitmapIsPreview = false;
            bitmapIsCached = false;
        }
        if (tileMap != null) {
            for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {
                for (Tile tile : tileMapEntry.getValue()) {
                    tile.visible = false;
                    if (tile.bitmap != null) {
                        tile.bitmap.recycle();
                        tile.bitmap = null;
                    }
                }
            }
            tileMap = null;
        }
        setGestureDetector(getContext());
    }

    private void setGestureDetector(final Context context) {
        this.detector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {

            @Override
            public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                if (panEnabled && readySent && vTranslate != null && e1 != null && e2 != null && (Math.abs(e1.getX() - e2.getX()) > 50 || Math.abs(e1.getY() - e2.getY()) > 50) && (Math.abs(velocityX) > 500 || Math.abs(velocityY) > 500) && !isZooming) {
                    PointF vTranslateEnd = new PointF(vTranslate.x + (velocityX * 0.25f), vTranslate.y + (velocityY * 0.25f));
                    float sCenterXEnd = ((getWidth()/2) - vTranslateEnd.x)/scale;
                    float sCenterYEnd = ((getHeight()/2) - vTranslateEnd.y)/scale;
                    new AnimationBuilder(new PointF(sCenterXEnd, sCenterYEnd)).withEasing(EASE_OUT_QUAD).withPanLimited(false).withOrigin(ORIGIN_FLING).start();
                    return true;
                }
                return super.onFling(e1, e2, velocityX, velocityY);
            }

            @Override
            public boolean onSingleTapConfirmed(MotionEvent e) {
                performClick();
                return true;
            }

            @Override
            public boolean onDoubleTap(MotionEvent e) {
                if (zoomEnabled && readySent && vTranslate != null) {
                    // Hacky solution for #15 - after a double tap the GestureDetector gets in a state
                    // where the next fling is ignored, so here we replace it with a new one.
                    setGestureDetector(context);
                    if (quickScaleEnabled) {
                        // Store quick scale params. This will become either a double tap zoom or a
                        // quick scale depending on whether the user swipes.
                        vCenterStart = new PointF(e.getX(), e.getY());
                        vTranslateStart = new PointF(vTranslate.x, vTranslate.y);
                        scaleStart = scale;
                        isQuickScaling = true;
                        isZooming = true;
                        quickScaleLastDistance = -1F;
                        quickScaleSCenter = viewToSourceCoord(vCenterStart);
                        quickScaleVStart = new PointF(e.getX(), e.getY());
                        quickScaleVLastPoint = new PointF(quickScaleSCenter.x, quickScaleSCenter.y);
                        quickScaleMoved = false;
                        // We need to get events in onTouchEvent after this.
                        return false;
                    } else {
                        // Start double tap zoom animation.
                        doubleTapZoom(viewToSourceCoord(new PointF(e.getX(), e.getY())), new PointF(e.getX(), e.getY()));
                        return true;
                    }
                }
                return super.onDoubleTapEvent(e);
            }
        });

        singleDetector = new GestureDetector(context, new GestureDetector.SimpleOnGestureListener() {
            @Override
            public boolean onSingleTapConfirmed(MotionEvent e) {
                performClick();
                return true;
            }
        });
    }

    /**
     * On resize, preserve center and scale. Various behaviours are possible, override this method to use another.
     */
    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        debug("onSizeChanged %dx%d -> %dx%d", oldw, oldh, w, h);
        PointF sCenter = getCenter();
        if (readySent && sCenter != null) {
            this.anim = null;
            this.pendingScale = scale;
            this.sPendingCenter = sCenter;
        }
    }

    /**
     * Measures the width and height of the view, preserving the aspect ratio of the image displayed if wrap_content is
     * used. The image will scale within this box, not resizing the view as it is zoomed.
     */
    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);
        int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);
        int parentWidth = MeasureSpec.getSize(widthMeasureSpec);
        int parentHeight = MeasureSpec.getSize(heightMeasureSpec);
        boolean resizeWidth = widthSpecMode != MeasureSpec.EXACTLY;
        boolean resizeHeight = heightSpecMode != MeasureSpec.EXACTLY;
        int width = parentWidth;
        int height = parentHeight;
        if (sWidth > 0 && sHeight > 0) {
            if (resizeWidth && resizeHeight) {
                width = sWidth();
                height = sHeight();
            } else if (resizeHeight) {
                height = (int)((((double)sHeight()/(double)sWidth()) * width));
            } else if (resizeWidth) {
                width = (int)((((double)sWidth()/(double)sHeight()) * height));
            }
        }
        width = Math.max(width, getSuggestedMinimumWidth());
        height = Math.max(height, getSuggestedMinimumHeight());
        setMeasuredDimension(width, height);
    }

    /**
     * Handle touch events. One finger pans, and two finger pinch and zoom plus panning.
     */
    @Override
    public boolean onTouchEvent(@NonNull MotionEvent event) {
        // During non-interruptible anims, ignore all touch events
        if (anim != null && !anim.interruptible) {
            requestDisallowInterceptTouchEvent(true);
            return true;
        } else {
            if (anim != null && anim.listener != null) {
                try {
                    anim.listener.onInterruptedByUser();
                } catch (Exception e) {
                    Log.w(TAG, "Error thrown by animation listener", e);
                }
            }
            anim = null;
        }

        // Abort if not ready
        if (vTranslate == null) {
            if (singleDetector != null) {
                singleDetector.onTouchEvent(event);
            }
            return true;
        }
        // Detect flings, taps and double taps
        if (!isQuickScaling && (detector == null || detector.onTouchEvent(event))) {
            isZooming = false;
            isPanning = false;
            maxTouchCount = 0;
            return true;
        }

        if (vTranslateStart == null) { vTranslateStart = new PointF(0, 0); }
        if (vTranslateBefore == null) { vTranslateBefore = new PointF(0, 0); }
        if (vCenterStart == null) { vCenterStart = new PointF(0, 0); }

        // Store current values so we can send an event if they change
        float scaleBefore = scale;
        vTranslateBefore.set(vTranslate);

        boolean handled = onTouchEventInternal(event);
        sendStateChanged(scaleBefore, vTranslateBefore, ORIGIN_TOUCH);
        return handled || super.onTouchEvent(event);
    }

    @SuppressWarnings("deprecation")
    private boolean onTouchEventInternal(@NonNull MotionEvent event) {
        int touchCount = event.getPointerCount();
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_POINTER_1_DOWN:
            case MotionEvent.ACTION_POINTER_2_DOWN:
                anim = null;
                requestDisallowInterceptTouchEvent(true);
                maxTouchCount = Math.max(maxTouchCount, touchCount);
                if (touchCount >= 2) {
                    if (zoomEnabled) {
                        // Start pinch to zoom. Calculate distance between touch points and center point of the pinch.
                        float distance = distance(event.getX(0), event.getX(1), event.getY(0), event.getY(1));
                        scaleStart = scale;
                        vDistStart = distance;
                        vTranslateStart.set(vTranslate.x, vTranslate.y);
                        vCenterStart.set((event.getX(0) + event.getX(1))/2, (event.getY(0) + event.getY(1))/2);
                    } else {
                        // Abort all gestures on second touch
                        maxTouchCount = 0;
                    }
                    // Cancel long click timer
                    handler.removeMessages(MESSAGE_LONG_CLICK);
                } else if (!isQuickScaling) {
                    // Start one-finger pan
                    vTranslateStart.set(vTranslate.x, vTranslate.y);
                    vCenterStart.set(event.getX(), event.getY());

                    // Start long click timer
                    handler.sendEmptyMessageDelayed(MESSAGE_LONG_CLICK, 600);
                }
                return true;
            case MotionEvent.ACTION_MOVE:
                boolean consumed = false;
                if (maxTouchCount > 0) {
                    if (touchCount >= 2) {
                        // Calculate new distance between touch points, to scale and pan relative to start values.
                        float vDistEnd = distance(event.getX(0), event.getX(1), event.getY(0), event.getY(1));
                        float vCenterEndX = (event.getX(0) + event.getX(1))/2;
                        float vCenterEndY = (event.getY(0) + event.getY(1))/2;

                        if (zoomEnabled && (distance(vCenterStart.x, vCenterEndX, vCenterStart.y, vCenterEndY) > 5 || Math.abs(vDistEnd - vDistStart) > 5 || isPanning)) {
                            isZooming = true;
                            isPanning = true;
                            consumed = true;

                            double previousScale = scale;
                            scale = Math.min(maxScale, (vDistEnd / vDistStart) * scaleStart);

                            if (scale <= minScale()) {
                                // Minimum scale reached so don't pan. Adjust start settings so any expand will zoom in.
                                vDistStart = vDistEnd;
                                scaleStart = minScale();
                                vCenterStart.set(vCenterEndX, vCenterEndY);
                                vTranslateStart.set(vTranslate);
                            } else if (panEnabled) {
                                // Translate to place the source image coordinate that was at the center of the pinch at the start
                                // at the center of the pinch now, to give simultaneous pan + zoom.
                                float vLeftStart = vCenterStart.x - vTranslateStart.x;
                                float vTopStart = vCenterStart.y - vTranslateStart.y;
                                float vLeftNow = vLeftStart * (scale/scaleStart);
                                float vTopNow = vTopStart * (scale/scaleStart);
                                vTranslate.x = vCenterEndX - vLeftNow;
                                vTranslate.y = vCenterEndY - vTopNow;
                                if ((previousScale * sHeight() < getHeight() && scale * sHeight() >= getHeight()) || (previousScale * sWidth() < getWidth() && scale * sWidth() >= getWidth())) {
                                    fitToBounds(true);
                                    vCenterStart.set(vCenterEndX, vCenterEndY);
                                    vTranslateStart.set(vTranslate);
                                    scaleStart = scale;
                                    vDistStart = vDistEnd;
                                }
                            } else if (sRequestedCenter != null) {
                                // With a center specified from code, zoom around that point.
                                vTranslate.x = (getWidth()/2) - (scale * sRequestedCenter.x);
                                vTranslate.y = (getHeight()/2) - (scale * sRequestedCenter.y);
                            } else {
                                // With no requested center, scale around the image center.
                                vTranslate.x = (getWidth()/2) - (scale * (sWidth()/2));
                                vTranslate.y = (getHeight()/2) - (scale * (sHeight()/2));
                            }

                            fitToBounds(true);
                            refreshRequiredTiles(eagerLoadingEnabled);
                        }
                    } else if (isQuickScaling) {
                        // One finger zoom
                        // Stole Google's Magical Formula™ to make sure it feels the exact same
                        float dist = Math.abs(quickScaleVStart.y - event.getY()) * 2 + quickScaleThreshold;

                        if (quickScaleLastDistance == -1f) {
                            quickScaleLastDistance = dist;
                        }
                        boolean isUpwards = event.getY() > quickScaleVLastPoint.y;
                        quickScaleVLastPoint.set(0, event.getY());

                        float spanDiff = Math.abs(1 - (dist / quickScaleLastDistance)) * 0.5f;

                        if (spanDiff > 0.03f || quickScaleMoved) {
                            quickScaleMoved = true;

                            float multiplier = 1;
                            if (quickScaleLastDistance > 0) {
                                multiplier = isUpwards ? (1 + spanDiff) : (1 - spanDiff);
                            }

                            double previousScale = scale;
                            scale = Math.max(minScale(), Math.min(maxScale, scale * multiplier));

                            if (panEnabled) {
                                float vLeftStart = vCenterStart.x - vTranslateStart.x;
                                float vTopStart = vCenterStart.y - vTranslateStart.y;
                                float vLeftNow = vLeftStart * (scale/scaleStart);
                                float vTopNow = vTopStart * (scale/scaleStart);
                                vTranslate.x = vCenterStart.x - vLeftNow;
                                vTranslate.y = vCenterStart.y - vTopNow;
                                if ((previousScale * sHeight() < getHeight() && scale * sHeight() >= getHeight()) || (previousScale * sWidth() < getWidth() && scale * sWidth() >= getWidth())) {
                                    fitToBounds(true);
                                    vCenterStart.set(sourceToViewCoord(quickScaleSCenter));
                                    vTranslateStart.set(vTranslate);
                                    scaleStart = scale;
                                    dist = 0;
                                }
                            } else if (sRequestedCenter != null) {
                                // With a center specified from code, zoom around that point.
                                vTranslate.x = (getWidth()/2) - (scale * sRequestedCenter.x);
                                vTranslate.y = (getHeight()/2) - (scale * sRequestedCenter.y);
                            } else {
                                // With no requested center, scale around the image center.
                                vTranslate.x = (getWidth()/2) - (scale * (sWidth()/2));
                                vTranslate.y = (getHeight()/2) - (scale * (sHeight()/2));
                            }
                        }

                        quickScaleLastDistance = dist;

                        fitToBounds(true);
                        refreshRequiredTiles(eagerLoadingEnabled);

                        consumed = true;
                    } else if (!isZooming) {
                        // One finger pan - translate the image. We do this calculation even with pan disabled so click
                        // and long click behaviour is preserved.
                        float dx = Math.abs(event.getX() - vCenterStart.x);
                        float dy = Math.abs(event.getY() - vCenterStart.y);

                        //On the Samsung S6 long click event does not work, because the dx > 5 usually true
                        float offset = density * 5;
                        if (dx > offset || dy > offset || isPanning) {
                            consumed = true;
                            vTranslate.x = vTranslateStart.x + (event.getX() - vCenterStart.x);
                            vTranslate.y = vTranslateStart.y + (event.getY() - vCenterStart.y);

                            float lastX = vTranslate.x;
                            float lastY = vTranslate.y;
                            fitToBounds(true);
                            boolean atXEdge = lastX != vTranslate.x;
                            boolean atYEdge = lastY != vTranslate.y;
                            boolean edgeXSwipe = atXEdge && dx > dy && !isPanning;
                            boolean edgeYSwipe = atYEdge && dy > dx && !isPanning;
                            boolean yPan = lastY == vTranslate.y && dy > offset * 3;
                            if (!edgeXSwipe && !edgeYSwipe && (!atXEdge || !atYEdge || yPan || isPanning)) {
                                isPanning = true;
                            } else if (dx > offset || dy > offset) {
                                // Haven't panned the image, and we're at the left or right edge. Switch to page swipe.
                                maxTouchCount = 0;
                                handler.removeMessages(MESSAGE_LONG_CLICK);
                                requestDisallowInterceptTouchEvent(false);
                            }
                            if (!panEnabled) {
                                vTranslate.x = vTranslateStart.x;
                                vTranslate.y = vTranslateStart.y;
                                requestDisallowInterceptTouchEvent(false);
                            }

                            refreshRequiredTiles(eagerLoadingEnabled);
                        }
                    }
                }
                if (consumed) {
                    handler.removeMessages(MESSAGE_LONG_CLICK);
                    invalidate();
                    return true;
                }
                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_POINTER_UP:
            case MotionEvent.ACTION_POINTER_2_UP:
                handler.removeMessages(MESSAGE_LONG_CLICK);
                if (isQuickScaling) {
                    isQuickScaling = false;
                    if (!quickScaleMoved) {
                        doubleTapZoom(quickScaleSCenter, vCenterStart);
                    }
                }
                if (maxTouchCount > 0 && (isZooming || isPanning)) {
                    if (isZooming && touchCount == 2) {
                        // Convert from zoom to pan with remaining touch
                        isPanning = true;
                        vTranslateStart.set(vTranslate.x, vTranslate.y);
                        if (event.getActionIndex() == 1) {
                            vCenterStart.set(event.getX(0), event.getY(0));
                        } else {
                            vCenterStart.set(event.getX(1), event.getY(1));
                        }
                    }
                    if (touchCount < 3) {
                        // End zooming when only one touch point
                        isZooming = false;
                    }
                    if (touchCount < 2) {
                        // End panning when no touch points
                        isPanning = false;
                        maxTouchCount = 0;
                    }
                    // Trigger load of tiles now required
                    refreshRequiredTiles(true);
                    return true;
                }
                if (touchCount == 1) {
                    isZooming = false;
                    isPanning = false;
                    maxTouchCount = 0;
                }
                return true;
        }
        return false;
    }

    private void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {
        ViewParent parent = getParent();
        if (parent != null) {
            parent.requestDisallowInterceptTouchEvent(disallowIntercept);
        }
    }

    /**
     * Double tap zoom handler triggered from gesture detector or on touch, depending on whether
     * quick scale is enabled.
     */
    private void doubleTapZoom(PointF sCenter, PointF vFocus) {
        if (!panEnabled) {
            if (sRequestedCenter != null) {
                // With a center specified from code, zoom around that point.
                sCenter.x = sRequestedCenter.x;
                sCenter.y = sRequestedCenter.y;
            } else {
                // With no requested center, scale around the image center.
                sCenter.x = sWidth()/2;
                sCenter.y = sHeight()/2;
            }
        }
        float doubleTapZoomScale = Math.min(maxScale, SubsamplingScaleImageView.this.doubleTapZoomScale);
        boolean zoomIn = (scale <= doubleTapZoomScale * 0.9) || scale == minScale;
        float targetScale = zoomIn ? doubleTapZoomScale : minScale();
        if (doubleTapZoomStyle == ZOOM_FOCUS_CENTER_IMMEDIATE) {
            setScaleAndCenter(targetScale, sCenter);
        } else if (doubleTapZoomStyle == ZOOM_FOCUS_CENTER || !zoomIn || !panEnabled) {
            new AnimationBuilder(targetScale, sCenter).withInterruptible(false).withDuration(doubleTapZoomDuration).withOrigin(ORIGIN_DOUBLE_TAP_ZOOM).start();
        } else if (doubleTapZoomStyle == ZOOM_FOCUS_FIXED) {
            new AnimationBuilder(targetScale, sCenter, vFocus).withInterruptible(false).withDuration(doubleTapZoomDuration).withOrigin(ORIGIN_DOUBLE_TAP_ZOOM).start();
        }
        invalidate();
    }

    /**
     * Draw method should not be called until the view has dimensions so the first calls are used as triggers to calculate
     * the scaling and tiling required. Once the view is setup, tiles are displayed as they are loaded.
     */
    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        createPaints();

        // If image or view dimensions are not known yet, abort.
        if (sWidth == 0 || sHeight == 0 || getWidth() == 0 || getHeight() == 0) {
            return;
        }

        // When using tiles, on first render with no tile map ready, initialise it and kick off async base image loading.
        if (tileMap == null && decoder != null) {
            initialiseBaseLayer(getMaxBitmapDimensions(canvas));
        }

        // If image has been loaded or supplied as a bitmap, onDraw may be the first time the view has
        // dimensions and therefore the first opportunity to set scale and translate. If this call returns
        // false there is nothing to be drawn so return immediately.
        if (!checkReady()) {
            return;
        }

        // Set scale and translate before draw.
        preDraw();

        // If animating scale, calculate current scale and center with easing equations
        if (anim != null && anim.vFocusStart != null) {
            // Store current values so we can send an event if they change
            float scaleBefore = scale;
            if (vTranslateBefore == null) { vTranslateBefore = new PointF(0, 0); }
            vTranslateBefore.set(vTranslate);

            long scaleElapsed = System.currentTimeMillis() - anim.time;
            boolean finished = scaleElapsed > anim.duration;
            scaleElapsed = Math.min(scaleElapsed, anim.duration);
            scale = ease(anim.easing, scaleElapsed, anim.scaleStart, anim.scaleEnd - anim.scaleStart, anim.duration);

            // Apply required animation to the focal point
            float vFocusNowX = ease(anim.easing, scaleElapsed, anim.vFocusStart.x, anim.vFocusEnd.x - anim.vFocusStart.x, anim.duration);
            float vFocusNowY = ease(anim.easing, scaleElapsed, anim.vFocusStart.y, anim.vFocusEnd.y - anim.vFocusStart.y, anim.duration);
            // Find out where the focal point is at this scale and adjust its position to follow the animation path
            vTranslate.x -= sourceToViewX(anim.sCenterEnd.x) - vFocusNowX;
            vTranslate.y -= sourceToViewY(anim.sCenterEnd.y) - vFocusNowY;

            // For translate anims, showing the image non-centered is never allowed, for scaling anims it is during the animation.
            fitToBounds(finished || (anim.scaleStart == anim.scaleEnd));
            sendStateChanged(scaleBefore, vTranslateBefore, anim.origin);
            refreshRequiredTiles(finished);
            if (finished) {
                if (anim.listener != null) {
                    try {
                        anim.listener.onComplete();
                    } catch (Exception e) {
                        Log.w(TAG, "Error thrown by animation listener", e);
                    }
                }
                anim = null;
            }
            invalidate();
        }

        if (tileMap != null && isBaseLayerReady()) {

            // Optimum sample size for current scale
            int sampleSize = Math.min(fullImageSampleSize, calculateInSampleSize(scale));

            // First check for missing tiles - if there are any we need the base layer underneath to avoid gaps
            boolean hasMissingTiles = false;
            for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {
                if (tileMapEntry.getKey() == sampleSize) {
                    for (Tile tile : tileMapEntry.getValue()) {
                        if (tile.visible && (tile.loading || tile.bitmap == null)) {
                            hasMissingTiles = true;
                        }
                    }
                }
            }

            // Render all loaded tiles. LinkedHashMap used for bottom up rendering - lower res tiles underneath.
            for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {
                if (tileMapEntry.getKey() == sampleSize || hasMissingTiles) {
                    for (Tile tile : tileMapEntry.getValue()) {
                        sourceToViewRect(tile.sRect, tile.vRect);
                        if (!tile.loading && tile.bitmap != null) {
                            if (tileBgPaint != null) {
                                canvas.drawRect(tile.vRect, tileBgPaint);
                            }
                            if (matrix == null) { matrix = new Matrix(); }
                            matrix.reset();
                            setMatrixArray(srcArray, 0, 0, tile.bitmap.getWidth(), 0, tile.bitmap.getWidth(), tile.bitmap.getHeight(), 0, tile.bitmap.getHeight());
                            if (getRequiredRotation() == ORIENTATION_0) {
                                setMatrixArray(dstArray, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, tile.vRect.bottom);
                            } else if (getRequiredRotation() == ORIENTATION_90) {
                                setMatrixArray(dstArray, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, tile.vRect.bottom, tile.vRect.left, tile.vRect.top);
                            } else if (getRequiredRotation() == ORIENTATION_180) {
                                setMatrixArray(dstArray, tile.vRect.right, tile.vRect.bottom, tile.vRect.left, tile.vRect.bottom, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top);
                            } else if (getRequiredRotation() == ORIENTATION_270) {
                                setMatrixArray(dstArray, tile.vRect.left, tile.vRect.bottom, tile.vRect.left, tile.vRect.top, tile.vRect.right, tile.vRect.top, tile.vRect.right, tile.vRect.bottom);
                            }
                            matrix.setPolyToPoly(srcArray, 0, dstArray, 0, 4);
                            canvas.drawBitmap(tile.bitmap, matrix, bitmapPaint);
                            if (debug) {
                                canvas.drawRect(tile.vRect, debugLinePaint);
                            }
                        } else if (tile.loading && debug) {
                            canvas.drawText("LOADING", tile.vRect.left + px(5), tile.vRect.top + px(35), debugTextPaint);
                        }
                        if (tile.visible && debug) {
                            canvas.drawText("ISS " + tile.sampleSize + " RECT " + tile.sRect.top + "," + tile.sRect.left + "," + tile.sRect.bottom + "," + tile.sRect.right, tile.vRect.left + px(5), tile.vRect.top + px(15), debugTextPaint);
                        }
                    }
                }
            }

        } else if (bitmap != null && !bitmap.isRecycled()) {

            float xScale = scale, yScale = scale;
            if (bitmapIsPreview) {
                xScale = scale * ((float)sWidth/bitmap.getWidth());
                yScale = scale * ((float)sHeight/bitmap.getHeight());
            }

            if (matrix == null) { matrix = new Matrix(); }
            matrix.reset();
            matrix.postScale(xScale, yScale);
            matrix.postRotate(getRequiredRotation());
            matrix.postTranslate(vTranslate.x, vTranslate.y);

            if (getRequiredRotation() == ORIENTATION_180) {
                matrix.postTranslate(scale * sWidth, scale * sHeight);
            } else if (getRequiredRotation() == ORIENTATION_90) {
                matrix.postTranslate(scale * sHeight, 0);
            } else if (getRequiredRotation() == ORIENTATION_270) {
                matrix.postTranslate(0, scale * sWidth);
            }

            if (tileBgPaint != null) {
                if (sRect == null) { sRect = new RectF(); }
                sRect.set(0f, 0f, bitmapIsPreview ? bitmap.getWidth() : sWidth, bitmapIsPreview ? bitmap.getHeight() : sHeight);
                matrix.mapRect(sRect);
                canvas.drawRect(sRect, tileBgPaint);
            }
            canvas.drawBitmap(bitmap, matrix, bitmapPaint);

        }

        if (debug) {
            canvas.drawText("Scale: " + String.format(Locale.ENGLISH, "%.2f", scale) + " (" + String.format(Locale.ENGLISH, "%.2f", minScale()) + " - " + String.format(Locale.ENGLISH, "%.2f", maxScale) + ")", px(5), px(15), debugTextPaint);
            canvas.drawText("Translate: " + String.format(Locale.ENGLISH, "%.2f", vTranslate.x) + ":" + String.format(Locale.ENGLISH, "%.2f", vTranslate.y), px(5), px(30), debugTextPaint);
            PointF center = getCenter();
            //noinspection ConstantConditions
            canvas.drawText("Source center: " + String.format(Locale.ENGLISH, "%.2f", center.x) + ":" + String.format(Locale.ENGLISH, "%.2f", center.y), px(5), px(45), debugTextPaint);
            if (anim != null) {
                PointF vCenterStart = sourceToViewCoord(anim.sCenterStart);
                PointF vCenterEndRequested = sourceToViewCoord(anim.sCenterEndRequested);
                PointF vCenterEnd = sourceToViewCoord(anim.sCenterEnd);
                //noinspection ConstantConditions
                canvas.drawCircle(vCenterStart.x, vCenterStart.y, px(10), debugLinePaint);
                debugLinePaint.setColor(Color.RED);
                //noinspection ConstantConditions
                canvas.drawCircle(vCenterEndRequested.x, vCenterEndRequested.y, px(20), debugLinePaint);
                debugLinePaint.setColor(Color.BLUE);
                //noinspection ConstantConditions
                canvas.drawCircle(vCenterEnd.x, vCenterEnd.y, px(25), debugLinePaint);
                debugLinePaint.setColor(Color.CYAN);
                canvas.drawCircle(getWidth() / 2, getHeight() / 2, px(30), debugLinePaint);
            }
            if (vCenterStart != null) {
                debugLinePaint.setColor(Color.RED);
                canvas.drawCircle(vCenterStart.x, vCenterStart.y, px(20), debugLinePaint);
            }
            if (quickScaleSCenter != null) {
                debugLinePaint.setColor(Color.BLUE);
                canvas.drawCircle(sourceToViewX(quickScaleSCenter.x), sourceToViewY(quickScaleSCenter.y), px(35), debugLinePaint);
            }
            if (quickScaleVStart != null && isQuickScaling) {
                debugLinePaint.setColor(Color.CYAN);
                canvas.drawCircle(quickScaleVStart.x, quickScaleVStart.y, px(30), debugLinePaint);
            }
            debugLinePaint.setColor(Color.MAGENTA);
        }
    }

    /**
     * Helper method for setting the values of a tile matrix array.
     */
    private void setMatrixArray(float[] array, float f0, float f1, float f2, float f3, float f4, float f5, float f6, float f7) {
        array[0] = f0;
        array[1] = f1;
        array[2] = f2;
        array[3] = f3;
        array[4] = f4;
        array[5] = f5;
        array[6] = f6;
        array[7] = f7;
    }

    /**
     * Checks whether the base layer of tiles or full size bitmap is ready.
     */
    private boolean isBaseLayerReady() {
        if (bitmap != null && !bitmapIsPreview) {
            return true;
        } else if (tileMap != null) {
            boolean baseLayerReady = true;
            for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {
                if (tileMapEntry.getKey() == fullImageSampleSize) {
                    for (Tile tile : tileMapEntry.getValue()) {
                        if (tile.loading || tile.bitmap == null) {
                            baseLayerReady = false;
                        }
                    }
                }
            }
            return baseLayerReady;
        }
        return false;
    }

    /**
     * Check whether view and image dimensions are known and either a preview, full size image or
     * base layer tiles are loaded. First time, send ready event to listener. The next draw will
     * display an image.
     */
    private boolean checkReady() {
        boolean ready = getWidth() > 0 && getHeight() > 0 && sWidth > 0 && sHeight > 0 && (bitmap != null || isBaseLayerReady());
        if (!readySent && ready) {
            preDraw();
            readySent = true;
            onReady();
            if (onImageEventListener != null) {
                onImageEventListener.onReady();
            }
        }
        return ready;
    }

    /**
     * Check whether either the full size bitmap or base layer tiles are loaded. First time, send image
     * loaded event to listener.
     */
    private boolean checkImageLoaded() {
        boolean imageLoaded = isBaseLayerReady();
        if (!imageLoadedSent && imageLoaded) {
            preDraw();
            imageLoadedSent = true;
            onImageLoaded();
            if (onImageEventListener != null) {
                onImageEventListener.onImageLoaded();
            }
        }
        return imageLoaded;
    }

    /**
     * Creates Paint objects once when first needed.
     */
    private void createPaints() {
        if (bitmapPaint == null) {
            bitmapPaint = new Paint();
            bitmapPaint.setAntiAlias(true);
            bitmapPaint.setFilterBitmap(true);
            bitmapPaint.setDither(true);
        }
        if ((debugTextPaint == null || debugLinePaint == null) && debug) {
            debugTextPaint = new Paint();
            debugTextPaint.setTextSize(px(12));
            debugTextPaint.setColor(Color.MAGENTA);
            debugTextPaint.setStyle(Style.FILL);
            debugLinePaint = new Paint();
            debugLinePaint.setColor(Color.MAGENTA);
            debugLinePaint.setStyle(Style.STROKE);
            debugLinePaint.setStrokeWidth(px(1));
        }
    }

    /**
     * Called on first draw when the view has dimensions. Calculates the initial sample size and starts async loading of
     * the base layer image - the whole source subsampled as necessary.
     */
    private synchronized void initialiseBaseLayer(@NonNull Point maxTileDimensions) {
        debug("initialiseBaseLayer maxTileDimensions=%dx%d", maxTileDimensions.x, maxTileDimensions.y);

        satTemp = new ScaleAndTranslate(0f, new PointF(0, 0));
        fitToBounds(true, satTemp);

        // Load double resolution - next level will be split into four tiles and at the center all four are required,
        // so don't bother with tiling until the next level 16 tiles are needed.
        fullImageSampleSize = calculateInSampleSize(satTemp.scale);
        if (fullImageSampleSize > 1) {
            fullImageSampleSize /= 2;
        }

        if (fullImageSampleSize == 1 && sRegion == null && sWidth() < maxTileDimensions.x && sHeight() < maxTileDimensions.y) {

            // Whole image is required at native resolution, and is smaller than the canvas max bitmap size.
            // Use BitmapDecoder for better image support.
            decoder.recycle();
            decoder = null;
            BitmapLoadTask task = new BitmapLoadTask(this, getContext(), bitmapDecoderFactory, uri, false);
            execute(task);

        } else {

            initialiseTileMap(maxTileDimensions);

            List<Tile> baseGrid = tileMap.get(fullImageSampleSize);
            for (Tile baseTile : baseGrid) {
                TileLoadTask task = new TileLoadTask(this, decoder, baseTile);
                execute(task);
            }
            refreshRequiredTiles(true);

        }

    }

    /**
     * Loads the optimum tiles for display at the current scale and translate, so the screen can be filled with tiles
     * that are at least as high resolution as the screen. Frees up bitmaps that are now off the screen.
     * @param load Whether to load the new tiles needed. Use false while scrolling/panning for performance.
     */
    private void refreshRequiredTiles(boolean load) {
        if (decoder == null || tileMap == null) { return; }

        int sampleSize = Math.min(fullImageSampleSize, calculateInSampleSize(scale));

        // Load tiles of the correct sample size that are on screen. Discard tiles off screen, and those that are higher
        // resolution than required, or lower res than required but not the base layer, so the base layer is always present.
        for (Map.Entry<Integer, List<Tile>> tileMapEntry : tileMap.entrySet()) {
            for (Tile tile : tileMapEntry.getValue()) {
                if (tile.sampleSize < sampleSize || (tile.sampleSize > sampleSize && tile.sampleSize != fullImageSampleSize)) {
                    tile.visible = false;
                    if (tile.bitmap != null) {
                        tile.bitmap.recycle();
                        tile.bitmap = null;
                    }
                }
                if (tile.sampleSize == sampleSize) {
                    if (tileVisible(tile)) {
                        tile.visible = true;
                        if (!tile.loading && tile.bitmap == null && load) {
                            TileLoadTask task = new TileLoadTask(this, decoder, tile);
                            execute(task);
                        }
                    } else if (tile.sampleSize != fullImageSampleSize) {
                        tile.visible = false;
                        if (tile.bitmap != null) {
                            tile.bitmap.recycle();
                            tile.bitmap = null;
                        }
                    }
                } else if (tile.sampleSize == fullImageSampleSize) {
                    tile.visible = true;
                }
            }
        }

    }

    /**
     * Determine whether tile is visible.
     */
    private boolean tileVisible(Tile tile) {
        float sVisLeft = viewToSourceX(0),
            sVisRight = viewToSourceX(getWidth()),
            sVisTop = viewToSourceY(0),
            sVisBottom = viewToSourceY(getHeight());
        return !(sVisLeft > tile.sRect.right || tile.sRect.left > sVisRight || sVisTop > tile.sRect.bottom || tile.sRect.top > sVisBottom);
    }

    /**
     * Sets scale and translate ready for the next draw.
     */
    private void preDraw() {
        if (getWidth() == 0 || getHeight() == 0 || sWidth <= 0 || sHeight <= 0) {
            return;
        }

        // If waiting to translate to new center position, set translate now
        if (sPendingCenter != null && pendingScale != null) {
            scale = pendingScale;
            if (vTranslate == null) {
                vTranslate = new PointF();
            }
            vTranslate.x = (getWidth()/2) - (scale * sPendingCenter.x);
            vTranslate.y = (getHeight()/2) - (scale * sPendingCenter.y);
            sPendingCenter = null;
            pendingScale = null;
            fitToBounds(true);
            refreshRequiredTiles(true);
        }

        // On first display of base image set up position, and in other cases make sure scale is correct.
        fitToBounds(false);
    }

    /**
     * Calculates sample size to fit the source image in given bounds.
     */
    private int calculateInSampleSize(float scale) {
        if (minimumTileDpi > 0) {
            DisplayMetrics metrics = getResources().getDisplayMetrics();
            float averageDpi = (metrics.xdpi + metrics.ydpi)/2;
            scale = (minimumTileDpi/averageDpi) * scale;
        }

        int reqWidth = (int)(sWidth() * scale);
        int reqHeight = (int)(sHeight() * scale);

        // Raw height and width of image
        int inSampleSize = 1;
        if (reqWidth == 0 || reqHeight == 0) {
            return 32;
        }

        if (sHeight() > reqHeight || sWidth() > reqWidth) {

            // Calculate ratios of height and width to requested height and width
            final int heightRatio = Math.round((float) sHeight() / (float) reqHeight);
            final int widthRatio = Math.round((float) sWidth() / (float) reqWidth);

            // Choose the smallest ratio as inSampleSize value, this will guarantee
            // a final image with both dimensions larger than or equal to the
            // requested height and width.
            inSampleSize = heightRatio < widthRatio ? heightRatio : widthRatio;
        }

        // We want the actual sample size that will be used, so round down to nearest power of 2.
        int power = 1;
        while (power * 2 < inSampleSize) {
            power = power * 2;
        }

        return power;
    }

    /**
     * Adjusts hypothetical future scale and translate values to keep scale within the allowed range and the image on screen. Minimum scale
     * is set so one dimension fills the view and the image is centered on the other dimension. Used to calculate what the target of an
     * animation should be.
     * @param center Whether the image should be centered in the dimension it's too small to fill. While animating this can be false to avoid changes in direction as bounds are reached.
     * @param sat The scale we want and the translation we're aiming for. The values are adjusted to be valid.
     */
    private void fitToBounds(boolean center, ScaleAndTranslate sat) {
        if (panLimit == PAN_LIMIT_OUTSIDE && isReady()) {
            center = false;
        }

        PointF vTranslate = sat.vTranslate;
        float scale = limitedScale(sat.scale);
        float scaleWidth = scale * sWidth();
        float scaleHeight = scale * sHeight();

        if (panLimit == PAN_LIMIT_CENTER && isReady()) {
            vTranslate.x = Math.max(vTranslate.x, getWidth()/2 - scaleWidth);
            vTranslate.y = Math.max(vTranslate.y, getHeight()/2 - scaleHeight);
        } else if (center) {
            vTranslate.x = Math.max(vTranslate.x, getWidth() - scaleWidth);
            vTranslate.y = Math.max(vTranslate.y, getHeight() - scaleHeight);
        } else {
            vTranslate.x = Math.max(vTranslate.x, -scaleWidth);
            vTranslate.y = Math.max(vTranslate.y, -scaleHeight);
        }

        // Asymmetric padding adjustments
        float xPaddingRatio = getPaddingLeft() > 0 || getPaddingRight() > 0 ? getPaddingLeft()/(float)(getPaddingLeft() + getPaddingRight()) : 0.5f;
        float yPaddingRatio = getPaddingTop() > 0 || getPaddingBottom() > 0 ? getPaddingTop()/(float)(getPaddingTop() + getPaddingBottom()) : 0.5f;

        float maxTx;
        float maxTy;
        if (panLimit == PAN_LIMIT_CENTER && isReady()) {
            maxTx = Math.max(0, getWidth()/2);
            maxTy = Math.max(0, getHeight()/2);
        } else if (center) {
            maxTx = Math.max(0, (getWidth() - scaleWidth) * xPaddingRatio);
            maxTy = Math.max(0, (getHeight() - scaleHeight) * yPaddingRatio);
        } else {
            maxTx = Math.max(0, getWidth());
            maxTy = Math.max(0, getHeight());
        }

        vTranslate.x = Math.min(vTranslate.x, maxTx);
        vTranslate.y = Math.min(vTranslate.y, maxTy);

        sat.scale = scale;
    }

    /**
     * Adjusts current scale and translate values to keep scale within the allowed range and the image on screen. Minimum scale
     * is set so one dimension fills the view and the image is centered on the other dimension.
     * @param center Whether the image should be centered in the dimension it's too small to fill. While animating this can be false to avoid changes in direction as bounds are reached.
     */
    private void fitToBounds(boolean center) {
        boolean init = false;
        if (vTranslate == null) {
            init = true;
            vTranslate = new PointF(0, 0);
        }
        if (satTemp == null) {
            satTemp = new ScaleAndTranslate(0, new PointF(0, 0));
        }
        satTemp.scale = scale;
        satTemp.vTranslate.set(vTranslate);
        fitToBounds(center, satTemp);
        scale = satTemp.scale;
        vTranslate.set(satTemp.vTranslate);
        if (init && minimumScaleType != SCALE_TYPE_START) {
            vTranslate.set(vTranslateForSCenter(sWidth()/2, sHeight()/2, scale));
        }
    }

    /**
     * Once source image and view dimensions are known, creates a map of sample size to tile grid.
     */
    private void initialiseTileMap(Point maxTileDimensions) {
        debug("initialiseTileMap maxTileDimensions=%dx%d", maxTileDimensions.x, maxTileDimensions.y);
        this.tileMap = new LinkedHashMap<>();
        int sampleSize = fullImageSampleSize;
        int xTiles = 1;
        int yTiles = 1;
        while (true) {
            int sTileWidth = sWidth()/xTiles;
            int sTileHeight = sHeight()/yTiles;
            int subTileWidth = sTileWidth/sampleSize;
            int subTileHeight = sTileHeight/sampleSize;
            while (subTileWidth + xTiles + 1 > maxTileDimensions.x || (subTileWidth > getWidth() * 1.25 && sampleSize < fullImageSampleSize)) {
                xTiles += 1;
                sTileWidth = sWidth()/xTiles;
                subTileWidth = sTileWidth/sampleSize;
            }
            while (subTileHeight + yTiles + 1 > maxTileDimensions.y || (subTileHeight > getHeight() * 1.25 && sampleSize < fullImageSampleSize)) {
                yTiles += 1;
                sTileHeight = sHeight()/yTiles;
                subTileHeight = sTileHeight/sampleSize;
            }
            List<Tile> tileGrid = new ArrayList<>(xTiles * yTiles);
            for (int x = 0; x < xTiles; x++) {
                for (int y = 0; y < yTiles; y++) {
                    Tile tile = new Tile();
                    tile.sampleSize = sampleSize;
                    tile.visible = sampleSize == fullImageSampleSize;
                    tile.sRect = new Rect(
                        x * sTileWidth,
                        y * sTileHeight,
                        x == xTiles - 1 ? sWidth() : (x + 1) * sTileWidth,
                        y == yTiles - 1 ? sHeight() : (y + 1) * sTileHeight
                    );
                    tile.vRect = new Rect(0, 0, 0, 0);
                    tile.fileSRect = new Rect(tile.sRect);
                    tileGrid.add(tile);
                }
            }
            tileMap.put(sampleSize, tileGrid);
            if (sampleSize == 1) {
                break;
            } else {
                sampleSize /= 2;
            }
        }
    }

    /**
     * Async task used to get image details without blocking the UI thread.
     */
    private static class TilesInitTask extends AsyncTask<Void, Void, int[]> {
        private final WeakReference<SubsamplingScaleImageView> viewRef;
        private final WeakReference<Context> contextRef;
        private final WeakReference<DecoderFactory<? extends ImageRegionDecoder>> decoderFactoryRef;
        private final Uri source;
        private ImageRegionDecoder decoder;
        private Exception exception;

        TilesInitTask(SubsamplingScaleImageView view, Context context, DecoderFactory<? extends ImageRegionDecoder> decoderFactory, Uri source) {
            this.viewRef = new WeakReference<>(view);
            this.contextRef = new WeakReference<>(context);
            this.decoderFactoryRef = new WeakReference<DecoderFactory<? extends ImageRegionDecoder>>(decoderFactory);
            this.source = source;
        }

        @Override
        protected int[] doInBackground(Void... params) {
            try {
                String sourceUri = source.toString();
                Context context = contextRef.get();
                DecoderFactory<? extends ImageRegionDecoder> decoderFactory = decoderFactoryRef.get();
                SubsamplingScaleImageView view = viewRef.get();
                if (context != null && decoderFactory != null && view != null) {
                    view.debug("TilesInitTask.doInBackground");
                    decoder = decoderFactory.make();
                    Point dimensions = decoder.init(context, source);
                    int sWidth = dimensions.x;
                    int sHeight = dimensions.y;
                    int exifOrientation = view.getExifOrientation(context, sourceUri);
                    if (view.sRegion != null) {
                        view.sRegion.left = Math.max(0, view.sRegion.left);
                        view.sRegion.top = Math.max(0, view.sRegion.top);
                        view.sRegion.right = Math.min(sWidth, view.sRegion.right);
                        view.sRegion.bottom = Math.min(sHeight, view.sRegion.bottom);
                        sWidth = view.sRegion.width();
                        sHeight = view.sRegion.height();
                    }
                    return new int[] { sWidth, sHeight, exifOrientation };
                }
            } catch (Exception e) {
                Log.e(TAG, "Failed to initialise bitmap decoder", e);
                this.exception = e;
            }
            return null;
        }

        @Override
        protected void onPostExecute(int[] xyo) {
            final SubsamplingScaleImageView view = viewRef.get();
            if (view != null) {
                if (decoder != null && xyo != null && xyo.length == 3) {
                    view.onTilesInited(decoder, xyo[0], xyo[1], xyo[2]);
                } else if (exception != null && view.onImageEventListener != null) {
                    view.onImageEventListener.onImageLoadError(exception);
                }
            }
        }
    }

    /**
     * Called by worker task when decoder is ready and image size and EXIF orientation is known.
     */
    private synchronized void onTilesInited(ImageRegionDecoder decoder, int sWidth, int sHeight, int sOrientation) {
        debug("onTilesInited sWidth=%d, sHeight=%d, sOrientation=%d", sWidth, sHeight, orientation);
        // If actual dimensions don't match the declared size, reset everything.
        if (this.sWidth > 0 && this.sHeight > 0 && (this.sWidth != sWidth || this.sHeight != sHeight)) {
            reset(false);
            if (bitmap != null) {
                if (!bitmapIsCached) {
                    bitmap.recycle();
                }
                bitmap = null;
                if (onImageEventListener != null && bitmapIsCached) {
                    onImageEventListener.onPreviewReleased();
                }
                bitmapIsPreview = false;
                bitmapIsCached = false;
            }
        }
        this.decoder = decoder;
        this.sWidth = sWidth;
        this.sHeight = sHeight;
        this.sOrientation = sOrientation;
        checkReady();
        if (!checkImageLoaded() && maxTileWidth > 0 && maxTileWidth != TILE_SIZE_AUTO && maxTileHeight > 0 && maxTileHeight != TILE_SIZE_AUTO && getWidth() > 0 && getHeight() > 0) {
            initialiseBaseLayer(new Point(maxTileWidth, maxTileHeight));
        }
        invalidate();
        requestLayout();
    }

    /**
     * Async task used to load images without blocking the UI thread.
     */
    private static class TileLoadTask extends AsyncTask<Void, Void, Bitmap> {
        private final WeakReference<SubsamplingScaleImageView> viewRef;
        private final WeakReference<ImageRegionDecoder> decoderRef;
        private final WeakReference<Tile> tileRef;
        private Exception exception;

        TileLoadTask(SubsamplingScaleImageView view, ImageRegionDecoder decoder, Tile tile) {
            this.viewRef = new WeakReference<>(view);
            this.decoderRef = new WeakReference<>(decoder);
            this.tileRef = new WeakReference<>(tile);
            tile.loading = true;
        }

        @Override
        protected Bitmap doInBackground(Void... params) {
            try {
                SubsamplingScaleImageView view = viewRef.get();
                ImageRegionDecoder decoder = decoderRef.get();
                Tile tile = tileRef.get();
                if (decoder != null && tile != null && view != null && decoder.isReady() && tile.visible) {
                    view.debug("TileLoadTask.doInBackground, tile.sRect=%s, tile.sampleSize=%d", tile.sRect, tile.sampleSize);
                    view.decoderLock.readLock().lock();
                    try {
                        if (decoder.isReady()) {
                            // Update tile's file sRect according to rotation
                            view.fileSRect(tile.sRect, tile.fileSRect);
                            if (view.sRegion != null) {
                                tile.fileSRect.offset(view.sRegion.left, view.sRegion.top);
                            }
                            return decoder.decodeRegion(tile.fileSRect, tile.sampleSize);
                        } else {
                            tile.loading = false;
                        }
                    } finally {
                        view.decoderLock.readLock().unlock();
                    }
                } else if (tile != null) {
                    tile.loading = false;
                }
            } catch (Exception e) {
                Log.e(TAG, "Failed to decode tile", e);
                this.exception = e;
            } catch (OutOfMemoryError e) {
                Log.e(TAG, "Failed to decode tile - OutOfMemoryError", e);
                this.exception = new RuntimeException(e);
            }
            return null;
        }

        @Override
        protected void onPostExecute(Bitmap bitmap) {
            final SubsamplingScaleImageView subsamplingScaleImageView = viewRef.get();
            final Tile tile = tileRef.get();
            if (subsamplingScaleImageView != null && tile != null) {
                if (bitmap != null) {
                    tile.bitmap = bitmap;
                    tile.loading = false;
                    subsamplingScaleImageView.onTileLoaded();
                } else if (exception != null && subsamplingScaleImageView.onImageEventListener != null) {
                    subsamplingScaleImageView.onImageEventListener.onTileLoadError(exception);
                }
            }
        }
    }

    /**
     * Called by worker task when a tile has loaded. Redraws the view.
     */
    private synchronized void onTileLoaded() {
        debug("onTileLoaded");
        checkReady();
        checkImageLoaded();
        if (isBaseLayerReady() && bitmap != null) {
            if (!bitmapIsCached) {
                bitmap.recycle();
            }
            bitmap = null;
            if (onImageEventListener != null && bitmapIsCached) {
                onImageEventListener.onPreviewReleased();
            }
            bitmapIsPreview = false;
            bitmapIsCached = false;
        }
        invalidate();
    }

    /**
     * Async task used to load bitmap without blocking the UI thread.
     */
    private static class BitmapLoadTask extends AsyncTask<Void, Void, Integer> {
        private final WeakReference<SubsamplingScaleImageView> viewRef;
        private final WeakReference<Context> contextRef;
        private final WeakReference<DecoderFactory<? extends ImageDecoder>> decoderFactoryRef;
        private final Uri source;
        private final boolean preview;
        private Bitmap bitmap;
        private Exception exception;

        BitmapLoadTask(SubsamplingScaleImageView view, Context context, DecoderFactory<? extends ImageDecoder> decoderFactory, Uri source, boolean preview) {
            this.viewRef = new WeakReference<>(view);
            this.contextRef = new WeakReference<>(context);
            this.decoderFactoryRef = new WeakReference<DecoderFactory<? extends ImageDecoder>>(decoderFactory);
            this.source = source;
            this.preview = preview;
        }

        @Override
        protected Integer doInBackground(Void... params) {
            try {
                String sourceUri = source.toString();
                Context context = contextRef.get();
                DecoderFactory<? extends ImageDecoder> decoderFactory = decoderFactoryRef.get();
                SubsamplingScaleImageView view = viewRef.get();
                if (context != null && decoderFactory != null && view != null) {
                    view.debug("BitmapLoadTask.doInBackground");
                    bitmap = decoderFactory.make().decode(context, source);
                    return view.getExifOrientation(context, sourceUri);
                }
            } catch (Exception e) {
                Log.e(TAG, "Failed to load bitmap", e);
                this.exception = e;
            } catch (OutOfMemoryError e) {
                Log.e(TAG, "Failed to load bitmap - OutOfMemoryError", e);
                this.exception = new RuntimeException(e);
            }
            return null;
        }

        @Override
        protected void onPostExecute(Integer orientation) {
            SubsamplingScaleImageView subsamplingScaleImageView = viewRef.get();
            if (subsamplingScaleImageView != null) {
                if (bitmap != null && orientation != null) {
                    if (preview) {
                        subsamplingScaleImageView.onPreviewLoaded(bitmap);
                    } else {
                        subsamplingScaleImageView.onImageLoaded(bitmap, orientation, false);
                    }
                } else if (exception != null && subsamplingScaleImageView.onImageEventListener != null) {
                    if (preview) {
                        subsamplingScaleImageView.onImageEventListener.onPreviewLoadError(exception);
                    } else {
                        subsamplingScaleImageView.onImageEventListener.onImageLoadError(exception);
                    }
                }
            }
        }
    }

    /**
     * Called by worker task when preview image is loaded.
     */
    private synchronized void onPreviewLoaded(Bitmap previewBitmap) {
        debug("onPreviewLoaded");
        if (bitmap != null || imageLoadedSent) {
            previewBitmap.recycle();
            return;
        }
        if (pRegion != null) {
            bitmap = Bitmap.createBitmap(previewBitmap, pRegion.left, pRegion.top, pRegion.width(), pRegion.height());
        } else {
            bitmap = previewBitmap;
        }
        bitmapIsPreview = true;
        if (checkReady()) {
            invalidate();
            requestLayout();
        }
    }

    /**
     * Called by worker task when full size image bitmap is ready (tiling is disabled).
     */
    private synchronized void onImageLoaded(Bitmap bitmap, int sOrientation, boolean bitmapIsCached) {
        debug("onImageLoaded");
        // If actual dimensions don't match the declared size, reset everything.
        if (this.sWidth > 0 && this.sHeight > 0 && (this.sWidth != bitmap.getWidth() || this.sHeight != bitmap.getHeight())) {
            reset(false);
        }
        if (this.bitmap != null && !this.bitmapIsCached) {
            this.bitmap.recycle();
        }

        if (this.bitmap != null && this.bitmapIsCached && onImageEventListener!=null) {
            onImageEventListener.onPreviewReleased();
        }

        this.bitmapIsPreview = false;
        this.bitmapIsCached = bitmapIsCached;
        this.bitmap = bitmap;
        this.sWidth = bitmap.getWidth();
        this.sHeight = bitmap.getHeight();
        this.sOrientation = sOrientation;
        boolean ready = checkReady();
        boolean imageLoaded = checkImageLoaded();
        if (ready || imageLoaded) {
            invalidate();
            requestLayout();
        }
    }

    /**
     * Helper method for load tasks. Examines the EXIF info on the image file to determine the orientation.
     * This will only work for external files, not assets, resources or other URIs.
     */
    @AnyThread
    private int getExifOrientation(Context context, String sourceUri) {
        int exifOrientation = ORIENTATION_0;
        if (sourceUri.startsWith(ContentResolver.SCHEME_CONTENT)) {
            Cursor cursor = null;
            try {
                String[] columns = { MediaStore.Images.Media.ORIENTATION };
                cursor = context.getContentResolver().query(Uri.parse(sourceUri), columns, null, null, null);
                if (cursor != null) {
                    if (cursor.moveToFirst()) {
                        int orientation = cursor.getInt(0);
                        if (VALID_ORIENTATIONS.contains(orientation) && orientation != ORIENTATION_USE_EXIF) {
                            exifOrientation = orientation;
                        } else {
                            Log.w(TAG, "Unsupported orientation: " + orientation);
                        }
                    }
                }
            } catch (Exception e) {
                Log.w(TAG, "Could not get orientation of image from media store");
            } finally {
                if (cursor != null) {
                    cursor.close();
                }
            }
        } else if (sourceUri.startsWith(ImageSource.FILE_SCHEME) && !sourceUri.startsWith(ImageSource.ASSET_SCHEME)) {
            try {
                ExifInterface exifInterface = new ExifInterface(sourceUri.substring(ImageSource.FILE_SCHEME.length() - 1));
                int orientationAttr = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
                if (orientationAttr == ExifInterface.ORIENTATION_NORMAL || orientationAttr == ExifInterface.ORIENTATION_UNDEFINED) {
                    exifOrientation = ORIENTATION_0;
                } else if (orientationAttr == ExifInterface.ORIENTATION_ROTATE_90) {
                    exifOrientation = ORIENTATION_90;
                } else if (orientationAttr == ExifInterface.ORIENTATION_ROTATE_180) {
                    exifOrientation = ORIENTATION_180;
                } else if (orientationAttr == ExifInterface.ORIENTATION_ROTATE_270) {
                    exifOrientation = ORIENTATION_270;
                } else {
                    Log.w(TAG, "Unsupported EXIF orientation: " + orientationAttr);
                }
            } catch (Exception e) {
                Log.w(TAG, "Could not get EXIF orientation of image");
            }
        }
        return exifOrientation;
    }

    private void execute(AsyncTask<Void, Void, ?> asyncTask) {
        asyncTask.executeOnExecutor(executor);
    }

    private static class Tile {

        private Rect sRect;
        private int sampleSize;
        private Bitmap bitmap;
        private boolean loading;
        private boolean visible;

        // Volatile fields instantiated once then updated before use to reduce GC.
        private Rect vRect;
        private Rect fileSRect;

    }

    private static class Anim {

        private float scaleStart; // Scale at start of anim
        private float scaleEnd; // Scale at end of anim (target)
        private PointF sCenterStart; // Source center point at start
        private PointF sCenterEnd; // Source center point at end, adjusted for pan limits
        private PointF sCenterEndRequested; // Source center point that was requested, without adjustment
        private PointF vFocusStart; // View point that was double tapped
        private PointF vFocusEnd; // Where the view focal point should be moved to during the anim
        private long duration = 500; // How long the anim takes
        private boolean interruptible = true; // Whether the anim can be interrupted by a touch
        private int easing = EASE_IN_OUT_QUAD; // Easing style
        private int origin = ORIGIN_ANIM; // Animation origin (API, double tap or fling)
        private long time = System.currentTimeMillis(); // Start time
        private OnAnimationEventListener listener; // Event listener

    }

    private static class ScaleAndTranslate {
        private ScaleAndTranslate(float scale, PointF vTranslate) {
            this.scale = scale;
            this.vTranslate = vTranslate;
        }
        private float scale;
        private final PointF vTranslate;
    }

    /**
     * Set scale, center and orientation from saved state.
     */
    private void restoreState(ImageViewState state) {
        if (state != null && VALID_ORIENTATIONS.contains(state.getOrientation())) {
            this.orientation = state.getOrientation();
            this.pendingScale = state.getScale();
            this.sPendingCenter = state.getCenter();
            invalidate();
        }
    }

    /**
     * By default the View automatically calculates the optimal tile size. Set this to override this, and force an upper limit to the dimensions of the generated tiles. Passing {@link #TILE_SIZE_AUTO} will re-enable the default behaviour.
     *
     * @param maxPixels Maximum tile size X and Y in pixels.
     */
    public void setMaxTileSize(int maxPixels) {
        this.maxTileWidth = maxPixels;
        this.maxTileHeight = maxPixels;
    }

    /**
     * By default the View automatically calculates the optimal tile size. Set this to override this, and force an upper limit to the dimensions of the generated tiles. Passing {@link #TILE_SIZE_AUTO} will re-enable the default behaviour.
     *
     * @param maxPixelsX Maximum tile width.
     * @param maxPixelsY Maximum tile height.
     */
    public void setMaxTileSize(int maxPixelsX, int maxPixelsY) {
        this.maxTileWidth = maxPixelsX;
        this.maxTileHeight = maxPixelsY;
    }

    /**
     * Use canvas max bitmap width and height instead of the default 2048, to avoid redundant tiling.
     */
    @NonNull
    private Point getMaxBitmapDimensions(Canvas canvas) {
        return new Point(Math.min(canvas.getMaximumBitmapWidth(), maxTileWidth), Math.min(canvas.getMaximumBitmapHeight(), maxTileHeight));
    }

    /**
     * Get source width taking rotation into account.
     */
    @SuppressWarnings("SuspiciousNameCombination")
    private int sWidth() {
        int rotation = getRequiredRotation();
        if (rotation == 90 || rotation == 270) {
            return sHeight;
        } else {
            return sWidth;
        }
    }

    /**
     * Get source height taking rotation into account.
     */
    @SuppressWarnings("SuspiciousNameCombination")
    private int sHeight() {
        int rotation = getRequiredRotation();
        if (rotation == 90 || rotation == 270) {
            return sWidth;
        } else {
            return sHeight;
        }
    }

    /**
     * Converts source rectangle from tile, which treats the image file as if it were in the correct orientation already,
     * to the rectangle of the image that needs to be loaded.
     */
    @SuppressWarnings("SuspiciousNameCombination")
    @AnyThread
    private void fileSRect(Rect sRect, Rect target) {
        if (getRequiredRotation() == 0) {
            target.set(sRect);
        } else if (getRequiredRotation() == 90) {
            target.set(sRect.top, sHeight - sRect.right, sRect.bottom, sHeight - sRect.left);
        } else if (getRequiredRotation() == 180) {
            target.set(sWidth - sRect.right, sHeight - sRect.bottom, sWidth - sRect.left, sHeight - sRect.top);
        } else {
            target.set(sWidth - sRect.bottom, sRect.left, sWidth - sRect.top, sRect.right);
        }
    }

    /**
     * Determines the rotation to be applied to tiles, based on EXIF orientation or chosen setting.
     */
    @AnyThread
    private int getRequiredRotation() {
        if (orientation == ORIENTATION_USE_EXIF) {
            return sOrientation;
        } else {
            return orientation;
        }
    }

    /**
     * Pythagoras distance between two points.
     */
    private float distance(float x0, float x1, float y0, float y1) {
        float x = x0 - x1;
        float y = y0 - y1;
        return (float) Math.sqrt(x * x + y * y);
    }

    /**
     * Releases all resources the view is using and resets the state, nulling any fields that use significant memory.
     * After you have called this method, the view can be re-used by setting a new image. Settings are remembered
     * but state (scale and center) is forgotten. You can restore these yourself if required.
     */
    public void recycle() {
        reset(true);
        bitmapPaint = null;
        debugTextPaint = null;
        debugLinePaint = null;
        tileBgPaint = null;
    }

    /**
     * Convert screen to source x coordinate.
     */
    private float viewToSourceX(float vx) {
        if (vTranslate == null) { return Float.NaN; }
        return (vx - vTranslate.x)/scale;
    }

    /**
     * Convert screen to source y coordinate.
     */
    private float viewToSourceY(float vy) {
        if (vTranslate == null) { return Float.NaN; }
        return (vy - vTranslate.y)/scale;
    }

    /**
     * Converts a rectangle within the view to the corresponding rectangle from the source file, taking
     * into account the current scale, translation, orientation and clipped region. This can be used
     * to decode a bitmap from the source file.
     *
     * This method will only work when the image has fully initialised, after {@link #isReady()} returns
     * true. It is not guaranteed to work with preloaded bitmaps.
     *
     * The result is written to the fRect argument. Re-use a single instance for efficiency.
     * @param vRect rectangle representing the view area to interpret.
     * @param fRect rectangle instance to which the result will be written. Re-use for efficiency.
     */
    public void viewToFileRect(Rect vRect, Rect fRect) {
        if (vTranslate == null || !readySent) {
            return;
        }
        fRect.set(
                (int)viewToSourceX(vRect.left),
                (int)viewToSourceY(vRect.top),
                (int)viewToSourceX(vRect.right),
                (int)viewToSourceY(vRect.bottom));
        fileSRect(fRect, fRect);
        fRect.set(
                Math.max(0, fRect.left),
                Math.max(0, fRect.top),
                Math.min(sWidth, fRect.right),
                Math.min(sHeight, fRect.bottom)
        );
        if (sRegion != null) {
            fRect.offset(sRegion.left, sRegion.top);
        }
    }

    /**
     * Find the area of the source file that is currently visible on screen, taking into account the
     * current scale, translation, orientation and clipped region. This is a convenience method; see
     * {@link #viewToFileRect(Rect, Rect)}.
     * @param fRect rectangle instance to which the result will be written. Re-use for efficiency.
     */
    public void visibleFileRect(Rect fRect) {
        if (vTranslate == null || !readySent) {
            return;
        }
        fRect.set(0, 0, getWidth(), getHeight());
        viewToFileRect(fRect, fRect);
    }

    /**
     * Convert screen coordinate to source coordinate.
     * @param vxy view X/Y coordinate.
     * @return a coordinate representing the corresponding source coordinate.
     */
    @Nullable
    public final PointF viewToSourceCoord(PointF vxy) {
        return viewToSourceCoord(vxy.x, vxy.y, new PointF());
    }

    /**
     * Convert screen coordinate to source coordinate.
     * @param vx view X coordinate.
     * @param vy view Y coordinate.
     * @return a coordinate representing the corresponding source coordinate.
     */
    @Nullable
    public final PointF viewToSourceCoord(float vx, float vy) {
        return viewToSourceCoord(vx, vy, new PointF());
    }

    /**
     * Convert screen coordinate to source coordinate.
     * @param vxy view coordinates to convert.
     * @param sTarget target object for result. The same instance is also returned.
     * @return source coordinates. This is the same instance passed to the sTarget param.
     */
    @Nullable
    public final PointF viewToSourceCoord(PointF vxy, @NonNull PointF sTarget) {
        return viewToSourceCoord(vxy.x, vxy.y, sTarget);
    }

    /**
     * Convert screen coordinate to source coordinate.
     * @param vx view X coordinate.
     * @param vy view Y coordinate.
     * @param sTarget target object for result. The same instance is also returned.
     * @return source coordinates. This is the same instance passed to the sTarget param.
     */
    @Nullable
    public final PointF viewToSourceCoord(float vx, float vy, @NonNull PointF sTarget) {
        if (vTranslate == null) {
            return null;
        }
        sTarget.set(viewToSourceX(vx), viewToSourceY(vy));
        return sTarget;
    }

    /**
     * Convert source to view x coordinate.
     */
    private float sourceToViewX(float sx) {
        if (vTranslate == null) { return Float.NaN; }
        return (sx * scale) + vTranslate.x;
    }

    /**
     * Convert source to view y coordinate.
     */
    private float sourceToViewY(float sy) {
        if (vTranslate == null) { return Float.NaN; }
        return (sy * scale) + vTranslate.y;
    }

    /**
     * Convert source coordinate to view coordinate.
     * @param sxy source coordinates to convert.
     * @return view coordinates.
     */
    @Nullable
    public final PointF sourceToViewCoord(PointF sxy) {
        return sourceToViewCoord(sxy.x, sxy.y, new PointF());
    }

    /**
     * Convert source coordinate to view coordinate.
     * @param sx source X coordinate.
     * @param sy source Y coordinate.
     * @return view coordinates.
     */
    @Nullable
    public final PointF sourceToViewCoord(float sx, float sy) {
        return sourceToViewCoord(sx, sy, new PointF());
    }

    /**
     * Convert source coordinate to view coordinate.
     * @param sxy source coordinates to convert.
     * @param vTarget target object for result. The same instance is also returned.
     * @return view coordinates. This is the same instance passed to the vTarget param.
     */
    @SuppressWarnings("UnusedReturnValue")
    @Nullable
    public final PointF sourceToViewCoord(PointF sxy, @NonNull PointF vTarget) {
        return sourceToViewCoord(sxy.x, sxy.y, vTarget);
    }

    /**
     * Convert source coordinate to view coordinate.
     * @param sx source X coordinate.
     * @param sy source Y coordinate.
     * @param vTarget target object for result. The same instance is also returned.
     * @return view coordinates. This is the same instance passed to the vTarget param.
     */
    @Nullable
    public final PointF sourceToViewCoord(float sx, float sy, @NonNull PointF vTarget) {
        if (vTranslate == null) {
            return null;
        }
        vTarget.set(sourceToViewX(sx), sourceToViewY(sy));
        return vTarget;
    }

    /**
     * Convert source rect to screen rect, integer values.
     */
    private void sourceToViewRect(@NonNull Rect sRect, @NonNull Rect vTarget) {
        vTarget.set(
            (int)sourceToViewX(sRect.left),
            (int)sourceToViewY(sRect.top),
            (int)sourceToViewX(sRect.right),
            (int)sourceToViewY(sRect.bottom)
        );
    }

    /**
     * Get the translation required to place a given source coordinate at the center of the screen, with the center
     * adjusted for asymmetric padding. Accepts the desired scale as an argument, so this is independent of current
     * translate and scale. The result is fitted to bounds, putting the image point as near to the screen center as permitted.
     */
    @NonNull
    private PointF vTranslateForSCenter(float sCenterX, float sCenterY, float scale) {
        int vxCenter = getPaddingLeft() + (getWidth() - getPaddingRight() - getPaddingLeft())/2;
        int vyCenter = getPaddingTop() + (getHeight() - getPaddingBottom() - getPaddingTop())/2;
        if (satTemp == null) {
            satTemp = new ScaleAndTranslate(0, new PointF(0, 0));
        }
        satTemp.scale = scale;
        satTemp.vTranslate.set(vxCenter - (sCenterX * scale), vyCenter - (sCenterY * scale));
        fitToBounds(true, satTemp);
        return satTemp.vTranslate;
    }

    /**
     * Given a requested source center and scale, calculate what the actual center will have to be to keep the image in
     * pan limits, keeping the requested center as near to the middle of the screen as allowed.
     */
    @NonNull
    private PointF limitedSCenter(float sCenterX, float sCenterY, float scale, @NonNull PointF sTarget) {
        PointF vTranslate = vTranslateForSCenter(sCenterX, sCenterY, scale);
        int vxCenter = getPaddingLeft() + (getWidth() - getPaddingRight() - getPaddingLeft())/2;
        int vyCenter = getPaddingTop() + (getHeight() - getPaddingBottom() - getPaddingTop())/2;
        float sx = (vxCenter - vTranslate.x)/scale;
        float sy = (vyCenter - vTranslate.y)/scale;
        sTarget.set(sx, sy);
        return sTarget;
    }

    /**
     * Returns the minimum allowed scale.
     */
    private float minScale() {
        int vPadding = getPaddingBottom() + getPaddingTop();
        int hPadding = getPaddingLeft() + getPaddingRight();
        if (minimumScaleType == SCALE_TYPE_CENTER_CROP || minimumScaleType == SCALE_TYPE_START) {
            return Math.max((getWidth() - hPadding) / (float) sWidth(), (getHeight() - vPadding) / (float) sHeight());
        } else if (minimumScaleType == SCALE_TYPE_CUSTOM && minScale > 0) {
            return minScale;
        } else {
            return Math.min((getWidth() - hPadding) / (float) sWidth(), (getHeight() - vPadding) / (float) sHeight());
        }
    }

    /**
     * Adjust a requested scale to be within the allowed limits.
     */
    private float limitedScale(float targetScale) {
        targetScale = Math.max(minScale(), targetScale);
        targetScale = Math.min(maxScale, targetScale);
        return targetScale;
    }

    /**
     * Apply a selected type of easing.
     * @param type Easing type, from static fields
     * @param time Elapsed time
     * @param from Start value
     * @param change Target value
     * @param duration Anm duration
     * @return Current value
     */
    private float ease(int type, long time, float from, float change, long duration) {
        switch (type) {
            case EASE_IN_OUT_QUAD:
                return easeInOutQuad(time, from, change, duration);
            case EASE_OUT_QUAD:
                return easeOutQuad(time, from, change, duration);
            default:
                throw new IllegalStateException("Unexpected easing type: " + type);
        }
    }

    /**
     * Quadratic easing for fling. With thanks to Robert Penner - http://gizma.com/easing/
     * @param time Elapsed time
     * @param from Start value
     * @param change Target value
     * @param duration Anm duration
     * @return Current value
     */
    private float easeOutQuad(long time, float from, float change, long duration) {
        float progress = (float)time/(float)duration;
        return -change * progress*(progress-2) + from;
    }

    /**
     * Quadratic easing for scale and center animations. With thanks to Robert Penner - http://gizma.com/easing/
     * @param time Elapsed time
     * @param from Start value
     * @param change Target value
     * @param duration Anm duration
     * @return Current value
     */
    private float easeInOutQuad(long time, float from, float change, long duration) {
        float timeF = time/(duration/2f);
        if (timeF < 1) {
            return (change/2f * timeF * timeF) + from;
        } else {
            timeF--;
            return (-change/2f) * (timeF * (timeF - 2) - 1) + from;
        }
    }

    /**
     * Debug logger
     */
    @AnyThread
    private void debug(String message, Object... args) {
        if (debug) {
            Log.d(TAG, String.format(message, args));
        }
    }

    /**
     * For debug overlays. Scale pixel value according to screen density.
     */
    private int px(int px) {
        return (int)(density * px);
    }

    /**
     *
     * Swap the default region decoder implementation for one of your own. You must do this before setting the image file or
     * asset, and you cannot use a custom decoder when using layout XML to set an asset name. Your class must have a
     * public default constructor.
     * @param regionDecoderClass The {@link ImageRegionDecoder} implementation to use.
     */
    public final void setRegionDecoderClass(@NonNull Class<? extends ImageRegionDecoder> regionDecoderClass) {
        //noinspection ConstantConditions
        if (regionDecoderClass == null) {
            throw new IllegalArgumentException("Decoder class cannot be set to null");
        }
        this.regionDecoderFactory = new CompatDecoderFactory<>(regionDecoderClass);
    }

    /**
     * Swap the default region decoder implementation for one of your own. You must do this before setting the image file or
     * asset, and you cannot use a custom decoder when using layout XML to set an asset name.
     * @param regionDecoderFactory The {@link DecoderFactory} implementation that produces {@link ImageRegionDecoder}
     *                             instances.
     */
    public final void setRegionDecoderFactory(@NonNull DecoderFactory<? extends ImageRegionDecoder> regionDecoderFactory) {
        //noinspection ConstantConditions
        if (regionDecoderFactory == null) {
            throw new IllegalArgumentException("Decoder factory cannot be set to null");
        }
        this.regionDecoderFactory = regionDecoderFactory;
    }

    /**
     * Swap the default bitmap decoder implementation for one of your own. You must do this before setting the image file or
     * asset, and you cannot use a custom decoder when using layout XML to set an asset name. Your class must have a
     * public default constructor.
     * @param bitmapDecoderClass The {@link ImageDecoder} implementation to use.
     */
    public final void setBitmapDecoderClass(@NonNull Class<? extends ImageDecoder> bitmapDecoderClass) {
        //noinspection ConstantConditions
        if (bitmapDecoderClass == null) {
            throw new IllegalArgumentException("Decoder class cannot be set to null");
        }
        this.bitmapDecoderFactory = new CompatDecoderFactory<>(bitmapDecoderClass);
    }

    /**
     * Swap the default bitmap decoder implementation for one of your own. You must do this before setting the image file or
     * asset, and you cannot use a custom decoder when using layout XML to set an asset name.
     * @param bitmapDecoderFactory The {@link DecoderFactory} implementation that produces {@link ImageDecoder} instances.
     */
    public final void setBitmapDecoderFactory(@NonNull DecoderFactory<? extends ImageDecoder> bitmapDecoderFactory) {
        //noinspection ConstantConditions
        if (bitmapDecoderFactory == null) {
            throw new IllegalArgumentException("Decoder factory cannot be set to null");
        }
        this.bitmapDecoderFactory = bitmapDecoderFactory;
    }

    /**
     * Calculate how much further the image can be panned in each direction. The results are set on
     * the supplied {@link RectF} and expressed as screen pixels. For example, if the image cannot be
     * panned any further towards the left, the value of {@link RectF#left} will be set to 0.
     * @param vTarget target object for results. Re-use for efficiency.
     */
    public final void getPanRemaining(RectF vTarget) {
        if (!isReady()) {
            return;
        }

        float scaleWidth = scale * sWidth();
        float scaleHeight = scale * sHeight();

        if (panLimit == PAN_LIMIT_CENTER) {
            vTarget.top = Math.max(0, -(vTranslate.y - (getHeight() / 2)));
            vTarget.left = Math.max(0, -(vTranslate.x - (getWidth() / 2)));
            vTarget.bottom = Math.max(0, vTranslate.y - ((getHeight() / 2) - scaleHeight));
            vTarget.right = Math.max(0, vTranslate.x - ((getWidth() / 2) - scaleWidth));
        } else if (panLimit == PAN_LIMIT_OUTSIDE) {
            vTarget.top = Math.max(0, -(vTranslate.y - getHeight()));
            vTarget.left = Math.max(0, -(vTranslate.x - getWidth()));
            vTarget.bottom = Math.max(0, vTranslate.y + scaleHeight);
            vTarget.right = Math.max(0, vTranslate.x + scaleWidth);
        } else {
            vTarget.top = Math.max(0, -vTranslate.y);
            vTarget.left = Math.max(0, -vTranslate.x);
            vTarget.bottom = Math.max(0, (scaleHeight + vTranslate.y) - getHeight());
            vTarget.right = Math.max(0, (scaleWidth + vTranslate.x) - getWidth());
        }
    }

    /**
     * Set the pan limiting style. See static fields. Normally {@link #PAN_LIMIT_INSIDE} is best, for image galleries.
     * @param panLimit a pan limit constant. See static fields.
     */
    public final void setPanLimit(int panLimit) {
        if (!VALID_PAN_LIMITS.contains(panLimit)) {
            throw new IllegalArgumentException("Invalid pan limit: " + panLimit);
        }
        this.panLimit = panLimit;
        if (isReady()) {
            fitToBounds(true);
            invalidate();
        }
    }

    /**
     * Set the minimum scale type. See static fields. Normally {@link #SCALE_TYPE_CENTER_INSIDE} is best, for image galleries.
     * @param scaleType a scale type constant. See static fields.
     */
    public final void setMinimumScaleType(int scaleType) {
        if (!VALID_SCALE_TYPES.contains(scaleType)) {
            throw new IllegalArgumentException("Invalid scale type: " + scaleType);
        }
        this.minimumScaleType = scaleType;
        if (isReady()) {
            fitToBounds(true);
            invalidate();
        }
    }

    /**
     * Set the maximum scale allowed. A value of 1 means 1:1 pixels at maximum scale. You may wish to set this according
     * to screen density - on a retina screen, 1:1 may still be too small. Consider using {@link #setMinimumDpi(int)},
     * which is density aware.
     * @param maxScale maximum scale expressed as a source/view pixels ratio.
     */
    public final void setMaxScale(float maxScale) {
        this.maxScale = maxScale;
    }

    /**
     * Set the minimum scale allowed. A value of 1 means 1:1 pixels at minimum scale. You may wish to set this according
     * to screen density. Consider using {@link #setMaximumDpi(int)}, which is density aware.
     * @param minScale minimum scale expressed as a source/view pixels ratio.
     */
    public final void setMinScale(float minScale) {
        this.minScale = minScale;
    }

    /**
     * This is a screen density aware alternative to {@link #setMaxScale(float)}; it allows you to express the maximum
     * allowed scale in terms of the minimum pixel density. This avoids the problem of 1:1 scale still being
     * too small on a high density screen. A sensible starting point is 160 - the default used by this view.
     * @param dpi Source image pixel density at maximum zoom.
     */
    public final void setMinimumDpi(int dpi) {
        DisplayMetrics metrics = getResources().getDisplayMetrics();
        float averageDpi = (metrics.xdpi + metrics.ydpi)/2;
        setMaxScale(averageDpi/dpi);
    }

    /**
     * This is a screen density aware alternative to {@link #setMinScale(float)}; it allows you to express the minimum
     * allowed scale in terms of the maximum pixel density.
     * @param dpi Source image pixel density at minimum zoom.
     */
    public final void setMaximumDpi(int dpi) {
        DisplayMetrics metrics = getResources().getDisplayMetrics();
        float averageDpi = (metrics.xdpi + metrics.ydpi)/2;
        setMinScale(averageDpi / dpi);
    }

    /**
     * Returns the maximum allowed scale.
     * @return the maximum scale as a source/view pixels ratio.
     */
    public float getMaxScale() {
        return maxScale;
    }

    /**
     * Returns the minimum allowed scale.
     * @return the minimum scale as a source/view pixels ratio.
     */
    public final float getMinScale() {
        return minScale();
    }

    /**
     * By default, image tiles are at least as high resolution as the screen. For a retina screen this may not be
     * necessary, and may increase the likelihood of an OutOfMemoryError. This method sets a DPI at which higher
     * resolution tiles should be loaded. Using a lower number will on average use less memory but result in a lower
     * quality image. 160-240dpi will usually be enough. This should be called before setting the image source,
     * because it affects which tiles get loaded. When using an untiled source image this method has no effect.
     * @param minimumTileDpi Tile loading threshold.
     */
    public void setMinimumTileDpi(int minimumTileDpi) {
        DisplayMetrics metrics = getResources().getDisplayMetrics();
        float averageDpi = (metrics.xdpi + metrics.ydpi)/2;
        this.minimumTileDpi = (int)Math.min(averageDpi, minimumTileDpi);
        if (isReady()) {
            reset(false);
            invalidate();
        }
    }

    /**
     * Returns the source point at the center of the view.
     * @return the source coordinates current at the center of the view.
     */
    @Nullable
    public final PointF getCenter() {
        int mX = getWidth()/2;
        int mY = getHeight()/2;
        return viewToSourceCoord(mX, mY);
    }

    /**
     * Returns the current scale value.
     * @return the current scale as a source/view pixels ratio.
     */
    public final float getScale() {
        return scale;
    }

    /**
     * Externally change the scale and translation of the source image. This may be used with getCenter() and getScale()
     * to restore the scale and zoom after a screen rotate.
     * @param scale New scale to set.
     * @param sCenter New source image coordinate to center on the screen, subject to boundaries.
     */
    public final void setScaleAndCenter(float scale, @Nullable PointF sCenter) {
        this.anim = null;
        this.pendingScale = scale;
        this.sPendingCenter = sCenter;
        this.sRequestedCenter = sCenter;
        invalidate();
    }

    /**
     * Fully zoom out and return the image to the middle of the screen. This might be useful if you have a view pager
     * and want images to be reset when the user has moved to another page.
     */
    public final void resetScaleAndCenter() {
        this.anim = null;
        this.pendingScale = limitedScale(0);
        if (isReady()) {
            this.sPendingCenter = new PointF(sWidth()/2, sHeight()/2);
        } else {
            this.sPendingCenter = new PointF(0, 0);
        }
        invalidate();
    }

    /**
     * Call to find whether the view is initialised, has dimensions, and will display an image on
     * the next draw. If a preview has been provided, it may be the preview that will be displayed
     * and the full size image may still be loading. If no preview was provided, this is called once
     * the base layer tiles of the full size image are loaded.
     * @return true if the view is ready to display an image and accept touch gestures.
     */
    public final boolean isReady() {
        return readySent;
    }

    /**
     * Called once when the view is initialised, has dimensions, and will display an image on the
     * next draw. This is triggered at the same time as {@link OnImageEventListener#onReady()} but
     * allows a subclass to receive this event without using a listener.
     */
    @SuppressWarnings("EmptyMethod")
    protected void onReady() {

    }

    /**
     * Call to find whether the main image (base layer tiles where relevant) have been loaded. Before
     * this event the view is blank unless a preview was provided.
     * @return true if the main image (not the preview) has been loaded and is ready to display.
     */
    public final boolean isImageLoaded() {
        return imageLoadedSent;
    }

    /**
     * Called once when the full size image or its base layer tiles have been loaded.
     */
    @SuppressWarnings("EmptyMethod")
    protected void onImageLoaded() {

    }

    /**
     * Get source width, ignoring orientation. If {@link #getOrientation()} returns 90 or 270, you can use {@link #getSHeight()}
     * for the apparent width.
     * @return the source image width in pixels.
     */
    public final int getSWidth() {
        return sWidth;
    }

    /**
     * Get source height, ignoring orientation. If {@link #getOrientation()} returns 90 or 270, you can use {@link #getSWidth()}
     * for the apparent height.
     * @return the source image height in pixels.
     */
    public final int getSHeight() {
        return sHeight;
    }

    /**
     * Returns the orientation setting. This can return {@link #ORIENTATION_USE_EXIF}, in which case it doesn't tell you
     * the applied orientation of the image. For that, use {@link #getAppliedOrientation()}.
     * @return the orientation setting. See static fields.
     */
    public final int getOrientation() {
        return orientation;
    }

    /**
     * Returns the actual orientation of the image relative to the source file. This will be based on the source file's
     * EXIF orientation if you're using ORIENTATION_USE_EXIF. Values are 0, 90, 180, 270.
     * @return the orientation applied after EXIF information has been extracted. See static fields.
     */
    public final int getAppliedOrientation() {
        return getRequiredRotation();
    }

    /**
     * Get the current state of the view (scale, center, orientation) for restoration after rotate. Will return null if
     * the view is not ready.
     * @return an {@link ImageViewState} instance representing the current position of the image. null if the view isn't ready.
     */
    @Nullable
    public final ImageViewState getState() {
        if (vTranslate != null && sWidth > 0 && sHeight > 0) {
            //noinspection ConstantConditions
            return new ImageViewState(getScale(), getCenter(), getOrientation());
        }
        return null;
    }

    /**
     * Returns true if zoom gesture detection is enabled.
     * @return true if zoom gesture detection is enabled.
     */
    public final boolean isZoomEnabled() {
        return zoomEnabled;
    }

    /**
     * Enable or disable zoom gesture detection. Disabling zoom locks the the current scale.
     * @param zoomEnabled true to enable zoom gestures, false to disable.
     */
    public final void setZoomEnabled(boolean zoomEnabled) {
        this.zoomEnabled = zoomEnabled;
    }

    /**
     * Returns true if double tap &amp; swipe to zoom is enabled.
     * @return true if double tap &amp; swipe to zoom is enabled.
     */
    public final boolean isQuickScaleEnabled() {
        return quickScaleEnabled;
    }

    /**
     * Enable or disable double tap &amp; swipe to zoom.
     * @param quickScaleEnabled true to enable quick scale, false to disable.
     */
    public final void setQuickScaleEnabled(boolean quickScaleEnabled) {
        this.quickScaleEnabled = quickScaleEnabled;
    }

    /**
     * Returns true if pan gesture detection is enabled.
     * @return true if pan gesture detection is enabled.
     */
    public final boolean isPanEnabled() {
        return panEnabled;
    }

    /**
     * Enable or disable pan gesture detection. Disabling pan causes the image to be centered. Pan
     * can still be changed from code.
     * @param panEnabled true to enable panning, false to disable.
     */
    public final void setPanEnabled(boolean panEnabled) {
        this.panEnabled = panEnabled;
        if (!panEnabled && vTranslate != null) {
            vTranslate.x = (getWidth()/2) - (scale * (sWidth()/2));
            vTranslate.y = (getHeight()/2) - (scale * (sHeight()/2));
            if (isReady()) {
                refreshRequiredTiles(true);
                invalidate();
            }
        }
    }

    /**
     * Set a solid color to render behind tiles, useful for displaying transparent PNGs.
     * @param tileBgColor Background color for tiles.
     */
    public final void setTileBackgroundColor(int tileBgColor) {
        if (Color.alpha(tileBgColor) == 0) {
            tileBgPaint = null;
        } else {
            tileBgPaint = new Paint();
            tileBgPaint.setStyle(Style.FILL);
            tileBgPaint.setColor(tileBgColor);
        }
        invalidate();
    }

    /**
     * Set the scale the image will zoom in to when double tapped. This also the scale point where a double tap is interpreted
     * as a zoom out gesture - if the scale is greater than 90% of this value, a double tap zooms out. Avoid using values
     * greater than the max zoom.
     * @param doubleTapZoomScale New value for double tap gesture zoom scale.
     */
    public final void setDoubleTapZoomScale(float doubleTapZoomScale) {
        this.doubleTapZoomScale = doubleTapZoomScale;
    }

    /**
     * A density aware alternative to {@link #setDoubleTapZoomScale(float)}; this allows you to express the scale the
     * image will zoom in to when double tapped in terms of the image pixel density. Values lower than the max scale will
     * be ignored. A sensible starting point is 160 - the default used by this view.
     * @param dpi New value for double tap gesture zoom scale.
     */
    public final void setDoubleTapZoomDpi(int dpi) {
        DisplayMetrics metrics = getResources().getDisplayMetrics();
        float averageDpi = (metrics.xdpi + metrics.ydpi)/2;
        setDoubleTapZoomScale(averageDpi/dpi);
    }

    /**
     * Set the type of zoom animation to be used for double taps. See static fields.
     * @param doubleTapZoomStyle New value for zoom style.
     */
    public final void setDoubleTapZoomStyle(int doubleTapZoomStyle) {
        if (!VALID_ZOOM_STYLES.contains(doubleTapZoomStyle)) {
            throw new IllegalArgumentException("Invalid zoom style: " + doubleTapZoomStyle);
        }
        this.doubleTapZoomStyle = doubleTapZoomStyle;
    }

    /**
     * Set the duration of the double tap zoom animation.
     * @param durationMs Duration in milliseconds.
     */
    public final void setDoubleTapZoomDuration(int durationMs) {
        this.doubleTapZoomDuration = Math.max(0, durationMs);
    }

    /**
     * <p>
     * Provide an {@link Executor} to be used for loading images. By default, {@link AsyncTask#THREAD_POOL_EXECUTOR}
     * is used to minimise contention with other background work the app is doing. You can also choose
     * to use {@link AsyncTask#SERIAL_EXECUTOR} if you want to limit concurrent background tasks.
     * Alternatively you can supply an {@link Executor} of your own to avoid any contention. It is
     * strongly recommended to use a single executor instance for the life of your application, not
     * one per view instance.
     * </p><p>
     * <b>Warning:</b> If you are using a custom implementation of {@link ImageRegionDecoder}, and you
     * supply an executor with more than one thread, you must make sure your implementation supports
     * multi-threaded bitmap decoding or has appropriate internal synchronization. From SDK 21, Android's
     * {@link android.graphics.BitmapRegionDecoder} uses an internal lock so it is thread safe but
     * there is no advantage to using multiple threads.
     * </p>
     * @param executor an {@link Executor} for image loading.
     */
    public void setExecutor(@NonNull Executor executor) {
        //noinspection ConstantConditions
        if (executor == null) {
            throw new NullPointerException("Executor must not be null");
        }
        this.executor = executor;
    }

    /**
     * Enable or disable eager loading of tiles that appear on screen during gestures or animations,
     * while the gesture or animation is still in progress. By default this is enabled to improve
     * responsiveness, but it can result in tiles being loaded and discarded more rapidly than
     * necessary and reduce the animation frame rate on old/cheap devices. Disable this on older
     * devices if you see poor performance. Tiles will then be loaded only when gestures and animations
     * are completed.
     * @param eagerLoadingEnabled true to enable loading during gestures, false to delay loading until gestures end
     */
    public void setEagerLoadingEnabled(boolean eagerLoadingEnabled) {
        this.eagerLoadingEnabled = eagerLoadingEnabled;
    }

    /**
     * Enables visual debugging, showing tile boundaries and sizes.
     * @param debug true to enable debugging, false to disable.
     */
    public final void setDebug(boolean debug) {
        this.debug = debug;
    }

    /**
     * Check if an image has been set. The image may not have been loaded and displayed yet.
     * @return If an image is currently set.
     */
    public boolean hasImage() {
        return uri != null || bitmap != null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setOnLongClickListener(OnLongClickListener onLongClickListener) {
        this.onLongClickListener = onLongClickListener;
    }

    /**
     * Add a listener allowing notification of load and error events. Extend {@link DefaultOnImageEventListener}
     * to simplify implementation.
     * @param onImageEventListener an {@link OnImageEventListener} instance.
     */
    public void setOnImageEventListener(OnImageEventListener onImageEventListener) {
        this.onImageEventListener = onImageEventListener;
    }

    /**
     * Add a listener for pan and zoom events. Extend {@link DefaultOnStateChangedListener} to simplify
     * implementation.
     * @param onStateChangedListener an {@link OnStateChangedListener} instance.
     */
    public void setOnStateChangedListener(OnStateChangedListener onStateChangedListener) {
        this.onStateChangedListener = onStateChangedListener;
    }

    private void sendStateChanged(float oldScale, PointF oldVTranslate, int origin) {
        if (onStateChangedListener != null && scale != oldScale) {
            onStateChangedListener.onScaleChanged(scale, origin);
        }
        if (onStateChangedListener != null && !vTranslate.equals(oldVTranslate)) {
            onStateChangedListener.onCenterChanged(getCenter(), origin);
        }
    }

    /**
     * Creates a panning animation builder, that when started will animate the image to place the given coordinates of
     * the image in the center of the screen. If doing this would move the image beyond the edges of the screen, the
     * image is instead animated to move the center point as near to the center of the screen as is allowed - it's
     * guaranteed to be on screen.
     * @param sCenter Target center point
     * @return {@link AnimationBuilder} instance. Call {@link SubsamplingScaleImageView.AnimationBuilder#start()} to start the anim.
     */
    @Nullable
    public AnimationBuilder animateCenter(PointF sCenter) {
        if (!isReady()) {
            return null;
        }
        return new AnimationBuilder(sCenter);
    }

    /**
     * Creates a scale animation builder, that when started will animate a zoom in or out. If this would move the image
     * beyond the panning limits, the image is automatically panned during the animation.
     * @param scale Target scale.
     * @return {@link AnimationBuilder} instance. Call {@link SubsamplingScaleImageView.AnimationBuilder#start()} to start the anim.
     */
    @Nullable
    public AnimationBuilder animateScale(float scale) {
        if (!isReady()) {
            return null;
        }
        return new AnimationBuilder(scale);
    }

    /**
     * Creates a scale animation builder, that when started will animate a zoom in or out. If this would move the image
     * beyond the panning limits, the image is automatically panned during the animation.
     * @param scale Target scale.
     * @param sCenter Target source center.
     * @return {@link AnimationBuilder} instance. Call {@link SubsamplingScaleImageView.AnimationBuilder#start()} to start the anim.
     */
    @Nullable
    public AnimationBuilder animateScaleAndCenter(float scale, PointF sCenter) {
        if (!isReady()) {
            return null;
        }
        return new AnimationBuilder(scale, sCenter);
    }

    /**
     * Builder class used to set additional options for a scale animation. Create an instance using {@link #animateScale(float)},
     * then set your options and call {@link #start()}.
     */
    public final class AnimationBuilder {

        private final float targetScale;
        private final PointF targetSCenter;
        private final PointF vFocus;
        private long duration = 500;
        private int easing = EASE_IN_OUT_QUAD;
        private int origin = ORIGIN_ANIM;
        private boolean interruptible = true;
        private boolean panLimited = true;
        private OnAnimationEventListener listener;

        private AnimationBuilder(PointF sCenter) {
            this.targetScale = scale;
            this.targetSCenter = sCenter;
            this.vFocus = null;
        }

        private AnimationBuilder(float scale) {
            this.targetScale = scale;
            this.targetSCenter = getCenter();
            this.vFocus = null;
        }

        private AnimationBuilder(float scale, PointF sCenter) {
            this.targetScale = scale;
            this.targetSCenter = sCenter;
            this.vFocus = null;
        }

        private AnimationBuilder(float scale, PointF sCenter, PointF vFocus) {
            this.targetScale = scale;
            this.targetSCenter = sCenter;
            this.vFocus = vFocus;
        }

        /**
         * Desired duration of the anim in milliseconds. Default is 500.
         * @param duration duration in milliseconds.
         * @return this builder for method chaining.
         */
        @NonNull
        public AnimationBuilder withDuration(long duration) {
            this.duration = duration;
            return this;
        }

        /**
         * Whether the animation can be interrupted with a touch. Default is true.
         * @param interruptible interruptible flag.
         * @return this builder for method chaining.
         */
        @NonNull
        public AnimationBuilder withInterruptible(boolean interruptible) {
            this.interruptible = interruptible;
            return this;
        }

        /**
         * Set the easing style. See static fields. {@link #EASE_IN_OUT_QUAD} is recommended, and the default.
         * @param easing easing style.
         * @return this builder for method chaining.
         */
        @NonNull
        public AnimationBuilder withEasing(int easing) {
            if (!VALID_EASING_STYLES.contains(easing)) {
                throw new IllegalArgumentException("Unknown easing type: " + easing);
            }
            this.easing = easing;
            return this;
        }

        /**
         * Add an animation event listener.
         * @param listener The listener.
         * @return this builder for method chaining.
         */
        @NonNull
        public AnimationBuilder withOnAnimationEventListener(OnAnimationEventListener listener) {
            this.listener = listener;
            return this;
        }

        /**
         * Only for internal use. When set to true, the animation proceeds towards the actual end point - the nearest
         * point to the center allowed by pan limits. When false, animation is in the direction of the requested end
         * point and is stopped when the limit for each axis is reached. The latter behaviour is used for flings but
         * nothing else.
         */
        @NonNull
        private AnimationBuilder withPanLimited(boolean panLimited) {
            this.panLimited = panLimited;
            return this;
        }

        /**
         * Only for internal use. Indicates what caused the animation.
         */
        @NonNull
        private AnimationBuilder withOrigin(int origin) {
            this.origin = origin;
            return this;
        }

        /**
         * Starts the animation.
         */
        public void start() {
            if (anim != null && anim.listener != null) {
                try {
                    anim.listener.onInterruptedByNewAnim();
                } catch (Exception e) {
                    Log.w(TAG, "Error thrown by animation listener", e);
                }
            }

            int vxCenter = getPaddingLeft() + (getWidth() - getPaddingRight() - getPaddingLeft())/2;
            int vyCenter = getPaddingTop() + (getHeight() - getPaddingBottom() - getPaddingTop())/2;
            float targetScale = limitedScale(this.targetScale);
            PointF targetSCenter = panLimited ? limitedSCenter(this.targetSCenter.x, this.targetSCenter.y, targetScale, new PointF()) : this.targetSCenter;
            anim = new Anim();
            anim.scaleStart = scale;
            anim.scaleEnd = targetScale;
            anim.time = System.currentTimeMillis();
            anim.sCenterEndRequested = targetSCenter;
            anim.sCenterStart = getCenter();
            anim.sCenterEnd = targetSCenter;
            anim.vFocusStart = sourceToViewCoord(targetSCenter);
            anim.vFocusEnd = new PointF(
                vxCenter,
                vyCenter
            );
            anim.duration = duration;
            anim.interruptible = interruptible;
            anim.easing = easing;
            anim.origin = origin;
            anim.time = System.currentTimeMillis();
            anim.listener = listener;

            if (vFocus != null) {
                // Calculate where translation will be at the end of the anim
                float vTranslateXEnd = vFocus.x - (targetScale * anim.sCenterStart.x);
                float vTranslateYEnd = vFocus.y - (targetScale * anim.sCenterStart.y);
                ScaleAndTranslate satEnd = new ScaleAndTranslate(targetScale, new PointF(vTranslateXEnd, vTranslateYEnd));
                // Fit the end translation into bounds
                fitToBounds(true, satEnd);
                // Adjust the position of the focus point at end so image will be in bounds
                anim.vFocusEnd = new PointF(
                    vFocus.x + (satEnd.vTranslate.x - vTranslateXEnd),
                    vFocus.y + (satEnd.vTranslate.y - vTranslateYEnd)
                );
            }

            invalidate();
        }

    }

    /**
     * An event listener for animations, allows events to be triggered when an animation completes,
     * is aborted by another animation starting, or is aborted by a touch event. Note that none of
     * these events are triggered if the activity is paused, the image is swapped, or in other cases
     * where the view's internal state gets wiped or draw events stop.
     */
    @SuppressWarnings("EmptyMethod")
    public interface OnAnimationEventListener {

        /**
         * The animation has completed, having reached its endpoint.
         */
        void onComplete();

        /**
         * The animation has been aborted before reaching its endpoint because the user touched the screen.
         */
        void onInterruptedByUser();

        /**
         * The animation has been aborted before reaching its endpoint because a new animation has been started.
         */
        void onInterruptedByNewAnim();

    }

    /**
     * Default implementation of {@link OnAnimationEventListener} for extension. This does nothing in any method.
     */
    public static class DefaultOnAnimationEventListener implements OnAnimationEventListener {

        @Override public void onComplete() { }
        @Override public void onInterruptedByUser() { }
        @Override public void onInterruptedByNewAnim() { }

    }

    /**
     * An event listener, allowing subclasses and activities to be notified of significant events.
     */
    @SuppressWarnings("EmptyMethod")
    public interface OnImageEventListener {

        /**
         * Called when the dimensions of the image and view are known, and either a preview image,
         * the full size image, or base layer tiles are loaded. This indicates the scale and translate
         * are known and the next draw will display an image. This event can be used to hide a loading
         * graphic, or inform a subclass that it is safe to draw overlays.
         */
        void onReady();

        /**
         * Called when the full size image is ready. When using tiling, this means the lowest resolution
         * base layer of tiles are loaded, and when tiling is disabled, the image bitmap is loaded.
         * This event could be used as a trigger to enable gestures if you wanted interaction disabled
         * while only a preview is displayed, otherwise for most cases {@link #onReady()} is the best
         * event to listen to.
         */
        void onImageLoaded();

        /**
         * Called when a preview image could not be loaded. This method cannot be relied upon; certain
         * encoding types of supported image formats can result in corrupt or blank images being loaded
         * and displayed with no detectable error. The view will continue to load the full size image.
         * @param e The exception thrown. This error is logged by the view.
         */
        void onPreviewLoadError(Exception e);

        /**
         * Indicates an error initiliasing the decoder when using a tiling, or when loading the full
         * size bitmap when tiling is disabled. This method cannot be relied upon; certain encoding
         * types of supported image formats can result in corrupt or blank images being loaded and
         * displayed with no detectable error.
         * @param e The exception thrown. This error is also logged by the view.
         */
        void onImageLoadError(Exception e);

        /**
         * Called when an image tile could not be loaded. This method cannot be relied upon; certain
         * encoding types of supported image formats can result in corrupt or blank images being loaded
         * and displayed with no detectable error. Most cases where an unsupported file is used will
         * result in an error caught by {@link #onImageLoadError(Exception)}.
         * @param e The exception thrown. This error is logged by the view.
         */
        void onTileLoadError(Exception e);

        /**
        * Called when a bitmap set using ImageSource.cachedBitmap is no longer being used by the View.
        * This is useful if you wish to manage the bitmap after the preview is shown
        */
        void onPreviewReleased();
    }

    /**
     * Default implementation of {@link OnImageEventListener} for extension. This does nothing in any method.
     */
    public static class DefaultOnImageEventListener implements OnImageEventListener {

        @Override public void onReady() { }
        @Override public void onImageLoaded() { }
        @Override public void onPreviewLoadError(Exception e) { }
        @Override public void onImageLoadError(Exception e) { }
        @Override public void onTileLoadError(Exception e) { }
        @Override public void onPreviewReleased() { }

    }

    /**
     * An event listener, allowing activities to be notified of pan and zoom events. Initialisation
     * and calls made by your code do not trigger events; touch events and animations do. Methods in
     * this listener will be called on the UI thread and may be called very frequently - your
     * implementation should return quickly.
     */
    @SuppressWarnings("EmptyMethod")
    public interface OnStateChangedListener {

        /**
         * The scale has changed. Use with {@link #getMaxScale()} and {@link #getMinScale()} to determine
         * whether the image is fully zoomed in or out.
         * @param newScale The new scale.
         * @param origin Where the event originated from - one of {@link #ORIGIN_ANIM}, {@link #ORIGIN_TOUCH}.
         */
        void onScaleChanged(float newScale, int origin);

        /**
         * The source center has been changed. This can be a result of panning or zooming.
         * @param newCenter The new source center point.
         * @param origin Where the event originated from - one of {@link #ORIGIN_ANIM}, {@link #ORIGIN_TOUCH}.
         */
        void onCenterChanged(PointF newCenter, int origin);

    }

    /**
     * Default implementation of {@link OnStateChangedListener}. This does nothing in any method.
     */
    public static class DefaultOnStateChangedListener implements OnStateChangedListener {

        @Override public void onCenterChanged(PointF newCenter, int origin) { }
        @Override public void onScaleChanged(float newScale, int origin) { }

    }

}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/decoder/CompatDecoderFactory.java`:

```java
package com.davemorrissey.labs.subscaleview.decoder;

import android.graphics.Bitmap;
import android.support.annotation.NonNull;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

/**
 * Compatibility factory to instantiate decoders with empty public constructors.
 * @param <T> The base type of the decoder this factory will produce.
 */
@SuppressWarnings("WeakerAccess")
public class CompatDecoderFactory<T> implements DecoderFactory<T> {

    private final Class<? extends T> clazz;
    private final Bitmap.Config bitmapConfig;

    /**
     * Construct a factory for the given class. This must have a default constructor.
     * @param clazz a class that implements {@link ImageDecoder} or {@link ImageRegionDecoder}.
     */
    public CompatDecoderFactory(@NonNull Class<? extends T> clazz) {
    this(clazz, null);
    }

    /**
     * Construct a factory for the given class. This must have a constructor that accepts a {@link Bitmap.Config} instance.
     * @param clazz a class that implements {@link ImageDecoder} or {@link ImageRegionDecoder}.
     * @param bitmapConfig bitmap configuration to be used when loading images.
     */
    public CompatDecoderFactory(@NonNull Class<? extends T> clazz, Bitmap.Config bitmapConfig) {
        this.clazz = clazz;
        this.bitmapConfig = bitmapConfig;
    }

    @Override
    @NonNull
    public T make() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        if (bitmapConfig == null) {
            return clazz.newInstance();
        } else {
            Constructor<? extends T> ctor = clazz.getConstructor(Bitmap.Config.class);
            return ctor.newInstance(bitmapConfig);
        }
    }

}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/decoder/DecoderFactory.java`:

```java
package com.davemorrissey.labs.subscaleview.decoder;


import android.support.annotation.NonNull;

import java.lang.reflect.InvocationTargetException;

/**
 * Interface for {@link ImageDecoder} and {@link ImageRegionDecoder} factories.
 * @param <T> the class of decoder that will be produced.
 */
public interface DecoderFactory<T> {

    /**
     * Produce a new instance of a decoder with type {@link T}.
     * @return a new instance of your decoder.
     * @throws IllegalAccessException if the factory class cannot be instantiated.
     * @throws InstantiationException if the factory class cannot be instantiated.
     * @throws NoSuchMethodException if the factory class cannot be instantiated.
     * @throws InvocationTargetException if the factory class cannot be instantiated.
     */
    @NonNull T make() throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException;

}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/decoder/ImageDecoder.java`:

```java
package com.davemorrissey.labs.subscaleview.decoder;

import android.content.Context;
import android.graphics.Bitmap;
import android.net.Uri;
import android.support.annotation.NonNull;

/**
 * Interface for image decoding classes, allowing the default {@link android.graphics.BitmapFactory}
 * based on the Skia library to be replaced with a custom class.
 */
public interface ImageDecoder {

    /**
     * Decode an image. The URI can be in one of the following formats:
     * <br>
     * File: <code>file:///scard/picture.jpg</code>
     * <br>
     * Asset: <code>file:///android_asset/picture.png</code>
     * <br>
     * Resource: <code>android.resource://com.example.app/drawable/picture</code>
     *
     * @param context Application context
     * @param uri URI of the image
     * @return the decoded bitmap
     * @throws Exception if decoding fails.
     */
    @NonNull Bitmap decode(Context context, @NonNull Uri uri) throws Exception;

}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/decoder/ImageRegionDecoder.java`:

```java
package com.davemorrissey.labs.subscaleview.decoder;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Point;
import android.graphics.Rect;
import android.net.Uri;
import android.support.annotation.NonNull;

/**
 * Interface for image decoding classes, allowing the default {@link android.graphics.BitmapRegionDecoder}
 * based on the Skia library to be replaced with a custom class.
 */
public interface ImageRegionDecoder {

    /**
     * Initialise the decoder. When possible, perform initial setup work once in this method. The
     * dimensions of the image must be returned. The URI can be in one of the following formats:
     * <br>
     * File: <code>file:///scard/picture.jpg</code>
     * <br>
     * Asset: <code>file:///android_asset/picture.png</code>
     * <br>
     * Resource: <code>android.resource://com.example.app/drawable/picture</code>
     * @param context Application context. A reference may be held, but must be cleared on recycle.
     * @param uri URI of the image.
     * @return Dimensions of the image.
     * @throws Exception if initialisation fails.
     */
    @NonNull Point init(Context context, @NonNull Uri uri) throws Exception;

    /**
     * <p>
     * Decode a region of the image with the given sample size. This method is called off the UI
     * thread so it can safely load the image on the current thread. It is called from
     * {@link android.os.AsyncTask}s running in an executor that may have multiple threads, so
     * implementations must be thread safe. Adding <code>synchronized</code> to the method signature
     * is the simplest way to achieve this, but bear in mind the {@link #recycle()} method can be
     * called concurrently.
     * </p><p>
     * See {@link SkiaImageRegionDecoder} and {@link SkiaPooledImageRegionDecoder} for examples of
     * internal locking and synchronization.
     * </p>
     * @param sRect Source image rectangle to decode.
     * @param sampleSize Sample size.
     * @return The decoded region. It is safe to return null if decoding fails.
     */
    @NonNull Bitmap decodeRegion(@NonNull Rect sRect, int sampleSize);

    /**
     * Status check. Should return false before initialisation and after recycle.
     * @return true if the decoder is ready to be used.
     */
    boolean isReady();

    /**
     * This method will be called when the decoder is no longer required. It should clean up any resources still in use.
     */
    void recycle();

}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/decoder/SkiaImageDecoder.java`:

```java
package com.davemorrissey.labs.subscaleview.decoder;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.net.Uri;
import android.support.annotation.Keep;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;

import com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView;

import java.io.InputStream;
import java.util.List;

/**
 * Default implementation of {@link com.davemorrissey.labs.subscaleview.decoder.ImageDecoder}
 * using Android's {@link android.graphics.BitmapFactory}, based on the Skia library. This
 * works well in most circumstances and has reasonable performance, however it has some problems
 * with grayscale, indexed and CMYK images.
 */
public class SkiaImageDecoder implements ImageDecoder {

    private static final String FILE_PREFIX = "file://";
    private static final String ASSET_PREFIX = FILE_PREFIX + "/android_asset/";
    private static final String RESOURCE_PREFIX = ContentResolver.SCHEME_ANDROID_RESOURCE + "://";

    private final Bitmap.Config bitmapConfig;

    @Keep
    @SuppressWarnings("unused")
    public SkiaImageDecoder() {
        this(null);
    }

    @SuppressWarnings({"WeakerAccess", "SameParameterValue"})
    public SkiaImageDecoder(@Nullable Bitmap.Config bitmapConfig) {
        Bitmap.Config globalBitmapConfig = SubsamplingScaleImageView.getPreferredBitmapConfig();
        if (bitmapConfig != null) {
            this.bitmapConfig = bitmapConfig;
        } else if (globalBitmapConfig != null) {
            this.bitmapConfig = globalBitmapConfig;
        } else {
            this.bitmapConfig = Bitmap.Config.RGB_565;
        }
    }

    @Override
    @NonNull
    public Bitmap decode(Context context, @NonNull Uri uri) throws Exception {
        String uriString = uri.toString();
        BitmapFactory.Options options = new BitmapFactory.Options();
        Bitmap bitmap;
        options.inPreferredConfig = bitmapConfig;
        if (uriString.startsWith(RESOURCE_PREFIX)) {
            Resources res;
            String packageName = uri.getAuthority();
            if (context.getPackageName().equals(packageName)) {
                res = context.getResources();
            } else {
                PackageManager pm = context.getPackageManager();
                res = pm.getResourcesForApplication(packageName);
            }

            int id = 0;
            List<String> segments = uri.getPathSegments();
            int size = segments.size();
            if (size == 2 && segments.get(0).equals("drawable")) {
                String resName = segments.get(1);
                id = res.getIdentifier(resName, "drawable", packageName);
            } else if (size == 1 && TextUtils.isDigitsOnly(segments.get(0))) {
                try {
                    id = Integer.parseInt(segments.get(0));
                } catch (NumberFormatException ignored) {
                }
            }

            bitmap = BitmapFactory.decodeResource(context.getResources(), id, options);
        } else if (uriString.startsWith(ASSET_PREFIX)) {
            String assetName = uriString.substring(ASSET_PREFIX.length());
            bitmap = BitmapFactory.decodeStream(context.getAssets().open(assetName), null, options);
        } else if (uriString.startsWith(FILE_PREFIX)) {
            bitmap = BitmapFactory.decodeFile(uriString.substring(FILE_PREFIX.length()), options);
        } else {
            InputStream inputStream = null;
            try {
                ContentResolver contentResolver = context.getContentResolver();
                inputStream = contentResolver.openInputStream(uri);
                bitmap = BitmapFactory.decodeStream(inputStream, null, options);
            } finally {
                if (inputStream != null) {
                    try { inputStream.close(); } catch (Exception e) { /* Ignore */ }
                }
            }
        }
        if (bitmap == null) {
            throw new RuntimeException("Skia image region decoder returned null bitmap - image format may not be supported");
        }
        return bitmap;
    }
}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/decoder/SkiaImageRegionDecoder.java`:

```java
package com.davemorrissey.labs.subscaleview.decoder;

import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.graphics.*;
import android.net.Uri;
import android.os.Build;
import android.support.annotation.Keep;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;

import com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView;

import java.io.InputStream;
import java.util.List;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * Default implementation of {@link com.davemorrissey.labs.subscaleview.decoder.ImageRegionDecoder}
 * using Android's {@link android.graphics.BitmapRegionDecoder}, based on the Skia library. This
 * works well in most circumstances and has reasonable performance due to the cached decoder instance,
 * however it has some problems with grayscale, indexed and CMYK images.
 *
 * A {@link ReadWriteLock} is used to delegate responsibility for multi threading behaviour to the
 * {@link BitmapRegionDecoder} instance on SDK &gt;= 21, whilst allowing this class to block until no
 * tiles are being loaded before recycling the decoder. In practice, {@link BitmapRegionDecoder} is
 * synchronized internally so this has no real impact on performance.
 */
public class SkiaImageRegionDecoder implements ImageRegionDecoder {

    private BitmapRegionDecoder decoder;
    private final ReadWriteLock decoderLock = new ReentrantReadWriteLock(true);

    private static final String FILE_PREFIX = "file://";
    private static final String ASSET_PREFIX = FILE_PREFIX + "/android_asset/";
    private static final String RESOURCE_PREFIX = ContentResolver.SCHEME_ANDROID_RESOURCE + "://";

    private final Bitmap.Config bitmapConfig;

    @Keep
    @SuppressWarnings("unused")
    public SkiaImageRegionDecoder() {
        this(null);
    }

    @SuppressWarnings({"WeakerAccess", "SameParameterValue"})
    public SkiaImageRegionDecoder(@Nullable Bitmap.Config bitmapConfig) {
        Bitmap.Config globalBitmapConfig = SubsamplingScaleImageView.getPreferredBitmapConfig();
        if (bitmapConfig != null) {
            this.bitmapConfig = bitmapConfig;
        } else if (globalBitmapConfig != null) {
            this.bitmapConfig = globalBitmapConfig;
        } else {
            this.bitmapConfig = Bitmap.Config.RGB_565;
        }
    }

    @Override
    @NonNull
    public Point init(Context context, @NonNull Uri uri) throws Exception {
        String uriString = uri.toString();
        if (uriString.startsWith(RESOURCE_PREFIX)) {
            Resources res;
            String packageName = uri.getAuthority();
            if (context.getPackageName().equals(packageName)) {
                res = context.getResources();
            } else {
                PackageManager pm = context.getPackageManager();
                res = pm.getResourcesForApplication(packageName);
            }

            int id = 0;
            List<String> segments = uri.getPathSegments();
            int size = segments.size();
            if (size == 2 && segments.get(0).equals("drawable")) {
                String resName = segments.get(1);
                id = res.getIdentifier(resName, "drawable", packageName);
            } else if (size == 1 && TextUtils.isDigitsOnly(segments.get(0))) {
                try {
                    id = Integer.parseInt(segments.get(0));
                } catch (NumberFormatException ignored) {
                }
            }

            decoder = BitmapRegionDecoder.newInstance(context.getResources().openRawResource(id), false);
        } else if (uriString.startsWith(ASSET_PREFIX)) {
            String assetName = uriString.substring(ASSET_PREFIX.length());
            decoder = BitmapRegionDecoder.newInstance(context.getAssets().open(assetName, AssetManager.ACCESS_RANDOM), false);
        } else if (uriString.startsWith(FILE_PREFIX)) {
            decoder = BitmapRegionDecoder.newInstance(uriString.substring(FILE_PREFIX.length()), false);
        } else {
            InputStream inputStream = null;
            try {
                ContentResolver contentResolver = context.getContentResolver();
                inputStream = contentResolver.openInputStream(uri);
                if (inputStream == null) {
                    throw new Exception("Content resolver returned null stream. Unable to initialise with uri.");
                }
                decoder = BitmapRegionDecoder.newInstance(inputStream, false);
            } finally {
                if (inputStream != null) {
                    try { inputStream.close(); } catch (Exception e) { /* Ignore */ }
                }
            }
        }
        return new Point(decoder.getWidth(), decoder.getHeight());
    }

    @Override
    @NonNull
    public Bitmap decodeRegion(@NonNull Rect sRect, int sampleSize) {
        getDecodeLock().lock();
        try {
            if (decoder != null && !decoder.isRecycled()) {
                BitmapFactory.Options options = new BitmapFactory.Options();
                options.inSampleSize = sampleSize;
                options.inPreferredConfig = bitmapConfig;
                Bitmap bitmap = decoder.decodeRegion(sRect, options);
                if (bitmap == null) {
                    throw new RuntimeException("Skia image decoder returned null bitmap - image format may not be supported");
                }
                return bitmap;
            } else {
                throw new IllegalStateException("Cannot decode region after decoder has been recycled");
            }
        } finally {
            getDecodeLock().unlock();
        }
    }

    @Override
    public synchronized boolean isReady() {
        return decoder != null && !decoder.isRecycled();
    }

    @Override
    public synchronized void recycle() {
        decoderLock.writeLock().lock();
        try {
            decoder.recycle();
            decoder = null;
        } finally {
            decoderLock.writeLock().unlock();
        }
    }

    /**
     * Before SDK 21, BitmapRegionDecoder was not synchronized internally. Any attempt to decode
     * regions from multiple threads with one decoder instance causes a segfault. For old versions
     * use the write lock to enforce single threaded decoding.
     */
    private Lock getDecodeLock() {
        if (Build.VERSION.SDK_INT < 21) {
            return decoderLock.writeLock();
        } else {
            return decoderLock.readLock();
        }
    }
}

```

`app/src/main/java/com/davemorrissey/labs/subscaleview/decoder/SkiaPooledImageRegionDecoder.java`:

```java
package com.davemorrissey.labs.subscaleview.decoder;

import android.app.ActivityManager;
import android.content.ContentResolver;
import android.content.Context;
import android.content.pm.PackageManager;
import android.content.res.AssetFileDescriptor;
import android.content.res.AssetManager;
import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.BitmapRegionDecoder;
import android.graphics.Point;
import android.graphics.Rect;
import android.net.Uri;
import android.os.Build;
import android.support.annotation.Keep;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.text.TextUtils;
import android.util.Log;

import com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView;

import java.io.File;
import java.io.FileFilter;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executor;
import java.util.concurrent.Semaphore;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.regex.Pattern;

import static android.content.Context.ACTIVITY_SERVICE;

/**
 * <p>
 * An implementation of {@link ImageRegionDecoder} using a pool of {@link BitmapRegionDecoder}s,
 * to provide true parallel loading of tiles. This is only effective if parallel loading has been
 * enabled in the view by calling {@link com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView#setExecutor(Executor)}
 * with a multi-threaded {@link Executor} instance.
 * </p><p>
 * One decoder is initialised when the class is initialised. This is enough to decode base layer tiles.
 * Additional decoders are initialised when a subregion of the image is first requested, which indicates
 * interaction with the view. Creation of additional encoders stops when {@link #allowAdditionalDecoder(int, long)}
 * returns false. The default implementation takes into account the file size, number of CPU cores,
 * low memory status and a hard limit of 4. Extend this class to customise this.
 * </p><p>
 * <b>WARNING:</b> This class is highly experimental and not proven to be stable on a wide range of
 * devices. You are advised to test it thoroughly on all available devices, and code your app to use
 * {@link SkiaImageRegionDecoder} on old or low powered devices you could not test.
 * </p>
 */
public class SkiaPooledImageRegionDecoder implements ImageRegionDecoder {

    private static final String TAG = SkiaPooledImageRegionDecoder.class.getSimpleName();

    private static boolean debug = false;

    private DecoderPool decoderPool = new DecoderPool();
    private final ReadWriteLock decoderLock = new ReentrantReadWriteLock(true);

    private static final String FILE_PREFIX = "file://";
    private static final String ASSET_PREFIX = FILE_PREFIX + "/android_asset/";
    private static final String RESOURCE_PREFIX = ContentResolver.SCHEME_ANDROID_RESOURCE + "://";

    private final Bitmap.Config bitmapConfig;

    private Context context;
    private Uri uri;

    private long fileLength = Long.MAX_VALUE;
    private final Point imageDimensions = new Point(0, 0);
    private final AtomicBoolean lazyInited = new AtomicBoolean(false);

    @Keep
    @SuppressWarnings("unused")
    public SkiaPooledImageRegionDecoder() {
        this(null);
    }

    @SuppressWarnings({"WeakerAccess", "SameParameterValue"})
    public SkiaPooledImageRegionDecoder(@Nullable Bitmap.Config bitmapConfig) {
        Bitmap.Config globalBitmapConfig = SubsamplingScaleImageView.getPreferredBitmapConfig();
        if (bitmapConfig != null) {
            this.bitmapConfig = bitmapConfig;
        } else if (globalBitmapConfig != null) {
            this.bitmapConfig = globalBitmapConfig;
        } else {
            this.bitmapConfig = Bitmap.Config.RGB_565;
        }
    }

    /**
     * Controls logging of debug messages. All instances are affected.
     * @param debug true to enable debug logging, false to disable.
     */
    @Keep
    @SuppressWarnings("unused")
    public static void setDebug(boolean debug) {
        SkiaPooledImageRegionDecoder.debug = debug;
    }

    /**
     * Initialises the decoder pool. This method creates one decoder on the current thread and uses
     * it to decode the bounds, then spawns an independent thread to populate the pool with an
     * additional three decoders. The thread will abort if {@link #recycle()} is called.
     */
    @Override
    @NonNull
    public Point init(final Context context, @NonNull final Uri uri) throws Exception {
        this.context = context;
        this.uri = uri;
        initialiseDecoder();
        return this.imageDimensions;
    }

    /**
     * Initialises extra decoders for as long as {@link #allowAdditionalDecoder(int, long)} returns
     * true and the pool has not been recycled.
     */
    private void lazyInit() {
        if (lazyInited.compareAndSet(false, true) && fileLength < Long.MAX_VALUE) {
            debug("Starting lazy init of additional decoders");
            Thread thread = new Thread() {
                @Override
                public void run() {
                    while (decoderPool != null && allowAdditionalDecoder(decoderPool.size(), fileLength)) {
                        // New decoders can be created while reading tiles but this read lock prevents
                        // them being initialised while the pool is being recycled.
                        try {
                            if (decoderPool != null) {
                                long start = System.currentTimeMillis();
                                debug("Starting decoder");
                                initialiseDecoder();
                                long end = System.currentTimeMillis();
                                debug("Started decoder, took " + (end - start) + "ms");
                            }
                        } catch (Exception e) {
                            // A decoder has already been successfully created so we can ignore this
                            debug("Failed to start decoder: " + e.getMessage());
                        }
                    }
                }
            };
            thread.start();
        }
    }

    /**
     * Initialises a new {@link BitmapRegionDecoder} and adds it to the pool, unless the pool has
     * been recycled while it was created.
     */
    private void initialiseDecoder() throws Exception {
        String uriString = uri.toString();
        BitmapRegionDecoder decoder;
        long fileLength = Long.MAX_VALUE;
        if (uriString.startsWith(RESOURCE_PREFIX)) {
            Resources res;
            String packageName = uri.getAuthority();
            if (context.getPackageName().equals(packageName)) {
                res = context.getResources();
            } else {
                PackageManager pm = context.getPackageManager();
                res = pm.getResourcesForApplication(packageName);
            }

            int id = 0;
            List<String> segments = uri.getPathSegments();
            int size = segments.size();
            if (size == 2 && segments.get(0).equals("drawable")) {
                String resName = segments.get(1);
                id = res.getIdentifier(resName, "drawable", packageName);
            } else if (size == 1 && TextUtils.isDigitsOnly(segments.get(0))) {
                try {
                    id = Integer.parseInt(segments.get(0));
                } catch (NumberFormatException ignored) {
                }
            }
            try {
                AssetFileDescriptor descriptor = context.getResources().openRawResourceFd(id);
                fileLength = descriptor.getLength();
            } catch (Exception e) {
                // Pooling disabled
            }
            decoder = BitmapRegionDecoder.newInstance(context.getResources().openRawResource(id), false);
        } else if (uriString.startsWith(ASSET_PREFIX)) {
            String assetName = uriString.substring(ASSET_PREFIX.length());
            try {
                AssetFileDescriptor descriptor = context.getAssets().openFd(assetName);
                fileLength = descriptor.getLength();
            } catch (Exception e) {
                // Pooling disabled
            }
            decoder = BitmapRegionDecoder.newInstance(context.getAssets().open(assetName, AssetManager.ACCESS_RANDOM), false);
        } else if (uriString.startsWith(FILE_PREFIX)) {
            decoder = BitmapRegionDecoder.newInstance(uriString.substring(FILE_PREFIX.length()), false);
            try {
                File file = new File(uriString);
                if (file.exists()) {
                    fileLength = file.length();
                }
            } catch (Exception e) {
                // Pooling disabled
            }
        } else {
            InputStream inputStream = null;
            try {
                ContentResolver contentResolver = context.getContentResolver();
                inputStream = contentResolver.openInputStream(uri);
                decoder = BitmapRegionDecoder.newInstance(inputStream, false);
                try {
                    AssetFileDescriptor descriptor = contentResolver.openAssetFileDescriptor(uri, "r");
                    if (descriptor != null) {
                        fileLength = descriptor.getLength();
                    }
                } catch (Exception e) {
                    // Stick with MAX_LENGTH
                }
            } finally {
                if (inputStream != null) {
                    try { inputStream.close(); } catch (Exception e) { /* Ignore */ }
                }
            }
        }

        this.fileLength = fileLength;
        this.imageDimensions.set(decoder.getWidth(), decoder.getHeight());
        decoderLock.writeLock().lock();
        try {
            if (decoderPool != null) {
                decoderPool.add(decoder);
            }
        } finally {
            decoderLock.writeLock().unlock();
        }
    }

    /**
     * Acquire a read lock to prevent decoding overlapping with recycling, then check the pool still
     * exists and acquire a decoder to load the requested region. There is no check whether the pool
     * currently has decoders, because it's guaranteed to have one decoder after {@link #init(Context, Uri)}
     * is called and be null once {@link #recycle()} is called. In practice the view can't call this
     * method until after {@link #init(Context, Uri)}, so there will be no blocking on an empty pool.
     */
    @Override
    @NonNull
    public Bitmap decodeRegion(@NonNull Rect sRect, int sampleSize) {
        debug("Decode region " + sRect + " on thread " + Thread.currentThread().getName());
        if (sRect.width() < imageDimensions.x || sRect.height() < imageDimensions.y) {
            lazyInit();
        }
        decoderLock.readLock().lock();
        try {
            if (decoderPool != null) {
                BitmapRegionDecoder decoder = decoderPool.acquire();
                try {
                    // Decoder can't be null or recycled in practice
                    if (decoder != null && !decoder.isRecycled()) {
                        BitmapFactory.Options options = new BitmapFactory.Options();
                        options.inSampleSize = sampleSize;
                        options.inPreferredConfig = bitmapConfig;
                        Bitmap bitmap = decoder.decodeRegion(sRect, options);
                        if (bitmap == null) {
                            throw new RuntimeException("Skia image decoder returned null bitmap - image format may not be supported");
                        }
                        return bitmap;
                    }
                } finally {
                    if (decoder != null) {
                        decoderPool.release(decoder);
                    }
                }
            }
            throw new IllegalStateException("Cannot decode region after decoder has been recycled");
        } finally {
            decoderLock.readLock().unlock();
        }
    }

    /**
     * Holding a read lock to avoid returning true while the pool is being recycled, this returns
     * true if the pool has at least one decoder available.
     */
    @Override
    public synchronized boolean isReady() {
        return decoderPool != null && !decoderPool.isEmpty();
    }

    /**
     * Wait until all read locks held by {@link #decodeRegion(Rect, int)} are released, then recycle
     * and destroy the pool. Elsewhere, when a read lock is acquired, we must check the pool is not null.
     */
    @Override
    public synchronized void recycle() {
        decoderLock.writeLock().lock();
        try {
            if (decoderPool != null) {
                decoderPool.recycle();
                decoderPool = null;
                context = null;
                uri = null;
            }
        } finally {
            decoderLock.writeLock().unlock();
        }
    }

    /**
     * Called before creating a new decoder. Based on number of CPU cores, available memory, and the
     * size of the image file, determines whether another decoder can be created. Subclasses can
     * override and customise this.
     * @param numberOfDecoders the number of decoders that have been created so far
     * @param fileLength the size of the image file in bytes. Creating another decoder will use approximately this much native memory.
     * @return true if another decoder can be created.
     */
    @SuppressWarnings("WeakerAccess")
    protected boolean allowAdditionalDecoder(int numberOfDecoders, long fileLength) {
        if (numberOfDecoders >= 4) {
            debug("No additional decoders allowed, reached hard limit (4)");
            return false;
        } else if (numberOfDecoders * fileLength > 20 * 1024 * 1024) {
            debug("No additional encoders allowed, reached hard memory limit (20Mb)");
            return false;
        } else if (numberOfDecoders >= getNumberOfCores()) {
            debug("No additional encoders allowed, limited by CPU cores (" + getNumberOfCores() + ")");
            return false;
        } else if (isLowMemory()) {
            debug("No additional encoders allowed, memory is low");
            return false;
        }
        debug("Additional decoder allowed, current count is " + numberOfDecoders + ", estimated native memory " + ((fileLength * numberOfDecoders)/(1024 * 1024)) + "Mb");
        return true;
    }


    /**
     * A simple pool of {@link BitmapRegionDecoder} instances, all loading from the same source.
     */
    private static class DecoderPool {
        private final Semaphore available = new Semaphore(0, true);
        private final Map<BitmapRegionDecoder, Boolean> decoders = new ConcurrentHashMap<>();

        /**
         * Returns false if there is at least one decoder in the pool.
         */
        private synchronized boolean isEmpty() {
            return decoders.isEmpty();
        }

        /**
         * Returns number of encoders.
         */
        private synchronized int size() {
            return decoders.size();
        }

        /**
         * Acquire a decoder. Blocks until one is available.
         */
        private BitmapRegionDecoder acquire() {
            available.acquireUninterruptibly();
            return getNextAvailable();
        }

        /**
         * Release a decoder back to the pool.
         */
        private void release(BitmapRegionDecoder decoder) {
            if (markAsUnused(decoder)) {
                available.release();
            }
        }

        /**
         * Adds a newly created decoder to the pool, releasing an additional permit.
         */
        private synchronized void add(BitmapRegionDecoder decoder) {
            decoders.put(decoder, false);
            available.release();
        }

        /**
         * While there are decoders in the map, wait until each is available before acquiring,
         * recycling and removing it. After this is called, any call to {@link #acquire()} will
         * block forever, so this call should happen within a write lock, and all calls to
         * {@link #acquire()} should be made within a read lock so they cannot end up blocking on
         * the semaphore when it has no permits.
         */
        private synchronized void recycle() {
            while (!decoders.isEmpty()) {
                BitmapRegionDecoder decoder = acquire();
                decoder.recycle();
                decoders.remove(decoder);
            }
        }

        private synchronized BitmapRegionDecoder getNextAvailable() {
            for (Map.Entry<BitmapRegionDecoder, Boolean> entry : decoders.entrySet()) {
                if (!entry.getValue()) {
                    entry.setValue(true);
                    return entry.getKey();
                }
            }
            return null;
        }

        private synchronized boolean markAsUnused(BitmapRegionDecoder decoder) {
            for (Map.Entry<BitmapRegionDecoder, Boolean> entry : decoders.entrySet()) {
                if (decoder == entry.getKey()) {
                    if (entry.getValue()) {
                        entry.setValue(false);
                        return true;
                    } else {
                        return false;
                    }
                }
            }
            return false;
        }

    }

    private int getNumberOfCores() {
        if (Build.VERSION.SDK_INT >= 17) {
            return Runtime.getRuntime().availableProcessors();
        } else {
            return getNumCoresOldPhones();
        }
    }

    /**
     * Gets the number of cores available in this device, across all processors.
     * Requires: Ability to peruse the filesystem at "/sys/devices/system/cpu"
     * @return The number of cores, or 1 if failed to get result
     */
    private int getNumCoresOldPhones() {
        class CpuFilter implements FileFilter {
            @Override
            public boolean accept(File pathname) {
                return Pattern.matches("cpu[0-9]+", pathname.getName());
            }
        }
        try {
            File dir = new File("/sys/devices/system/cpu/");
            File[] files = dir.listFiles(new CpuFilter());
            return files.length;
        } catch(Exception e) {
            return 1;
        }
    }

    private boolean isLowMemory() {
        ActivityManager activityManager = (ActivityManager)context.getSystemService(ACTIVITY_SERVICE);
        if (activityManager != null) {
            ActivityManager.MemoryInfo memoryInfo = new ActivityManager.MemoryInfo();
            activityManager.getMemoryInfo(memoryInfo);
            return memoryInfo.lowMemory;
        } else {
            return true;
        }
    }

    private void debug(String message) {
        if (debug) {
            Log.d(TAG, message);
        }
    }

}

```

`app/src/main/java/com/tomclaw/imageloader/SimpleImageLoader.java`:

```java
package com.tomclaw.imageloader;

import android.content.Context;

import com.tomclaw.cache.DiskLruCache;
import com.tomclaw.imageloader.core.Decoder;
import com.tomclaw.imageloader.core.DiskCacheImpl;
import com.tomclaw.imageloader.core.FileProvider;
import com.tomclaw.imageloader.core.FileProviderImpl;
import com.tomclaw.imageloader.core.ImageLoader;
import com.tomclaw.imageloader.core.ImageLoaderImpl;
import com.tomclaw.imageloader.core.MainExecutorImpl;
import com.tomclaw.imageloader.core.MemoryCache;
import com.tomclaw.imageloader.core.MemoryCacheImpl;
import com.tomclaw.imageloader.util.BitmapDecoder;
import com.tomclaw.imageloader.util.loader.ContentLoader;
import com.tomclaw.imageloader.util.loader.FileLoader;
import com.tomclaw.imageloader.util.loader.UrlLoader;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class SimpleImageLoader {

    private static ImageLoader imageLoader;

    // converted from extension function
    public static ImageLoader getImageLoader(Context context) {
        try {
            return imageLoader != null ? imageLoader : initImageLoader(context,null,null,null,null,null);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    // converted from extension function
    public static ImageLoader initImageLoader(Context context, List<Decoder> decoders, FileProvider fileProvider, MemoryCache memoryCache, Executor mainExecutor, ExecutorService backgroundExecutor) throws IOException {
        if(decoders == null) decoders = Collections.singletonList(new BitmapDecoder());
        if(fileProvider == null) fileProvider = new FileProviderImpl(
                context.getCacheDir(),
                new DiskCacheImpl(DiskLruCache.create(context.getCacheDir(), 15728640L)),
                new UrlLoader(),
                new FileLoader(context.getAssets()),
                new ContentLoader(context.getContentResolver())
        );
        if(memoryCache == null) memoryCache = new MemoryCacheImpl();
        if(mainExecutor == null) mainExecutor = new MainExecutorImpl();
        if(backgroundExecutor == null) backgroundExecutor = Executors.newFixedThreadPool(10);
        ImageLoaderImpl loader = new ImageLoaderImpl(
                fileProvider,
                decoders,
                memoryCache,
                mainExecutor,
                backgroundExecutor
        );
        imageLoader = loader;
        return loader;
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/Decoder.java`:

```java
package com.tomclaw.imageloader.core;

import android.support.annotation.Nullable;

import java.io.File;

public interface Decoder {

    boolean probe(File file);

    @Nullable Result decode(File file, int width, int height);
}

```

`app/src/main/java/com/tomclaw/imageloader/core/DiskCache.java`:

```java
package com.tomclaw.imageloader.core;

import android.support.annotation.Nullable;

import com.tomclaw.cache.RecordNotFoundException;

import java.io.File;
import java.io.IOException;

public interface DiskCache {

    @Nullable File get(String key);

    File put(String key, File file) throws IOException;

    void remove(String key) throws IOException, RecordNotFoundException;

}

```

`app/src/main/java/com/tomclaw/imageloader/core/DiskCacheImpl.java`:

```java
package com.tomclaw.imageloader.core;

import com.tomclaw.cache.DiskLruCache;
import com.tomclaw.cache.RecordNotFoundException;

import java.io.File;
import java.io.IOException;

public class DiskCacheImpl implements DiskCache {

    private final DiskLruCache diskLruCache;

    public DiskCacheImpl(DiskLruCache diskLruCache) {
        this.diskLruCache = diskLruCache;
    }

    @Override
    public File get(String key) {
        return diskLruCache.get(key);
    }

    @Override
    public File put(String key, File file) throws IOException {
        return diskLruCache.put(key, file);
    }

    @Override
    public void remove(String key) throws IOException, RecordNotFoundException {
        diskLruCache.delete(key);
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/FileProvider.java`:

```java
package com.tomclaw.imageloader.core;

import android.net.Uri;

import java.io.File;


public interface FileProvider {
    File getFile(Uri uri);

    default File getFile(String url) {
        return getFile(Uri.parse(url));
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/FileProviderImpl.java`:

```java
package com.tomclaw.imageloader.core;

import android.net.Uri;

import java.io.File;
import java.util.HashMap;


public final class FileProviderImpl implements FileProvider {
    private final File cacheDir;
    private final DiskCache diskCache;
    private final HashMap<String, Loader> loaders = new HashMap<>();

    public FileProviderImpl(File cacheDir, DiskCache diskCache, Loader... loaders) {
        this.cacheDir = cacheDir;
        this.diskCache = diskCache;
        for(Loader loader : loaders)
            for(String s : loader.getSchemes())
                this.loaders.put(s, loader);
    }

    @Override
    public File getFile(Uri uri) {
        File f = diskCache.get(uri.toString());
        if(f != null) return f;
        return loadIntoCache(uri);
    }

    private File loadIntoCache(Uri uri) {
        File tempFile = null;
        try {
            tempFile = File.createTempFile("file", ".tmp", cacheDir);
            Loader loader = loaders.get(uri.getScheme());
            if(loader == null) return null;
            String uriString = uri.toString();
            if(loader.load(uriString, tempFile))
                return diskCache.put(uriString, tempFile);
        }
        catch(Throwable t) {
            t.printStackTrace();
        }
        finally {
            if(tempFile != null) tempFile.delete();
        }
        return null;
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/Handlers.java`:

```java
package com.tomclaw.imageloader.core;

public class Handlers<T> {
    @FunctionalInterface
    public interface SuccessInterface<T> {
        void fn(ViewHolder<T> viewHolder, Result result);
    }

    @FunctionalInterface
    public interface PlaceholderOrErrorInterface<T> {
        void fn(ViewHolder<T> viewHolder);
    }

    public SuccessInterface<T> success = (v,r) -> {};
    public PlaceholderOrErrorInterface<T> placeholder = v -> {};
    public PlaceholderOrErrorInterface<T> error = v -> {};

    public void setPlaceholder(PlaceholderOrErrorInterface<T> placeholder) {
        this.placeholder = placeholder;
    }

    public void setError(PlaceholderOrErrorInterface<T> error) {
        this.error = error;
    }

    public void setSuccess(SuccessInterface<T> success) {
        this.success = success;
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/ImageLoader.java`:

```java
package com.tomclaw.imageloader.core;

import java.security.NoSuchAlgorithmException;

public interface ImageLoader {

    <T> void load(ViewHolder<T> view, String uriString, Handlers<T> handlers) throws NoSuchAlgorithmException;

}

```

`app/src/main/java/com/tomclaw/imageloader/core/ImageLoaderImpl.java`:

```java
package com.tomclaw.imageloader.core;

import java.io.File;
import java.lang.ref.WeakReference;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

import it.pgp.xfiles.utils.Misc;

public class ImageLoaderImpl implements ImageLoader {

    public final FileProvider fileProvider;
    public final List<Decoder> decoders;
    public final MemoryCache memoryCache;
    public final Executor mainExecutor;
    public final ExecutorService backgroundExecutor;

    public final Map<String, Future<?>> futures = new HashMap<>();

    public ImageLoaderImpl(FileProvider fileProvider, List<Decoder> decoders, MemoryCache memoryCache, Executor mainExecutor, ExecutorService backgroundExecutor) {
        this.fileProvider = fileProvider;
        this.decoders = decoders;
        this.memoryCache = memoryCache;
        this.mainExecutor = mainExecutor;
        this.backgroundExecutor = backgroundExecutor;
    }

    @Override
    public <T> void load(ViewHolder<T> view, String uriString, Handlers<T> handlers) throws NoSuchAlgorithmException {
        ViewSize size = view.optSize();
        if(size == null) {
            waitSizeAsync(view, uriString, handlers);
            return;
        }
        String key = generateKey(uriString, size.width, size.height);
        Object prevTag = view.getTag();
        view.setTag(key);
        boolean isLoading = false;
        if(prevTag instanceof String) {
            String prevKey = (String) prevTag;
            Future<?> future = futures.get(prevKey);
            if(prevKey.equals(key) && (future != null && !future.isDone())) {
                isLoading = true;
            }
            else {
                if(future != null) future.cancel(true);
                isLoading = false;
            }
        }
        if(isLoading) return;

        Result value = memoryCache.get(key);
        if(value == null || value.isRecycled())
            loadAsync(view, size, uriString, key, handlers);
        else handlers.success.fn(view, value);
    }

    private <T> void waitSizeAsync(
            ViewHolder<T> viewHolder,
            String uriString,
            Handlers<T> handlers) {
        backgroundExecutor.submit(()->{
            viewHolder.getSize(); // not sure about implicit return in kotlin equivalent code
            mainExecutor.execute(()-> {
                try {
                    load(viewHolder, uriString, handlers);
                }
                catch(NoSuchAlgorithmException e) {
                    throw new RuntimeException(e);
                }
            });
        });
    }

    private <T> void loadAsync(
            ViewHolder<T> view,
            ViewSize size,
            String uriString,
            String key,
            Handlers<T> handlers
    ) {
        WeakReference<ViewHolder<T>> weakImageView = new WeakReference<>(view);
        handlers.placeholder.fn(view);
        Future<?> f = backgroundExecutor.submit(() -> {
            File file = fileProvider.getFile(uriString);
            if(file != null) {
                Decoder decoder = null;
                for(Decoder d: decoders) {
                    if(d.probe(file)) {
                        decoder = d;
                        break;
                    }
                }
                if(decoder != null) {
                    Result result = decoder != null ? decoder.decode(file, size.width, size.height) : null;
                    if(result != null) {
                        memoryCache.put(key, result);
                        mainExecutor.execute(() -> {
                            ViewHolder<T> weakImageViewVal = weakImageView.get();
                            if(weakImageViewVal != null) {
                                if(weakImageViewVal.getTag().equals(key)) {
                                    handlers.success.fn(view, result);
                                }
                            }
                            futures.remove(key);
                        });
                    }
                }
            }
            else handlers.error.fn(view);
        });
        futures.put(uriString, f);
    }

    private String generateKey(String url, int width, int height) throws NoSuchAlgorithmException {
        return toSHA1(url) + "_" + width + "_" + height;
    }

    static String toSHA1(String s) throws NoSuchAlgorithmException {
        byte[] bytes = MessageDigest.getInstance("SHA-1").digest(s.getBytes());
        return Misc.toHexString(bytes);
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/Loader.java`:

```java
package com.tomclaw.imageloader.core;

import java.io.File;
import java.util.List;

public interface Loader {

    List<String> getSchemes();

    boolean load(String uriString, File file);
}

```

`app/src/main/java/com/tomclaw/imageloader/core/MainExecutorImpl.java`:

```java
package com.tomclaw.imageloader.core;

import android.os.Handler;
import android.os.Looper;

import java.util.concurrent.Executor;

public class MainExecutorImpl implements Executor {

    private final Handler mainHandler = new Handler(Looper.getMainLooper());

    private boolean isMainThread() {
        return mainHandler.getLooper().getThread() == Thread.currentThread();
    }

    @Override
    public void execute(Runnable runnable) {
        if(isMainThread()) runnable.run();
        else mainHandler.post(runnable);
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/MemoryCache.java`:

```java
package com.tomclaw.imageloader.core;

import android.support.annotation.Nullable;

public interface MemoryCache {

    @Nullable Result get(String key);

    @Nullable Result put(String key, Result result);

    @Nullable Result remove(String key);

}

```

`app/src/main/java/com/tomclaw/imageloader/core/MemoryCacheImpl.java`:

```java
package com.tomclaw.imageloader.core;

import android.util.LruCache;

public class MemoryCacheImpl implements MemoryCache {

    private final LruCache<String, Result> bitmapLruCache;

    public MemoryCacheImpl() {
        int maxMemory = (int)Runtime.getRuntime().maxMemory();
        int cacheSize = maxMemory / 12;
        bitmapLruCache = new LruCache<String, Result>(cacheSize) {
            @Override
            protected int sizeOf(String key, Result value) {
                return value.getByteCount();
            }
        };
    }

    @Override
    public Result get(String key) {
        return bitmapLruCache.get(key);
    }

    @Override
    public Result put(String key, Result result) {
        return bitmapLruCache.put(key, result);
    }

    @Override
    public Result remove(String key) {
        return bitmapLruCache.remove(key);
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/core/Result.java`:

```java
package com.tomclaw.imageloader.core;

import android.graphics.drawable.Drawable;

public interface Result {

    int getByteCount();

    boolean isRecycled();

    Drawable getDrawable();
}

```

`app/src/main/java/com/tomclaw/imageloader/core/ViewHolder.java`:

```java
package com.tomclaw.imageloader.core;

import android.support.annotation.Nullable;

public interface ViewHolder<T> {

    @Nullable ViewSize optSize();

    ViewSize getSize();

    @Nullable Object getTag();

    void setTag(Object tag);

    T get();
}
```

`app/src/main/java/com/tomclaw/imageloader/core/ViewSize.java`:

```java
package com.tomclaw.imageloader.core;

public class ViewSize {
    public int width;
    public int height;

    public ViewSize(int width, int height) {
        this.width = width;
        this.height = height;
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/util/BitmapDecoder.java`:

```java
package com.tomclaw.imageloader.util;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.media.ExifInterface;
import android.support.annotation.Nullable;

import com.tomclaw.imageloader.core.Decoder;
import com.tomclaw.imageloader.core.Result;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class BitmapDecoder implements Decoder {
    @Override
    public boolean probe(File file) {
        try(InputStream inputStream = new FileInputStream(file)) {
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeStream(inputStream, null, options);
            return true;
        }
        catch(Throwable t) {
            t.printStackTrace();
            return false;
        }
    }

    @Override
    public @Nullable Result decode(File file, int width, int height) {
        Bitmap bitmap = null;
        try(InputStream inputStream = new FileInputStream(file)) {
            bitmap = decodeSampledBitmapFromStream(inputStream, width, height);
            int rotation = getRotation(file);
            if(bitmap != null && rotation != 0) {
                Matrix m = new Matrix();
                m.setRotate(
                        (float)rotation,
                        (float)(bitmap.getWidth() / 2),
                        (float)(bitmap.getHeight() / 2)
                );
                bitmap = Bitmap.createBitmap(bitmap, 0, 0, bitmap.getWidth(), bitmap.getHeight(), m, false);
            }
        }
        catch(Throwable t) {
            t.printStackTrace();
        }
        return bitmap != null ? new BitmapResult(bitmap) : null;
    }

    private @Nullable Bitmap decodeSampledBitmapFromStream(
            InputStream stream,
            int reqWidth,
            int reqHeight) {
        try {
            InputStream inputStream = new BufferedInputStream(stream, THUMBNAIL_BUFFER_SIZE);
            inputStream.mark(THUMBNAIL_BUFFER_SIZE);

            // First decode with inJustDecodeBounds=true to check dimensions
            BitmapFactory.Options options = new BitmapFactory.Options();
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeStream(inputStream, null, options);

            // Calculate inSampleSize
            float widthSample = (float)(options.outWidth / reqWidth);
            float heightSample = (float)(options.outHeight / reqHeight);
            float scaleFactor = Math.max(widthSample, heightSample);
            if(scaleFactor < 1.0f) scaleFactor = 1.0f;
            options.inJustDecodeBounds = false;
            options.inSampleSize = (int)scaleFactor;
            options.inPreferredConfig = Bitmap.Config.RGB_565;

            // Decode bitmap with inSampleSize set
            inputStream.reset();
            return BitmapFactory.decodeStream(inputStream, null, options);
        }
        catch(Throwable t) {
            t.printStackTrace();
            return null;
        }
    }

    private static int getRotation(File file) {
        switch(obtainFileOrientation(file.getAbsolutePath())) {
            case ExifInterface.ORIENTATION_ROTATE_90:
            case ExifInterface.ORIENTATION_TRANSPOSE:
                return 90;
            case ExifInterface.ORIENTATION_ROTATE_180:
            case ExifInterface.ORIENTATION_FLIP_VERTICAL:
                return 180;
            case ExifInterface.ORIENTATION_ROTATE_270:
            case ExifInterface.ORIENTATION_TRANSVERSE:
                return 270;
            default:
                return 0;
        }
    }

    private static int obtainFileOrientation(String fileName) {
        try {
            return new ExifInterface(fileName).getAttributeInt(
                    ExifInterface.TAG_ORIENTATION,
                    ExifInterface.ORIENTATION_NORMAL);
        }
        catch(IOException e) {
            return ExifInterface.ORIENTATION_UNDEFINED;
        }
    }

    static class BitmapResult implements Result {

        private final Bitmap bitmap;

        public BitmapResult(Bitmap bitmap) {
            this.bitmap = bitmap;
        }

        @Override
        public int getByteCount() {
            return bitmap.getByteCount();
        }

        @Override
        public boolean isRecycled() {
            return bitmap.isRecycled();
        }

        @Override
        public Drawable getDrawable() {
            return new BitmapDrawable(null, bitmap);
        }
    }

    /**
     * Buffer is large enough to rewind past any EXIF headers.
     */
    private static final int THUMBNAIL_BUFFER_SIZE = 128 * 1024;
}

```

`app/src/main/java/com/tomclaw/imageloader/util/ImageViewHandlers.java`:

```java
package com.tomclaw.imageloader.util;

import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.PorterDuff;
import android.graphics.PorterDuffColorFilter;
import android.widget.ImageView;

import com.tomclaw.imageloader.core.Handlers;
import com.tomclaw.imageloader.core.ViewHolder;

public class ImageViewHandlers {
    // these are all ported from extension functions

    public static Handlers<ImageView> fitCenter(Handlers<ImageView> handlers) {
        handlers.success = (viewHolder, result) -> {
            ImageView imgView = viewHolder.get();
            imgView.setImageDrawable(null);
            imgView.setScaleType(ImageView.ScaleType.FIT_CENTER);
            imgView.setColorFilter(null);
            imgView.setImageDrawable(result.getDrawable());
        };
        return handlers;
    }

    public static Handlers<ImageView> matrixMode(Handlers<ImageView> handlers) {
        handlers.success = (viewHolder, result) -> {
            ImageView imgView = viewHolder.get();
            imgView.setImageDrawable(null);
            imgView.setScaleType(ImageView.ScaleType.MATRIX);
            imgView.setColorFilter(null);
            imgView.setImageDrawable(result.getDrawable());
        };
        return handlers;
    }

    public static Handlers<ImageView> centerCrop(Handlers<ImageView> handlers) {
        handlers.success = (viewHolder, result) -> {
            ImageView imgView = viewHolder.get();
            imgView.setImageDrawable(null);
            imgView.setScaleType(ImageView.ScaleType.CENTER_CROP);
            imgView.setColorFilter(null);
            imgView.setImageDrawable(result.getDrawable());
        };
        return handlers;
    }

    public static Handlers<ImageView> centerInside(Handlers<ImageView> handlers) {
        handlers.success = (viewHolder, result) -> {
            ImageView imgView = viewHolder.get();
            imgView.setImageDrawable(null);
            imgView.setScaleType(ImageView.ScaleType.CENTER_INSIDE);
            imgView.setColorFilter(null);
            imgView.setImageDrawable(result.getDrawable());
        };
        return handlers;
    }

    public static Handlers<ImageView> withPlaceholder(Handlers<ImageView> handlers, int drawableRes) {
        handlers.placeholder = viewHolder -> {
            centerRes(viewHolder, drawableRes);
            viewHolder.get().setColorFilter(null);
        };
        return handlers;
    }

    public static Handlers<ImageView> withPlaceholder(Handlers<ImageView> handlers, int drawableRes, int tintColor) {
        handlers.placeholder = viewHolder -> {
            centerRes(viewHolder, drawableRes);
            tint(viewHolder, tintColor);
        };
        return handlers;
    }

    public static Handlers<ImageView> whenError(Handlers<ImageView> handlers, int drawableRes, int tintColor) {
        handlers.error = viewHolder -> {
            centerRes(viewHolder, drawableRes);
            tint(viewHolder, tintColor);
        };
        return handlers;
    }

    public static void centerRes(ViewHolder<ImageView> viewHolder, int drawableRes) {
        ImageView imgView = viewHolder.get();
        imgView.setScaleType(ImageView.ScaleType.CENTER);
        imgView.setImageResource(drawableRes);
    }

    public static void tint(ViewHolder<ImageView> viewHolder, int tintColor) {
        ImageView imgView = viewHolder.get();
        imgView.setColorFilter(tintColor, PorterDuff.Mode.MULTIPLY);
    }

    ///////////////////////////////////////////

    public static Bitmap tintBitmap(Bitmap originalBitmap, int tintColor) {
        // Create a mutable bitmap to draw on
        Bitmap tintedBitmap = Bitmap.createBitmap(originalBitmap.getWidth(), originalBitmap.getHeight(), originalBitmap.getConfig());

        // Create a canvas to draw on the new bitmap
        Canvas canvas = new Canvas(tintedBitmap);

        // Create a paint object and set the color filter
        Paint paint = new Paint();
        paint.setColorFilter(new PorterDuffColorFilter(tintColor, PorterDuff.Mode.MULTIPLY));

        // Draw the original bitmap onto the canvas with the paint
        canvas.drawBitmap(originalBitmap, 0, 0, paint);

        return tintedBitmap;
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/util/ImageViewHolder.java`:

```java
package com.tomclaw.imageloader.util;

import android.view.ViewGroup;
import android.view.ViewTreeObserver;
import android.widget.ImageView;

import com.tomclaw.imageloader.core.ViewHolder;
import com.tomclaw.imageloader.core.ViewSize;

import java.util.concurrent.CountDownLatch;

public class ImageViewHolder implements ViewHolder<ImageView> {

    private final ImageView imageView;

    public ImageViewHolder(ImageView imageView) {
        this.imageView = imageView;
    }

    @Override
    public ViewSize optSize() {
        ViewGroup.LayoutParams params = imageView.getLayoutParams();
        int width;
        if(params != null && params.width > 0) {
            width = params.width;
        }
        else if (imageView.getWidth() > 0)
            width = imageView.getWidth();
        else width = ViewGroup.LayoutParams.MATCH_PARENT;

        if(width == ViewGroup.LayoutParams.WRAP_CONTENT)
            width = imageView.getContext().getResources().getDisplayMetrics().widthPixels;


        int height;
        if(params != null && params.height > 0) {
            height = params.height;
        }
        else if (imageView.getHeight() > 0)
            height = imageView.getHeight();
        else height = ViewGroup.LayoutParams.MATCH_PARENT;

        if(height == ViewGroup.LayoutParams.WRAP_CONTENT)
            height = imageView.getContext().getResources().getDisplayMetrics().heightPixels;


        return width > 0 && height > 0 ? new ViewSize(width, height) : null;
    }

    @Override
    public ViewSize getSize() {
        ViewSize optSize = optSize();
        if(optSize != null) return optSize;

        final ViewSize[] viewSize = {null};
        CountDownLatch latch = new CountDownLatch(1);

        ViewTreeObserver viewTreeObserver = imageView.getViewTreeObserver();
        ViewTreeObserver.OnPreDrawListener preDrawListener = new ViewTreeObserver.OnPreDrawListener() {

            private boolean isResumed = false;

            @Override
            public boolean onPreDraw() {
                ViewSize size = optSize();
                if(size != null) {
                    viewSize[0] = size;
                    if(viewTreeObserver.isAlive()) // without this: java.lang.IllegalStateException: This ViewTreeObserver is not alive, call getViewTreeObserver() again
                        viewTreeObserver.removeOnPreDrawListener(this);

                    if(!isResumed) {
                        isResumed = true;
                        latch.countDown();
                    }
                }
                return true;
            }
        };
        viewTreeObserver.addOnPreDrawListener(preDrawListener);

        try {
            latch.await();
        }
        catch(InterruptedException e) {
            throw new RuntimeException(e);
        }
        return viewSize[0];
    }

    @Override
    public Object getTag() {
        return imageView.getTag();
    }

    @Override
    public void setTag(Object value) {
        imageView.setTag(value);
    }

    @Override
    public ImageView get() {
        return imageView;
    }
}
```

`app/src/main/java/com/tomclaw/imageloader/util/ImageViews.java`:

```java
package com.tomclaw.imageloader.util;

import android.support.annotation.Nullable;
import android.widget.ImageView;

import com.tomclaw.imageloader.SimpleImageLoader;
import com.tomclaw.imageloader.core.Handlers;

public class ImageViews {

    // translated from extension function for Handlers<ImageView>
    @FunctionalInterface
    public interface handlersFn {
        void fn(Handlers<ImageView> handlers);
    }

    static final handlersFn emptyHandlersFn = h -> {};

    public static void fetch(ImageView imageView, String url, @Nullable handlersFn params) {
        Handlers<ImageView> handlers = new Handlers<>();
        handlers.success = (viewHolder, result) -> viewHolder.get().setImageDrawable(result.getDrawable());
        if(params == null) params = emptyHandlersFn;
        params.fn(handlers);
        ImageViewHolder viewHolder = new ImageViewHolder(imageView);
        try {
            SimpleImageLoader.getImageLoader(imageView.getContext()).load(viewHolder, url, handlers);
        }
        catch(Exception e) {
            throw new RuntimeException(e);
        }
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/util/loader/ContentLoader.java`:

```java
package com.tomclaw.imageloader.util.loader;

import android.content.ContentResolver;
import android.net.Uri;

import com.tomclaw.imageloader.core.Loader;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Collections;
import java.util.List;

import it.pgp.xfiles.utils.Misc;

public class ContentLoader implements Loader {

    private final ContentResolver contentResolver;

    public ContentLoader(ContentResolver contentResolver) {
        this.contentResolver = contentResolver;
    }

    @Override
    public List<String> getSchemes() {
        return Collections.singletonList("content");
    }

    @Override
    public boolean load(String uriString, File file) {
        Uri uri = Uri.parse(uriString);
        try(InputStream input = contentResolver.openInputStream(uri);
            OutputStream output = new FileOutputStream(file)) {
            Misc.pipe(input,output);
            return true;
        }
        catch(IOException e) {
            return false;
        }
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/util/loader/FileLoader.java`:

```java
package com.tomclaw.imageloader.util.loader;

import android.content.res.AssetManager;

import com.tomclaw.imageloader.core.Loader;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InterruptedIOException;
import java.io.OutputStream;
import java.net.URI;
import java.net.URISyntaxException;
import java.util.Collections;
import java.util.List;

public class FileLoader implements Loader {

    public static boolean safeCopyTo(InputStream safeCopyTo, OutputStream output) {
        try {
            copyTo(safeCopyTo, output);
            return true;
        }
        catch(Throwable t) {
            t.printStackTrace();
            return false;
        }
    }

    public static void copyTo(InputStream inputStream, OutputStream outputStream) throws IOException {
        byte[] bArr = new byte[10240];
        do {
            int read = inputStream.read(bArr);
            if(read == -1) return;
            outputStream.write(bArr, 0, read);
        }
        while(!Thread.interrupted());
        throw new InterruptedIOException();
    }

    private static final String ASSET_PREFIX = "/android_asset/";

    private final AssetManager assets;

    public FileLoader(AssetManager assets) {
        this.assets = assets;
    }

    @Override
    public List<String> getSchemes() {
        return Collections.singletonList("file");
    }

    @Override
    public boolean load(String uriString, File file) {
        URI uri;
        try {
            uri = new URI(uriString);
        }
        catch (URISyntaxException e) {
            throw new RuntimeException(e);
        }
        InputStream input = null;
        OutputStream output = null;
        try {
            if(uri.getPath().startsWith(ASSET_PREFIX)) {
                if(assets != null) input = assets.open(uri.getPath().replace(ASSET_PREFIX, ""));
            }
            else input = new FileInputStream(new File(uri));
            output = new FileOutputStream(file);
            safeCopyTo(input, output);
            return true;
        }
        catch(IOException e) {
            e.printStackTrace();
            return false;
        }
        finally {
            try {input.close();}
            catch(Exception ignored) {}
            try {output.close();}
            catch(Exception ignored) {}
        }
    }
}

```

`app/src/main/java/com/tomclaw/imageloader/util/loader/UrlLoader.java`:

```java
package com.tomclaw.imageloader.util.loader;

import com.tomclaw.imageloader.core.Loader;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Arrays;
import java.util.List;

import it.pgp.xfiles.utils.Misc;

public class UrlLoader implements Loader {
    private static final String METHOD_GET = "GET";
    private static final int TIMEOUT_SOCKET = 70 * 1000;
    private static final int TIMEOUT_CONNECTION = 60 * 1000;


    @Override
    public List<String> getSchemes() {
        return Arrays.asList("http", "https");
    }

    @Override
    public boolean load(String uriString, File file) {
        InputStream input = null;
        OutputStream output = null;
        HttpURLConnection connection = null;
        try {
            connection = openConnection(uriString);
            input = connection.getInputStream();
            output = new FileOutputStream(file);
            if(input != null) {
                int code = connection.getResponseCode();
                if(code >= 200 && code <= 299) {
                    Misc.pipe(input, output);
                    return true;
                }
            }
        }
        catch(Exception e) {
            e.printStackTrace();
        }
        finally {
            try {input.close();} catch(Exception ignored) {}
            try {output.close();} catch(Exception ignored) {}
            if(connection != null) connection.disconnect();
        }
        return false;
    }

    private HttpURLConnection openConnection(String uri) throws Exception {
        URL url = new URL(uri);
        HttpURLConnection c = (HttpURLConnection)url.openConnection();
        c.setRequestMethod(METHOD_GET);
        c.setDoInput(true);
        c.setDoOutput(false);
        c.setConnectTimeout(TIMEOUT_CONNECTION);
        c.setReadTimeout(TIMEOUT_SOCKET);
        return c;
    }
}

```

`app/src/main/java/it/pgp/Native.java`:

```java
package it.pgp;

/**
 * Created by pgp on 07/01/18
 */

public class Native {

    // just ignore the IDE's symbol resolution errors here, we don't need to put C/CPP headers here,
    // just the exported libr.so (which is both executable - for su - and shared object - for jni)

    public static native int isSymLink(String path);
    public static native String stringFromJNI();
    public static native int nHashCode(byte[] input);
    public static native byte[] spongeForHashViewShake(byte[] input, int inputLen, int outputLen);
//    public static native void c20StreamGen(byte[] key, byte[] output);
//    public static native void spongeForHashView(byte[] input, byte[] output);
//    public static native void spongeForHashViewInPlace(byte[] input, int inputLen, byte[] output, int outputLen);
    public static native int sendDetachedFD(int udsToSendFdOver, int fdToSend);

    public static native long sendfstat(int udsToSendStatOver, int fd, String filename_);
    public static native String getPathFromFd(String fdNumAsString);
}

```

`app/src/main/java/it/pgp/xfiles/BrowserItem.java`:

```java
package it.pgp.xfiles;

import android.widget.Checkable;

import java.io.Serializable;
import java.util.Date;
import java.util.Map;

import it.pgp.xfiles.roothelperclient.resps.ls_resp;

/**
 * Created by pgp on 26/09/16
 */

public class BrowserItem implements Serializable, Checkable, Comparable<BrowserItem> {
    public Boolean isDirectory;
    public Boolean isLink;
    public String filename;
    public Long size;
    public Date date;
    private boolean checked = false;
    public boolean isNestedDir = false;

    public BrowserItem(String filename, long size, Date date, Boolean isDirectory, Boolean isLink) {
        this.filename = filename;
        this.size = size;
        this.date = date;
        this.isDirectory = isDirectory;
        this.isLink = isLink;
    }

    // build from roothelper ls response
    public BrowserItem(ls_resp resp) {
        filename = new String(resp.filename); // new String(resp.filename,"UTF-8")
        size = resp.size;
        date = new Date(resp.date*1000);
        isDirectory = resp.permissions[0]=='d' || resp.permissions[0]=='L'; // new String(resp.permissions, "UTF-8").charAt(0) == 'd')
        isLink = resp.permissions[0]=='l' || resp.permissions[0]=='L';
    }

    // build item from vMap node properties
    // a directory entry may not be stored explicitly in an archive, so attributes may not exists in the vmap
    // for simplicity, then, assume isDir true when isDir not present, and set default values for other attributes
    public BrowserItem(String name, Map<String,?> nodeProperties) {
        this.filename = name;
        if (nodeProperties == null) {
            this.isDirectory = true;
            this.size = 0L;
            this.date = new Date(0);
            this.isLink = false; // assume no directory softlink in archive
        }
        else {
            this.size = nodeProperties.containsKey("size")?(Long)nodeProperties.get("size"):0;
            this.date = nodeProperties.containsKey("date")?(Date)nodeProperties.get("date"):new Date(0);
            this.isDirectory = nodeProperties.containsKey("isDir")?(Boolean)nodeProperties.get("isDir"):true;
            this.isLink = nodeProperties.containsKey("isLink")?(Boolean)nodeProperties.get("isLink"):false;
        }
        this.checked = false;
    }

    public String getFileExt() {
        String extension = "";
        int i = filename.lastIndexOf('.');
        if (i > 0) extension = filename.substring(i+1);
        return extension;
    }

    public boolean hasExt() {
        int i = filename.lastIndexOf('.');
        return (i>0);
    }

    @Override
    public boolean isChecked() {
        return checked;
    }

    @Override
    public void setChecked(boolean checked) {
        this.checked = checked;
    }

    @Override
    public void toggle() {
        checked = !checked;
    }

    @Override
    public int compareTo(BrowserItem o) {
        return filename.compareTo(o.filename); // sort by filename attribute
    }

    @Override
    public String toString() {
        return filename+"\t"+size+"\t"+date+"\t"+isDirectory+"\t"+isLink;
    }

    public String getFilename() {
        return filename;
    }
}

```

`app/src/main/java/it/pgp/xfiles/BrowserViewPager.java`:

```java
package it.pgp.xfiles;

import android.content.Context;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.util.Log;
import android.view.MotionEvent;

/**
 * Web source:
 * https://stackoverflow.com/questions/16671382/limited-swipe-area-android#16671976
 * for limiting swipe area when in continuous (grid) select mode
 *
 * TODO fix coupling between modes (selection enabled, continuous selection, grid vs list view)
 * example: if select mode is on and switch to grid, padLayout is not full
 * (each one of the three button should update compound mode behaviour accordingly)
 */

public class BrowserViewPager extends ViewPager {

    public final MainActivity mainActivity;

    public BrowserViewPager(Context context) {
        super(context);
        this.mainActivity = (MainActivity) context;
    }

    public BrowserViewPager(Context context, AttributeSet attrs) {
        super(context, attrs);
        this.mainActivity = (MainActivity) context;
    }

    private void update() {
        mainActivity.updateScreenDimensions();
        startX = 0.15f*(mainActivity.currentScreenDimensions.x);
        endX = 0.85f*(mainActivity.currentScreenDimensions.x);
        Log.d(getClass().getName(),"startX: "+startX+" endX: "+endX);
    }

    private float startX,endX;
    public boolean swipeDisabled = false; // true if no continuous (grid) selection enabled

    public void switchNeutralArea() {
        swipeDisabled = !swipeDisabled;
        update();
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if(swipeDisabled && inNeutralArea(ev.getX(),ev.getY())) {
            //--events re-directed to this ViewPager's onTouch() and to its child views from there--
            return false;
        }
        else {
            //--events intercepted by this ViewPager's default implementation, where it looks for swipe gestures--
            return super.onInterceptTouchEvent(ev);
        }
    }

    // area in which swipe must be disabled
    private boolean inNeutralArea(float x, float y) {
        return x > startX && x < endX; // allow swiping only from screen borders
    }
}

```

`app/src/main/java/it/pgp/xfiles/CopyListUris.java`:

```java
package it.pgp.xfiles;

import android.net.Uri;

import java.util.ArrayList;
import java.util.List;

public class CopyListUris extends CopyMoveListPathContent {

    public List<String> contentUris;

    public CopyListUris(List<String> contentUris) {
        super();
        this.contentUris = contentUris;
    }

    public static CopyListUris getFromUriList(List<Uri> uris) {
        List<String> urisAsStrings = new ArrayList<>();
        for (Uri uri : uris) urisAsStrings.add(uri.toString());
        return new CopyListUris(urisAsStrings);
    }
}

```

`app/src/main/java/it/pgp/xfiles/CopyMoveListPathContent.java`:

```java
package it.pgp.xfiles;

import android.support.annotation.NonNull;

import java.io.Serializable;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import it.pgp.xfiles.adapters.BrowserAdapter;
import it.pgp.xfiles.enums.CopyMoveMode;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 15/05/17
 * Stores parent dir as BasePathContent, and items as BrowserItem (size and attributes known in advance)
 */

public class CopyMoveListPathContent implements Serializable,Iterable<String> {
    public List<BrowserItem> files; // only filenames, to be concatenated with parentDir (full path of parent folder)
    public CopyMoveMode copyOrMove;
    public BasePathContent parentDir;

    // multiple selection
    public CopyMoveListPathContent(BrowserAdapter ba, CopyMoveMode copyOrMove, BasePathContent parentDir) {
        this.copyOrMove = copyOrMove;
        this.parentDir = parentDir;
        this.files = new ArrayList<>();

        for(int i=0; i<ba.getCount(); i++) {
            BrowserItem b = ba.getItem(i);
            if (b != null && b.isChecked()) this.files.add(b);
        }
    }

    // single-file
    public CopyMoveListPathContent(BrowserItem b, CopyMoveMode copyOrMove, BasePathContent parentDir) {
        this.copyOrMove = copyOrMove;
        this.parentDir = parentDir;
        this.files = Collections.singletonList(b);
    }

    // multiple selection, for XREDirectShareActivity
    public CopyMoveListPathContent(List<BrowserItem> files, CopyMoveMode copyOrMove, BasePathContent parentDir) {
        this.copyOrMove = copyOrMove;
        this.parentDir = parentDir;
        this.files = files;
    }

    // for handling received content URIs from third-party apps
    public CopyMoveListPathContent() {
        copyOrMove = CopyMoveMode.COPY;
    }

    @NonNull
    @Override
    public Iterator<String> iterator() {
        return new Iterator<String>() {
            final Iterator<BrowserItem> i = files.iterator();

            @Override
            public boolean hasNext() {
                return i.hasNext();
            }

            @Override
            public String next() {
                return parentDir+"/"+i.next().filename;
            }
        };
    }

    // iterator for SFTP download preliminary progress building: returns full remote paths and file type (file or dir)
    public Iterable<Map.Entry<String,Boolean>> getSFTPProgressHelperIterable() {
        return () -> new Iterator<Map.Entry<String, Boolean>>() {
            final Iterator<BrowserItem> i = files.iterator();
            @Override
            public boolean hasNext() {
                return i.hasNext();
            }
            @Override
            public Map.Entry<String, Boolean> next() {
                BrowserItem b = i.next();
                return new AbstractMap.SimpleEntry<>(
                        parentDir.dir + "/" + b.filename, b.isDirectory);
            }
        };
    }

    public Iterable<Map.Entry<String,Boolean>> getSFTPProgressHelperIterableFilenamesOnly() {
        return () -> new Iterator<Map.Entry<String, Boolean>>() {
            final Iterator<BrowserItem> i = files.iterator();
            @Override
            public boolean hasNext() {
                return i.hasNext();
            }
            @Override
            public Map.Entry<String, Boolean> next() {
                BrowserItem b = i.next();
                return new AbstractMap.SimpleEntry<>(b.filename, b.isDirectory);
            }
        };
    }

    public Iterable<String> asNameOnlyStrings() {
        return () -> new Iterator<String>() {
            final Iterator<BrowserItem> i = files.iterator();
            @Override
            public boolean hasNext() {
                return i.hasNext();
            }

            @Override
            public String next() {
                return i.next().filename;
            }
        };
    }
}

```

`app/src/main/java/it/pgp/xfiles/EffectActivity.java`:

```java
package it.pgp.xfiles;

import android.app.ActionBar;
import android.app.Activity;
import android.content.ComponentName;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Bundle;

import java.io.Serializable;

public abstract class EffectActivity extends Activity {

    protected ActionBar b;

    protected void setActivityIcon(int resId) {
        if (b != null) b.setIcon(resId);
    }

    public static Object currentlyOnFocus;

    public static final DialogInterface.OnShowListener defaultDialogShowListener = d -> EffectActivity.currentlyOnFocus = d;

    @Override
    protected void onCreate(final Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        b = getActionBar();
        overridePendingTransition(R.anim.fade_in,R.anim.fade_out);
    }

    @Override
    protected void onResume() {
        super.onResume();
        currentlyOnFocus = this;
    }

    @Override
    protected void onPause() {
        super.onPause();
        overridePendingTransition(R.anim.fade_in,R.anim.fade_out);
        if(this instanceof MainActivity) currentlyOnFocus = null;
    }

    public static Serializable serviceParams;

    // useful for removing usage of parcelization (which prevents using lazy iterables as params)
    @Override
    public ComponentName startService(Intent service) {
        serviceParams = service.getSerializableExtra("params");
        service.putExtra("params",(Serializable)null);
        return super.startService(service);
    }
}

```

`app/src/main/java/it/pgp/xfiles/FavoritesActivity.java`:

```java
package it.pgp.xfiles;

import android.os.Bundle;
import android.support.v4.view.ViewPager;

import it.pgp.xfiles.adapters.FavoritesPagerAdapter;

/**
 * Created by pgp on 06/07/17
 */

public class FavoritesActivity extends EffectActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle("Favorites Manager");
        setActivityIcon(R.drawable.xfiles_favorites);
        setContentView(R.layout.favorites);

        ViewPager viewPager = findViewById(R.id.favorites_viewpager);
        viewPager.setAdapter(new FavoritesPagerAdapter(this));
    }
}

```

`app/src/main/java/it/pgp/xfiles/FindActivity.java`:

```java
package it.pgp.xfiles;

import android.os.Bundle;
import android.view.ContextMenu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.ImageView;
import android.widget.ListView;
import android.widget.Toast;

import java.util.Collections;
import java.util.List;

import it.pgp.xfiles.adapters.FindResultsAdapter;
import it.pgp.xfiles.dialogs.PropertiesDialog;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.roothelperclient.FindInArchiveThread;
import it.pgp.xfiles.roothelperclient.FindManager;
import it.pgp.xfiles.roothelperclient.reqs.find_rq;
import it.pgp.xfiles.utils.ArrayTextView;
import it.pgp.xfiles.utils.FileSelectFragment;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.ArchivePathContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

public class FindActivity extends EffectActivity implements FileSelectFragment.Callbacks {

    ImageButton dropdownButton;
    View dropdownLayout;
    STATUS currentStatus = STATUS.DOWN;

    public static FindActivity instance; // never null after first initialization

    // Dropdown layout views
    Button startSearch,stopSearch,clearResults;

    ArrayTextView basePathTextView;
    ImageView pathTypeImageView;

    Button findPathChooseButton;
    EditText namePattern,contentPattern;
    CheckedTextView searchOnlyCurrentFolder, caseInsensitiveSearch;

    // TODO add case sensitive,escape,regex options widgets for both name and content pattern fields

    ListView resultsView;

    find_rq findRq;

    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu_find,menu);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        AdapterView.AdapterContextMenuInfo info = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo();
        BrowserItem b = FindResultsAdapter.instance.getItem(info.position);
        BasePathContent bpc = FindResultsAdapter.instance.basePaths.get(0).getCopy();
        // by construction, if one is local, all ones are local (archive path must be a single one)
        // and then we ignore it at all, since for local search, result paths are returned as full paths
        if(bpc instanceof LocalPathContent)
            bpc = new LocalPathContent(b.getFilename());
        else if(bpc instanceof ArchivePathContent) {
            // ensure we are starting from archive's root before concat,
            // since find thread returns paths w.r.t. archive's root
            bpc.dir = "";
            bpc = bpc.concat(b.getFilename());
        }
        switch (item.getItemId()) {
            case R.id.findItemLocate:
                finish();
                MainActivity.mainActivity.goDir(
                        bpc.getParent(),
                        MainActivity.mainActivity.browserPager.getCurrentItem(),
                        b.getFilename());
                break;
            case R.id.findItemProperties:
                new PropertiesDialog(this,
                        b.isDirectory ? FileMode.DIRECTORY : FileMode.FILE,
                        Collections.singletonList(bpc)).show();
                break;
        }
        return true;
    }

    void startSearchTask(View unused) {
        FindResultsAdapter.reset(basePathTextView.getTexts());
        resultsView.setAdapter(FindResultsAdapter.instance);
        if(basePathTextView.getTexts().get(0) instanceof ArchivePathContent) startSearchTaskArchive();
        else startSearchTaskLocal();
    }

    void startSearchTaskLocal() {
        findRq = new find_rq(
                basePathTextView.getMultipleLocalPathsAsStrings(),
                namePattern.getText().toString().getBytes(),
                contentPattern.getText().toString().getBytes(),
                new find_rq.FlagBits(searchOnlyCurrentFolder.isChecked()), // only search in subfolders supported currently
                new find_rq.SearchBits(
                        false,
                        false,
                        caseInsensitiveSearch.isChecked(),
                        false,
                        false,
                        false,
                        false,
                        false,
                        false
                        )
        );

        Toast.makeText(this,
                (FindManager.find_action(FindManager.FIND_ACTION.START,findRq) == 1)?
                        "Search started":
                        "Unable to start search, another search task still active?",
                Toast.LENGTH_SHORT).show();
    }

    void startSearchTaskArchive() {
        new FindInArchiveThread(
                (ArchivePathContent) basePathTextView.getTexts().get(0),
                namePattern.getText().toString(),
                !searchOnlyCurrentFolder.isChecked(),
                caseInsensitiveSearch.isChecked()
        ).start();
    }

    void stopSearchTask(View unused) {
        Toast.makeText(this,
                (FindManager.find_action(FindManager.FIND_ACTION.STOP) == 1) ?
                        "Search cancelled":
                        "Error cancelling search"
                , Toast.LENGTH_SHORT).show();
    }

    // called by find threads
    public synchronized void toggleSearchButtons(boolean searchIsActive) {
        startSearch.setEnabled(!searchIsActive);
        stopSearch.setEnabled(searchIsActive);
        clearResults.setEnabled(!searchIsActive);
//        if (searchIsActive ||
//                (FindResultsAdapter.instance != null &&
//                        !FindResultsAdapter.instance.isEmpty()))
        if (searchIsActive)
            onSlideViewButtonClick(null); // slide up search options panel
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        instance = this;
        setActivityIcon(R.drawable.xfiles_find);
        setContentView(R.layout.activity_find);

        dropdownLayout = findViewById(R.id.dropdown_layout);
        dropdownButton = findViewById(R.id.dropdown_button);
        dropdownButton.setImageResource(currentStatus.getDrawable());

        // dropdown layout views
        startSearch = findViewById(R.id.startSearch);
        stopSearch = findViewById(R.id.stopSearch);
        clearResults = findViewById(R.id.clearResults);

        basePathTextView = findViewById(R.id.find_path_textview);
        basePathTextView.setTexts((List<BasePathContent>) getIntent().getSerializableExtra("paths"));
        pathTypeImageView = findViewById(R.id.find_path_type);
        findPathChooseButton = findViewById(R.id.find_path_choose_button);
        findPathChooseButton.setOnClickListener(this::openDestinationFolderSelector);
        namePattern = findViewById(R.id.find_name_pattern_edittext);
        contentPattern = findViewById(R.id.find_content_pattern_edittext);

        searchOnlyCurrentFolder = findViewById(R.id.find_only_current_folder_checkbox);
        caseInsensitiveSearch = findViewById(R.id.case_insensitive_search_checkbox);
        searchOnlyCurrentFolder.setOnClickListener(Misc.ctvListener);
        caseInsensitiveSearch.setOnClickListener(Misc.ctvListener);

        startSearch.setOnClickListener(this::startSearchTask);
        stopSearch.setOnClickListener(this::stopSearchTask);
        clearResults.setOnClickListener(v -> FindResultsAdapter.reset(basePathTextView.getTexts()));

        // depending on search status (active or not) toggle buttons state
        toggleSearchButtons(FindManager.findManagerThreadRef.get()!=null);

        resultsView = findViewById(R.id.results_view);
        FindResultsAdapter.createIfNotExisting();
        resultsView.setAdapter(FindResultsAdapter.instance);
        registerForContextMenu(resultsView);

        dropdownLayout.bringToFront();
        dropdownButton.bringToFront();

        // set current base path textview
        if(basePathTextView.getTexts().size()>1) pathTypeImageView.setImageResource(R.drawable.xf_dir_blu);
        else {
            BasePathContent bpc = basePathTextView.getTexts().get(0);
            if (bpc.providerType == ProviderType.LOCAL_WITHIN_ARCHIVE)
                pathTypeImageView.setImageResource(R.drawable.xfiles_archive);
            else
                pathTypeImageView.setImageResource(R.drawable.xf_dir_blu);
        }
    }

    public void onSlideViewButtonClick(View unused) {
        dropdownLayout.animate().y(
                (currentStatus == STATUS.DOWN) ?
                        -dropdownLayout.getHeight() : 0).setDuration(1000).start();
        currentStatus = currentStatus.next();
        dropdownButton.bringToFront();
        dropdownButton.setImageResource(currentStatus.getDrawable());
        PopupWindowUtils.toggleSoftKeyBoard(dropdownButton, false);
    }

    @Override
    public void onConfirmSelect(String absolutePath, String fileName) {
        basePathTextView.setText(new LocalPathContent(absolutePath));
        pathTypeImageView.setImageResource(R.drawable.xf_dir_blu);
    }

    @Override
    public boolean isValid(String absolutePath, String fileName) { return true; }

    // duplicated code from ExtractActivity
    public void openDestinationFolderSelector(View unused) {
        String fragTag = getResources().getString(R.string.tag_fragment_FileSelect);

        BasePathContent bpc = basePathTextView.getTexts().get(0);

        // Set up a selector for directory selection.
        FileSelectFragment fsf = FileSelectFragment.newInstance(
                FileSelectFragment.Mode.DirectorySelector,
                android.R.string.ok,
                android.R.string.cancel,
                R.string.alert_file_select,
                R.drawable.xfiles_new_app_icon,
                R.drawable.xf_dir_blu,
                R.drawable.xfiles_file_icon,
                bpc instanceof ArchivePathContent ? bpc.getParent().dir : bpc.dir);

        fsf.show(getFragmentManager(), fragTag);
    }

    private enum STATUS {
        UP(android.R.drawable.arrow_down_float),
        DOWN(android.R.drawable.arrow_up_float);

        int drawable;

        STATUS(int drawable) {
            this.drawable = drawable;
        }

        public int getDrawable() {
            return drawable;
        }

        STATUS next() {
            return this == UP ? DOWN : UP;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/GalleryViewPager.java`:

```java
package it.pgp.xfiles;

import android.content.Context;
import android.support.v4.view.ViewPager;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;

import it.pgp.xfiles.viewmodels.TouchImageView;

public class GalleryViewPager extends ViewPager {

    public boolean enabled = true;

    public GalleryViewPager(Context context) {
        super(context);
    }

    public GalleryViewPager(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
        if(v instanceof TouchImageView) return ((TouchImageView) v).canScrollHorizontallyFroyo(-dx);
        else return super.canScroll(v, checkV, dx, x, y);
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if(enabled) return super.onInterceptTouchEvent(ev);
        return false;
    }

    @Override
    public boolean onTouchEvent(MotionEvent ev) {
        if(enabled) return super.onTouchEvent(ev);
        return false;
    }
}

```

`app/src/main/java/it/pgp/xfiles/MainActivity.java`:

```java
package it.pgp.xfiles;

import android.Manifest;
import android.app.Activity;
import android.app.ActivityManager;
import android.app.AlertDialog;
import android.app.Dialog;
import android.app.NotificationManager;
import android.app.UiModeManager;
import android.content.ActivityNotFoundException;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.SharedPreferences;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.res.Configuration;
import android.graphics.Point;
import android.net.Uri;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Looper;
import android.os.StatFs;
import android.os.StrictMode;
import android.provider.Settings;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.RequiresApi;
import android.support.v4.view.ViewPager;
import android.util.DisplayMetrics;
import android.util.Log;
import android.util.TypedValue;
import android.view.ContextMenu;
import android.view.ContextThemeWrapper;
import android.view.Display;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.webkit.MimeTypeMap;
import android.widget.AbsListView;
import android.widget.AdapterView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.PopupMenu;
import android.widget.ProgressBar;
import android.widget.RadioButton;
import android.widget.TextView;
import android.widget.Toast;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.Future;

import it.pgp.xfiles.adapters.BrowserAdapter;
import it.pgp.xfiles.adapters.BrowserPagerAdapter;
import it.pgp.xfiles.adapters.OperationalPagerAdapter;
import it.pgp.xfiles.adapters.QuickPathsAdapter;
import it.pgp.xfiles.adapters.RecentPositionsAdapter;
import it.pgp.xfiles.comparators.AdvancedComparator;
import it.pgp.xfiles.dialogs.AdvancedSortingDialog;
import it.pgp.xfiles.dialogs.BulkRenameDialog;
import it.pgp.xfiles.dialogs.ChecksumActivity;
import it.pgp.xfiles.dialogs.CloseActiveServersDialog;
import it.pgp.xfiles.dialogs.CreateFileOrDirectoryDialog;
import it.pgp.xfiles.dialogs.CreateLinkDialog;
import it.pgp.xfiles.dialogs.FilterSelectionDialog;
import it.pgp.xfiles.dialogs.GenericChangeDirectoryDialog;
import it.pgp.xfiles.dialogs.OpenAsDialog;
import it.pgp.xfiles.dialogs.PropertiesDialog;
import it.pgp.xfiles.dialogs.RamdiskDialog;
import it.pgp.xfiles.dialogs.RemoteRHServerManagementDialog;
import it.pgp.xfiles.dialogs.RenameDialog;
import it.pgp.xfiles.dialogs.SSHAlreadyInKnownHostsDialog;
import it.pgp.xfiles.dialogs.SSHNotInKnownHostsDialog;
import it.pgp.xfiles.dialogs.UpdateCheckDialog;
import it.pgp.xfiles.dialogs.XFilesRemoteSessionsManagementActivity;
import it.pgp.xfiles.dialogs.compress.AskPasswordDialogOnListing;
import it.pgp.xfiles.dialogs.compress.CompressActivity;
import it.pgp.xfiles.dialogs.compress.ExtractActivity;
import it.pgp.xfiles.enums.ArchiveType;
import it.pgp.xfiles.enums.BrowserViewMode;
import it.pgp.xfiles.enums.ComparatorField;
import it.pgp.xfiles.enums.CopyMoveMode;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ForegroundServiceType;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.fileservers.FileServer;
import it.pgp.xfiles.roothelperclient.RemoteClientManager;
import it.pgp.xfiles.roothelperclient.RemoteServerManager;
import it.pgp.xfiles.roothelperclient.RootHandler;
import it.pgp.xfiles.roothelperclient.RootHelperClient;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.CopyMoveService;
import it.pgp.xfiles.service.ExtractService;
import it.pgp.xfiles.service.HTTPUploadService;
import it.pgp.xfiles.service.NonInteractiveSftpService;
import it.pgp.xfiles.service.NonInteractiveSmbService;
import it.pgp.xfiles.service.NonInteractiveXFilesRemoteTransferService;
import it.pgp.xfiles.service.TestService;
import it.pgp.xfiles.service.params.CopyMoveParams;
import it.pgp.xfiles.service.params.DownloadParams;
import it.pgp.xfiles.service.params.ExtractParams;
import it.pgp.xfiles.service.params.TestParams;
import it.pgp.xfiles.service.visualization.ProgressIndicator;
import it.pgp.xfiles.sftpclient.InteractiveHostKeyVerifier;
import it.pgp.xfiles.sftpclient.SFTPProvider;
import it.pgp.xfiles.sftpclient.VaultActivity;
import it.pgp.xfiles.smbclient.SmbProvider;
import it.pgp.xfiles.smbclient.SmbVaultActivity;
import it.pgp.xfiles.utils.ContentProviderUtils;
import it.pgp.xfiles.utils.DirCommander;
import it.pgp.xfiles.utils.FileOperationHelper;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.SelectImageButtonListener;
import it.pgp.xfiles.utils.XFilesUtils;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.dircontent.SftpDirWithContent;
import it.pgp.xfiles.utils.pathcontent.ArchivePathContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;
import it.pgp.xfiles.utils.pathcontent.SFTPPathContent;
import it.pgp.xfiles.viewmodels.PasteableEditText;

public class MainActivity extends EffectActivity {

    /************** JNI part **************/
    static {
        System.loadLibrary("r"); // libr.so
        // avoid messing up with content URIs
        StrictMode.setVmPolicy(StrictMode.VmPolicy.LAX);
    }
    /************** end JNI part **************/

    public static MainActivity mainActivity;
    public static Context context;
    public static final Handler handler = new Handler(Looper.getMainLooper());

    public ActivityManager activityManager;

    public BrowserViewPager browserPager;

    private CopyMoveListPathContent copyMoveList = null; // only one for the entire ViewPager (you may want to copy files from one browser view to the other one)

    private LayoutInflater layoutInflater;

    public BrowserPagerAdapter browserPagerAdapter;

    public static final int fullScreenVisibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_FULLSCREEN
            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;

    public static final int horizontalVisibility = View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;

    public int defaultUIVisibility;

    public void makeImageButtonsStateful(ViewGroup layout, SelectImageButtonListener l) {
        for (int i = 0; i < layout.getChildCount(); i++) {
            View vv = layout.getChildAt(i);
            if(vv instanceof ImageButton && deviceType != DeviceType.TV)
                vv.setOnTouchListener(l);
            int id = vv.getId();
            if(id == R.id.goBackButton || id == R.id.goAheadButton)
                vv.setOnLongClickListener(v -> {
                    RecentPositionsAdapter.showPopup(this,id == R.id.goAheadButton, v);
                    return true;
                });
        }
    }

    // File Operations Helpers
    public static SmbProvider smbProvider;
    public static SFTPProvider sftpProvider;

    public static XFilesUtils xFilesUtils;
    private static RootHelperClient rootHelperClient;

    public FileOperationHelper getFileOpsHelper(ProviderType providerType) {
        switch(providerType) {
            case LOCAL:
                return usingRootHelperForLocal?getRootHelperClient():xFilesUtils;
            case LOCAL_WITHIN_ARCHIVE:
            case XFILES_REMOTE:
            case URL_DOWNLOAD:
                return getRootHelperClient();
            case SFTP:
                return sftpProvider;
            case SMB:
                return smbProvider;
            default:
                return null;
        }
    }

    public static RootHelperClient getRootHelperClient(Context... context) {
        if (rootHelperClient == null) {
            rootHelperClient = RootHandler.startAndGetRH(context);
            if (rootHelperClient != null)
                showToast(RootHandler.isRootAvailableAndGranted?
                        "Started roothelper in root mode":
                        "Root privileges not available, started roothelper in normal mode");
            else showToast("Unable to start roothelper");
        }
        return rootHelperClient;
    }

    public static void killRHWrapper() {
        try {
            rootHelperClient.killServer();
        }
        catch (NullPointerException n) {
            Log.e("RH","Unable to kill roothelper server, reference already null");
        }
        catch (Exception e) {
            Log.e("RH","Unable to kill roothelper server",e);
        }
        rootHelperClient = null;
    }

    public static final RemoteClientManager rootHelperRemoteClientManager = new RemoteClientManager();
    public static boolean usingRootHelperForLocal = false;

    public BrowserAdapter getCurrentBrowserAdapter() {
        return browserPagerAdapter.browserAdapters[browserPager.getCurrentItem()];
    }

    public DirCommander getCurrentDirCommander() {
        return browserPagerAdapter.dirCommanders[browserPager.getCurrentItem()];
    }

    public AbsListView getCurrentMainBrowserView() {
        return browserPagerAdapter.mainBrowserViews[browserPager.getCurrentItem()];
    }

    public static void refreshAppContext(Context context) {
        MainActivity.context = context;
    }

    public static void showToast(String s) {
        handler.post(()-> Toast.makeText(context, s, Toast.LENGTH_SHORT).show());
    }

    public ProgressBar progressCircleForGoDirOps;
    public ImageButton showNavLayoutBtn;
    public ImageButton fileOperationHelperSwitcher;

    ImageButton quickFindButton,
            itemSelectionButton,
            sortButton,
            credsFavsButton,
            chooseBrowserViewButton;

    public LinearLayout quickPathsLayout;
    ListView quickPathsListView;

    public AdapterView.OnItemClickListener listViewLevelOICL = new AdapterView.OnItemClickListener() {
        @Override
        public void onItemClick(AdapterView<?> parent, View view, int position, long id) {

            BrowserAdapter ba = getCurrentBrowserAdapter();
            BrowserItem browserItem = ba.getItem(position);

            if (browserPagerAdapter.multiSelectModes[browserPager.getCurrentItem()]) {
                // if in multi select mode, simply select item
                ba.toggleSelectOne(browserItem);
                return;
            }
//            String currentFile = getCurrentDirCommander().getCurrentDirectoryPathname() + "/" + browserItem.filename;
            BasePathContent currentFile = getCurrentDirCommander().getCurrentDirectoryPathname().concat(browserItem.filename);

            // file or dir may have been deleted meanwhile, anyway don't do this check here, since it couples fileopshelper responsibilities with browseradapter ones
//            if (!currentHelper.exists(currentFile)) {
//                Toast.makeText(parent.getContext(),"File should exist: "+currentFile,Toast.LENGTH_LONG).show();
//                return;
//            }

            // open local directory
            if (browserItem.isDirectory) {
                goDir_async(currentFile,null);
                return;
            }

            // from now on, exclude any open operation on non-local path contents
            if (currentFile.providerType != ProviderType.LOCAL) return;

            // open local archive
            if (browserItem.hasExt()) {
                String arcExt = browserItem.getFileExt();
                ArchivePathContent apc = new ArchivePathContent(currentFile.dir,"/");
                if(ArchiveType.APK.name().equals(arcExt.toUpperCase())) {
                    AlertDialog.Builder bld = new AlertDialog.Builder(MainActivity.this);
                    bld.setTitle("Choose APK action");
                    bld.setNegativeButton("Install", (dialog, which) -> installApk(new File(currentFile.dir)));
                    bld.setPositiveButton("Open as archive", (dialog, which) -> goDir_async(apc,null));
                    bld.create().show();
                    return;
                }
                if(ArchiveType.formats.contains(arcExt)) {
                    goDir_async(apc,null);
                    return;
                }
            }

            // TODO take BasePathContent as input
            openWithDefaultApp(new File(currentFile.dir));
        }
    };

    public Point currentScreenDimensions; // TODO should be updated on screen rotation
    public void updateScreenDimensions() {
        Display display = getWindowManager().getDefaultDisplay();
        Point size = new Point();
        display.getSize(size);
        currentScreenDimensions = size;
    }

    public void getStats(BrowserItem b) {
        new PropertiesDialog(MainActivity.this,
                b.isDirectory?FileMode.DIRECTORY :FileMode.FILE,
                Collections.singletonList(getCurrentDirCommander().getCurrentDirectoryPathname().concat(b.filename))).show();
    }

    // for current browserAdapter selection
    public void getStats() {
        PropertiesDialog propertiesDialog = new PropertiesDialog(
                MainActivity.this,
                null,
                getCurrentBrowserAdapter().getSelectedItemsAsPathContents());
        propertiesDialog.show();
    }

    private void showDeleteDialog(final List<BasePathContent> selection) {
        AlertDialog.Builder bld = new AlertDialog.Builder(MainActivity.this);
        int size = selection.size();
        String name = size==1?selection.get(0).getName():""+size+" items";
        bld.setTitle("Delete items");
        bld.setIcon(R.drawable.xf_recycle_bin);
        bld.setNegativeButton(android.R.string.cancel, null);
        bld.setPositiveButton(android.R.string.ok, null);

        TextView a = new TextView(this);
        a.setText("Confirm delete "+name);
        a.setTextSize(TypedValue.COMPLEX_UNIT_SP, 18);
        bld.setView(a);

        AlertDialog alertDialog = bld.create();
        alertDialog.show();

        Button ok = alertDialog.getButton(AlertDialog.BUTTON_POSITIVE);
        Button no = alertDialog.getButton(AlertDialog.BUTTON_NEGATIVE);
        ok.setOnClickListener(view -> {
            int posToRestore = browserPagerAdapter.mainBrowserViews[browserPager.getCurrentItem()].getFirstVisiblePosition();
            a.setText("Deleting...");
            ok.setEnabled(false);
            no.setEnabled(false);
            new Thread(()->{
                try {
                    mainActivity.getFileOpsHelper(selection.get(0).providerType).deleteFilesOrDirectories(selection);
                    runOnUiThread(()->{
                        Toast.makeText(MainActivity.this,((size==1)?name:(size+" items"))+" deleted", Toast.LENGTH_SHORT).show();
                        browserPagerAdapter.showDirContent(getCurrentDirCommander().refresh(),browserPager.getCurrentItem(),posToRestore);
                    });
                }
                catch (IOException e) {
                    e.printStackTrace();
                    showToast("Unable to delete some items");
                }
                alertDialog.dismiss();
            }).start();
        });
    }

    private byte[] reverseByteArray(byte[] b) {
        byte[] c = new byte[b.length];
        for (int i=0;i<b.length;i++)
            c[b.length-1-i] = b[i];
        return c;
    }

    public String getMyIP() {
        WifiManager manager = (WifiManager)getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        WifiInfo wifiinfo = manager.getConnectionInfo();
        byte[] myIPAddress = BigInteger.valueOf(wifiinfo.getIpAddress()).toByteArray();
        myIPAddress = reverseByteArray(myIPAddress);
        InetAddress myInetIP;
        try {
            myInetIP = InetAddress.getByAddress(myIPAddress);
            return myInetIP.getHostAddress();
        }
        catch (UnknownHostException e) {
            e.printStackTrace();
            return "UNKNOWN";
        }
    }

    public void showXREConnections(View unused) {
        Intent i = new Intent(MainActivity.this, XFilesRemoteSessionsManagementActivity.class);
        startActivity(i);
    }

    public void showStartRHRemoteServerDialog(View unused) {
        new RemoteRHServerManagementDialog(MainActivity.this).show();
    }

    public void showNavLayout(View unused) {
        QuickPathsAdapter a = QuickPathsAdapter.create(this);
        quickPathsListView.setAdapter(a);
        quickPathsListView.setOnItemClickListener((parent, view, position, id) -> goDir_async(new LocalPathContent(a.getItem(position)),null));
        quickPathsListView.setOnItemLongClickListener((parent, view, position, id) -> {
            StatFs statFs = new StatFs(a.getItem(position));
            long availableBytes = statFs.getAvailableBytes();
            long freeBytes = statFs.getFreeBytes();
            long totalBytes = statFs.getTotalBytes();
            String s = "Available: "+availableBytes+" bytes ("+Misc.getHumanReadableFileSize(availableBytes)+")\nFree: "+
                    freeBytes+" bytes ("+Misc.getHumanReadableFileSize(freeBytes)+")\nTotal: "+
                    totalBytes+" bytes ("+Misc.getHumanReadableFileSize(totalBytes)+")";
            AlertDialog.Builder bld = new AlertDialog.Builder(MainActivity.this);
            TextView content = new TextView(MainActivity.this);
            content.setText(s);
            content.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
            bld.setTitle("Disk stats");
            bld.setView(content);
            bld.setNeutralButton(android.R.string.ok, null);
            bld.create().show();
            return true;
        });
        quickPathsLayout.setVisibility(View.VISIBLE);
        quickPathsListView.requestFocus();
    }

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if(quickPathsLayout.getVisibility() == View.VISIBLE) {
            if(Misc.isWithinViewBounds((int)ev.getRawX(), (int)ev.getRawY(), quickPathsLayout)) {
                return super.dispatchTouchEvent(ev);
            }
            else {
                quickPathsLayout.setVisibility(View.GONE);
                return true;
            }
        }
        return super.dispatchTouchEvent(ev);
    }

    private boolean wasShortClick = false;
    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
        super.onCreateContextMenu(menu, v, menuInfo);
        MenuInflater inflater = getMenuInflater();

        if (v instanceof ImageButton) {
            switch (v.getId()) {
                case R.id.sortButton:
                    if (wasShortClick)
                        inflater.inflate(R.menu.menu_sort, menu);
                    else
                        new AdvancedSortingDialog(MainActivity.this,getCurrentBrowserAdapter()).show();
                    wasShortClick = false;
                    break;
                case R.id.itemSelectionButton:
                    inflater.inflate(R.menu.menu_checkbox, menu);
                    break;
                case R.id.openCredsFavsMenu:
                    inflater.inflate(R.menu.menu_credentials_favorites, menu);
                    break;
                default: // chooseBrowserViewButton
                    inflater.inflate(R.menu.menu_browserview, menu);
            }
        }
        else if (v.getId()==R.id.currentDirectoryTextView) {
            inflater.inflate(R.menu.menu_fast_changedir,menu);
        }
        else {
            Toast.makeText(this, "Switch not allowed anymore here, check showPopup", Toast.LENGTH_SHORT).show();
        }
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        int itemId = item.getItemId();
        switch(itemId) {

            // check showPopup for additional items moved from here

            // sorting
            // TODO need to add directory priority switch some way (used priority on as default)
            case R.id.sortByFilename:
            case R.id.sortByFilenameDesc:
            case R.id.sortByDate:
            case R.id.sortByDateDesc:
            case R.id.sortBySize:
            case R.id.sortBySizeDesc:
            case R.id.sortByType:
            case R.id.sortByTypeDesc:
                Pair<ComparatorField, Boolean> whichAttribute_reverse = ComparatorField.fromResMap.get(itemId);
                browserPagerAdapter.browserAdapters[browserPager.getCurrentItem()].sort(new AdvancedComparator(new SortingItem(whichAttribute_reverse.i, true, whichAttribute_reverse.j)));
                return true;
            // browser view
            case R.id.listBrowserViewMode:
                return true;
            case R.id.gridBrowserViewMode:
                return true;

            // sftp credentials or favorites
            case R.id.openSftpCredManager:
            case R.id.openSmbCredManager:
            case R.id.openFavsManager:
                openCredOrFavsManager(itemId);
                return true;

            case R.id.openRamdiskManager:
                new RamdiskDialog(this).show();
                return true;

            case R.id.openAboutDialog:
                openAboutDialog();
                return true;
            case R.id.openPermissionActivity:
                startPermissionManagementActivity();
                return true;

            // fast menu for change directory
            case R.id.localFolder:
            case R.id.localArchive:
            case R.id.sftpRemoteFolder:
            case R.id.xfilesRemoteFolder:
            case R.id.smbRemoteFolder:
            case R.id.httpUrlDownload:
                cdd = new GenericChangeDirectoryDialog(
                        MainActivity.this,
                        getCurrentDirCommander().getCurrentDirectoryPathname()
                );
                cdd.show();
                // using same resIds (with different parent) for both menu items and radiobuttons
                ((RadioButton)cdd.findViewById(itemId)).setChecked(true);
                return true;
            default:
                return true; // No action
        }
    }

    /**************************************************
     * Runtime permission management for Android >= 6 *
     **************************************************/

    public void exitOnPermissionsDenied() {
        Toast.makeText(this,"Some permissions were denied, exiting...",Toast.LENGTH_LONG).show();
        finishAffinity();
    }

    public void restartActivityOnPermissionOK() {
        // with kill process
        Intent i = new Intent(MainActivity.this,RestarterActivity.class);
        i.putExtra("",android.os.Process.myPid());
        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP | Intent.FLAG_ACTIVITY_CLEAR_TASK);
        startActivity(i);
    }

    @RequiresApi(api = Build.VERSION_CODES.M)
    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        if (grantResults.length == 0) { // request cancelled
            exitOnPermissionsDenied();
            return;
        }

        for (int grantResult : grantResults) {
            if (grantResult != PackageManager.PERMISSION_GRANTED) {
                exitOnPermissionsDenied();
                return;
            }
        }

        restartActivityOnPermissionOK();
    }

    // for handling result of alert permission request, once other permission have already been granted
    @RequiresApi(api = Build.VERSION_CODES.M)
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (Settings.canDrawOverlays(this) && Settings.System.canWrite(this))
            restartActivityOnPermissionOK();
        else exitOnPermissionsDenied();
    }

    /**************************************************
     **************************************************
     **************************************************/

    // for receiving intents in open as archive from same app
    // (for archives with unknown extension)

    public void updateFromSelfIntent(Intent intent) {
        String startDir = intent.getStringExtra("STARTDIR");
        // start with custom dir, used at the end of CompressTask if CompressActivity was started by share intent, in order to show the compressed archive in its destination folder
        if(startDir != null) {
            try {
                goDirOrArchive(new LocalPathContent(startDir));
            }
            catch (Exception e) {
                e.printStackTrace();
                Toast.makeText(this, "Unable to access directory: "+startDir, Toast.LENGTH_SHORT).show();
            }
        }
        else if (intent.getData() !=null) {
            if((intent.getFlags() & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) != 0) return; // avoid spurious download intents when re-opening from Recent Apps menu
            try {
                Uri data = intent.getData();
                String path = ContentProviderUtils.getPathFromUri(this, data);
//                Toast.makeText(this, path, Toast.LENGTH_SHORT).show();
                // treat path as archive, since one cannot do open as on folders
                // (even sending intent from other apps, it doesn't make sense to "open as" a folder)
                // obviously, this doesn't work if the path is a in-archive (with relative-to-root subpath not empty) or remote one
                if (path != null) goDirOrArchive(new LocalPathContent(path));
                else if ("https".equalsIgnoreCase(data.getScheme()) || "http".equalsIgnoreCase(data.getScheme())) {
                    // launch URL download dialog, populating it with the received URL
                    showChangeDirectoryDialog_(data.toString());
                }
            }
            catch (Exception e) {
                e.printStackTrace();
                Toast.makeText(this, "Unable to convert URI to path", Toast.LENGTH_SHORT).show();
            }
        }
    }

    @Override
    protected void onNewIntent(Intent intent) {
        updateFromSelfIntent(intent);
    }

    enum DeviceType {
        PHONE, // 0
        TABLET, // 1
        TV // 2
    }

    public SharedPreferences sharedPrefs;
    private void firstRunCheck() {
        sharedPrefs = getSharedPreferences(context.getPackageName(), Context.MODE_PRIVATE);
        boolean copied = sharedPrefs.getBoolean("FR",false);
        SharedPreferences.Editor editor = null;
        if (!copied) {
//            FirstRunAssetsExtract.copyInstallNamesToRuntimeNames(mainActivityContext);
            editor = sharedPrefs.edit();
            editor.putBoolean("FR",true);
            editor.putBoolean("SOFTKEYS",hasSoftKeys());
            editor.apply();
        }
        String label = "DEVICETYPE";
        int deviceTypeOrdinal_ = sharedPrefs.getInt(label,-1);
        if(deviceTypeOrdinal_ < 0) {
            if(editor == null) editor = sharedPrefs.edit();
            UiModeManager uiModeManager = (UiModeManager) getSystemService(UI_MODE_SERVICE);
            if(uiModeManager.getCurrentModeType() == Configuration.UI_MODE_TYPE_TELEVISION)
                deviceTypeOrdinal_ = 2;
            else deviceTypeOrdinal_ = getDisplayDiagonalSizeInches()>=6.5?1:0;
            editor.putInt(label,deviceTypeOrdinal_);
            editor.apply();
        }
        deviceType = DeviceType.values()[deviceTypeOrdinal_];
        hasPermanentMenuKey = !(sharedPrefs.getBoolean("SOFTKEYS",true));
    }

    // 2 bits: LSB for dang, MSB for sign
    static int permMask = 0; // 0: nothing enabled, 1: dang enabled, 2: sign enabled, 3: both

    void startPermissionManagementActivity() {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            Intent i = new Intent(this, PermissionManagementActivity.class);
            i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
            startActivity(i);
            finish();
        }
        else Toast.makeText(mainActivity, "Runtime permission management does not exist on Android < 6", Toast.LENGTH_SHORT).show();
    }

    boolean hasPermanentMenuKey;

    public double getDisplayDiagonalSizeInches() {
        DisplayMetrics metrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(metrics);

        float yInches = metrics.heightPixels/metrics.ydpi;
        float xInches = metrics.widthPixels/metrics.xdpi;
        return Math.sqrt(xInches*xInches + yInches*yInches);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        boolean isHorizontal = newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE;
        getWindow().getDecorView().setSystemUiVisibility(horizontalVisibility);
        setOperationButtonsLayout();
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        super.onCreate(savedInstanceState);
        activityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
        setContentView(R.layout.activity_main_with_pager);

        refreshAppContext(getApplicationContext());
        mainActivity = this;

        // ensure at least storage permissions are granted, it's useless to proceed otherwise
        if((Build.VERSION.SDK_INT >= Build.VERSION_CODES.R && !Environment.isExternalStorageManager()) ||
                (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M &&
                 Build.VERSION.SDK_INT < Build.VERSION_CODES.R &&
                 checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED)) {
            Toast.makeText(this, "Storage permissions not granted, please enable them",
                    Toast.LENGTH_SHORT).show();
            startPermissionManagementActivity();
            return;
        }

        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
            if(!nm.areNotificationsEnabled()) {
                Toast.makeText(this, "Notification permissions for Android 13+ not granted, please enable them",
                        Toast.LENGTH_SHORT).show();
                startPermissionManagementActivity();
                return;
            }
        }

        xFilesUtils = new XFilesUtils();

        smbProvider = new SmbProvider(context,this);
        sftpProvider = new SFTPProvider(this);


        layoutInflater = LayoutInflater.from(MainActivity.this);

        defaultUIVisibility = getWindow().getDecorView().getSystemUiVisibility();
        getWindow().getDecorView().setSystemUiVisibility(horizontalVisibility);

        firstRunCheck();

        progressCircleForGoDirOps = findViewById(R.id.progressCircleForGoDirOps);
        showNavLayoutBtn = findViewById(R.id.showNavLayoutBtn);
        quickPathsLayout = findViewById(R.id.quickpaths_layout);
        quickPathsListView = findViewById(R.id.quickpaths_listview);
        fileOperationHelperSwitcher = findViewById(R.id.toggleRootHelperButton);

        // conditional inflating
        setOperationButtonsLayout();

        sortButton = findViewById(R.id.sortButton);
        sortButton.setOnClickListener(this::showAdvancedSortingDialogOrMenu);

        credsFavsButton = findViewById(R.id.openCredsFavsMenu);

        chooseBrowserViewButton = findViewById(R.id.chooseBrowserViewButton);

        itemSelectionButton = findViewById(R.id.itemSelectionButton);

        quickFindButton = findViewById(R.id.quickFindButton);

        itemSelectionButton.setOnClickListener(v -> browserPagerAdapter.switchMultiSelectMode(browserPager.getCurrentItem()));

        quickFindButton.setOnClickListener(v -> browserPagerAdapter.switchQuickFindMode(browserPager.getCurrentItem()));

        quickFindButton.setOnLongClickListener(v -> {
            findInFolders(getCurrentDirCommander().getCurrentDirectoryPathname(), true);
            return true;
        });

        makeImageButtonsStateful(findViewById(R.id.pathViewLayout),
                new SelectImageButtonListener(this, R.color.imagebuttonselect));

        registerForContextMenu(sortButton);
        registerForContextMenu(credsFavsButton);
        credsFavsButton.setOnClickListener(this::openContextMenu);
        registerForContextMenu(chooseBrowserViewButton);

//        getRootHelperClient();

        browserPagerAdapter = new BrowserPagerAdapter(this,this);

        browserPager = findViewById(R.id.browserpager);
        browserPager.setAdapter(browserPagerAdapter);

        // XFiles being run by external application for opening file
        browserPagerAdapter.checkUpdateIntent = true;
        // updateFromSelfIntent(getIntent()); // MOVED INTO BrowserPagerAdapter
    }

    // called only on first start, then saved and retrieved from SharedPreferences
    public boolean hasSoftKeys() {
        boolean hasSoftwareKeys;

        Display d = getWindowManager().getDefaultDisplay();

        DisplayMetrics realDisplayMetrics = new DisplayMetrics();
        d.getRealMetrics(realDisplayMetrics);

        int realHeight = realDisplayMetrics.heightPixels;
        int realWidth = realDisplayMetrics.widthPixels;

        DisplayMetrics displayMetrics = new DisplayMetrics();
        d.getMetrics(displayMetrics);

        int displayHeight = displayMetrics.heightPixels;
        int displayWidth = displayMetrics.widthPixels;

        hasSoftwareKeys =  (realWidth - displayWidth) > 0 || (realHeight - displayHeight) > 0;
        return hasSoftwareKeys;
    }

    public void changeBrowserViewMode(View v) {
        browserPagerAdapter.changeBrowserViewMode(browserPager.getCurrentItem());
    }

    public void openCredOrFavsManager(int resId) {
        Class targetActivity;
        switch(resId) {
            case R.id.openSftpCredManager:
                targetActivity = VaultActivity.class;
                break;
            case R.id.openSmbCredManager:
                targetActivity = SmbVaultActivity.class;
                break;
            case R.id.openFavsManager:
                targetActivity = FavoritesActivity.class;
                break;
            default:
                throw new RuntimeException("Guard block");
        }
        startActivity(new Intent(MainActivity.this,targetActivity));
    }

    public void openAboutDialog() {
        Dialog d = new Dialog(this);
        d.requestWindowFeature(Window.FEATURE_NO_TITLE);
        d.getWindow().setBackgroundDrawableResource(android.R.color.transparent);
        d.setContentView(R.layout.about_dialog);
        try {
            PackageInfo pInfo = getPackageManager().getPackageInfo(getPackageName(), 0);
            ((TextView)(d.findViewById(R.id.aboutAppVersionName))).setText(pInfo.versionName);
            ((TextView)(d.findViewById(R.id.aboutAppVersionCode))).setText(""+pInfo.versionCode);
            d.findViewById(R.id.updateCheckButton).setOnClickListener(v -> {
                d.dismiss();
                new UpdateCheckDialog(this).show();
//                startActivity(new Intent(MainActivity.this, com.tomclaw.imageloader.demo.DemoActivity.class));
            });
        }
        catch(PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
        d.show();
    }

    public void showAdvancedSortingDialogOrMenu(View v) {
        wasShortClick = true;
        openContextMenu(v);
        // dialog open moved in onCreateContextMenu
        // new AdvancedSortingDialog(MainActivity.this,getCurrentBrowserAdapter()).show();
    }

    public static GenericChangeDirectoryDialog cdd;
    public void showChangeDirectoryDialog_(String... downloadUrlToPopulate) {
        cdd = new GenericChangeDirectoryDialog(
                MainActivity.this,
                getCurrentDirCommander().getCurrentDirectoryPathname()
        );
        cdd.show();
        if(downloadUrlToPopulate.length > 0) {
            cdd.findViewById(R.id.httpUrlDownload).performClick();
            ((PasteableEditText)cdd.findViewById(R.id.httpUrlEditText)).setText(downloadUrlToPopulate[0]);
        }
    }

    public void showChangeDirectoryDialog(View v) {
        showChangeDirectoryDialog_();
    }

    public void toggleRootHelper(View v) {
        String h = usingRootHelperForLocal ? "standard" : "roothelper-enabled";
        AlertDialog.Builder bld = new AlertDialog.Builder(MainActivity.this);
        bld.setTitle("Switch dir commander to "+h+" one?");
        bld.setIcon(usingRootHelperForLocal?R.drawable.xfiles_root_off:R.drawable.xfiles_root_on);
        bld.setNegativeButton(android.R.string.cancel, null);
        bld.setPositiveButton(android.R.string.ok, (dialog, which) -> {
            // disabled, better user experience, to be tested
            // browserPagerAdapter.createStandardCommanders();
            if (usingRootHelperForLocal) { // switch to normal dircommander
                usingRootHelperForLocal = false;
                fileOperationHelperSwitcher.setImageResource(R.drawable.xfiles_root_off);
            }
            else { // switch to roothelper-based dircommander
                getRootHelperClient();
                usingRootHelperForLocal = true;
                fileOperationHelperSwitcher.setImageResource(R.drawable.xfiles_root_on);
            }
        });
        AlertDialog alertDialog = bld.create();
        alertDialog.show();
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        getWindow().getDecorView().setSystemUiVisibility(horizontalVisibility);
        if(deviceType != DeviceType.PHONE || hasPermanentMenuKey || getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
            return;
        }
        /**
         * Web source:
         * https://stackoverflow.com/questions/54140793/how-to-fix-navigation-bar-icons-still-showing-when-pop-up-menu-is-opened-ful
         * Still ugly as hack (navbar appears and disappears rapidly) but at least it works
         */
        else if(EffectActivity.currentlyOnFocus instanceof MainActivity) {
            // When PopupMenu appears, the current Activity looses the focus;
            // hijack to the current peek view, apply the Flags on it
            try {
                Class wmgClass = Class.forName("android.view.WindowManagerGlobal");
                Object wmgInstance = wmgClass.getMethod("getInstance").invoke(null);
                Field viewsField = wmgClass.getDeclaredField("mViews");
                viewsField.setAccessible(true);

                List<View> views = (List<View>) viewsField.get(wmgInstance);
                views.get(views.size()-1).setSystemUiVisibility(horizontalVisibility);
//                v.setOnSystemUiVisibilityChangeListener(i->{v.setSystemUiVisibility(i);});
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    public static void simulateHomePress(Activity activity) {
        Intent startMain = new Intent(Intent.ACTION_MAIN);
        startMain.addCategory(Intent.CATEGORY_HOME);
        startMain.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        activity.startActivity(startMain);
    }

    public void installApk(File file) {
        if(file.exists()) {
            Intent intent;
            Uri uri = ContentProviderUtils.getUriFromFile(getApplicationContext(), file);
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
                intent = new Intent(Intent.ACTION_INSTALL_PACKAGE);
                intent.setData(uri);
            }
            else {
                intent = new Intent(Intent.ACTION_VIEW);
                intent.setDataAndType(uri, "application/vnd.android.package-archive");
                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            }
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            try {
                startActivity(intent);
            }
            catch(ActivityNotFoundException e) {
                e.printStackTrace();
                Toast.makeText(this, "Error in opening the file as APK for installation", Toast.LENGTH_SHORT).show();
            }
        }
        else {
            Toast.makeText(this, "APK for installation not existing or not accessible", Toast.LENGTH_SHORT).show();
        }
    }

    public void openWithDefaultApp(File file) {
        // get extension
        String extension = "";
        String fullName = file.getName();
        int i = fullName.lastIndexOf('.');
        if (i > 0) extension = fullName.substring(i+1);

        MimeTypeMap myMime = MimeTypeMap.getSingleton();
        Intent intent = new Intent(Intent.ACTION_VIEW);
        String mimeType = myMime.getMimeTypeFromExtension(extension);
        intent.setDataAndType(Uri.fromFile(file),mimeType);
//        intent.setDataAndType(
//                FileProvider.getUriForFile(MainActivity.this,
//                        BuildConfig.APPLICATION_ID + ".provider",
//                        file),
//                mimeType
//        );

        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

        try {
            startActivity(intent);
        } catch (ActivityNotFoundException e) { // if no default app found, show open as menu
            Toast.makeText(this, "No handler for this type of file.", Toast.LENGTH_LONG).show();
            showOpenAsList(file);
        }
    }

    public void showOpenAsList(File file) {
        if (file.isDirectory()) {
            Toast.makeText(this,"File is a directory",Toast.LENGTH_SHORT).show();
            return;
        }
        OpenAsDialog oad = new OpenAsDialog(MainActivity.this,file);
        oad.show();
    }

    public void prepareForCopyOrMove(CopyMoveMode mode) {
        BasePathContent path = getCurrentDirCommander().getCurrentDirectoryPathname();
        copyMoveList = new CopyMoveListPathContent(
                getCurrentBrowserAdapter(),mode,path);
        String zeroWarning = "No items selected for ";
        String success = " items ready to be ";
        String successS = " item ready to be ";
        if (copyMoveList.files.size()==0) {
            Toast.makeText(this,
                    (mode==CopyMoveMode.COPY)?zeroWarning+"copy":zeroWarning+"move",
                    Toast.LENGTH_SHORT).show();
            copyMoveList=null;
            return;
        }
        String prefix = ""+copyMoveList.files.size();
        prefix+=copyMoveList.files.size()==1?successS:success;
        Toast.makeText(this,
                (mode==CopyMoveMode.COPY)?prefix+"copied":prefix+"moved",
                Toast.LENGTH_SHORT).show();
    }

    public void extractItem(BrowserItem b) {
//        new ExtractDialog(this,null,b.filename).show();

        Intent i = new Intent(MainActivity.this, ExtractActivity.class);
        i.putExtra("filename",b.filename);
        startActivity(i);
    }

    public void extractItems() {
        // extract dialog will take selected items directly from browser adapter
//        new ExtractDialog(this,null,null).show();
        Intent i = new Intent(MainActivity.this, ExtractActivity.class);
        startActivity(i);
    }

    public void testItems(ProviderType providerType) {
        Intent startIntent = new Intent(this, TestService.class);
        startIntent.setAction(BaseBackgroundService.START_ACTION);
        startIntent.putExtra("params",
                providerType == ProviderType.LOCAL_WITHIN_ARCHIVE ?
                        new TestParams(Collections.singletonList(getCurrentDirCommander().getCurrentDirectoryPathname()),
                                null,getCurrentBrowserAdapter().getSelectedItemsAsNameOnlyStrings()) :
                        new TestParams(getCurrentBrowserAdapter().getSelectedItemsAsPathContents(), null, null));
        startService(startIntent);
    }

    public void shareItems(boolean unattended) {
        List<BasePathContent> selection = getCurrentBrowserAdapter().getSelectedItemsAsPathContents();
        if (selection.size()==0) {
            Toast.makeText(this,"No items selected for sharing",Toast.LENGTH_SHORT).show();
            return;
        }
        Intent sharingIntent = unattended?
                new Intent(this,XREDirectShareActivity.class):new Intent();
        sharingIntent.setAction(Intent.ACTION_SEND_MULTIPLE);

        sharingIntent.setType("*/*");
        ArrayList<Uri> uris = new ArrayList<>();
        for (BasePathContent f : selection) {
            if (f.providerType != ProviderType.LOCAL) {
                Toast.makeText(this,"Sharing not implemented for non-local or within-archive files",Toast.LENGTH_LONG).show();
                return;
            }
            // commented in order to allow also directories sharing with XRE or XFiles compress
//            if (new File(f.dir).isDirectory()) {
//                Toast.makeText(this,"Only files can be shared, not directories",Toast.LENGTH_SHORT).show();
//                return;
//            }
            uris.add(Uri.fromFile(new File(f.dir)));
//            uris.add(FileProvider.getUriForFile(MainActivity.this,
//                    BuildConfig.APPLICATION_ID + ".provider",
//                    new File(f.dir)));
        }
        sharingIntent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, uris);
        sharingIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
        sharingIntent.putExtra("unattended",unattended);
        startActivity(unattended?sharingIntent:Intent.createChooser(sharingIntent, "Share files using"));
    }

    // with singleSelection = true, basePath is the only folder in which to perform search
    // otherwise, basePath is the parent dir, and we have to retrieve current selection (and concat the folder names to basePath)
    public void findInFolders(BasePathContent basePath, boolean singleSelection) {
        ArrayList<BasePathContent> localFolders = new ArrayList<>();
        if(singleSelection) {
            switch(basePath.providerType) {
                case LOCAL:
                case LOCAL_WITHIN_ARCHIVE:
                    localFolders.add(basePath);
                    break;
                default:
                    localFolders.add(new LocalPathContent(Misc.internalStorageDir.getPath()));
                    break;
            }
        }
        else {
            List<BrowserItem> selection = getCurrentBrowserAdapter().getSelectedItems();
            if(selection.size() == 0) {
                Toast.makeText(this, "No selected folders to search in", Toast.LENGTH_SHORT).show();
                return;
            }
            for(BrowserItem item: selection) {
                if(!(item.isDirectory)) {
                    Toast.makeText(this, "Selection to search in contains files", Toast.LENGTH_SHORT).show();
                    return;
                }
                localFolders.add(basePath.concat(item.filename));
            }
        }
        Intent intent = new Intent(MainActivity.this, FindActivity.class);
        intent.putExtra("paths", localFolders);
        startActivity(intent);
    }

    public void paste(BasePathContent bpc) {
        final BasePathContent destPath = bpc==null?getCurrentDirCommander().getCurrentDirectoryPathname():bpc;

        if (copyMoveList==null || copyMoveList.files.size()==0) {
            Toast.makeText(this,"No items to be pasted",Toast.LENGTH_SHORT).show();
            return;
        }

        // useless with conflict handling enabled
//        if (copyMoveList.parentDir.equals(destPath)) {
//            Toast.makeText(this,"Source and destination are the same!",Toast.LENGTH_SHORT).show();
//            return;
//        }

        // if destPath is a sub-folder of some item in the copy/move selection, cancel file transfer
        for (BrowserItem fn : copyMoveList.files) {
            if (copyMoveList.parentDir.concat(fn.filename).isParentOrSameOf(destPath)) {
                Toast.makeText(this, "Cannot copy or move a directory into one of its descendants", Toast.LENGTH_SHORT).show();
                return;
            }
        }

        // 4 cases local x remote, origin x destination

        // local to local file transfer
        if (copyMoveList.parentDir.providerType == ProviderType.LOCAL &&
                destPath.providerType == ProviderType.LOCAL) {

            //*/*/*/*/*/*/*/*/ 1 - with service and task
            Intent startIntent = new Intent(MainActivity.this,CopyMoveService.class);
            startIntent.setAction(BaseBackgroundService.START_ACTION);
            startIntent.putExtra("params",new CopyMoveParams(copyMoveList,destPath));
            startService(startIntent);
            //*/*/*/*/*/*/*/*/

            //*/*/*/*/*/*/*/*/ 2 - with IndeterminateAsyncTask
//            IndeterminateAsyncTask t = new IndeterminateAsyncTask(
//                    MainActivity.this,
//                    copyMoveList.copyOrMove==CopyMoveMode.COPY?"Copying...":"Moving...",
//                    copyMoveList.copyOrMove.name().toLowerCase()+" completed",
//                    copyMoveList.copyOrMove.name().toLowerCase()+" error")
//            {
//                @Override
//                protected Integer doInBackground(Void... params) {
//                    try {
////                        for(int k=5;k>=0;k--) {
////                            Thread.sleep(1000);
////                            Log.d("COPYTASK","sleeping... "+k);
////                        }
//                        currentHelper.copyMoveFilesToDirectory(copyMoveList, destPath);
//                        return 0;
//                    }
//                    catch (Exception e) {
//                        e.printStackTrace();
//                        return -1;
//                    }
//                }
//
//                @Override
//                protected void onPostExecute(Integer integer) {
//                    super.onPostExecute(integer);
//                    copyMoveList = null;
//                    showDirContent(getCurrentDirCommander().refresh());
//                }
//            };
//            t.execute((Void[])null);
            //*/*/*/*/*/*/*/*/

            //*/*/*/*/*/*/*/*/ 3 - plain, on UI thread, without dialogs or progress indication
//            try {
//                currentHelper.copyMoveFilesToDirectory(copyMoveList, destPath);
//            } catch (IOException e) {
//                Toast.makeText(this,"File transfer error",Toast.LENGTH_LONG).show();
//            }
            //*/*/*/*/*/*/*/*/
        }

        // SFTP upload or download
        else if ((copyMoveList.parentDir.providerType == ProviderType.LOCAL &&
                destPath.providerType == ProviderType.SFTP) ||
                ((copyMoveList.parentDir.providerType == ProviderType.SFTP &&
                        destPath.providerType == ProviderType.LOCAL))) {
            //*/*/*/*/*/*/*/*/ 1 - with service and task
            Intent startIntent = new Intent(MainActivity.this,NonInteractiveSftpService.class);
            startIntent.setAction(BaseBackgroundService.START_ACTION);
            startIntent.putExtra("params",new CopyMoveParams(copyMoveList,destPath));
            startService(startIntent);
            //*/*/*/*/*/*/*/*/
        }
        // SFTP to SFTP file transfer
        else if (copyMoveList.parentDir.providerType == ProviderType.SFTP &&
                destPath.providerType == ProviderType.SFTP) {
            // remote transfer on the same remote host
            if (((SFTPPathContent)copyMoveList.parentDir).authData.equals(((SFTPPathContent)destPath).authData)) {
                // move (rename) on the remote host
                if (copyMoveList.copyOrMove == CopyMoveMode.MOVE) {
                    try {
                        sftpProvider.copyMoveFilesToDirectory(copyMoveList,destPath);
                        copyMoveList = null;
                        browserPagerAdapter.showDirContent(getCurrentDirCommander().refresh(),browserPager.getCurrentItem(),null);
                        Toast.makeText(this,"Remote-to-remote move completed",Toast.LENGTH_SHORT).show();
                    }
                    catch (IOException e) {
                        Toast.makeText(this,"Remote-to-remote error: "+e.getMessage(),Toast.LENGTH_LONG).show();
                    }
                }
                else {
                    Toast.makeText(this,"Only remote to remote move on same host supported",Toast.LENGTH_SHORT).show();
                }
            }
            else {
                Toast.makeText(this,"Unpractical to be implemented",Toast.LENGTH_SHORT).show();
                // not implementable without downloading to device & uploading from it (unpractical), or
                // without already key-exchanged remote end-points
            }
        }
        // XFiles remote transfer
        else if ((copyMoveList.parentDir.providerType == ProviderType.XFILES_REMOTE &&
                        destPath.providerType == ProviderType.LOCAL) ||
                (copyMoveList.parentDir.providerType == ProviderType.LOCAL &&
                        destPath.providerType == ProviderType.XFILES_REMOTE)) {
            Intent startIntent = new Intent(MainActivity.this,NonInteractiveXFilesRemoteTransferService.class);
            startIntent.setAction(BaseBackgroundService.START_ACTION);
            startIntent.putExtra("params",new CopyMoveParams(copyMoveList,destPath));
            startService(startIntent);
        }
        // SMB upload or download
        else if ((copyMoveList.parentDir.providerType == ProviderType.LOCAL &&
                destPath.providerType == ProviderType.SMB) ||
                ((copyMoveList.parentDir.providerType == ProviderType.SMB &&
                        destPath.providerType == ProviderType.LOCAL))) {
            //*/*/*/*/*/*/*/*/ 1 - with service and task
            Intent startIntent = new Intent(MainActivity.this, NonInteractiveSmbService.class);
            startIntent.setAction(BaseBackgroundService.START_ACTION);
            startIntent.putExtra("params",new CopyMoveParams(copyMoveList,destPath));
            startService(startIntent);
            //*/*/*/*/*/*/*/*/
        }
        else if (copyMoveList.parentDir.providerType == ProviderType.LOCAL_WITHIN_ARCHIVE &&
                destPath.providerType == ProviderType.LOCAL) {
            if(copyMoveList.copyOrMove==CopyMoveMode.MOVE)
                Toast.makeText(MainActivity.this,
                        "Warning: extracting files from archive in response to cut/paste command", Toast.LENGTH_SHORT).show();
            Intent startIntent = new Intent(MainActivity.this, ExtractService.class);
            startIntent.setAction(BaseBackgroundService.START_ACTION);
            startIntent.putExtra(
                    "params",
                    new ExtractParams(
                            Collections.singletonList(copyMoveList.parentDir),
                            destPath,
                            null,
                            copyMoveList.asNameOnlyStrings(),
                            false
                    ));
            startService(startIntent);
        }
        else {
            Toast.makeText(mainActivity, "Unknown data provider pair", Toast.LENGTH_LONG).show();
        }

        // With asynctask used in copy/move, the following commented lines are enabled in the onPostExecute method of the IndeterminateAsyncTask
//        Toast.makeText(this,(copyMoveList.copyOrMove==CopyMoveMode.COPY?"copy":"move")+" completed",Toast.LENGTH_SHORT).show();
//        copyMoveList = null;
//
//        showDirContent(getCurrentDirCommander().refresh());

    }

    void deleteSelection() {
        List<BasePathContent> selection = getCurrentBrowserAdapter().getSelectedItemsAsPathContents();
        if (selection.size()==0) {
            Toast.makeText(this,"No items selected for deletion",Toast.LENGTH_SHORT).show();
            return;
        }
        showDeleteDialog(selection);
    }

    void renameSelection() {
        List<BrowserItem> selection = getCurrentBrowserAdapter().getSelectedItems();
        if (selection.size()==0) {
            Toast.makeText(this,"No items selected for rename",Toast.LENGTH_SHORT).show();
            return;
        }
        ArrayList<String> a = new ArrayList<>();
        for(BrowserItem item: selection)
            a.add(item.filename);
        BulkRenameDialog.createAndShow(this, getCurrentDirCommander().getCurrentDirectoryPathname(),a);
    }

    void compressSelection() {
        if (getCurrentBrowserAdapter().getSelectedCount() == 0) {
            Toast.makeText(this,"No items selected for compression",Toast.LENGTH_SHORT).show();
            return;
        }
        // with CompressActivity
        startActivity(new Intent(MainActivity.this,CompressActivity.class));
    }

    void checksumSelection() {
        if (getCurrentBrowserAdapter().getSelectedCount() == 0) {
            Toast.makeText(this,"No items selected for checksum",Toast.LENGTH_SHORT).show();
            return;
        }
        startActivity(new Intent(MainActivity.this,ChecksumActivity.class));
    }

    // false when starting, true after end
    public void toggleGoDirOpsIndeterminateProgress(boolean status) {
        progressCircleForGoDirOps.setVisibility(status?View.GONE:View.VISIBLE);
        showNavLayoutBtn.setVisibility(status?View.VISIBLE:View.GONE);
    }

    void upOneLevel() {
        BasePathContent parentFile = getCurrentDirCommander().getCurrentDirectoryPathname().getParent();
        if (parentFile == null) {
            Toast.makeText(this,"Already on root path for the current filesystem",Toast.LENGTH_SHORT).show();
            return;
        }
        goDir_async(parentFile,null);
    }

    public void goDirOrArchive(LocalPathContent path) {
        final int targetViewPagerPosition = browserPager.getCurrentItem();
        BasePathContent path_ = (getRootHelperClient().isDir(path))? path: new ArchivePathContent(path.dir,"");
        GenericDirWithContent gdwc = goDir_inner(path_);
        completeGoDir(gdwc,path_,targetViewPagerPosition,null);
    }

    /**
     * @param targetFilenameToHighlight Target filename to be highlighted and centered in the listview (in case of Locate command from {@link FindActivity})
     */
    public FileOpsErrorCodes goDir(Object dirOrOffset, int targetViewPagerPosition, @Nullable String targetFilenameToHighlight, Runnable... onCompletion) {
        GenericDirWithContent gdwc = goDir_inner(dirOrOffset);
        completeGoDir(gdwc,dirOrOffset,targetViewPagerPosition,targetFilenameToHighlight,onCompletion);
        return gdwc.errorCode;
    }

    public void goDir_async(Object dirOrOffset, @Nullable String targetFilenameToHighlight) {
        Future<FileOpsErrorCodes> ff = browserPagerAdapter.goDirExecutors[browserPager.getCurrentItem()].submit(() -> goDir(
                dirOrOffset,
                browserPager.getCurrentItem(),
                targetFilenameToHighlight,
                () -> toggleGoDirOpsIndeterminateProgress(true)));
        if(ff == null) return;
        handler.postDelayed(() -> {
            if (!ff.isDone())
                toggleGoDirOpsIndeterminateProgress(false);
        },250);
    }

    /**
     * @param dirOrOffset Target path to be loaded, or direction as boolean (back or ahead)
     */
    public GenericDirWithContent goDir_inner(Object dirOrOffset) {
        GenericDirWithContent dwc;
        int prevPos = getCurrentMainBrowserView().getFirstVisiblePosition();
        if (dirOrOffset instanceof Integer) {
            int offset = (Integer)dirOrOffset;
            dwc = getCurrentDirCommander().shiftNPlaces(offset, prevPos);
        }
        else if (dirOrOffset instanceof BasePathContent) {
            dwc = getCurrentDirCommander().setDir((BasePathContent) dirOrOffset, prevPos);
        }
        else return new GenericDirWithContent(FileOpsErrorCodes.ILLEGAL_ARGUMENT);

        return dwc;
    }

    // this part can be submitted to UI
    public void completeGoDir(GenericDirWithContent dwc, Object dirOrOffset, int position, @Nullable String targetFilenameToHighlight, Runnable... onCompletion) {
        runOnUiThread(()->{
            if(dwc.errorCode != null && dwc.errorCode != FileOpsErrorCodes.OK) {
                switch(dwc.errorCode) {
                    case ILLEGAL_ARGUMENT:
                        showToast("Invalid object type for dir browsing");
                        break;
                    case NULL_OR_WRONG_PASSWORD:
                        new AskPasswordDialogOnListing(
                                MainActivity.this,
                                (BasePathContent) dirOrOffset // tested, no classCastException on go back/ahead into an archive
                        ).show();
                        break;
                    case HOST_KEY_INEXISTENT_ERROR:
                        new SSHNotInKnownHostsDialog(
                                MainActivity.this,
                                ((SftpDirWithContent)dwc).authData,
                                InteractiveHostKeyVerifier.currentHostKey,
                                MainActivity.sftpProvider,
                                new SFTPPathContent(
                                        ((SftpDirWithContent)dwc).authData,
                                        ((SftpDirWithContent)dwc).pendingLsPath)).show();
                        break;
                    case HOST_KEY_CHANGED_ERROR:
                        new SSHAlreadyInKnownHostsDialog(
                                MainActivity.this,
                                ((SftpDirWithContent)dwc).authData,
                                InteractiveHostKeyVerifier.oldHostEntry,
                                InteractiveHostKeyVerifier.currentHostKey,
                                MainActivity.sftpProvider,
                                new SFTPPathContent(
                                        ((SftpDirWithContent)dwc).authData,
                                        ((SftpDirWithContent)dwc).pendingLsPath)).show();
                        break;
                    default:
                        Toast.makeText(MainActivity.this, dwc.errorCode.getValue(), Toast.LENGTH_SHORT).show();
                        break;
                }
            }
            else browserPagerAdapter.showDirContent(dwc,position,targetFilenameToHighlight);

            if(onCompletion.length > 0) onCompletion[0].run();
        });
    }

    public void showPopup(AdapterView<?> parent, View v, int position1, View rootAnchorFor2ndLevel) {
        Context wrapper = new ContextThemeWrapper(this, R.style.popupMenuStyle);
        PopupMenu mypopupmenu = new PopupMenu(wrapper, rootAnchorFor2ndLevel != null ? rootAnchorFor2ndLevel : v);
        setForceShowIcon(mypopupmenu);

        MenuInflater inflater = mypopupmenu.getMenuInflater();
        Menu menu = mypopupmenu.getMenu();

        BrowserAdapter ba = getCurrentBrowserAdapter();
        int mainId = v.getId();
        if(mainId == R.id.newFileButton) inflater.inflate(R.menu.menu_new, menu);
        else {
            BrowserItem bi = ba.getItem(position1);
            if(mainId == R.id.itemShare2ndLevel) {
                inflater.inflate(R.menu.menu_2ndlevel_share, menu);
                if(bi.isDirectory) menu.removeItem(R.id.itemHttpUpload);
            }
            else if(mainId == R.id.itemShareFolder2ndLevel) inflater.inflate(R.menu.menu_2ndlevel_share_local_folder, menu);
            else if(ba.getSelectedCount() == 0) { // long-click on single file, without active selection
                switch(getCurrentDirCommander().getCurrentDirectoryPathname().providerType) {
                    case LOCAL:
                        inflater.inflate(R.menu.menu_single, menu);
                        if(bi.isDirectory) {
                            menu.removeItem(R.id.itemTest);
                            inflater.inflate(R.menu.menu_single_local_folder, menu);
                        }
                        break;
                    case LOCAL_WITHIN_ARCHIVE:
                        // allowed operations: extract, properties (click only if folder, extract on click)
                        inflater.inflate(R.menu.menu_single_within_archive, menu);
                        break;
                    case SFTP:
                    case XFILES_REMOTE:
                    case SMB:
                        // allowed operations: copy, move, delete, rename, properties
                        inflater.inflate(R.menu.menu_single_remote, menu);
                        if(bi.isDirectory) inflater.inflate(R.menu.menu_single_remote_folder,menu);
                        break;
                }
            }
            else {
                switch(getCurrentDirCommander().getCurrentDirectoryPathname().providerType) {
                    case LOCAL:
                        inflater.inflate(R.menu.menu_multi, menu);
                        break;
                    case LOCAL_WITHIN_ARCHIVE:
                        inflater.inflate(R.menu.menu_multi_within_archive, menu);
                        break;
                    case SFTP:
                    case XFILES_REMOTE:
                    case SMB:
                        inflater.inflate(R.menu.menu_multi_remote, menu);
                        break;
                }
            }
        }

////        getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
////                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE);
////
////        getWindow().getDecorView().setSystemUiVisibility(horizontalVisibility);

        mypopupmenu.show();

////        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE);
////
////        //Update the WindowManager with the new attributes (no nicer way I know of to do this)..
////        WindowManager wm = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
////        wm.updateViewLayout(getWindow().getDecorView(), getWindow().getAttributes());

//        mypopupmenu.getMenu().getItem(0).setIcon(getResources().getDrawable(R.mipmap.ic_launcher));
        mypopupmenu.setOnMenuItemClickListener(item -> {
            BrowserItem b;
            File currentFile;
            List<BasePathContent> selection;
            BasePathContent path = getCurrentDirCommander().getCurrentDirectoryPathname();
            int itemId = item.getItemId();
            switch (itemId) {
                // multi-selection menu
                case R.id.itemsCopy:
                    prepareForCopyOrMove(CopyMoveMode.COPY);
                    return true;
                case R.id.itemsMove:
                    prepareForCopyOrMove(CopyMoveMode.MOVE);
                    return true;
                case R.id.itemsChecksum:
                    checksumSelection();
                    return true;
                case R.id.itemsCompress:
                    compressSelection();
                    return true;
                case R.id.itemsExtract:
                case R.id.itemsTest:
                    if (path.providerType != ProviderType.LOCAL_WITHIN_ARCHIVE && path.providerType != ProviderType.LOCAL) {
                        Toast.makeText(MainActivity.this,"Cannot extract/test multiple items if they are on remote filesystems",Toast.LENGTH_SHORT).show();
                        return true;
                    }
                    if(itemId == R.id.itemsExtract) extractItems();
                    else testItems(path.providerType);
                    return true;
                case R.id.itemsDelete:
                    deleteSelection();
                    return true;
                case R.id.itemsRename:
                    renameSelection();
                    return true;
                case R.id.itemsFind:
                    findInFolders(path, false);
                    return true;
                case R.id.itemsShare:
                    shareItems(false);
                    return true;
                case R.id.itemsXreShareUnattended:
                    shareItems(true);
                    return true;
                case R.id.itemsShowInGallery:
                    // TODO consider also the case when image viewer is invoked by third party app - use MainActivity.mainActivity
                    BasePathContent currentDir = getCurrentDirCommander().getCurrentDirectoryPathname();
                    ArrayList<String> imageList = MediaGalleryActivity.filterByImageExtensionsOnSelection(currentDir,ba.getSelectedItems());
                    MediaGallery.Builder(MainActivity.this,imageList)
                            .title("Media Gallery")
                            .backgroundColor(R.color.white)
                            .placeHolder(R.drawable.media_gallery_placeholder)
                            .selectedImagePosition(MediaGalleryActivity.targetIdx)
                            .show();
                    return true;
                case R.id.itemsProperties:
                    getStats();
                    return true;

                // single-selection menu
                case R.id.itemOpenAs:
                    b = ba.getItem(position1);
                    if (path.providerType != ProviderType.LOCAL) {
                        Toast.makeText(MainActivity.this,"Open not implemented for non-local or within-archive paths",Toast.LENGTH_LONG).show();
                        return true;
                    }

                    currentFile = new File(path.dir, b.filename);
                    showOpenAsList(currentFile);
                    return true;
                case R.id.itemCopy:
                    b = ba.getItem(position1);
                    copyMoveList = new CopyMoveListPathContent(b, CopyMoveMode.COPY, path);
                    Toast.makeText(MainActivity.this, "Copy item " + b.filename, Toast.LENGTH_LONG).show();
                    return true;
                case R.id.itemMove:
                    b = ba.getItem(position1);
                    copyMoveList = new CopyMoveListPathContent(b, CopyMoveMode.MOVE, path);
                    Toast.makeText(MainActivity.this, "Move item " + b.filename, Toast.LENGTH_LONG).show();
                    return true;
                case R.id.itemPasteIntoFolder:
                    b = ba.getItem(position1);
                    paste(path.concat(b.filename));
                    return true;
                case R.id.itemFind:
                    b = ba.getItem(position1);
                    findInFolders(path.concat(b.filename), true);
                    return true;
                case R.id.itemCreateLink:
                    b = ba.getItem(position1);
                    new CreateLinkDialog(MainActivity.this, path.concat(b.filename), b.isDirectory?FileMode.DIRECTORY:FileMode.FILE).show();
                    return true;
                case R.id.itemCompress:
                    b = ba.getItem(position1);
                    Intent i = new Intent(MainActivity.this,CompressActivity.class);
                    i.putExtra("filename", b);
                    startActivity(i);
                    return true;
                case R.id.itemExtract:
                case R.id.itemTest:
                    b = ba.getItem(position1);
                    if(b.isDirectory && path.providerType != ProviderType.LOCAL_WITHIN_ARCHIVE) {
                        Toast.makeText(MainActivity.this, "Cannot extract/test files from a directory, please select a compressed archive", Toast.LENGTH_LONG).show();
                        return true;
                    }
                    if(itemId == R.id.itemTest) {
                        Intent startIntent = new Intent(this, TestService.class);
                        startIntent.setAction(BaseBackgroundService.START_ACTION);
                        startIntent.putExtra(
                                "params",
                                new TestParams(Collections.singletonList(path.concat(b.filename)),null,null));
                        startService(startIntent);
                    }
                    else extractItem(b);
                    return true;
                case R.id.itemDelete:
                    b = ba.getItem(position1);
                    selection = Collections.singletonList(path.concat(b.filename));
                    showDeleteDialog(selection);
                    return true;
                case R.id.itemRename:
                    b = ba.getItem(position1);
                    AbsListView lv = getCurrentMainBrowserView();
                    if(lv instanceof ListView)
                        RenameDialog.toggleFastRename(this, position1,
                            path.concat(b.filename),true);
                    else
                        new RenameDialog(MainActivity.this, path.concat(b.filename)).show();
                    return true;
                case R.id.itemChecksum:
                    if (path.providerType != ProviderType.LOCAL &&
                            path.providerType != ProviderType.XFILES_REMOTE) {
                        Toast.makeText(MainActivity.this,"Checksum implemented only for local and XFiles remote files",Toast.LENGTH_LONG).show();
                        return true;
                    }
                    Intent intent = new Intent(MainActivity.this, ChecksumActivity.class);
                    intent.putExtra("browseritem", ba.getItem(position1));

                    startActivity(intent);
                    return true;
                case R.id.itemShare:
                case R.id.itemXreShareUnattended:
                    boolean unattended = itemId == R.id.itemXreShareUnattended;
                    b = ba.getItem(position1);
                    Intent sharingIntent = unattended?new Intent(this,XREDirectShareActivity.class):new Intent();
                    sharingIntent.setAction(Intent.ACTION_SEND);
                    Uri sharingUri = Uri.fromFile(new File(path.dir, b.filename));
//                Uri sharingUri = FileProvider.getUriForFile(MainActivity.this,
//                        BuildConfig.APPLICATION_ID + ".provider",
//                        new File(path.dir, b.filename));
                    sharingIntent.setType("*/*");
                    sharingIntent.putExtra(Intent.EXTRA_STREAM, sharingUri);
                    sharingIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
                    sharingIntent.putExtra("unattended",unattended);
                    startActivity(unattended?sharingIntent:Intent.createChooser(sharingIntent, "Share file using"));
                    return true;
                case R.id.itemShare2ndLevel:
                case R.id.itemShareFolder2ndLevel:
                    showPopup(null, item.getActionView(), position1, v);
                    return true;
                case R.id.itemHttpUpload:
                    b = ba.getItem(position1);
                    if(b.isDirectory) {
                        Toast.makeText(MainActivity.this, "Selected file is a directory", Toast.LENGTH_SHORT).show();
                        return true;
                    }
                    String srcPath = (path.concat(b.filename)).dir;
                    // build alert dialog, three options: x0.at, 0x0.st, dismiss
                    AlertDialog.Builder bld = new AlertDialog.Builder(MainActivity.this);
                    bld.setMessage("You are about to upload this file:\n"+b.filename+"\nto a public internet service");
                    DialogInterface.OnClickListener l = (d,w) -> {
                        String domain = null;
                        switch(w) {
                            case Dialog.BUTTON_NEGATIVE:
                                domain = "0x0.st";
                                break;
                            case Dialog.BUTTON_NEUTRAL:
                                domain = "file.io";
                                break;
                            case DialogInterface.BUTTON_POSITIVE:
                                domain = "x0.at";
                                break;
                        }
                        Intent uploadIntent = new Intent(MainActivity.this, HTTPUploadService.class);
                        uploadIntent.setAction(BaseBackgroundService.START_ACTION);
                        uploadIntent.putExtra("params",new DownloadParams(domain, srcPath, null, true));
                        startService(uploadIntent);
                    };
                    String up = "Upload to ";
                    bld.setNegativeButton(up+"0x0.st", l);
                    bld.setNeutralButton(up+"file.io", l);
                    bld.setPositiveButton(up+"x0.at", l);
                    bld.create().show();
                    return true;
                case R.id.itemShowInGallery:
                    // TODO consider also the case when image viewer is invoked by third party app - use MainActivity.mainActivity
                    currentDir = getCurrentDirCommander().getCurrentDirectoryPathname();
                    if(!(currentDir instanceof LocalPathContent)) {
                        Toast.makeText(MainActivity.this, "Cannot preview images in a non-local directory", Toast.LENGTH_SHORT).show();
                        return true;
                    }

                    b = ba.getItem(position1);
                    if(b.filename.length()>=4 &&
                            MediaGalleryActivity.allowedImageExtensions.contains(b.filename.substring(b.filename.length()-4).toLowerCase())) {
                        imageList = MediaGalleryActivity.filterByImageExtensionsAndSaveTargetIdx(currentDir,b.filename);
                        MediaGallery.Builder(MainActivity.this,imageList)
                                .title("Media Gallery")
                                .backgroundColor(R.color.white)
                                .placeHolder(R.drawable.media_gallery_placeholder)
                                .selectedImagePosition(Math.max(MediaGalleryActivity.targetIdx, 0))
                                .show();
                    }
                    else Toast.makeText(MainActivity.this, "This file doesn't seem to be an image", Toast.LENGTH_SHORT).show();
                    return true;
                case R.id.itemShareOverHTTP:
                case R.id.itemShareOverFTP:
                case R.id.itemShareOverXRE:
                    b = ba.getItem(position1);
                    path = path.concat(b.filename);
                    new RemoteRHServerManagementDialog(MainActivity.this);

                    if(itemId==R.id.itemShareOverXRE) {
                        ((EditText)RemoteRHServerManagementDialog.instance.findViewById(R.id.xreHomePath)).setText(path.dir);
                        RemoteRHServerManagementDialog.instance.show();
                        if(RemoteServerManager.rhssManagerRef.get() != null) {
                            Toast.makeText(MainActivity.this, "XRE server is already active, please stop it before sharing a new directory", Toast.LENGTH_LONG).show();
                            return true;
                        }
                        RemoteRHServerManagementDialog.instance.findViewById(R.id.rhss_toggle_rhss_button).performClick();
                    }
                    else {
                        ((EditText)RemoteRHServerManagementDialog.instance.findViewById(R.id.ftpHttpRootPath)).setText(path.dir);
                        RemoteRHServerManagementDialog.instance.show();
                        // autostart HTTP/FTP server
                        FileServer fileServer = FileServer.fromMenuRes(itemId);
                        if(fileServer.server.isAlive()) {
                            Toast.makeText(MainActivity.this, fileServer.name()+" server is already running, please stop it before sharing a new directory", Toast.LENGTH_LONG).show();
                            return true;
                        }
                        RemoteRHServerManagementDialog.instance.findViewById(fileServer.buttonId).performClick();
                    }
                    return true;
                case R.id.itemProperties:
                    b = ba.getItem(position1);
                    getStats(b);
                    return true;
                case R.id.createNewFile:
                case R.id.createNewFileAdvanced:
                case R.id.createNewDirectory:
                    FileMode fileMode = itemId == R.id.createNewDirectory ? FileMode.DIRECTORY : FileMode.FILE;
                    if(browserPagerAdapter.browserViewModes[browserPager.getCurrentItem()]==BrowserViewMode.GRID ||
                            itemId == R.id.createNewFileAdvanced)
                        new CreateFileOrDirectoryDialog(MainActivity.this,fileMode,itemId == R.id.createNewFileAdvanced,"").show();
                    else
                        CreateFileOrDirectoryDialog.toggleFastCreateMode(MainActivity.this, fileMode, true);
                    return true;
                default:
                    return true;
            }
        });
    }

    private void setForceShowIcon(PopupMenu popupMenu) {
        try {
            Field[] mFields = popupMenu.getClass().getDeclaredFields();
            for (Field field : mFields) {
                if ("mPopup".equals(field.getName())) {
                    field.setAccessible(true);
                    Object menuPopupHelper = field.get(popupMenu);
                    Class<?> popupHelper = Class.forName(menuPopupHelper.getClass().getName());
                    Method mMethods = popupHelper.getMethod("setForceShowIcon", boolean.class);
                    mMethods.invoke(menuPopupHelper, true);
                    break;
                }
            }
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        /*
         * ensure the are no other active long term tasks; if so,
         * the main roothelper server instance could be needed
         * to cancel those tasks (via kill signal from one RH to the other)
         */

        // kill RH server only if there aren't foreground services using it, and if XRE remote server is not active

        // if busy, terminate all the rest, if not, terminate everything
        synchronized (ProgressIndicator.busy) {
            ForegroundServiceType f = ProgressIndicator.busy.get();
            if (f == null) {
                // close all
                if (sftpProvider != null) sftpProvider.closeAllSessions();
                if (smbProvider != null) smbProvider.closeAllSessions();
                rootHelperRemoteClientManager.closeAllSessions();
                if (RemoteServerManager.rhssManagerRef.get() == null)
                    killRHWrapper();
            }
            else {
                // TODO apply a better construct for set exclusion
                switch (f) {
                    case FILE_TRANSFER:
                    case FILE_ARCHIVING:
                    case XRE_TRANSFER:
                    case URL_DOWNLOAD:
                        if (sftpProvider != null) sftpProvider.closeAllSessions();
                        if (smbProvider != null) smbProvider.closeAllSessions();
                        break;
                    case SFTP_TRANSFER:
                        if (smbProvider != null) smbProvider.closeAllSessions();
                        rootHelperRemoteClientManager.closeAllSessions(); // FIXME this shouldn't be done anymore since the use of RobustLocal file streams, to be checked
                        if (RemoteServerManager.rhssManagerRef.get() == null)
                            killRHWrapper();
                        break;
                    case SMB_TRANSFER:
                        if (sftpProvider != null) sftpProvider.closeAllSessions();
                        break;
                }
            }
        }

        usingRootHelperForLocal = false;
//        context = null; // FIXME may cause NPE? better to leave it non-null and check null-check usages
        mainActivity = null;
    }

    boolean doubleBackToExitPressedOnce = false;

    private void guiBackButton() {
        // TODO maybe should handle mode exit differently (not both at once)
        // TODO decide if it is needed to restore original adapter content on quick find mode exit
        int pos = browserPager.getCurrentItem();

        if(quickPathsLayout.getVisibility() == View.VISIBLE) {
            quickPathsLayout.setVisibility(View.GONE);
            return;
        }

        if(browserPagerAdapter.fastRenameModeViews[pos] != null) {
            RenameDialog.resetRenameMode(pos,browserPagerAdapter.fastRenameModeViews);
            return;
        }

        if(browserPagerAdapter.browserAdapters[pos].fastCreateModeHeaderView != null) {
            CreateFileOrDirectoryDialog.resetCreateMode(
                    browserPagerAdapter.browserAdapters[pos],
                    browserPagerAdapter.mainBrowserViews[pos]);
            return;
        }

        if (browserPagerAdapter.multiSelectModes[pos] ||
                browserPagerAdapter.quickFindModes[pos])
        {
            if (browserPagerAdapter.multiSelectModes[pos]) browserPagerAdapter.switchMultiSelectMode(pos);
            if (browserPagerAdapter.quickFindModes[pos]) browserPagerAdapter.switchQuickFindMode(pos);
            return;
        }

        if (doubleBackToExitPressedOnce) {

            // check if there is any remote server active and, in case, show dialog
            if((RemoteServerManager.rhssManagerRef.get() != null) ||
                    FileServer.FTP.server.isAlive() ||
                    FileServer.HTTP.server.isAlive()) {
                new CloseActiveServersDialog(this).show();
            }
            else {
                super.onBackPressed();
            }
            return;
        }

        this.doubleBackToExitPressedOnce = true;
        Toast.makeText(this, "Please click BACK again to exit", Toast.LENGTH_SHORT).show();

        handler.postDelayed(() -> doubleBackToExitPressedOnce=false, 2000);
    }

    @Override
    public void onBackPressed() {
        if(deviceType == DeviceType.TV) {
            if(getCurrentDirCommander().currentIndex > 0) {
                goDir_async(-1, null);
                return;
            }
        }
        guiBackButton();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if(keyCode == KeyEvent.KEYCODE_MENU) {
            credsFavsButton.performClick();
            return true;
        }
        return super.onKeyDown(keyCode, event);
    }

    DeviceType deviceType;
    public void setOperationButtonsLayout() {
        LinearLayout operationButtonsLayout = findViewById(R.id.operationButtonsLayout);
        operationButtonsLayout.removeAllViews();

        ViewPager vp = new ViewPager(this);
        int[] l1 = new int[]{R.layout.overriding_home_buttons_operational_layout, R.layout.standard_operational_layout};
        int[] l2 = new int[]{R.layout.standard_operational_layout};
        int[] l3 = new int[]{R.layout.horizontal_operational_layout};

        int[] targetLayout;

        boolean isHorizontal = getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE;

        if(isHorizontal || (deviceType == DeviceType.TABLET && !hasPermanentMenuKey)) {
            // no need for switching layouts when one has all the possible buttons available
            targetLayout = l3;
        }
        else { // vertical mode AND (smartphone OR (tablet with physical buttons))
            if(deviceType == DeviceType.TABLET) {
                // (tablet with physical buttons) in vertical mode, show all buttons except Back and Home
                targetLayout = l2;
            }
            else {
                if (hasPermanentMenuKey) targetLayout = l2;
                else targetLayout = l1;
            }
        }

        if(targetLayout == l1) { // more than one layout, needs ViewPager
            vp.setAdapter(new OperationalPagerAdapter(this, targetLayout));
            operationButtonsLayout.addView(vp);
            // MainActivity.makeImageButtonsStateful called in instantiateItem, calling it here would produce an NPE
        }
        else {
            ViewGroup layout = (ViewGroup) layoutInflater.inflate(targetLayout[0], operationButtonsLayout, false);
            operationButtonsLayout.addView(layout);
            makeImageButtonsStateful(layout,
                    new SelectImageButtonListener(context, R.color.imagebuttonselect));
        }
    }

    public void multiSelectAction(View v) {
        FilterSelectionDialog fsd;
        switch (v.getId()) {
            case R.id.itemsSelectAll:
                getCurrentBrowserAdapter().selectAll();
                return;
            case R.id.itemsSelectNone:
                getCurrentBrowserAdapter().selectNone();
                return;
            case R.id.itemsInvertSelection:
                getCurrentBrowserAdapter().invertSelection();
                return;
            case R.id.itemsFilterSelection:
                fsd = new FilterSelectionDialog(MainActivity.this, getCurrentBrowserAdapter(), true);
                fsd.show();
                return;
            case R.id.itemsFilterDeselection:
                fsd = new FilterSelectionDialog(MainActivity.this, getCurrentBrowserAdapter(), false);
                fsd.show();
                return;
        }
    }

    public void operationBarOnClick(View v) {
        switch (v.getId()) {
            case R.id.androidGoBackButton:
                guiBackButton();break;
            case R.id.androidGoHomeButton:
                simulateHomePress(this);break;

            case R.id.upOneLevelButton:
                upOneLevel();break;
            case R.id.pasteButton:
                paste(null);break;

            case R.id.goBackButton:
                goDir_async(-1,null);break;
            case R.id.goAheadButton:
                goDir_async(1,null);break;

            case R.id.newFileButton: // context menu with both file and dir options
                showPopup(null,v,0,null);
                break;

            case R.id.cutButton:
                prepareForCopyOrMove(CopyMoveMode.MOVE);break;
            case R.id.copyButton:
                prepareForCopyOrMove(CopyMoveMode.COPY);break;

            case R.id.deleteButton:
                deleteSelection();break;
            case R.id.compressButton:
                compressSelection();break;
            case R.id.shareButton:
                shareItems(false);break;

            default: break;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/MediaGallery.java`:

```java
package it.pgp.xfiles;

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.ColorRes;
import android.support.annotation.DrawableRes;

import java.util.ArrayList;


public class MediaGallery {
    private Activity mActivity;
    private ArrayList mDataset;
    private String mTitle;
    private int mSelectedImagePosition;
    @ColorRes
    private int mBackgroundColor;
    @DrawableRes
    private int mPlaceHolder;

    public enum Constants {
        IMAGES,
        TITLE,
        SELECTED_IMG_POS,
        BACKGROUND_COLOR,
        PLACE_HOLDER,
        SELECTED_IMAGE_POSITION
    }

    public static MediaGallery Builder(Activity activity, ArrayList<String> imagesURLs) {
        return new MediaGallery(activity, imagesURLs);
    }

    private MediaGallery(Activity activity, ArrayList<String> imagesList) {
        this.mDataset = imagesList;
        this.mActivity = activity;
    }

    public MediaGallery title(String title) {
        this.mTitle = title;
        return this;
    }

    public MediaGallery backgroundColor(@ColorRes int color){
        this.mBackgroundColor = color;
        return this;
    }
    public MediaGallery placeHolder(@DrawableRes int placeholder) {
        this.mPlaceHolder = placeholder;
        return this;
    }

    public MediaGallery selectedImagePosition(int position) {
        this.mSelectedImagePosition = position;
        return this;
    }

    public void show() {
        Intent intent = new Intent(mActivity, MediaGalleryActivity.class);
        Bundle bundle = new Bundle();

        bundle.putStringArrayList(Constants.IMAGES.name(), mDataset);
        bundle.putString(Constants.TITLE.name(), mTitle);
        bundle.putInt(Constants.BACKGROUND_COLOR.name(),mBackgroundColor);
        bundle.putInt(Constants.PLACE_HOLDER.name(),mPlaceHolder);
        bundle.putInt(Constants.SELECTED_IMAGE_POSITION.name(),mSelectedImagePosition);
        intent.putExtras(bundle);
        mActivity.startActivity(intent);
    }
}

```

`app/src/main/java/it/pgp/xfiles/MediaGalleryActivity.java`:

```java
package it.pgp.xfiles;

import android.app.Activity;
import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.os.Build;
import android.os.Bundle;
import android.provider.Settings;
import android.support.annotation.ColorRes;
import android.support.annotation.Nullable;
import android.support.v4.view.ViewPager;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.view.WindowManager;
import android.widget.HorizontalScrollView;
import android.widget.RelativeLayout;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import it.pgp.xfiles.adapters.GalleryPagerAdapter;
import it.pgp.xfiles.adapters.HorizontalListAdapter;
import it.pgp.xfiles.service.visualization.ViewType;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;


public class MediaGalleryActivity extends Activity implements ViewPager.OnPageChangeListener, HorizontalListAdapter.OnImgClick {
    protected HorizontalScrollView mToolbar;
    protected ArrayList<String> dataSet;
    protected String title;
    @ColorRes
    protected int backgroundColor;
    protected int selectedImagePosition;

    private GalleryViewPager mViewPager;
    private RecyclerView imagesHorizontalList;
    private HorizontalListAdapter hAdapter;
    private RelativeLayout rlParentMain;

    public static final Set<String> allowedImageExtensions = Collections.unmodifiableSet(new HashSet<>(Arrays.asList(".bmp",".gif",".jpg",".png")));

    public static int targetIdx = -1;

    public static ArrayList<String> filterByImageExtensionsAndSaveTargetIdx(BasePathContent currentDir, String targetFilename) {
        ArrayList<String> x = new ArrayList<>();
        if(targetFilename==null) targetIdx = 0;
        int idx = 0;
        for (BrowserItem b : MainActivity.mainActivity.getCurrentBrowserAdapter().objects) {
            String y = b.getFilename();
            int l = y.length();
            if(l < 4) continue;
            if(!b.isDirectory && allowedImageExtensions.contains(y.toLowerCase().substring(l-4))) {
                x.add(currentDir.concat(y).dir);
                if(targetIdx==-1 && y.equals(targetFilename)) targetIdx = idx;
                idx++;
            }
        }
        return x;
    }

    public static ArrayList<String> filterByImageExtensionsOnSelection(BasePathContent currentDir, List<BrowserItem> activeSelection) {
        ArrayList<String> x = new ArrayList<>();
        targetIdx = 0;
        for (BrowserItem b : activeSelection) {
            String y = b.getFilename();
            int l = y.length();
            if(l < 4) continue;
            if(!b.isDirectory && allowedImageExtensions.contains(y.toLowerCase().substring(l-4)))
                x.add(currentDir.concat(y).dir);
        }
        return x;
    }

    @Override
    protected void onDestroy() {
        targetIdx = -1;
        super.onDestroy();
    }

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        requestWindowFeature(Window.FEATURE_NO_TITLE);

        // setShowOnLockScreenFlags:
        // -1 -> show only current image in lockscreen mode (i.e. swipe and horizontal viewpager are disabled)
        //  0 (not present) -> no lockscreen mode
        //  1 -> allow browsing current folder in lockscreen mode (i.e. swipe and horizontal viewpager are enabled)

        int lockScreenMode = getIntent().getIntExtra("setShowOnLockScreenFlags",0);
        if(lockScreenMode != 0)
            getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON|
                    WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD|
                    WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED|
                    WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);

        setContentView(R.layout.activity_gallery);
        if(lockScreenMode != 0) findViewById(R.id.showImageOnLockScreen).setVisibility(View.GONE); // no need to show the related button again when we already are in lockscreen mode

        Intent intent = getIntent();
        if(intent == null || intent.getExtras() == null) return;
        Bundle bundle = intent.getExtras();
        dataSet = bundle.getStringArrayList(MediaGallery.Constants.IMAGES.name());
        title = bundle.getString(MediaGallery.Constants.TITLE.name());
        backgroundColor = bundle.getInt(MediaGallery.Constants.BACKGROUND_COLOR.name(),-1);
        selectedImagePosition = bundle.getInt(MediaGallery.Constants.SELECTED_IMAGE_POSITION.name(),0);

        mToolbar = findViewById(R.id.toolbar_media_gallery);

        // init layouts
        mViewPager = findViewById(R.id.pager);
        imagesHorizontalList = findViewById(R.id.imagesHorizontalList);
        rlParentMain = findViewById(R.id.rl_parent_main);
        if(backgroundColor != -1)
            rlParentMain.setBackgroundColor(getResources().getColor(backgroundColor));

        GalleryPagerAdapter adapter = new GalleryPagerAdapter(this, dataSet, mToolbar, imagesHorizontalList, lockScreenMode == -1);
        if(lockScreenMode == -1) mViewPager.enabled = false;
        mViewPager.addOnPageChangeListener(this);
        mViewPager.setAdapter(adapter);
        adapter.notifyDataSetChanged();
        hAdapter = new HorizontalListAdapter(dataSet, this);
        imagesHorizontalList.setLayoutManager(new LinearLayoutManager(this, LinearLayoutManager.HORIZONTAL, false));
        imagesHorizontalList.setAdapter(hAdapter);
        if(lockScreenMode == -1) imagesHorizontalList.setVisibility(View.GONE);
        hAdapter.notifyDataSetChanged();
        hAdapter.setSelectedItem(selectedImagePosition);
        mViewPager.setCurrentItem(selectedImagePosition);
    }

    public DialogInterface.OnClickListener getListener(int lockscreenMode) {
        return (dialog, which) -> {
            Intent i = new Intent(this, MediaGalleryActivity.class);
            i.putExtras(getIntent().getExtras());
            i.putExtra("setShowOnLockScreenFlags", lockscreenMode);
            i.putExtra(MediaGallery.Constants.SELECTED_IMAGE_POSITION.name(), mViewPager.getCurrentItem());
            Toast.makeText(this, "Gallery is being shown on lock screen now", Toast.LENGTH_SHORT).show();
            finish();
            startActivity(i);
        };
    }

    public void setShowImageOnLockScreen(View unused) {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.canDrawOverlays(this)) {
            Toast.makeText(this, "Please grant overlay permission in order to show gallery over lock screen", Toast.LENGTH_SHORT).show();
            return;
        }
        AlertDialog.Builder bld = new AlertDialog.Builder(this);
        bld.setTitle("Show this gallery on lock screen, if any?");
        bld.setNegativeButton(android.R.string.cancel, null);
        bld.setNeutralButton("This folder", getListener(1));
        bld.setPositiveButton("This image only", getListener(-1));
        AlertDialog alertDialog = bld.create();
        alertDialog.getWindow().setType(ViewType.OVERLAY_WINDOW_TYPE);
        alertDialog.show();
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.getItemId() == android.R.id.home) {
            onBackPressed();
        }
        return super.onOptionsItemSelected(item);
    }

    @Override
    public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {

    }

    @Override
    public void onPageSelected(int position) {
        imagesHorizontalList.smoothScrollToPosition(position);
        hAdapter.setSelectedItem(position);
    }

    @Override
    public void onPageScrollStateChanged(int state) {

    }

    @Override
    public void onClick(int pos) {
        mViewPager.setCurrentItem(pos, true);
    }


}

```

`app/src/main/java/it/pgp/xfiles/PermissionManagementActivity.java`:

```java
package it.pgp.xfiles;

import android.Manifest;
import android.app.Activity;
import android.app.NotificationManager;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageManager;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.provider.Settings;
import android.support.annotation.NonNull;
import android.support.annotation.RequiresApi;
import android.view.View;
import android.widget.Button;
import android.widget.Toast;

public class PermissionManagementActivity extends Activity {

    public enum PermReqCodes { STORAGE, SYSTEM_SETTINGS, OVERLAYS, STORAGE_READ /*, EXTERNAL_SD*/, INSTALL_UNKNOWN_APPS, NOTIFS13 }

    NotificationManager nm;

    public boolean areStoragePermissionsGranted() {
        // EITHER Android < 6
        // OR storage permissions granted between Android 6 and 10
        // OR all-files permissions granted on Android 11+
        return /*Build.VERSION.SDK_INT < Build.VERSION_CODES.M ||*/ // PermissionManagementActivity is not shown on Android < 6, decomment this predicate if this method has to be used elsewhere
                (Build.VERSION.SDK_INT < Build.VERSION_CODES.R &&
                        checkSelfPermission(Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) ||
                (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R && Environment.isExternalStorageManager());
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == PermReqCodes.STORAGE.ordinal()) {
            if (grantResults.length == 0) { // request cancelled
                Toast.makeText(this, R.string.storage_perm_denied, Toast.LENGTH_SHORT).show();
                return;
            }

            for (int grantResult : grantResults) {
                if (grantResult != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(this, R.string.storage_perm_denied, Toast.LENGTH_SHORT).show();
                    return;
                }
            }

            Toast.makeText(this, R.string.storage_perm_granted, Toast.LENGTH_SHORT).show();

            requestStorageReadPermissions(); // Oreo and above needs this!
        }
        else if (requestCode == PermReqCodes.STORAGE_READ.ordinal()) {
            if (grantResults.length == 0) { // request cancelled
                Toast.makeText(this, R.string.storage_read_perm_denied, Toast.LENGTH_SHORT).show();
                return;
            }

            for (int grantResult : grantResults) {
                if (grantResult != PackageManager.PERMISSION_GRANTED) {
                    Toast.makeText(this, R.string.storage_read_perm_denied, Toast.LENGTH_SHORT).show();
                    return;
                }
            }

            Toast.makeText(this, R.string.storage_read_perm_granted, Toast.LENGTH_SHORT).show();
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.M)
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        super.onActivityResult(requestCode, resultCode, data);
        PermReqCodes prc = PermReqCodes.values()[requestCode];
        switch (prc) {
            case STORAGE:
                if(Build.VERSION.SDK_INT < Build.VERSION_CODES.R)
                    Toast.makeText(this, "Nothing to do here, already handled in onRequestPermissionsResult", Toast.LENGTH_SHORT).show();
                else
                    Toast.makeText(this, "(Android >= 11) All-files permission "+
                            (Environment.isExternalStorageManager()?"granted":"denied"), Toast.LENGTH_SHORT).show();
                break;
            case SYSTEM_SETTINGS:
                Toast.makeText(this, "System settings permission "+
                        (Settings.System.canWrite(this)?"granted":"denied"), Toast.LENGTH_SHORT).show();
                break;
            case OVERLAYS:
                Toast.makeText(this, "Overlay permission "+
                        (Settings.canDrawOverlays(this)?"granted":"denied"), Toast.LENGTH_SHORT).show();
                break;
            case INSTALL_UNKNOWN_APPS:
                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                    Toast.makeText(this, "Install unknown apps permission "+
                            (getPackageManager().canRequestPackageInstalls()?"granted":"denied"), Toast.LENGTH_SHORT).show();
                }
                break;
            case NOTIFS13:
                Toast.makeText(this, "Notification permission "+(nm.areNotificationsEnabled()?"granted":"denied"), Toast.LENGTH_SHORT).show();
                break;
        }
    }

    public void requestStoragePermissions(View unused) {
        if(Build.VERSION.SDK_INT < Build.VERSION_CODES.R)
            requestPermissions(new String[]{Manifest.permission.WRITE_EXTERNAL_STORAGE}, PermReqCodes.STORAGE.ordinal());
        else {
            // with Android >= 11, by having this signature permission granted by user, we can access all files (both read and write, even external sd and usb drives)
            Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION, Uri.parse("package:" + getPackageName()));
            startActivityForResult(intent, PermReqCodes.STORAGE.ordinal());
        }
    }

    @RequiresApi(api = Build.VERSION_CODES.TIRAMISU)
    public void requestNotifs13Permissions(View view) {
        Intent intent = new Intent();
        intent.setAction(Settings.ACTION_APP_NOTIFICATION_SETTINGS);
        intent.putExtra("android.provider.extra.APP_PACKAGE", getPackageName());
        startActivityForResult(intent, PermReqCodes.NOTIFS13.ordinal());
    }

    // for Oreo, that absurdly needs READ external storage permission request AFTER WRITE one has already been granted (and the latter in this case is automatically granted!)
    protected void requestStorageReadPermissions() {
        if(Build.VERSION.SDK_INT < Build.VERSION_CODES.R)
            requestPermissions(new String[]{Manifest.permission.READ_EXTERNAL_STORAGE}, PermReqCodes.STORAGE_READ.ordinal());
    }

    public static Intent getSystemSettingsIntent(Context context) {
        return new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS, Uri.parse("package:" + context.getPackageName()));
    }

    @RequiresApi(api = Build.VERSION_CODES.M)
    public void openSystemSettingsPermissionsManagement(View unused) {
        startActivityForResult(getSystemSettingsIntent(this), PermReqCodes.SYSTEM_SETTINGS.ordinal());
    }

    @RequiresApi(api = Build.VERSION_CODES.M)
    public void openOverlayPermissionsManagement(View unused) {
        startActivityForResult(new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION, Uri.parse("package:" + getPackageName())), PermReqCodes.OVERLAYS.ordinal());
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    public void openInstallUnknownAppsPermissionsManagement(View unused) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
            startActivityForResult(new Intent(Settings.ACTION_MANAGE_UNKNOWN_APP_SOURCES, Uri.parse("package:" + getPackageName())), PermReqCodes.INSTALL_UNKNOWN_APPS.ordinal());
        else
            Toast.makeText(this, "Request not needed on Android < Oreo", Toast.LENGTH_LONG).show();
    }

    public void completePermissions(View unused) {
        Intent i = new Intent(this,MainActivity.class);
        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_CLEAR_TOP);
        startActivity(i);
    }

    static final String alreadyGrantedButtonText = "Permission already granted";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle("Permission management");
        setContentView(R.layout.activity_permission_management);
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU)
            nm = (NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
    }

    @Override
    protected void onResume() {
        super.onResume();
        Button b;
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            b = findViewById(R.id.notifs13Permissions);
            b.setVisibility(View.VISIBLE);
            findViewById(R.id.notifs13PermissionsExplain).setVisibility(View.VISIBLE);
            if(nm.areNotificationsEnabled()) {
                b.setEnabled(false);
                b.setText(alreadyGrantedButtonText);
            }
        }
        // disable buttons for permissions already granted
        if(areStoragePermissionsGranted()) {
            b = findViewById(R.id.storagePermissions);
            b.setEnabled(false);
            b.setText(alreadyGrantedButtonText);
        }
        if(Settings.System.canWrite(this)) {
            b = findViewById(R.id.sysSettingsPermissions);
            b.setEnabled(false);
            b.setText(alreadyGrantedButtonText);
        }
        if(Settings.canDrawOverlays(this)) {
            b = findViewById(R.id.overlayPermissions);
            b.setEnabled(false);
            b.setText(alreadyGrantedButtonText);
        }
        if(getPackageManager().canRequestPackageInstalls()) {
            b = findViewById(R.id.installUnknownAppsPermissions);
            b.setEnabled(false);
            b.setText(alreadyGrantedButtonText);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/RestarterActivity.java`:

```java
package it.pgp.xfiles;

/**
 * Created by pgp on 13/07/17
 * Activity in standalone Dalvik process that restarts MainActivity
 * when permissions are granted on Android >= 6
 */

import android.app.Activity;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

public class RestarterActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        Log.d("RESTART","RESTART");
        super.onCreate(savedInstanceState);
        setContentView(R.layout.empty);

        int targetPid = getIntent().getExtras().getInt("");
        android.os.Process.sendSignal(targetPid,2); // SIGINT

        // start target activity again
        Intent i = new Intent(RestarterActivity.this,MainActivity.class);

        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK);
        i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
        finish();
        startActivity(i);

        // self kill process
//        android.os.Process.sendSignal(android.os.Process.myPid(),2); // SIGINT
    }
}

```

`app/src/main/java/it/pgp/xfiles/SettingsLauncherActivity.java`:

```java
package it.pgp.xfiles;

import android.app.Activity;
import android.content.Intent;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.provider.Settings;
import android.support.annotation.RequiresApi;
import android.widget.Toast;

public class SettingsLauncherActivity extends Activity {

    static final int overlay_rq_code = 123;
    static final int write_settings_rq_code = 456;

    @RequiresApi(api = Build.VERSION_CODES.M)
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
//        setContentView(R.layout.empty);

        startActivityForResult(new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION),overlay_rq_code);
    }

    @RequiresApi(api = Build.VERSION_CODES.M)
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        if (requestCode == overlay_rq_code) {
            if (Settings.canDrawOverlays(this)) {
                // ok, ask for next signature permission
                startActivityForResult(new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS, Uri.parse("package:" + getPackageName())),write_settings_rq_code);
            }
            else {
                Toast.makeText(this, "Alert permissions must be granted, exiting...", Toast.LENGTH_SHORT).show();
                finishAffinity();
            }
        }
        else if (requestCode == write_settings_rq_code){
            if (Settings.canDrawOverlays(this) && Settings.System.canWrite(this)) {
                Intent i = new Intent(SettingsLauncherActivity.this,MainActivity.class);
                i.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK|Intent.FLAG_ACTIVITY_CLEAR_TOP);
                startActivity(i);
            }
            else {
                Toast.makeText(this, "Both signature permissions must be granted, exiting...", Toast.LENGTH_SHORT).show();
                finishAffinity();
            }
        }
        else throw new RuntimeException("Invalid request code returned in SettingsLauncherActivity");
    }
}

```

`app/src/main/java/it/pgp/xfiles/SortingItem.java`:

```java
package it.pgp.xfiles;

import it.pgp.xfiles.enums.ComparatorField;

/**
 * Created by pgp on 28/10/16
 */

public class SortingItem {
    public ComparatorField comparatorField;
    private boolean selected;
    private boolean reversed;

    public SortingItem(ComparatorField comparatorField, boolean selected, boolean reversed) {
        this.comparatorField = comparatorField;
        this.selected = selected;
        this.reversed = reversed;
    }

    public boolean isSelected() {
        return selected;
    }
    public boolean isReversed() {
        return reversed;
    }

    public void setSelected(boolean selected) {
        this.selected = selected;
    }
    public void setReversed(boolean reversed) {
        this.reversed = reversed;
    }

    public void toggleSelected() {
        selected = !selected;
    }
    public void toggleReversed() {
        reversed = !reversed;
    }

    // DEBUG toString
    // return comparatorField.name1()+": "+(selected?"V":"O")+", "+(reversed?"V":"O");
}

```

`app/src/main/java/it/pgp/xfiles/SwipeRefreshLayoutChildCanScroll.java`:

```java
package it.pgp.xfiles;

import android.content.Context;
import android.support.v4.widget.SwipeRefreshLayout;
import android.util.AttributeSet;

/**
 * Created by pgp on 03/11/16
 */

public class SwipeRefreshLayoutChildCanScroll extends SwipeRefreshLayout {
    MainActivity mainActivity;

    public SwipeRefreshLayoutChildCanScroll(Context context) {
        super(context);
    }

    public SwipeRefreshLayoutChildCanScroll(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public void setParentActivity(MainActivity mainActivity) {
        this.mainActivity= mainActivity;
    }

    @Override
    public boolean canChildScrollUp() {
        return mainActivity.getCurrentMainBrowserView().canScrollVertically(-1);
    }
}

```

`app/src/main/java/it/pgp/xfiles/XREDirectShareActivity.java`:

```java
package it.pgp.xfiles;

import android.app.ProgressDialog;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.util.Log;
import android.view.View;
import android.widget.LinearLayout;
import android.widget.Toast;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.locks.LockSupport;

import it.pgp.xfiles.enums.CopyMoveMode;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.roothelperclient.RootHelperClient;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.NonInteractiveXFilesRemoteTransferService;
import it.pgp.xfiles.service.params.CopyMoveParams;
import it.pgp.xfiles.utils.GenericDBHelper;
import it.pgp.xfiles.utils.IntentUtil;
import it.pgp.xfiles.utils.NetworkUtils;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;
import it.pgp.xfiles.utils.wifi.WifiButtonsLayout;
import it.pgp.xfiles.viewmodels.XREDirectoryViewModel;

public class XREDirectShareActivity extends EffectActivity {

    WifiButtonsLayout wbl;
    LinearLayout xre_embedded_layout;

    GenericDBHelper dbh;

    List<String> filesToUpload_; // to be converged into CopyMoveListPathContent below
    BasePathContent srcPath; // to be converged into CopyMoveListPathContent below
    CopyMoveListPathContent filesToUpload;

    private final AtomicBoolean currentDirAutofillOverride = new AtomicBoolean(true);

    XREDirectoryViewModel xreDirectoryViewModel;

    public static XREDirectShareActivity instance;

    private void ok(View unused) {
        BasePathContent path;

        // empty base path means root path (/), so don't validate it
        String ret = XREDirectoryViewModel.basicNonEmptyValidation(xreDirectoryViewModel.xreServerHost);
        if (!ret.isEmpty()) {
            Toast.makeText(this, ret, Toast.LENGTH_SHORT).show();
            return;
        }
        path = new XREPathContent(
                xreDirectoryViewModel.xreServerHost.getText().toString(),
//                        Integer.valueOf(xreDirectoryViewModel.xreServerPort.getText().toString()),
                xreDirectoryViewModel.xreRemotePath.getText().toString()
        );

        // run xre copy service/task
        Intent startIntent = new Intent(this,NonInteractiveXFilesRemoteTransferService.class);
        startIntent.setAction(BaseBackgroundService.START_ACTION);
        startIntent.putExtra("params",new CopyMoveParams(filesToUpload,path));
        startService(startIntent);
//        finish(); // Security Manager prevents using content provider's file objects after the activity has ended
        if(filesToUpload instanceof CopyListUris) MainActivity.simulateHomePress(this); // pause activity instead of finishing it
        else finish();
    }

    static class ThreadWrapper extends Thread {
        private Runnable r;

        public void setRunnable(Runnable r) {
            this.r = r;
        }

        @Override
        public void run() {
            r.run();
        }
    }

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        instance = this;
        setActivityIcon(R.drawable.xf_xre_server_up);
        MainActivity.refreshAppContext(getApplicationContext());
        final RootHelperClient rh = MainActivity.getRootHelperClient();

        // CHECK SHARE INTENT
        List<Uri> uris = IntentUtil.getShareSelectionFromIntent(getIntent());
        if (uris == null || uris.isEmpty()) {
            Toast.makeText(this, "Unable to get URI selection", Toast.LENGTH_SHORT).show();
            finish();
            return;
            /* onDestroy() called immediately after this
            web source: https://developer.android.com/reference/android/app/Activity#onCreate(android.os.Bundle)
            */
        }

        if ("content".equals(uris.get(0).getScheme())) { // TODO check if condition is well written
            Log.d("DIRECTSHARE", "Populating from content uris");
            filesToUpload = CopyListUris.getFromUriList(uris);
        }
        else {
            Log.d("DIRECTSHARE", "Populating from path uris");
            Map.Entry<BasePathContent,List<String>> me = IntentUtil.getCommonAncestorAndItems(this,uris);
            filesToUpload_ = me.getValue();
            srcPath = me.getKey();

            // anonymous local classes are not serializable, so should populate it the standard way
            List<BrowserItem> lb = new ArrayList<>();
            try {
                for (String path : filesToUpload_) {
                    // FIXME not optimized, one stat request for item
                    SingleStatsItem ssi = rh.statFile(srcPath.concat(path));
                    lb.add(new BrowserItem(path,ssi.size,ssi.modificationTime,ssi.isDir,false));
                }
            }
            catch (IOException e) {
                e.printStackTrace();
            }

            filesToUpload = new CopyMoveListPathContent(lb,CopyMoveMode.COPY,srcPath);
        }

        setContentView(R.layout.activity_xre_direct_share);
        dbh = new GenericDBHelper(this);
        xre_embedded_layout = findViewById(R.id.xre_embedded_layout);

        wbl = new WifiButtonsLayout(this);
        LinearLayout target = findViewById(R.id.targetWifiButtonsLayout);
        target.addView(wbl);

        xreDirectoryViewModel = new XREDirectoryViewModel(this, xre_embedded_layout, dbh, currentDirAutofillOverride);
        xreDirectoryViewModel.initViews();

        findViewById(R.id.xreDirectShareOkButton).setOnClickListener(this::ok);

        /**
         * check extras for unattended direct share:
         * creates a cancelable progressdialog, waits for some xre server to send an announce,
         * then connects to it and sends data
         */
        if(getIntent().getBooleanExtra("unattended", false)) {

            ThreadWrapper t = new ThreadWrapper();

            ProgressDialog pd = new ProgressDialog(this);
            pd.setIndeterminate(true);
            pd.setCancelable(true);
            pd.setOnCancelListener(d -> {
                t.interrupt();
                finish();
            });
            pd.setMessage("Waiting for an XRE server to come online...");
            pd.show();

            // periodically check size of listener adapter, then click item and ok
            t.setRunnable(()->{
                while(!Thread.currentThread().isInterrupted()) {
                    if(xreDirectoryViewModel.xreAnnouncesAdapter.items.size() > 0) {
                        int activePosition = 0;
                        runOnUiThread(()->{
                            pd.dismiss();
                            xreDirectoryViewModel.xreAnnouncesListView.performItemClick(
                                    xreDirectoryViewModel.xreAnnouncesListView.getAdapter().getView(activePosition,null,null),
                                    activePosition,
                                    xreDirectoryViewModel.xreAnnouncesListView.getAdapter().getItemId(activePosition));
                            ok(null);
                        });
                        break;
                    }
                    LockSupport.parkNanos(500000000);
                }
                Log.d("UNATTENDED","Thread ended");
            });
            t.start();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        wbl.registerListeners();
        NetworkUtils.startXreAnnounceListenerThread(this,xreDirectoryViewModel.xreAnnouncesAdapter);
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (wbl != null) wbl.unregisterListeners();
        NetworkUtils.shutdownMulticastListening();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        instance = null;
        if (MainActivity.mainActivity == null) MainActivity.context = null;
    }
}

```

`app/src/main/java/it/pgp/xfiles/XRE_RHSS_Widget.java`:

```java
package it.pgp.xfiles;

import android.app.PendingIntent;
import android.appwidget.AppWidgetManager;
import android.appwidget.AppWidgetProvider;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.util.Log;
import android.widget.RemoteViews;

import it.pgp.xfiles.dialogs.XFilesRemoteSessionsManagementActivity;
import it.pgp.xfiles.roothelperclient.RemoteServerManager;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.utils.NetworkUtils;

public class XRE_RHSS_Widget extends AppWidgetProvider {

    private static final String standard = "it.pgp.xfiles.appwidget.action.STANDARD_UPDATE";
    private static final String onDemand = "it.pgp.xfiles.appwidget.action.ON_DEMAND_UPDATE";

    public static void updateAllDirect(Context context) {
        Log.d(XRE_RHSS_Widget.class.getName(),"updateAllDirect");
        AppWidgetManager widgetManager = AppWidgetManager.getInstance(context);
        int[] ids = widgetManager.getAppWidgetIds(new ComponentName(context, XRE_RHSS_Widget.class));
        widgetManager.notifyAppWidgetViewDataChanged(ids, android.R.id.list);

        RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.xre_rhss_widget);

        // check rhss manager thread status
        if (RemoteServerManager.rhssManagerRef.get() == null) {
            remoteViews.setImageViewResource(R.id.rhss_toggle_rhss_button,R.drawable.xf_xre_server_down);
            remoteViews.setTextViewText(R.id.rhssIPAddresses,"");
        }
        else {
            remoteViews.setImageViewResource(R.id.rhss_toggle_rhss_button,R.drawable.xf_xre_server_up);
            remoteViews.setTextViewText(R.id.rhssIPAddresses, NetworkUtils.getInterfaceAddressesAsString());
        }

        for (int appWidgetId : ids) {
            Intent forToggleIntentUpdate = new Intent(context, XRE_RHSS_Widget.class);
            forToggleIntentUpdate.setAction(onDemand);
            forToggleIntentUpdate.putExtra(AppWidgetManager.EXTRA_APPWIDGET_IDS, new int[]{appWidgetId});
            PendingIntent forToggleUpdate = PendingIntent.getBroadcast(
                    context, appWidgetId, forToggleIntentUpdate,
                    PendingIntent.FLAG_UPDATE_CURRENT | BaseBackgroundService.pendingIntentFlag);
            remoteViews.setOnClickPendingIntent(R.id.rhss_toggle_rhss_button, forToggleUpdate);

            Intent XREActiveClientsActivityLaunchIntent = new Intent(context, XFilesRemoteSessionsManagementActivity.class);
            PendingIntent XREActiveClientsActivityLaunchPendingIntent = PendingIntent.getActivity(context, 0, XREActiveClientsActivityLaunchIntent, BaseBackgroundService.pendingIntentFlag);
            remoteViews.setOnClickPendingIntent(R.id.rhss_show_xre_connections, XREActiveClientsActivityLaunchPendingIntent);

            widgetManager.updateAppWidget(appWidgetId, remoteViews);
        }
    }

    @Override
    public void onReceive(Context context, Intent intent) {
        super.onReceive(context, intent);
        String a = intent.getAction();
        Log.d("XRE_RHSS","onReceive action: "+intent.getAction());
        if (a == null) return;
        if (MainActivity.context == null)
            MainActivity.refreshAppContext(context); // hack, to let RHSSUpdateThread be able to refresh widgets without an alive activity
        try {
            switch(a) {
                case standard:
                    Log.d("XRE_RHSS","standard");
                    break;
                case onDemand:
                    Log.d("XRE_RHSS","onDemand: toggle server status");

                    if (RemoteServerManager.rhssManagerRef.get() == null) {
                        MainActivity.getRootHelperClient(context);
                        int result = RemoteServerManager.rhss_action(RemoteServerManager.RHSS_ACTION.START_ANNOUNCE);
                        Log.d("XRE_RHSS", "onDemand toggle result (->ON): "+result);
                    }
                    else {
                        if(MainActivity.mainActivity == null) MainActivity.killRHWrapper();
                        int result = RemoteServerManager.rhss_action(RemoteServerManager.RHSS_ACTION.STOP);
                        Log.d("XRE_RHSS", "onDemand toggle result (->OFF): "+result);
                    }
                    // RHSSUpdateThread will do the direct widget update once started/stopped
                    return;
                default:
                    break;
            }
            updateAllDirect(context);
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }
}


```

`app/src/main/java/it/pgp/xfiles/adapters/BrowserAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.drawable.BitmapDrawable;
import android.graphics.drawable.Drawable;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ArrayAdapter;

import com.tomclaw.imageloader.util.ImageViewHandlers;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ArchiveType;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 26/09/16
 */

public abstract class BrowserAdapter extends ArrayAdapter<BrowserItem> {

    public static Bitmap dirIV,nestedDirIv,fileIV,linkIV;
    public static final Map<String,Bitmap> archiveIcons = new HashMap<>();

    public static Bitmap overlay(Bitmap bmp1, Bitmap bmp2) {
        Bitmap bmOverlay = Bitmap.createBitmap(bmp1.getWidth(), bmp1.getHeight(), bmp1.getConfig());
        Canvas canvas = new Canvas(bmOverlay);
        canvas.drawBitmap(bmp1, new Matrix(), null);
        canvas.drawBitmap(bmp2, 0, 0, null);
        return bmOverlay;
    }

    private static void loadArchiveIcons(Context context) {
        if(archiveIcons.isEmpty()) {
            for(ArchiveType a : ArchiveType.values()) {
                if (a == ArchiveType.RAR5 || a == ArchiveType.UNKNOWN) continue;
                archiveIcons.put(a.s,BitmapFactory.decodeResource(context.getResources(), a.resId));
            }
        }
    }

    public static final Map<String,Bitmap> apkIconCache = new HashMap<>();

    public static Bitmap loadApkIconAsBitmap(String apkFilePath, Context context) {
        Bitmap bitmap = apkIconCache.get(apkFilePath);
        if(bitmap != null) return bitmap;
        PackageManager pm = context.getPackageManager();
        PackageInfo packageInfo = pm.getPackageArchiveInfo(apkFilePath, PackageManager.GET_META_DATA);
        if(packageInfo != null) {
            ApplicationInfo appInfo = packageInfo.applicationInfo;
            appInfo.sourceDir = apkFilePath;
            appInfo.publicSourceDir = apkFilePath;

            Drawable iconDrawable = appInfo.loadIcon(pm);
            if(iconDrawable instanceof BitmapDrawable) bitmap = ((BitmapDrawable)iconDrawable).getBitmap();
            else {
                // Convert other drawable types to Bitmap if necessary
                bitmap = Bitmap.createBitmap(iconDrawable.getIntrinsicWidth(), iconDrawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
                Canvas canvas = new Canvas(bitmap);
                iconDrawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
                iconDrawable.draw(canvas);
            }
        }
        else bitmap = null;
        apkIconCache.put(apkFilePath, bitmap);
        return bitmap;
    }

    public static Bitmap getBitmapByExtension(BrowserItem item, MainActivity context) {
        Bitmap target;
        if(item.isNestedDir) target = nestedDirIv;
        else if(item.isDirectory) target = dirIV;
        else {
            String ext = item.getFileExt().toLowerCase();
            if(ext.equals(ArchiveType.APK.s)) {
                BasePathContent bpc = context.getCurrentDirCommander().getCurrentDirectoryPathname();
                if(bpc.providerType == ProviderType.LOCAL) return loadApkIconAsBitmap(bpc.concat(item.getFilename()).dir, context);
            }
            if (ArchiveType.formats.contains(ext)) target = archiveIcons.get(ext);
            else target = fileIV;
        }
        if(item.isLink)
            target = overlay(target,linkIV);

        return target;
    }

    public View fastCreateModeHeaderView = null;

    protected final MainActivity mainActivity;
    protected LayoutInflater inflater;
    protected int containerLayout; // to be assigned in subclasses constructors
    public List<BrowserItem> objects,currentObjects;
    // "objects" (full objects) as reference list, and currentObjects for quick find currently shown results

    BrowserAdapter(MainActivity mainActivity, List<BrowserItem> objects) {
        super(mainActivity, android.R.layout.simple_list_item_1, objects);
        this.mainActivity = mainActivity;
        this.objects = objects;
        this.currentObjects = objects;
        inflater = LayoutInflater.from(mainActivity);

        if (dirIV == null) dirIV = BitmapFactory.decodeResource(mainActivity.getResources(), R.drawable.xf_dir_blu);
        if (nestedDirIv == null) nestedDirIv = ImageViewHandlers.tintBitmap(dirIV, 0xFF00FF00); // green
        if (fileIV == null) fileIV = BitmapFactory.decodeResource(mainActivity.getResources(), R.drawable.xfiles_file_icon);
        if (linkIV == null) linkIV = BitmapFactory.decodeResource(mainActivity.getResources(), R.drawable.xfiles_link_icon);
        loadArchiveIcons(mainActivity);
    }

    @Override
    public long getItemId(int position) {
        return position; //return position here
    }

    @Override
    public BrowserItem getItem(int position) {
        return currentObjects.get(position);
    }

    @Override
    public int getCount() {
        return currentObjects.size();
    }

    @Override
    public boolean areAllItemsEnabled() {
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            if (!b.isChecked()) return false;
        }
        return true;
    }

    public int getSelectedCount() {
        int selectedCount=0;
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            if (b.isChecked()) selectedCount++;
        }
        return selectedCount;
    }

    // remove return value when checksum directory protocol will be implemented
    public boolean ensureOnlyFilesSelection() {
        for (BrowserItem b : objects) {
            if (b.isChecked()) {
                if (b.isDirectory) return false;
            }
        }
        return true;
    }

//    public List<String> getSelectedItemsAsStrings() {
//        List<String> selectedItems = new ArrayList<>();
//        for(int i=0; i<getCount() ; i++) {
//            BrowserItem b = getItem(i);
//            if (b.isChecked()) {
//                String f = activity.getCurrentDirCommander().getCurrentDirectoryPathname().dir+"/"+b.filename;
//                selectedItems.add(f);
//            }
//        }
//        return selectedItems;
//    }

    public List<BrowserItem> getSelectedItems() {
        List<BrowserItem> selectedItems = new ArrayList<>();
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            if (b.isChecked()) {
                selectedItems.add(b);
            }
        }
        return selectedItems;
    }

    public List<String> getSelectedItemsAsNameOnlyStrings() {
        List<String> selectedItems = new ArrayList<>();
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            if (b.isChecked()) {
                selectedItems.add(b.getFilename());
            }
        }
        return selectedItems;
    }

    public List<BasePathContent> getSelectedItemsAsPathContents() {
        List<BasePathContent> selectedFiles = new ArrayList<>();
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            if (b.isChecked()) {
                BasePathContent f = mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname().concat(b.getFilename());
                selectedFiles.add(f);
            }
        }
        return selectedFiles;
    }


    public void toggleSelectOne(BrowserItem b) {
        b.toggle();
        notifyDataSetChanged();
    }

    // method used for one-click select all / deselect all switching
//    public void selectAllDeselectAllSwitch() {
//        if (areAllItemsEnabled()) selectNone();
//        else selectAll();
//    }

    public void selectAll() {
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            b.setChecked(true);
        }
        notifyDataSetChanged();
    }

    public void selectNone() {
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            b.setChecked(false);
        }
        notifyDataSetChanged();
    }

    public void invertSelection() {
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            b.toggle();
        }
        notifyDataSetChanged();
    }

    // from RAR UI
    public void filterSelection(String content, boolean selectOrDeselect, boolean ignoreCase) {
        for(int i=0; i<getCount() ; i++) {
            BrowserItem b = getItem(i);
            String f = b.getFilename();
            if((ignoreCase && f.toLowerCase().contains(content.toLowerCase())) ||
                    (!ignoreCase && f.contains(content)))
                b.setChecked(selectOrDeselect);
        }
        notifyDataSetChanged();
    }

    public void filterObjects(CharSequence content, boolean ignoreCase) {
        if (content.equals("")) {
            // no filter, revert to full list of objects
            currentObjects = objects;
        }
        else {
            currentObjects = new ArrayList<>();
            // TODO to be replaced with recursive filtering (on currentObjects)
            if (ignoreCase) {
                for (BrowserItem b : objects) {
                    if (b.getFilename().toLowerCase().contains(content.toString().toLowerCase())) currentObjects.add(b);
                }
            }
            else {
                for (BrowserItem b : objects) {
                    if (b.getFilename().contains(content)) currentObjects.add(b);
                }
            }
        }
        notifyDataSetChanged();
    }

    /**
     * @param filename filename to get the position
     * @return position in the adapter of the located file
     * @apiNote To be used only from {@link it.pgp.xfiles.FindActivity}
     */
    public int findPositionByFilename(String filename) {
        int locatedPosition = 0;
        String[] splitted = filename.split("/"); // from find, contains whole path
        if (splitted.length == 0) return -1;
        String filenameOnly = splitted[splitted.length-1];
        for (BrowserItem b : objects) { // from main browser adapter, they contain filename only
            if (filenameOnly.equals(b.getFilename())) return locatedPosition;
            locatedPosition++;
        }
        return -1;
    }

}

```

`app/src/main/java/it/pgp/xfiles/adapters/BrowserGridAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.graphics.Color;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;

/**
 * Created by pgp on 01/11/16
 */

public class BrowserGridAdapter extends BrowserAdapter {
    public static class BrowserItemViewHolder {
        TextView name;
        ImageView imageView;
        BrowserItemViewHolder(TextView name, ImageView imageView) {
            this.name = name;
            this.imageView = imageView;
        }
    }

    public BrowserGridAdapter(MainActivity mainActivity, List<BrowserItem> objects) {
        super(mainActivity, objects);
        containerLayout = R.layout.browser_item_grid;
    }

    @Override
    public View getView(final int position, View convertView, final ViewGroup parent) {
        BrowserItem item = this.getItem(position);
        TextView name;
        ImageView imageView;

        if(convertView == null){
            convertView = inflater.inflate(containerLayout, null);

            name = convertView.findViewById(R.id.browserItemFilename);
            imageView = convertView.findViewById(R.id.fileTypeImage);

            convertView.setTag(new BrowserItemViewHolder(name,imageView));
        }
        else {
            BrowserItemViewHolder viewHolder = (BrowserItemViewHolder) convertView.getTag();
            name = viewHolder.name;
            imageView = viewHolder.imageView;
        }

        convertView.setBackgroundColor(item.isChecked()? 0x9934B5E4: Color.TRANSPARENT);

        name.setText(item.getFilename());

        imageView.setImageBitmap(getBitmapByExtension(item, mainActivity));
        return convertView;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/BrowserListAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.graphics.Color;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;

/**
 * Created by pgp on 01/11/16
 */

public class BrowserListAdapter extends BrowserAdapter {

    public BrowserListAdapter(MainActivity mainActivity, List<BrowserItem> objects) {
        super(mainActivity, objects);
        containerLayout = R.layout.browser_item;
    }

    public static class BrowserItemViewHolder {
        TextView name,size,date;
        ImageView imageView;

        BrowserItemViewHolder(TextView name,TextView size, TextView date, ImageView imageView) {
            this.name = name;
            this.size = size;
            this.date = date;
            this.imageView = imageView;
        }
    }

    private final DateFormat formatter = new SimpleDateFormat("dd-MM-yyyy HH:mm:ss zzz");

    @Override
    public View getView(final int position, View convertView, final ViewGroup parent) {
        BrowserItem item = this.getItem(position);
        TextView name,size,date;
        ImageView imageView;

        if(convertView == null){
            convertView = inflater.inflate(containerLayout, null);

            name = convertView.findViewById(R.id.browserItemFilename);
            size = convertView.findViewById(R.id.browserItemFileSize);
            date = convertView.findViewById(R.id.browserItemFileDate);
            imageView = convertView.findViewById(R.id.fileTypeImage);

            convertView.setTag(new BrowserItemViewHolder(name,size,date,imageView));
        }
        else {
            BrowserItemViewHolder viewHolder = (BrowserItemViewHolder) convertView.getTag();
            name = viewHolder.name;
            size = viewHolder.size;
            date = viewHolder.date;
            imageView = viewHolder.imageView;
        }

        convertView.setBackgroundColor(item.isChecked()? 0x9934B5E4: Color.TRANSPARENT);

        name.setText(item.getFilename());
        size.setText(""+item.size);
        date.setText(formatter.format(item.date));

        imageView.setImageBitmap(getBitmapByExtension(item, mainActivity));

        imageView.setOnClickListener(v -> {
            boolean multiselect = mainActivity.browserPagerAdapter.multiSelectModes[mainActivity.browserPager.getCurrentItem()];
            boolean inFind = BrowserListAdapter.this instanceof FindResultsAdapter;

            if(multiselect && !inFind) {
                // same logic of listViewLevelOICL
                // FIXME no long click handling in multiselect mode
                // checking condition in getView generates inconsistencies, unless one forces recycling views on multiselect mode change
                mainActivity.getCurrentBrowserAdapter().toggleSelectOne(item);
            }
            else if(!inFind)
                mainActivity.showPopup(null,v,position,null);
        });

        return convertView;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/BrowserPagerAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.app.AlertDialog;
import android.content.Context;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.text.Editable;
import android.text.TextWatcher;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AbsListView;
import android.widget.CheckedTextView;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;
import android.widget.TextView;
import android.widget.Toast;

import java.util.Collections;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.SortingItem;
import it.pgp.xfiles.SwipeRefreshLayoutChildCanScroll;
import it.pgp.xfiles.adapters.continuousselection.CSCheckboxes;
import it.pgp.xfiles.adapters.continuousselection.ContSelHandlingLayout;
import it.pgp.xfiles.adapters.continuousselection.ContSelListener;
import it.pgp.xfiles.comparators.AdvancedComparator;
import it.pgp.xfiles.comparators.FilenameComparator;
import it.pgp.xfiles.dialogs.CreateFileOrDirectoryDialog;
import it.pgp.xfiles.enums.BrowserViewMode;
import it.pgp.xfiles.enums.ComparatorField;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.exceptions.DirCommanderException;
import it.pgp.xfiles.utils.CheckableSingleExecutor;
import it.pgp.xfiles.utils.DirCommander;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

/**
 * Created by pgp on 03/11/16
 */

public class BrowserPagerAdapter extends PagerAdapter {

    private final Context mContext;
    private final MainActivity mainActivity;

    private static final int ADAPTER_SIZE = 2;

    public final CheckableSingleExecutor[] goDirExecutors;

    private final ViewGroup[] rootLayouts = new ViewGroup[ADAPTER_SIZE];

    // almost every array is initially populated with null objects
    public final DirCommander[] dirCommanders = new DirCommander[ADAPTER_SIZE];
    public final AbsListView[] mainBrowserViews = new AbsListView[ADAPTER_SIZE]; // to be assigned as ListView or GridView (same adapter as support)
    public final BrowserAdapter[] browserAdapters = new BrowserAdapter[ADAPTER_SIZE];
    public final BrowserViewMode[] browserViewModes = new BrowserViewMode[]{BrowserViewMode.LIST,BrowserViewMode.LIST};
    public final TextView[] currentDirectoryTextViews = new TextView[ADAPTER_SIZE];
    public final RelativeLayout[] mainBrowserViewLayouts = new RelativeLayout[ADAPTER_SIZE]; // target container for inflating different browser views (list, grid)
    public final RelativeLayout[] mainBrowserViewLayoutParents = new RelativeLayout[ADAPTER_SIZE];

    public final View[] fastRenameModeViews = new View[ADAPTER_SIZE];


    private final SwipeRefreshLayoutChildCanScroll[] swipeRefreshLayouts = new SwipeRefreshLayoutChildCanScroll[ADAPTER_SIZE];

    private final CSCheckboxes[] csCheckBoxes = new CSCheckboxes[ADAPTER_SIZE];
    private final ContSelListener[] csListeners = new ContSelListener[ADAPTER_SIZE];
    private final ContSelHandlingLayout[] csLayouts = new ContSelHandlingLayout[ADAPTER_SIZE];

    private final LinearLayout[] quickFindModeLayouts = new LinearLayout[ADAPTER_SIZE];

    public void createStandardCommanders() {
        BasePathContent path0, path1;
        path0 = dirCommanders[0]==null?
                new LocalPathContent(Misc.internalStorageDir.getAbsolutePath()):
                dirCommanders[0].getCurrentDirectoryPathname();
        path1 = dirCommanders[1]==null?
                new LocalPathContent("/"):
                dirCommanders[1].getCurrentDirectoryPathname();

        // first commander expected to load an always-accessible directory (fail on first exception)
        try {
            this.dirCommanders[0] = new DirCommander(path0);
            this.dirCommanders[1] = new DirCommander(path1,path0);
        }
        catch (DirCommanderException e) {
            Toast.makeText(mainActivity, "Unable to create or rebuild dir commanders, exiting...", Toast.LENGTH_SHORT).show();
            mainActivity.finishAffinity();
        }
    }

    public BrowserPagerAdapter(Context context, final MainActivity mainActivity) {
        mContext = context;
        this.mainActivity = mainActivity;
        this.goDirExecutors = new CheckableSingleExecutor[]{new CheckableSingleExecutor(context),new CheckableSingleExecutor(context)};
        createStandardCommanders();
    }

    public boolean checkUpdateIntent = false;

    // position: 0 or 1
    @NonNull
    @Override
    public Object instantiateItem(@NonNull ViewGroup collection, int position) {
        viewPager = (ViewPager)collection;
        return instantiateItem_(BrowserViewMode.LIST, position);
    }

    private Object instantiateItem_(BrowserViewMode browserViewMode, int position) {
        final LayoutInflater inflater = LayoutInflater.from(mContext);

        ViewGroup layout = (ViewGroup) inflater.inflate(R.layout.browser_page, viewPager, false);

        initMainViews(inflater, layout, browserViewMode, position);
        viewPager.addView(layout);

        rootLayouts[position] = layout;

        if (checkUpdateIntent) {
            mainActivity.updateFromSelfIntent(mainActivity.getIntent());
            checkUpdateIntent = false;
        }

        return layout;
    }

    // browserPageLayout: the one to perform findviewbyid over
    private void initMainViews(LayoutInflater inflater,
                               @NonNull View browserPageLayout,
                               BrowserViewMode browserViewMode,
                               int position) {
        browserViewModes[position] = browserViewMode;

        final Runnable refreshRunnable = () -> {
            GenericDirWithContent dwc = mainActivity.getCurrentDirCommander().refresh_background();

            if(dwc.errorCode == FileOpsErrorCodes.CURRENT_DIR_NO_LONGER_AVAILABLE) {
                mainActivity.runOnUiThread(()-> {
                    if(dwc.listViewPosition == null) {
                        Toast.makeText(mainActivity, "Current dir was no longer available, unable to go back even to start folder, exiting...", Toast.LENGTH_SHORT).show();
                        mainActivity.finishAffinity();
                    }
                    else Toast.makeText(mainActivity,"Current dir is no longer available, went back of " + dwc.listViewPosition + " positions", Toast.LENGTH_SHORT).show();
                });
            }

            if(dwc.listViewPosition != null)
                mainActivity.runOnUiThread(()->showDirContent(dwc,position,null));
        };

        swipeRefreshLayouts[position] = browserPageLayout.findViewById(R.id.activity_main_swipe_refresh_layout);
        swipeRefreshLayouts[position].setParentActivity(mainActivity);
        swipeRefreshLayouts[position].setOnRefreshListener(() -> {
            if(browserAdapters[position].getSelectedCount() == 0) {
                goDirExecutors[position].submit(refreshRunnable);
            }
            else {
                AlertDialog.Builder bld = new AlertDialog.Builder(mainActivity);
                bld.setTitle("Refreshing will clear active selection");
                bld.setNegativeButton(android.R.string.cancel, (dialog, which) -> swipeRefreshLayouts[position].setRefreshing(false));
                bld.setPositiveButton(android.R.string.ok, (dialog, which) -> goDirExecutors[position].submit(refreshRunnable));
                bld.create().show();
            }
        });

        mainBrowserViewLayouts[position] = browserPageLayout.findViewById(R.id.mainBrowserViewLayout);
        mainBrowserViewLayoutParents[position] = browserPageLayout.findViewById(R.id.mainBrowserViewLayoutParent);

        View targetLayout = inflater.inflate(browserViewModes[position].getLayout(),null);
        mainBrowserViewLayouts[position].addView(targetLayout);

        mainBrowserViews[position] = browserPageLayout.findViewById(browserViewModes[position].getId());

        mainBrowserViews[position].setFastScrollEnabled(true);
        currentDirectoryTextViews[position] = browserPageLayout.findViewById(R.id.currentDirectoryTextView);
        mainActivity.registerForContextMenu(currentDirectoryTextViews[position]);

        showDirContent(dirCommanders[position].refresh(),position,null);

        mainBrowserViews[position].setOnItemClickListener(mainActivity.listViewLevelOICL);
        setLongClickListener(position);
    }

    private void changeMainViews(BrowserViewMode browserViewMode, int position) {
        LayoutInflater inflater = LayoutInflater.from(mContext);
        browserViewModes[position] = browserViewMode;

        mainBrowserViewLayouts[position].removeAllViews();

        View targetLayout = inflater.inflate(browserViewModes[position].getLayout(),null);
        mainBrowserViewLayouts[position].addView(targetLayout);

        mainBrowserViews[position] = mainBrowserViewLayouts[position].findViewById(browserViewModes[position].getId());

        mainBrowserViews[position].setFastScrollEnabled(true);

        // avoid refreshing directory, retrieve current dir with content from current browseradapter and dircommander
        showDirContent(
                new GenericDirWithContent(
                        dirCommanders[position].getCurrentDirectoryPathname().dir,
                        browserAdapters[position].objects
                ),
                position,
                null);

        // mainBrowserViews[position].setAdapter(browserAdapters[position]); // already called in showDirContent
        mainBrowserViews[position].setOnItemClickListener(mainActivity.listViewLevelOICL);
        setLongClickListener(position);
    }

    @Override
    public void destroyItem(@NonNull ViewGroup collection, int position, @NonNull Object view) {
        collection.removeView((View) view);
    }

    // number of browser views
    @Override
    public int getCount() {
        return ADAPTER_SIZE;
    }

    @Override
    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {
        return view==object;
    }

    private ViewPager viewPager; // actually it is the ViewPager instance
    @Override
    public void setPrimaryItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
        rootLayouts[position] = (ViewGroup)object;
    }

    public void changeBrowserViewMode(int position) {
        browserViewModes[position] = browserViewModes[position].next();
        changeMainViews(browserViewModes[position], position);
    }

    public void setLongClickListener(int position) {
        mainBrowserViews[position].setOnItemLongClickListener((parent, view, position1, id) -> {
            if(fastRenameModeViews[position]==null) {
                mainActivity.showPopup(parent, view, position1, null);
                return true;
            }
            else return false; // fast rename mode for the current browser page, allow clipboard context menu to popup
        });
    }

    public void recreateAdapterAndSelectMode(BrowserViewMode m, int position, GenericDirWithContent dirWithContent) {
        boolean[] lastcontselmode = (csCheckBoxes[position] != null)?csCheckBoxes[position].getAsBooleans():new boolean[]{false,false,false};
        CreateFileOrDirectoryDialog.resetCreateMode(browserAdapters[position], mainBrowserViews[position]);
        browserAdapters[position] = m.newAdapter(mainActivity,dirWithContent.content);
        fastRenameModeViews[position] = null;
        setMultiSelectModeLayout(multiSelectModes[position],position);
        int[] resIds = {R.id.toggleSelectMode,R.id.invertSelection,R.id.stickySelection};
        for(int i=0;i<resIds.length;i++) {
            if(lastcontselmode[i]) {
                View v = mainActivity.findViewById(resIds[i]);
                if(v!=null) v.performClick();
            }
        }
        PopupWindowUtils.toggleSoftKeyBoard(mainBrowserViews[position],false);
    }

    public void showDirContent(GenericDirWithContent dirWithContent,
                               int position,
                               @Nullable Object targetFilenameToHighlight) { // with filename comparator

        Collections.sort(dirWithContent.content,new FilenameComparator());

        currentDirectoryTextViews[position].setText(
                dirCommanders[position].getCurrentDirectoryPathname().toString());

        recreateAdapterAndSelectMode(browserViewModes[position],position,dirWithContent);
        mainBrowserViews[position].setAdapter(browserAdapters[position]);
        if (targetFilenameToHighlight != null) {
            if (targetFilenameToHighlight instanceof String) { // reposition listview with FindActivity locate
                int locatedPos = browserAdapters[position].findPositionByFilename((String)targetFilenameToHighlight);
                if (locatedPos < 0)
                    MainActivity.showToast("Unable to find file position in browser adapter");
                else {
                    setSelectionOnAbsListView(mainBrowserViews[position],locatedPos,position);
                }
            }
            else { // reposition listview after delete operation
                Integer locatedPos = (Integer)targetFilenameToHighlight;
                mainBrowserViews[position].setSelection(locatedPos);
            }
        }
        else { // reposition listview when going back in dir navigation
            mainBrowserViews[position].setSelection(dirWithContent.listViewPosition);
        }
        swipeRefreshLayouts[position].setRefreshing(false);
        mainActivity.quickPathsLayout.setVisibility(View.GONE); // close quick paths menu if open, once a showDirContent is complete
    }

    private final LinearLayout.LayoutParams onParams = new LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT);

    private void togglePaddingToMainBrowserView(int position, boolean enabled) {
        int measuredHeight = 0;
        // measure last item height
        if (enabled) {
            int nItems = browserAdapters[position].getCount();
            if(nItems > 0) {
                View item = browserAdapters[position].getView(nItems-1,null,mainBrowserViews[position]);
                item.measure(View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED),
                        View.MeasureSpec.makeMeasureSpec(0, View.MeasureSpec.UNSPECIFIED));
                measuredHeight = item.getMeasuredHeight()*3;
            }
        }

        mainBrowserViews[position].setPadding(0,0,0,measuredHeight);
        mainBrowserViews[position].setClipToPadding(!enabled);
        if (enabled) mainBrowserViews[position].setScrollBarStyle(View.SCROLLBARS_OUTSIDE_OVERLAY);
    }

    private void setMultiSelectModeLayout(boolean active, int position) {
        if (mainBrowserViewLayoutParents[position] != null && csLayouts[position] != null)
            mainBrowserViewLayoutParents[position].removeView(csLayouts[position]);

        if (active) {
            // TODO rootLayouts member must become RelativeLayout

            csCheckBoxes[position] = new CSCheckboxes();
            csListeners[position] = browserViewModes[position].buildCSListener(
                    mainBrowserViews[position],
                    browserAdapters[position],
                    browserAdapters[position].objects,
                    csCheckBoxes[position]
            );

            csLayouts[position] = new ContSelHandlingLayout(
                    mainActivity,
                    csListeners[position],
                    csCheckBoxes[position],
                    browserViewModes[position].isFullPadLayout()
            );

            mainBrowserViewLayoutParents[position].addView(csLayouts[position]);
        }

        togglePaddingToMainBrowserView(position,active);

        // reset swipe settings on BrowserViewPager
        if(!active)
            mainActivity.browserPager.swipeDisabled = false;
    }

    private final EditText[] quickFindEditTexts = new EditText[ADAPTER_SIZE];
    private final CheckedTextView[] quickFindIgnoreCases = new CheckedTextView[ADAPTER_SIZE];

    private void setQuickFindModeLayout(boolean active, int position) {
        final LayoutInflater inflater = LayoutInflater.from(mContext);

        // FIXME adjust layouts (inflated target does not fill screen horizontally)
        // TODO test also with visibility GONE instead of dynamic layout params
        quickFindModeLayouts[position] = rootLayouts[position].findViewById(R.id.quickFindModeLayout);
        quickFindModeLayouts[position].removeAllViews();

        if (active) {
            View targetLayout = inflater.inflate(R.layout.quickfind_edittext_layout,null);
            quickFindModeLayouts[position].setLayoutParams(onParams);
            quickFindModeLayouts[position].addView(targetLayout);

            quickFindEditTexts[position] = rootLayouts[position].findViewById(R.id.quickFindEditText);

            quickFindEditTexts[position].addTextChangedListener(new TextWatcher() {
                @Override
                public void beforeTextChanged(CharSequence s, int start, int count, int after) {}

                @Override
                public void onTextChanged(CharSequence s, int start, int before, int count) {
                    // reload filter results on every typed character
                    browserAdapters[position].filterObjects(s,quickFindIgnoreCases[position].isChecked());
                }

                @Override
                public void afterTextChanged(Editable s) {}
            });

            quickFindIgnoreCases[position] = rootLayouts[position].findViewById(R.id.quickFindIgnoreCase);
            quickFindIgnoreCases[position].setOnClickListener(v -> {
                quickFindIgnoreCases[position].toggle();
                browserAdapters[position].filterObjects(
                        quickFindEditTexts[position].getText(),
                        quickFindIgnoreCases[position].isChecked());
            });

            quickFindEditTexts[position].requestFocus();
        }
    }

    public final boolean[] multiSelectModes = new boolean[ADAPTER_SIZE];
    public void switchMultiSelectMode(int position) {
        multiSelectModes[position] = !multiSelectModes[position];
        setMultiSelectModeLayout(multiSelectModes[position],position);
    }

    public final boolean[] quickFindModes = new boolean[ADAPTER_SIZE];
    public void switchQuickFindMode(int position) {
        quickFindModes[position] = !quickFindModes[position];
        setQuickFindModeLayout(quickFindModes[position],position);
    }

    // use a method here, instead of inserting intermediate class between AbsListView and (ListView and GridView)
    public void setSelectionOnAbsListView(AbsListView absListView, int targetPos, int viewPagerPos) {
        absListView.setSelection(targetPos);
        MainActivity.handler.postDelayed(()-> Misc.highlightListViewItem(targetPos, mainBrowserViews[viewPagerPos]),250);
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/ContinuousSelectionAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.support.annotation.NonNull;
import android.util.Log;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.widget.AbsListView;
import android.widget.ArrayAdapter;

import java.util.List;

public abstract class ContinuousSelectionAdapter<T> extends ArrayAdapter<T> {

    protected final AbsListView lv; // indicate if select mode is active and needed to auto scroll, to be used with selection mode toggle performed separately (like in XFiles)
    protected final List<T> objects;
    protected final LayoutInflater inflater;

    public boolean active = false;

    public ContinuousSelectionAdapter(@NonNull Context context, int resource, AbsListView lv, List<T> objects) {
        super(context, resource, objects);
        this.objects = objects;
        this.lv = lv;
        inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    }

    public AbsListView getLv() {
        return lv;
    }

    // this is used by the listener
    public void startSelectMode(int startPos) {
        if (active) {
            Log.d("MOTION", "Repeated ACTION_DOWN events (multitouch?), ignoring...");
            return;
        }
        if (startPos < 0 || startPos >= objects.size()) return;
        active = true;
    }

    abstract void ongoingSelectMode(int position);
    abstract void endSelectMode(int endPos);

    public abstract boolean getInvSel();

    public final View.OnTouchListener listener = (v, ev) -> {
        Log.d("Motion", "Default: " + ev.getActionMasked() + " " + ev.getX() + " " + ev.getY());
        try {
            int ptoPos = getLv().pointToPosition((int) ev.getX(), (int) ev.getY());
            switch(ev.getActionMasked()) {
                case MotionEvent.ACTION_DOWN:
                    Log.d("MotionSTART", "Start select mode");
                    startSelectMode(ptoPos);
                    break;
                case MotionEvent.ACTION_UP:
                    Log.d("MotionEND", "End select mode");
                    endSelectMode(ptoPos);
                    break;
                case MotionEvent.ACTION_MOVE:
                    Log.d("MotionCONTINUE", "Ongoing select mode");
                    ongoingSelectMode(ptoPos);
                    break;
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        return true;
    };

}

```

`app/src/main/java/it/pgp/xfiles/adapters/ExtendedSimpleAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import java.util.List;
import java.util.Map;

import android.content.Context;
import android.graphics.Bitmap;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Checkable;
import android.widget.ImageView;
import android.widget.SimpleAdapter;
import android.widget.TextView;



public class ExtendedSimpleAdapter extends SimpleAdapter{
    private List<? extends Map<String, ?>> map; // if fails to compile, replace with List<HashMap<String, Object>> map
    private String[] from;
    private int layout;
    private int[] to;
    private Context context;
    private LayoutInflater mInflater;
    public ExtendedSimpleAdapter(Context context, List<? extends Map<String, ?>> data, // if fails to compile, do the same replacement as above on this line
                                 int resource, String[] from, int[] to) {
        super(context, data, resource, from, to);
        layout = resource;
        map = data;
        this.from = from;
        this.to = to;
        this.context = context;
    }


    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        return this.createViewFromResource(position, convertView, parent, layout);
    }

    private View createViewFromResource(int position, View convertView,
                                        ViewGroup parent, int resource) {
        View v;
        if (convertView == null) {
            v = mInflater.inflate(resource, parent, false);
        } else {
            v = convertView;
        }

        this.bindView(position, v);

        return v;
    }


    private void bindView(int position, View view) {
        final Map dataSet = map.get(position);
        if (dataSet == null) {
            return;
        }

        final ViewBinder binder = super.getViewBinder();
        final int count = to.length;

        for (int i = 0; i < count; i++) {
            final View v = view.findViewById(to[i]);
            if (v != null) {
                final Object data = dataSet.get(from[i]);
                String text = data == null ? "" : data.toString();
                if (text == null) {
                    text = "";
                }

                boolean bound = false;
                if (binder != null) {
                    bound = binder.setViewValue(v, data, text);
                }

                if (!bound) {
                    if (v instanceof Checkable) {
                        if (data instanceof Boolean) {
                            ((Checkable) v).setChecked((Boolean) data);
                        } else if (v instanceof TextView) {
                            // Note: keep the instanceof TextView check at the bottom of these
                            // ifs since a lot of views are TextViews (e.g. CheckBoxes).
                            setViewText((TextView) v, text);
                        } else {
                            throw new IllegalStateException(v.getClass().getName() +
                                    " should be bound to a Boolean, not a " +
                                    (data == null ? "<unknown type>" : data.getClass()));
                        }
                    } else if (v instanceof TextView) {
                        // Note: keep the instanceof TextView check at the bottom of these
                        // ifs since a lot of views are TextViews (e.g. CheckBoxes).
                        setViewText((TextView) v, text);
                    } else if (v instanceof ImageView) {
                        if (data instanceof Integer) {
                            setViewImage((ImageView) v, (Integer) data);
                        } else if (data instanceof Bitmap){
                            setViewImage((ImageView) v, (Bitmap)data);
                        } else {
                            setViewImage((ImageView) v, text);
                        }
                    } else {
                        throw new IllegalStateException(v.getClass().getName() + " is not a " +
                                " view that can be bounds by this SimpleAdapter");
                    }
                }
            }
        }
    }



    private void setViewImage(ImageView v, Bitmap bmp){
        v.setImageBitmap(bmp);
    }



}
```

`app/src/main/java/it/pgp/xfiles/adapters/ExtractResultsAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.support.annotation.Nullable;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.TextView;

import java.util.List;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class ExtractResultsAdapter extends BaseAdapter {
    private final Context context;
    private final LayoutInflater inflater;
    private final List<BasePathContent> srcArchives;
    private final List<FileOpsErrorCodes> results;

    public ExtractResultsAdapter(Context context, List<BasePathContent> srcArchives, List<FileOpsErrorCodes> results) {
        this.context = context;
        this.inflater = LayoutInflater.from(context);
        this.srcArchives = srcArchives;
        this.results = results;
    }

    public static class ExtractResultsViewHolder {
        public TextView srcArchive, result;

        ExtractResultsViewHolder(TextView srcArchive, TextView result) {
            this.srcArchive = srcArchive;
            this.result = result;
        }
    }

    @Override
    public int getCount() {
        return srcArchives.size();
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return position;
    }

    @Override
    public View getView(int position, @Nullable View convertView, ViewGroup parent) {
        TextView srcArchive, result;

        if(convertView == null) {
            convertView = inflater.inflate(R.layout.extract_results_item, null);

            srcArchive = convertView.findViewById(R.id.extract_results_srcArchive);
            result = convertView.findViewById(R.id.extract_results_result);

            convertView.setTag(new ExtractResultsAdapter.ExtractResultsViewHolder(srcArchive,result));
        }
        else {
            ExtractResultsAdapter.ExtractResultsViewHolder viewHolder = (ExtractResultsAdapter.ExtractResultsViewHolder) convertView.getTag();
            srcArchive = viewHolder.srcArchive;
            result = viewHolder.result;
        }

        srcArchive.setText(srcArchives.get(position).toString());
        FileOpsErrorCodes res = results.get(position);
        if(res==null) res = FileOpsErrorCodes.OK;
        result.setText(res.toString());
        result.setTextColor(context.getResources().getColor(res == FileOpsErrorCodes.OK ? R.color.green : R.color.red));

        return convertView;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/FavoritesPagerAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.support.v4.view.PagerAdapter;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.Button;
import android.widget.ListView;
import android.widget.Toast;

import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.InsertEditLocalFavoritesDialog;
import it.pgp.xfiles.dialogs.InsertEditXreFavoritesDialog;

/**
 * Created by pgp on 04/07/17
 */

public class FavoritesPagerAdapter extends PagerAdapter {

    private final Context context;

//    private final ProviderType[] allowedValues = new ProviderType[]{ProviderType.LOCAL,ProviderType.SFTP};
    private final int[] allowedLayouts = {R.layout.favorites_local,R.layout.favorites_sftp,R.layout.favorites_xfiles_remote,R.layout.favorites_smb};
    private final String[] titles = new String[]{"Local favorites","Sftp favorites","XFiles remote favorites", "SMB favorites"};

    // page one widgets
    private ListView localFavoritesListView; // mapped to "@+id/favorites_local_list"
    private LocalFavoritesAdapter localFavoritesAdapter;
    private InsertEditLocalFavoritesDialog insertLocalFavoritesDialog; // only for insert, edit mode called from within its adapter
    private Button localFavoritesAddButton;

    // page two widgets
    private ListView sftpFavoritesListView; // mapped to "@+id/favorites_sftp_list"
    private SftpFavoritesAdapter sftpFavoritesAdapter;

    // page three widgets
    private ListView xreFavoritesListView; // mapped to "@+id/favorites_xre_list"
    private XreFavoritesAdapter xreFavoritesAdapter;
    private InsertEditXreFavoritesDialog insertXreFavoritesDialog;
    private Button xreFavoritesAddButton;

    // page four widgets
    private ListView smbFavoritesListView; // mapped to "@+id/favorites_smb_list"
    private SmbFavoritesAdapter smbFavoritesAdapter;


    public FavoritesPagerAdapter(final Context context) {
        this.context = context;
    }

    @Override
    public Object instantiateItem(ViewGroup collection, int position) {
        LayoutInflater inflater = LayoutInflater.from(context);
        ViewGroup layout = (ViewGroup) inflater.inflate(allowedLayouts[position], collection, false);

        switch (position) {
            case 0: // local
                localFavoritesListView = layout.findViewById(R.id.favorites_local_list);
                localFavoritesAddButton = layout.findViewById(R.id.favorites_local_add_button);
                localFavoritesAddButton.setOnClickListener(v -> {
                    insertLocalFavoritesDialog = new InsertEditLocalFavoritesDialog(
                            context,localFavoritesAdapter);
                    insertLocalFavoritesDialog.show();
                });
                localFavoritesAdapter = new LocalFavoritesAdapter(context);
                localFavoritesListView.setAdapter(localFavoritesAdapter);
                break;

            case 1: // sftp
                sftpFavoritesListView = layout.findViewById(R.id.favorites_sftp_list);
                sftpFavoritesAdapter = new SftpFavoritesAdapter(context);
                sftpFavoritesListView.setAdapter(sftpFavoritesAdapter);
                sftpFavoritesListView.setEmptyView(layout.findViewById(R.id.favorites_sftp_list_empty_view));
                break;

            case 2: // xfiles_remote
                xreFavoritesListView = layout.findViewById(R.id.favorites_xre_list);
                xreFavoritesAddButton = layout.findViewById(R.id.favorites_xre_add_button);
                xreFavoritesAddButton.setOnClickListener(view -> {
                    insertXreFavoritesDialog = new InsertEditXreFavoritesDialog(
                            context,xreFavoritesAdapter);
                    insertXreFavoritesDialog.show();
                });
                xreFavoritesAdapter = new XreFavoritesAdapter(context);
                xreFavoritesListView.setAdapter(xreFavoritesAdapter);
                break;
            case 3: // smb
                smbFavoritesListView = layout.findViewById(R.id.favorites_smb_list);
                smbFavoritesAdapter = new SmbFavoritesAdapter(context);
                smbFavoritesListView.setAdapter(smbFavoritesAdapter);
                smbFavoritesListView.setEmptyView(layout.findViewById(R.id.favorites_smb_list_empty_view));
                break;
            default:
                Toast.makeText(context,"Position not available in the adapter",Toast.LENGTH_SHORT).show();
                throw new RuntimeException("Position not available in the adapter");
        }

        collection.addView(layout);
        return layout;
    }

    @Override
    public void destroyItem(ViewGroup collection, int position, Object view) {
        collection.removeView((View) view);
    }

    @Override
    public int getCount() {
        return allowedLayouts.length;
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {
        return view == object;
    }

    @Override
    public CharSequence getPageTitle(int position) {
        return titles[position];
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/FindResultsAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.support.annotation.NonNull;

import java.util.ArrayList;
import java.util.List;

import it.pgp.xfiles.FindActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Construction rationale behind asynchronous adapter (keeping state and surviving across activities-listviews instances, while preserving real-time notify requirements):
 * - Adapter is nullable singleton
 * - It is created using the first available activity reference, in order to perform add method via runOnUIThread
 * - Current activity instance is kept updated via static instance, and it is used for runOnUIThread;
 *   moreover, by construction the static instance is never null at the time runOnUIThread is invoked
 */

public class FindResultsAdapter extends BrowserListAdapter { // uses FindBrowserItem instead of BrowserItem

    public static FindResultsAdapter instance;

    public List<BasePathContent> basePaths; // base path from which search was started

    private FindResultsAdapter(@NonNull MainActivity mainActivity) {
//        super(context,android.R.layout.simple_list_item_1);
        super(mainActivity,new ArrayList<>());
    }

    public static synchronized void createIfNotExisting() {
        if (instance == null) {
            instance = new FindResultsAdapter(MainActivity.mainActivity);
        }
    }

    public static synchronized void reset(List<BasePathContent> basePaths) {
        createIfNotExisting();
        if(basePaths != null)
            instance.basePaths = basePaths;
        FindActivity.instance.runOnUiThread(()->FindResultsAdapter.instance.clear());
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/GalleryPagerAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.app.Activity;
import android.support.annotation.NonNull;
import android.support.v4.view.PagerAdapter;
import android.support.v7.widget.RecyclerView;
import android.view.GestureDetector;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.animation.AccelerateInterpolator;
import android.view.animation.DecelerateInterpolator;
import android.widget.HorizontalScrollView;
import android.widget.TextView;

import com.davemorrissey.labs.subscaleview.ImageSource;
import com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView;

import java.util.ArrayList;

import it.pgp.xfiles.R;


public class GalleryPagerAdapter extends PagerAdapter {

    private final boolean showOnlyCurrentImage;
    private Activity activity;
    private boolean isShowing = true;
    private HorizontalScrollView toolbar;
    private RecyclerView imagesHorizontalList;
    private ArrayList<String> imageList;

    public GalleryPagerAdapter(Activity activity, ArrayList<String> dataSet, HorizontalScrollView toolbar, RecyclerView imagesHorizontalList, boolean showOnlyCurrentImage) {
        this.activity = activity;
        this.imageList = dataSet;
        this.toolbar = toolbar;
        this.imagesHorizontalList = imagesHorizontalList;
        this.showOnlyCurrentImage = showOnlyCurrentImage;
    }

    @Override
    public int getCount() {
        return imageList.size();
    }

    @Override
    public boolean isViewFromObject(View view, Object object) {
        return view == object;
    }

    @Override
    public Object instantiateItem(ViewGroup container, int position) {
        View itemView = LayoutInflater.from(activity).inflate(R.layout.pager_item, container, false);
        SubsamplingScaleImageView imageView = itemView.findViewById(R.id.iv);
        imageView.setImage(ImageSource.uri(imageList.get(position)));
        TextView filename = itemView.findViewById(R.id.pager_item_filename);
        filename.setText(imageList.get(position));

        if(!showOnlyCurrentImage) {
            GestureDetector gestureDetector = new GestureDetector(activity, new GestureDetector.SimpleOnGestureListener() {
                @Override
                public boolean onSingleTapConfirmed(@NonNull MotionEvent e) {
                    if (isShowing) {
                        toolbar.animate().translationY(-toolbar.getBottom()).setInterpolator(new AccelerateInterpolator()).start();
                        imagesHorizontalList.animate().translationY(imagesHorizontalList.getBottom()).setInterpolator(new AccelerateInterpolator()).start();
                        filename.setVisibility(View.GONE);
                    } else {
                        toolbar.animate().translationY(0).setInterpolator(new DecelerateInterpolator()).start();
                        imagesHorizontalList.animate().translationY(0).setInterpolator(new DecelerateInterpolator()).start();
                        filename.setVisibility(View.VISIBLE);
                    }
                    isShowing = !isShowing;
                    return false;
                }
            });
            imageView.setOnTouchListener((view, motionEvent) -> gestureDetector.onTouchEvent(motionEvent));
        }

        container.addView(itemView);
        return itemView;
    }

    @Override
    public void destroyItem(ViewGroup container, int position, Object object) {
        container.removeView((View)object);
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/HashAlgorithmsAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.CheckedTextView;

import java.util.Arrays;
import java.util.LinkedHashSet;
import java.util.Set;

import it.pgp.xfiles.R;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;

public class HashAlgorithmsAdapter extends ArrayAdapter<HashRequestCodes> {

    public static class ViewHolder {
        public CheckedTextView ctv;

        ViewHolder(CheckedTextView ctv) {
            this.ctv = ctv;
        }
    }

    private final LayoutInflater inflater;
    private final Context context;

    public HashAlgorithmsAdapter(Context context) {
        super(context,
                R.layout.checksum_label_item,
                R.id.checksum_ctv,
                Arrays.asList(HashRequestCodes.values()));
        this.context = context;
        inflater = LayoutInflater.from(context);
    }

    @Override
    public View getView(int position, View convertView, ViewGroup parent) {
        HashRequestCodes item = getItem(position);
        CheckedTextView ctv;

        if(convertView == null) {
            convertView = inflater.inflate(R.layout.checksum_label_item, null);
            ctv = convertView.findViewById(R.id.checksum_ctv);
            ctv.setOnClickListener(v->{
                ctv.toggle();
                ((HashRequestCodes)ctv.getTag()).setChecked(ctv.isChecked());
            });
            convertView.setTag(new ViewHolder(ctv));
        }
        else {
            ctv = ((ViewHolder)convertView.getTag()).ctv;
        }

        ctv.setTag(item);

        ctv.setText(item.toString());
        ctv.setChecked(item.isChecked());
        ctv.setTextColor(context.getResources().getColor(item.getLabelColor()));

        return convertView;
    }

    @Override
    public int getCount() {
        return HashRequestCodes.values().length;
    }

    public Set<HashRequestCodes> getSelectedItems() {
        Set<HashRequestCodes> items = new LinkedHashSet<>();
        for(HashRequestCodes h: HashRequestCodes.values())
            if(h.isChecked()) items.add(h);
        return items;
    }
}
```

`app/src/main/java/it/pgp/xfiles/adapters/HorizontalListAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.graphics.ColorMatrix;
import android.graphics.ColorMatrixColorFilter;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageView;
import android.widget.TextView;

import com.tomclaw.imageloader.util.ImageViewHandlers;
import com.tomclaw.imageloader.util.ImageViews;

import java.io.File;
import java.util.ArrayList;

import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Misc;


public class HorizontalListAdapter extends RecyclerView.Adapter<HorizontalListAdapter.ViewHolder> {
    private final ArrayList<String> mDataset;
    private int mSelectedItem = -1;
    private final OnImgClick mClickListner;

    public HorizontalListAdapter(ArrayList<String> images, OnImgClick imgClick) {
        this.mDataset = images;
        this.mClickListner = imgClick;
    }

    @Override
    public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {
        return new ViewHolder(LayoutInflater.from(parent.getContext()).inflate(R.layout.item_image_horizontal, null));
    }

    @Override
    public void onBindViewHolder(final ViewHolder holder, final int position) {
        int blue = holder.image.getContext().getResources().getColor(R.color.transparentCobaltBlue);
        String o = mDataset.get(holder.getAdapterPosition());
        if(new File(o).exists() || Misc.isValidURL(o)) {
            ImageViews.fetch(holder.image, "file://"+o, handlers -> {
                ImageViewHandlers.centerCrop(handlers);
                ImageViewHandlers.withPlaceholder(handlers, R.drawable.ic_image);
                ImageViewHandlers.whenError(handlers, R.drawable.ic_image_remove, blue);
            });
        }
        else throw new RuntimeException("Not implemented");
        ColorMatrix matrix = new ColorMatrix();
        if (mSelectedItem != holder.getAdapterPosition()) {
            matrix.setSaturation(0);
            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(matrix);
            holder.image.setColorFilter(filter);
            holder.image.setAlpha(0.5f);
        } else {
            matrix.setSaturation(1);

            ColorMatrixColorFilter filter = new ColorMatrixColorFilter(matrix);
            holder.image.setColorFilter(filter);
            holder.image.setAlpha(1f);
        }
        holder.image.setOnClickListener(v->mClickListner.onClick(holder.getAdapterPosition()));
    }

    @Override
    public int getItemCount() {
        return mDataset.size();
    }

    public void setSelectedItem(int position) {
        if (position >= mDataset.size()) return;
        mSelectedItem = position;
        notifyDataSetChanged();
    }

    static class ViewHolder extends RecyclerView.ViewHolder {
        public ImageView image;
        public TextView filename;

        ViewHolder(View itemView) {
            super(itemView);
            image = itemView.findViewById(R.id.iv);
            filename = itemView.findViewById(R.id.pager_item_filename);
        }
    }

    public interface OnImgClick {
        void onClick(int pos);
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/LocalFavoritesAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.TextView;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.InsertEditLocalFavoritesDialog;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 04/07/17
 */

public class LocalFavoritesAdapter extends BaseAdapter implements ListAdapter {
    private final Context context;
    private ArrayList<String> localFavorites;
    private ArrayList<Long> dbIds;
    private GenericDBHelper dbh;

    LocalFavoritesAdapter(final Context context) {
        this.context = context;
        this.dbh = new GenericDBHelper(context);
        this.dbIds = new ArrayList<>();
        this.localFavorites = new ArrayList<>();

        Map<Long,String> lfDbMap;
        lfDbMap = dbh.getAllRowsOfLocalFavoritesTable();

        for (Map.Entry<Long,String> entry : lfDbMap.entrySet()) {
            dbIds.add(entry.getKey());
            localFavorites.add(entry.getValue());
        }
    }

    public void syncInsertFromDialog(Long oid, String u) {
        dbIds.add(oid);
        localFavorites.add(u);
        notifyDataSetChanged();
    }

    public void syncEditFromDialog(Long oldOid, Long newOid, String oldU, String newU) {
        // this code is safe because localFavorites cannot contain duplicates due to the primary key
        // constraint on the db table
        dbIds.remove(oldOid);
        localFavorites.remove(oldU);
        dbIds.add(newOid);
        localFavorites.add(newU);
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return dbIds.size();
    }

    @Override
    public String getItem(int position) {
        return localFavorites.get(position);
    }

    @Override
    public long getItemId(int position) {
        return dbIds.get(position);
    }

    @Override
    public View getView(final int position, final View convertView, ViewGroup parent) {
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            view = inflater.inflate(R.layout.favorites_local_list_item, null);
        }
        final String localPath = localFavorites.get(position);

        //Handle TextView and display string from your list
        TextView path = view.findViewById(R.id.favorites_local_list_item_path);
        path.setText(localPath);

        //Handle buttons and add onClickListeners
        ImageButton editBtn = view.findViewById(R.id.favorites_local_list_item_edit);
        ImageButton deleteBtn = view.findViewById(R.id.favorites_local_list_item_delete);

        editBtn.setOnClickListener(v -> new InsertEditLocalFavoritesDialog(
                context,
                LocalFavoritesAdapter.this,
                getItemId(position),
                getItem(position)).show());
        deleteBtn.setOnClickListener(v -> {
            // remove row from db
            boolean deleted = dbh.deleteRowFromLocalFavoritesTable(dbIds.get(position));
            if(deleted) {
                // remove row from localFavorites
                dbIds.remove(position);
                localFavorites.remove(position);
            }
            String message=deleted?"Deleted!":"Delete error";
            Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
            notifyDataSetChanged();
        });

        return view;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/OperationalPagerAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.support.annotation.NonNull;
import android.support.v4.view.PagerAdapter;
import android.support.v4.view.ViewPager;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.SelectImageButtonListener;

public class OperationalPagerAdapter extends PagerAdapter {

    private final MainActivity mainActivity;
    private final int[] operationalLayouts;
    private final SelectImageButtonListener l;

    public OperationalPagerAdapter(MainActivity mainActivity, int[] operationalLayouts) {
        this.mainActivity = mainActivity;
        this.operationalLayouts = operationalLayouts;
        this.l = new SelectImageButtonListener(this.mainActivity, R.color.imagebuttonselect);
    }

    @NonNull
    @Override
    public Object instantiateItem(@NonNull ViewGroup container, int position) {
        ViewPager viewPager = (ViewPager) container;
        ViewGroup layout = (ViewGroup) LayoutInflater.from(mainActivity).inflate(operationalLayouts[position], viewPager,false);
        viewPager.addView(layout);
        viewPager.setOnTouchListener((v, event) -> {
            if(event.getAction() == MotionEvent.ACTION_UP) {
                // the children listener might not catch the ACTION_UP event due to a too rapid swipe, so restore the involved ImageButton state from here
                if(l.startV != null) {
                    l.startV.getDrawable().clearColorFilter();
                    l.startV.invalidate();
                }
            }
            return false;
        });
        mainActivity.makeImageButtonsStateful(layout, l);
        return layout;
    }

    @Override
    public void destroyItem(@NonNull ViewGroup container, int position, @NonNull Object object) {
        container.removeView((View) object);
    }

    @Override
    public int getCount() {
        return operationalLayouts.length;
    }

    @Override
    public boolean isViewFromObject(@NonNull View view, @NonNull Object object) {
        return view==object;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/QuickPathsAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.os.Environment;
import android.widget.ArrayAdapter;

import java.util.ArrayList;
import java.util.Set;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.utils.DiskHelper;

// currently used for showing external mounts
// TODO to be generalized (e.g. show favorites and currently opened xre connections as well)
public class QuickPathsAdapter extends ArrayAdapter<String> {

    public static QuickPathsAdapter create(MainActivity context) {
        Set<String> s = DiskHelper.getExternalMounts(context);
        s.add(Environment.getExternalStorageDirectory().getAbsolutePath());
        return new QuickPathsAdapter(context, new ArrayList<>(s));
    }

    public ArrayList<String> objects;

    private QuickPathsAdapter(Context context, ArrayList<String> objects) {
        super(context, android.R.layout.simple_list_item_1, objects);
        this.objects = objects;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/RecentPositionsAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.content.res.Resources;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ArrayAdapter;
import android.widget.ListView;
import android.widget.PopupWindow;
import android.widget.Toast;

import java.util.List;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.DirCommander;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class RecentPositionsAdapter extends ArrayAdapter<Pair<Integer,BasePathContent>> {

    List<Pair<Integer, BasePathContent>> objects;

    public RecentPositionsAdapter(Context context, List<Pair<Integer, BasePathContent>> objects) {
        super(context, android.R.layout.simple_list_item_1, objects);
        this.objects = objects;
    }

    @Override
    public Pair<Integer, BasePathContent> getItem(int position) {
        return super.getItem(position);
    }

    public static void showPopup(MainActivity activity, boolean beforeOrAfterCurrentIndex, View anchor) {
        DirCommander dirCommander = activity.getCurrentDirCommander();
        List<Pair<Integer, BasePathContent>> objects = dirCommander.splitPositions(beforeOrAfterCurrentIndex);
        if(objects.isEmpty()) {
            Toast.makeText(activity, "No items in commander for the specified direction", Toast.LENGTH_SHORT).show();
            return;
        }
        RecentPositionsAdapter a = new RecentPositionsAdapter(activity, objects);
        LayoutInflater layoutInflater = (LayoutInflater) activity.getBaseContext().getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        View popupView = layoutInflater.inflate(R.layout.dircommander_popup_window, null);
        ListView dircommander_positions = popupView.findViewById(R.id.dircommander_positions);
        dircommander_positions.setAdapter(a);
        popupView.measure(View.MeasureSpec.UNSPECIFIED, View.MeasureSpec.UNSPECIFIED);
        PopupWindow window = new PopupWindow(popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);
        dircommander_positions.setOnItemClickListener((parent, view, position, id) -> {
            activity.goDir_async(a.getItem(position).i - dirCommander.currentIndex,null);
            window.dismiss();
        });
        window.setFocusable(true); // in order to dismiss when clicked outside
        window.showAtLocation(anchor,Gravity.TOP|(beforeOrAfterCurrentIndex ? Gravity.END : Gravity.START), 0,
                Resources.getSystem().getDisplayMetrics().heightPixels-anchor.getHeight()-popupView.getHeight());
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/SftpFavoritesAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;

import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.InsertEditSftpFavoritesDialog;
import it.pgp.xfiles.sftpclient.AuthData;
import it.pgp.xfiles.smbclient.SmbAuthData;
import it.pgp.xfiles.utils.FavoritesList;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 04/07/17
 *
 * web sources for multiple-kind-of-row listview:
 *  - http://stackoverflow.com/questions/4777272/android-listview-with-different-layouts-for-each-row
 *  - http://android.amberfog.com/?p=296
 */

public class SftpFavoritesAdapter extends BaseAdapter {
    public static final int HEADER_TYPE = 0;
    public static final int CONTENT_TYPE = 1;

    final Context context;

    ArrayList<Object> adapterItems; // objects can be (Smb)AuthData (header) or String (content)
    ArrayList<Long> adapterDbIds;

    TreeMap<Long, FavoritesList> sfDbMap; // for preserving explicit position ordering

    GenericDBHelper dbh;

    protected void refillArrays() {
        adapterDbIds = new ArrayList<>();
        adapterItems = new ArrayList<>();
        notifyDataSetChanged(); // this additional notify is needed for making edit mode working (on edit, number of items remains the same, and since positions are not changed as well, observers of base adapter wouldn't notice the difference, leaving old values in the views)
        for (Map.Entry<Long,FavoritesList>  entry : sfDbMap.entrySet()) {
            adapterDbIds.add(entry.getKey());
            adapterItems.add(entry.getValue().a); // add header

            for (String path : ((FavoritesList<AuthData>)(entry.getValue())).paths) {
                adapterDbIds.add(entry.getKey());
                adapterItems.add(path); // add content
            }
        }
        notifyDataSetChanged();
    }

    public SftpFavoritesAdapter(final Context context) {
        this.context = context;
        this.dbh = new GenericDBHelper(context);

        init();
    }

    protected void init() {
        sfDbMap = new TreeMap<>(dbh.getAllCredsWithFavs(AuthData.ref));
        refillArrays();
    }

    // only edit here, every favorite insert/add/update is an update to the FavoritesList bean
    public void syncEditFromDialog() {
        refillArrays(); // inefficient, but avoids passing delta params for updating views
//        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return adapterItems.size();
    }

    @Override
    public int getViewTypeCount() {
        return 2; // allowed types: header and content
    }

    @Override
    public int getItemViewType(int position) {
        Object o = adapterItems.get(position);

        if (o instanceof AuthData || o instanceof SmbAuthData) return HEADER_TYPE;
        else if (o instanceof String) return CONTENT_TYPE;
        else throw new RuntimeException("Unexpected adapter item type");
    }

    @Override
    public Object getItem(int position) {
        return adapterItems.get(position);
    }

    @Override
    public long getItemId(int position) {
        return adapterDbIds.get(position);
    }

    @Override
    public View getView(final int position, final View convertView, ViewGroup parent) {
        // list item can be of two types: header or content
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            if (getItemViewType(position) == HEADER_TYPE) {
                view = inflater.inflate(R.layout.sftp_list_header_item, null);
                TextView user = view.findViewById(R.id.sftp_listitem_user);
                TextView domain = view.findViewById(R.id.sftp_listitem_domain);
                TextView port = view.findViewById(R.id.sftp_listitem_port);
                ImageButton addButton = view.findViewById(R.id.sftp_add_favorite_button);
                user.setText(((AuthData)getItem(position)).username);
                domain.setText(((AuthData)getItem(position)).domain);
                port.setText(((AuthData)getItem(position)).port+"");
                addButton.setOnClickListener(v -> {
                    // insert mode
                    new InsertEditSftpFavoritesDialog(
                            AuthData.ref,
                            context,
                            SftpFavoritesAdapter.this,
                            getItemId(position),
                            sfDbMap.get(getItemId(position)),
                            null).show();
                });
            }
            else { // CONTENT_TYPE
                view = inflater.inflate(R.layout.favorites_local_list_item, null);
                TextView path = view.findViewById(R.id.favorites_local_list_item_path);

                path.setText((String)getItem(position));

                //Handle buttons and add onClickListeners
                ImageButton editBtn = view.findViewById(R.id.favorites_local_list_item_edit);
                ImageButton deleteBtn = view.findViewById(R.id.favorites_local_list_item_delete);

                editBtn.setOnClickListener(v -> {
                    // edit mode
                    new InsertEditSftpFavoritesDialog(
                            AuthData.ref,
                            context,
                            SftpFavoritesAdapter.this,
                            getItemId(position),
                            sfDbMap.get(getItemId(position)),
                            (String) getItem(position)).show();
                });
                deleteBtn.setOnClickListener(v -> {
                    // remove row from db
                    FavoritesList<AuthData> currentFavorites = sfDbMap.get(getItemId(position));
                    currentFavorites.paths.remove(getItem(position));

                    // update only, leave oid unchanged
//                    if (dbh.updateSftpFavs(getItemId(position),currentFavorites.paths)) {
                    if (dbh.updateFavs(AuthData.ref,getItemId(position),currentFavorites.paths)) {
                        // update visualization
                        // sfdbMap is updated from here, no need to pass params
                        syncEditFromDialog();
                        Toast.makeText(context,"Edit successful",Toast.LENGTH_SHORT).show();
                    }
                    else {
                        Toast.makeText(context,"Edit failed",Toast.LENGTH_SHORT).show();
                    }
                });
            }
            // no need to perform offensive coding here, getItemViewType already throws RuntimeException
        }

        return view;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/SmbFavoritesAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;

import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.InsertEditSftpFavoritesDialog;
import it.pgp.xfiles.smbclient.SmbAuthData;
import it.pgp.xfiles.utils.FavoritesList;

public class SmbFavoritesAdapter extends SftpFavoritesAdapter {
    public SmbFavoritesAdapter(Context context) {
        super(context);
    }

    @Override
    protected void init() {
        sfDbMap = new TreeMap<>(dbh.getAllCredsWithFavs(SmbAuthData.ref));
        refillArrays();
    }

    @Override
    protected void refillArrays() {
        adapterDbIds = new ArrayList<>();
        adapterItems = new ArrayList<>();
        notifyDataSetChanged(); // this additional notify is needed for making edit mode working (on edit, number of items remains the same, and since positions are not changed as well, observers of base adapter wouldn't notice the difference, leaving old values in the views)
        for (Map.Entry<Long,FavoritesList>  entry : sfDbMap.entrySet()) {
            adapterDbIds.add(entry.getKey());
            adapterItems.add(entry.getValue().a); // add header

            for (String path : ((FavoritesList<SmbAuthData>)(entry.getValue())).paths) {
                adapterDbIds.add(entry.getKey());
                adapterItems.add(path); // add content
            }
        }
        notifyDataSetChanged();
    }

    @Override
    public View getView(final int position, final View convertView, ViewGroup parent) {
        // list item can be of two types: header or content
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            if (getItemViewType(position) == HEADER_TYPE) {
                view = inflater.inflate(R.layout.smb_list_header_item, null);
                TextView user = view.findViewById(R.id.smb_listitem_user);
                TextView domain = view.findViewById(R.id.smb_listitem_domain);
                TextView host = view.findViewById(R.id.smb_listitem_host);
                TextView port = view.findViewById(R.id.smb_listitem_port);
                ImageButton addButton = view.findViewById(R.id.smb_add_favorite_button);
                user.setText(((SmbAuthData)getItem(position)).username);
                domain.setText(((SmbAuthData)getItem(position)).domain);
                host.setText(((SmbAuthData)getItem(position)).host);
                port.setText(((SmbAuthData)getItem(position)).port+"");
                addButton.setOnClickListener(v -> {
                    // insert mode
                    new InsertEditSftpFavoritesDialog(
                            SmbAuthData.ref,
                            context,
                            SmbFavoritesAdapter.this,
                            getItemId(position),
                            sfDbMap.get(getItemId(position)),
                            null).show();
                });
            }
            else { // CONTENT_TYPE
                view = inflater.inflate(R.layout.favorites_local_list_item, null);
                TextView path = view.findViewById(R.id.favorites_local_list_item_path);

                path.setText((String)getItem(position));

                //Handle buttons and add onClickListeners
                ImageButton editBtn = view.findViewById(R.id.favorites_local_list_item_edit);
                ImageButton deleteBtn = view.findViewById(R.id.favorites_local_list_item_delete);

                editBtn.setOnClickListener(v -> {
                    // edit mode
                    new InsertEditSftpFavoritesDialog(
                            SmbAuthData.ref,
                            context,
                            SmbFavoritesAdapter.this,
                            getItemId(position),
                            sfDbMap.get(getItemId(position)),
                            (String) getItem(position)).show();
                });
                deleteBtn.setOnClickListener(v -> {
                    // remove row from db
                    FavoritesList<SmbAuthData> currentFavorites = sfDbMap.get(getItemId(position));
                    currentFavorites.paths.remove(getItem(position));

                    // update only, leave oid unchanged
//                    if (dbh.updateSftpFavs(getItemId(position),currentFavorites.paths)) {
                    if (dbh.updateFavs(SmbAuthData.ref,getItemId(position),currentFavorites.paths)) {
                        // update visualization
                        // sfdbMap is updated from here, no need to pass params
                        syncEditFromDialog();
                        Toast.makeText(context,"Edit successful",Toast.LENGTH_SHORT).show();
                    }
                    else {
                        Toast.makeText(context,"Edit failed",Toast.LENGTH_SHORT).show();
                    }
                });
            }
            // no need to perform offensive coding here, getItemViewType already throws RuntimeException
        }

        return view;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/XFilesRemoteEndpointAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.app.Activity;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageButton;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Map;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.roothelperclient.RHSSServerStatus;
import it.pgp.xfiles.roothelperclient.RemoteManager;
import it.pgp.xfiles.roothelperclient.RemoteServerManager;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

/**
 * Created by pgp on 27/10/17
 */

public class XFilesRemoteEndpointAdapter extends BaseAdapter {

    final Activity context;

    private final ArrayList<String> addresses = new ArrayList<>();

    /*
     if true, loads and updates adapter status from RHSSServerStatus,
     else from static RemoteClientManager in MainActivity
     */
    private final boolean serverMode;

    private void fillAdapter() {
        addresses.clear();
        if (serverMode) {
            if (RemoteServerManager.rhssManagerRef.get()!=null) {
                addresses.addAll(RHSSServerStatus.StoCSessions.keySet());
            }
        }
        else {
            for (Map.Entry<String,RemoteManager> entry :
                    MainActivity.rootHelperRemoteClientManager.fastClients.entrySet()) {
                addresses.add("F_"+entry.getKey());
            }
            // long term sessions
            for (Map.Entry<String,RemoteManager> entry :
                    MainActivity.rootHelperRemoteClientManager.longTermClients.entrySet()) {
                addresses.add("LT_"+entry.getKey());
            }
        }
    }

    public XFilesRemoteEndpointAdapter(final Activity context, boolean serverMode) {
        this.context = context;
        this.serverMode = serverMode;
        fillAdapter();
    }

    // (legacy comment for StoC sessions)
    // rhss update thread modifies serverSessionData, then calls syncFromActivity
    // map reference to serverSessionData is always the same, just reload array from map

    public void syncFromActivity() {
        fillAdapter();
        context.runOnUiThread(this::notifyDataSetChanged);
    }

    @Override
    public int getCount() {
        return addresses.size();
    }

    @Override
    public String getItem(int i) {
        return addresses.get(i);
    }

    @Override
    public long getItemId(int i) {
        return i;
    }

    @Override
    public View getView(int i, View convertView, ViewGroup viewGroup) {
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            view = inflater.inflate(R.layout.rhss_server_sessions_item, null);

            TextView clientIPandPort = view.findViewById(R.id.rhss_session_endpoint_IP_and_port);

            ImageButton endpointInfo = view.findViewById(R.id.rhss_session_endpoint_info);

            endpointInfo.setOnClickListener(v -> {
                byte[] sessionHash;
                String endpoint = getItem(i);
                if (serverMode) sessionHash = RHSSServerStatus.StoCSessions.get(endpoint);
                else {
                     if (endpoint.startsWith("F_")) {
                         endpoint = endpoint.replace("F_","");
                         sessionHash = MainActivity.rootHelperRemoteClientManager.fastClients.get(endpoint).tlsSessionHash;
                     }
                     else if (endpoint.startsWith("LT_")) {
                         endpoint = endpoint.replace("LT_","");
                         sessionHash = MainActivity.rootHelperRemoteClientManager.longTermClients.get(endpoint).tlsSessionHash;
                     }
                     else throw new RuntimeException("Unexpected prefix for remote client session");
                }

                // also show visual hash dialog
                // new HashViewDialog(context,sessionHash,false).show();
                PopupWindowUtils.createAndShowHashViewCommon(context,sessionHash,false,endpointInfo);
            });

//            ImageButton clientDisconnect = view.findViewById(R.id.rhss_server_session_client_disconnect);

            clientIPandPort.setText(getItem(i));
        }
        return view;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/XreAnnouncesAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.widget.ArrayAdapter;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.TreeSet;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.utils.Pair;

public class XreAnnouncesAdapter extends ArrayAdapter<Pair<String,String>> {

    public final Set<Pair<String,String>> support = new TreeSet<>();
    public final List<Pair<String,String>> items;

    protected XreAnnouncesAdapter(Context context, List<Pair<String,String>> items) {
        super(context, android.R.layout.simple_spinner_dropdown_item, items);
        this.items = items; // ugly workaround, cannot assign local variable before super() call
        this.support.addAll(items);
    }

    public static XreAnnouncesAdapter from(Context context) {
        return new XreAnnouncesAdapter(context, new ArrayList<>());
    }

    // not for announced hosts, but for already connected ones
    public static XreAnnouncesAdapter fromAlreadyOpenedConnections(Context context) {
        List<Pair<String,String>> items = new ArrayList<>();
        Set<String> hosts = new HashSet<>(MainActivity.rootHelperRemoteClientManager.fastClients.keySet());
        hosts.addAll(MainActivity.rootHelperRemoteClientManager.longTermClients.keySet());
        for(String h : hosts)
            items.add(new Pair<>(h,""));
        return new XreAnnouncesAdapter(context, items);
    }

    // accumulates indefinitely till dialog dismiss, irrespective of the fact that a XRE server may have stopped announcing itself
    @Override
    public void add(Pair<String, String> object) {
        if(support.contains(object)) return;
        support.add(object);
        items.clear();
        items.addAll(support);
        notifyDataSetChanged();
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/XreFavoritesAdapter.java`:

```java
package it.pgp.xfiles.adapters;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.TextView;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.InsertEditXreFavoritesDialog;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 22/09/17
 */

public class XreFavoritesAdapter extends BaseAdapter implements ListAdapter {
    private final Context context;
    private ArrayList<String> xreFavoriteServers;
    private ArrayList<String> xreFavoritePaths;
    private ArrayList<Long> dbIds;
    private GenericDBHelper dbh;

    XreFavoritesAdapter(final Context context) {
        this.context = context;
        this.dbh = new GenericDBHelper(context);
        this.dbIds = new ArrayList<>();
        this.xreFavoriteServers = new ArrayList<>();
        this.xreFavoritePaths = new ArrayList<>();

        Map<Long,Map.Entry<String,String>> lfDbMap;
        lfDbMap = dbh.getAllRowsOfXreFavoritesTable();

        for (Map.Entry<Long,Map.Entry<String,String>> entry : lfDbMap.entrySet()) {
            dbIds.add(entry.getKey());
            xreFavoriteServers.add(entry.getValue().getKey());
            xreFavoritePaths.add(entry.getValue().getValue());
        }
    }

    public void syncInsertFromDialog(Long oid, String server, String path) {
        dbIds.add(oid);
        xreFavoriteServers.add(server);
        xreFavoritePaths.add(path);
        notifyDataSetChanged();
    }

    public void syncEditFromDialog(Long oldOid,
                                   Long newOid,
                                   String oldServer,
                                   String newServer,
                                   String oldPath,
                                   String newPath) {
        // this code is safe because xreFavorites cannot contain duplicates due to the primary key
        // constraint on the db table
        dbIds.remove(oldOid);
        xreFavoriteServers.remove(oldServer);
        xreFavoritePaths.remove(oldPath);
        dbIds.add(newOid);
        xreFavoriteServers.add(newServer);
        xreFavoritePaths.add(newPath);
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return dbIds.size();
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return dbIds.get(position);
    }

    @Override
    public View getView(final int position, final View convertView, ViewGroup parent) {
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            view = inflater.inflate(R.layout.favorites_xre_list_item, null);
        }
        final String xreServer = xreFavoriteServers.get(position);
        final String xrePath = xreFavoritePaths.get(position);

        //Handle TextView and display string from your list
        TextView server = view.findViewById(R.id.favorites_xre_list_item_server);
        TextView path = view.findViewById(R.id.favorites_xre_list_item_path);
        server.setText(xreServer);
        path.setText(xrePath);

        //Handle buttons and add onClickListeners
        ImageButton editBtn = view.findViewById(R.id.favorites_xre_list_item_edit);
        ImageButton deleteBtn = view.findViewById(R.id.favorites_xre_list_item_delete);

        editBtn.setOnClickListener(v -> new InsertEditXreFavoritesDialog(
                context,
                XreFavoritesAdapter.this,
                getItemId(position),
                xreFavoriteServers.get(position),
                xreFavoritePaths.get(position)).show());
        deleteBtn.setOnClickListener(v -> {
            // remove row from db
            boolean deleted = dbh.deleteRowFromXreFavoritesTable(dbIds.get(position));
            if(deleted) {
                // remove row
                dbIds.remove(position);
                xreFavoriteServers.remove(position);
                xreFavoritePaths.remove(position);
            }
            String message=deleted?"Deleted!":"Delete error";
            Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
            notifyDataSetChanged();
        });

        return view;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/continuousselection/CSCheckboxes.java`:

```java
package it.pgp.xfiles.adapters.continuousselection;

import android.widget.CheckedTextView;

import it.pgp.xfiles.utils.Misc;

public class CSCheckboxes {
    public CheckedTextView continuousSelection; // governs the visibility of the other two checkboxes
    public CheckedTextView invertSelection;
    public CheckedTextView stickySelection;

    public CheckedTextView getContinuousSelection() {
        return continuousSelection;
    }

    public void setContinuousSelection(CheckedTextView continuousSelection) {
        this.continuousSelection = continuousSelection;
//        this.continuousSelection.setOnClickListener(Misc.ctvListener); // already done in method toggleSelStatus of ContSelHandlingLayout
    }

    public CheckedTextView getInvertSelection() {
        return invertSelection;
    }

    public void setInvertSelection(CheckedTextView invertSelection) {
        this.invertSelection = invertSelection;
        this.invertSelection.setOnClickListener(Misc.ctvListener);
    }

    public CheckedTextView getStickySelection() {
        return stickySelection;
    }

    public void setStickySelection(CheckedTextView stickySelection) {
        this.stickySelection = stickySelection;
        this.stickySelection.setOnClickListener(Misc.ctvListener);
    }

    public boolean[] getAsBooleans() {
        return new boolean[]{
                continuousSelection != null && continuousSelection.isChecked(),
                invertSelection != null && invertSelection.isChecked(),
                stickySelection != null && stickySelection.isChecked()
        };
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/continuousselection/ContSelHandlingLayout.java`:

```java
package it.pgp.xfiles.adapters.continuousselection;

import android.view.View;
import android.widget.CheckedTextView;
import android.widget.LinearLayout;
import android.widget.RelativeLayout;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;

public class ContSelHandlingLayout extends RelativeLayout {

    public final MainActivity mainActivity;
    public final OnTouchListener listener;

    public LinearLayout barLayout;
    public LinearLayout padLayout;

    // params to be used for listview
    static final LayoutParams lvParams = new RelativeLayout.LayoutParams(
            200,
            LayoutParams.MATCH_PARENT){{
       addRule(ALIGN_PARENT_END);
    }};

    static final LayoutParams gvParams = new RelativeLayout.LayoutParams(
            LayoutParams.MATCH_PARENT,
            LayoutParams.MATCH_PARENT
    );

    public final CSCheckboxes csCheckboxes; // to break cyclic dependency

    public boolean selStatus;
    public void toggleSelStatus(View v) {
        ((CheckedTextView)v).toggle();
        selStatus = !selStatus;
        padLayout.setVisibility(selStatus?VISIBLE:GONE);
        if(selStatus) barLayout.bringToFront();
        mainActivity.browserPager.switchNeutralArea();
    }

    public ContSelHandlingLayout(MainActivity context, OnTouchListener listener, CSCheckboxes csCheckboxes, boolean fullScreenPadLayout) {
        super(context);
        mainActivity = context;
        this.listener = listener;
        this.csCheckboxes = csCheckboxes;

        inflate(context,R.layout.cont_sel,this);

        csCheckboxes.setContinuousSelection(findViewById(R.id.toggleSelectMode));
        csCheckboxes.setInvertSelection(findViewById(R.id.invertSelection));
        csCheckboxes.setStickySelection(findViewById(R.id.stickySelection));

        barLayout = findViewById(R.id.barLayout);
        padLayout = findViewById(R.id.padLayout);
        if (!fullScreenPadLayout) {
            padLayout.setLayoutParams(lvParams);

        }
        padLayout.setOnTouchListener(listener);
        csCheckboxes.getContinuousSelection().setOnClickListener(this::toggleSelStatus);
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/continuousselection/ContSelListener.java`:

```java
package it.pgp.xfiles.adapters.continuousselection;

import android.util.Log;
import android.view.MotionEvent;
import android.view.View;
import android.view.View.OnTouchListener;
import android.widget.AbsListView;
import android.widget.ArrayAdapter;
import android.widget.Checkable;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

public abstract class ContSelListener implements OnTouchListener {

    protected final AbsListView lv;
    protected final ArrayAdapter adapter;
    protected final List<? extends Checkable> objects; // adapter objects
    protected final CSCheckboxes csCheckboxes;

    public boolean active = false;

    protected boolean atLeastOneMoveAfterDown = false;

    public ContSelListener(AbsListView lv, ArrayAdapter adapter, List<? extends Checkable> objects, CSCheckboxes csCheckboxes) {
        this.lv = lv;
        this.adapter = adapter;
        this.objects = objects;
        this.csCheckboxes = csCheckboxes;
    }

    public AbsListView getLv() {
        return lv;
    }

    protected boolean destCheckStatus = true;
    protected final Set<Integer> selectionBeforeStart = new HashSet<>();
    protected void fillSelectionBeforeStart() {
        selectionBeforeStart.clear();
        if (!getStickySel()) {
            setAllSelection(getInvSel());
        }
        else {
            for (int ii=0;ii<objects.size();ii++) {
                if (objects.get(ii).isChecked() == destCheckStatus)
                    selectionBeforeStart.add(ii);
            }
        }
    }

    // this is used by the listener
    public void startSelectMode(int startPos) {
        if (active) {
            Log.d("MOTION", "Repeated ACTION_DOWN events (multitouch?), ignoring...");
            return;
        }
        if (startPos < 0 || startPos >= objects.size()) return;
        active = true;
    }

    abstract void ongoingSelectMode(int position);
    abstract void endSelectMode(int endPos);

    public void toggleSelectOne(int position) {
        objects.get(position).toggle();
        adapter.notifyDataSetChanged();
    }

    public void setAllSelection(boolean checked) {
        for (Checkable i : objects)
            i.setChecked(checked);
        adapter.notifyDataSetChanged();
    }

    public boolean getInvSel() {
        return csCheckboxes.getInvertSelection().isChecked();
    }

    public boolean getStickySel() {
        return csCheckboxes.getStickySelection().isChecked();
    }


    @Override
    public boolean onTouch(View v, MotionEvent ev) {
        Log.d("Motion", "Default: " + ev.getActionMasked() + " " + ev.getX() + " " + ev.getY());
        try {
            int ptoPos = getLv().pointToPosition((int) ev.getX(), (int) ev.getY());
            switch(ev.getActionMasked()) {
                case MotionEvent.ACTION_DOWN:
                    Log.d("MotionSTART", "Start select mode");
                    startSelectMode(ptoPos);
                    break;
                case MotionEvent.ACTION_UP:
                    Log.d("MotionEND", "End select mode");
                    endSelectMode(ptoPos);
                    break;
                case MotionEvent.ACTION_MOVE:
                    Log.d("MotionCONTINUE", "Ongoing select mode");
                    ongoingSelectMode(ptoPos);
                    break;
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        return true;
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/continuousselection/ContSelListenerGrid.java`:

```java
package it.pgp.xfiles.adapters.continuousselection;

import android.util.Log;
import android.widget.AbsListView;
import android.widget.ArrayAdapter;
import android.widget.Checkable;
import android.widget.GridView;

import java.util.List;

import it.pgp.xfiles.utils.Pair;

public class ContSelListenerGrid extends ContSelListener {

    private static Pair<Integer,Integer> intToPoint(int h, int colsInRow) {
        if (h < 0) return new Pair<>(-1,-1); // convention for error-code return style
        return new Pair<>(h / colsInRow, h % colsInRow);
    }

    private static int pointToInt(Pair<Integer, Integer> p, int colsInRow) {
        if (p.i < 0 || p.j < 0) return -1; // convention for error-code return style
        return p.i*colsInRow + p.j;
    }

    private int colsInRow;

    // for select-on-move mode
    private final Pair<Integer,Integer> p_1 = new Pair<>(-1,-1); // last selected index

    private final Pair<Integer,Integer> startPos = new Pair<>(-1,-1);

    public ContSelListenerGrid(AbsListView lv, ArrayAdapter adapter, List<? extends Checkable> objects, CSCheckboxes csCheckboxes) {
        super(lv, adapter, objects, csCheckboxes);
    }

    @Override
    public void startSelectMode(int startPos) {
        super.startSelectMode(startPos);
        colsInRow = ((GridView)getLv()).getNumColumns();
        Log.d("ContSelMode", "colNum: "+colsInRow);
        this.startPos.set(intToPoint(startPos,colsInRow));
        destCheckStatus = !getInvSel();
        fillSelectionBeforeStart();

        objects.get(startPos).setChecked(destCheckStatus);
        adapter.notifyDataSetChanged();
    }

    // restart from initially selected items on each action move
    private void startFromInitialSelection() {
        for (int i=0;i<objects.size();i++)
            if (!selectionBeforeStart.contains(i))
                objects.get(i).setChecked(getInvSel());
    }

    @Override
    public void ongoingSelectMode(int position_) {
        if (position_ < 0 || position_ >= objects.size() || position_ == pointToInt(p_1,colsInRow)) return;

        Log.d("ContSelMode", "Abs: "+position_+" p_1: "+p_1+"p_1_flat: "+pointToInt(p_1,colsInRow));

        atLeastOneMoveAfterDown = true;
        startFromInitialSelection();
        final Pair<Integer,Integer> position = intToPoint(position_,colsInRow);
        p_1.set(position);

        int minx,miny,maxx,maxy;
        minx = startPos.i<position.i?startPos.i:position.i;
        miny = startPos.j<position.j?startPos.j:position.j;
        maxx = startPos.i>position.i?startPos.i:position.i;
        maxy = startPos.j>position.j?startPos.j:position.j;

        boolean checked = !getInvSel();
        for (int i=minx;i<=maxx;i++)
            for (int j=miny;j<=maxy;j++)
                objects.get(i*colsInRow+j).setChecked(checked);
        adapter.notifyDataSetChanged();
    }

    @Override
    public void endSelectMode(int endPos) {
        Log.d("SelectModeEnd", "SelectModeEnd");
        if (!active) {
            Log.d("MOTION", "Repeated ACTION_UP events (multitouch?), ignoring...");
            return;
        }
        if (startPos.equals(intToPoint(endPos,colsInRow)) && !atLeastOneMoveAfterDown) {
            if (!selectionBeforeStart.contains(endPos)) {
                objects.get(endPos).setChecked(!destCheckStatus);
            }
        }

        selectionBeforeStart.clear();
        p_1.set(-1,-1);
        active = false;
        atLeastOneMoveAfterDown = false;
        adapter.notifyDataSetChanged();
    }
}

```

`app/src/main/java/it/pgp/xfiles/adapters/continuousselection/ContSelListenerList.java`:

```java
package it.pgp.xfiles.adapters.continuousselection;

import android.util.Log;
import android.widget.AbsListView;
import android.widget.ArrayAdapter;
import android.widget.Checkable;

import java.util.List;

public class ContSelListenerList extends ContSelListener {

    // for continuous selection mode
    private int idx_2 = -1; // before last selected index
    private int idx_1 = -1; // last selected index

    private boolean initialDestCheckStatus;

    private int startPos;


    public ContSelListenerList(AbsListView lv, ArrayAdapter adapter, List<? extends Checkable> objects, CSCheckboxes csCheckboxes) {
        super(lv, adapter, objects, csCheckboxes);
    }

    @Override
    public void startSelectMode(int startPos) {
        super.startSelectMode(startPos);
        this.startPos = startPos;
        destCheckStatus = initialDestCheckStatus = !getInvSel();
        fillSelectionBeforeStart();

        objects.get(startPos).setChecked(destCheckStatus);
        adapter.notifyDataSetChanged();
    }

    @Override
    public void ongoingSelectMode(int position) {
        Log.d("POSITION", "Current: "+position+" Previous: "+idx_1+" Old: "+idx_2);
        if (position < 0 || position >= objects.size() || position == idx_1) return;
        Log.d("ContSelMode", "ContSelMode");

        atLeastOneMoveAfterDown = true;

        if (position == startPos && idx_1 >= 0) { // returned to startPos after having left it
            destCheckStatus = initialDestCheckStatus;
            if (!selectionBeforeStart.contains(idx_1)) {
                objects.get(idx_1).setChecked(!destCheckStatus);
            }
            if (idx_2 >= 0 && !selectionBeforeStart.contains(idx_2)) {
                objects.get(idx_2).setChecked(!destCheckStatus);
            }
            idx_1 = -1;
            idx_2 = -1;
            return;
        }

        if (position != idx_1) {
            if (position == idx_2) { // direction inverted, deselect previous
                destCheckStatus = !destCheckStatus;
                if (!selectionBeforeStart.contains(idx_1)) {
                    objects.get(idx_1).setChecked(destCheckStatus);
                }
                if (!selectionBeforeStart.contains(position)) {
                    objects.get(position).setChecked(destCheckStatus);
                }
            }
            else {
                if (!selectionBeforeStart.contains(position)) {
                    objects.get(position).setChecked(destCheckStatus);
                }
            }
            adapter.notifyDataSetChanged();

            if (idx_1 < 0) {
                idx_1 = idx_2 = position;
            }
            else {
                idx_2 = idx_1;
                idx_1 = position;
            }
        }

        if (position >= lv.getLastVisiblePosition()) {
            lv.smoothScrollToPosition(position+1);
        }
        else if (position <= lv.getFirstVisiblePosition()) {
            lv.smoothScrollToPosition(position-1);
        }
    }

    @Override
    public void endSelectMode(int endPos) {
        // Log.d("SelectModeEnd", "SelectModeEnd");
        if (!active) {
            // Log.d("MOTION", "Repeated ACTION_UP events (multitouch?), ignoring...");
            return;
        }
        if (startPos == endPos && !atLeastOneMoveAfterDown) {
            if (!selectionBeforeStart.contains(startPos)) {
                objects.get(startPos).setChecked(!initialDestCheckStatus);
            }
        }

        selectionBeforeStart.clear();
        idx_1 = -1;
        idx_2 = -1;
        active = false;
        destCheckStatus = initialDestCheckStatus;
        atLeastOneMoveAfterDown = false;
        adapter.notifyDataSetChanged();
    }
}

```

`app/src/main/java/it/pgp/xfiles/comparators/AdvancedComparator.java`:

```java
package it.pgp.xfiles.comparators;

import java.util.Comparator;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.SortingItem;

/**
 * Created by pgp on 27/10/16
 * Last modified on 30/10/16
 */

public class AdvancedComparator implements Comparator<BrowserItem> {

    private SortingItem[] attributes; // sorting is sequential w.r.t. these attributes

    public AdvancedComparator(SortingItem... attributes) {
        this.attributes = attributes;
    }

    @Override
    public int compare(BrowserItem o1, BrowserItem o2) {
        int currentComparisonResult = 0;

        for (SortingItem a : attributes) {
            switch (a.comparatorField) {
                case FILENAME:
                    currentComparisonResult = o1.getFilename().compareTo(o2.getFilename());
                    if (a.isReversed()) currentComparisonResult*=-1;
                    if (currentComparisonResult == 0) continue;
                    else return currentComparisonResult;
                case DATE:
                    currentComparisonResult = o1.date.compareTo(o2.date);
                    if (a.isReversed()) currentComparisonResult*=-1;
                    if (currentComparisonResult == 0) continue;
                    else return currentComparisonResult;
                case SIZE:
                    currentComparisonResult = o1.size.compareTo(o2.size);
                    if (a.isReversed()) currentComparisonResult*=-1;
                    if (currentComparisonResult == 0) continue;
                    else return currentComparisonResult;
                case TYPE:
                    boolean d1 = o1.isDirectory;
                    boolean d2 = o2.isDirectory;

                    // use directory/file comparison logic if both items have no extension
                    // (this in order to prevent mixing folders and files without extension)
                    if(d1 && !d2) currentComparisonResult = -1;
                    else if(!d1 && d2) currentComparisonResult = 1;
                    else /*if((!d1 && !d2) || (d1 && d2))*/ // both files or both directories
                        currentComparisonResult = o1.getFileExt().compareTo(o2.getFileExt());
                    if (a.isReversed()) currentComparisonResult*=-1;
                    if (currentComparisonResult == 0) continue;
                    else return currentComparisonResult;
                case DIR:
                    currentComparisonResult = o1.isDirectory.compareTo(o2.isDirectory);
                    if (!a.isReversed()) currentComparisonResult*=-1; // more natural order than considering boolean precedence (reverse means files first, then direectories)
                    if (currentComparisonResult == 0) continue;
                    else return currentComparisonResult;
                default:
                    throw new RuntimeException("Guard block");
            }
        }
        return currentComparisonResult;
    }
}

```

`app/src/main/java/it/pgp/xfiles/comparators/AdvancedComparatorStrategy.java`:

```java
package it.pgp.xfiles.comparators;

import java.util.*;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.SortingItem;
import it.pgp.xfiles.enums.ComparatorField;

/**
 * Created by pgp on 30/10/16
 */

public class AdvancedComparatorStrategy implements Comparator<BrowserItem> {
    // code more readable, but slightly less efficient than switch-based one (AdvancedComparator)
    private static class FilenameComp implements Comparator<BrowserItem> {
        @Override
        public int compare(BrowserItem o1, BrowserItem o2) {
            return o1.getFilename().compareTo(o2.getFilename());
        }
    }

    private static class DateComp implements Comparator<BrowserItem> {
        @Override
        public int compare(BrowserItem o1, BrowserItem o2) {
            return o1.date.compareTo(o2.date);
        }
    }

    private static class SizeComp implements Comparator<BrowserItem> {
        @Override
        public int compare(BrowserItem o1, BrowserItem o2) {
            return o1.size.compareTo(o2.size);
        }
    }

    private static class TypeComp implements Comparator<BrowserItem> {
        @Override
        public int compare(BrowserItem o1, BrowserItem o2) {
            boolean d1 = o1.isDirectory;
            boolean d2 = o2.isDirectory;

            // use directory/file comparison logic if both items have no extension
            // (this in order to prevent mixing folders and files without extension)
            if(d1 && !d2) return -1;
            else if(!d1 && d2) return 1;
            else /*if((!d1 && !d2) || (d1 && d2))*/ // both files or both directories
                return o1.getFileExt().compareTo(o2.getFileExt());
        }
    }

    private static class DirComp implements Comparator<BrowserItem> {
        // -1 factor: more natural order than considering boolean precedence (reverse means files first, then directories)
        @Override
        public int compare(BrowserItem o1, BrowserItem o2) {
            return -1*o1.isDirectory.compareTo(o2.isDirectory);
        }
    }

    private List<SortingItem> attributes; // sorting is sequential w.r.t. these attributes
    private static final Map<ComparatorField,Comparator> comparators;

    static {
        Map<ComparatorField,Comparator> m = new HashMap<>();
        m.put(ComparatorField.FILENAME,new FilenameComp());
        m.put(ComparatorField.DATE,new DateComp());
        m.put(ComparatorField.SIZE,new SizeComp());
        m.put(ComparatorField.TYPE,new TypeComp());
        m.put(ComparatorField.DIR,new DirComp());
        comparators = Collections.unmodifiableMap(m);
    }

    public AdvancedComparatorStrategy(List<SortingItem> attributes) {
        this.attributes = attributes;
    }

    @Override
    public int compare(BrowserItem o1, BrowserItem o2) {
        int currentComparisonResult = 0;
        for (SortingItem a : attributes) {
            try {currentComparisonResult = comparators.get(a.comparatorField).compare(o1,o2);}
            catch (NullPointerException n) {
                throw new RuntimeException("Guard block");
            }
            if (a.isReversed()) currentComparisonResult*=-1;
            if (currentComparisonResult != 0) return currentComparisonResult;
        }
        return currentComparisonResult;
    }
}

```

`app/src/main/java/it/pgp/xfiles/comparators/FilenameComparator.java`:

```java
package it.pgp.xfiles.comparators;

import java.util.Comparator;

import it.pgp.xfiles.BrowserItem;

/**
 * Created by pgp on 26/10/16
 */

public class FilenameComparator implements Comparator<BrowserItem> {
    @Override
    public int compare(BrowserItem o1, BrowserItem o2) {
        // directory priority (directories first, then files)
        if ((o1.isDirectory && o2.isDirectory)||(!o1.isDirectory && !o2.isDirectory))
            return o1.getFilename().compareTo(o2.getFilename()); // both files or both dirs
        else if (!o1.isDirectory /* && o2.isDirectory */) return 1;
        else return -1;
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/AdvancedSortingDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Activity;
import android.support.v7.widget.LinearLayoutManager;
import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.helper.ItemTouchHelper;
import android.widget.Button;

import java.util.ArrayList;

import it.pgp.xfiles.R;
import it.pgp.xfiles.SortingItem;
import it.pgp.xfiles.adapters.BrowserAdapter;
import it.pgp.xfiles.comparators.AdvancedComparator;
import it.pgp.xfiles.dragdroplist.DragDropItemTouchHelperCallback;
import it.pgp.xfiles.dragdroplist.DragNDropAdapter;
import it.pgp.xfiles.enums.ComparatorField;

/**
 * Created by pgp on 28/10/16
 * Last modified on 23/11/2016
 */

public class AdvancedSortingDialog extends BaseDialog {
    private DragNDropAdapter dragNDropAdapter;
    private RecyclerView listView;

    private AdvancedComparator advancedComparator;

    public AdvancedSortingDialog(final Activity activity, final BrowserAdapter browserAdapter) {
        super(activity);
        setTitle("Advanced sort");
        setContentView(R.layout.advanced_sorting_dialog);
        setDialogIcon(R.drawable.xfiles_sort_icon);

        final ArrayList<SortingItem> content = new ArrayList<>();
        for (ComparatorField c : ComparatorField.values()) {
            content.add(new SortingItem(c,true,false)); // default: all attributes selected, no one reversed
        }

        listView = findViewById(R.id.sortingAttributesDragNDropListView);
        LinearLayoutManager layoutManager = new LinearLayoutManager(activity, LinearLayoutManager.VERTICAL, false);
        dragNDropAdapter = new DragNDropAdapter(activity,content);
        listView.setLayoutManager(layoutManager);
        listView.setAdapter(dragNDropAdapter);

        new ItemTouchHelper(new DragDropItemTouchHelperCallback(dragNDropAdapter,content)).attachToRecyclerView(listView);

        Button okButton = findViewById(R.id.advancedSortOKButton);
        okButton.setOnClickListener(v -> {
            advancedComparator = new AdvancedComparator(dragNDropAdapter.getSelectedItems());
//            dragNDropAdapter.printContent(); // DEBUG
            browserAdapter.sort(advancedComparator);
            dismiss();
        });

        Button cancelButton = findViewById(R.id.advancedSortCancelButton);
        cancelButton.setOnClickListener(v -> cancel());
    }
}


```

`app/src/main/java/it/pgp/xfiles/dialogs/BaseDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Activity;
import android.app.Dialog;
import android.support.annotation.NonNull;
import android.view.Window;

public class BaseDialog extends Dialog {
    public BaseDialog(@NonNull Activity activity) {
        super(activity);
        requestWindowFeature(Window.FEATURE_LEFT_ICON);
    }

    // https://stackoverflow.com/questions/11430253/how-to-set-icon-for-dialog-in-android
    public void setDialogIcon(int resId) {
        setFeatureDrawableResource(Window.FEATURE_LEFT_ICON, resId);
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/BulkRenameDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.view.View;
import android.view.ViewGroup;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.ProgressBar;
import android.widget.RadioGroup;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.items.BulkRenameItem;
import it.pgp.xfiles.utils.FileOperationHelper;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class BulkRenameDialog extends Dialog {
    private final FileOperationHelper helper;

    private final List<String> inputFilenames;
    private final ArrayAdapter<String> inputAdapter;

    private final ArrayList<BulkRenameItem> outputFilenames = new ArrayList<>();
    private final ArrayAdapter<BulkRenameItem> outputAdapter;

    private final ListView[] lvs = new ListView[]{null,null}; // inputLv, outputLv

    private Map<BulkRenameItem, Set<Integer>> itemsOccurrences;

    private final EditText inputPattern, outputPattern;
    private final Button preview, ok;
    private final ProgressBar pb;
    private final RadioGroup renameRadioGroup;

    private AdapterView.OnItemClickListener getListener(int lvPos) {
        return (parent, view, position, id) -> {
            // TODO use smoothScrollToPosition only if there are few items (e.g. less than 100)
            lvs[1-lvPos].setSelection(position);
            MainActivity.handler.postDelayed(()-> Misc.highlightListViewItem(position, lvs[1-lvPos]),250);
        };
    }

    public enum PatternType {
        STANDARD, REGEX, GLOB
    }

    public boolean highlightOutputPanel() {
        boolean duplicates = false;
        itemsOccurrences = Misc.createOccurrencesMap(outputFilenames);
        for(Map.Entry<BulkRenameItem, Set<Integer>> me : itemsOccurrences.entrySet()) {
            Set<Integer> v = me.getValue();
            if(v.size()>1) {
                duplicates = true;
                // TODO this could also be generalized with a different color for each duplicate set
                //  by storing the int resId instead of the duplicate boolean in BulkRenameItem
                for(Integer i : v)
                    outputFilenames.get(i).duplicate = true;
            }
        }
        outputAdapter.notifyDataSetChanged();
        ok.setEnabled(!duplicates);
        return duplicates;
    }

    public boolean refreshOutputAdapter() {
        outputFilenames.clear();
        // convert names
        String ii = inputPattern.getText().toString();
        String oo = outputPattern.getText().toString();

        int idx = renameRadioGroup.indexOfChild(
                renameRadioGroup.findViewById(
                        renameRadioGroup.getCheckedRadioButtonId()));
        switch(PatternType.values()[idx]) {
            case STANDARD:
                for(String s : inputFilenames)
                    outputFilenames.add(new BulkRenameItem(s.replace(ii,oo)));
                break;
            case REGEX:
                for(String s : inputFilenames)
                    outputFilenames.add(new BulkRenameItem(s.replaceAll(ii,oo)));
                break;
            case GLOB:
                for(String s : inputFilenames)
                    outputFilenames.add(new BulkRenameItem(s.replaceAll(Misc.convertGlobToRegex(ii),oo)));
                break;
        }
        return highlightOutputPanel();
    }

    private BulkRenameDialog(MainActivity activity, BasePathContent baseDir, List<String> inputFilenames) {
        super(activity, R.style.fs_dialog);
        this.inputFilenames = inputFilenames;
        for(String s : inputFilenames)
            outputFilenames.add(new BulkRenameItem(s));
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.bulk_rename_dialog);
        helper = activity.getFileOpsHelper(baseDir.providerType);

        inputPattern = findViewById(R.id.inputRenamePattern);
        outputPattern = findViewById(R.id.outputRenamePattern);
        renameRadioGroup = findViewById(R.id.renameRadioGroup);
        preview = findViewById(R.id.renamePreviewButton);
        ok = findViewById(R.id.renameOkButton);
        pb = findViewById(R.id.renameProgressBar);

        inputAdapter = new ArrayAdapter<>(activity, android.R.layout.simple_list_item_1, inputFilenames);
        lvs[0] = findViewById(R.id.inputRenameLv);
        lvs[0].setAdapter(inputAdapter);
        outputAdapter = new ArrayAdapter<BulkRenameItem>(activity, android.R.layout.simple_list_item_1, outputFilenames){
            @NonNull
            @Override
            public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {
                BulkRenameItem item = getItem(position);
                View view = super.getView(position, convertView, parent);
                view.findViewById(android.R.id.text1).setBackgroundResource(item.duplicate?android.R.color.holo_red_dark:R.color.transparentCobaltBlue);
                return view;
            }
        };
        lvs[1] = findViewById(R.id.outputRenameLv);
        lvs[1].setAdapter(outputAdapter);

        lvs[0].setOnItemClickListener(getListener(0));
        lvs[1].setOnItemClickListener(getListener(1));
        highlightOutputPanel();

        preview.setOnClickListener(v -> refreshOutputAdapter());

        ok.setOnClickListener(v->{
            if(refreshOutputAdapter()) {
                Toast.makeText(activity, "Duplicates are present in output list, please set a different rename transformation", Toast.LENGTH_SHORT).show();
                return;
            }
            ok.setVisibility(View.GONE);
            preview.setVisibility(View.GONE);
            pb.setVisibility(View.VISIBLE);
            pb.setIndeterminate(false);
            pb.setMax(inputFilenames.size());
            setCancelable(false);
            // TODO at the end, don't dismiss the dialog, instead remove progress bar and restore previous buttons
            new Thread(()-> {
                int itemsToRename = 0;
                List<BasePathContent> failedPaths = new ArrayList<>();
                for(int i=0;i<inputFilenames.size();i++) {
                    int k=i;
                    String i1 = inputFilenames.get(i);
                    String i2 = outputFilenames.get(i).filename;
                    if(i1.equals(i2)) {
                        MainActivity.handler.post(()->pb.setProgress(k));
                        continue;
                    }
                    BasePathContent p1 = baseDir.concat(i1);
                    BasePathContent p2 = baseDir.concat(i2);
                    try {
                        helper.renameFile(p1,p2);
                        itemsToRename++;
                    }
                    catch (Exception e) {
                        e.printStackTrace();
                        failedPaths.add(p1);
                    }
                    MainActivity.handler.post(()->pb.setProgress(k));
                }
                int renamedItems = itemsToRename;
                activity.runOnUiThread(()->{
                    dismiss();
                    if(failedPaths.isEmpty())
                        Toast.makeText(activity, "Rename completed, renamed "+renamedItems+" items", Toast.LENGTH_SHORT).show();
                    else {
                        StringBuilder errMsg = new StringBuilder();
                        for(BasePathContent p : failedPaths)
                            errMsg.append(p).append("\n");
                        Toast.makeText(activity, "Failed items:\n"+errMsg.toString(), Toast.LENGTH_SHORT).show();
                    }
                    activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),null);
                });
            }).start();
        });
    }

    public static void createAndShow(MainActivity activity, BasePathContent baseDir, List<String> inputFilenames) {
        if(baseDir.providerType != ProviderType.LOCAL && baseDir.providerType != ProviderType.SFTP) {
            Toast.makeText(activity, "Rename is available only for local and SFTP paths", Toast.LENGTH_SHORT).show();
            return;
        }
        new BulkRenameDialog(activity, baseDir, inputFilenames).show();
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/ChecksumActivity.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.graphics.Color;
import android.os.AsyncTask;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.ContextMenu;
import android.view.MenuItem;
import android.view.View;
import android.view.Window;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.GridView;
import android.widget.LinearLayout;
import android.widget.TableLayout;
import android.widget.TableRow;
import android.widget.TextView;
import android.widget.Toast;

import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.HashAlgorithmsAdapter;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;
import it.pgp.xfiles.utils.FileOperationHelper;
import it.pgp.xfiles.utils.FileSaveFragment;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 21/02/18
 */

public class ChecksumActivity extends EffectActivity implements FileSaveFragment.Callbacks {

    private ChecksumTask checksumTask;

    private BasePathContent parentDir;
    private List<BrowserItem> files;

    private HashAlgorithmsAdapter adapter;
    private TableLayout standardResultsLayout;
    private Button computeChecksumsButton;

    private ClipboardManager clipboard;

    // directory hashing layout and checkboxes for options
    private LinearLayout dirHashOptsLayout;
    private CheckedTextView dirHashWithNames;
    private CheckedTextView dirHashIgnoreThumbsFiles;
    private CheckedTextView dirHashIgnoreUnixHiddenFiles;
    private CheckedTextView dirHashIgnoreEmptyDirs;

    private List<List<HashTextView>> hashMatrix = new ArrayList<>();
    private Set<HashRequestCodes> selectedHashAlgorithms; // selected from the last run (not necessarily completed)

    public String chosenExportExt = "";

    public void showLegend(View unused) {
        Dialog hashLegendDialog = new Dialog(this){
            @Override
            public void show() {
                requestWindowFeature(Window.FEATURE_NO_TITLE);
                setContentView(R.layout.hash_labels_legend);
                super.show();
            }
        };
        hashLegendDialog.show();
    }

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        clipboard = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);

        // parent dir passed as BasePathContent, valid for both local and XRE paths
        BrowserItem singleFile = (BrowserItem)getIntent().getSerializableExtra("browseritem");
        if (singleFile == null)
            files = MainActivity.mainActivity.getCurrentBrowserAdapter().getSelectedItems();
        else
            files = Collections.singletonList(singleFile);

        parentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();

        setContentView(R.layout.checksum_base_dialog);
        setTitle("Checksum");

        standardResultsLayout = findViewById(R.id.standardResultsLayout);

        dirHashOptsLayout = findViewById(R.id.checksum_dirHashOptsLayout);

        // if there's at least a directory in the selection, enable dir hash options layout
        int dirHashOptsLayoutVisibility = View.GONE;
        for(BrowserItem b : files) {
            if(b.isDirectory) {
                dirHashOptsLayoutVisibility = View.VISIBLE;
                break;
            }
        }
        dirHashOptsLayout.setVisibility(dirHashOptsLayoutVisibility);

        dirHashWithNames = findViewById(R.id.checksum_dirHashWithNames);
        dirHashIgnoreThumbsFiles = findViewById(R.id.checksum_dirHashIgnoreThumbsFiles);
        dirHashIgnoreUnixHiddenFiles = findViewById(R.id.checksum_dirHashIgnoreUnixHiddenFiles);
        dirHashIgnoreEmptyDirs = findViewById(R.id.checksum_dirHashIgnoreEmptyDirs);

        dirHashWithNames.setOnClickListener(Misc.ctvListener);
        dirHashIgnoreThumbsFiles.setOnClickListener(Misc.ctvListener);
        dirHashIgnoreUnixHiddenFiles.setOnClickListener(Misc.ctvListener);
        dirHashIgnoreEmptyDirs.setOnClickListener(Misc.ctvListener);

        GridView hashSelectorView = findViewById(R.id.hashSelectorView);
        adapter = new HashAlgorithmsAdapter(this);
        hashSelectorView.setAdapter(adapter);

        computeChecksumsButton = findViewById(R.id.computeChecksumsButton);

        // check SHA-256 by default
        Misc.getViewByPosition(HashRequestCodes.sha256.ordinal(),hashSelectorView).findViewById(R.id.checksum_ctv).performClick();
    }

    HashTextView currentlySelectedTableItem;

    // context menu for long click on hashtextview in the table layout
    @Override
    public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) {
        if (!(v instanceof HashTextView)) {
            Toast.makeText(this, "Context selection is not a HashTextView", Toast.LENGTH_SHORT).show();
            return;
        }
        currentlySelectedTableItem = (HashTextView) v;
        super.onCreateContextMenu(menu, v, menuInfo);
        getMenuInflater().inflate(R.menu.menu_checksum, menu);
    }

    @Override
    public boolean onContextItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.checksumCopyHashToClipboard:
                clipboard.setPrimaryClip(ClipData.newPlainText(
                        currentlySelectedTableItem.getHeader(),
                        currentlySelectedTableItem.getContent()));
                break;
            case R.id.checksumCopyFullInfoToClipboard:
                clipboard.setPrimaryClip(ClipData.newPlainText(
                        currentlySelectedTableItem.getHeader(),
                        currentlySelectedTableItem.getText()));
                break;
            default:
                return true;
        }
        Toast.makeText(this, "Hash copied to clipboard", Toast.LENGTH_SHORT).show();
        return true;
    }

    // FIXME duplicated from CompressActivity, refactor
    @Override
    public boolean onCanSave(String absolutePath, String fileName) {

        // Catch the really stupid case.
        if (absolutePath == null || absolutePath.length() ==0 ||
                fileName == null || fileName.length() == 0) {
            Toast.makeText(this,R.string.alert_supply_filename, Toast.LENGTH_SHORT).show();
            return false;
        }

        // Do we have a filename if the extension is thrown away?
        String copyName = FileSaveFragment.NameNoExtension(fileName);
        if (copyName == null || copyName.length() == 0 ) {
            Toast.makeText(this,R.string.alert_supply_filename, Toast.LENGTH_SHORT).show();
            return false;
        }

        // No overwrite of an existing file.
        if (FileSaveFragment.FileExists(absolutePath, fileName)) {
            Toast.makeText(this,R.string.alert_file_exists, Toast.LENGTH_SHORT).show();
            return false;
        }

        return true;
    }

    @Override
    public void onConfirmSave(String absolutePath, String fileName) {
        String fileNameWithExt = fileName + "." + chosenExportExt;
        if (onCanSave(absolutePath,fileNameWithExt)) {
            if(chosenExportExt.equals("csv"))
                exportToCSV(absolutePath,fileNameWithExt);
            else exportToJSON(absolutePath,fileNameWithExt);
        }
    }

    private static class HashTextView extends TextView {

        private HashRequestCodes code;
        private CharSequence filename;
        private CharSequence content; // the digest as hex string

        public HashTextView(Context context,
                            CharSequence content,
                            CharSequence filename,
                            HashRequestCodes code) {
            super(context);
            this.content = content;
            this.code = code;
            this.filename = filename;
            setText(getHeader()+": "+content);
        }

        public CharSequence getHeader() {
            return filename+", "+code.toString();
        }

        public CharSequence getContent() {
            return content;
        }
    }

    private boolean checksumInterrupted = false;

    @Override
    protected void onDestroy() {
        super.onDestroy();
        checksumInterrupted = true;
        HashRequestCodes.clear();
    }

    private class ChecksumTask extends AsyncTask<Void, Void, Void> {
        final boolean someSelection;

        {
            selectedHashAlgorithms = adapter.getSelectedItems();
            someSelection = selectedHashAlgorithms.size()>0;
        }

        @Override
        protected void onPreExecute() {
            computeChecksumsButton.setEnabled(false);
            standardResultsLayout.removeAllViews();
        }

        private byte[] computeHashForLocalOrXREPaths(BasePathContent path, HashRequestCodes s, FileOperationHelper helper) throws IOException {
            switch (path.providerType) {
                case LOCAL:
                case XFILES_REMOTE:
                    BitSet dirHashOpts = new BitSet(4);
                    dirHashOpts.set(0,dirHashWithNames.isChecked());
                    dirHashOpts.set(1,dirHashIgnoreThumbsFiles.isChecked());
                    dirHashOpts.set(2,dirHashIgnoreUnixHiddenFiles.isChecked());
                    dirHashOpts.set(3,dirHashIgnoreEmptyDirs.isChecked());
                    return helper.hashFile(path,s,dirHashOpts);
                default:
                    throw new RuntimeException("Only local and XRE paths allowed for hashing");
            }
        }

        @Override
        protected Void doInBackground(Void... unused) {
            hashMatrix = new ArrayList<>();
            final int[][] tvBackground = new int[][]{{Color.DKGRAY,Color.BLUE},{Color.RED,Color.GRAY}};

            // TODO restructure hash request in RH protocol, allow multiple hashes per multiple files
            // then, make the RH task cancellable via another sub-request type (like in FindUpdatesThread)
            int i=0, j=0;
            try {
                if(!someSelection) return null;
                if (files.size()==1) { // algorithms on rows, 1 column (only 1 file)
                    List<HashTextView> lhtv = new ArrayList<>(); // for csv/json export, keep the format coherent (1 row, multiple columns)
                    hashMatrix.add(lhtv);
                    BasePathContent file = parentDir.concat(files.get(0).getFilename());
                    FileOperationHelper helper = MainActivity.mainActivity.getFileOpsHelper(file.providerType);
                    for (HashRequestCodes s : selectedHashAlgorithms) {
                        if (checksumInterrupted) {
                            MainActivity.showToast("Checksum task interrupted");
                            return null;
                        }
                        TableRow tr = new TableRow(ChecksumActivity.this);
                        runOnUiThread(()->standardResultsLayout.addView(tr));

                        byte[] digest = computeHashForLocalOrXREPaths(file,s, helper);

                        // run on UI thread
                        HashTextView t = new HashTextView(
                                ChecksumActivity.this,
                                Misc.toHexString(digest),
                                file.getName(), s);

                        t.setBackgroundColor(tvBackground[i][j++%2]);
                        registerForContextMenu(t);
                        lhtv.add(t);
                        runOnUiThread(()->tr.addView(t));
                    }
                }
                else for (BrowserItem file : files) { // files on rows
                    TableRow tr = new TableRow(ChecksumActivity.this);
                    List<HashTextView> lhtv = new ArrayList<>();
                    hashMatrix.add(lhtv);
                    runOnUiThread(()->standardResultsLayout.addView(tr));
                    BasePathContent file1 = parentDir.concat(file.getFilename());
                    FileOperationHelper helper = MainActivity.mainActivity.getFileOpsHelper(file1.providerType);

                    for (HashRequestCodes s : selectedHashAlgorithms) {
                        if (checksumInterrupted) {
                            MainActivity.showToast("Checksum task interrupted");
                            return null;
                        }

                        byte[] digest = computeHashForLocalOrXREPaths(file1, s, helper);

                        // run on UI thread
                        HashTextView t = new HashTextView(
                                ChecksumActivity.this,
                                Misc.toHexString(digest),
                                file.getFilename(), s);

                        t.setBackgroundColor(tvBackground[i][j++%2]);
                        registerForContextMenu(t);
                        lhtv.add(t);
                        runOnUiThread(()->tr.addView(t));

                    }
                    i=(i+1)%2;
                }
            }
            catch (Exception e) {
                e.printStackTrace();
                MainActivity.showToast("Error during checksum computation");
            }
            return null;
        }

        @Override
        protected void onPostExecute(Void unused) {
            if(checksumInterrupted) return;
            if(!someSelection)
                Toast.makeText(ChecksumActivity.this,"No checksum algorithm selected",Toast.LENGTH_SHORT).show();
            computeChecksumsButton.setEnabled(true);
        }
    }

    public void ok(View unused) {
        checksumTask = new ChecksumTask();
        checksumTask.execute((Void[])null);
    }

    public void openExportOutputSelector(View v) {
        if(hashMatrix.isEmpty()) {
            Toast.makeText(this, "No checksums to export", Toast.LENGTH_SHORT).show();
            return;
        }

        String fragTag = getResources().getString(R.string.tag_fragment_FileSave);

        chosenExportExt = v.getId()==R.id.exportChecksumsCSVButton?"csv":"json";

        // Get an instance supplying a default extension, captions and
        // icon appropriate to the calling application/activity.
        FileSaveFragment fsf = FileSaveFragment.newInstance(chosenExportExt,
                android.R.string.ok,
                android.R.string.cancel,
                R.string.app_name,
                R.string.edit_hint,
                R.string.checksums_export_filename_header,
                R.drawable.xfiles_file_icon);
        fsf.show(getFragmentManager(), fragTag);
    }

    public void exportToCSV(String absolutePath, String fileNameWithExt) {
        File csvFile = new File(absolutePath +"/"+fileNameWithExt);
        try(OutputStream o = new BufferedOutputStream(new FileOutputStream(csvFile))) {
            // create header
            Misc.csvWriteRow(o,new ArrayList(){{
                add("filename");
                for (HashRequestCodes code : selectedHashAlgorithms) add(code.toString());
            }});

            for(List<HashTextView> lhtv : hashMatrix) {
                Misc.csvWriteRow(o,new ArrayList(){{
                    // by construction, lhtv contains hashes for the same filename
                    add(""+lhtv.get(0).filename);
                    for(HashTextView htv: lhtv) add(""+htv.content);
                }});
            }

            MainActivity.showToast("Checksums export complete");
        } catch (IOException e) {
            e.printStackTrace();
            MainActivity.showToast("Error exporting checksums to CSV");
        }
    }

    public void exportToJSON(String absolutePath, String fileNameWithExt) {
        List l = new ArrayList();
        for(List<HashTextView> lhtv : hashMatrix) {
            Map m = new HashMap();
            Map n = new HashMap();
            for(HashTextView htv : lhtv) {
                n.put(htv.code.toString(),""+htv.content);
            }
            m.put("filename",""+lhtv.get(0).filename);
            m.put("checksums",n);
            l.add(m);
        }
        ObjectMapper mapper = new ObjectMapper();
        try {
            mapper.writeValue(new File(absolutePath+"/"+fileNameWithExt),l);
            MainActivity.showToast("Checksums export complete");
        }
        catch (IOException e) {
            e.printStackTrace();
            MainActivity.showToast("Error exporting checksums to JSON");
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/CloseActiveServersDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Activity;
import android.app.Dialog;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.fileservers.FileServer;
import it.pgp.xfiles.roothelperclient.RemoteServerManager;

public class CloseActiveServersDialog extends Dialog {

    Button Bxre,Bftp,Bhttp;
    TextView Txre,Tftp,Thttp;

    final Activity context;

    int red,green;

    public CloseActiveServersDialog(final Activity context) {
        super(context);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        this.context = context;
        setOnShowListener(EffectActivity.defaultDialogShowListener);
        setOnDismissListener(d->EffectActivity.currentlyOnFocus = MainActivity.mainActivity);

        red = context.getResources().getColor(R.color.red);
        green = context.getResources().getColor(R.color.green);

        setContentView(R.layout.active_remote_servers_layout);

        Txre = findViewById(R.id.active_servers_xre_textview);
        Tftp = findViewById(R.id.active_servers_ftp_textview);
        Thttp = findViewById(R.id.active_servers_http_textview);

        Bxre = findViewById(R.id.active_servers_xre_button);
        Bftp = findViewById(R.id.active_servers_ftp_button);
        Bhttp = findViewById(R.id.active_servers_http_button);

        if(RemoteServerManager.rhssManagerRef.get() != null) {
            Txre.setTextColor(green);
            Bxre.setOnClickListener(v->{
                RemoteServerManager.rhss_action(RemoteServerManager.RHSS_ACTION.STOP);
                Txre.setTextColor(red);
                Bxre.setEnabled(false);
            });
        }
        else {
            Txre.setTextColor(red);
            Bxre.setEnabled(false);
        }
        
        if(FileServer.FTP.server.isAlive()) {
            Tftp.setTextColor(green);
            Bftp.setOnClickListener(v-> {
                FileServer.FTP.server.stopServer();
                Tftp.setTextColor(red);
                Bftp.setEnabled(false);
            });
        }
        else {
            Tftp.setTextColor(red);
            Bftp.setEnabled(false);
        }

        if(FileServer.HTTP.server.isAlive()) {
            Thttp.setTextColor(green);
            Bhttp.setOnClickListener(v-> {
                FileServer.HTTP.server.stopServer();
                Thttp.setTextColor(red);
                Bhttp.setEnabled(false);
            });
        }
        else {
            Thttp.setTextColor(red);
            Bhttp.setEnabled(false);
        }
    }

    @Override
    public void onBackPressed() {
        context.finishAffinity();
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/ConflictDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.content.Context;
import android.view.View;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.conflicthandling.ConflictDecision;
import it.pgp.xfiles.enums.conflicthandling.ConflictType;
import it.pgp.xfiles.utils.ProgressConflictHandler;

public class ConflictDialog extends Dialog implements View.OnClickListener {
    private final TextView srcPathTv,destPathTv;
    private EditText newFilename;
    private Button
            srcRename,srcRenameAll,
            destRename,destRenameAll,
            overwrite,overwriteAll,
            skip,skipAll,cancel;

    private Button merge,mergeAll;

    private ImageView srcImage,destImage;

    private final ProgressConflictHandler handler;

    // srcType == cflType
//    public FileConflictDialog(Context context, ConflictType cflType) {
    public ConflictDialog(Context context,
                          ConflictType srcType,
                          String srcPath,
                          ConflictType destType,
                          String destPath,
                          ProgressConflictHandler handler) {
        super(context);
        this.handler = handler;
        setCancelable(false);
        getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN);
        setTitle(srcType.name()+" over "+destType.name()+" conflict");
        setContentView(R.layout.conflict_dialog);

        srcImage = findViewById(R.id.conflictSrcImage);
        destImage = findViewById(R.id.conflictDestImage);
        srcImage.setImageResource(srcType.getImageRes());
        destImage.setImageResource(destType.getImageRes());

        newFilename = findViewById(R.id.conflictNewPathnameEditText);

        srcPathTv = findViewById(R.id.conflictSrcPath);
        destPathTv = findViewById(R.id.conflictDestPath);
        srcPathTv.setText(srcPath);
        destPathTv.setText(destPath);

        srcRename = findViewById(R.id.conflictRenameSrc);
        srcRename.setOnClickListener(this);
        srcRenameAll = findViewById(R.id.conflictAutoRenameSrc);
        srcRenameAll.setOnClickListener(this);
        destRename = findViewById(R.id.conflictRenameDest);
        destRename.setOnClickListener(this);
        destRenameAll = findViewById(R.id.conflictAutoRenameDest);
        destRenameAll.setOnClickListener(this);
        overwrite = findViewById(R.id.conflictOverwrite);
        overwrite.setOnClickListener(this);
        overwriteAll = findViewById(R.id.conflictOverwriteAll);
        overwriteAll.setOnClickListener(this);
        skip = findViewById(R.id.conflictSkip);
        skip.setOnClickListener(this);
        skipAll = findViewById(R.id.conflictSkipAll);
        skipAll.setOnClickListener(this);

        merge = findViewById(R.id.conflictMerge);
        mergeAll = findViewById(R.id.conflictMergeAll);
        if (srcType == ConflictType.DIR && destType == ConflictType.DIR) {
            merge.setOnClickListener(this);
            mergeAll.setOnClickListener(this);
        }
        else {
            merge.setEnabled(false);
            mergeAll.setEnabled(false);
        }

        // just enable only skip, cancel and copy-with-rename (a.k.a. rename-source) option in case of copying a file onto itself
        if (srcPath.equals(destPath)) {
            destRename.setEnabled(false);
            destRenameAll.setEnabled(false);
            overwrite.setEnabled(false);
            overwriteAll.setEnabled(false);
            merge.setEnabled(false);
            mergeAll.setEnabled(false);
        }

        cancel = findViewById(R.id.conflictCancel);
        cancel.setOnClickListener(this);
    }

    @Override
    public void onClick(View v) {
        int res = v.getId();
        handler.lastDecision = ConflictDecision.fromResource(res);
        if (handler.lastDecision == ConflictDecision.CD_REN_SRC ||
                handler.lastDecision == ConflictDecision.CD_REN_DEST) {
            handler.lastNewName = newFilename.getText().toString();
            if (handler.lastNewName.isEmpty()) {
                Toast.makeText(getContext(), "Please insert a valid filename", Toast.LENGTH_SHORT).show();
                return;
            }
        }
        else handler.lastNewName = null; // FIXME should be useless

        dismiss();
        synchronized (ConflictDecision.m) {
            ConflictDecision.m.notifyAll();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/CreateFileOrDirectoryDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.content.Intent;
import android.view.KeyEvent;
import android.view.LayoutInflater;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.widget.AbsListView;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.EditText;
import android.widget.ImageView;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.RadioGroup;
import android.widget.Spinner;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.BrowserAdapter;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;
import it.pgp.xfiles.roothelperclient.StreamCiphers;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.CreateFileService;
import it.pgp.xfiles.service.params.CreateFileParams;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.SFTPPathContent;
import it.pgp.xfiles.utils.pathcontent.SMBPathContent;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

public class CreateFileOrDirectoryDialog extends BaseDialog {

    EditText filename;
    Button ok;

    CheckedTextView advancedOptionsCtv; // disabled for folders

    LinearLayout advancedOptionsLayout; // disabled for folder, togglable for files

    EditText fileSize;
    RadioGroup fileCreationStrategy, sizeUnit;
    CheckedTextView useCustomSeedCtv, enableOutputHash, useCustomBackendCipher;
    EditText prngSeed; // visibility governed by useCustomSeedCtv
    Spinner outputHashTypes; // visibility governed by enableOutputHash
    Spinner streamCiphers; // visibility governed by useCustomBackendCipher
    final MainActivity mainActivity;
    final FileMode type;
    long byteMultiplier = 1;

    public CreateFileOrDirectoryDialog(final MainActivity mainActivity, final FileMode type, boolean showAdvancedOptions, String currentState) {
        super(mainActivity);
        this.mainActivity = mainActivity;
        this.type = type;
        setContentView(R.layout.create_file_dir_dialog);
        setDialogIcon(type == FileMode.FILE ?
                R.drawable.xf_new_file :
                R.drawable.xf_new_dir);

        advancedOptionsCtv = findViewById(R.id.fileDirCreate_advancedOptionsCtv);
        advancedOptionsLayout = findViewById(R.id.fileDirCreate_advancedOptionsLayout);
        advancedOptionsLayout.setVisibility(View.GONE);

        switch (type) {
            case DIRECTORY:
                setTitle("Create directory");
                advancedOptionsCtv.setVisibility(View.GONE);
                break;
            case FILE:
                setTitle("Create file");
                advancedOptionsCtv.setOnClickListener(v -> {
                    advancedOptionsCtv.toggle();
                    advancedOptionsLayout.setVisibility(advancedOptionsCtv.isChecked() ? View.VISIBLE : View.GONE);
                });
                fileSize = findViewById(R.id.fileDirCreate_fileSize);
                fileCreationStrategy = findViewById(R.id.fileDirCreate_fileCreationStrategy);
                sizeUnit = findViewById(R.id.sizeUnitRadioGroup);
                prngSeed = findViewById(R.id.fileCreationStrategy_seed);
                useCustomSeedCtv = findViewById(R.id.fileCreationStrategy_useCustomSeed);
                useCustomSeedCtv.setOnClickListener(v -> {
                    boolean status = !useCustomSeedCtv.isChecked();
                    useCustomSeedCtv.toggle();
                    prngSeed.setVisibility(status ? View.VISIBLE : View.GONE);
                });
                outputHashTypes = findViewById(R.id.fileCreationStrategy_HashTypesSpinner);
                outputHashTypes.setAdapter(new ArrayAdapter<>(mainActivity, android.R.layout.simple_spinner_dropdown_item, HashRequestCodes.values()));
                outputHashTypes.setSelection(4); // pre-select SHA256
                enableOutputHash = findViewById(R.id.fileCreationStrategy_enableOutputHash);
                enableOutputHash.setOnClickListener(v -> {
                    boolean status = !enableOutputHash.isChecked();
                    enableOutputHash.toggle();
                    outputHashTypes.setVisibility(status ? View.VISIBLE : View.GONE);
                });
                streamCiphers = findViewById(R.id.fileCreationStrategy_StreamCiphersSpinner);
                streamCiphers.setAdapter(new ArrayAdapter<>(mainActivity, android.R.layout.simple_spinner_dropdown_item, StreamCiphers.values()));
                streamCiphers.setSelection(0); // preselect ChaCha
                useCustomBackendCipher = findViewById(R.id.fileCreationStrategy_useCustomBackendCipher);
                useCustomBackendCipher.setOnClickListener(v -> {
                    boolean status = !useCustomBackendCipher.isChecked();
                    useCustomBackendCipher.toggle();
                    streamCiphers.setVisibility(status ? View.VISIBLE : View.GONE);
                });
                break;
            default:
                throw new RuntimeException("Undefined file mode"); // Unreachable statement
        }

        filename = findViewById(R.id.fileDirCreate_filename);
        filename.setText(currentState);
        ok = findViewById(R.id.fileDirCreate_OkButton);

        ok.setOnClickListener(v -> {
            final String filename_ = filename.getText().toString();
            if (filename_.contains("/")) {
                MainActivity.showToast("Full path creation implemented but not enabled yet");
                return;
            }
            if (filename_.isEmpty()) {
                MainActivity.showToast("Empty filename provided");
                return;
            }
            toggleButtons(true);

            BasePathContent f = mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname().concat(filename_);
            // dirty hack to workaround final variable requirements in lambdas and catch-finally data flow dependency
            // Collection.singletonList or Arrays.asList cannot be used here, in that they create immutables
            List<String> nameToLocate = new ArrayList<String>(){{add(filename_);}};

            try {
                String tmp = fileSize.getText().toString();
                long fileSizeL = 0;
                if(!tmp.isEmpty()) {
                    int idx = sizeUnit.indexOfChild(sizeUnit.findViewById(sizeUnit.getCheckedRadioButtonId()));
                    switch(idx) {
                        case 0:
                            byteMultiplier = 1L;
                            break;
                        case 1:
                            byteMultiplier = 1000L;
                            break;
                        case 2:
                            byteMultiplier = 1000000L;
                            break;
                        case 3:
                            byteMultiplier = 1000000000L;
                            break;
                        default:
                            throw new RuntimeException("Unsupported size unit");
                    }
                    fileSizeL = Long.parseLong(tmp)*byteMultiplier;
                }
                int idx = (advancedOptionsCtv.isChecked() && type == FileMode.FILE)?
                        1 + fileCreationStrategy.indexOfChild(
                                fileCreationStrategy.findViewById(
                                        fileCreationStrategy.getCheckedRadioButtonId())):
                        -1;
                FileCreationAdvancedOptions.FileCreationMode mode = (idx == -1) ? null : FileCreationAdvancedOptions.FileCreationMode.values()[idx];
                FileCreationAdvancedOptions opts = idx == -1 ? null :
                        new FileCreationAdvancedOptions(fileSizeL,
                                new FileCreationAdvancedOptions.CreationStrategyAndOptions(
                                        mode,
                                        useCustomSeedCtv.isChecked() ? prngSeed.getText().toString() : null,
                                        enableOutputHash.isChecked() ? outputHashTypes.getSelectedItem().toString() : null,
                                        useCustomBackendCipher.isChecked() ? streamCiphers.getSelectedItem().toString() : null
                                )
                        );

                if(f instanceof SFTPPathContent) MainActivity.sftpProvider.createFileOrDirectory(f,type);
                else if(f instanceof SMBPathContent) MainActivity.smbProvider.createFileOrDirectory(f,type);
                else {
//                    MainActivity.getRootHelperClient().createFileOrDirectory(f,type,opts);
                    try {
                        Intent startIntent = new Intent(mainActivity, CreateFileService.class);
                        startIntent.setAction(BaseBackgroundService.START_ACTION);
                        startIntent.putExtra("params", new CreateFileParams(f, opts));
                        mainActivity.startService(startIntent);
                    }
                    catch(Exception e) {
                        e.printStackTrace();
                    }
                    dismiss();
                    return;
                }
                MainActivity.showToast(type.name().toLowerCase()+" created");
            }
            catch(Exception e) {
                e.printStackTrace();
                MainActivity.showToast(e.getMessage());
                nameToLocate.clear();
            }

            mainActivity.runOnUiThread(()->{
                mainActivity.browserPagerAdapter.showDirContent(
                        mainActivity.getCurrentDirCommander().refresh(),
                        mainActivity.browserPager.getCurrentItem(),
                        nameToLocate.isEmpty()?null:nameToLocate.get(0));
                dismiss();
            });
        });

        if(type==FileMode.FILE && showAdvancedOptions) advancedOptionsCtv.performClick();
    }

    private void toggleButtons(boolean start) {
        setCancelable(!start);
        ok.setEnabled(!start);
        ok.setText(start?"Creating...":"OK");
    }

    public static boolean doCreate(MainActivity mainActivity, BasePathContent ff, FileMode type) {
        try {
            mainActivity.getFileOpsHelper(ff.providerType).createFileOrDirectory(ff,type);
            MainActivity.showToast(type.name().toLowerCase()+" created");
            return true;
        }
        catch (IOException e) {
            e.printStackTrace();
            MainActivity.showToast("Error creating "+type.name().toLowerCase()+": "+e.getMessage());
            return false;
        }
    }

    public static void resetCreateMode(BrowserAdapter ba, AbsListView lv) {
        if(lv instanceof ListView) {
            if(ba != null && ba.fastCreateModeHeaderView != null) {
                ((ListView) lv).removeHeaderView(ba.fastCreateModeHeaderView);
                ba.fastCreateModeHeaderView = null;
            }
        }
    }

    public static void toggleFastCreateMode(MainActivity mainActivity, FileMode type, boolean status) {
        LayoutInflater inflater = LayoutInflater.from(mainActivity);
        EditText et;
        ListView listView = (ListView) mainActivity.browserPagerAdapter.mainBrowserViews[mainActivity.browserPager.getCurrentItem()];
        // DO NOT call listView.getAdapter(), which returns an adapter wrapper when fast create mode is enabled
        BrowserAdapter ba = mainActivity.getCurrentBrowserAdapter();
        if(status) { // -> ON
            if(ba.fastCreateModeHeaderView != null) {
                MainActivity.showToast("You are already creating a file or directory");
                et = ba.fastCreateModeHeaderView.findViewById(R.id.browserItemFilename_edit);
                listView.setSelection(0);
                et.requestFocus();
                PopupWindowUtils.toggleSoftKeyBoard(et, true);
                return;
            }
            ba.fastCreateModeHeaderView = inflater.inflate(R.layout.browser_item, null);
            ba.fastCreateModeHeaderView.findViewById(R.id.browserItemFilename).setVisibility(View.GONE);
            et = ba.fastCreateModeHeaderView.findViewById(R.id.browserItemFilename_edit);
            et.setVisibility(View.VISIBLE);
            et.setOnEditorActionListener((v, actionId, event) -> {
                // If the event is a key-down event on the "enter" button
                if ((event != null && event.getKeyCode() == KeyEvent.KEYCODE_ENTER) ||
                        (actionId == EditorInfo.IME_ACTION_DONE)) {
                    // Perform action on key press
                    toggleFastCreateMode(mainActivity, type, false);
                    return true;
                }
                return false;
            });
            ImageView iv = ba.fastCreateModeHeaderView.findViewById(R.id.fileTypeImage);
            if(type==FileMode.FILE) {
                iv.setImageResource(android.R.drawable.ic_dialog_info);
                iv.setOnClickListener(v -> {
                    String content = et.getText().toString();
                    et.clearFocus();
                    resetCreateMode(ba, listView);
                    new CreateFileOrDirectoryDialog(mainActivity, type, true, content).show();
                });
            }
            else iv.setImageBitmap(BrowserAdapter.dirIV);

            listView.addHeaderView(ba.fastCreateModeHeaderView);
            listView.setSelection(0);
            et.requestFocus();
            PopupWindowUtils.toggleSoftKeyBoard(et, true);
        }
        else { // -> OFF
            if(ba.fastCreateModeHeaderView != null) {
                et = ba.fastCreateModeHeaderView.findViewById(R.id.browserItemFilename_edit);
                final String filename_ = et.getText().toString();
                BasePathContent ff = mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname().concat(filename_);

                listView.removeHeaderView(ba.fastCreateModeHeaderView);
                ba.fastCreateModeHeaderView = null;
                et.clearFocus(); // fixes "parameter must be a descendant of this view" on legacy Android versions

                if(doCreate(mainActivity, ff, type))
                    mainActivity.runOnUiThread(()-> mainActivity.browserPagerAdapter.showDirContent(
                            mainActivity.getCurrentDirCommander().refresh(),
                            mainActivity.browserPager.getCurrentItem(),
                            filename_));
            }

            View v = mainActivity.getCurrentFocus();
            if (v != null) PopupWindowUtils.toggleSoftKeyBoard(v, false);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/CreateLinkDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.RadioButton;
import android.widget.Toast;

import java.io.IOException;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class CreateLinkDialog extends BaseDialog {

    BasePathContent originPath;
    EditText linkPathEditText;
    Button ok;

    RadioButton isSoftLink,isHardLink;
    final MainActivity mainActivity;

    public CreateLinkDialog(final MainActivity mainActivity, final BasePathContent originPath, final FileMode type) {
        super(mainActivity);
        this.mainActivity = mainActivity;
        this.originPath = originPath;
        setContentView(R.layout.create_link_dialog);
        setDialogIcon(R.drawable.xfiles_link_icon);

        linkPathEditText = findViewById(R.id.linkCreate_targetPath);
        isSoftLink = findViewById(R.id.linkCreate_type_soft);
        isHardLink = findViewById(R.id.linkCreate_type_hard);
        ok = findViewById(R.id.linkCreate_OkButton);

        if(type==FileMode.DIRECTORY) { // allow only symlinks for directories
            isHardLink.setEnabled(false);
        }
        isSoftLink.setChecked(true);

        linkPathEditText.setText(originPath.dir+".link");

        ok.setOnClickListener(this::ok);
    }

    public void ok(View unused) {
        // clone source path, then assign dest path
        final BasePathContent linkPath = originPath.getCopy();
        linkPath.dir = linkPathEditText.getText().toString();
        if (linkPath.dir.isEmpty()) {
            Toast.makeText(mainActivity, "Empty target path provided", Toast.LENGTH_SHORT).show();
            return;
        }

        try {
            mainActivity.getFileOpsHelper(originPath.providerType).createLink(originPath,linkPath,isHardLink.isChecked());
            Toast.makeText(mainActivity, "Link created", Toast.LENGTH_SHORT).show();
            mainActivity.browserPagerAdapter.showDirContent(
                    mainActivity.getCurrentDirCommander().refresh(),
                    mainActivity.browserPager.getCurrentItem(), linkPath.getName());
        }
        catch (IOException e) {
            e.printStackTrace();
            Toast.makeText(mainActivity, "Link creation error, reason: "+e.getMessage(), Toast.LENGTH_SHORT).show();
        }
        dismiss();
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/FilterSelectionDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Activity;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.EditText;

import it.pgp.xfiles.adapters.BrowserAdapter;
import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 26/10/16 (converted inner class to standalone one)
 */
public class FilterSelectionDialog extends BaseDialog {
    public FilterSelectionDialog(final Activity activity, final BrowserAdapter browserAdapter, final boolean selectOrDeselect) {
        super(activity);
        setTitle(selectOrDeselect ? "Filter selection" : "Filter deselection");
        setContentView(R.layout.filter_selection_dialog);
        setDialogIcon(R.drawable.xfiles_find);
        EditText content = findViewById(R.id.singleFilenameEditText);
        CheckedTextView ignoreCase = findViewById(R.id.ignoreCaseCtv);
        ignoreCase.setOnClickListener(Misc.ctvListener);
        Button okButton = findViewById(R.id.singleFilenameOkButton);
        okButton.setOnClickListener(v -> {
            browserAdapter.filterSelection(content.getText().toString(), selectOrDeselect, ignoreCase.isChecked());
            dismiss();
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/GenericChangeDirectoryDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.content.Context;
import android.content.Intent;
import android.os.Build;
import android.view.LayoutInflater;
import android.view.View;
import android.view.Window;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.AutoCompleteTextView;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.Spinner;
import android.widget.Toast;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.concurrent.atomic.AtomicBoolean;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.HTTPDownloadService;
import it.pgp.xfiles.service.params.DownloadParams;
import it.pgp.xfiles.sftpclient.AuthData;
import it.pgp.xfiles.smbclient.SmbAuthData;
import it.pgp.xfiles.utils.FavoritesList;
import it.pgp.xfiles.utils.GenericDBHelper;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.NetworkUtils;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.ArchivePathContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;
import it.pgp.xfiles.utils.pathcontent.SFTPPathContent;
import it.pgp.xfiles.utils.pathcontent.SMBPathContent;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;
import it.pgp.xfiles.utils.wifi.WifiButtonsLayout;
import it.pgp.xfiles.viewmodels.PasteableEditText;
import it.pgp.xfiles.viewmodels.XREDirectoryViewModel;

/**
 * Created by pgp on 14/05/17
 */
public class GenericChangeDirectoryDialog extends Dialog {
    private MainActivity mainActivity;
    LayoutInflater layoutInflater;
    BasePathContent curDirPath;

    final GenericDBHelper dbh;

    // parent layout controls

    RadioGroup pathContentTypeSelector;
    Button okButton;
    LinearLayout containerLayout; // target container for inflating content for different pathContent types

    final LinearLayout.LayoutParams layoutParams = new LinearLayout.LayoutParams(
            LinearLayout.LayoutParams.MATCH_PARENT,
            LinearLayout.LayoutParams.WRAP_CONTENT);

    // aggregated controls mapped to specialized PathContent classes

    // in-archive dir
    EditText inArchivePath;

    // local path common to local and in-archive modes
    AutoCompleteTextView localPath;
    Spinner localStoredData; // same resource label for all path types

    // sftp remote dir
    EditText user;
    EditText domain;
    EditText port;
    EditText password;
    AutoCompleteTextView remotePath;

    FavoritesList<AuthData>[] credsWithFavs;

    final XREDirectoryViewModel xreDirectoryViewModel;

    // smb remote dir
    EditText smbUser;
    EditText smbDomain;
    EditText smbHost;
    EditText smbPort;
    EditText smbPassword;
    AutoCompleteTextView smbRemotePath;

    FavoritesList<SmbAuthData>[] smbCredsWithFavs;

    // http download params
    PasteableEditText httpUrlToDownload;
    EditText httpDestPath; // if empty, take currently shown path in browser view
    EditText httpTargetFilename;
    CheckedTextView httpForceHttps; // -> httpsOnly

    private final AtomicBoolean currentDirAutofillOverride = new AtomicBoolean(true);

    // on Android 11, /data/data is not accessible even with root
    final String datadataPath = Build.VERSION.SDK_INT >= Build.VERSION_CODES.R ? "/data_mirror/data_ce/null/0" : "/data/data";

    private void ok(View unused) {
        okButton.setEnabled(false);
        okButton.setText("Loading...");
        new Thread(this::ok_inner).start();
    }

    // dummy int return, just to avoid writing two lines of code for early returns in invocations of this method
    private int reenableOkButton(Object ret) { // ret is a String in all calls of this method
        mainActivity.runOnUiThread(()->{
            Toast.makeText(mainActivity, ret.toString(), Toast.LENGTH_SHORT).show();
            okButton.setEnabled(true);
            okButton.setText(android.R.string.ok);
        });
        return 0;
    }

    private int ok_inner() {
        BasePathContent path = null;

        // see which pathContent type is currently selected
        int idx = pathContentTypeSelector.indexOfChild(
                pathContentTypeSelector.findViewById(
                        pathContentTypeSelector.getCheckedRadioButtonId()));

        // empty base path means root path (/), so don't validate it
        if (idx < 5) {
            switch (idx) {
                case 0: // LOCAL
                    path = new LocalPathContent(localPath.getText().toString());
                    break;
                case 1: // ARCHIVE
                    path = new ArchivePathContent(
                            localPath.getText().toString(),
                            inArchivePath.getText().toString()
                    );
                    break;
                case 2: // SFTP
                /*
                 TODO call tryConnectAndGetPath, which returns the default remote home
                 (in order, on success, to perform listDir from SftpProvider and update dir commander)
                 and launches error dialogs (host key not found/not valid and auth error -> provide password)
                 accordingly. Otherwise, a SFTPPathContent object needs explicitly a home directory
                 */
                    String ret = XREDirectoryViewModel.basicNonEmptyValidation(user,domain,port);
                    if (!ret.isEmpty()) return reenableOkButton(ret); // password can be empty
                    path = new SFTPPathContent(
                            new AuthData(
                                    user.getText().toString(),
                                    domain.getText().toString(),
                                    Integer.parseInt(port.getText().toString()),
                                    password.getText().toString()
                            ),
                            remotePath.getText().toString()
                    );
                    break;
                case 3: // XFILES_REMOTE
                    ret = XREDirectoryViewModel.basicNonEmptyValidation(xreDirectoryViewModel.xreServerHost);
                    if (!ret.isEmpty()) return reenableOkButton(ret);
                    path = new XREPathContent(
                            xreDirectoryViewModel.xreServerHost.getText().toString(),
//                        Integer.valueOf(xreServerPort.getText().toString()),
                            xreDirectoryViewModel.xreRemotePath.getText().toString()
                    );
                    break;
                case 4: // SMB
                    ret = XREDirectoryViewModel.basicNonEmptyValidation(smbUser,smbDomain,smbHost,smbPort,smbPassword);
                    if (!ret.isEmpty()) return reenableOkButton(ret); // password cannot be empty (no pubkey authentication for SMB)
                    path = new SMBPathContent(
                            new SmbAuthData(
                                    smbUser.getText().toString(),
                                    smbDomain.getText().toString(),
                                    smbHost.getText().toString(),
                                    Integer.parseInt(smbPort.getText().toString()),
                                    smbPassword.getText().toString()
                            ),
                            smbRemotePath.getText().toString()
                    );
                    break;

            }
            final int targetViewPagerPosition = mainActivity.browserPager.getCurrentItem();
            GenericDirWithContent gdwc = mainActivity.goDir_inner(path);
            FileOpsErrorCodes fe = gdwc.errorCode;
            mainActivity.runOnUiThread(()-> {
                if (fe == null || fe == FileOpsErrorCodes.OK) dismiss();
                else reenableOkButton(fe);
            });
            mainActivity.completeGoDir(gdwc,path,targetViewPagerPosition,null);
        }
        else if (idx == 5) {
            // if we're not trying to download from a local url...
            boolean isLocalUrl = false;
            try {
                URI uri = new URI(httpUrlToDownload.getText().toString());
                String s = uri.getHost();
                isLocalUrl = s.startsWith("127.0.0.1") || s.startsWith("localhost");
            }
            catch (URISyntaxException e) {
                e.printStackTrace();
            }
            // ...check whether there's some connection enabled first
            if(!isLocalUrl && !(Misc.isDataConnectionEnabled(mainActivity) ||
                    Misc.isWifiEnabled(mainActivity) ||
                    Misc.isHotspotEnabled(mainActivity))) {
                mainActivity.runOnUiThread(() -> {
                    okButton.setEnabled(true);
                    okButton.setText(android.R.string.ok);
                    Toast.makeText(mainActivity, "Please enable some data connection in order to download", Toast.LENGTH_SHORT).show();
                });
                return 0;
            }

            // start download service
            Intent startIntent = new Intent(mainActivity,HTTPDownloadService.class);
            startIntent.setAction(BaseBackgroundService.START_ACTION);
            startIntent.putExtra("params",
                    new DownloadParams(
                            httpUrlToDownload.getText().toString(),
                            httpDestPath.getText().toString(),
                            httpTargetFilename.getText().toString(),
                            httpForceHttps.isChecked()
                            ));
            mainActivity.startService(startIntent);
            dismiss();
        }
        else throw new RuntimeException("Unexpected selector index");

        return 0;
    }

    public void setLayout(ProviderType providerType, BasePathContent... currentDir) {
        // inflate specialized layouts
        containerLayout = findViewById(R.id.pathContentTypeContainerLayout);
        containerLayout.removeAllViews();
        containerLayout.setLayoutParams(layoutParams);

        View targetLayout;

        switch(providerType) {
            case LOCAL:
                targetLayout = layoutInflater.inflate(R.layout.change_directory_dialog_frame_local, null);
                containerLayout.addView(targetLayout);
                localPath = findViewById(R.id.localDirEditText);
                localStoredData = findViewById(R.id.storedDataSpinner);
                break;
            case LOCAL_WITHIN_ARCHIVE:
                targetLayout = layoutInflater.inflate(R.layout.change_directory_dialog_frame_archive, null);
                containerLayout.addView(targetLayout);
                localPath = findViewById(R.id.archivePathnameEditText);
                localStoredData = findViewById(R.id.storedDataSpinner);
                inArchivePath = findViewById(R.id.archiveSubDirEditText);
                break;
            case SFTP:
                targetLayout = layoutInflater.inflate(R.layout.change_directory_dialog_frame_sftp, null);
                containerLayout.addView(targetLayout);
                localStoredData = findViewById(R.id.storedDataSpinner);
                user = findViewById(R.id.connectionUserEditText);
                password = findViewById(R.id.connectionPasswordEditText);
                domain = findViewById(R.id.connectionDomainEditText);
                port = findViewById(R.id.connectionPortEditText);
                port.setText(R.string.ssh_default_port);
                remotePath = findViewById(R.id.remoteDirEditText);
                break;
            case XFILES_REMOTE:
                targetLayout = layoutInflater.inflate(R.layout.change_directory_dialog_frame_xre, null);
                containerLayout.addView(targetLayout);
                xreDirectoryViewModel.initViews();
                break;
            case SMB:
                targetLayout = layoutInflater.inflate(R.layout.change_directory_dialog_frame_smb, null);
                containerLayout.addView(targetLayout);
                localStoredData = findViewById(R.id.storedDataSpinner);
                smbUser = findViewById(R.id.connectionUserEditText);
                smbPassword = findViewById(R.id.connectionPasswordEditText);
                smbDomain = findViewById(R.id.connectionDomainEditText);
                smbHost = findViewById(R.id.connectionHostEditText);
                smbPort = findViewById(R.id.connectionPortEditText);
                smbPort.setText(R.string.smb_default_port);
                smbRemotePath = findViewById(R.id.remoteDirEditText);
                break;
            case URL_DOWNLOAD:
                targetLayout = layoutInflater.inflate(R.layout.change_directory_dialog_frame_http, null);
                containerLayout.addView(targetLayout);
                httpUrlToDownload = findViewById(R.id.httpUrlEditText);
                httpDestPath = findViewById(R.id.httpDestDirEditText);
                httpTargetFilename = findViewById(R.id.httpTargetFilenameEditText);
                httpUrlToDownload.setText("https://");
                httpForceHttps = findViewById(R.id.httpForceHttpsCheckbox);
                httpForceHttps.setOnClickListener(Misc.ctvListener);
                break;
            default:
                throw new RuntimeException("Unknown subtype layout");
        }

        switch(providerType) {
            case LOCAL:
            case LOCAL_WITHIN_ARCHIVE:
                // autocomplete stuff
                ArrayList<String> lItems = new ArrayList<>(Arrays.asList(
                        "", // empty item for no selection
                        Misc.internalStorageDir.getAbsolutePath(),
                        mainActivity.getFilesDir().getAbsolutePath(), // xfiles app private dir
                        "/data/app",
                        datadataPath,
                        "/data/local/tmp"));
                lItems.addAll(dbh.getAllRowsOfLocalFavoritesTable().values());
                ArrayAdapter<String> lAdapter = new ArrayAdapter<>(
                        mainActivity,
                        android.R.layout.select_dialog_item,
                        lItems);
                localPath.setAdapter(lAdapter);
                localPath.setOnClickListener(v -> localPath.showDropDown());
                ArrayAdapter<String> lAdapterForSpinner = new ArrayAdapter<>(
                        mainActivity,
                        android.R.layout.simple_spinner_dropdown_item,
                        lItems);
                localStoredData.setAdapter(lAdapterForSpinner);
                localStoredData.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
                    @Override
                    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                        if (currentDirAutofillOverride.get()) {
                            currentDirAutofillOverride.set(false);
                            return;
                        }
                        localPath.setText((String)parent.getItemAtPosition(position));
                    }

                    @Override
                    public void onNothingSelected(AdapterView<?> parent) {}
                });
                break;
            case SFTP:
                // fill spinner from database
                ArrayList<String> items = new ArrayList<>();

//                Collection cwf = dbh.getAllSftpCredsWithFavs().values();
                Collection cwf = dbh.getAllCredsWithFavs(AuthData.ref).values();
                credsWithFavs = (FavoritesList<AuthData>[]) cwf.toArray(new FavoritesList[0]);

                // add empty spinner for no selection
                items.add("");
                for (FavoritesList<AuthData> awf : credsWithFavs) items.add(awf.a.toString());
                ArrayAdapter<String> adapter = new ArrayAdapter<>(mainActivity, android.R.layout.simple_spinner_dropdown_item, items);
                localStoredData.setAdapter(adapter);
                //////////////////////////////
                localStoredData.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
                    @Override
                    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                        if (currentDirAutofillOverride.get()) {
                            currentDirAutofillOverride.set(false);
                            return;
                        }

                        // query database with that (user,domain,port) tuple, get password, and fill fields
                        String item = (String) parent.getItemAtPosition(position);
                        if (item.equals("")) {
                            user.setText("");
                            password.setText("");
                            domain.setText("");
                            port.setText(R.string.ssh_default_port);
                            return;
                        }

//                        AuthData a = dbh.find(new AuthData(item));
//                        if (a == null) return;

                        // no db update expected from this dialog, use adapter position to access data
                        AuthData a = credsWithFavs[position-1].a; // pos-1 cause first item is empty item
                        user.setText(a.username);
                        if (a.password != null) password.setText(a.password);
                        domain.setText(a.domain);
                        port.setText(a.port+"");

                        // populate auto-complete list for remote path's AutoCompleteTextView
                        Collection paths = credsWithFavs[position-1].paths; // pos-1: idem as before
                        String[] autoCompleteSupport = (paths!=null)?(String[])paths.toArray(new String[0]):new String[0];

                        ArrayAdapter<String> autoCompleteAdapter = new ArrayAdapter<>(
                                mainActivity,
                                android.R.layout.select_dialog_item,
                                autoCompleteSupport);
                        remotePath.setAdapter(autoCompleteAdapter);
                    }

                    @Override
                    public void onNothingSelected(AdapterView<?> parent) {}
                });
                remotePath.setThreshold(1); // auto-completing from first character
                remotePath.setOnClickListener(v -> remotePath.showDropDown());
                break;
            case XFILES_REMOTE:
                // initViews() already called in viewmodel
                break;
            case SMB:
                items = new ArrayList<>();

                cwf = dbh.getAllCredsWithFavs(SmbAuthData.ref).values();
                smbCredsWithFavs = (FavoritesList<SmbAuthData>[]) cwf.toArray(new FavoritesList[0]);

                // add empty spinner for no selection
                items.add("");
                for (FavoritesList<SmbAuthData> awf : smbCredsWithFavs) items.add(awf.a.toString());
                adapter = new ArrayAdapter<>(mainActivity, android.R.layout.simple_spinner_dropdown_item, items);
                localStoredData.setAdapter(adapter);
                //////////////////////////////
                localStoredData.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
                    @Override
                    public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                        if (currentDirAutofillOverride.get()) {
                            currentDirAutofillOverride.set(false);
                            return;
                        }

                        // query database with that (user,domain,port) tuple, get password, and fill fields
                        String item = (String) parent.getItemAtPosition(position);
                        if (item.equals("")) {
                            smbUser.setText("");
                            smbPassword.setText("");
                            smbDomain.setText(R.string.smb_default_domain);
                            smbHost.setText("");
                            smbPort.setText(R.string.smb_default_port);
                            return;
                        }

                        // no db update expected from this dialog, use adapter position to access data
                        SmbAuthData a = smbCredsWithFavs[position-1].a; // pos-1 cause first item is empty item
                        smbUser.setText(a.username);
                        if (a.password != null) smbPassword.setText(a.password);
                        smbDomain.setText(a.domain);
                        smbHost.setText(a.host);
                        smbPort.setText(a.port+"");

                        // populate auto-complete list for remote path's AutoCompleteTextView
                        Collection paths = smbCredsWithFavs[position-1].paths; // pos-1: idem as before
                        String[] autoCompleteSupport = (paths!=null)?(String[])paths.toArray(new String[0]):new String[0];

                        ArrayAdapter<String> autoCompleteAdapter = new ArrayAdapter<>(
                                mainActivity,
                                android.R.layout.select_dialog_item,
                                autoCompleteSupport);
                        smbRemotePath.setAdapter(autoCompleteAdapter);
                    }

                    @Override
                    public void onNothingSelected(AdapterView<?> parent) {}
                });
                smbRemotePath.setThreshold(1); // auto-completing from first character
                smbRemotePath.setOnClickListener(v -> smbRemotePath.showDropDown());
                break;
            // useless to insert throw branch here, already thrown if necessary in previous switch construct
        }

        // populate fields with current path content on dialog open
        if (currentDir.length > 0) {
            switch (currentDir[0].providerType) {
                case LOCAL:
                    localPath.setText(currentDir[0].dir);
                    break;
                case LOCAL_WITHIN_ARCHIVE:
                    ArchivePathContent apc = (ArchivePathContent)currentDir[0];
                    localPath.setText(apc.archivePath);
                    inArchivePath.setText(apc.dir);
                    break;
                case SFTP:
                    SFTPPathContent rpc = (SFTPPathContent)currentDir[0];
                    if (rpc.authData != null) {
                        user.setText(rpc.authData.username==null?"":rpc.authData.username);
                        // ignore setText of password, which may not be present, AuthData hashcode ignores it, so on login attempt, if any credential is present, it will work anyway
                        domain.setText(rpc.authData.domain==null?"":rpc.authData.domain);
                        port.setText(rpc.authData.port==0?"":rpc.authData.port+"");
                    }
                    remotePath.setText(rpc.dir);
                    break;
                case XFILES_REMOTE:
                    XREPathContent xrpc = (XREPathContent)currentDir[0];
                    xreDirectoryViewModel.xreServerHost.setText(xrpc.serverHost);
                    xreDirectoryViewModel.xreRemotePath.setText(xrpc.dir);
                    break;
                case SMB:
                    SMBPathContent srpc = (SMBPathContent) currentDir[0];
                    if (srpc.smbAuthData != null) {
                        user.setText(srpc.smbAuthData.username==null?"":srpc.smbAuthData.username);
                        // ignore setText of password, which may not be present, SmbAuthData hashcode ignores it, so on login attempt, if any credential is present, it will work anyway
                        smbDomain.setText(srpc.smbAuthData.domain==null?"":srpc.smbAuthData.domain);
                        smbHost.setText(srpc.smbAuthData.host==null?"":srpc.smbAuthData.host);
                        smbPort.setText(srpc.smbAuthData.port==0?"":srpc.smbAuthData.port+"");
                    }
                    smbRemotePath.setText(srpc.dir);
                    break;
            }
        }

        ((RadioButton)pathContentTypeSelector.getChildAt(providerType.ordinal())).setChecked(true);

        if(providerType == ProviderType.XFILES_REMOTE)
            NetworkUtils.startXreAnnounceListenerThread(MainActivity.mainActivity,xreDirectoryViewModel.xreAnnouncesAdapter);
        else NetworkUtils.shutdownMulticastListening();
    }

    public GenericChangeDirectoryDialog(MainActivity mainActivity, BasePathContent curDirPath) {
        super(mainActivity);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        MainActivity.cdd = this;
        this.mainActivity = mainActivity;
        this.curDirPath = curDirPath;
        dbh = new GenericDBHelper(mainActivity);
        layoutInflater = (LayoutInflater) mainActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);

        xreDirectoryViewModel = new XREDirectoryViewModel(mainActivity, this, dbh, currentDirAutofillOverride);

        setContentView(R.layout.change_directory_generic_dialog);
        pathContentTypeSelector = findViewById(R.id.pathContentRadioGroup);
        setLayout(curDirPath.providerType,curDirPath);

        pathContentTypeSelector.setOnCheckedChangeListener((group, checkedId) -> {
            int idx = pathContentTypeSelector.indexOfChild(
                    pathContentTypeSelector.findViewById(
                            pathContentTypeSelector.getCheckedRadioButtonId()));

            setLayout(ProviderType.values()[idx]); // reverse ordinal
        });

        okButton = findViewById(R.id.changeDirOkButton);
        okButton.setOnClickListener(this::ok);

        WifiButtonsLayout wbl = new WifiButtonsLayout(mainActivity);
        LinearLayout target = findViewById(R.id.targetWifiButtonsLayout);
        target.addView(wbl);

        wbl.registerListeners();
        setOnDismissListener(dialog->{
            wbl.unregisterListeners();
            MainActivity.cdd = null;
            NetworkUtils.shutdownMulticastListening();
        });
    }

}

```

`app/src/main/java/it/pgp/xfiles/dialogs/ImmersiveModeDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.content.Context;
import android.view.WindowManager;

/**
 * Created by pgp on 26/10/16
 */

public class ImmersiveModeDialog extends Dialog {
    public ImmersiveModeDialog(Context context) {
        super(context);
    }

    @Override
    public void show() {
        // Set the dialog to not focusable.
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE);

//        copySystemUiVisibility();
//        web source: http://stackoverflow.com/questions/22794049/how-to-maintain-the-immersive-mode-in-dialogs

        // Show the dialog with NavBar hidden.
        super.show();

        // Set the dialog to focusable again.
        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE);
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/InsertEditLocalFavoritesDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.content.Context;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.LocalFavoritesAdapter;
import it.pgp.xfiles.sftpclient.InsertFailedException;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 26/10/16 (converted inner class to standalone one)
 */
public class InsertEditLocalFavoritesDialog extends ImmersiveModeDialog {
    private EditText fullPath;
    private Button ok;
    private GenericDBHelper dbh;

    // insert mode
    public InsertEditLocalFavoritesDialog(final Context context,
                                          final LocalFavoritesAdapter adapter) {
        super(context);
        setContentView(R.layout.single_filename_dialog);
        setTitle("Add local favorite");
        dbh = new GenericDBHelper(context);
        fullPath = findViewById(R.id.singleFilenameEditText);
        ok = findViewById(R.id.singleFilenameOkButton);

        ok.setOnClickListener(v -> {
            try {
                // TODO validate path content
                Map.Entry<Long,String> entry = dbh.addLocalFavorite(fullPath.getText().toString());
                Toast.makeText(context, "Favorite added", Toast.LENGTH_SHORT).show();
                adapter.syncInsertFromDialog(entry.getKey(),entry.getValue());
                dismiss();
            }
            catch (InsertFailedException e) {
                Toast.makeText(context, "Favorite already exists", Toast.LENGTH_SHORT).show();
            }
        });
    }

    // edit mode
    public InsertEditLocalFavoritesDialog(final Context context,
                                          final LocalFavoritesAdapter adapter,
                                          final long currentOid,
                                          final String currentPath) {
        super(context);
        setContentView(R.layout.single_filename_dialog);
        setTitle("Add local favorite");
        dbh = new GenericDBHelper(context);
        fullPath = findViewById(R.id.singleFilenameEditText);
        fullPath.setText(currentPath);
        ok = findViewById(R.id.singleFilenameOkButton);

        ok.setOnClickListener(v -> {
            // TODO validate path content
            String newPath = fullPath.getText().toString();
            if (newPath.equals(currentPath)) {
                Toast.makeText(context, "Old path not modified", Toast.LENGTH_SHORT).show();
                return;
            }

            if (dbh.updateLocalFavorite(currentPath,newPath)) {
                Toast.makeText(context, "Favorite updated", Toast.LENGTH_SHORT).show();
                // notify dataset changed in adapter (same oid)
                adapter.syncEditFromDialog(currentOid,currentOid,currentPath,newPath);
                dismiss();
            }
            else {
                Toast.makeText(context, "Favorite update error", Toast.LENGTH_SHORT).show();
            }
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/InsertEditSftpFavoritesDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.content.Context;
import android.support.annotation.Nullable;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.SftpFavoritesAdapter;
import it.pgp.xfiles.utils.FavoritesList;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 05/07/17
 * Insert and edit mode are equal here, they both translate into an update to the serialized list blob
 * of an existing sftp/smb credential record
 */

public class InsertEditSftpFavoritesDialog extends Dialog {

    // Edit mode if currentFavoritePath non null, insert mode otherwise
    // currentFavoritePath is a member of currentFavorites list
    // currentFavorites list is updated before serialization, by replacing currentFavoritePath with
    // the content of the EditText
    // currentFavoritePath is unique
    // currentFavorites is a reference contained in the sfdbMap, so its modification
    // need not be explicitly passed back, it is sufficent to refill the positional arrays in syncEditFromDialog
    public InsertEditSftpFavoritesDialog(
            final Object ref,
            final Context context,
            final SftpFavoritesAdapter adapter,
            final long currentOid,
            final FavoritesList currentFavorites,
            final @Nullable String currentFavoritePath) {
        super(context);
        setContentView(R.layout.single_filename_dialog);
        EditText favorite = findViewById(R.id.singleFilenameEditText);
        if (currentFavoritePath != null)
            favorite.setText(currentFavoritePath);

        Button ok = findViewById(R.id.singleFilenameOkButton);
        ok.setOnClickListener(v -> {
            GenericDBHelper dbh = new GenericDBHelper(context);
            // update favorites list: remove old path if not null, insert new
            if (currentFavoritePath != null)
                currentFavorites.paths.remove(currentFavoritePath);
            currentFavorites.paths.add(favorite.getText().toString());

            // update only, leave oid unchanged
//            if (dbh.updateSftpFavs(currentOid,currentFavorites.paths)) {
            if (dbh.updateFavs(ref,currentOid,currentFavorites.paths)) {
                // update visualization
                adapter.syncEditFromDialog();
                Toast.makeText(context,"Edit successful",Toast.LENGTH_SHORT).show();
            }
            else {
                Toast.makeText(context,"Edit failed",Toast.LENGTH_SHORT).show();
            }
            dismiss();
        });

    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/InsertEditXreFavoritesDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.content.Context;
import android.widget.Button;
import android.widget.EditText;
import android.widget.Toast;

import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.XreFavoritesAdapter;
import it.pgp.xfiles.sftpclient.InsertFailedException;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 22/09/17 (adapted from {@link InsertEditLocalFavoritesDialog})
 */
public class InsertEditXreFavoritesDialog extends ImmersiveModeDialog {
    private EditText fullPath;
    private EditText fullServer;
    private Button ok;
    private GenericDBHelper dbh;

    // insert mode
    public InsertEditXreFavoritesDialog(final Context context,
                                        final XreFavoritesAdapter adapter) {
        super(context);
        setContentView(R.layout.xre_path_dialog);
        setTitle("Add XFiles remote favorite");
        dbh = new GenericDBHelper(context);
        fullServer = findViewById(R.id.xre_server_edittext);
        fullPath = findViewById(R.id.xre_path_edittext);
        ok = findViewById(R.id.xre_ok_button);

        ok.setOnClickListener(v -> {
            try {
                // TODO validate path content
                Map.Entry<Long,Map.Entry<String,String>> entry = dbh.addXreFavorite(
                        fullServer.getText().toString(),
                        fullPath.getText().toString());
                Toast.makeText(context, "Favorite added", Toast.LENGTH_SHORT).show();
                adapter.syncInsertFromDialog(
                        entry.getKey(),
                        entry.getValue().getKey(),
                        entry.getValue().getValue()
                        );
                dismiss();
            }
            catch (InsertFailedException e) {
                Toast.makeText(context, "Favorite already exists", Toast.LENGTH_SHORT).show();
            }
        });
    }

    // edit mode
    public InsertEditXreFavoritesDialog(final Context context,
                                        final XreFavoritesAdapter adapter,
                                        final long currentOid,
                                        final String currentServer,
                                        final String currentPath) {
        super(context);
        setContentView(R.layout.xre_path_dialog);
        setTitle("Add XFiles remote favorite");
        dbh = new GenericDBHelper(context);
        fullServer = findViewById(R.id.xre_server_edittext);
        fullPath = findViewById(R.id.xre_path_edittext);
        fullServer.setText(currentServer);
        fullPath.setText(currentPath);

        ok = findViewById(R.id.xre_ok_button);

        ok.setOnClickListener(v -> {
            // TODO validate path content
            String newServer = fullServer.getText().toString();
            String newPath = fullPath.getText().toString();
            if (newServer.equals(currentServer) && newPath.equals(currentPath)) {
                Toast.makeText(context, "Old data not modified", Toast.LENGTH_SHORT).show();
                return;
            }

            if (dbh.updateXreFavorite(
                    currentServer,
                    newServer,
                    currentPath,
                    newPath)) {
                Toast.makeText(context, "Favorite updated", Toast.LENGTH_SHORT).show();
                // notify dataset changed in adapter (same oid)
                adapter.syncEditFromDialog(
                        currentOid,
                        currentOid,
                        currentServer,
                        newServer,
                        currentPath,
                        newPath);
                dismiss();
            }
            else {
                Toast.makeText(context, "Favorite update error", Toast.LENGTH_SHORT).show();
            }
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/OpenAsDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Activity;
import android.app.Dialog;
import android.content.Intent;
import android.net.Uri;
import android.widget.Button;
import android.widget.ListView;
import android.widget.SimpleAdapter;

import java.io.File;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import it.pgp.xfiles.R;

/**
 * Created by pgp on 26/10/16 (converted inner class to standalone one)
 */
public class OpenAsDialog extends Dialog {

    private static final String[] columnTags = new String[]{"image", "label"};
    private static final int[] columnIds = new int[]{R.id.openAsTypeImage, R.id.openAsTypeName};

    private static final String[] openAsMIMETypes = {"text/plain", "image/*", "audio/*", "video/*", "application/x-compressed", "*/*"};

    private static final String[] openAsLabels = {"Text", "Image", "Audio", "Video", "Archive", "Any"};
    private static final int[] openAsDrawables = {R.drawable.xfiles_text, R.drawable.xfiles_image,
            R.drawable.xfiles_audio, R.drawable.xfiles_video,
            R.drawable.xfiles_archive, R.drawable.xfiles_anytype};

    public OpenAsDialog(final Activity activityContext, final File file) {
        super(activityContext);
        setTitle("Open as");
        setContentView(R.layout.open_as_dialog);
        Button openAsCancelButton = findViewById(R.id.openAsCancelButton);
        openAsCancelButton.setOnClickListener(v -> dismiss());

        ListView openAsListView = findViewById(R.id.openAsListView);

        List<Map<String, String>> openAsListData = new ArrayList<>();
        for (int i = 0; i < openAsLabels.length; i++) {
            Map<String, String> h = new HashMap<>();
            h.put(columnTags[0], "" + openAsDrawables[i]);
            h.put(columnTags[1], openAsLabels[i]);
            openAsListData.add(h);
        }

        SimpleAdapter openAsAdapter = new SimpleAdapter(activityContext, openAsListData, R.layout.open_as_dialog_item, columnTags, columnIds);
        openAsListView.setAdapter(openAsAdapter);

        openAsListView.setOnItemClickListener((parent, view, position, id) -> {
            Uri uri = Uri.fromFile(file);
//                Uri uri = FileProvider.getUriForFile(activityContext,
//                        BuildConfig.APPLICATION_ID + ".provider",
//                        file);
            Intent intent = new Intent(Intent.ACTION_VIEW);
            intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);
            intent.setDataAndType(uri, openAsMIMETypes[position]);
            //  intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            activityContext.startActivity(intent);
            dismiss();
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/PropertiesDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.app.Activity;
import android.view.View;
import android.widget.Button;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.TextView;
import android.widget.Toast;

import java.util.List;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.roothelperclient.resps.folderStats_resp;
import it.pgp.xfiles.utils.FileOperationHelper;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 26/10/16 (converted inner class to standalone one)
 */
public class PropertiesDialog extends Dialog {

    private TextView childrenFiles,childrenFolders,totalFiles,totalFolders,totalSize;
    private SingleStatsItem stats;
    private folderStats_resp statsFolderOrMultipleItems;

    private LinearLayout singleItemLayout;
    private LinearLayout aggregatesLayout;
    private ProgressBar progressCircle;

    // Constructor for showing properties of a single file or a single folder
    // TODO maybe it's better to inherit a FolderPropertiesDialog from this
    public PropertiesDialog(final Activity activity, FileMode fileMode, List<BasePathContent> pathname_) {
        super(activity);
        setContentView(R.layout.properties_file_dialog);

        singleItemLayout = findViewById(R.id.propertiesSingleItemLayout);
        aggregatesLayout = findViewById(R.id.propertiesAggregatesLayout);
        progressCircle = findViewById(R.id.progressCircle);

        if (pathname_.size() != 1) {
            setTitle("Multiple items properties");
            singleItemLayout.setVisibility(View.GONE);
        }
        else {
            if (fileMode==FileMode.DIRECTORY) {
                setTitle("Directory properties"); // do not hide any sub-layout
            }
            else {
                setTitle("File properties");
                aggregatesLayout.setVisibility(View.GONE); // hide aggregates layout
            }
        }

        TextView pathname;
        TextView size;
        TextView created;
        TextView modified;
        TextView lastAccessed;
        TextView permissions;
        TextView owner;
        TextView group;

        FileMode fm_ = fileMode == null ? FileMode.DIRECTORY : fileMode;
        switch (fm_) {
            case DIRECTORY:
                childrenFiles = findViewById(R.id.propertiesChildrenFilesTextView);
                childrenFolders = findViewById(R.id.propertiesChildrenFoldersTextView);
                totalFiles = findViewById(R.id.propertiesTotalFilesTextView);
                totalFolders = findViewById(R.id.propertiesTotalFoldersTextView);
                totalSize = findViewById(R.id.propertiesTotalSizeTextView);
                // no break here, file layout elements are in common
            case FILE:
                pathname = findViewById(R.id.propertiesFileNameTextView);
//                TextView type = findViewById(R.id.propertiesFileTypeTextView);
                size = findViewById(R.id.propertiesFileSizeTextView);
                created = findViewById(R.id.propertiesFileDateCreatedTextView);
                modified = findViewById(R.id.propertiesFileDateLastModifiedTextView);
                lastAccessed = findViewById(R.id.propertiesFileDateLastAccessTextView);
                permissions = findViewById(R.id.propertiesPermissionsTextView);
                owner = findViewById(R.id.propertiesOwnerTextView);
                group = findViewById(R.id.propertiesGroupTextView);
                Button closeButton = findViewById(R.id.propertiesDismissButton);
                closeButton.setOnClickListener(view -> dismiss());
                break;
            default:
                throw new RuntimeException("Unknown operation mode, only dir and file allowed");
        }

        new Thread(() -> {
            Exception[] lastException = {null};
            try {
                BasePathContent firstPath = pathname_.get(0);
                FileOperationHelper helper = MainActivity.mainActivity.getFileOpsHelper(firstPath.providerType);
                if (pathname_.size() != 1) // ignore filemode, stats multiple items
                    statsFolderOrMultipleItems = helper.statFiles(pathname_);
                else {
                    stats = helper.statFile(firstPath);
                    if (fileMode == FileMode.DIRECTORY)
                        statsFolderOrMultipleItems = helper.statFolder(firstPath);
                }
            }
            catch (Exception e) {
                e.printStackTrace();
                lastException[0] = e;
            }
            activity.runOnUiThread(() -> {
                if(lastException[0] != null)
                    Toast.makeText(activity, "Generic stats error, reason: "+lastException[0].getMessage(), Toast.LENGTH_SHORT).show();
                else if (statsFolderOrMultipleItems == null && fileMode != FileMode.FILE) {
                    Toast.makeText(activity, "Unknown error on stat folder or multiple items", Toast.LENGTH_SHORT).show();
                }
                else {
                    if (pathname_.size() == 1) {
                        pathname.setText(pathname_.get(0).toString());
                        // TODO type setText MIME type
                        size.setText(""+stats.size);
                        created.setText(""+stats.creationTime);
                        modified.setText(""+stats.modificationTime);
                        lastAccessed.setText(""+stats.lastAccessTime);
                        permissions.setText(stats.permissions);
                        owner.setText(stats.owner);
                        group.setText(stats.group);
                    }

                    if (pathname_.size() != 1 || fileMode == FileMode.DIRECTORY) {
                        childrenFiles.setText(""+ statsFolderOrMultipleItems.childrenFiles);
                        childrenFolders.setText(""+ statsFolderOrMultipleItems.childrenDirs);
                        totalFiles.setText(""+ statsFolderOrMultipleItems.totalFiles);
                        totalFolders.setText(""+ statsFolderOrMultipleItems.totalDirs);
                        totalSize.setText(""+ statsFolderOrMultipleItems.totalSize);
                    }
                }
                progressCircle.setVisibility(View.GONE);
            });
        }).start();
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/RamdiskDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.os.Build;
import android.text.InputType;
import android.widget.Button;
import android.widget.EditText;

import java.io.File;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.roothelperclient.RootHandler;

public class RamdiskDialog extends ImmersiveModeDialog {
    public static final String mountpath = "/data/local/tmp/devshm";

    public RamdiskDialog(MainActivity mainActivity) {
        super(mainActivity);
        setContentView(R.layout.single_filename_dialog);
        setTitle("Ramdisk");
        EditText size_ = findViewById(R.id.singleFilenameEditText);
        Button ok = findViewById(R.id.singleFilenameOkButton);
        size_.setRawInputType(InputType.TYPE_CLASS_NUMBER);
        size_.setText("500");

        ok.setOnClickListener(v -> {
            int sz;
            String commands;
            try {
                sz = Integer.parseInt(size_.getText().toString());
                if(sz == 0) { // Unmount existing
                    commands = "umount "+mountpath+" && rm -rf "+mountpath;
                }
                else {
                    String size = size_.getText().toString() + "m";
                    commands = (Build.VERSION.SDK_INT < Build.VERSION_CODES.M ? "" : "setenforce 0 && ")+
                            "mkdir -p "+mountpath+" && chmod 777 "+mountpath+
                            " && mount -t tmpfs xfilesramdisk "+mountpath+" -o mode=0777,size="+size;
                }
            }
            catch(Exception e) {
                MainActivity.showToast("Error getting ramdisk size: "+e.getMessage());
                return;
            }

            try {
                Process p = RootHandler.executeCommandSimple(commands, new File("/"), true, false);
                int ret = p.waitFor();
                if(ret != 0) throw new Exception("Non-zero return value "+ret);
            }
            catch(Exception e) {
                MainActivity.showToast("Error creating or unmounting ramdisk: "+e.getMessage());
                return;
            }
            MainActivity.showToast(sz == 0 ? "Ramdisk unmounted" : "Ramdisk of size "+sz+" Mb created at "+mountpath);
            dismiss();
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/RemoteRHServerManagementDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Activity;
import android.app.Dialog;
import android.support.annotation.NonNull;
import android.view.View;
import android.view.Window;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.TextView;
import android.widget.Toast;

import java.util.Observable;
import java.util.Observer;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.fileservers.FileServer;
import it.pgp.xfiles.fileservers.SimpleFileServer;
import it.pgp.xfiles.roothelperclient.RHSSServerStatus;
import it.pgp.xfiles.roothelperclient.RemoteServerManager;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.NetworkUtils;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;
import it.pgp.xfiles.utils.wifi.WifiButtonsLayout;

/**
 * Created by pgp on 13/10/17
 */

public class RemoteRHServerManagementDialog extends Dialog {
    private ImageButton rhss_show_xre_connections;

    private EditText xreHomePath;
    private EditText xreAnnouncedPath;
    private EditText xreExposedPath;
    private ImageButton xreSetHomePath;
    private ImageButton xreSetAnnouncedPath;
    private ImageButton xreSetExposedPath;

    private EditText ftpHttpRootPath;

    private CheckedTextView rhssSendXreAnnounceCtv;
    public final IfAddrsObserver ifAddrsObserver;

    private BasePathContent currentDir;

    public class IfAddrsObserver implements Observer {

        private final TextView rhssIPAddresses;

        private final Button ftpServerButton;
        private final Button httpServerButton;
        private final ImageButton rhss_status_button;

        private final boolean[] state = new boolean[3]; // FTP, HTTP, XRE (first two are FileServer enum values)

        private boolean anyOn() {
            boolean res = false;
            for(boolean x : state)
                res |= x;
            return res;
        }

        public IfAddrsObserver() {
            rhssIPAddresses = findViewById(R.id.rhssIPAddresses);

            ftpServerButton = findViewById(R.id.ftpServerButton);
            httpServerButton = findViewById(R.id.httpServerButton);
            rhss_status_button = findViewById(R.id.rhss_toggle_rhss_button);
            rhss_status_button.setOnClickListener(RemoteRHServerManagementDialog.this::switch_rhss_status);

            state[0] = FileServer.FTP.server.isAlive();
            state[1] = FileServer.HTTP.server.isAlive();
            state[2] = RemoteServerManager.rhssManagerRef.get()!=null;
            updateViews(null);
        }

        private void updateViews(Pair<Integer, Boolean> on) {
            activity.runOnUiThread(()->{
                rhssIPAddresses.setText(anyOn()?NetworkUtils.getInterfaceAddressesAsString():"");

                if(on==null) { // on dialog constructor, set all views
                    ftpServerButton.setTextColor(activity.getResources().getColor(state[0]? R.color.green:R.color.red));
                    httpServerButton.setTextColor(activity.getResources().getColor(state[1]? R.color.green:R.color.red));
                    rhss_status_button.setImageResource(state[2]?R.drawable.xf_xre_server_up:R.drawable.xf_xre_server_down);
                }
                else switch(on.i) {
                    case 0:
                        ftpServerButton.setTextColor(activity.getResources().getColor(on.j? R.color.green:R.color.red));
                        break;
                    case 1:
                        httpServerButton.setTextColor(activity.getResources().getColor(on.j? R.color.green:R.color.red));
                        break;
                    case 2:
                        rhss_status_button.setImageResource(on.j?R.drawable.xf_xre_server_up:R.drawable.xf_xre_server_down);
                        break;
                }
            });
        }

        @Override
        public void update(Observable o, Object arg) {
            Pair<Integer, Boolean> on = (Pair) arg;
            state[on.i] = on.j;
            updateViews(on);
        }
    }

    private final View.OnClickListener setCurrentDirectoryListener = v -> {
        EditText targetEditText;
        switch(v.getId()) {
            case R.id.setXreHomePathToCurrent:
                targetEditText = xreHomePath;
                break;
            case R.id.setXreAnnouncedPathToCurrent:
                targetEditText = xreAnnouncedPath;
                break;
            case R.id.setXreExposedPathToCurrent:
                targetEditText = xreExposedPath;
                break;
            default:
                MainActivity.showToast("Invalid resource id in setCurrentDirectoryListener");
                return;
        }

        targetEditText.setText(currentDir.dir);
    };

    private void togglePathsWidgets(boolean status) {
        rhssSendXreAnnounceCtv.setEnabled(status);
        xreHomePath.setEnabled(status);
        xreAnnouncedPath.setEnabled(status);
        xreExposedPath.setEnabled(status);
    }

    private void saveOrClearPaths(boolean save) {
        if(save) {
            RHSSServerStatus.xreHomePathStr = xreHomePath.getText().toString();
            RHSSServerStatus.xreAnnouncedPathStr = xreAnnouncedPath.getText().toString();
            RHSSServerStatus.xreExposedPathStr = xreExposedPath.getText().toString();
            RHSSServerStatus.announceEnabled = rhssSendXreAnnounceCtv.isChecked();
        }
        else {
            RHSSServerStatus.xreHomePathStr = "";
            RHSSServerStatus.xreAnnouncedPathStr = "";
            RHSSServerStatus.xreExposedPathStr = "";
        }
    }

    private void retrievePathsIntoEditTexts() {
        xreHomePath.setText(RHSSServerStatus.xreHomePathStr);
        xreAnnouncedPath.setText(RHSSServerStatus.xreAnnouncedPathStr);
        xreExposedPath.setText(RHSSServerStatus.xreExposedPathStr);
        rhssSendXreAnnounceCtv.setChecked(RHSSServerStatus.announceEnabled);
    }

    private void switch_rhss_status(View unused) {
        if (RemoteServerManager.rhssManagerRef.get()==null) { // OFF -> ON
            RemoteServerManager.RHSS_ACTION targetAction =
                    (rhssSendXreAnnounceCtv !=null && rhssSendXreAnnounceCtv.isChecked())?
                            RemoteServerManager.RHSS_ACTION.START_ANNOUNCE:
                            RemoteServerManager.RHSS_ACTION.START;

            MainActivity.getRootHelperClient(); // ensure RH local server is started

            int result = RemoteServerManager.rhss_action(targetAction,
                    xreHomePath.getText().toString(),
                    xreAnnouncedPath.getText().toString(),
                    xreExposedPath.getText().toString());

            switch (result) {
                case 1:
                    Toast.makeText(activity, "Remote RH server started on port "+ XREPathContent.defaultRHRemoteServerPort, Toast.LENGTH_SHORT).show();
//                    rhss_status_button.setImageResource(R.drawable.xf_xre_server_up);
                    togglePathsWidgets(false);
                    saveOrClearPaths(true);
//                    rhssIPAddresses.setText(NetworkUtils.getInterfaceAddressesAsString());
                    break;
                case 0:
                    Toast.makeText(activity, "Unable to start remote RH server", Toast.LENGTH_SHORT).show();
                    break;
                case -1:
                    Toast.makeText(activity, "Unable to start remote RH server (I/O error)", Toast.LENGTH_SHORT).show();
                    break;
                default:
                    throw new RuntimeException("Unexpected return value from rhss_action");
            }
        }
        else { // ON -> OFF
            switch (RemoteServerManager.rhss_action(RemoteServerManager.RHSS_ACTION.STOP)) {
                case 1:
                    Toast.makeText(activity, "Remote RH server stopped", Toast.LENGTH_SHORT).show();
//                    rhss_status_button.setImageResource(R.drawable.xf_xre_server_down);
                    togglePathsWidgets(true);
                    saveOrClearPaths(false);

//                    rhssIPAddresses.setText("");
                    break;
                case 0:
                    Toast.makeText(activity, "Unable to stop remote RH server", Toast.LENGTH_SHORT).show();
                    break;
                case -1:
                    Toast.makeText(activity, "Unable to stop remote RH server (I/O error)", Toast.LENGTH_SHORT).show();
                    break;
                default:
                    throw new RuntimeException("Unexpected return value from rhss_action");
            }
        }
    }

    private final Activity activity;

    public static RemoteRHServerManagementDialog instance;
    public RemoteRHServerManagementDialog(@NonNull Activity activity) {
        super(activity,R.style.fs_dialog);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        instance = this;
        setOnShowListener(EffectActivity.defaultDialogShowListener);
        this.activity = activity;
        setContentView(R.layout.remote_rh_server_management_dialog);

        currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();

        ifAddrsObserver = new IfAddrsObserver();
        FileServer.FTP.server.addObserver(ifAddrsObserver);
        FileServer.HTTP.server.addObserver(ifAddrsObserver);
        RemoteServerManager.rsmObservable.addObserver(ifAddrsObserver);

//        rhss_status_button = findViewById(R.id.rhss_toggle_rhss_button);
        rhss_show_xre_connections = findViewById(R.id.rhss_show_xre_connections);

        for (FileServer fileServer : FileServer.values()) {
            SimpleFileServer s = fileServer.server;
            s.serverButton = findViewById(s.serverButtonRes);
            s.serverButton.setOnClickListener(v->{
                s.setRootPath(((EditText)findViewById(R.id.ftpHttpRootPath)).getText().toString()); // not needed in case of server On->OFF
                s.toggle();
            });
        }

        WifiButtonsLayout wbl = new WifiButtonsLayout(activity);
        LinearLayout target = findViewById(R.id.targetWifiButtonsLayout);
        target.addView(wbl);

        xreHomePath = findViewById(R.id.xreHomePath);
        xreAnnouncedPath = findViewById(R.id.xreAnnouncedPath);
        xreExposedPath = findViewById(R.id.xreExposedPath);

        xreSetHomePath = findViewById(R.id.setXreHomePathToCurrent);
        xreSetAnnouncedPath = findViewById(R.id.setXreAnnouncedPathToCurrent);
        xreSetExposedPath = findViewById(R.id.setXreExposedPathToCurrent);
        if(currentDir instanceof LocalPathContent) {
            xreSetHomePath.setOnClickListener(setCurrentDirectoryListener);
            xreSetAnnouncedPath.setOnClickListener(setCurrentDirectoryListener);
            xreSetExposedPath.setOnClickListener(setCurrentDirectoryListener);
        }
        else {
            xreSetHomePath.setEnabled(false);
            xreSetAnnouncedPath.setEnabled(false);
            xreSetExposedPath.setEnabled(false);
        }

        ftpHttpRootPath = findViewById(R.id.ftpHttpRootPath);
        ftpHttpRootPath.setText(Misc.internalStorageDir.getAbsolutePath());

        rhssSendXreAnnounceCtv = findViewById(R.id.rhssAnnounceOptionCtv);
        rhssSendXreAnnounceCtv.setOnClickListener(Misc.ctvListener);

        // check rhss manager thread status
        if (RemoteServerManager.rhssManagerRef.get() == null) {
//            rhss_status_button.setImageResource(R.drawable.xf_xre_server_down);
            togglePathsWidgets(true);
        }
        else {
//            rhss_status_button.setImageResource(R.drawable.xf_xre_server_up);
            // rhssIPAddresses.setText(NetworkUtils.getInterfaceAddressesAsString());
            retrievePathsIntoEditTexts();
            togglePathsWidgets(false);
        }

        rhss_show_xre_connections.setOnClickListener(((MainActivity) activity)::showXREConnections);

        wbl.registerListeners();
        setOnDismissListener(dialog->{
            wbl.unregisterListeners();

            FileServer.FTP.server.deleteObserver(ifAddrsObserver);
            FileServer.HTTP.server.deleteObserver(ifAddrsObserver);
            RemoteServerManager.rsmObservable.deleteObserver(ifAddrsObserver);

            instance = null;
            EffectActivity.currentlyOnFocus = MainActivity.mainActivity;
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/RenameDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.widget.AbsListView;
import android.widget.Button;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import java.io.IOException;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.BrowserAdapter;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

/**
 * Created by pgp on 26/10/16 (converted inner class to standalone one)
 */
public class RenameDialog extends ImmersiveModeDialog {

    public RenameDialog(final MainActivity mainActivity, final BasePathContent f) {
        super(mainActivity);
        setContentView(R.layout.single_filename_dialog);
        setTitle("Rename");
        EditText filename = findViewById(R.id.singleFilenameEditText);
        Button ok = findViewById(R.id.singleFilenameOkButton);
        filename.setText(f.getName());

        ok.setOnClickListener(v -> {
            String filename_ = filename.getText().toString();
            BasePathContent ff = f.getParent().concat(filename_);
            if(doRename(mainActivity,f,ff))
                mainActivity.browserPagerAdapter.showDirContent(
                        mainActivity.getCurrentDirCommander().refresh(),
                        mainActivity.browserPager.getCurrentItem(),filename_);

            dismiss();
        });
    }

    public static boolean doRename(MainActivity mainActivity, BasePathContent f, BasePathContent ff) {
        boolean ok = false;

        try {
            ok = mainActivity.getFileOpsHelper(f.providerType).renameFile(f,ff);
            Toast.makeText(mainActivity, ok?"Renamed":"Error renaming item", Toast.LENGTH_SHORT).show();
        }
        catch (IOException e) {
            e.printStackTrace();
            Toast.makeText(mainActivity, "Roothelper communication error", Toast.LENGTH_SHORT).show();
        }
        return ok;
    }

    public static void resetRenameMode(int pagerPos, View[] fastModes) {
        View a = fastModes[pagerPos];
        if(a!=null) {
            TextView tv = a.findViewById(R.id.browserItemFilename);
            EditText et = a.findViewById(R.id.browserItemFilename_edit);
            et.setVisibility(View.GONE);
            tv.setVisibility(View.VISIBLE);
            fastModes[pagerPos] = null;
        }
    }

    public static void toggleFastRename(MainActivity mainActivity, int pos, BasePathContent f, boolean status) {
        AbsListView listView = mainActivity.browserPagerAdapter.mainBrowserViews[mainActivity.browserPager.getCurrentItem()];
        BrowserAdapter ba = (BrowserAdapter) listView.getAdapter();
        BrowserItem b = ba.getItem(pos);

        if(status) { // ON
            if(!(listView instanceof ListView))
                throw new RuntimeException("Won't modify layout of GridView");

            View a = Misc.getViewByPosition(pos, listView);
            TextView tv = a.findViewById(R.id.browserItemFilename);
            EditText et = a.findViewById(R.id.browserItemFilename_edit);

            tv.setVisibility(View.GONE);
            et.setText(tv.getText().toString());
            et.setVisibility(View.VISIBLE);
            et.setOnEditorActionListener((v, actionId, event) -> {
                // If the event is a key-down event on the "enter" button
                if ((event != null && event.getKeyCode() == KeyEvent.KEYCODE_ENTER) ||
                        (actionId == EditorInfo.IME_ACTION_DONE)) {
                    // Perform action on key press
                    toggleFastRename(mainActivity,pos,f,false);
                    return true;
                }
                return false;
            });
            mainActivity.browserPagerAdapter.fastRenameModeViews[mainActivity.browserPager.getCurrentItem()] = a;
            et.setSelection(et.getText().length());
            et.requestFocus();
            PopupWindowUtils.toggleSoftKeyBoard(et, true);
        }
        else { // OFF
            View a = mainActivity.browserPagerAdapter.fastRenameModeViews[mainActivity.browserPager.getCurrentItem()];
            TextView tv = a.findViewById(R.id.browserItemFilename);
            EditText et = a.findViewById(R.id.browserItemFilename_edit);

            if(et!=null) et.setVisibility(View.GONE);
            if(tv!=null) tv.setVisibility(View.VISIBLE);

            if(f!=null && et!=null)
                if(doRename(mainActivity,f,f.getParent().concat(et.getText().toString()))) {
                    b.filename = et.getText().toString();
//                tv.setText(b.filename);
                    ba.notifyDataSetChanged();
                }

            View v = mainActivity.getCurrentFocus();
            if (v != null) PopupWindowUtils.toggleSoftKeyBoard(v, false);

            mainActivity.browserPagerAdapter.fastRenameModeViews[mainActivity.browserPager.getCurrentItem()] = null;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/SSHAlreadyInKnownHostsDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import net.schmizz.sshj.common.KeyType;
import net.schmizz.sshj.transport.verification.OpenSSHKnownHosts;

import java.io.IOException;
import java.security.PublicKey;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.sftpclient.AuthData;
import it.pgp.xfiles.sftpclient.SFTPProvider;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 03/03/17
 *
 * Dialog to be displayed when a host key does not match the one
 * already in known hosts. Choices are:
 *    - overwrite old host key and continue connecting
 *    - keep old host key and abort connection
 *    - (not really necessary: temporarily accept new host key, but don't remove old one)
 */

public class SSHAlreadyInKnownHostsDialog extends SSHKnownHostsBaseDialog {

    public SSHAlreadyInKnownHostsDialog(final MainActivity activity,
                                        final AuthData authData,
                                        final OpenSSHKnownHosts.KnownHostEntry oldHostEntry,
                                        final PublicKey newHostKey,
                                        final SFTPProvider provider,
                                        final BasePathContent pendingLsPath) {
        super(activity,pendingLsPath);

        setTitle("Conflicting host key");
        setContentView(R.layout.ssh_already_in_known_hosts_dialog);
        TextView oldFingerprint = findViewById(R.id.storedHostKeyFingerprintTextView);
        TextView newFingerprint = findViewById(R.id.currentHostKeyFingerprintTextView);
        Button accept = findViewById(R.id.hostKeyAcceptOverwriteButton);
        Button discard = findViewById(R.id.hostKeyKeepOldAndDisconnectButton);

        if(oldHostEntry != null)
            oldFingerprint.setText(oldHostEntry.getType().name()+"\n"+oldHostEntry.getFingerprint());

        newFingerprint.setText(KeyType.fromKey(newHostKey)+" "+newHostKey.getAlgorithm()+" "+newHostKey.getFormat()+"\n"+getHostkeyFingerprint(newHostKey));

        accept.setOnClickListener(v -> {
            try {
                final String adjustedHostname = (authData.port != 22) ? "[" + authData.domain + "]:" + authData.port : authData.domain;
                provider.updateHostKey(adjustedHostname,newHostKey);
                Toast.makeText(activity,"Host key updated in known hosts",Toast.LENGTH_LONG).show();
                dismiss();
                // retry getChannel and LS pending request (if any) is done in dismiss listener
            } catch (IOException e) {
                Toast.makeText(activity,"Unable to update host key in known hosts",Toast.LENGTH_LONG).show();
                resetPath();
                cancel();
            }
        });

        discard.setOnClickListener(v -> {
            resetPath();
            cancel();
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/SSHKnownHostsBaseDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.Dialog;
import android.widget.Toast;

import net.schmizz.sshj.common.KeyType;
import net.schmizz.sshj.common.SecurityUtils;
import net.schmizz.sshj.transport.verification.OpenSSHKnownHosts;

import java.security.PublicKey;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.SFTPPathContent;

public abstract class SSHKnownHostsBaseDialog extends Dialog {

    public static String getHostkeyFingerprint(Object hostKey) {
        try {
            return (hostKey instanceof OpenSSHKnownHosts.KnownHostEntry)?
                    ((OpenSSHKnownHosts.KnownHostEntry) hostKey).getFingerprint()
                    :SecurityUtils.getFingerprint((PublicKey) hostKey);
        }
        catch(Exception e) {
            e.printStackTrace();
            return KeyType.UNKNOWN.name();
        }
    }

    public SFTPPathContent pendingLsPath;
    public void resetPath() {
        pendingLsPath = null;
    }

    public SSHKnownHostsBaseDialog(MainActivity activity, BasePathContent pendingLsPath) {
        super(activity);
        this.pendingLsPath = (SFTPPathContent) pendingLsPath;

        setOnDismissListener(d_-> {
            SSHKnownHostsBaseDialog d = (SSHKnownHostsBaseDialog)d_;
            if (d.pendingLsPath == null) {
                Toast.makeText(activity.getApplicationContext(),"No pending request in SFTP retry",Toast.LENGTH_LONG).show();
                return;
            }
            activity.goDir(pendingLsPath,activity.browserPager.getCurrentItem(),null);
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/SSHNotInKnownHostsDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import net.schmizz.sshj.common.KeyType;

import java.io.IOException;
import java.security.PublicKey;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.sftpclient.AuthData;
import it.pgp.xfiles.sftpclient.SFTPProvider;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 03/03/17
 *
 * Dialog to be displayed when a host key does not exist in known hosts:
 *     - asking for adding it
 *     - showing SHA256 fingerprint of the host key
 */

public class SSHNotInKnownHostsDialog extends SSHKnownHostsBaseDialog {

    public SSHNotInKnownHostsDialog(final MainActivity activity,
                                    final AuthData authData,
                                    final PublicKey hostKey,
                                    final SFTPProvider provider,
                                    final BasePathContent pendingLsPath) {
        super(activity,pendingLsPath);

        setTitle("Unknown host key");
        setContentView(R.layout.ssh_not_in_known_hosts_dialog);
        TextView fingerprint = findViewById(R.id.hostKeyFingerprintTextView);
        Button accept = findViewById(R.id.hostKeyAcceptButton);
        Button discard = findViewById(R.id.hostKeyDiscardButton);

        fingerprint.setText(KeyType.fromKey(hostKey)+" "+hostKey.getAlgorithm()+" "+hostKey.getFormat()+"\n"+getHostkeyFingerprint(hostKey));

        accept.setOnClickListener(v -> {
            try {
                final String adjustedHostname = (authData.port != 22) ? "[" + authData.domain + "]:" + authData.port : authData.domain;
                provider.addHostKey(adjustedHostname,hostKey);
                Toast.makeText(activity,"Host key added to known hosts",Toast.LENGTH_LONG).show();
                dismiss();
                if (MainActivity.cdd != null) {
                    MainActivity.cdd.dismiss();
                    MainActivity.cdd = null;
                }
                // retry getChannel and LS pending request (if any) is done in dismiss listener
            } catch (IOException e) {
                Toast.makeText(activity,"Unable to add host key to known hosts",Toast.LENGTH_LONG).show();
                resetPath();
                cancel();
            }
        });

        discard.setOnClickListener(v -> {
            resetPath();
            cancel();
        });

    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/UpdateCheckDialog.java`:

```java
package it.pgp.xfiles.dialogs;

import android.app.AlertDialog;
import android.app.Dialog;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.support.annotation.NonNull;
import android.util.Log;
import android.view.View;
import android.view.Window;
import android.widget.Button;
import android.widget.TextView;
import android.widget.Toast;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.util.StdDateFormat;

import java.io.File;
import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.BaseBackgroundTask;
import it.pgp.xfiles.service.ExtractService;
import it.pgp.xfiles.service.HTTPDownloadService;
import it.pgp.xfiles.service.params.DownloadParams;
import it.pgp.xfiles.service.params.ExtractParams;
import it.pgp.xfiles.service.visualization.ViewType;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

public class UpdateCheckDialog extends Dialog {

    private static class JsonParseDuringCompareException extends RuntimeException {
        public JsonParseDuringCompareException(Exception e) {
            super(e);
        }
        public JsonParseDuringCompareException(String msg) {
            super(msg);
        }
    }

    final MainActivity activity;

    final StdDateFormat df = new StdDateFormat();

    String currentVersionTagname,latestVersionTagName,latestVersionDownloadUrl;

    Date currentVersionCreatedAt,latestVersionCreatedAt;

    TextView updateMessage;
    TextView currentVersion, latestVersion;
    Button downloadButton,cancelButton;

    List<Map> releases;

    private void compareReleases(final MainActivity activity) throws ParseException {
        if(releases == null || releases.isEmpty())
            throw new JsonParseDuringCompareException("Null or empty releases list");

        /*Collections.sort(releases,(o1,o2) -> {
            try {
                Date d1 = df.parse((String) o1.get("created_at"));
                Date d2 = df.parse((String) o2.get("created_at"));
                return -(d1.compareTo(d2)); // sort in reversed order
            }
            catch(Exception e) {
                throw new JsonParseDuringCompareException(e);
            }
        });*/

        Map<String,Integer> tagnames = new HashMap<>();
        int cnt=0;
        for(Map<String,String> rel : releases) // actually not Map<String,String>, variable types, but we are interested only in tag_name, so no ClassCastException if the format is the expected one
            tagnames.put(rel.get("tag_name"),cnt++);
        Integer currentVersionIdx = tagnames.get(currentVersionTagname);
        if(currentVersionIdx == null) { // currently installed version not found in GH releases
            // extract date from versionCode (latest 6 chars, yyMMdd)
            currentVersionCreatedAt = new SimpleDateFormat("yyMMdd").parse(
                    currentVersionTagname.substring(currentVersionTagname.length()-6));
        }
        else currentVersionCreatedAt = df.parse((String) releases.get(currentVersionIdx).get("created_at"));

        latestVersionTagName = (String) releases.get(0).get("tag_name");
        latestVersionCreatedAt = df.parse((String) releases.get(0).get("created_at"));
        latestVersionDownloadUrl = (String)((Map)((List)releases.get(0).get("assets")).get(0)).get("browser_download_url");
        activity.runOnUiThread(()->{
            int compareResult = currentVersionCreatedAt.compareTo(latestVersionCreatedAt);
            switch(compareResult) {
                case -1:
                    updateMessage.setText("Update available");
                    break;
                case 0:
                    updateMessage.setText("Already up to date");
                    break;
                case 1:
                    updateMessage.setText("This version is newer than latest official release");
                    break;
                default:
                    throw new RuntimeException("Guard block");
            }
            if(compareResult > -1) {
                downloadButton.setText("Get anyway");
            }

            currentVersion.setText(currentVersionTagname);
            latestVersion.setText(latestVersionTagName);
        });
    }

    public UpdateCheckDialog(@NonNull final MainActivity activity) {
        super(activity);
        this.activity = activity;
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        setContentView(R.layout.update_check_dialog);
        try {
            PackageInfo pInfo = activity.getPackageManager().getPackageInfo(activity.getPackageName(), 0);
            currentVersionTagname = pInfo.versionName+"_"+pInfo.versionCode; // STRONG ASSUMPTION
        }
        catch (PackageManager.NameNotFoundException e) {
            throw new RuntimeException(e);
        }
        currentVersion = findViewById(R.id.updateCheckCurrentVersion);
        latestVersion = findViewById(R.id.updateCheckLatestVersion);
        downloadButton = findViewById(R.id.updateCheckOkButton);
        downloadButton.setOnClickListener(this::startDownloadOfLatestRelease);
        cancelButton = findViewById(R.id.updateCheckCancelButton);
        cancelButton.setOnClickListener(v->dismiss());
        updateMessage = findViewById(R.id.updateCheckMessage);
        updateMessage.setText("Checking for updates...");
        new Thread(()->{
            String errMsg;
            Exception ee;
            try {
                byte[] x = MainActivity.getRootHelperClient().downloadHttpsUrlInMemory("api.github.com/repos/pgp/XFiles/releases/latest");
                Log.d(UpdateCheckDialog.class.getName(),new String(x));
                releases = Collections.singletonList(new ObjectMapper().readValue(x, Map.class));
                compareReleases(activity);
                activity.runOnUiThread(()-> downloadButton.setEnabled(true));
                return;
            }
            catch(JsonParseDuringCompareException e) {
                ee = e;
                errMsg = "Json parse error during release sorting";
            }
            catch(JsonParseException | JsonMappingException e) {
                ee = e;
                errMsg = "Json parse error after downloading releases file";
            }
            catch (IOException e) {
                ee = e;
                errMsg = "Prefetch error, check connection";
            }
            catch (ParseException e) {
                ee = e;
                errMsg = "Date parse error";
            }
            catch (Exception e) {
                ee = e;
                errMsg = "Generic error during update check";
            }
            ee.printStackTrace();
            MainActivity.showToast(errMsg);
            dismiss();
        }).start();
    }

    private void startDownloadOfLatestRelease(View unused) {
        /**
         * 1) download latest release zip from GH assets, into internal memory path
         * 2) on complete, extract zip into same folder
         * 3) on extract complete, delete zip and show popup "Install now?"
         */
        Toast.makeText(activity, "Download url: "+latestVersionDownloadUrl, Toast.LENGTH_LONG).show();

        // prepare extract task to be executed after download task has ended
        String[] s = latestVersionDownloadUrl.split("/");
        final String zipname = s[s.length-1];
        final BasePathContent outDir = new LocalPathContent(Misc.internalStorageDir.getAbsolutePath());
        final BasePathContent srcArchive = outDir.concat(zipname);
        String expectedApkName = zipname.substring(0,zipname.length()-3)+"apk";
        final File zipFile = new File(srcArchive.dir);
        final File apkFile = new File(outDir.concat(expectedApkName).dir);

        // add extract task
        BaseBackgroundTask.nextAutoTasks.add(()->{
            if(!zipFile.exists()) {
                BaseBackgroundTask.nextAutoTasks.clear();
                return;
            }
            Intent startIntent = new Intent(activity, ExtractService.class);
            startIntent.setAction(BaseBackgroundService.START_ACTION);
            startIntent.putExtra(
                    "params",
                    new ExtractParams(
                            Collections.singletonList(srcArchive),
                            outDir,
                            null,
                            null,
                            false
                    ));
            activity.startService(startIntent);
        });

        // add install task (delete zipped apk file as well
        BaseBackgroundTask.nextAutoTasks.add(()->{
            if(!apkFile.exists()) {
                BaseBackgroundTask.nextAutoTasks.clear();
                return;
            }
            try {
                MainActivity.getRootHelperClient().deleteFilesOrDirectories(Collections.singletonList(srcArchive));
            }
            catch (IOException|NullPointerException e) {
                MainActivity.showToast("Unable to delete zipped apk file");
            }

            // show dialog asking if installation should be done now
            activity.runOnUiThread(()->{
                AlertDialog.Builder bld = new AlertDialog.Builder(activity);
                bld.setTitle("APK file has been downloaded, install now?");
                bld.setNegativeButton(android.R.string.cancel, null);
                bld.setPositiveButton(android.R.string.ok, (dialog, which) -> {
                    // kill RH before updating; this is useful in older versions of Android with root,
                    // since the RH process (being root) cannot be terminated till restart
                    // (even if the executable on the filesystem is actually updated)
                    MainActivity.killRHWrapper();
                    activity.installApk(apkFile);
                });
                AlertDialog alertDialog = bld.create();
                alertDialog.getWindow().setType(ViewType.OVERLAY_WINDOW_TYPE);
                alertDialog.show();
            });
        });

        // run download task, subsequent tasks will be run automatically after download end
        Intent relDownloadIntent = new Intent(activity, HTTPDownloadService.class);
        relDownloadIntent.setAction(BaseBackgroundService.START_ACTION);
        relDownloadIntent.putExtra("params",new DownloadParams(
                latestVersionDownloadUrl,
                Misc.internalStorageDir.getAbsolutePath(),
                zipname,
                true));
        activity.startService(relDownloadIntent);
        dismiss();
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/XFilesRemoteSessionsManagementActivity.java`:

```java
package it.pgp.xfiles.dialogs;

import android.os.Bundle;
import android.support.annotation.Nullable;
import android.widget.ListView;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.XFilesRemoteEndpointAdapter;

/**
 * Created by pgp on 21/12/17
 */

public class XFilesRemoteSessionsManagementActivity extends EffectActivity {

    public static XFilesRemoteEndpointAdapter StoCAdapter = null;
    public static XFilesRemoteEndpointAdapter CtoSAdapter = null;

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setActivityIcon(R.drawable.xf_xre_server_up);
        setContentView(R.layout.xfiles_remote_sessions_management);
        StoCAdapter = new XFilesRemoteEndpointAdapter(this, true);
        ListView StoCListView = findViewById(R.id.currentlyOpenServerSessions); // observed
        StoCListView.setAdapter(StoCAdapter);

        CtoSAdapter = new XFilesRemoteEndpointAdapter(this, false);
        ListView CtoSListView = findViewById(R.id.currentlyOpenClientSessions); // not observed
        CtoSListView.setAdapter(CtoSAdapter);
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        StoCAdapter = null;
        CtoSAdapter = null;
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/compress/AskPasswordDialogOnExtract.java`:

```java
package it.pgp.xfiles.dialogs.compress;

import android.app.Activity;
import android.content.Intent;
import android.support.annotation.NonNull;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.EditText;

import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.BaseDialog;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.ExtractService;
import it.pgp.xfiles.service.params.ExtractParams;

/**
 * Created by pgp on 03/06/17
 *
 * to be used on extract
 * (that is, after first failed extract archive request to roothelper, with errno set to custom NULL_OR_WRONG_PASSWORD)
 */

public class AskPasswordDialogOnExtract extends BaseDialog {

    private String pendingPassword;

    // after list attempt
    public AskPasswordDialogOnExtract(@NonNull final Activity activity,
                                      @NonNull final ExtractParams extractParams) {
        super(activity);
        setTitle("Insert password");
        setContentView(R.layout.ask_password_dialog);
        setDialogIcon(R.drawable.xfiles_extract);

        EditText password = findViewById(R.id.passwordEditText);
        CheckedTextView passwordVisible = findViewById(R.id.passwordVisibleCtv);
        Button ok = findViewById(R.id.askPasswordOkButton);

        passwordVisible.setOnClickListener(AskPasswordDialogOnListing.getPasswordCtvListener(password));

        ok.setOnClickListener(v -> {
            pendingPassword = password.getText().toString();
            dismiss();
        });

        // cancel is called before dismiss, anyway don't rely on that order
        setOnDismissListener(dialog -> {
            if(pendingPassword != null) {
                // wrong password will trigger a new dialog open
                // with service & task
                ////////////////////////
                Intent startIntent = new Intent(activity,ExtractService.class);
                startIntent.setAction(BaseBackgroundService.START_ACTION);
                extractParams.setPassword(pendingPassword);
                startIntent.putExtra("params",extractParams);
                activity.startService(startIntent);
                ////////////////////////
                dismiss();
            }
        });
    }

    // after extract attempt
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/compress/AskPasswordDialogOnListing.java`:

```java
package it.pgp.xfiles.dialogs.compress;

import android.support.annotation.NonNull;
import android.text.InputType;
import android.view.View;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.EditText;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.BaseDialog;
import it.pgp.xfiles.utils.pathcontent.ArchivePathContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 19/05/17
 *
 * to be used on open archive (encrypted filenames)
 * (that is, after first failed list archive request to roothelper, with errno set to custom NULL_OR_WRONG_PASSWORD)
 */

public class AskPasswordDialogOnListing extends BaseDialog {
    private ArchivePathContent pendingArchivePath_;

    public static View.OnClickListener getPasswordCtvListener(EditText passwordEditText) {
        return v -> {
            CheckedTextView ctv = (CheckedTextView) v;
            ctv.toggle();
            passwordEditText.setInputType(ctv.isChecked() ?
                    (InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD) :
                    InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);
        };
    }

    // after list attempt
    public AskPasswordDialogOnListing(@NonNull final MainActivity activity,
                                      @NonNull final BasePathContent pendingArchivePath) {
        super(activity);
        pendingArchivePath_ = null;
        setTitle("Insert password");
        setContentView(R.layout.ask_password_dialog);
        setDialogIcon(R.drawable.xfiles_archive);

        EditText password = findViewById(R.id.passwordEditText);
        CheckedTextView passwordVisible = findViewById(R.id.passwordVisibleCtv);
        Button ok = findViewById(R.id.askPasswordOkButton);

        passwordVisible.setOnClickListener(getPasswordCtvListener(password));

        ok.setOnClickListener(v -> {
            switch(pendingArchivePath.providerType) {
                case LOCAL:
                    pendingArchivePath_ = new ArchivePathContent(pendingArchivePath.dir,"/");
                    break;
                case LOCAL_WITHIN_ARCHIVE:
                    pendingArchivePath_ = new ArchivePathContent(
                            ((ArchivePathContent) pendingArchivePath).archivePath,
                            pendingArchivePath.dir
                    );
                    break;
                default:
                    break;
            }
            pendingArchivePath_.password = password.getText().toString();
            dismiss();
        });

        // cancel is called before dismiss, anyway don't rely on that order
        setOnDismissListener(dialog -> {
            if(pendingArchivePath_ != null) activity.goDir_async(pendingArchivePath_,null);
            else activity.toggleGoDirOpsIndeterminateProgress(true); // equivalent to cancel dialog
            // wrong password will trigger a new dialog open
        });
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/compress/CompressActivity.java`:

```java
package it.pgp.xfiles.dialogs.compress;

import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.util.Log;
import android.view.View;
import android.widget.CheckedTextView;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.RadioGroup;
import android.widget.SeekBar;
import android.widget.TextView;
import android.widget.Toast;

import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.CopyListUris;
import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.OutputArchiveType;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.CompressService;
import it.pgp.xfiles.service.params.CompressParams;
import it.pgp.xfiles.service.visualization.ProgressIndicator;
import it.pgp.xfiles.utils.FileSaveFragment;
import it.pgp.xfiles.utils.IntentUtil;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

/**
 * Created by pgp on 20/11/17
 * Activity instead of Dialog in order to launch another dialog to browse for destination archive
 */

public class CompressActivity extends EffectActivity implements FileSaveFragment.Callbacks {

    boolean standaloneMode = false; // true if not started by MainActivity

    @Nullable BrowserItem filename;

    BasePathContent dirPath; // source dir path

    EditText outputArchiveFilePath;
    EditText outputArchivePassword;

    SeekBar compressionLevel;
    TextView compressionLevelNum;
    CheckedTextView encryptHeaders;
    CheckedTextView solidMode;

    ImageButton selectOutputArchiveFilePath;
    RadioGroup archiveTypeSelector;

    List<String> selectedItems;
    CopyListUris contentUris;


    boolean streamingArchivesEnabled = false;

    private void populateSelectedItems(Intent intent) {
        List<Uri> imageUris = IntentUtil.getShareSelectionFromIntent(intent);

        if (imageUris == null) {
            Log.e(getClass().getName(), "both extras are null, assuming CompressActivity was started by MainActivity...");
            standaloneMode = false;

            selectedItems = MainActivity.mainActivity.getCurrentBrowserAdapter().getSelectedItemsAsNameOnlyStrings();

            // compress one single item, only if no other item is selected
            if (selectedItems.size()==0 && filename != null)
                selectedItems = Collections.singletonList(filename.getFilename());

            // enable flag for streaming archive support only if single selection and the item is a file
            if(selectedItems.size() == 1) {
                List<BrowserItem> x = MainActivity.mainActivity.getCurrentBrowserAdapter().getSelectedItems();
                if((x.size()!=0 && !x.get(0).isDirectory)|| (x.size()==0 && !filename.isDirectory))
                    streamingArchivesEnabled = true;
            }

            ///////////////
            dirPath = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
            if (dirPath.providerType != ProviderType.LOCAL) {
                Toast.makeText(this,"Create archive supported only on local filesystem",Toast.LENGTH_SHORT).show();
                finish();
                return;
            }
            ///////////////

            return;
        }

        standaloneMode = true;

        try { // standard mode, deduce paths from uris
            Map.Entry<BasePathContent,List<String>> me = IntentUtil.getCommonAncestorAndItems(this,imageUris);
            dirPath = me.getKey();
            selectedItems = me.getValue();
            return;
        }
        catch(Exception e) { // content provider mode, extract paths from fds opened from uris,
            Log.e("COMPRESS","Path extraction from uri failed, trying with /proc/self/fd trick...",e);
        }

        try {
            Map.Entry<BasePathContent,List<String>> me = IntentUtil.getCommonAncestorAndItems_mode2(this,imageUris);
            dirPath = me.getKey();
            selectedItems = me.getValue();

            // try to access the resolved dirPath
            GenericDirWithContent dircontent = MainActivity.getRootHelperClient().listDirectory(dirPath);
            if (dircontent.errorCode != null) {
                throw new IOException("Common path extraction from /proc/self/fd succeeded, but resolved path is not accessible (e.g. ext sdcard original mount point, and no root access)");
            }
        }
        catch(IOException e) {
            Log.e("COMPRESS","Path extraction from /proc/self/fd failed",e);
            Toast.makeText(this,"Unable to extract paths from content uris, reverting to limited content provider mode",Toast.LENGTH_SHORT).show();
        }

        Log.e("COMPRESS", "entering limited content provider mode, only zip output format available");
        dirPath = new LocalPathContent(Misc.internalStorageDir.getAbsolutePath());
        selectedItems = null;
        contentUris = CopyListUris.getFromUriList(imageUris);

        // here, it's assumed 3rd party apps won't send URIs of directories via content provider
        if ((selectedItems!=null && selectedItems.size()==1) || (contentUris!=null && contentUris.contentUris.size()==1))
            streamingArchivesEnabled = true;
    }

    public void compress_ok(View unused) {
        BasePathContent filePath = new LocalPathContent(outputArchiveFilePath.getText().toString());
//        BasePathContent filePath = BasePathContent.concat(dirPath,outputArchiveFilePath.getText().toString());
        int idx = archiveTypeSelector.indexOfChild(
                archiveTypeSelector.findViewById(
                        archiveTypeSelector.getCheckedRadioButtonId()));
        String ext = OutputArchiveType.values()[idx].getValue();

        String destArchive = filePath.toString()+"."+ext;
        String srcFolder = dirPath.toString();

        // with service & task
        ////////////////////////
        Intent startIntent = new Intent(this,CompressService.class);
        startIntent.setAction(BaseBackgroundService.START_ACTION);
        startIntent.putExtra(
                "params",
                contentUris==null?
                        new CompressParams(
                                new LocalPathContent(srcFolder),
                                new LocalPathContent(destArchive),
                                compressionLevel.getProgress(),
                                encryptHeaders.isChecked(),
                                solidMode.isChecked(),
                                outputArchivePassword.getText().toString(),
                                selectedItems,
                                standaloneMode
                        ):
                        new CompressParams(
                                contentUris,
                                new LocalPathContent(destArchive),
                                compressionLevel.getProgress(),
                                encryptHeaders.isChecked(),
                                solidMode.isChecked(),
                                outputArchivePassword.getText().toString(),
                                standaloneMode
                        )
        );
        startService(startIntent);
//        finish(); // Security Manager prevents using content provider's file objects after the activity has ended
        if(contentUris==null) finish(); // back to MainActivity, or actually finishAffinity if in standalone mode, and not in limited content provider mode
        else MainActivity.simulateHomePress(this); // else, pause activity instead of finishing it
    }

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        // constructor params of CompressDialog are now passed in the bundle
        setTitle("Compress");
        setActivityIcon(R.drawable.xfiles_archive);
        setContentView(R.layout.compress_layout);
        MainActivity.refreshAppContext(getApplicationContext());
        MainActivity.getRootHelperClient();

        Intent intent = getIntent();

        filename = (BrowserItem)intent.getSerializableExtra("filename"); // single file to be compressed, if null use adapter selection

        populateSelectedItems(intent);

        outputArchiveFilePath = findViewById(R.id.outputArchiveFilePath);
        outputArchiveFilePath.setText(dirPath.concat((filename==null)?"archive":filename.getFilename()).toString());
        outputArchivePassword = findViewById(R.id.outputArchivePassword);

        compressionLevel = findViewById(R.id.compressionLevel);
        compressionLevelNum = findViewById(R.id.compressionLevelNum);
        int maxCompLevel = 9;
        compressionLevel.setMax(maxCompLevel); // max 7z compression level
        compressionLevel.setProgress(maxCompLevel);
        compressionLevelNum.setText(maxCompLevel+"");
        compressionLevel.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                compressionLevelNum.setText(progress+"");
            }

            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {}

            @Override
            public void onStopTrackingTouch(SeekBar seekBar) {}
        });

        encryptHeaders = findViewById(R.id.encryptFilenames);
        encryptHeaders.setOnClickListener(Misc.ctvListener);
        solidMode = findViewById(R.id.solidMode);
        solidMode.setOnClickListener(Misc.ctvListener);

        selectOutputArchiveFilePath = findViewById(R.id.selectOutputArchiveFilePath);
        selectOutputArchiveFilePath.setOnClickListener(this::openDestinationArchiveSelector);

        archiveTypeSelector = findViewById(R.id.archiveTypeRadioGroup);
        archiveTypeSelector.setOnCheckedChangeListener((radioGroup, i) -> {
            int idx = archiveTypeSelector.indexOfChild(
                    archiveTypeSelector.findViewById(
                            archiveTypeSelector.getCheckedRadioButtonId()));
            switch (OutputArchiveType.values()[idx]) {
                case _7Z:
                    // enable all
                    outputArchivePassword.setEnabled(true);
                    compressionLevel.setEnabled(true);
                    encryptHeaders.setEnabled(true);
                    solidMode.setEnabled(true);
                    break;
                case ZIP:
                    // no solid mode nor encrypt headers supported
                    outputArchivePassword.setEnabled(true);
                    compressionLevel.setEnabled(true);
                    encryptHeaders.setEnabled(false);
                    solidMode.setEnabled(false);
                    break;
                case TAR:
                    // no option supported
                    outputArchivePassword.setEnabled(false);
                    compressionLevel.setEnabled(false);
                    encryptHeaders.setEnabled(false);
                    solidMode.setEnabled(false);
                    break;
                case GZ:
                case BZ2:
                case XZ:
                    outputArchivePassword.setEnabled(false);
                    compressionLevel.setEnabled(true);
                    encryptHeaders.setEnabled(false);
                    solidMode.setEnabled(false);
                    break;
            }
        });

        // disable ZIP format (Update error in roothelper)
        if(contentUris != null) {
            archiveTypeSelector.check(R.id._7zRadioButton);
            findViewById(OutputArchiveType.ZIP.getId()).setEnabled(false);

        // LEGACY, java zip backend, set format to ZIP and disable all the settings widgets when in limited content provider mode
//            for (OutputArchiveType t : OutputArchiveType.values())
//                if(t != OutputArchiveType.ZIP)
//                    findViewById(t.getId()).setEnabled(false);
//            outputArchivePassword.setEnabled(false);
//            encryptHeaders.setEnabled(false);
//            compressionLevel.setEnabled(false);
//            solidMode.setEnabled(false);
        }

        // disable streaming archive formats for multiple selection (lazy fail if single directory is passed)
        if(!streamingArchivesEnabled) {
            findViewById(OutputArchiveType.GZ.getId()).setEnabled(false);
            findViewById(OutputArchiveType.BZ2.getId()).setEnabled(false);
            findViewById(OutputArchiveType.XZ.getId()).setEnabled(false);
        }

    }

    @Override
    public boolean onCanSave(String absolutePath, String fileName) {

        // Catch the really stupid case.
        if (absolutePath == null || absolutePath.length() ==0 ||
                fileName == null || fileName.length() == 0) {
            Toast.makeText(this,R.string.alert_supply_filename, Toast.LENGTH_SHORT).show();
            return false;
        }

        // Do we have a filename if the extension is thrown away?
        String copyName = FileSaveFragment.NameNoExtension(fileName);
        if (copyName == null || copyName.length() == 0 ) {
            Toast.makeText(this,R.string.alert_supply_filename, Toast.LENGTH_SHORT).show();
            return false;
        }

        // Allow only alpha-numeric names. Simplify dealing with reserved path
        // characters.
        if (!FileSaveFragment.IsAlphaNumeric(fileName)) {
            Toast.makeText(this,R.string.alert_bad_filename_chars, Toast.LENGTH_SHORT).show();
            return false;
        }

        // No overwrite of an existing file.
        if (FileSaveFragment.FileExists(absolutePath, fileName)) {
            Toast.makeText(this,R.string.alert_file_exists, Toast.LENGTH_SHORT).show();
            return false;
        }

        return true;
    }

    @Override
    public void onConfirmSave(String absolutePath, String fileName) {
        if (onCanSave(absolutePath,fileName))
            outputArchiveFilePath.setText(absolutePath +"/"+fileName);
    }

    public void openDestinationArchiveSelector(View unused) {
        // TODO handle Cancel case without useless error messages

        String fragTag = getResources().getString(R.string.tag_fragment_FileSave);

        int idx = archiveTypeSelector.indexOfChild(
                archiveTypeSelector.findViewById(
                        archiveTypeSelector.getCheckedRadioButtonId()));
        String ext = OutputArchiveType.values()[idx].getValue();

        // Get an instance supplying a default extension, captions and
        // icon appropriate to the calling application/activity.
        FileSaveFragment fsf = FileSaveFragment.newInstance(ext,
                android.R.string.ok,
                android.R.string.cancel,
                R.string.app_name,
                R.string.edit_hint,
                R.string.dest_archive_filename_header,
                R.drawable.xfiles_archive);
        fsf.show(getFragmentManager(), fragTag);
    }

    // kill RH if no compress task active and it wasn't main activity the one that launched this activity
    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (MainActivity.mainActivity == null) MainActivity.context = null;

        if(!standaloneMode)
            if (MainActivity.mainActivity == null && ProgressIndicator.busy.get() == null)
                MainActivity.killRHWrapper();
    }
}

```

`app/src/main/java/it/pgp/xfiles/dialogs/compress/ExtractActivity.java`:

```java
package it.pgp.xfiles.dialogs.compress;

import android.content.Intent;
import android.os.Bundle;
import android.support.annotation.Nullable;
import android.view.View;
import android.widget.EditText;
import android.widget.RadioGroup;
import android.widget.Toast;

import java.util.Collections;
import java.util.List;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.service.BaseBackgroundService;
import it.pgp.xfiles.service.ExtractService;
import it.pgp.xfiles.service.params.ExtractParams;
import it.pgp.xfiles.utils.FileSelectFragment;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.ArchivePathContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

/**
 * Created by pgp on 21/11/17
 */

public class ExtractActivity extends EffectActivity implements FileSelectFragment.Callbacks {

    // TODO should be populated with nearest directory path (parent of archive, or current open directory)
    private LocalPathContent candidateExtractDirectory;
    private boolean isWholeArchiveExtract;

    String filename; // on single selection
    String password;

    private EditText destDirectoryEditText;

    private BasePathContent srcArchiveWithSubDir;

    private List<BasePathContent> srcArchives;

    RadioGroup intermediateDirectoryPolicyRadioGroup; // only enabled when extracting a whole archive (not extracting single items from within the archive)

    private boolean smartDirectoryCreation = false;

    private void getSrcArchiveWithSubDirOrFinish() {
        srcArchiveWithSubDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
        if (srcArchiveWithSubDir.providerType != ProviderType.LOCAL_WITHIN_ARCHIVE &&
                srcArchiveWithSubDir.providerType != ProviderType.LOCAL) {
            Toast.makeText(this,"Unexpected path content type",Toast.LENGTH_SHORT).show();
            finish();
            return;
        }
        if (srcArchiveWithSubDir.errorCode != null) {
            Toast.makeText(this,"File ops helper error: "+srcArchiveWithSubDir.errorCode.getValue(),Toast.LENGTH_SHORT).show();
            finish();
            return;
        }
        isWholeArchiveExtract = srcArchiveWithSubDir.providerType == ProviderType.LOCAL;
    }

    private BasePathContent getCandidateExtractDirectory() {
        BasePathContent defaultPath = new LocalPathContent(Misc.internalStorageDir.getAbsolutePath());

        if (srcArchiveWithSubDir.errorCode != null) {
            Toast.makeText(this,"File ops helper error: "+srcArchiveWithSubDir.errorCode.getValue(),Toast.LENGTH_SHORT).show();
            return defaultPath;
        }

        switch (srcArchiveWithSubDir.providerType) {
            case LOCAL:
                return srcArchiveWithSubDir;
            case LOCAL_WITHIN_ARCHIVE:
                return new LocalPathContent(((ArchivePathContent)srcArchiveWithSubDir).archivePath).getParent();
            default:
                Toast.makeText(this,"Invalid path type for extraction",Toast.LENGTH_SHORT).show();
                return defaultPath;
        }
    }

    public void extract_ok(View unused) {
        // check if sub items or nothing selected
        List<String> selectedItems = MainActivity.mainActivity.getCurrentBrowserAdapter().getSelectedItemsAsNameOnlyStrings();

        if (selectedItems.size()==0) selectedItems = null;

        // dialog was loaded from context-menu, on single selection
        if (filename != null) {
            if (srcArchiveWithSubDir.providerType==ProviderType.LOCAL) {
                // context-extract from outside archive, so extract content of archive into dest dir
                srcArchiveWithSubDir = srcArchiveWithSubDir.concat(filename);
            }
            else if (srcArchiveWithSubDir.providerType==ProviderType.LOCAL_WITHIN_ARCHIVE) {
                // context extract from within archive, so extract that file into dest dir
                selectedItems = Collections.singletonList(filename);
            }
            else {
                Toast.makeText(this,"Unexpected path type",Toast.LENGTH_LONG).show();
                return;
            }
        }
        else { // multiple archives to extract, or multiple items within a single archive
            if(selectedItems == null) throw new RuntimeException("Guard block");
            if (isWholeArchiveExtract)
                srcArchives = MainActivity.mainActivity.getCurrentBrowserAdapter().getSelectedItemsAsPathContents();
        }

        LocalPathContent destDir = new LocalPathContent(destDirectoryEditText.getText().toString());

        if(isWholeArchiveExtract) {
            int idx = intermediateDirectoryPolicyRadioGroup.indexOfChild(
                    intermediateDirectoryPolicyRadioGroup.findViewById(
                            intermediateDirectoryPolicyRadioGroup.getCheckedRadioButtonId()));

            if (idx == 2) { // smart subdirectory creation
                smartDirectoryCreation = true;
            }
            else if (idx == 0) { // always create subdirectory
                String archiveFilename = srcArchiveWithSubDir.getName();
                // strip extension
                int dotIdx = archiveFilename.lastIndexOf('.');
                if(dotIdx <= 0) archiveFilename += ".extracted";
                else archiveFilename = archiveFilename.substring(0,dotIdx);
                destDir = (LocalPathContent) destDir.concat(archiveFilename);
            }
            // else if (idx == 1) {} // nothing to be done for no subdirectory creation
        }

        Intent startIntent = new Intent(MainActivity.mainActivity,ExtractService.class);
        startIntent.setAction(BaseBackgroundService.START_ACTION);
        startIntent.putExtra(
                "params",
                new ExtractParams(
                        srcArchives != null ? srcArchives: Collections.singletonList(srcArchiveWithSubDir),
                        destDir,
                        password,
                        selectedItems,
                        smartDirectoryCreation
                ));
        startService(startIntent);

        finish();
    }

    @Override
    public void onConfirmSelect(String absolutePath, String fileName) {
        destDirectoryEditText.setText(absolutePath);
    }

    @Override
    public boolean isValid(String absolutePath, String fileName) {
        return true;
    }

    public void openDestinationFolderSelector(View unused) {
        String fragTag = getResources().getString(R.string.tag_fragment_FileSelect);

        // Set up a selector for directory selection.
        FileSelectFragment fsf = FileSelectFragment.newInstance(
                FileSelectFragment.Mode.DirectorySelector,
                android.R.string.ok,
                android.R.string.cancel,
                R.string.alert_file_select,
                R.drawable.xfiles_new_app_icon,
                R.drawable.xf_dir_blu,
                R.drawable.xfiles_file_icon);

        fsf.show(getFragmentManager(), fragTag);
    }

    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle("Extract");
        setActivityIcon(R.drawable.xfiles_extract);
        getSrcArchiveWithSubDirOrFinish();
        Intent intent = getIntent();
        filename = intent.getStringExtra("filename");
        password = intent.getStringExtra("password");
        setContentView(R.layout.extract_layout);
        destDirectoryEditText = findViewById(R.id.extractDirectoryEditText);
        destDirectoryEditText.setText(getCandidateExtractDirectory().dir);
        intermediateDirectoryPolicyRadioGroup = findViewById(R.id.intermediateDirectoryPolicyRadioGroup);
        if(!isWholeArchiveExtract) {
            intermediateDirectoryPolicyRadioGroup.setVisibility(View.GONE);
            findViewById(R.id.intermediateDirectoryPolicyTextView).setVisibility(View.GONE);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/dragdroplist/DragDropItemTouchHelperCallback.java`:

```java
package it.pgp.xfiles.dragdroplist;

import android.support.v7.widget.RecyclerView;
import android.support.v7.widget.helper.ItemTouchHelper;

import java.util.ArrayList;
import java.util.Collections;

/**
 * Web source:
 * https://medium.com/@gopalawasthi383/android-recyclerview-drag-and-drop-a3f227cdb641
 */

public class DragDropItemTouchHelperCallback extends ItemTouchHelper.Callback {
    int dragFrom = -1;
    int dragTo = -1;

    final DragNDropAdapter adapter;
    final ArrayList arrayList;

    public DragDropItemTouchHelperCallback(DragNDropAdapter adapter, ArrayList arrayList) {
        this.adapter = adapter;
        this.arrayList = arrayList;
    }

    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {
        // get the viewHolder's and target's positions in your adapter data, swap them
        if(viewHolder.getItemViewType() != target.getItemViewType()){
            return false;
        }
        int fromPosition = viewHolder.getAdapterPosition();
        int toPosition = target.getAdapterPosition();


        if(dragFrom == -1) {
            dragFrom =  fromPosition;
        }
        dragTo = toPosition;

        if(dragFrom != -1 && dragTo != -1 && dragFrom != dragTo) {
            reallyMoved(dragFrom, dragTo);
            dragFrom = dragTo = -1;
        }

        // and notify the adapter that its dataset has changed
        adapter.notifyItemMoved(viewHolder.getAdapterPosition(), target.getAdapterPosition());
        //nestedScrollView.requestDisallowInterceptTouchEvent(false);
        //recyclerView.setNestedScrollingEnabled(false);

        return true;
    }

    private void reallyMoved(int dragFrom, int dragTo) {
        if(dragFrom == 0 || dragTo == arrayList.size()+1) return;
        Collections.swap(arrayList, dragFrom-1, dragTo-1);
    }

    @Override
    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {}

    //defines the enabled move directions in each state (idle, swiping, dragging).
    @Override
    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {
        if(viewHolder.getItemViewType() == DragNDropAdapter.HEADERVIEW)
            return makeMovementFlags(0,0);
        int dragflags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;
        return makeMovementFlags(dragflags,0);
    }
}

```

`app/src/main/java/it/pgp/xfiles/dragdroplist/DragNDropAdapter.java`:

```java
package it.pgp.xfiles.dragdroplist;

import android.content.Context;
import android.support.annotation.NonNull;
import android.support.v7.widget.RecyclerView;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.CheckBox;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.Locale;

import it.pgp.xfiles.R;
import it.pgp.xfiles.SortingItem;

public class DragNDropAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolder> {
    Context context;
    ArrayList<SortingItem> arrayList;
    private final Locale currentLocale;
    public static final int HEADERVIEW =0;
    public static final int LISTVIEW =1;

    public DragNDropAdapter(Context context, ArrayList<SortingItem> arrayList) {
        this.arrayList =arrayList;
        this.context = context;
        currentLocale = context.getResources().getConfiguration().locale;
    }

    @NonNull
    @Override
    public RecyclerView.ViewHolder onCreateViewHolder(@NonNull ViewGroup viewGroup, int i) {
        View v;
        if(getItemViewType(i) == HEADERVIEW) {
            v = LayoutInflater.from(context).inflate(R.layout.sorting_dialog_header_view,viewGroup,false);
            return new HeaderViewHoler(v);
        }
        v = LayoutInflater.from(context).inflate(R.layout.dragitem,viewGroup,false);
        return new MyHolder(v);
    }

    @Override
    public void onBindViewHolder(@NonNull RecyclerView.ViewHolder viewHolder, int i) {
        if(viewHolder.getItemViewType() == HEADERVIEW ){
            HeaderViewHoler headerViewHoler = (HeaderViewHoler)viewHolder;
        }
        else {
            MyHolder myHolder = (MyHolder) viewHolder;
            SortingItem item = arrayList.get(i - 1);
            myHolder.name.setText(item.comparatorField.getLocalized(currentLocale));
            myHolder.sel.setChecked(item.isSelected());
            myHolder.sel.setOnCheckedChangeListener((b,c) -> item.setSelected(c));
            myHolder.rev.setChecked(item.isReversed());
            myHolder.rev.setOnCheckedChangeListener((b,c) -> item.setReversed(c));
        }
    }

    @Override
    public int getItemViewType(int position) {
        if(position == 0){
            return HEADERVIEW;
        }
        return LISTVIEW;
    }

    @Override
    public int getItemCount() {
        return arrayList.size()+1;
    }

    public SortingItem[] getSelectedItems() {
        ArrayList<SortingItem> a = new ArrayList<>();
        for (int i=0; i<arrayList.size(); i++)
            if (arrayList.get(i).isSelected()) a.add(arrayList.get(i));
        return a.toArray(new SortingItem[0]);
    }

    static class MyHolder extends RecyclerView.ViewHolder{
        TextView name;
        CheckBox sel, rev;
        public MyHolder(@NonNull View itemView) {
            super(itemView);
            name = itemView.findViewById(R.id.sortingAttributeLabel);
            sel = itemView.findViewById(R.id.sortingAttributeSelectedCheckbox);
            rev = itemView.findViewById(R.id.sortingAttributeReversedCheckbox);
        }
    }

    static class HeaderViewHoler extends RecyclerView.ViewHolder{
        TextView headertextview;
        public HeaderViewHoler(@NonNull View itemView) {
            super(itemView);
//            headertextview = itemView.findViewById(R.id.header);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/enums/ArchiveType.java`:

```java
package it.pgp.xfiles.enums;

import java.util.HashSet;
import java.util.Set;

import it.pgp.xfiles.R;

/**
 * Created by pgp on 23/05/17
 * Archive types supported by rootHelper's p7zip embedded library
 */

public enum ArchiveType {
    _7Z("7z", R.drawable.xfiles_archive_7z),
    XZ("xz", R.drawable.xfiles_archive_xz),
    RAR("rar", R.drawable.xfiles_archive_rar),
    RAR5("rar5", R.drawable.xfiles_archive_rar),
    ZIP("zip", R.drawable.xfiles_archive_zip),
    CAB("cab", R.drawable.xfiles_archive_cab),
    GZ("gz", R.drawable.xfiles_archive_gz),
    BZ2("bz2", R.drawable.xfiles_archive_bz2),
    TAR("tar", R.drawable.xfiles_archive_tar), // with offset
    APK("apk", R.drawable.xfiles_archive_apk),
    UNKNOWN("unknown", -1);

    public final String s;
    public final int resId;

    ArchiveType(String s, int resId) {
        this.s = s;
        this.resId = resId;
    }

    public static final Set<String> formats = new HashSet<String>(){{
        for (ArchiveType a : ArchiveType.values()) {
            if (a != RAR5 && a != UNKNOWN) {
                add(a.s);
            }
        }
    }};
}

```

`app/src/main/java/it/pgp/xfiles/enums/BrowserViewMode.java`:

```java
package it.pgp.xfiles.enums;

import android.widget.AbsListView;
import android.widget.ArrayAdapter;
import android.widget.Checkable;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.BrowserAdapter;
import it.pgp.xfiles.adapters.BrowserGridAdapter;
import it.pgp.xfiles.adapters.BrowserListAdapter;
import it.pgp.xfiles.adapters.continuousselection.CSCheckboxes;
import it.pgp.xfiles.adapters.continuousselection.ContSelListener;
import it.pgp.xfiles.adapters.continuousselection.ContSelListenerGrid;
import it.pgp.xfiles.adapters.continuousselection.ContSelListenerList;

/**
 * Created by pgp on 31/10/16
 */

public enum BrowserViewMode {
    LIST(R.layout.listview_layout,R.id.mainBrowserListView),
    GRID(R.layout.gridview_layout,R.id.mainBrowserGridView);

    int layout;
    int id;

    BrowserViewMode(int layout, int id) {
        this.layout = layout;
        this.id = id;
    }

    static final RuntimeException invalidMode = new RuntimeException("Invalid browser view mode");

    public BrowserAdapter newAdapter(MainActivity mainActivity, List<BrowserItem> objects) {
        return (this==LIST)?new BrowserListAdapter(mainActivity,objects):new BrowserGridAdapter(mainActivity,objects);
    }

    public BrowserViewMode next() {
        switch (this) {
            case LIST: return GRID;
            case GRID: return LIST;
            default: throw invalidMode;
        }
    }

    public int getLayout() {
        return layout;
    }

    public ContSelListener buildCSListener(AbsListView lv, ArrayAdapter adapter, List<? extends Checkable> objects, CSCheckboxes csCheckboxes) {
        switch (this) {
            case LIST: return new ContSelListenerList(lv,adapter,objects,csCheckboxes);
            case GRID: return new ContSelListenerGrid(lv,adapter,objects,csCheckboxes);
            default: throw invalidMode;
        }
    }

    public boolean isFullPadLayout() {
        return this==GRID;
    }

    public int getId() {
        return id;
    }
}

```

`app/src/main/java/it/pgp/xfiles/enums/ComparatorField.java`:

```java
package it.pgp.xfiles.enums;

import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Pair;

public enum ComparatorField {
    FILENAME,
    DATE,
    SIZE,
    TYPE,
    DIR;

    public static final Map<Locale,Map<ComparatorField,String>> localizedLabels;

    public static final Map<Integer, Pair<ComparatorField,Boolean>> fromResMap;

    static {
        Map<Locale,Map<ComparatorField,String>> localizedLabels_ = new HashMap<>();

        // IT
        Map<ComparatorField,String> itMap = new HashMap<>();
        itMap.put(FILENAME,"Nome file");
        itMap.put(DATE,"Data");
        itMap.put(SIZE,"Dimensione");
        itMap.put(TYPE,"Tipo");
        itMap.put(DIR,"Cartella");
        localizedLabels_.put(Locale.ITALIAN,Collections.unmodifiableMap(itMap));

        // EN
        Map<ComparatorField,String> enMap = new HashMap<>();
        enMap.put(FILENAME,"Filename");
        enMap.put(DATE,"Date");
        enMap.put(SIZE,"Size");
        enMap.put(TYPE,"Type");
        enMap.put(DIR,"Directory");
        localizedLabels_.put(Locale.ENGLISH,Collections.unmodifiableMap(enMap));

        // ...Add other languages if needed...

        localizedLabels = Collections.unmodifiableMap(localizedLabels_);

        fromResMap = new HashMap<>();
        fromResMap.put(R.id.sortByFilename,new Pair<>(ComparatorField.FILENAME,false));
        fromResMap.put(R.id.sortByFilenameDesc,new Pair<>(ComparatorField.FILENAME,true));
        fromResMap.put(R.id.sortByDate,new Pair<>(ComparatorField.DATE,false));
        fromResMap.put(R.id.sortByDateDesc,new Pair<>(ComparatorField.DATE,true));
        fromResMap.put(R.id.sortBySize,new Pair<>(ComparatorField.SIZE,false));
        fromResMap.put(R.id.sortBySizeDesc,new Pair<>(ComparatorField.SIZE,true));
        fromResMap.put(R.id.sortByType,new Pair<>(ComparatorField.TYPE,false));
        fromResMap.put(R.id.sortByTypeDesc,new Pair<>(ComparatorField.TYPE,true));
    }

    public static String getLocalizedString(Locale locale,ComparatorField comparatorField) {
        try {
            return localizedLabels.get(locale).get(comparatorField);
        }
        catch (NullPointerException n) {
            return null;
        }
    }

    public String getLocalized(Locale locale) {
        try {
            return localizedLabels.get(locale).get(this);
        }
        catch (NullPointerException n) {
            return localizedLabels.get(Locale.ENGLISH).get(this);
        }
    }

    // DEBUG
//    public String name1() {
//        switch(this) {
//            case FILENAME:
//                return "FILE";
//            case DATE:
//                return "DATE";
//            case SIZE:
//                return "SIZE";
//            case TYPE:
//                return "TYPE";
//            case DIR:
//                return "DIR1";
//        }
//        return null;
//    }
}

```

`app/src/main/java/it/pgp/xfiles/enums/CopyMoveMode.java`:

```java
package it.pgp.xfiles.enums;

/**
 * Created by pgp on 31/10/16
 */

public enum CopyMoveMode {
    COPY,
    MOVE
}

```

`app/src/main/java/it/pgp/xfiles/enums/FileIOMode.java`:

```java
package it.pgp.xfiles.enums;

/**
 * Created by pgp on 06/11/17
 */

public enum FileIOMode {
    READFROMFILE,
    WRITETOFILE
}

```

`app/src/main/java/it/pgp/xfiles/enums/FileMode.java`:

```java
package it.pgp.xfiles.enums;

/**
 * Created by pgp on 31/10/16
 */

public enum FileMode {
    FILE(0644),
    DIRECTORY(0755);

    int mask;

    FileMode(int mask) {
        this.mask = mask;
    }

    public int getDefaultMask() {
        return mask;
    }
}

```

`app/src/main/java/it/pgp/xfiles/enums/FileOpsAction.java`:

```java
package it.pgp.xfiles.enums;

/**
 * Created by pgp on 16/03/17
 */

public enum FileOpsAction {
    CONFLICT,
    PAUSE,
    RESUME,
    CANCEL
}

```

`app/src/main/java/it/pgp/xfiles/enums/FileOpsErrorCodes.java`:

```java
package it.pgp.xfiles.enums;

/**
 * Created by pgp on 14/02/17 (adapted from roothelperclient ControlCodes)
 */

public enum FileOpsErrorCodes {
    OK("OK"),
    COMMANDER_CANNOT_SHIFT("Cannot go back or ahead"),
    COMMANDER_CANNOT_REFRESH("Cannot refresh"),
    COMMANDER_CANNOT_ACCESS("Cannot access"), // generic
    NOT_IMPLEMENTED("Not implemented"),
    ILLEGAL_ARGUMENT("Illegal argument"),
    CURRENT_DIR_NO_LONGER_AVAILABLE("Current directory no longer available"),

    TRANSFER_ERROR(""), // generic copy error (read/write error)
    TRANSFER_CANCELLED(""), // transfer explicitly cancelled by user
    DEST_FILE_ALREADY_EXISTS("Destination file already exists"), // to trigger file conflict dialog

    ROOTHELPER_INIT_ERROR("Cannot start or connect to roothelper process"),
    COMPRESS_ERROR("Error during compression"), // TODO duplicate error messages from rh server's 7z code

    NULL_OR_WRONG_PASSWORD("Null or wrong password"),
    CRC_FAILED("CRC failed"), // wrong password in extract as well

    // SFTP errors
    MALFORMED_PATH_ERROR("Malformed path"),
    CONNECTION_ERROR("Connection error"),
    SFTP_PATH_CANONICALIZE_ERROR("SFTP path canonicalization error"), // FIXME to be removed, just for debugging
    AUTHENTICATION_ERROR("Authentication error"), // to trigger password insert
    HOST_KEY_CHANGED_ERROR("Host key changed"), // to trigger dialog on host key changed
    HOST_KEY_INEXISTENT_ERROR("Host key does not exists") // to trigger dialog on host key not found
    ;

    final String value;

    FileOpsErrorCodes(String value) {
        this.value = value;
    }

    // enum value to string value
    public String getValue() {
        return value;
    }

}

```

`app/src/main/java/it/pgp/xfiles/enums/ForegroundServiceType.java`:

```java
package it.pgp.xfiles.enums;

/**
 * Created by pgp on 13/11/17
 * To be used with ProgressIndicator
 */

public enum ForegroundServiceType {
    FILE_TRANSFER,
    FILE_ARCHIVING,
    XRE_TRANSFER,
    XRE_HASH, // currently without overlay usage, only resource locking for long term tls connection, enable overlay when progress indication will be implemented in rh's hashFile
    SFTP_TRANSFER,
    SMB_TRANSFER,
    URL_DOWNLOAD,
    FIND,
    CREATE_FILE
}

```

`app/src/main/java/it/pgp/xfiles/enums/OutputArchiveType.java`:

```java
package it.pgp.xfiles.enums;

import it.pgp.xfiles.R;

/**
 * Created by pgp on 30/05/17
 * Supported 7z output formats
 */

public enum OutputArchiveType {
    // no need to use explicit numberings, ordinal() is enough
    _7Z("7z", R.id._7zRadioButton),
    ZIP("zip", R.id.zipRadioButton),
    TAR("tar", R.id.tarRadioButton), // with offset
    GZ("gz", R.id.gzRadioButton),
    BZ2("bz2", R.id.bz2RadioButton),
    XZ("xz", R.id.xzRadioButton)
    ;

    final String s;
    final int id;

    OutputArchiveType(String s, int id) {
        this.s = s;
        this.id = id;
    }

    public String getValue() {
        return s;
    }

    public int getId() {
        return id;
    }
}

```

`app/src/main/java/it/pgp/xfiles/enums/ProviderType.java`:

```java
package it.pgp.xfiles.enums;

public enum ProviderType {
    LOCAL,
    LOCAL_WITHIN_ARCHIVE,
    SFTP,
    XFILES_REMOTE,
    SMB,
    URL_DOWNLOAD
}

```

`app/src/main/java/it/pgp/xfiles/enums/ServiceStatus.java`:

```java
package it.pgp.xfiles.enums;

/**
 * Created by pgp on 29/03/17
 */

public enum ServiceStatus {
    ACTIVE,
    PAUSED,
    CANCELLED,
    COMPLETED
}

```

`app/src/main/java/it/pgp/xfiles/enums/SshKeyType.java`:

```java
package it.pgp.xfiles.enums;

public enum SshKeyType {
    RSA,
    ED25519
}

```

`app/src/main/java/it/pgp/xfiles/enums/WIFI_AP_STATE.java`:

```java
package it.pgp.xfiles.enums;

public enum WIFI_AP_STATE {
    WIFI_AP_STATE_DISABLING,
    WIFI_AP_STATE_DISABLED,
    WIFI_AP_STATE_ENABLING,
    WIFI_AP_STATE_ENABLED,
    WIFI_AP_STATE_FAILED
}
```

`app/src/main/java/it/pgp/xfiles/enums/conflicthandling/ConflictDecision.java`:

```java
package it.pgp.xfiles.enums.conflicthandling;

import java.util.HashMap;
import java.util.Map;

import it.pgp.xfiles.R;

public enum ConflictDecision {
    CD_SKIP((byte)0x00, R.id.conflictSkip),
    CD_SKIP_ALL((byte)0x10,R.id.conflictSkipAll),
    CD_OVERWRITE((byte)0x01,R.id.conflictOverwrite),
    CD_OVERWRITE_ALL((byte)0x11,R.id.conflictOverwriteAll),
    CD_REN_SRC((byte)0x02,R.id.conflictRenameSrc),
    CD_REN_DEST((byte)0x03,R.id.conflictRenameDest),
    CD_REN_SRC_ALL((byte)0x12,R.id.conflictAutoRenameSrc),
    CD_REN_DEST_ALL((byte)0x13,R.id.conflictAutoRenameDest),

    CD_MERGE((byte)0x04,R.id.conflictMerge),
//    CD_MERGE_RECURSIVE((byte)0x14,R.id.conflictMergeRecursive), // not implemented yet
    CD_MERGE_ALL((byte)0x24,R.id.conflictMergeAll),

    CD_CANCEL((byte)0x05,R.id.conflictCancel),

    NO_PREV_DEC((byte)0xFF,-1);

    public static final Map<Integer,ConflictDecision> m = new HashMap<Integer,ConflictDecision>(){{
        for (ConflictDecision c: ConflictDecision.values()) put(c.res,c);
    }};

    public static ConflictDecision fromResource(int res) {
        return m.get(res);
    }

    byte i;
    int res;
    
    ConflictDecision(byte i, int res) {
        this.i = i;
        this.res = res;
    }

    public byte getValue() {
        return i;
    }

    public int getResource() {
        return 0;
    }
}

```

`app/src/main/java/it/pgp/xfiles/enums/conflicthandling/ConflictType.java`:

```java
package it.pgp.xfiles.enums.conflicthandling;

import it.pgp.xfiles.R;

public enum ConflictType {
    FILE((byte)0x00, R.drawable.xfiles_file_icon),
    DIR((byte)0x01, R.drawable.xf_dir_blu);

    byte b;
    int imageRes;

    ConflictType(byte b, int imageRes) {
        this.b = b;
        this.imageRes = imageRes;
    }

    public byte getValue() {
        return b;
    }

    public int getImageRes() {
        return imageRes;
    }

    public static ConflictType fromNumeric(byte b) {
        switch (b) {
            case ((byte)0x00):
                return FILE;
            case ((byte)0x01):
                return DIR;
            default:
                return null;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/enums/conflicthandling/ErrorDecision.java`:

```java
package it.pgp.xfiles.enums.conflicthandling;

public enum ErrorDecision {
    ED_CONTINUE((byte)0x00),
    ED_CANCEL((byte)0xFF);

    byte i;

    ErrorDecision(byte i) {
        this.i = i;
    }

    public byte getValue() {
        return i;
    }
}

```

`app/src/main/java/it/pgp/xfiles/exceptions/DirCommanderException.java`:

```java
package it.pgp.xfiles.exceptions;

/**
 * Created by pgp on 19/01/18
 * For now, indicating only that current dir cannot be accessed by dir commander
 * Could be generalized (with an exception type enum) including other access errors of dir commander
 */

public class DirCommanderException extends Exception {
    public DirCommanderException() {
        super("Dir not accessible by commander");
    }

    public DirCommanderException(String message) {
        super(message);
    }
}

```

`app/src/main/java/it/pgp/xfiles/exceptions/InterruptedTransferAsIOException.java`:

```java
package it.pgp.xfiles.exceptions;

import java.io.IOException;

/**
 * Created by pgp on 16/11/17
 * Just to check whether to show copy error in case of IOException
 * (SSHJ IOException by stream copier listener trick, will cancel transfer
 * web source: https://github.com/hierynomus/sshj/issues/288 )
 */

public class InterruptedTransferAsIOException extends IOException {
    public InterruptedTransferAsIOException() {
        super("Sftp transfer cancelled by user");
    }
}

```

`app/src/main/java/it/pgp/xfiles/fileservers/FileServer.java`:

```java
package it.pgp.xfiles.fileservers;

import it.pgp.xfiles.R;

public enum FileServer {
    FTP(new SimpleFTPServer(),R.id.itemShareOverFTP,R.id.ftpServerButton),
    HTTP(new SimpleHTTPServer(),R.id.itemShareOverHTTP,R.id.httpServerButton);

    public final SimpleFileServer server;
    public final int menuId;
    public final int buttonId;

    FileServer(SimpleFileServer server, int menuId, int buttonId) {
        this.server = server;
        this.menuId = menuId;
        this.buttonId = buttonId;
    }

    public static FileServer fromMenuRes(int res) {
        switch(res) {
            case R.id.itemShareOverFTP:
                return FTP;
            case R.id.itemShareOverHTTP:
                return HTTP;
            default:
                throw new RuntimeException("Invalid resource id provided");
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/fileservers/HTTPSessionThread.java`:

```java
package it.pgp.xfiles.fileservers;

import android.util.Log;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.net.Socket;
import java.net.URLDecoder;
import java.net.URLEncoder;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Set;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.io.RobustLocalFileInputStream;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

/**
 * Adapted from:
 * http://cs.au.dk/~amoeller/WWW/examples/FileServer.java
 */

public class HTTPSessionThread extends Thread {

    private final Set<Socket> clientConnections;
    private final Socket connection;
    private final String wwwhome;

    private static String getHeader(String path) {
        return "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n"+
                "<html>\n" +
                "<head>\n" +
                "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">\n" +
                "<title>Directory listing for "+Misc.escapeHtml(path)+"</title>\n" +
                "</head>\n" +
                "<body>\n" +
                "<h1>Directory listing for "+Misc.escapeHtml(path)+"</h1>\n" +
                "<hr>\n" +
                "<ul>\n";
    }

    private static final String footer = "</ul>\n" +
            "<hr>\n" +
            "</body>\n" +
            "</html>";

    // html dir listing output copied from python3 http.server module
    private static String assembleDirList(LocalPathContent path) throws UnsupportedEncodingException {
        StringBuilder sb = new StringBuilder();

        // 1st attempt, Java
        try {
            List<File> dircontent = Arrays.asList(new File(path.dir).listFiles());
            Collections.sort(dircontent);

            for (File f: dircontent) {
                String dirTermination = f.isDirectory()?"/":"";
                sb.append("<li><a href=\"");
                sb.append(URLEncoder.encode(f.getName(), "UTF-8").replace("+","%20")).append(dirTermination);
                sb.append("\">");
                sb.append(Misc.escapeHtml(f.getName())).append(dirTermination);
                sb.append("</a></li>\n");
            }

            return sb.toString();
        }
        catch (Exception e) {
            Log.e("assembleDirList","Exception during listdir, trying with roothelper...", e);
        }

        // 2nd attempt, via RH
        sb = new StringBuilder();
        GenericDirWithContent gdwc = MainActivity.getRootHelperClient().listDirectory(path);

        if (gdwc.errorCode == null)
            for (BrowserItem f: gdwc.content) {
                String dirTermination = (f.isDirectory?"/":"");
                sb.append("<li><a href=\"");
                sb.append(URLEncoder.encode(f.getFilename(), "UTF-8").replace("+","%20")).append(dirTermination);
                sb.append("\">");
                sb.append(Misc.escapeHtml(f.getFilename())).append(dirTermination);
                sb.append("</a></li>\n");
            }

        return sb.toString();
    }

    private static String guessContentType(String path)
    {
        if (path.endsWith(".html") || path.endsWith(".htm"))
            return "text/html";
        else if (path.endsWith(".txt") || path.endsWith(".java"))
            return "text/plain";
        else if (path.endsWith(".gif"))
            return "image/gif";
        else if (path.endsWith(".class"))
            return "application/octet-stream";
        else if (path.endsWith(".jpg") || path.endsWith(".jpeg"))
            return "image/jpeg";
        else
            return "text/plain";
    }

    private static void sendFile(InputStream in, OutputStream out)
    {
        try {
            byte[] buffer = new byte[1000];
            for(;;) {
                int readBytes = in.read(buffer);
                if (readBytes <= 0) {
                    Log.e("sendFile", "EOF or read error");
                    break;
                }
                out.write(buffer,0,readBytes);
            }
        }
        catch (IOException e) {
            Log.e("sendFile", "IOEXCEPTION or EOF", e);
        }
    }

    private static void log(Socket connection, String msg)
    {
        Log.e(HTTPSessionThread.class.getName(), new Date() + " [" + connection.getInetAddress().getHostAddress() + ":" + connection.getPort() + "] " + msg);
    }

    private static void errorReport(PrintStream pout, Socket connection,
                                    String code, String title, String msg)
    {
        pout.print("HTTP/1.0 " + code + " " + title + "\r\n" +
                "\r\n" +
                "<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\r\n" +
                "<TITLE>" + code + " " + title + "</TITLE>\r\n" +
                "</HEAD><BODY>\r\n" +
                "<H1>" + title + "</H1>\r\n" + msg + "<P>\r\n" +
                "<HR><ADDRESS>SimpleHTTPServer 1.0 at " +
                connection.getLocalAddress().getHostName() +
                " Port " + connection.getLocalPort() + "</ADDRESS>\r\n" +
                "</BODY></HTML>\r\n");
        log(connection, code + " " + title);
    }

    public HTTPSessionThread(Socket connection, String wwwhome, Set<Socket> clientConnections) {
        this.clientConnections = clientConnections; // just to remove itself from the set when this thread ends
        this.connection = connection;
        this.wwwhome = wwwhome;
    }

    @Override
    public void run() {
        Log.i(getClass().getName(),"Client session thread started");
        try {
            // wait for request
            BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));
            OutputStream out = new BufferedOutputStream(connection.getOutputStream());
            PrintStream pout = new PrintStream(out);

            // read first line of request (ignore the rest)
            String request = in.readLine();
            if (request==null) {
                Log.i(getClass().getName(),"Client session ended");
                return;
            }
            log(connection, request);
            while (true) {
                String misc = in.readLine();
                if (misc==null || misc.length()==0)
                    break;
            }

            // parse the line
            if (!request.startsWith("GET") || request.length()<14 ||
                    !(request.endsWith("HTTP/1.0") || request.endsWith("HTTP/1.1"))) {
                // bad request
                errorReport(pout, connection, "400", "Bad Request",
                        "Your browser sent a request that " +
                                "this server could not understand.");
            } else {
                String req = request.substring(4, request.length()-9).trim();
                if (req.contains("..") || req.contains("/.ht") || req.endsWith("~")) {
                    // evil hacker trying to read non-wwwhome or secret file
                    errorReport(pout, connection, "403", "Forbidden",
                            "You don't have permission to access the requested URL.");
                } else {
                    String subpath = URLDecoder.decode(req,"UTF-8");
                    String path = wwwhome + "/" + subpath;
                    LocalPathContent lpc = new LocalPathContent(path);
                    boolean isDir = MainActivity.getRootHelperClient().isDir(lpc);
//                    File f = new File(path);
                    if (isDir && !path.endsWith("/")) {
                        // redirect browser if referring to directory without final '/'
                        pout.print("HTTP/1.0 301 Moved Permanently\r\n" +
                                "Location: http://" +
                                connection.getLocalAddress().getHostAddress() + ":" +
                                connection.getLocalPort() + (req.startsWith("/")?"":"/") + req + "/\r\n\r\n");
                        log(connection, "301 Moved Permanently");
                    }
                    else {
                        if (isDir) {
                                /*// if directory, implicitly add 'index.html'
                                path = path + "index.html";
                                f = new File(path);*/

                            // generate and send HTML with dir content
                            try {
                                pout.print("HTTP/1.0 200 OK\r\n" +
                                        "Content-Type: text/html\r\n" +
                                        "Date: " + new Date() + "\r\n" +
                                        "Server: SimpleHTTPServer 1.0\r\n\r\n");
                                pout.print(getHeader(subpath)+assembleDirList(lpc)+footer);
                            } catch (Exception e) {
                                // file not found
                                errorReport(pout, connection, "400", "Not Found",
                                        "The requested URL was not found on this server.");
                            }
                        }
                        else {
                            // stat in order to populate Content-Length header with file size
                            long contentLength;
                            try {
                                SingleStatsItem stat = MainActivity.getRootHelperClient().statFile(new LocalPathContent(path));
                                contentLength = stat.size;
                            }
                            catch(Exception e) {
                                e.printStackTrace();
                                contentLength = -1;
                            }

                            try (RobustLocalFileInputStream file = new RobustLocalFileInputStream(path)) {
                                // send file
//                                InputStream file = new FileInputStream(f);
                                pout.print("HTTP/1.0 200 OK\r\n" +
                                        "Content-Type: " + guessContentType(path) + "\r\n" +
                                        ((contentLength>=0)?("Content-Length: "+contentLength+"\r\n"):"")+
                                        "Date: " + new Date() + "\r\n" +
                                        "Server: SimpleHTTPServer 1.0\r\n\r\n");
                                sendFile(file, out); // send raw file
                                log(connection, "200 OK");
                            }
                            catch (FileNotFoundException e) {
                                Log.e("HTTPSessionThread", "FNFException", e);
                                // file not found
                                errorReport(pout, connection, "404", "Not Found",
                                        "The requested URL was not found on this server.");
                            }
                        }
                    }
                }
            }
            out.flush();
        }
        catch (IOException e) {
            Log.e(getClass().getName(),"IOException", e);
        }
        try {
            connection.close();
        }
        catch (Exception e) {
            Log.e(getClass().getName(),"Exception on close", e);
        }
        Log.i(getClass().getName(),"Client session ended");
        synchronized(clientConnections) {
            clientConnections.remove(connection);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/fileservers/SimpleFTPServer.java`:

```java
package it.pgp.xfiles.fileservers;

import org.apache.ftpserver.ConnectionConfigFactory;
import org.apache.ftpserver.FtpServer;
import org.apache.ftpserver.FtpServerFactory;
import org.apache.ftpserver.listener.ListenerFactory;
import org.apache.ftpserver.usermanager.impl.BaseUser;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Pair;

public class SimpleFTPServer extends SimpleFileServer {

    private FtpServer server;
    public static final int defaultPort = 2121;

    SimpleFTPServer() {
        port = defaultPort;
        serverButtonRes = R.id.ftpServerButton;
    }

    @Override
    public void stopServer() {
        try { server.stop(); }
        catch (Exception e) {e.printStackTrace();}
        server = null;
        MainActivity.showToast("FTP server stopped");
        notifyObservers(new Pair<>(FileServer.FTP.ordinal(), false));
    }

    @Override
    public void startServer() {
        if (server != null) stopServer();
        FtpServerFactory serverFactory = new FtpServerFactory();
        ConnectionConfigFactory connectionConfigFactory = new ConnectionConfigFactory();
        connectionConfigFactory.setAnonymousLoginEnabled(true);

        serverFactory.setConnectionConfig(connectionConfigFactory.createConnectionConfig());
        ListenerFactory factory = new ListenerFactory();
        factory.setPort(port);
        serverFactory.addListener("default", factory.createListener());

        BaseUser user = new BaseUser();
        user.setName("anonymous");
        user.setHomeDirectory(rootPath);
        try {
            serverFactory.getUserManager().save(user);
            server = serverFactory.createServer();
            server.start();
            MainActivity.showToast("FTP server started on port "+port+", root path: "+rootPath);
            notifyObservers(new Pair<>(FileServer.FTP.ordinal(), true));
        }
        catch (Exception e) {
            MainActivity.showToast("Error in starting FTP server");
            e.printStackTrace();
            stopServer();
        }
    }

    @Override
    public boolean isAlive() {
        return server != null &&
                !server.isStopped() &&
                !server.isSuspended();
    }
}

```

`app/src/main/java/it/pgp/xfiles/fileservers/SimpleFileServer.java`:

```java
package it.pgp.xfiles.fileservers;

import android.widget.Button;

import java.util.Observable;

import it.pgp.xfiles.utils.Misc;

public abstract class SimpleFileServer extends Observable {

    public Button serverButton;
    public int serverButtonRes;

    public String rootPath = Misc.internalStorageDir.getAbsolutePath();
    public int port;

    public abstract void startServer();
    public abstract void stopServer();

    public abstract boolean isAlive();

    public void setRootPath(String rootPath) {
        this.rootPath = rootPath;
    }

    public int getPort() {
        return port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public void toggle() {
        if (isAlive()) stopServer(); else startServer();
    }

    @Override
    public synchronized boolean hasChanged() {
        return true;
    }
}

```

`app/src/main/java/it/pgp/xfiles/fileservers/SimpleHTTPServer.java`:

```java
package it.pgp.xfiles.fileservers;

import android.util.Log;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import java.util.HashSet;
import java.util.Set;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Pair;

public class SimpleHTTPServer extends SimpleFileServer {
    public static final int defaultPort = 8000;

    private AcceptorThread acceptorThread;

    public final Set<Socket> clientConnections = new HashSet<>();

    public SimpleHTTPServer() {
        serverButtonRes = R.id.httpServerButton;
        port = defaultPort;
    }

    private class AcceptorThread extends Thread {
        public final ServerSocket acceptorSocket;

        AcceptorThread(int port) throws IOException {
            acceptorSocket = new ServerSocket(port);
        }

        @Override
        public void run() {
            for(;;) {
                try {
                    Socket connection = acceptorSocket.accept();
                    synchronized(clientConnections) {
                        clientConnections.add(connection);
                    }
                    new HTTPSessionThread(connection,rootPath, clientConnections).start();
                }
                catch (Exception e) {
                    e.printStackTrace();
                    SimpleHTTPServer.this.acceptorThread = null;
                    MainActivity.showToast("SimpleHTTPServer: "+(e instanceof SocketException?"acceptor closed":"accept error"));
                    notifyObservers(new Pair<>(FileServer.HTTP.ordinal(), false));
                    disconnectAllClients();
                    return;
                }
            }
        }
    }

    @Override
    public void startServer() {
        if (acceptorThread != null) {
            Log.e(getClass().getName(),"Server object already exists, closing existing...");
            stopServer();
        }
        try {
            acceptorThread = new AcceptorThread(port);
            acceptorThread.start();
        } catch (IOException e) {
            Log.e(getClass().getName(), "IOException - Could not start server: ", e);
            stopServer();
            return;
        }
        MainActivity.showToast("SimpleHTTPServer accepting connections on port " + port +", root path: "+rootPath);
        notifyObservers(new Pair<>(FileServer.HTTP.ordinal(), true));
    }

    @Override
    public void stopServer() {
        try {
            acceptorThread.acceptorSocket.close();
        } catch (Exception ignored) {}
    }

    @Override
    public boolean isAlive() {
        if(acceptorThread != null) {
            Thread.State state = acceptorThread.getState();
            return (!Thread.State.NEW.equals(state)
                    && !Thread.State.TERMINATED.equals(state));
        }
        return false;
    }

    private void disconnectAllClients() {
        synchronized(clientConnections) {
            for(Socket c : clientConnections)
                try {c.close();} catch (Exception ignored) {}
            clientConnections.clear();
        }
    }
}
```

`app/src/main/java/it/pgp/xfiles/io/FlushingBufferedOutputStream.java`:

```java
package it.pgp.xfiles.io;

import java.io.BufferedOutputStream;
import java.io.IOException;
import java.io.OutputStream;

/**
 * Represents a continuous (not necessarily atomic) socket write, made of a group of smaller writes;
 * the actual write to the enclosed outputstream happens on full buffer and on close(),
 * in so allowing to use try with resources
 * It is actually a BufferedOutputStream with close() disabled (calls only flush() instead)
 */

public class FlushingBufferedOutputStream extends BufferedOutputStream {

    public FlushingBufferedOutputStream(OutputStream out) {
        super(out);
    }

    public FlushingBufferedOutputStream(OutputStream out, int size) {
        super(out, size);
    }

    @Override
    public void close() throws IOException {
        flush();
    }
}

```

`app/src/main/java/it/pgp/xfiles/io/RobustLocalFileInputStream.java`:

```java
package it.pgp.xfiles.io;

import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

import it.pgp.xfiles.MainActivity;

public class RobustLocalFileInputStream extends InputStream {

    InputStream i;

    public RobustLocalFileInputStream(String path) throws IOException {
        try {
            i = new FileInputStream(new File(path));
            return;
        }
        catch (IOException e) {
            Log.e("XFiles-IO", getClass().getName()+": open for reading failed in in-app mode, trying with roothelper-proxy file streams...", e);
        }
        try {
            i = MainActivity.getRootHelperClient().getInputStream(path);
        }
        catch (NullPointerException e) {
            throw new IOException(e);
        }
    }

    @Override
    public int read(byte[] b) throws IOException {
        return i.read(b);
    }

    @Override
    public int read(byte[] b, int off, int len) throws IOException {
        return i.read(b, off, len);
    }

    @Override
    public long skip(long n) throws IOException {
        return i.skip(n);
    }

    @Override
    public int available() throws IOException {
        return i.available();
    }

    @Override
    public void close() throws IOException {
        i.close();
    }

    @Override
    public synchronized void mark(int readlimit) {
        i.mark(readlimit);
    }

    @Override
    public synchronized void reset() throws IOException {
        i.reset();
    }

    @Override
    public boolean markSupported() {
        return i.markSupported();
    }

    @Override
    public int read() throws IOException {
        return i.read();
    }
}

```

`app/src/main/java/it/pgp/xfiles/io/RobustLocalFileOutputStream.java`:

```java
package it.pgp.xfiles.io;

import android.util.Log;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.MainActivity;

public class RobustLocalFileOutputStream extends OutputStream {

    OutputStream o;

    public RobustLocalFileOutputStream(String path) throws IOException {
        try {
            o = new FileOutputStream(new File(path));
            return;
        }
        catch (IOException e) {
            e.printStackTrace();
            Log.e("XFiles-IO", getClass().getName()+": open for writing failed in in-app mode, trying with roothelper-proxy file streams...");
        }
        try {
            o = MainActivity.getRootHelperClient().getOutputStream(path);
        }
        catch(NullPointerException e) {
            throw new IOException(e);
        }
    }

    @Override
    public void write(byte[] b) throws IOException {
        o.write(b);
    }

    @Override
    public void write(byte[] b, int off, int len) throws IOException {
        o.write(b, off, len);
    }

    @Override
    public void flush() throws IOException {
        o.flush();
    }

    @Override
    public void write(int b) throws IOException {
        o.write(b);
    }

    @Override
    public void close() throws IOException {
        o.close();
    }
}

```

`app/src/main/java/it/pgp/xfiles/items/BulkRenameItem.java`:

```java
package it.pgp.xfiles.items;

import android.support.annotation.NonNull;

public class BulkRenameItem {
    public final String filename;
    public boolean duplicate;

    public BulkRenameItem(String filename) {
        this.filename = filename;
        this.duplicate = false;
    }

    @NonNull
    @Override
    public String toString() {
        return filename;
    }

    // equals implementation is needed, for hashCode to work as well
    @Override
    public boolean equals(Object obj) {
        if(obj instanceof BulkRenameItem)
            return filename.equals(((BulkRenameItem) obj).filename);
        return super.equals(obj);
    }

    @Override
    public int hashCode() {
        return filename.hashCode();
    }
}


```

`app/src/main/java/it/pgp/xfiles/items/FileCreationAdvancedOptions.java`:

```java
package it.pgp.xfiles.items;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.Serializable;

import it.pgp.xfiles.utils.Misc;

public class FileCreationAdvancedOptions implements Serializable {

    public enum FileCreationMode {
        FALLOCATE,ZEROS,RANDOM // FALLOCATE not used, but don't remove that, needed offset till ZEROS and RANDOM ordinal shifted back at protocol level to 0 and 1 instead of 1 and 2
    }

    public static class CreationStrategyAndOptions {
        public final FileCreationMode mode;
        public String customSeed;
        public String outputHashType;
        public String backendCipher;

        public CreationStrategyAndOptions(FileCreationMode mode, String customSeed, String outputHashType, String backendCipher) {
            this.mode = mode;
            this.customSeed = customSeed;
            this.outputHashType = outputHashType;
            this.backendCipher = backendCipher;
        }

        public int getByte() {
            int ret = mode.ordinal(); // 0,1,2
            if(customSeed != null) ret |= 4;
            if(outputHashType != null) ret |= 8;
            if(backendCipher != null) ret |= 16;
            return ret;
        }
    }

    public CreationStrategyAndOptions strategy;
    public long size;

    public FileCreationAdvancedOptions(long size, CreationStrategyAndOptions strategy) {
        this.strategy = size == 0 ? new CreationStrategyAndOptions(FileCreationMode.ZEROS,null,null, null) : strategy; // fallocate returns errno 22 (invalid argument) if called with zero size
        this.size = size;
    }

    public byte[] toRootHelperRequestOptions() throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        baos.write(strategy.getByte());
        baos.write(Misc.castUnsignedNumberToBytes(size,8));
        if(strategy.mode == FileCreationMode.RANDOM) {
            if(strategy.customSeed != null) Misc.sendStringWithLen(baos, strategy.customSeed);
            if(strategy.outputHashType != null) Misc.sendStringWithLen(baos, strategy.outputHashType);
            if(strategy.backendCipher != null) Misc.sendStringWithLen(baos, strategy.backendCipher);
        }
        return baos.toByteArray();
    }
}

```

`app/src/main/java/it/pgp/xfiles/items/FolderStatsItem.java`:

```java
package it.pgp.xfiles.items;

/**
 * Created by pgp on 14/07/17
 * Just a placeholder, since there is no byte array conversion from folderStats_resp (only numeric members)
 */

public final class FolderStatsItem {
    private FolderStatsItem() {}
}

```

`app/src/main/java/it/pgp/xfiles/items/MultiStatsItem.java`:

```java
package it.pgp.xfiles.items;

/**
 * Created by pgp on 14/07/17
 */

public class MultiStatsItem {
}

```

`app/src/main/java/it/pgp/xfiles/items/SingleStatsItem.java`:

```java
package it.pgp.xfiles.items;

import java.nio.charset.StandardCharsets;
import java.util.Date;

import it.pgp.xfiles.roothelperclient.resps.singleStats_resp;

/**
 * Created by pgp on 14/07/17
 */

public class SingleStatsItem {

    public String group;
    public String owner;
    public Date creationTime;
    public Date lastAccessTime;
    public Date modificationTime;
    public String permissions;
    public long size;
    public boolean isDir;

    public SingleStatsItem(String group, String owner, Date creationTime, Date lastAccessTime, Date modificationTime, String permissions, long size) {
        this.group = group;
        this.owner = owner;
        this.creationTime = creationTime;
        this.lastAccessTime = lastAccessTime;
        this.modificationTime = modificationTime;
        this.permissions = permissions;
        this.size = size;
    }

    public SingleStatsItem(singleStats_resp r) {
        group = new String(r.group, StandardCharsets.UTF_8);
        owner = new String(r.owner, StandardCharsets.UTF_8);
        creationTime = new Date(r.creationTime*1000L);
        lastAccessTime = new Date(r.lastAccessTime*1000L);
        modificationTime = new Date(r.modificationTime*1000L);
        permissions = new String(r.permissions,StandardCharsets.UTF_8);
        isDir = permissions.charAt(0) == 'd';
        size = r.size;
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/ControlCodes.java`:

```java
package it.pgp.xfiles.roothelperclient;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by pgp on 21/01/17
 * (corresponding to common_uds.h in C roothelper project)
 */

public enum ControlCodes {
    // these are to be considered 5-bit opcodes, most significant 3 bits (when set) are option flags
    // requests (5 bit)
    ACTION_LS((byte)0x01), // list or list archive, depending on flags (000 or 111)
    ACTION_MOVE((byte)0x02),
    ACTION_COPY((byte)0x03),
    ACTION_DELETE((byte)0x04),
    ACTION_STATS((byte)0x05),
    ACTION_COMPRESS((byte)0x06),
    ACTION_EXTRACT((byte)0x07),
    ACTION_EXISTS((byte)0x08), // exists/is file/is directory
    ACTION_CREATE((byte)0x09), // create file/directory
    ACTION_HASH((byte)0x0A),
    ACTION_FIND((byte)0x0B),
    ACTION_KILL((byte)0x0C), // for killing long-term roothelper processes from main roothelper process
    ACTION_GETPID((byte)0x0D), // for probing connection and getting RH server pid for later sending kill signals from the main RH server instance (via ACTION_KILL request)
//    ACTION_FORK((byte)0x0E),
    ACTION_FILEIO((byte)0x0F),

    ACTION_DOWNLOAD((byte)0x10),
    ACTION_UPLOAD((byte)0x11),

    REMOTE_SERVER_MANAGEMENT((byte)0x12), // flags: 000: stop, 111: start, 101: start with announce, 010: get status

    REMOTE_CONNECT((byte)0x14),

    ACTION_SETATTRIBUTES((byte)0x15), // embeds set ownership, permissions and dates actions

    ACTION_SSH_KEYGEN((byte)0x16),

    ACTION_LINK((byte)0x17),

    ACTION_HTTPS_URL_DOWNLOAD((byte)0x18),

    ACTION_CLOUD_SERVICES((byte)0x19),

//    ACTION_CANCEL((byte)0x1E),
    ACTION_EXIT((byte)0x1F);

    public static final int rq_bit_length = 5;
    public static final int flags_bit_length = 3;

    final byte value;
    static final Map<Byte,ControlCodes> codeMap = new HashMap<Byte,ControlCodes>(){{
        for (ControlCodes x: ControlCodes.values())
            put(x.getValue(),x);
    }};

    ControlCodes(byte value) {
        this.value = value;
    }

    // enum value to byte value
    public byte getValue() {
        return value;
    }

    // byte value to enum value
    public static ControlCodes getCode(byte value) {
        return codeMap.get(value);
    }

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/FindInArchiveThread.java`:

```java
package it.pgp.xfiles.roothelperclient;

import it.pgp.xfiles.utils.ArchiveVMap;
import it.pgp.xfiles.utils.pathcontent.ArchivePathContent;

public class FindInArchiveThread extends FindUpdatesThread {
    private final ArchiveVMap m;
    private final String namePattern;
    private final boolean recursiveSearch;
    private final boolean caseInsensitive;

    @Override
    protected String getErrMsg() {
        return "Generic error in "+getClass().getName();
    }

    public FindInArchiveThread(ArchivePathContent basePath, String namePattern, boolean recursiveSearch, boolean caseInsensitive) {
        super(null);
        this.m = RootHelperClient.archiveMRU.getByPath(basePath.archivePath,null);
        if(this.m==null) throw new RuntimeException("archive mru item should be present at this point");
        this.namePattern = namePattern;
        this.recursiveSearch = recursiveSearch; // if false, just retrieve the subtree map at the given path key, and loop over map keys
        this.caseInsensitive = caseInsensitive;
    }

    private boolean matchFilename(String filename) {
        // TODO here it would be simple to match using regex and globbing, adapt logic from bulk rename
        return (!caseInsensitive && filename.contains(namePattern)) ||
                (caseInsensitive && filename.toUpperCase().contains(namePattern.toUpperCase()));
    }

    @Override
    protected void doFind() {
        m.findInArchive(this::matchFilename,recursiveSearch?"":null);
    }
}


```

`app/src/main/java/it/pgp/xfiles/roothelperclient/FindManager.java`:

```java
package it.pgp.xfiles.roothelperclient;

import java.io.IOException;
import java.util.concurrent.atomic.AtomicReference;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.roothelperclient.reqs.find_rq;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 22/01/18
 * Updater class for find tasks, to be embedded into AsyncTask/Service if needed
 */

public class FindManager extends RemoteManager {

    public static final AtomicReference<Thread> findManagerThreadRef = new AtomicReference<>(null);

    private FindManager() throws IOException {
        super();
    }

    private boolean start_find(find_rq find_rq) throws IOException {
        // start RH find thread
        find_rq.write(o);

        int resp = Misc.receiveBaseResponse(i);
        if (resp != 0) {
            // Unable to start RH find thread
            return false;
        }
        // ok, RH find thread started
        // now, start rhss update thread
        new FindUpdatesThread(this).start();
        return true;
    }

    // cancel current search, if any
    private boolean stop_find() throws IOException {
        new find_rq().write(o);

        int resp = Misc.receiveBaseResponse(i);
        if (resp != 0) return false;
        // ok, RH find thread stopped, local updates thread will end automatically as well
        findManagerThreadRef.set(null);
        return true;
    }

    ////////////////////////////////////
    // methods with auto-close after request send

    public enum FIND_ACTION {START,STOP}

    public static int find_action(FIND_ACTION action, find_rq... request) {
        if (action == FIND_ACTION.START) {
            MainActivity.getRootHelperClient();
            // without auto-close
            try {return (new FindManager().start_find(request[0])) ? 1 : 0;}
            catch (IOException e) {return -1;}
        }
        else {
            // with auto-close
            try(FindManager f = new FindManager()) {
                return f.stop_find()?1:0;
            }
            catch (IOException ignored) {}
            return -1;
        }
    }

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/FindUpdatesThread.java`:

```java
package it.pgp.xfiles.roothelperclient;

import android.util.Log;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.FindActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.adapters.FindResultsAdapter;
import it.pgp.xfiles.roothelperclient.resps.find_resp;

public class FindUpdatesThread extends Thread {
    protected final AutoCloseable ac;

    protected String getErrMsg() {
        return "Local socket closed by rhss server or other exception, exiting...";
    }

    FindUpdatesThread(AutoCloseable ac) {
        this.ac = ac;
    }

    private static boolean onSearchItemFound(find_resp item) {
        try {
            // TODO when content search will be available, should replace BrowserItem with a subclass including content results
            FindActivity.instance.runOnUiThread(() ->
                    FindResultsAdapter.instance.add(new BrowserItem(item.fileItem)));
            return true;
        }
        catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    protected void doFind() throws Exception {
        for(;;) { // exits on IOException when the other socket endpoint is closed (search interrupted), or when receives end of list (not strictly needed, roothelper find thread could also close the connection after sending last item found)
            // receive search results
            find_resp item = find_resp.readNext(((FindManager)ac).i);
            if(item == null || !onSearchItemFound(item)) break; // exit immediately if adapter has been destroyed (actually, that should not happen)
        }
    }

    @Override
    public void run() {
        // strong cas, a thread is guaranteed to win
        if (!FindManager.findManagerThreadRef.compareAndSet(null,this)) {
            MainActivity.showToast("Another find thread is already receiving updates");
            return;
        }

        try {
            FindActivity.instance.runOnUiThread(()->FindActivity.instance.toggleSearchButtons(true));
            FindResultsAdapter.reset(null);
            doFind();
            MainActivity.showToast("Search completed");
        }
        catch(Throwable t) {
            t.printStackTrace();
            Log.d(getClass().getName(),getErrMsg());
        }

        try {ac.close();} catch(Exception ignored) {}
        FindManager.findManagerThreadRef.set(null); // unset reference only if compareAndSet was successful
        FindActivity.instance.runOnUiThread(()->FindActivity.instance.toggleSearchButtons(false));
        Log.d(getClass().getName(),"Really exiting find thread now!");
    }
}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/HashRequestCodes.java`:

```java
package it.pgp.xfiles.roothelperclient;

import android.widget.Checkable;

import java.util.HashMap;
import java.util.Map;

/**
 * Created by pgp on 03/02/17
 *
 * corresponding to hashMethods,hashLabels,hashLengths enum and arrays in roothelper code
 * (rh_hasher_botan.h, cli_hashLabels vector)
 */

public enum HashRequestCodes implements Checkable {

    crc32((byte)0x00,"CRC32",4,android.R.color.holo_purple),
    md5((byte)0x01,"MD5",16, android.R.color.holo_red_dark),
    sha1((byte)0x02,"SHA1",20, android.R.color.holo_red_dark),
    sha224((byte)0x0B,"SHA224",28, android.R.color.holo_green_light),
    sha256((byte)0x03,"SHA256",32, android.R.color.holo_orange_light),
    sha384((byte)0x04,"SHA384",48, android.R.color.holo_green_light),
    sha512((byte)0x05,"SHA512",64, android.R.color.holo_orange_light),
    sha3_224((byte)0x06,"SHA3-224",28, android.R.color.holo_green_light),
    sha3_256((byte)0x07,"SHA3-256",32, android.R.color.holo_green_light),
    sha3_384((byte)0x08,"SHA3-384",48, android.R.color.holo_green_light),
    sha3_512((byte)0x09,"SHA3-512",64, android.R.color.holo_green_light),
    blake2b_256((byte)0x0A,"BLAKE2B-256",32, android.R.color.holo_green_light);

    final byte value;
    final String label;
    final int length;
    final int labelColor;
    static final Map<Byte,HashRequestCodes> codeMap = new HashMap<Byte,HashRequestCodes>(){{
        for (HashRequestCodes x: HashRequestCodes.values())
            put(x.getValue(),x);
    }};

    HashRequestCodes(byte value, String label, int length, int labelColor) {
        this.value = value;
        this.label = label;
        this.length = length;
        this.labelColor = labelColor;
    }

    // enum value to byte value
    public byte getValue() {
        return value;
    }

    @Override
    public String toString() {
        return label;
    }

    public int getLength() {
        return length;
    }

    public int getLabelColor() {
        return labelColor;
    }

    // byte value to enum value
    public static HashRequestCodes getCode(byte value) {
        return codeMap.get(value);
    }


    /**
     * Just for handling selection status in {@link it.pgp.xfiles.adapters.HashAlgorithmsAdapter}
     */
    boolean checked = false;

    public boolean isChecked() {
        return checked;
    }

    public void setChecked(boolean checked) {
        this.checked = checked;
    }

    public void toggle() {
        checked = !checked;
    }

    public static void clear() {
        for (HashRequestCodes c : HashRequestCodes.values())
            c.checked = false;
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/RHSSServerStatus.java`:

```java
package it.pgp.xfiles.roothelperclient;

import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Created by pgp on 23/11/17
 * Bean of static members containing server status (should be in sync with information sent to roothelper client)
 * Singleton 0-1 object, with non-final inner fields
 */

public class RHSSServerStatus {

    public static volatile String xreHomePathStr;
    public static volatile String xreAnnouncedPathStr;
    public static volatile String xreExposedPathStr; // if null or empty, remote clients have access to the entire filesystem
    public static volatile boolean announceEnabled = true;

    // key is String (IPv4:port or [IPv6]:port)
    // byte[] value contains shared TLS key hash for that session
    // cleared on thread exit (rhss exit)
    public static final Map<String,byte[]> StoCSessions = new ConcurrentHashMap<>();

    public static void destroyServer() {
        xreHomePathStr = "";
        xreAnnouncedPathStr = "";
        xreExposedPathStr = "";
        StoCSessions.clear();
    }

    // CtoS connections are contained in the static final variable RemoteClientManager in MainActivity

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/RelativeExtractEntries.java`:

```java
package it.pgp.xfiles.roothelperclient;

import java.util.List;

/**
 * Created by pgp on 17/02/18
 */

public class RelativeExtractEntries {
    public int stripPathLen;
    public List<Integer> entries;

    public RelativeExtractEntries(int stripPathLen, List<Integer> entries) {
        this.stripPathLen = stripPathLen;
        this.entries = entries;
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/RemoteClientManager.java`:

```java
package it.pgp.xfiles.roothelperclient;

import android.content.ContentResolver;
import android.net.Uri;
import android.util.Log;

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import it.pgp.Native;
import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.CopyListUris;
import it.pgp.xfiles.CopyMoveListPathContent;
import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.XFilesRemoteSessionsManagementActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.roothelperclient.reqs.ListOfPathPairs_rq;
import it.pgp.xfiles.roothelperclient.reqs.retrieveHomePath_rq;
import it.pgp.xfiles.service.BaseBackgroundTask;
import it.pgp.xfiles.service.NonInteractiveXFilesRemoteTransferTask;
import it.pgp.xfiles.utils.ContentProviderUtils;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.ProgressConflictHandler;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

/**
 * Created by pgp on 20/09/17
 *
 * Remote client manager that performs remote action via the connected RH remote client session
 */

public class RemoteClientManager {

    private static final long EOF_ind = ProgressConflictHandler.Status.EOF.getStatus(); // end of file
    private static final long EOFs_ind = ProgressConflictHandler.Status.EOFs.getStatus(); // end of files

    // use only serverHost as key for now
    public final Map<String,RemoteManager> fastClients = new ConcurrentHashMap<>();
    public final Map<String,RemoteManager> longTermClients = new ConcurrentHashMap<>();

    public synchronized void closeAllSessions() {
        for (RemoteManager rm : fastClients.values()) rm.close();
        for (RemoteManager rm : longTermClients.values()) rm.close();
        fastClients.clear();
        longTermClients.clear();
        if (XFilesRemoteSessionsManagementActivity.CtoSAdapter != null) {
            XFilesRemoteSessionsManagementActivity.CtoSAdapter.syncFromActivity();
        }
    }

    // progress methods and task field put here in order to avoid putting them also in RemoteServerManager, which extends RemoteManager and doesn't publish progress

    public BaseBackgroundTask progressTask;
    public ContentResolver contentResolver;

    private void initProgressSupport(BaseBackgroundTask task) {
        this.progressTask = task;
    }

    private void destroyProgressSupport() {
        this.progressTask = null;
    }

    public RemoteManager createAndConnectClient(String serverHost) {
        try {
            RemoteManager client = new RemoteManager();
            client.o.write(ControlCodes.REMOTE_CONNECT.getValue());

            // send host string with length
            byte[] serverHost_ = serverHost.getBytes();
            byte[] hostLen_ = Misc.castUnsignedNumberToBytes(serverHost_.length,1);
            client.o.write(hostLen_);
            client.o.write(serverHost_);
            // send port
            byte[] port_ = Misc.castUnsignedNumberToBytes(XREPathContent.defaultRHRemoteServerPort,2);
            client.o.write(port_);

            if (Misc.receiveBaseResponse(client.i) != 0) {
                client.close();
                return null;
            }
            // ok, streams connected to RH in remote client mode

            // receive TLS session hash
            client.i.readFully(client.tlsSessionHash);
            Log.d(this.getClass().getName(),"Client TLS session shared secret hash: "+Misc.toHexString(client.tlsSessionHash));

            // show the visual hash of the shared TLS master secret
            MainActivity.handler.post(()-> PopupWindowUtils.createAndShowHashViewCommon(
                    MainActivity.mainActivity != null && EffectActivity.currentlyOnFocus != null ? MainActivity.mainActivity : MainActivity.context,
                    client.tlsSessionHash,
                    true,
                    MainActivity.mainActivity != null ?
                            MainActivity.mainActivity.findViewById(R.id.activity_main) : null));

            return client;
        }
        catch (IOException e) {
            return null;
        }
    }

    public RemoteManager getClient(String serverHost, boolean isFastClient) {
        RemoteManager client;
        if (isFastClient) {
            if (fastClients.containsKey(serverHost)) return fastClients.get(serverHost);
            client = createAndConnectClient(serverHost);
            if (client == null) return null;
            fastClients.put(serverHost,client);
        }
        else {
            if (longTermClients.containsKey(serverHost)) return longTermClients.get(serverHost);
            client = createAndConnectClient(serverHost);
            if (client == null) return null;
            longTermClients.put(serverHost,client);
        }
        if (XFilesRemoteSessionsManagementActivity.CtoSAdapter != null) {
            XFilesRemoteSessionsManagementActivity.CtoSAdapter.syncFromActivity();
        }
        return client;
    }

    private void publishReceivedProgress(long progress, long totalSizeSoFar, long totalSize, long currentFileSize) {
        Log.d("XREProgress","It's progress: "+progress);
        if (this.progressTask != null) {
            this.progressTask.publishProgressWrapper(
                    new Pair<>(totalSizeSoFar + progress, totalSize),
                    new Pair<>(progress, currentFileSize)
            );
        }
    }

    // TODO make RemoteClientManager implementor of FileOperationHelper and remove duplicated code in RootHelperClient
    // TODO use StreamsPair and getStreams(...) in RootHelperClient, remove duplicated methods from here

    public FileOpsErrorCodes transferItems(CopyMoveListPathContent items, BasePathContent destDir, ControlCodes action, NonInteractiveXFilesRemoteTransferTask progressTask, ContentResolver contentResolver) {
        this.contentResolver = contentResolver;
        // get communication endpoint
        String clientKey;
        switch (action) {
            case ACTION_DOWNLOAD:
                clientKey = ((XREPathContent)items.parentDir).serverHost;
                break;
            case ACTION_UPLOAD:
                clientKey = ((XREPathContent)destDir).serverHost;
                break;
            default:
                throw new RuntimeException("Unexpected action in remote transfer task");
        }

        RemoteManager client = getClient(clientKey,false);
        if (client == null) {
            // unable to connect
            return FileOpsErrorCodes.CONNECTION_ERROR;
        }

        initProgressSupport(progressTask);

        // beware: here we are sending a custom LS (i.e. retrieve home path) request
        // using isFastClient = false (this is intended behaviour)
        if(action == ControlCodes.ACTION_UPLOAD && destDir.dir.isEmpty()) {
            try {
                new retrieveHomePath_rq("").write(client.o);
                if (Misc.receiveBaseResponse(client.i) != 0)
                    throw new RuntimeException("Unexpected response for retrieve home path request");
                destDir.dir = Misc.receiveStringWithLen(client.i); // re-assign using received home dir
            }
            catch (Exception e) {
                e.printStackTrace();
                return FileOpsErrorCodes.TRANSFER_ERROR;
            }
        }

        if (items instanceof CopyListUris) {
            /* - customize ACTION_UPLOAD request byte with flags 111
             * - query size for each uri, accumulate total size and list with individual sizes
             * - get file descriptors one by one with content resolver and send them via UDS (LocalSocket)
             * - receive progress for each file
             */
            byte customizedRq = action.getValue();
            customizedRq ^= (7 << 5); // flags: 111

            try {
                int nativeUds = ContentProviderUtils.getNativeDescriptor(client.ls);

                List<Uri> uris = new ArrayList<>();
                List<String> names = new ArrayList<>();
                List<Long> sizes = new ArrayList<>();
                long totalSize = 0;
                long currentFileSize;
                for (String uriString : ((CopyListUris)items).contentUris) {
                    Uri uri = Uri.parse(uriString);
                    uris.add(uri);
                    names.add(ContentProviderUtils.getName(contentResolver,uri));
                    currentFileSize = ContentProviderUtils.getSize(contentResolver,uri);
                    sizes.add(currentFileSize);
                    totalSize += currentFileSize;
                }

                Log.d("XREProgress","Total size computed using content provider is "+totalSize);

                client.o.write(customizedRq);
                client.o.write(Misc.castUnsignedNumberToBytes(totalSize,8));
                long totalSizeSoFar = 0;

                for (int i=0;i<uris.size();i++) {
                    Log.d("XREProgress","Sending file info and descriptor for "+names.get(i));
                    currentFileSize = sizes.get(i);
                    Misc.sendStringWithLen(client.o,destDir.dir+"/"+names.get(i));
                    client.o.write(Misc.castUnsignedNumberToBytes(currentFileSize,8));
                    int fdToSend = contentResolver.openFileDescriptor(uris.get(i),"r").detachFd();
                    Native.sendDetachedFD(nativeUds,fdToSend);

                    // receive progress
                    long tmp;
                    do {
                        tmp = Misc.receiveTotalOrProgress(client.i);
                        publishReceivedProgress(tmp,totalSizeSoFar,totalSize,currentFileSize);
                    }
                    while(tmp!=EOF_ind);
                    totalSizeSoFar += currentFileSize;
                }
                client.o.write(Misc.EOL);

            }
            catch (Exception e) {
                e.printStackTrace();
                return FileOpsErrorCodes.TRANSFER_ERROR;
            }

            return FileOpsErrorCodes.OK;
        }
        else {
            ArrayList<String> v_fx = new ArrayList<>();
            ArrayList<String> v_fy = new ArrayList<>();

            for (BrowserItem fname : items.files) {
                v_fx.add(items.parentDir.dir+"/"+fname.getFilename());
                v_fy.add(destDir.dir+"/"+fname.getFilename());
            }

            ListOfPathPairs_rq r = new ListOfPathPairs_rq(action,v_fx,v_fy);

            try {
                r.write(client.o);

                // receive total number of files for outer progress
                final long totalFileCount = Misc.receiveTotalOrProgress(client.i);
                final long totalSize = Misc.receiveTotalOrProgress(client.i);
                Log.d("XREProgress","Total size is "+totalSize);
                long currentFileCount = 0;
                long totalSizeSoFar = 0; // rounded to last completed file
//            long currentFileSize = EOF_ind; // legacy, maybe breaks things
                long currentFileSize = 0; // placeholder, just to avoid uninitialized error

                boolean hasReceivedSizeForCurrentFile = false;

                // receive progress for single files, increment outer progress bar by 1 on EOF_ind progress

                for (;;) {
                    long tmp = Misc.receiveTotalOrProgress(client.i);

                    if (tmp == EOF_ind) {
                        Log.d("XREProgress","Received EOF, file count before: "+currentFileCount);
                        hasReceivedSizeForCurrentFile = false;
                        currentFileCount++;
                        totalSizeSoFar += currentFileSize;
                        this.progressTask.publishProgressWrapper(
                                new Pair<>(totalSizeSoFar, totalSize),
                                new Pair<>(0L,1L)
                        );
                    }
                    else if (tmp == EOFs_ind) {
                        Log.d("XREProgress","Received EOFs");
                        break;
                    }
                    else {
                        Log.d("XREProgress","Received progress or size");
                        if (hasReceivedSizeForCurrentFile) {
                            publishReceivedProgress(tmp,totalSizeSoFar,totalSize,currentFileSize);
                        }
                        else {
                            Log.d("XREProgress","It's size: "+tmp);
                            // here, tmp is current file's size, before starting copying current file
                            currentFileSize = tmp;
                            hasReceivedSizeForCurrentFile = true;
                            if (this.progressTask != null) {
                                this.progressTask.publishProgressWrapper(
                                        new Pair<>(totalSizeSoFar, totalSize),
                                        new Pair<>(0L,1L)
                                );
                            }
                        }
                    }
                }
                return FileOpsErrorCodes.OK;
            }
            catch (IOException e) {
                client.close();
                longTermClients.remove(clientKey);
                return FileOpsErrorCodes.TRANSFER_ERROR;
            }
            finally {
                destroyProgressSupport();
            }
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/RemoteManager.java`:

```java
package it.pgp.xfiles.roothelperclient;

import android.net.LocalSocket;
import android.net.LocalSocketAddress;
import android.util.Log;

import java.io.DataInputStream;
import java.io.IOException;

import it.pgp.xfiles.service.SocketNames;
import it.pgp.xfiles.utils.StreamsPair;

/**
 * Created by pgp on 20/09/17
 */

public class RemoteManager extends StreamsPair {
    private static final SocketNames defaultaddress = SocketNames.theroothelper;

    // streams connected to local socket
    public final LocalSocket ls;

    public final byte[] tlsSessionHash = new byte[32]; // hex string of SHA256

    RemoteManager() throws IOException {
        LocalSocket clientSocket = new LocalSocket();
        LocalSocketAddress socketAddress = new LocalSocketAddress(
                defaultaddress.name(),
                LocalSocketAddress.Namespace.ABSTRACT);
        clientSocket.connect(socketAddress);
        Log.d(getClass().getName(),"Connected");

        ls = clientSocket;

        o = clientSocket.getOutputStream();
        i = new DataInputStream(clientSocket.getInputStream());
        Log.d(getClass().getName(),"Streams acquired");
    }

    @Override
    public void close() {
        // Close method on streams won't work, use shutdown methods
        // Web source:
        // https://stackoverflow.com/questions/10984175/android-localsocket-wont-close-when-in-blocked-read

        if(ls != null) {
            try {ls.shutdownInput();} catch (Exception ignored) {}
            try {ls.shutdownOutput();} catch (Exception ignored) {}
        }

        try {i.close();} catch (Exception ignored) {}
        try {o.close();} catch (Exception ignored) {}
        Log.d(getClass().getName(),"Streams closed");
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/RemoteServerManager.java`:

```java
package it.pgp.xfiles.roothelperclient;

import android.content.Context;
import android.util.Log;
import android.view.View;

import java.io.IOException;
import java.util.Observable;
import java.util.concurrent.atomic.AtomicReference;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.XRE_RHSS_Widget;
import it.pgp.xfiles.dialogs.RemoteRHServerManagementDialog;
import it.pgp.xfiles.dialogs.XFilesRemoteSessionsManagementActivity;
import it.pgp.xfiles.fileservers.FileServer;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

/**
 * Created by pgp on 20/09/17
 * Client Thread that starts a RH remote server, and keeps connected to the underlying local socket
 * in order to receive information about started and ended server sessions with remote clients
 * Disconnection of local socket should cause RH remote server process termination
 */

public class RemoteServerManager extends RemoteManager {

    public static final AtomicReference<RemoteServerManager> rhssManagerRef = new AtomicReference<>(null);

    private final byte rq_byte = ControlCodes.REMOTE_SERVER_MANAGEMENT.getValue();

    public static class RSMObservable extends Observable { // TODO move rhssManagerRef into here

        @Override
        public synchronized boolean hasChanged() {
            return true;
        }
    }

    public static final RSMObservable rsmObservable = new RSMObservable();

    // constructor without auto start
    private RemoteServerManager() throws IOException {
        super();
    }

    /**
     *  servedPaths:
     *  - home (default) path - xre server will leave it unchanged if sent empty
     *  - announced path
     *  - exposed path - no restrictions if sent empty
     */
    private boolean start_rhss(boolean announce, String... servedPaths) throws IOException {
        // start RH remote server instance
        byte rq = announce?
                (byte)(rq_byte ^ (5 << ControlCodes.rq_bit_length)) : // flags: 101, start with UDP broadcast announce
                (byte)(rq_byte ^ (7 << ControlCodes.rq_bit_length)); // flags: 111, no announce
        o.write(rq);

        if(servedPaths.length == 0)
            servedPaths = new String[]{"","",""};

        if(servedPaths.length != 3)
            throw new RuntimeException("Invalid number of arguments in start_rhss");

        for(int i=0;i<3;i++)
            Misc.sendStringWithLen(o,servedPaths[i]);

        if (Misc.receiveBaseResponse(i) != 0) {
            // Unable to start RH remote server
            return false;
        }
        // ok, streams connected and RH remote server instance started
        // now, start rhss update thread
        RHSSServerStatus.StoCSessions.clear();
        new RHSSUpdateThread().start();
        return true;
    }

/*    private boolean stop_rhss() throws IOException {
        // stop RH remote server instance
        o.write(rq_byte); // flags: 000

        int resp = receiveBaseResponse();
        if (resp != 0) {
            // Unable to stop RH remote server
            return false;
        }
        // ok, streams connected and RH remote server instance stopped, now terminate local updates thread
        rhssManagerThreadRef.set(null);
        return true;
    }*/

    // true: running, false: not running
    /*private boolean status_rhss() throws IOException {
        byte rq = (byte)(rq_byte ^ (2 << ControlCodes.rq_bit_length)); // flags: 010
        o.write(rq);

        int resp = receiveBaseResponse();
        if (resp != 0) {
            close();
            throw new RuntimeException("Should not happen, response unconditionally OK in rh");
        }

        // receive status byte
        byte status = i.readByte();
        return (status == 0);
    }*/

    ////////////////////////////////////
    // methods with auto-close after request send

    public enum RHSS_ACTION {START,START_ANNOUNCE,STOP /*,STATUS*/}

    public static int rhss_action(RHSS_ACTION action, String... servedPaths) {
        switch (action) {
            case START:
            case START_ANNOUNCE:
                // without auto-close
                try {return (new RemoteServerManager().start_rhss(action==RHSS_ACTION.START_ANNOUNCE,servedPaths)) ? 1 : 0;}
                catch (IOException e) {return -1;}
            case STOP:
                try {
                    rhssManagerRef.get().close();
                    return 1;
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
//            case STATUS:
//                // with auto-close
//                try(RemoteServerManager r = new RemoteServerManager()) {
//                    switch (action) {
//                        case STOP: return r.stop_rhss()?1:0;
//                        case STATUS: return r.status_rhss()?1:0;
//                    }
//                }
//                catch (IOException ignored) {}
            default:
                return -1;
        }
    }
    ////////////////////////////////////

    private void onClientConnect(String clientIPandPort, byte[] sessionKey, Context context) {
        RHSSServerStatus.StoCSessions.put(clientIPandPort,sessionKey);
        if (XFilesRemoteSessionsManagementActivity.StoCAdapter != null)
            XFilesRemoteSessionsManagementActivity.StoCAdapter.syncFromActivity();

        // show the visual hash of the shared TLS master secret
        if (MainActivity.mainActivity != null && EffectActivity.currentlyOnFocus != null) {
            MainActivity.mainActivity.runOnUiThread(()-> {
                View anchor = (RemoteRHServerManagementDialog.instance!=null)?
                        RemoteRHServerManagementDialog.instance.findViewById(R.id.remote_rh_server_management_dialog):
                        MainActivity.mainActivity.findViewById(R.id.activity_main);
                PopupWindowUtils.createAndShowHashViewCommon(
                        MainActivity.mainActivity,
                        sessionKey,
                        true,
                        anchor);
            });
        }
        else
            PopupWindowUtils.createAndShowHashViewCommon(context, sessionKey, true, null);
    }

    private void onClientDisconnect(String clientIPandPort) {
        RHSSServerStatus.StoCSessions.remove(clientIPandPort);
        if (XFilesRemoteSessionsManagementActivity.StoCAdapter != null)
            XFilesRemoteSessionsManagementActivity.StoCAdapter.syncFromActivity();
    }

    // inner thread to be started only after rhss server start, to receive client connect/disconnect updates
    public class RHSSUpdateThread extends Thread {
        private Context rhssLocalContext;

        @Override
        public void run() {
            try {
                // strong cas, a thread is guaranteed to win
                if (!rhssManagerRef.compareAndSet(null,RemoteServerManager.this)) {
                    MainActivity.showToast("Another rhss thread is already receiving updates");
                    return;
                }

                // XRE is not an enum member of FileServer, although it should (too much logic to change in order to do this)
                // this just assumes it to be in the last position in the RemoteRHServerManagementDialog.IfAddrsObserver state boolean array
                rsmObservable.notifyObservers(new Pair<>(FileServer.values().length, true));

                // update on-screen widgets
                if (MainActivity.context != null) {
                    Log.d("XRE_RHSS","refreshing XRE widget (-> ON)");
                    XRE_RHSS_Widget.updateAllDirect(MainActivity.context);
                }
                else {
                    Log.e("XRE_RHSS","unable to refresh XRE widget, handlerContext is null, exiting...");
                    throw new Exception();
                }
                rhssLocalContext = MainActivity.context; // onDestroy resets handlerContext reference before this thread can use it for updating widget to OFF

                for(;;) { // always exits on IOException, when the other socket endpoint is closed
                    // receive started/ended session flag
                    int flag = i.readUnsignedByte();
                    String message = "Remote client "+((flag == 0)?"connected":"disconnected");

                    // receive 1-byte lenght-prended string with client IP
                    int s_len = i.readUnsignedByte();
                    byte[] s_ = new byte[s_len];
                    i.readFully(s_);
                    String clientIP = new String(s_);

                    message += ": " + clientIP;

                    if (flag == 0) {
                        // receive hex SHA256 hash of TLS session shared secret
                        byte[] sessionKey = new byte[32];
                        i.readFully(sessionKey);
                        onClientConnect(clientIP,sessionKey,rhssLocalContext);
                        message += "\nShared secret hash: "+Misc.toHexString(sessionKey);
                    }
                    else {
                        onClientDisconnect(clientIP);
                    }

                    Log.d(getClass().getName(),message);
                    final String msg = message;

                    // to be replaced with onClientUpdate
                    MainActivity.showToast(msg);
                }
            }
            catch (Throwable t) {
                Log.d(getClass().getName(),"Local socket closed by rhss server or other exception, exiting...");
                if (!(t instanceof IOException)) t.printStackTrace();
                // no need for finally, thread always exits with exception
                close();
                rhssManagerRef.set(null);

                rsmObservable.notifyObservers(new Pair<>(FileServer.values().length, false));

                // also update local views of dialog to off, if dialog is active
                RHSSServerStatus.destroyServer();
                if (MainActivity.mainActivity != null) {
                    MainActivity.mainActivity.runOnUiThread(() -> {
                        if (XFilesRemoteSessionsManagementActivity.StoCAdapter != null)
                            XFilesRemoteSessionsManagementActivity.StoCAdapter.syncFromActivity();
                    });
                }

                if (rhssLocalContext != null) {
                    // update on-screen widgets, if any, as well
                    Log.d("XRE_RHSS","refreshing XRE widget (-> OFF)");
                    XRE_RHSS_Widget.updateAllDirect(rhssLocalContext);
                }

                Log.d(getClass().getName(),"Really exiting update thread now!");
            }
        }
    }

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/ResponseCodes.java`:

```java
package it.pgp.xfiles.roothelperclient;

import java.util.HashMap;
import java.util.Map;

public enum ResponseCodes {

    // responses (full byte)
    RESPONSE_OK((byte)0x00),
    RESPONSE_ERROR((byte)0xFF),
    RESPONSE_REDIRECT((byte)0x11); // actually, end of redirects

    final byte value;
    static final Map<Byte, ResponseCodes> codeMap = new HashMap<Byte, ResponseCodes>(){{
        for (ResponseCodes x: ResponseCodes.values())
            put(x.getValue(),x);
    }};

    ResponseCodes(byte value) {
        this.value = value;
    }

    // enum value to byte value
    public byte getValue() {
        return value;
    }

    // byte value to enum value
    public static ResponseCodes getCode(byte value) {
        return codeMap.get(value);
    }

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/RootHandler.java`:

```java
package it.pgp.xfiles.roothelperclient;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Binder;
import android.os.Build;
import android.util.Log;

import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Field;
import java.util.concurrent.locks.LockSupport;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.service.SocketNames;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

/**
 * Created by pgp on 28/09/16
 * Last modified on 07/01/18
 */

public class RootHandler {

    public static synchronized long getPidOfProcess(Process p) {
        long pid;

        try {
            // on Android: java.lang.ProcessManager$ProcessImpl
//            if (p.getClass().getName().equals("java.lang.UNIXProcess")) {
                Field f = p.getClass().getDeclaredField("pid");
                f.setAccessible(true);
                pid = f.getLong(p);
                f.setAccessible(false);
                return pid;
//            }
        } catch (Exception e) {
            return -1;
        }
    }

    public static boolean isRootAvailableAndGranted = false;

    public static boolean isRooted() {
        return findBinary("su");
    }

    private static boolean findBinary(String binaryName) {
        boolean found = false;
        String[] places = {"/sbin/", "/system/bin/", "/system/xbin/", "/data/local/xbin/",
                "/data/local/bin/", "/system/sd/xbin/", "/system/bin/failsafe/", "/data/local/"};
        for (String where : places) {
            if ( new File( where + binaryName ).exists() ) {
                found = true;
                Log.d(RootHandler.class.getName(),"su binary found at "+where);
                break;
            }
        }
        return found;
    }

    public static Process executeCommandSimple(String command, File workingDir, boolean runAsSuperUser, boolean disableEnforcingSELinux, String... args) throws IOException {
        String s = "";
        s += command;
        if(args != null) for(String arg : args) s += " " + arg;

        Process p;
        if(runAsSuperUser) {
            p = Runtime.getRuntime().exec("su");
            DataOutputStream dos = new DataOutputStream(p.getOutputStream());
            if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.R && disableEnforcingSELinux)
                dos.writeBytes("setenforce 0\n");
            if(workingDir != null)
                dos.writeBytes("cd " + workingDir +"\n");
            dos.writeBytes(s + "\n");
            dos.writeBytes("exit\n");
            dos.flush();
            dos.close();
        }
        else {
            p = (workingDir==null)?
                    Runtime.getRuntime().exec(s):
                    Runtime.getRuntime().exec(s,null,workingDir);
        }

//        lastStartedPid = getPidOfProcess(p);

        return p; // p started, not joined

        // exitValue to be called later
//        int exitValue = 0;
//        try {
//            exitValue = p.waitFor();
//        }
//        catch (InterruptedException ignored) {}

//        StringBuilder output = new StringBuilder();
//        // no console output expected from process
//        BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
//
//        String line;
//        while ((line = reader.readLine()) != null) {
//            output.append(line).append("\n");
//        }
//
//        Log.d(RootHandler.class.getName(), "***BEGIN Parent process output:***\n" + output.toString() + "\n***END Parent process output***\nExit value: " + exitValue);
    }

    public static final String rootHelperInstallName = "libr.so";

    public static Process runRootHelper(Context context, boolean runAsSu, SocketNames socketName) throws IOException {
//        File workingDir = context.getFilesDir(); // old, taken from app private dir (files)
        File workingDir = new File(context.getApplicationInfo().nativeLibraryDir);

        File rootHelperExecutable = new File(workingDir,rootHelperInstallName);
        if (socketName == null)
            return executeCommandSimple(rootHelperExecutable.getAbsolutePath(),workingDir,runAsSu,true,Binder.getCallingUid()+"");
        else
            return executeCommandSimple(rootHelperExecutable.getAbsolutePath(),workingDir,runAsSu,true,Binder.getCallingUid()+"",socketName.name());
    }

    public static Process runRootHelper(SocketNames socketName) throws IOException {
        return runRootHelper(MainActivity.context,isRooted(),socketName);
    }

    /**
     * Tries to start a new RH process on the given socket name,
     * then creates a new RHClient instance connected to that process
     * and checks connection by the two by sending a ping message.
     * If everything is ok, the RHClient instance is returned, otherwise null.
     */
    public static RootHelperClient startAndGetRH(Context... context) {
        Context c = context.length > 0 ? context[0]:MainActivity.context;

        SocketNames socketName = SocketNames.theroothelper;
        RootHelperClient rh = null;
        long pid; // communicated by RH server itself once successfully started

        for(boolean asRoot : new Boolean[]{true,false}) {
            try {
                Process p = runRootHelper(c,asRoot,socketName);

                rh = new RootHelperClient(socketName);
                pid = rh.checkConnection();
                while (pid < 0) {
                    try {
                        p.exitValue();
                        // process exited prematurely, failed to start roothelper process in the given mode (when asRoot is false, should never happen)
                        rh = null;
                        break;
                    }
                    catch (IllegalThreadStateException e) {
                        Log.d(RootHandler.class.getName(),"Waiting for roothelper process to start...");
                        LockSupport.parkNanos(250000000); // sleep 250 ms
                    }
                    pid = rh.checkConnection();
                }

                if (rh != null) {
                    Log.d(RootHandler.class.getName(),"Started roothelper in "+(asRoot?"root":"normal")+" mode");
                    if(asRoot) {
                        isRootAvailableAndGranted = asRoot;
                        String rootModeStoragePath = getInternalStoragePathInRootMode(rh,c);
                        if(rootModeStoragePath != null) Misc.internalStorageDir = new File(rootModeStoragePath);
                        else MainActivity.showToast("Unable to get a common internal storage path for both normal and root mode, RH integration may not work properly");
                    }

                    if (pid <= 0) Log.e(RootHandler.class.getName(),"Failed to get roothelper pid: "+pid);
                    break;
                }
            }
            catch (IOException e) {
                if(!asRoot) e.printStackTrace();
            }
        }

        return rh;
    }

    public static String getInternalStoragePathInRootMode(RootHelperClient rh, Context c) {
        SharedPreferences sp = c.getSharedPreferences(c.getPackageName(), Context.MODE_PRIVATE);
        String rootModeStoragePath = sp.getString("rootModeStoragePath",null);
        if(rootModeStoragePath != null) return rootModeStoragePath; // a working path was already set

        GenericDirWithContent dwc = rh.listDirectory(new LocalPathContent(Misc.internalStorageDir.getAbsolutePath()));
        if(dwc.errorCode != null) {
            // internal storage dir exposed by Environment.getExternalStorageDir is not mounted for root user (some Kitkat devices)
            try {
                rootModeStoragePath = System.getenv("EXTERNAL_STORAGE");
                if(rootModeStoragePath == null) return null;
                dwc = rh.listDirectory(new LocalPathContent(rootModeStoragePath));
                if(dwc.errorCode != null) return null;
                if(new File(rootModeStoragePath).listFiles()==null) return null; // the found path for root mode must be accessible in normal mode as well
            }
            catch(Exception e) {
                return null;
            }
        }

        SharedPreferences.Editor editor = sp.edit();
        editor.putString("rootModeStoragePath",rootModeStoragePath);
        editor.commit();

        return rootModeStoragePath;
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/RootHelperClient.java`:

```java
package it.pgp.xfiles.roothelperclient;

import android.content.ContentResolver;
import android.net.LocalSocket;
import android.net.LocalSocketAddress;
import android.net.Uri;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.util.Log;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import it.pgp.Native;
import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.CopyListUris;
import it.pgp.xfiles.CopyMoveListPathContent;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.CopyMoveMode;
import it.pgp.xfiles.enums.FileIOMode;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ForegroundServiceType;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.enums.SshKeyType;
import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.roothelperclient.reqs.ListOfPathPairs_rq;
import it.pgp.xfiles.roothelperclient.reqs.SinglePath_rq;
import it.pgp.xfiles.roothelperclient.reqs.compress_rq;
import it.pgp.xfiles.roothelperclient.reqs.compress_rq_options;
import it.pgp.xfiles.roothelperclient.reqs.copylist_rq;
import it.pgp.xfiles.roothelperclient.reqs.create_rq;
import it.pgp.xfiles.roothelperclient.reqs.del_rq;
import it.pgp.xfiles.roothelperclient.reqs.exists_rq;
import it.pgp.xfiles.roothelperclient.reqs.extract_rq;
import it.pgp.xfiles.roothelperclient.reqs.fileio_rq;
import it.pgp.xfiles.roothelperclient.reqs.hash_rq;
import it.pgp.xfiles.roothelperclient.reqs.link_rq;
import it.pgp.xfiles.roothelperclient.reqs.ls_archive_rq;
import it.pgp.xfiles.roothelperclient.reqs.ls_rq;
import it.pgp.xfiles.roothelperclient.reqs.movelist_rq;
import it.pgp.xfiles.roothelperclient.reqs.multiStats_rq;
import it.pgp.xfiles.roothelperclient.reqs.multi_extract_rq;
import it.pgp.xfiles.roothelperclient.reqs.openssh_ed25519_keygen_rq;
import it.pgp.xfiles.roothelperclient.reqs.openssl_rsa_pem_keygen_rq;
import it.pgp.xfiles.roothelperclient.reqs.setDates_rq;
import it.pgp.xfiles.roothelperclient.reqs.setOwnership_rq;
import it.pgp.xfiles.roothelperclient.reqs.setPermission_rq;
import it.pgp.xfiles.roothelperclient.reqs.singleStats_rq;
import it.pgp.xfiles.roothelperclient.resps.exists_resp;
import it.pgp.xfiles.roothelperclient.resps.folderStats_resp;
import it.pgp.xfiles.roothelperclient.resps.ls_resp;
import it.pgp.xfiles.roothelperclient.resps.singleStats_resp;
import it.pgp.xfiles.roothelperclient.resps.ssh_keygen_resp;
import it.pgp.xfiles.service.BaseBackgroundTask;
import it.pgp.xfiles.service.SocketNames;
import it.pgp.xfiles.service.visualization.ProgressIndicator;
import it.pgp.xfiles.utils.ArchiveVMap;
import it.pgp.xfiles.utils.ContentProviderUtils;
import it.pgp.xfiles.utils.FileOperationHelper;
import it.pgp.xfiles.utils.GenericMRU;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.ProgressConflictHandler;
import it.pgp.xfiles.utils.StreamsPair;
import it.pgp.xfiles.utils.XFilesUtils;
import it.pgp.xfiles.utils.dircontent.ArchiveSubDirWithContent;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.dircontent.LocalDirWithContent;
import it.pgp.xfiles.utils.dircontent.XFilesRemoteDirWithContent;
import it.pgp.xfiles.utils.iterators.VMapSubTreeIterable;
import it.pgp.xfiles.utils.pathcontent.ArchivePathContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;

/**
 * Created by pgp on 20/01/17
 */

public class RootHelperClient implements FileOperationHelper {

    private static final long EOF_ind = ProgressConflictHandler.Status.EOF.getStatus(); // end of file
    private static final long EOFs_ind = ProgressConflictHandler.Status.EOFs.getStatus(); // end of files

    // for publishing progress from within a long term task (copy/move/compress/extract/upload/download)
    BaseBackgroundTask task;
//    NotificationManager notifyManager;
//    NotificationCompat.Builder builder;
//    int NOTIF_ID;

    @Override
    public void initProgressSupport(BaseBackgroundTask task/*, NotificationManager notifyManager, NotificationCompat.Builder builder, int NOTIF_ID*/) {
        this.task = task;
//        this.notifyManager = notifyManager;
//        this.builder = builder;
//        this.NOTIF_ID = NOTIF_ID;
    }

    @Override
    public void destroyProgressSupport() {
        task = null;
    }

    ///////////////////////////////////////////////////////////////

    public static final SocketNames defaultaddress = SocketNames.theroothelper;
    public SocketNames address;

    public RootHelperClient() {
        this.address = defaultaddress;
    }

    RootHelperClient(SocketNames address) {
        this.address = address;
    }

    public class RootHelperStreams extends StreamsPair {

        public final LocalSocket ls;

        public RootHelperStreams() throws IOException {
            LocalSocket clientSocket = new LocalSocket();
            LocalSocketAddress socketAddress = new LocalSocketAddress(address.name(), LocalSocketAddress.Namespace.ABSTRACT);
            clientSocket.connect(socketAddress);
            Log.d("roothelperclient","Connected");

            ls = clientSocket;
            o = clientSocket.getOutputStream();
            i = new DataInputStream(clientSocket.getInputStream());
            Log.d("roothelperclient","Streams acquired");
        }

        @Override
        public void close() {
            // Close method on streams won't work, use shutdown methods
            // Web source:
            // https://stackoverflow.com/questions/10984175/android-localsocket-wont-close-when-in-blocked-read

            try {ls.shutdownInput();} catch (Exception ignored) {}
            try {ls.shutdownOutput();} catch (Exception ignored) {}

            try {i.close();} catch (Exception ignored) {}
            try {o.close();} catch (Exception ignored) {}
        }
    }

    public StreamsPair getStreams() throws IOException {
        return new RootHelperStreams();
    }

    public StreamsPair getStreams(BasePathContent bpc, boolean isFastClient) throws IOException {
        if (bpc instanceof LocalPathContent) {
            return new RootHelperStreams();
        }
        else if (bpc instanceof XREPathContent) {
            XREPathContent xrpc = (XREPathContent) bpc;
            RemoteManager rm = MainActivity.rootHelperRemoteClientManager.getClient(xrpc.serverHost,isFastClient);
            if (rm == null) throw new IOException("XRE Session not connected");
            return rm;
        }
        else throw new RuntimeException("Guard block");
    }

    // TODO may be useful in all long-term tasks, change following comment if needed
    public StreamsPair rs; // exposed in order to force closing connection and terminate forked p7zip process on service close

    // returns pid on successful connection, -1 otherwise
    public long checkConnection() {
        try (StreamsPair rs = getStreams()) {
            rs.o.write(ControlCodes.ACTION_GETPID.getValue());
            byte[] resp = new byte[4];
            rs.i.readFully(resp);
            return Misc.castBytesToUnsignedNumber(resp,4);
        }
        catch (IOException e) {
            return -1;
        }
    }

    /***************************************************************************
     * Singleton class for using only one client to server connection
     * from the spawning of roothelper server process till the app exit;
     * any request made to the server gets a response and the streams are
     * not closed, in so preventing possible malicious apps attempts to access
     * roothelper server while running
     ***************************************************************************/
    private static RootHelperStreamsOnce rso;
    private class RootHelperStreamsOnce {
        DataInputStream i;
        OutputStream o;

        RootHelperStreamsOnce() throws IOException {
            LocalSocket clientSocket = new LocalSocket();
            LocalSocketAddress socketAddress = new LocalSocketAddress(address.name(), LocalSocketAddress.Namespace.ABSTRACT);
            clientSocket.connect(socketAddress);
            Log.d("roothelperclient","Connected");

            o = clientSocket.getOutputStream();
            i = new DataInputStream(clientSocket.getInputStream());
            Log.d("roothelperclient","Streams acquired");
        }

        public void close() {
            try {
                i.close();
                o.close();
            }
            catch (IOException ignored) {}
        }
    }

    private RootHelperStreamsOnce getStreamsOnce() {
        try {
            if (rso == null || rso.i == null || rso.o == null) {
                // TODO check that there are not active instances of roothelper (cat /proc/net/unix | grep theroothelper), if so, send exit request
                // TODO rso must be set to null after any IOException in roothelper client
                RootHandler.runRootHelper(address);
                rso = new RootHelperStreamsOnce();
            }
            return rso;
        }
        catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }
    /***************************************************************************
     ***************************************************************************/

    // only with RESPONSE_OK
    public static List<BrowserItem> assembleContentFromLsResps(DataInputStream clientInStream) throws IOException {
        List<BrowserItem> dirContent = new ArrayList<>();
        // read len, if 0 stop reading
        ls_resp resp = ls_resp.readNext(clientInStream);
        while (resp != null) {
            // TODO modify BrowserItem to host all permission instead of only isDirectory
//            BrowserItem b =
//                    new BrowserItem(new String(resp.filename,"UTF-8"),
//                            resp.size,
//                            new Date(resp.date*1000),
//                            new String(resp.permissions, "UTF-8").charAt(0) == 'd');
//            dirContent.add(b);
            dirContent.add(new BrowserItem(resp));
            resp = ls_resp.readNext(clientInStream);
        }
        return dirContent;
    }

    private ArchiveVMap fillArchiveVMap(DataInputStream clientInStream) throws IOException {
        ArchiveVMap v = new ArchiveVMap();
        // read len, if 0 stop reading
        ls_resp resp = ls_resp.readNext(clientInStream);
        int entryCnt = 0; // for extracting selected files, it is necessary to know their position in the archive entries list
        while (resp != null) {
            if(resp.permissions[0] != '!') {
                List<String> inArchivePath = new ArrayList<>(Arrays.asList((new String(resp.filename, StandardCharsets.UTF_8)).split("/")));
                inArchivePath.add(ArchiveVMap.sentinelKeyForNodeProperties);

                Map<String,Object> nodeProps = new HashMap<>();

                nodeProps.put("i",entryCnt);
                nodeProps.put("size",resp.size);
                nodeProps.put("date",new Date(resp.date*1000L));
                nodeProps.put("isDir",new String(resp.permissions, StandardCharsets.UTF_8).charAt(0) == 'd');

                v.set(nodeProps,inArchivePath.toArray()); // put in vMap with properties
            }
            resp = ls_resp.readNext(clientInStream);
            entryCnt++;
        }
        return v;
    }

    // ls interaction return list of BrowserItem (which is only a representation class, not a business logic one)
    // this because every request in the root case has to be passed to roothelper, so it doesn't make sense to create
    // an intermediate DirWithContent object

    public GenericDirWithContent listDirectory(BasePathContent dirPath) {
        StreamsPair rs = null;
        try {
            rs = getStreams(dirPath,true);

            List<BrowserItem> dirContent;
            SinglePath_rq req = new ls_rq(dirPath.dir);

            // send request
            req.write(rs.o);
            Log.d("roothelperclient","Ls request sent");


            // read responses (one item per file in directory)
            // read control byte (ok or error) // TODO embed in constructor? create two response classes (base response -1 file - and full response (accounting length-0 list termination)?

            // TODO response byte to be embedded in response classes (maybe also request byte)
            byte responseByte = rs.i.readByte();
            ResponseCodes c = ResponseCodes.getCode(responseByte);

            switch(c) {
                case RESPONSE_REDIRECT:
                    // read and replace redirect path before directory content
                    dirPath.dir = Misc.receiveStringWithLen(rs.i);
                    // missing break statement is intentional here
                case RESPONSE_OK:
                    dirContent = assembleContentFromLsResps(rs.i);
                    break;
                case RESPONSE_ERROR:
                    // propagate errno within DirWithContent object
                    byte[] errno_ = new byte[4];
                    rs.i.readFully(errno_);
                    int errno = (int) Misc.castBytesToUnsignedNumber(errno_,4);
                    Log.e("roothelper","Error returned from roothelper server: "+errno);
                    return new LocalDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS); // TODO errno constants in enum
                default:
                    throw new RuntimeException("Unexpected response code from roothelper server: "+(int)responseByte);
            }

            if (dirPath instanceof LocalPathContent)
                return new LocalDirWithContent(dirPath.dir,dirContent);
            else
                return new XFilesRemoteDirWithContent(
                        ((XREPathContent)dirPath).serverHost,
                        dirPath.dir,
                        dirContent);
        }
        catch (IOException e) {
            try { rs.close(); } catch (Exception ignored) {}
            if (dirPath instanceof LocalPathContent)
                return new LocalDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
            else {
                MainActivity.rootHelperRemoteClientManager.fastClients.remove(((XREPathContent)dirPath).serverHost);
                return new XFilesRemoteDirWithContent(
                        ((XREPathContent)dirPath).serverHost,
                        FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
            }
        }
        finally {
            if (dirPath instanceof LocalPathContent) {
                try { rs.close(); } catch (Exception ignored) {}
            }
        }
    }

    // because there are points when a new RootHelper instance is created locally
    public static final GenericMRU<String,ArchiveVMap> archiveMRU = new GenericMRU<>(10); // up to 10 entries

    // password may be null
    @Override
    public GenericDirWithContent listArchive(BasePathContent archivePath) {
        SingleStatsItem statForModifiedDate;
        Date modifiedFileDate;
        String path;
        String subpath;
        String password;
        ArchiveVMap archiveMap;

        try {
            // retrieve modification time of the archive file
            if (archivePath.providerType == ProviderType.LOCAL) {
                statForModifiedDate = statFile(archivePath);
                path = archivePath.dir;
                subpath = "";
                password = "";
            }
            else if (archivePath.providerType == ProviderType.LOCAL_WITHIN_ARCHIVE) {
                statForModifiedDate = statFile(new LocalPathContent(((ArchivePathContent) archivePath).archivePath));
                path = ((ArchivePathContent) archivePath).archivePath;
                subpath = archivePath.dir;
                password = ((ArchivePathContent) archivePath).password;
            }
            else throw new RuntimeException("Unexpected provider type");
            if (statForModifiedDate == null) {
                return new GenericDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
            }
            modifiedFileDate = statForModifiedDate.modificationTime;
        }
        catch (IOException e) {
            return new GenericDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
        }

        // check if the base archive exists in MRU and has not been modified, or not exists
        archiveMap = archiveMRU.getByPath(path,modifiedFileDate);
        if (archiveMap == null) { // file not yet in cache or conflicting modified dates
            // send listArchive request to rootHelper
            // zero-length password not allowed, used by roothelper protocol as indication of no password provided
            ls_archive_rq listArchive_rq = new ls_archive_rq(
                    path.getBytes(),
                    password==null?new byte[0]:password.getBytes()
            );

            try (StreamsPair rs = getStreams()) {
                listArchive_rq.write(rs.o);

                // receive response
                int errno = Misc.receiveBaseResponse(rs.i);
                if (errno==0) archiveMap = fillArchiveVMap(rs.i);
                else if (errno == 0x101010) return new GenericDirWithContent(FileOpsErrorCodes.NULL_OR_WRONG_PASSWORD);
                else return new GenericDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
            }
            catch (IOException e) {
                return new GenericDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
            }

            archiveMRU.setLatest(path,archiveMap,modifiedFileDate);
        }
        // at this point, if the file exists, the vmap is non null
        // retrieve subdir-only entries into genericdirwithcontent object

        List<BrowserItem> content = new ArrayList<>();
        List<String> inArchivePath = Arrays.asList(subpath.split("/"));

        if (inArchivePath.size()>0) { // get subdir children
            Map<String,Object> map = (Map) archiveMap.get(inArchivePath.toArray());
            for (Map.Entry entry: map.entrySet()) {
                if (
                        entry != null &&
                                !entry.getKey().equals(ArchiveVMap.sentinelKeyForNodeProperties)) {
                    content.add(
                            new BrowserItem(
                                    (String)(entry.getKey()),
                                    (Map<String,Object>)((Map<String,Object>)entry.getValue()).get(ArchiveVMap.sentinelKeyForNodeProperties)
                            )
                    );
                }
            }
        }
        else { // get children of root
            for (Map.Entry entry: archiveMap.h.entrySet()) {
                if (!entry.getKey().equals(ArchiveVMap.sentinelKeyForNodeProperties)) {
                    content.add(
                            new BrowserItem(
                                    (String)(entry.getKey()),
                                    (Map<String,Object>)((Map<String,Object>)entry.getValue()).get(ArchiveVMap.sentinelKeyForNodeProperties)
                            )
                    );
                }
            }
        }

        return new ArchiveSubDirWithContent(path,subpath,content);
    }

    private int handleCompressProgressAfterConfOK(StreamsPair rs, final long total) throws IOException {
        long last_progress = 0;
        int ret;
        // receive progress (end progress is -1 as uint64)
        for(;;) {
            long progress = Misc.receiveTotalOrProgress(rs.i);
            if (progress == EOF_ind) {
                if (last_progress == total) {
                    // OK
                }
                else {
                    // Warning, last progress before termination value differs from total
                }
                break;
            }
            last_progress = progress;
//            builder.setProgress((int) total, (int) progress,false);
//            notifyManager.notify(NOTIF_ID, builder.build());
            task.publishProgressWrapper(new Pair<>(progress, total));

//            Log.d("setCompleted ","publishProgressWrapper progress:\t"+progress+"\ttotal: "+total);
//            Log.d("setCompleted ","publishProgressWrapper round:\t"+Math.round(progress*100.0/total));
        }

        // receive 1-byte final OK or error response
        ret = Misc.receiveBaseResponse(rs.i);
        if (ret != 0) {
            Log.e("setCompleted ","Received error code after complete: "+ret);
        }
        rs.close();
        return ret;
    }

    private int handleCompressProgressAfterConfOK(StreamsPair rs, final long total, ContentResolver resolver, List<Uri> uris, int nativeUds) throws IOException {
        long last_progress = 0;
        int ret;
        byte[] b_idx = new byte[4];

        long totalFromRh = Misc.receiveTotalOrProgress(rs.i);

        if(totalFromRh != total) {
            Log.w("setCompleted","Expected total "+total+" is different from the one accumulated from RootHelper ("+totalFromRh+")");
        }

        // receive progress (end progress for single file is -1 as uint64, end all is -2 as uint64)
        for(;;) {
            long progress = Misc.receiveTotalOrProgress(rs.i);
            if (progress == EOF_ind) {
                // receive index and send corresponding fd
                Log.d("setCompleted","[RHClient]receiving index after EOF");
                rs.i.readFully(b_idx);
                int index = (int) Misc.castBytesToUnsignedNumber(b_idx,4);
                Log.d("setCompleted","[RHClient]index after EOF is "+index+", now sending fd for that index");
                int fdToSend = resolver.openFileDescriptor(uris.get(index),"r").detachFd(); // will be closed internally by p7zip back-end in rh forked process
                Native.sendDetachedFD(nativeUds,fdToSend);
                Log.d("setCompleted","[RHClient]fd for index "+index+" sent");
            }
            else if (progress == EOFs_ind) {
                Log.d("setCompleted","End of files");
                break;
            }
            else {
                if (progress - last_progress > 1000000) {
                    last_progress = progress;
                    task.publishProgressWrapper(new Pair<>(progress, total));
                }
            }
        }

        // receive 1-byte final OK or error response
        ret = Misc.receiveBaseResponse(rs.i);
        if (ret != 0) {
            Log.e("setCompleted ","Received error code after complete: "+ret);
        }
        rs.close();
        return ret;
    }

    public int compressToArchiveFromFds(CopyListUris contentUris,
                                        BasePathContent destArchive,
                                        @Nullable Integer compressionLevel,
                                        @Nullable Boolean encryptHeaders,
                                        @Nullable Boolean solidMode,
                                        @Nullable String password,
                                        ContentResolver resolver) throws IOException {
        if (destArchive.providerType!=ProviderType.LOCAL)
            throw new RuntimeException("Unexpected path content type"); // abuse of exception

        rs = getStreams();

        // send request byte with flags
        byte customizedRq = ControlCodes.ACTION_COMPRESS.getValue();
        customizedRq ^= (7 << 5); // flags: 111
        rs.o.write(customizedRq);

        int nativeUds = ContentProviderUtils.getNativeDescriptor(((RootHelperStreams)rs).ls);

        long total = 0;

        // compute file stats in JNI and send them all
        List<Uri> parsedUris = new ArrayList<>();
        for (String uri_ : contentUris.contentUris) {
            Uri uri = Uri.parse(uri_);
            parsedUris.add(uri);
            String filename = ContentProviderUtils.getName(resolver,uri);
            int fd = resolver.openFileDescriptor(uri,"r").detachFd();
            long fileSize = Native.sendfstat(nativeUds,fd,filename); // fd will be closed here after fstat
            if (fileSize < 0) throw new IOException("Unable to fstat "+filename);
            total += fileSize;
        }
        rs.o.write(Misc.EOL);

        Misc.sendStringWithLen(rs.o, destArchive.dir); // destArchive

        new compress_rq_options(compressionLevel,encryptHeaders,solidMode).writecompress_rq_options(rs.o); // compress options

        byte[] password_ = (password == null)?new byte[0]:password.getBytes();
        rs.o.write(password_.length); // single byte
        if (password_.length != 0)
            rs.o.write(password_);

        // OK response means archive init has been successful, and actual compression starts now, so start receiving progress
        int ret = Misc.receiveBaseResponse(rs.i);
        if (ret != 0) {
            rs.close();
            Log.e("setCompleted ","Received error code before progress start: "+ret);
            return ret;
        }

        return handleCompressProgressAfterConfOK(rs,total,resolver,parsedUris,nativeUds);
    }

    // Java zip backend
    // JUST IGNORE ALL OPTIONS, DEFAULT OUTPUT FORMAT TO ZIP
//    public int compressToArchiveFromFds(CopyListUris contentUris,
//                                        BasePathContent destArchive,
//                                        @Nullable Integer compressionLevel,
//                                        @Nullable Boolean encryptHeaders,
//                                        @Nullable Boolean solidMode,
//                                        @Nullable String password,
//                                        ContentResolver resolver) throws IOException {
//        if (destArchive.providerType!=ProviderType.LOCAL)
//            throw new RuntimeException("Unexpected path content type"); // abuse of exception
//
//        long total = 0;
//
//        // compute file stats in JNI and send them all
//        List<Uri> parsedUris = new ArrayList<>();
//        for (String uri_ : contentUris.contentUris) {
//            Uri uri = Uri.parse(uri_);
//            parsedUris.add(uri);
//            try(ParcelFileDescriptor pfd = resolver.openFileDescriptor(uri,"r")) {
//                total += pfd.getStatSize();
//            }
//        }
//
//        long progress = 0;
//        long lastShownProgress = 0;
//        // init zip archive
//        try(ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(new File(destArchive.dir)))) {
//            for (Uri uri : parsedUris) {
//                try(InputStream is = resolver.openInputStream(uri)) {
//                    String filename = ContentProviderUtils.getName(resolver,uri);
//                    ZipEntry ze = new ZipEntry(filename);
//                    zos.putNextEntry(ze);
//                    byte[] bytes = new byte[4096];
//                    for(;;) {
//                        int readBytes = is.read(bytes);
//                        if (readBytes <= 0) break;
//                        zos.write(bytes,0,readBytes);
//                        progress += readBytes;
//                        if (progress - lastShownProgress > 1000000) {
//                            lastShownProgress = progress;
//                            task.publishProgressWrapper((int)Math.round(progress*100.0/total));
//                        }
//                    }
//                    zos.closeEntry();
//                }
//            }
//        }
//        return 0;
//    }

    @Override
    public int compressToArchive(BasePathContent srcDirectory,
                                 BasePathContent destArchive,
                                 @Nullable Integer compressionLevel,
                                 @Nullable Boolean encryptHeaders,
                                 @Nullable Boolean solidMode,
                                 @Nullable String password,
                                 @Nullable List<String> filenames) throws IOException {
        rs = getStreams();

        if (!(srcDirectory.providerType==ProviderType.LOCAL &&
                destArchive.providerType==ProviderType.LOCAL)) {
            throw new RuntimeException("Unexpected path content type"); // abuse of exception
        }

        compress_rq rq = new compress_rq(
                srcDirectory.toString(),
                destArchive.toString(),
                compressionLevel,
                encryptHeaders,
                solidMode,
                password,
                filenames);
        rq.write(rs.o);

        // OK response means archive init has been successful, and actual compression starts now, so start receiving progress
        int ret = Misc.receiveBaseResponse(rs.i);
        if (ret != 0) {
            rs.close();
            Log.e("setCompleted ","Received error code: "+ret);
            return ret;
        }

        // receive total
        long total = Misc.receiveTotalOrProgress(rs.i);
//        Log.d("setCompleted ","Received total size: "+total);

        return handleCompressProgressAfterConfOK(rs,total);
    }

    /*
    extract from archive:
        - extract all: assumes file browser is currently OUTSIDE of an archive, so vmap need not exist;
          error results (among which, the null or wrong password one) are within GenericDirWithContent return value
        - extract some: assumes file browser is currently WITHIN an archive, so vmap MUST exist (throw runtimeexception if it doesn't);
     */
    @Override
    public List<FileOpsErrorCodes> extractFromArchive(List<BasePathContent> srcArchives,
                                                BasePathContent destDirectory,
                                                @Nullable String password,
                                                @Nullable Iterable<String> filenames,
                                                boolean smartDirectoryCreation) throws IOException {

        if (destDirectory != null && destDirectory.providerType != ProviderType.LOCAL) {
            throw new RuntimeException("Forbidden type for destination directory");
        }

        String destDir = destDirectory==null ? "" : destDirectory.dir;

        switch (srcArchives.get(0).providerType) {
            case LOCAL:
                // entryIdxs will be ignored, extract/test all, no need to preload VMap
                return extract(srcArchives, destDir, password,null,smartDirectoryCreation); // extract/test all
            case LOCAL_WITHIN_ARCHIVE:
                break;
            default:
                throw new RuntimeException("Forbidden types for archive and/or directories");
        }

        // since this point, we are LOCAL_WITHIN_ARCHIVE, so srcArchives must have size 1
        if(srcArchives.size() != 1) throw new RuntimeException("Guard block");

        ArchivePathContent srcArchive = (ArchivePathContent) srcArchives.get(0);
        ArchiveVMap avm = archiveMRU.getByPath(srcArchive.archivePath);
        if (avm == null) throw new RuntimeException("VMap should be non-null once in archive!");

        List<Integer> entries = new ArrayList<>();

        // srcArchive is ArchivePathContent
        if (filenames == null || !filenames.iterator().hasNext()) {
            if (srcArchive.dir == null || srcArchive.dir.equals("") || srcArchive.dir.equals("/")) {
                // no selection in root dir of archive, extract/test all
                return extract(srcArchives, // actually srcArchive as only item in the list
                        destDir, password,null,smartDirectoryCreation); // extract all
            }
            else {
                // no selection in subpath of archive
                // iterator over srcArchive (subpath as root), accumulate idxs
                entries.addAll(getEntries(avm,srcArchive.dir));
            }
        }
        else {
            // some selection
            for (String filename : filenames) {
                entries.addAll(getEntries(avm,srcArchive.concat(filename).dir));
            }
        }

        int stripPathLen = (srcArchive.dir==null||srcArchive.dir.equals("/"))?0:srcArchive.dir.length();
        return extract(srcArchives, // actually srcArchive as only item in the list
                destDir,
                password,
                new RelativeExtractEntries(stripPathLen,entries),
                smartDirectoryCreation);
    }

    @Override
    public int setDates(BasePathContent file, @Nullable Date accessDate, @Nullable Date modificationDate) {
        try (StreamsPair rs = getStreams()) {
            if (file.providerType!=ProviderType.LOCAL) return -1;
            setDates_rq rq = new setDates_rq(file.dir,accessDate,modificationDate);
            rq.write(rs.o);
            return Misc.receiveBaseResponse(rs.i);
        }
        catch (Exception e) {
            return -1;
        }
    }

    @Override
    public int setPermissions(BasePathContent file, int permMask) {
        try (StreamsPair rs = getStreams()) {
            if (file.providerType!=ProviderType.LOCAL) return -1;
            setPermission_rq rq = new setPermission_rq(file.dir,permMask);
            rq.write(rs.o);
            return Misc.receiveBaseResponse(rs.i);
        }
        catch (Exception e) {
            return -1;
        }
    }

    @Override
    public int setOwnership(BasePathContent file, @Nullable Integer ownerId, @Nullable Integer groupId) {
        try (StreamsPair rs = getStreams()) {
            if (file.providerType!=ProviderType.LOCAL) return -1;
            setOwnership_rq rq = new setOwnership_rq(file.dir,ownerId,groupId);
            rq.write(rs.o);
            return Misc.receiveBaseResponse(rs.i);
        }
        catch (Exception e) {
            return -1;
        }
    }

    private List<Integer> getEntries(ArchiveVMap vMap, String relToArchivePathname) throws IOException {
        List<Integer> entries = new ArrayList<>();

        if (relToArchivePathname.equals("") || relToArchivePathname.equals("/"))
            throw new RuntimeException("This condition should be managed earlier than here");

        VMapSubTreeIterable it = new VMapSubTreeIterable(vMap,relToArchivePathname.split("/"));

        for (Map.Entry me : it) {
            if (me.getKey().equals(ArchiveVMap.sentinelKeyForNodeProperties)) {
                Map x = (Map)me.getValue();
                Integer ii = (Integer) x.get("i");
                entries.add(ii);
            }
        }

        return entries;
    }

    private List<FileOpsErrorCodes> extract(List<BasePathContent> archives,
                                      String directory,
                                      @Nullable String password,
                                      @Nullable RelativeExtractEntries entries,
                                      boolean smartDirectoryCreation) throws IOException {
        rs = getStreams();

        if(archives.size() == 1) { // extract/test whole single archive, or extract/test some items from within one single archive
            BasePathContent bpc = archives.get(0);
            new extract_rq(bpc instanceof ArchivePathContent ? ((ArchivePathContent) bpc).archivePath : bpc.dir,
                    directory, password, null, entries, smartDirectoryCreation).write(rs.o);
        }
        else {
            new multi_extract_rq(archives, directory, password, smartDirectoryCreation).write(rs.o);
        }

        List<FileOpsErrorCodes> rets = new ArrayList<>();

        int nArchives = archives.size();
        boolean multiExtract = nArchives > 1;
        for(int i=0;i<nArchives;i++) {
            FileOpsErrorCodes ret;
            int errno = Misc.receiveBaseResponse(rs.i);
            if (errno == 0x101010) ret = FileOpsErrorCodes.NULL_OR_WRONG_PASSWORD; // null or wrong password for encrypted filenames archive
            else if (errno == 0x03) ret = FileOpsErrorCodes.CRC_FAILED; // probably, wrong password for plain filenames archive
            else if (errno == 0) { // start receiving progress here
                // receive total
                long total = Misc.receiveTotalOrProgress(rs.i);
                long last_progress = 0;

                // receive progress (end progress is -1 as uint64)
                for(;;) {
                    long progress = Misc.receiveTotalOrProgress(rs.i);
                    if (progress == EOF_ind) {
                        if (last_progress == total) {
                            // OK
                        }
                        else {
                            // Warning, last progress before termination value differs from total
                        }
                        break;
                    }
                    last_progress = progress;
                    Pair<Long, Long> inner =  new Pair<>(progress, total);
                    if(multiExtract)
                        task.publishProgressWrapper(new Pair<>((long)i,(long)nArchives),inner);
                    else task.publishProgressWrapper(inner);
                }

                // receive 1-byte final OK or error response
                errno = Misc.receiveBaseResponse(rs.i);
                if (errno == 0) ret = null;
                else if (errno == 0x101010) ret = FileOpsErrorCodes.NULL_OR_WRONG_PASSWORD; // null or wrong password for encrypted filenames archive
                else if (errno == 0x03) ret = FileOpsErrorCodes.CRC_FAILED; // probably, wrong password for plain filenames archive
                else ret = FileOpsErrorCodes.TRANSFER_ERROR;
            }
            else ret = FileOpsErrorCodes.TRANSFER_ERROR;
            rets.add(ret);
        }
        rs.close();
        return rets;
    }

    // TODO Remove find methods from interface, already implemented RH only

    @Override
    public String createFileOrDirectory(BasePathContent path, FileMode fileOrDirectory, FileCreationAdvancedOptions... fileOptions) throws IOException {
        SinglePath_rq req = (fileOrDirectory == FileMode.FILE && fileOptions.length > 0 && fileOptions[0] != null) ?
                new create_rq(path.dir, fileOptions[0]):
                new create_rq(path.dir, fileOrDirectory);
        int errno;
        String errMsg;
        StreamsPair rs = getStreams(path,true);
        req.write(rs.o);
        Log.d("roothelperclient","Create request sent");
        errno = Misc.receiveBaseResponse(rs.i);
        if(errno == 0) {
            if(fileOptions.length > 0) { // if a non-empty regular file is being created
                // receive progress
                FileCreationAdvancedOptions fopts = fileOptions[0];
                long progress;
                long total = fopts.size;
                do {
                    progress = Misc.receiveTotalOrProgress(rs.i);
                    task.publishProgressWrapper(new Pair<>(progress, total));
                }
                while(progress != EOF_ind);

                if(fopts.strategy.mode == FileCreationAdvancedOptions.FileCreationMode.RANDOM &&
                        fopts.strategy.outputHashType != null) {
                    return Misc.receiveStringWithLen(rs.i); // output hash, to be shown in dialog
                }
            }
            return null;
        }
        else if(errno == 17)
            errMsg = ALREADY_EXIST;
        else
            errMsg = fileOrDirectory.name().toLowerCase()+" creation error, errno is: "+errno;
        throw new IOException(errMsg);
    }

    @Override
    public void createLink(BasePathContent originPath, BasePathContent linkPath, boolean isHardLink) throws IOException {
        if((originPath.providerType != linkPath.providerType) ||
                ((originPath instanceof XREPathContent) &&
                        (!Objects.equals(((XREPathContent)originPath).serverHost,((XREPathContent)linkPath).serverHost))))
            throw new RuntimeException("Target and link paths must belong to the same filesystem");
        StreamsPair rs = getStreams(originPath,true);
        link_rq rq = new link_rq(originPath.dir,linkPath.dir,isHardLink);
        rq.write(rs.o);
        int errno = Misc.receiveBaseResponse(rs.i);
        if (errno != 0) throw new IOException("link creation error, errno is "+errno);
    }

    public BitSet existsIsFileIsDir(BasePathContent filePath, boolean exists, boolean isFile, boolean isDir) {
        BitSet ret = new BitSet(3);
        if (filePath.providerType==null) return ret;
        switch (filePath.providerType) {
            case LOCAL:
                exists_rq rq = new exists_rq(filePath.dir,exists,isFile,isDir);
                try (StreamsPair rs = getStreams()) {
                    rq.write(rs.o);
                    exists_resp resp = new exists_resp(rs.i);
                    return resp.respFlags;
                }
                catch (IOException ignored) {}
                return ret;
            case LOCAL_WITHIN_ARCHIVE:
                // TODO check existence in VMap
                return ret;
            case XFILES_REMOTE:
                // FIXME add exist request for XRE remote checksum request on single file
                return ret;
            default:
                throw new RuntimeException("Unsupported BasePathContent subtype in roothelperclient exists call");
        }
    }

    public boolean exists(BasePathContent filePath) {
        return existsIsFileIsDir(filePath,true,false,false).get(0);
    }

    public boolean isFile(BasePathContent filePath) {
        return existsIsFileIsDir(filePath,false,true,false).get(1);
    }

    public boolean isDir(BasePathContent filePath) {
        return existsIsFileIsDir(filePath,false,false,true).get(2);
    }

    // TODO to be tested
    // client test case for delete request-response interaction(s)
    @Override
    public void deleteFilesOrDirectories(List<BasePathContent> filePaths) throws IOException {
        // TODO make one connection per set of delete requests
        for (BasePathContent filePath : filePaths) {
            SinglePath_rq req = new del_rq(filePath.dir);
            StreamsPair rs = getStreams();

            // send request
            req.write(rs.o);
            Log.d("roothelperclient","Del request sent");


            // read responses (one item per file in directory)
            // read control byte (ok or error)

            byte responseByte = rs.i.readByte();
            ResponseCodes c = ResponseCodes.getCode(responseByte);

            switch(c) {
                case RESPONSE_OK:
                    Log.d("roothelper","OK returned from roothelper server for delete file: "+filePath.dir);
                    break;
                case RESPONSE_ERROR:
                    byte[] errno_ = new byte[4];
                    rs.i.readFully(errno_);
                    int errno = (int) Misc.castBytesToUnsignedNumber(errno_,4);
                    String msg = "Error returned from roothelper server: "+errno+" for file "+filePath.dir;
                    Log.e("roothelper",msg);
                    throw new IOException(msg);
                default:
                    throw new RuntimeException("Unexpected response code from roothelper server: "+(int)responseByte);
            }
        }
    }

    @Override
    public boolean renameFile(BasePathContent oldPathname, BasePathContent newPathname) throws IOException {
        // treat as move request
        StreamsPair rs = getStreams();

        // send request
        ListOfPathPairs_rq rq = new movelist_rq(
                Collections.singletonList(oldPathname.dir),
                Collections.singletonList(newPathname.dir)
        );
        rq.write(rs.o);

        // receive 1 EOF and 1 EOFs progress since move sends them, then receive OK/error response
        byte[] b = new byte[8];
        rs.i.read(b); // EOF
        rs.i.read(b); // EOFs

        boolean ret = false;
        if (Misc.receiveBaseResponse(rs.i) == 0) ret = true;

        rs.close();
        return ret;
    }

    @Override
    public SingleStatsItem statFile(BasePathContent pathname) throws IOException {
        switch (pathname.providerType) {
            case LOCAL:
                StreamsPair rs = getStreams();

                singleStats_rq rq = new singleStats_rq(pathname.dir,FileMode.FILE);
                rq.write(rs.o);

                if (Misc.receiveBaseResponse(rs.i) != 0) return null;

                // receive and return response
                singleStats_resp resp = new singleStats_resp(rs.i);
                rs.close();
                return new SingleStatsItem(resp);

            case LOCAL_WITHIN_ARCHIVE:
                ArchiveVMap v = archiveMRU.getByPath(((ArchivePathContent)pathname).archivePath);
                if (v == null)
                    throw new RuntimeException("ArchiveVMap should already be populated within archive");
                Map nodeProps = v.getNodeProps(pathname.dir);
                return new SingleStatsItem(
                        "", // empty group
                        "", // empty owner
                        new Date(0L),
                        new Date(0L),
                        (Date)nodeProps.get("date"),
                        (boolean)nodeProps.get("isDir")?"d---------":"----------",
                        (long)nodeProps.get("size")
                );
            case XFILES_REMOTE:
                XREPathContent xrpc = (XREPathContent) pathname;
                RemoteManager rm = MainActivity.rootHelperRemoteClientManager.getClient(xrpc.serverHost,true);
                if (rm == null) return null;
                // TODO stats_resp
                rq = new singleStats_rq(pathname.dir,FileMode.FILE);
                rq.write(rm.o);

                if (Misc.receiveBaseResponse(rm.i) != 0) return null;

                // receive and return response
                resp = new singleStats_resp(rm.i);
                return new SingleStatsItem(resp);

            default:
                throw new RuntimeException("Roothelper should not be the current helper when exploring SFTP paths");
        }
    }

    @Override
    public folderStats_resp statFiles(List<BasePathContent> files) throws IOException {
        if (files.isEmpty()) throw new IOException("statfiles list empty, cannot determine provider type");
        switch(files.get(0).providerType) {
            case LOCAL:
                StreamsPair rs = getStreams();
                List<String> tmp = new ArrayList<>();
                for (BasePathContent bpc : files) tmp.add(bpc.dir);
                multiStats_rq rq = new multiStats_rq(tmp);
                rq.write(rs.o);

                int errno = Misc.receiveBaseResponse(rs.i);
                if (errno != 0) {
                    Log.e("roothelperclient", "statFiles: Some files could not be stat, error code: " + errno);
                }

                // TODO propagate errno along with response
                // receive and return response
                folderStats_resp response = new folderStats_resp(rs.i);
                rs.close();
                return response;
            case LOCAL_WITHIN_ARCHIVE:
                // stat inner folder of archive (that is, archive is already opened and vmap is in memory)
                ArchiveVMap v = archiveMRU.getByPath(((ArchivePathContent) files.get(0)).archivePath);
                if (v == null)
                    throw new RuntimeException("ArchiveVMap should already be populated within archive");

                long childrenFiles = 0, childrenDirs = 0, totalFiles = 0, totalDirs = 0, totalSize = 0;
                for (BasePathContent pathname : files) {
                    VMapSubTreeIterable it = new VMapSubTreeIterable(v, pathname.dir.split("/"));

                    // FIXME currently, also the current folder node is taken into account when iterating (so, totalFolders is shifted up by 1)
                    for (Map.Entry me : it) {
                        if (me.getKey().equals(ArchiveVMap.sentinelKeyForNodeProperties)) {
                            Map x = (Map) me.getValue();
                            // TODO populate children files and dirs as well
                            boolean isDir = (boolean) x.get("isDir");
                            if (isDir) totalDirs++;
                            else {
                                totalFiles++;
                                totalSize += (long) x.get("size");
                            }
                        }
                    }
                }

                return new folderStats_resp(
                        childrenDirs,
                        childrenFiles,
                        totalDirs,
                        totalFiles,
                        totalSize);

            case XFILES_REMOTE:
                XREPathContent xrpc = (XREPathContent) files.get(0);
                RemoteManager rm = MainActivity.rootHelperRemoteClientManager.getClient(xrpc.serverHost, true);
                if (rm == null) return null;

                tmp = new ArrayList<>();
                for (BasePathContent bpc : files) tmp.add(bpc.dir);
                rq = new multiStats_rq(tmp);
                rq.write(rm.o);

                errno = Misc.receiveBaseResponse(rm.i);
                if (errno != 0) {
                    Log.e("roothelperclient", "Some files could not be stat, error code: " + errno);
                }

                // TODO propagate errno along with response
                // receive and return response
                return new folderStats_resp(rm.i);
            default:
                throw new RuntimeException("Roothelper should not be the current helper when exploring SFTP paths");
        }
    }

    @Override
    public folderStats_resp statFolder(BasePathContent pathname) throws IOException {
        switch(pathname.providerType) {
            case LOCAL:
                StreamsPair rs = getStreams();
                singleStats_rq rq = new singleStats_rq(pathname.dir, FileMode.DIRECTORY);
                rq.write(rs.o);

                int errno = Misc.receiveBaseResponse(rs.i);
                if (errno != 0)
                    Log.e("roothelperclient", "Some files could not be stat, error code: " + errno);

                // TODO propagate errno along with response
                // receive and return response
                folderStats_resp response = new folderStats_resp(rs.i);
                rs.close();
                return response;
            case LOCAL_WITHIN_ARCHIVE:
                // stat inner folder of archive (that is, archive is already opened and vmap is in memory)
                ArchiveVMap v = archiveMRU.getByPath(((ArchivePathContent) pathname).archivePath);
                if (v == null)
                    throw new RuntimeException("ArchiveVMap should already be populated within archive");

                VMapSubTreeIterable it = new VMapSubTreeIterable(v, pathname.dir.split("/"));

                long childrenFiles = 0, childrenDirs = 0, totalFiles = 0, totalDirs = 0, totalSize = 0;

                // FIXME currently, also the current folder node is taken into account when iterating (so, totalFolders is shifted up by 1)
                for (Map.Entry me : it) {
                    if (me.getKey().equals(ArchiveVMap.sentinelKeyForNodeProperties)) {
                        Map x = (Map) me.getValue();
                        // TODO populate children files and dirs as well
                        boolean isDir = (boolean) x.get("isDir");
                        if (isDir) totalDirs++;
                        else {
                            totalFiles++;
                            totalSize += (long) x.get("size");
                        }
                    }
                }

                return new folderStats_resp(
                        childrenDirs,
                        childrenFiles,
                        totalDirs,
                        totalFiles,
                        totalSize);
            case XFILES_REMOTE:
                XREPathContent xrpc = (XREPathContent) pathname;
                RemoteManager rm = MainActivity.rootHelperRemoteClientManager.getClient(xrpc.serverHost, true);
                if (rm == null) return null;

                rq = new singleStats_rq(pathname.dir, FileMode.DIRECTORY);
                rq.write(rm.o);

                errno = Misc.receiveBaseResponse(rm.i);
                if (errno != 0)
                    Log.e("roothelperclient", "Some files could not be stat, error code: " + errno);

                // TODO propagate errno along with response
                // receive and return response
                return new folderStats_resp(rm.i);
            default:
                throw new RuntimeException("Roothelper should not be the current helper when exploring SFTP paths");
        }
    }

    @Override
    public void copyMoveFilesToDirectory(CopyMoveListPathContent files, BasePathContent dstFolder) throws IOException {
        // for x in pathnames (full paths), send to roothelper the pair:
        // (x , dstFolder + "/" + x.getName() ) // stop on first level, roothelper C code performs dir tree move/copy/delete if needed
        // receive one response per pair

        // this variable must be saved into the corresponding CopyMoveTask
        // in order to interrupt the long-term copy operation by close/shutdown streams
//        RootHelperStreams rs = getStreams();
        rs = getStreams();

        // new mode: send list of file pairs in one request, then receive progress
        List<String> srcs = new ArrayList<>();
        List<String> dests = new ArrayList<>();

        for (String pathname : files) {
            srcs.add(pathname);
            dests.add(dstFolder.dir+"/"+(new File(pathname).getName()));
        }

        ListOfPathPairs_rq rq = (files.copyOrMove == CopyMoveMode.COPY) ?
                new copylist_rq(srcs,dests):new movelist_rq(srcs,dests);
        rq.write(rs.o);

        // for copy, receive total number of files for outer progress
        // (all regular files in all subfolders at any level of given items)
        long totalFileCount,totalSize = 0;
        if (files.copyOrMove == CopyMoveMode.COPY) {
            byte[] tot_ = new byte[8];
            rs.i.readFully(tot_);
            totalFileCount = Misc.castBytesToUnsignedNumber(tot_,8);
            rs.i.readFully(tot_);
            totalSize = Misc.castBytesToUnsignedNumber(tot_,8);
        }
        // for move, consider only top-level elements (dir and folders)
        else {
            totalFileCount = files.files.size();
        }

        //////////////////////// BEGIN LEGACY /////////////////////////////
//        long currentFileCount = 0;
//        long currentFileSize = EOF_ind; // placeholder, just to avoid uninitialized error
//
//        boolean hasReceivedSizeForCurrentFile = false;
//
//        // receive progress for single files, increment outer progress bar by 1 on EOF_ind progress
//        for (;;) {
//            long tmp = Misc.receiveTotalOrProgress(rs.i);
//
//            if (tmp == EOF_ind) {
//                hasReceivedSizeForCurrentFile = false;
//                currentFileCount++;
//                task.publishProgressWrapper(
//                        (int)Math.round(currentFileCount*100.0/totalFileCount),
//                        0
//                );
//            }
//            else if (tmp == EOFs_ind) break;
//            else {
//                if (hasReceivedSizeForCurrentFile) {
//                    task.publishProgressWrapper(
//                            (int)Math.round(currentFileCount*100.0/totalFileCount),
//                            (int)Math.round(tmp*100.0/currentFileSize)
//                    );
//                }
//                else {
//                    // here, tmp is current file's size, before starting copying current file
//                    currentFileSize = tmp;
//                    hasReceivedSizeForCurrentFile = true;
//                    task.publishProgressWrapper(
//                            (int)Math.round(currentFileCount*100.0/totalFileCount),
//                            0
//                    );
//                }
//            }
//        }

        //////////////////////// END LEGACY /////////////////////////////

        //////////////////////// BEGIN NEW /////////////////////////////
        new ProgressConflictHandler(rs,task,totalFileCount,totalSize,files.copyOrMove).start();
        //////////////////////// END NEW /////////////////////////////

        rs.close();
    }

    @Override
    public byte[] hashFile(BasePathContent pathname,
                           HashRequestCodes hashAlgorithm,
                           BitSet dirHashOpts) throws IOException {
        if (pathname instanceof XREPathContent)
            if (!ProgressIndicator.acquire(ForegroundServiceType.XRE_HASH)) return null;

        try {
            rs = getStreams(pathname,false);
            SinglePath_rq rq = new hash_rq(
                    pathname.dir,
                    hashAlgorithm,
                    dirHashOpts
            );
            rq.write(rs.o);

            int resp = Misc.receiveBaseResponse(rs.i);
            if (resp == 0) {
                byte[] digest = new byte[hashAlgorithm.getLength()];
                rs.i.readFully(digest);
                return digest;
            }
            return null;
        }
        catch (IOException e) {
            if (pathname instanceof XREPathContent) {
                rs.close();
                MainActivity.rootHelperRemoteClientManager.longTermClients.remove(((XREPathContent)pathname).serverHost);
                return null;
            }
            else throw e;
        }
        finally {
            if (pathname instanceof XREPathContent) {
                ProgressIndicator.release();
            }
            else rs.close();
        }

    }

    public void killServer() throws IOException {
        Log.d("RHClient","killserver invoked!!!!!!!!!!!!!!!");
        try(StreamsPair rs = getStreams()) {
            rs.o.write(ControlCodes.ACTION_EXIT.getValue());
        }
    }

    // kills another RH process (executing some long-term task) via SIGINT,
    // by performing the suitable ACTION_KILL request to the RH server instance
    // connected to this client (which, presumably, is different from the target server to be killed).
    // In theory, since the socket is bidirectional, one could also modify the RH server
    // to create an exit-only-listener thread to wait for request 31 (EXIT) and then issue exit(0)
    // and stop the entire process, but in case of conflict mode enabled, this listener thread
    // should also dispatch non-exit requests (conflict decisions) to the main thread, complicating
    // the server logic.
    /*
     * not used anymore, rh server is multithreaded
     */
    public int killRHProcess(long pid, SocketNames name) {
        Log.d("RHClient","kill invoked on pid "+pid);
        try (StreamsPair rs = getStreams()) {
            rs.o.write(ControlCodes.ACTION_KILL.getValue());
            rs.o.write(Misc.castUnsignedNumberToBytes(pid,4)); // PID
            rs.o.write(Misc.castUnsignedNumberToBytes(2,4)); // SIGNUM (SIGINT = 2)
            return Misc.receiveBaseResponse(rs.i);
        }
        catch (IOException e) {
            e.printStackTrace();
            return -1;
        }
    }

    // Using RH's internal HTTPS client
    public void downloadHttpsUrl(String url, String destPath, String[] targetFilename, boolean httpsOnly) throws IOException {
        try {
            rs = getStreams();
            try (FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(rs.o)) { // send a single packet instead of multiple ones
                byte req = ControlCodes.ACTION_HTTPS_URL_DOWNLOAD.getValue();
                req ^= ((httpsOnly ? 3 : 1) << 5); // flags: 011 vs 001 (most significant bit unused, httpsOnly variable, download to file true)
                nbf.write(req);
                Misc.sendStringWithLen(nbf,url);
                Misc.sendStringWithLen(nbf,destPath);
                Misc.sendStringWithLen(nbf,targetFilename[0]);
            }

            for(;;) {
                byte resp = rs.i.readByte();
                if (resp != ResponseCodes.RESPONSE_OK.getValue()) {
                    if (resp == ResponseCodes.RESPONSE_REDIRECT.getValue()) {
                        Log.d("RHHttpsClient","End of redirects");
                        break;
                    }
                    byte[] errno_ = new byte[4];
                    rs.i.readFully(errno_);
                    int errno = (int) Misc.castBytesToUnsignedNumber(errno_,4);
                    throw new IOException("Error returned from roothelper server: " + errno);
                }
                byte[] tlsSessionHash = new byte[32];
                rs.i.readFully(tlsSessionHash);
                Log.d("RHHttpsClient","Client TLS session shared secret hash: "+Misc.toHexString(tlsSessionHash));
            }

            targetFilename[0] = Misc.receiveStringWithLen(rs.i); // Receive possibly updated filename string from rh
            long downloadSize = Misc.receiveTotalOrProgress(rs.i);
            Log.d("RHHttpsClient","Received download size is: "+downloadSize);

            for(;;) {
                long progress = Misc.receiveTotalOrProgress(rs.i);
                if (progress == EOF_ind) break;
                if (downloadSize > 0)
                    task.publishProgressWrapper(new Pair<>(progress, downloadSize));
            }
            Log.d("RHHttpsClient","Download completed");
        }
        finally {
            rs.close();
        }
    }

    public byte[] downloadHttpsUrlInMemory(String url) throws IOException {
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try(StreamsPair rs = getStreams()) {
            try (FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(rs.o)) { // send a single packet instead of multiple ones
                byte req = ControlCodes.ACTION_HTTPS_URL_DOWNLOAD.getValue();
                req ^= (2 << 5); // flags: 010 -> most significant flag bit: unused; https only: true; download to file: false (i.e. download to memory)
                nbf.write(req);
                Misc.sendStringWithLen(nbf,url);
                Misc.sendStringWithLen(nbf,""); // empty dest path
                Misc.sendStringWithLen(nbf,""); // empty dest filename
            }

            for(;;) {
                byte resp = rs.i.readByte();
                if (resp != ResponseCodes.RESPONSE_OK.getValue()) {
                    if (resp == ResponseCodes.RESPONSE_REDIRECT.getValue()) { // RESPONSE_HTTPS_END_OF_REDIRECTS
                        Log.d("RHHttpsClient","End of redirects");
                        break;
                    }
                    byte[] errno_ = new byte[4];
                    rs.i.readFully(errno_);
                    int errno = (int) Misc.castBytesToUnsignedNumber(errno_,4);
                    throw new IOException("Error returned from roothelper server: " + errno);
                }
                byte[] tlsSessionHash = new byte[32];
                rs.i.readFully(tlsSessionHash);
                Log.d("RHHttpsClient","Client TLS session shared secret hash: "+Misc.toHexString(tlsSessionHash));
            }

            String unusedFilename = Misc.receiveStringWithLen(rs.i);
            long downloadSize = Misc.receiveTotalOrProgress(rs.i);
            Log.d("RHHttpsClient","Received download size is: "+downloadSize);

            for(;;) {
                byte[] x = new byte[1024];
                int readBytes = rs.i.read(x);
                if(readBytes <= 0) break;
                baos.write(x,0,readBytes);
            }
        }
        Log.d("RHHttpsClient","In-memory download completed");
        return baos.toByteArray();
    }

    // Using RH's internal HTTPS client
    public String uploadHttpsUrl(String domain, String srcPath) throws IOException {
        try {
            rs = getStreams();
            try (FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(rs.o)) { // send a single packet instead of multiple ones
                nbf.write(ControlCodes.ACTION_CLOUD_SERVICES.getValue());
                nbf.write(new byte[]{0x12, 0x00}); // HTTP upload selector string
                Misc.sendStringWithLen(nbf,domain); // upload domain: x0.at or 0x0.st
                Misc.sendStringWithLen(nbf,srcPath);
            }

            if(Misc.receiveBaseResponse(rs.i) != 0) throw new IOException("x0.at connection error");
            byte[] tlsSessionHash = new byte[32];
            rs.i.readFully(tlsSessionHash);
            Log.d("RHHttpsClient","Client TLS session shared secret hash: "+Misc.toHexString(tlsSessionHash));

            long size = Misc.receiveTotalOrProgress(rs.i);
            Log.d("RHHttpsClient","Received upload size is: "+size);

            for(;;) {
                long progress = Misc.receiveTotalOrProgress(rs.i);
                if (progress == EOF_ind) break;
                task.publishProgressWrapper(new Pair<>(progress, size));
            }
            Log.d("RHHttpsClient","Upload completed");

            /////////////////////////////////////////////////////////////////
            // Receive dummy data over local socket (common protocol part)
            byte dummy = rs.i.readByte();
            if(dummy != 0x11) throw new RuntimeException("Expected 0x11");
            Misc.receiveStringWithLen(rs.i); // unused string, but must be received
            /////////////////////////////////////////////////////////////////

            // response body (a.k.a. download link) size
            size = Misc.receiveTotalOrProgress(rs.i);
            if(size > 4096) throw new RuntimeException("Too large content size for generated link: "+size);
            byte[] b = new byte[(int)size];
            rs.i.readFully(b);
            return new String(b, StandardCharsets.UTF_8);
        }
        finally {
            rs.close();
        }
    }

    public ssh_keygen_resp generateSSHKeyPair(SshKeyType type, int keySize) {
        try (StreamsPair rs = getStreams()) {
            openssl_rsa_pem_keygen_rq rq;
            switch(type) {
                case RSA:
                    rq = new openssl_rsa_pem_keygen_rq(keySize);
                    break;
                case ED25519:
                    rq = new openssh_ed25519_keygen_rq();
                    break;
                default:
                    return null;
            }

            rq.write(rs.o);
            if(Misc.receiveBaseResponse(rs.i) != 0) return null;
            return new ssh_keygen_resp(rs.i);
        }
        catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    public InputStream getInputStream(String srcPath) throws IOException {
        return new RHInputStream(srcPath);
    }

    public OutputStream getOutputStream(String destPath) throws IOException {
        return new RHOutputStream(destPath);
    }

    // ByteArrayOutputStream to buffer and defer bigger write chunks internally, otherwise IO will be very slow if there are a lot of small writes

    public class RHInputStream extends InputStream {
        private final StreamsPair rs;
        public RHInputStream(String srcPath) throws IOException {
            rs = getStreams();

            // open target filepath
            fileio_rq rq = new fileio_rq(srcPath, FileIOMode.READFROMFILE);
            rq.write(rs.o);

            int ret = Misc.receiveBaseResponse(rs.i);
            if (ret != 0) {
                rs.close();
                throw new IOException("File read error");
            }
        }

        @Override
        public int read(@NonNull byte[] b) throws IOException {
            return rs.i.read(b);
        }

        @Override
        public int read() throws IOException {
            return rs.i.read();
        }

        @Override
        public void close() {
            try {rs.close();}
            catch (Exception ignored) {}
        }
    }

    public class RHOutputStream extends OutputStream {
        private final StreamsPair rs;
        private final ByteArrayOutputStream baos = new ByteArrayOutputStream(1048576);
        public RHOutputStream(String destPath) throws IOException {
            rs = getStreams();

            // open target filepath
            fileio_rq rq = new fileio_rq(destPath, FileIOMode.WRITETOFILE);
            rq.write(rs.o);

            int ret = Misc.receiveBaseResponse(rs.i);
            if (ret != 0) {
                rs.close();
                throw new IOException("File creation error");
            }

        }

        private void resetOnOverflow() throws IOException {
            if (baos.size() >= 1048576) {
                rs.o.write(baos.toByteArray());
                baos.reset();
            }
        }

        @Override
        public void write(@NonNull byte[] b) throws IOException {
            resetOnOverflow();
            baos.write(b);
        }

        @Override
        public void write(int i) throws IOException {
            resetOnOverflow();
            baos.write(i);
        }

        @Override
        public void write(@NonNull byte[] b, int off, int len) throws IOException {
            resetOnOverflow();
            baos.write(b,off,len);
        }

        @Override
        public void close() throws IOException {
            if (rs!=null) rs.o.write(baos.toByteArray());
            if (rs!=null) rs.close();
            baos.reset();
        }
    }

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/StreamCiphers.java`:

```java
package it.pgp.xfiles.roothelperclient;

public enum StreamCiphers {
    CHACHA,
    AES128CTR,
    AES256CTR,
    SHACAL2CTR;

    public String toString() {
        switch(this) {
            case CHACHA:
                return "ChaCha";
            case AES128CTR:
                return "AES-128/CTR";
            case AES256CTR:
                return "AES-256/CTR";
            case SHACAL2CTR:
                return "SHACAL2/CTR";
            default:
                return null;
        }
    }
}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/BaseRHRequest.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;

import it.pgp.xfiles.roothelperclient.ControlCodes;

public abstract class BaseRHRequest {

    static final Charset UTF8 = StandardCharsets.UTF_8;

    public final ControlCodes requestType;

    public BaseRHRequest(ControlCodes requestType) {
        this.requestType = requestType;
    }

    public byte getRequestByteWithFlags() {
        return requestType.getValue();
    }

    public abstract void write(OutputStream outputStream) throws IOException;

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/ListOfPathPairs_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.Iterator;
import java.util.List;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 19/07/17
 * One single request for copying/moving/uploading/downloading a selection of files
 */

public class ListOfPathPairs_rq extends BaseRHRequest {

    public List<String> v_fx,v_fy; // pathnames

    // Request type to be set by inheritors
    public ListOfPathPairs_rq(ControlCodes requestType, List<String> v_fx, List<String> v_fy) {
        super(requestType);
        this.v_fx = v_fx;
        this.v_fy = v_fy;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        final byte[] listEnd = new byte[]{0,0,0,0};
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            // write control byte
            nbf.write(requestType.getValue());

            Iterator<String> fxi = v_fx.iterator();
            Iterator<String> fyi = v_fy.iterator();

            while(fxi.hasNext()) {
                byte[] x = fxi.next().getBytes(UTF8);
                byte[] y = fyi.next().getBytes(UTF8);

                // write pair of lengths
                byte[] tmpx,tmpy;
                tmpx = Misc.castUnsignedNumberToBytes(x.length,2);
                tmpy = Misc.castUnsignedNumberToBytes(y.length,2);
                ByteBuffer b = ByteBuffer.allocate(4).order(ByteOrder.nativeOrder()); // change here if length decode error or swapped lengths
                b.put(tmpx);
                b.put(tmpy);
                nbf.write(b.array());

                // write pair of paths
                nbf.write(x);
                nbf.write(y);
            }

            nbf.write(listEnd);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/PairOfPaths_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 25/01/17
 */

public abstract class PairOfPaths_rq extends BaseRHRequest {

    public int lx,ly; // lengths
    public byte[] fx,fy; // pathnames

    // Request type to be set by inheritors
    public PairOfPaths_rq(ControlCodes requestType, Object fx, Object fy) {
        super(requestType);
        if (fx instanceof byte[] && fy instanceof byte[]) {
            this.fx = (byte[]) fx;
            this.lx = this.fx.length;
            this.fy = (byte[]) fy;
            this.ly = this.fy.length;
        }
        else if (fx instanceof String && fy instanceof String) {
            // UTF-8 String
            this.fx = ((String) fx).getBytes(UTF8);
            this.lx = this.fx.length;
            this.fy = ((String) fy).getBytes(UTF8);
            this.ly = this.fy.length;
        }
        else {
            throw new RuntimeException("Unexpected object type(s) in request constructor, allowed bytes and string");
        }
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            // write control byte
            nbf.write(getRequestByteWithFlags());
            // write lengths and fields
            nbf.write(Misc.castUnsignedNumberToBytes(lx,2));
            nbf.write(Misc.castUnsignedNumberToBytes(ly,2));
            nbf.write(fx);
            nbf.write(fy);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/SinglePath_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 25/01/17
 */

public abstract class SinglePath_rq extends BaseRHRequest {

    public int pathname_len;
    public byte[] pathname;

    // overriden for customizing with flag bits
    public byte getRequestByteWithFlags() {
        return requestType.getValue();
    }

    // Request type to be set by inheritors
    public SinglePath_rq(ControlCodes requestType, Object pathname) {
        super(requestType);
        if (pathname instanceof byte[]) {
            this.pathname = (byte[]) pathname;
            this.pathname_len = this.pathname.length;
        }
        else if (pathname instanceof String) {
            // UTF-8 String
            this.pathname = ((String) pathname).getBytes(UTF8);
            this.pathname_len = this.pathname.length;
        }
        else throw new RuntimeException("Unexpected object type in request constructor, allowed bytes and string");
    }

    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            // write request byte
            nbf.write(getRequestByteWithFlags());
            // write len and field
            nbf.write(Misc.castUnsignedNumberToBytes(this.pathname_len,2));
            nbf.write(this.pathname);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/compress_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import android.support.annotation.Nullable;

import java.io.IOException;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.List;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 30/05/17
 */

public class compress_rq extends PairOfPaths_rq {

    List<byte[]> filenames;
    byte[] password;
    compress_rq_options compress_options;

    // at least source folder and destination archive
    public compress_rq(Object fx, Object fy,
                       @Nullable Integer compressionLevel,
                       @Nullable Boolean encryptHeaders,
                       @Nullable Boolean solidMode,
                       @Nullable String password,
                       @Nullable List<String> filenames) {
        super(ControlCodes.ACTION_COMPRESS, fx, fy);
        compress_options = new compress_rq_options(compressionLevel,encryptHeaders,solidMode);

        if (password == null) this.password = new byte[0];
        else this.password = password.getBytes();
        if (filenames == null) return;
        this.filenames = new ArrayList<>();
        for (String x : filenames) {
            this.filenames.add(x.getBytes(UTF8));
        }
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        super.write(outputStream);
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            compress_options.writecompress_rq_options(nbf);

            nbf.write(password.length); // single byte (8 least significant bits of the 32-bit integer)
            if (password.length != 0)
                nbf.write(password);

            if (filenames == null) { // filenames not initialized, compress entire source directory content
                nbf.write(new byte[]{0,0,0,0}); // n. of filenames is 0
            }
            else {
                // send n. of filenames
                nbf.write(Misc.castUnsignedNumberToBytes(filenames.size(),4)); // send as 4-byte integer
                for (byte[] x : filenames) {
                    nbf.write(Misc.castUnsignedNumberToBytes(x.length,2));
                    nbf.write(x);
                }
            }
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/compress_rq_options.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

/**
 * Created by pgp on 28/06/17
 * to be sent embedded from within compress_rq
 */

public class compress_rq_options {
    private byte compressionLevel;
    private byte encryptHeader;
    private byte solid;

//    public compress_rq_options(byte compressionLevel, byte encryptHeader, byte solid)  {
//        this.compressionLevel = compressionLevel;
//        this.encryptHeader = encryptHeader;
//        this.solid = solid;
//    }

    public compress_rq_options(Integer compressionLevel, Boolean encryptHeaders, Boolean solidMode)  {
        this.compressionLevel = compressionLevel==null?(byte)9:(byte)compressionLevel.intValue(); // max compression by default
        this.encryptHeader = (encryptHeaders==null|| !encryptHeaders)?(byte)0:(byte)1; // do not encrypt headers by default
        this.solid = (solidMode==null|| solidMode)?(byte)1:(byte)0; // solid by default
    }

    public void writecompress_rq_options(OutputStream outputStream) throws IOException {
        byte[] tmp;
        tmp = new byte[]{compressionLevel};
        outputStream.write(tmp);
        tmp = new byte[]{encryptHeader};
        outputStream.write(tmp);
        tmp = new byte[]{solid};
        outputStream.write(tmp);
    }
}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/copylist_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.util.List;

import it.pgp.xfiles.roothelperclient.ControlCodes;

/**
 * Created by pgp on 19/07/17
 */

public class copylist_rq extends ListOfPathPairs_rq {
    public copylist_rq(List<String> v_fx, List<String> v_fy) {
        super(ControlCodes.ACTION_COPY, v_fx, v_fy);
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/create_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 31/01/17
 */

public class create_rq extends SinglePath_rq {
    final FileMode fileMode;
    final FileCreationAdvancedOptions fileOptions;

    public create_rq(Object pathname, FileMode fileMode) {
        super(ControlCodes.ACTION_CREATE, pathname);
        this.fileMode = fileMode;
        this.fileOptions = null;
    }

    // only for file creation requests
    public create_rq(Object pathname, FileCreationAdvancedOptions fileOptions) {
        super(ControlCodes.ACTION_CREATE, pathname);
        this.fileMode = FileMode.FILE;
        this.fileOptions = fileOptions;
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        // customize with flag bits
        rq ^= ((fileMode == FileMode.FILE ?1:0) << (ControlCodes.rq_bit_length));
        if (fileOptions != null && fileMode == FileMode.FILE)
            rq ^= (2 << ControlCodes.rq_bit_length);
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            // write request byte
            nbf.write(getRequestByteWithFlags());
            // write len and field
            nbf.write(Misc.castUnsignedNumberToBytes(this.pathname_len,2));
            nbf.write(this.pathname);
            // write mode
            nbf.write(Misc.castUnsignedNumberToBytes(fileMode.getDefaultMask(),4));
            if(fileOptions != null) nbf.write(fileOptions.toRootHelperRequestOptions());
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/del_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import it.pgp.xfiles.roothelperclient.ControlCodes;

/**
 * Created by pgp on 25/01/17
 */

public class del_rq extends SinglePath_rq {
    public del_rq(Object pathname) {
        super(ControlCodes.ACTION_DELETE, pathname);
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/exists_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;
import java.util.BitSet;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 31/01/17
 */

public class exists_rq extends SinglePath_rq {
    public BitSet flags;
    public exists_rq(Object pathname, boolean exists, boolean isFile, boolean isDir) {
        super(ControlCodes.ACTION_EXISTS, pathname);
        flags = new BitSet(3);
        flags.set(0,exists);
        flags.set(1,isFile);
        flags.set(2,isDir);
    }

    @Override
    public byte getRequestByteWithFlags() {
        // write request byte
        byte rq = requestType.getValue();
        // customize with flag bits
        for (int i=0;i<ControlCodes.flags_bit_length;i++) {
            rq ^= ((flags.get(i)?1:0) << (i+ControlCodes.rq_bit_length));
        }
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            nbf.write(getRequestByteWithFlags());
            // write len and field
            nbf.write(Misc.castUnsignedNumberToBytes(this.pathname_len,2));
            nbf.write(this.pathname);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/extract_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import android.support.annotation.Nullable;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.roothelperclient.RelativeExtractEntries;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 01/06/17
 */

public class extract_rq extends PairOfPaths_rq {

    public byte[] password;
    public byte[] subDir;
    public RelativeExtractEntries entries;
    public boolean smartDirectoryCreation;

    public extract_rq(Object fx, Object fy, // source archive and destination directory (both LocalPathContent)
                      @Nullable Object password, // password will be used if present to try to open archive
                      @Nullable Object subDir, // subDir prefix will be removed by entries path when extracting
                      @Nullable RelativeExtractEntries entries, // for selective extraction
                      boolean smartDirectoryCreation // valid only if entries is null
                      ) {
        super(ControlCodes.ACTION_EXTRACT, fx, fy);
        this.smartDirectoryCreation = smartDirectoryCreation;
        if (password != null)
            this.password = (password instanceof String)?((String) password).getBytes():(byte[])password;
        if (subDir != null)
            this.subDir = (subDir instanceof String)?((String) subDir).getBytes():(byte[])subDir;
        this.entries = entries;
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        rq ^= ((smartDirectoryCreation?6:7) << ControlCodes.rq_bit_length); // 110 vs 111 flags
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        super.write(outputStream);
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            if (password == null) {
                nbf.write(new byte[]{0}); // password length 0, 1 byte
            }
            else {
                nbf.write(Misc.castUnsignedNumberToBytes(password.length,1));
                nbf.write(password);
            }
            if (entries == null) {
                nbf.write(new byte[]{0,0,0,0}); // 0-length as integer, 4 byte
            }
            else {
                nbf.write(Misc.castUnsignedNumberToBytes(entries.entries.size(),4));
                for (Integer entry : entries.entries)
                    nbf.write(Misc.castUnsignedNumberToBytes(entry,4));
                nbf.write(Misc.castUnsignedNumberToBytes(entries.stripPathLen,4));
            }
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/fileio_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.enums.FileIOMode;
import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 06/11/17
 */

public class fileio_rq extends SinglePath_rq {
    FileIOMode mode;

    public fileio_rq(Object pathname, FileIOMode mode) {
        super(ControlCodes.ACTION_FILEIO, pathname);
        this.mode = mode;
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        // customize with flag bits (only one bit)
        rq ^= ((mode == FileIOMode.READFROMFILE?1:0) << (ControlCodes.rq_bit_length));
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            nbf.write(getRequestByteWithFlags());
            // write len and field
            nbf.write(Misc.castUnsignedNumberToBytes(this.pathname_len,2));
            nbf.write(this.pathname);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/find_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import android.support.annotation.Nullable;

import java.io.IOException;
import java.io.OutputStream;
import java.util.List;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

public class find_rq extends BaseRHRequest {

    public List<String> basepaths; // where to search into
    @Nullable private byte[] contentPattern;
    @Nullable private byte[] filenamePattern;
    private SearchBits searchBits;
    private FlagBits flagBits;

    // to be XORed over request byte
    public static class FlagBits {
        boolean cancelCurrentSearch = false;
        boolean searchOnlyCurrentFolder = false; // false means recurse search in subfolders
        boolean searchInArchives = false;

        public FlagBits(boolean cancelCurrentSearch, boolean searchOnlyCurrentFolder, boolean searchInArchives) {
            this.cancelCurrentSearch = cancelCurrentSearch;
            this.searchOnlyCurrentFolder = searchOnlyCurrentFolder;
            this.searchInArchives = searchInArchives;
        }

        // cancel search
        public FlagBits() {
            cancelCurrentSearch = true;
        }

        public FlagBits(boolean searchOnlyCurrentFolder) {
            this.searchOnlyCurrentFolder = searchOnlyCurrentFolder;
        }

        public byte getFlagBits() {
            byte bits = 0;
            if (cancelCurrentSearch) return 1;
            if (searchOnlyCurrentFolder) bits |= 2;
            if (searchInArchives) bits |= 4;
            return bits;
        }
    }

    public static class SearchBits {
        public SearchBits(boolean filenameRegex,
                          boolean filenameEscapes,
                          boolean filenameCaseInsensitive,
                          boolean filenameWholeWord,
                          boolean contentRegex,
                          boolean contentEscapes,
                          boolean contentCaseInsensitive,
                          boolean contentWholeWord,
                          boolean findAllContentOccurrences) {
            this.filenameRegex = filenameRegex;
            this.filenameEscapes = filenameEscapes;
            this.filenameCaseInsensitive = filenameCaseInsensitive;
            this.filenameWholeWord = filenameWholeWord;
            this.contentRegex = contentRegex;
            this.contentEscapes = contentEscapes;
            this.contentCaseInsensitive = contentCaseInsensitive;
            this.contentWholeWord = contentWholeWord;
            this.findAllContentOccurrences = findAllContentOccurrences;
        }

        boolean filenameRegex,filenameEscapes,filenameWholeWord,filenameCaseInsensitive;
        boolean contentRegex,contentEscapes,contentWholeWord,contentCaseInsensitive;
        boolean findAllContentOccurrences;

        byte[] getSearchBits() {
            byte[] searchBits = new byte[2];

            searchBits[0] |= filenameRegex ? 1 : 0;
            searchBits[0] |= (filenameEscapes ? 1 : 0) << 1;
            searchBits[0] |= (filenameCaseInsensitive ? 1 : 0) << 2;
            searchBits[0] |= (filenameWholeWord ? 1 : 0) << 3;

            searchBits[0] |= (contentRegex ? 1 : 0)<<4;
            searchBits[0] |= (contentEscapes ? 1 : 0) << 5;
            searchBits[0] |= (contentCaseInsensitive ? 1 : 0) << 6;
            searchBits[0] |= (contentWholeWord ? 1 : 0) << 7;

            searchBits[1] |= findAllContentOccurrences ? 1 : 0;

            return searchBits;
        }
    }

    public find_rq(
            List<String> basepaths,
            @Nullable byte[] filenamePattern,
            @Nullable byte[] contentPattern,
            FlagBits flagBits,
            SearchBits searchBits) {
        super(ControlCodes.ACTION_FIND);
        this.basepaths = basepaths;
        this.filenamePattern = filenamePattern==null?new byte[0]:filenamePattern;
        this.contentPattern = contentPattern==null?new byte[0]:contentPattern;
        this.searchBits = searchBits;
        this.flagBits = flagBits;
    }

    // cancel search
    public find_rq() {
        super(ControlCodes.ACTION_FIND);
        flagBits = new FlagBits();
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        rq ^= (flagBits.getFlagBits() << (ControlCodes.rq_bit_length));
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            nbf.write(getRequestByteWithFlags());
            if (flagBits.cancelCurrentSearch) return;

            nbf.write(searchBits.getSearchBits());

            for(String basepath : basepaths) {
                byte[] bp = basepath.getBytes();
                nbf.write(Misc.castUnsignedNumberToBytes(bp.length,2));
                nbf.write(bp);
            }
            nbf.write(Misc.EOL);

            nbf.write(Misc.castUnsignedNumberToBytes(filenamePattern.length,2));
            if (filenamePattern.length!=0) nbf.write(filenamePattern);

            nbf.write(Misc.castUnsignedNumberToBytes(contentPattern.length,2));
            if (contentPattern.length!=0) nbf.write(contentPattern);
        }
    }
}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/hash_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;
import java.util.BitSet;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 03/02/17
 */

public class hash_rq extends SinglePath_rq {
    HashRequestCodes hashAlgorithm;
    BitSet dirHashOpts;

    /**
     * Dir hash opts:
     * 0: dirHashWithNames, // keep into account filenames in directory hashing
     * 1: dirHashIgnoreThumbsFiles, // ignore .DS_Store and Thumbs.db
     * 2: dirHashIgnoreUnixHiddenFiles, // ignore files and folders whose names start with '.'
     * 3: dirHashIgnoreEmptyDirs
     */

    public hash_rq(Object pathname,
                   HashRequestCodes hashAlgorithm,
                   BitSet dirHashOpts) {
        super(ControlCodes.ACTION_HASH, pathname);
        this.hashAlgorithm = hashAlgorithm;
        this.dirHashOpts = dirHashOpts;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            // write request byte
            nbf.write(requestType.getValue());
            // write algorithm byte
            nbf.write(hashAlgorithm.getValue());

            // write dirHashOpts
            byte dirHashOpts_ = 0;
            // customize with flag bits
            for (int i=0;i<ControlCodes.flags_bit_length;i++)
                dirHashOpts_ ^= ((dirHashOpts.get(i)?1:0) << i);
            nbf.write(dirHashOpts_);

            // write len and field (digest output length is implicit)
            nbf.write(Misc.castUnsignedNumberToBytes(this.pathname_len,2));
            nbf.write(this.pathname);
        }
    }

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/link_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

public class link_rq extends PairOfPaths_rq {

    boolean isHardLink;

    public link_rq(Object fx, Object fy, boolean isHardLink) {
        super(ControlCodes.ACTION_LINK, fx, fy);
        this.isHardLink = isHardLink;
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        // customize with flag bits
        rq ^= ((isHardLink?2:0) << (ControlCodes.rq_bit_length));
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            nbf.write(getRequestByteWithFlags());
            // write lengths and fields
            nbf.write(Misc.castUnsignedNumberToBytes(lx,2));
            nbf.write(Misc.castUnsignedNumberToBytes(ly,2));
            nbf.write(fx);
            nbf.write(fy);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/ls_archive_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 22/05/17
 */
public class ls_archive_rq extends SinglePath_rq {
    public int password_len;
    public byte[] password;
    public byte flags = 0x07; // 0x07 = {1,1,1} (bitmask)

    // Object: String or byte[]
    public ls_archive_rq(Object archivePath, Object password) {
        super(ControlCodes.ACTION_LS, archivePath);
        if (password instanceof String) {
            this.password = ((String) password).getBytes();
            this.password_len = this.password.length;
        }
        else if (password instanceof byte[]) {
            this.password = (byte[]) password;
            this.password_len = (byte) this.password.length;
        }
        else {
            throw new RuntimeException("Unexpected password object type");
        }
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        rq ^= (flags << ControlCodes.rq_bit_length);
        return rq;
    }

    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            nbf.write(getRequestByteWithFlags());
            nbf.write(Misc.castUnsignedNumberToBytes(this.pathname_len,2));
            nbf.write(this.pathname);
            nbf.write(Misc.castUnsignedNumberToBytes(this.password_len,1));
            nbf.write(this.password);
        }
    }
}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/ls_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import it.pgp.xfiles.roothelperclient.ControlCodes;

public class ls_rq extends SinglePath_rq {

    public ls_rq(Object dirPath)  {
        super(ControlCodes.ACTION_LS, dirPath);
    }
}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/movelist_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.util.List;

import it.pgp.xfiles.roothelperclient.ControlCodes;

/**
 * Created by pgp on 19/07/17
 */

public class movelist_rq extends ListOfPathPairs_rq {

    public movelist_rq(List<String> v_fx, List<String> v_fy) {
        super(ControlCodes.ACTION_MOVE, v_fx, v_fy);
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/multiStats_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;
import java.util.BitSet;
import java.util.List;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 06/02/17
 */

public class multiStats_rq extends BaseRHRequest {

    public List<String> pathnames;
    protected final BitSet flags = BitSet.valueOf(new long[]{4});

    // Request type to be set by inheritors
    public multiStats_rq(List<String> pathnames) {
        super(ControlCodes.ACTION_STATS);
        this.pathnames = pathnames;
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        // customize with flag bits
        for (int i=0;i<ControlCodes.flags_bit_length;i++) {
            rq ^= ((flags.get(i)?1:0) << (i+ControlCodes.rq_bit_length));
        }
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            byte[] entry,entryLen;
            nbf.write(getRequestByteWithFlags());

            for (String pathname : pathnames) {
                // write len and field
                entry = pathname.getBytes(UTF8);
                entryLen = Misc.castUnsignedNumberToBytes(entry.length,2);
                nbf.write(entryLen);
                nbf.write(entry);
            }
            // list termination (length 0)
            nbf.write(new byte[2]);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/multi_extract_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import android.support.annotation.Nullable;

import java.io.IOException;
import java.io.OutputStream;
import java.util.List;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class multi_extract_rq extends BaseRHRequest {

    public final boolean smartDirectoryCreation;
    private final List<BasePathContent> fx;
    private final String fy;
    public byte[] password;

    public multi_extract_rq(List<BasePathContent> fx, String fy,
                            @Nullable Object password,
                            boolean smartDirectoryCreation) {
        super(ControlCodes.ACTION_EXTRACT);
        this.fx = fx;
        this.fy = fy;
        this.smartDirectoryCreation = smartDirectoryCreation;
        if (password != null)
            this.password = (password instanceof String)?((String) password).getBytes():(byte[])password;
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        rq ^= ((smartDirectoryCreation?2:3) << ControlCodes.rq_bit_length); // 010 vs 011 flags
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        byte[] b;
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            // send control byte
            nbf.write(getRequestByteWithFlags());

            // send source archives list and destination directory
            for(BasePathContent s : fx) {
                b = s.dir.getBytes(UTF8);
                nbf.write(Misc.castUnsignedNumberToBytes(b.length,2));
                nbf.write(b);
            }
            nbf.write(Misc.EOL);

            b = fy.getBytes(UTF8);
            nbf.write(Misc.castUnsignedNumberToBytes(b.length,2));
            nbf.write(b);

            if (password == null) {
                nbf.write(new byte[]{0}); // password length 0, 1 byte
            }
            else {
                nbf.write(Misc.castUnsignedNumberToBytes(password.length,1));
                nbf.write(password);
            }
            nbf.write(new byte[]{0,0,0,0}); // 0-length as integer, 4 byte
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/openssh_ed25519_keygen_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

public class openssh_ed25519_keygen_rq extends openssl_rsa_pem_keygen_rq {
    public openssh_ed25519_keygen_rq() {
        super(-1); // keysize argument unused
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        rq ^= (1 << 5); // flags: 001
        return rq;
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/openssl_rsa_pem_keygen_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 09/12/17
 * Only RSA key pair generation, for adding other formats (once SSHJ will support them)
 * add flag bits to requestType
 */

public class openssl_rsa_pem_keygen_rq extends BaseRHRequest {
    public final int keySize;

    public openssl_rsa_pem_keygen_rq(int keySize) {
        super(ControlCodes.ACTION_SSH_KEYGEN); // flags: 000
        this.keySize = keySize;
    }

    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            nbf.write(getRequestByteWithFlags());
            if(keySize > 0) nbf.write(Misc.castUnsignedNumberToBytes(keySize,4));
        }
    }
}


```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/retrieveHomePath_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import it.pgp.xfiles.roothelperclient.ControlCodes;

public class retrieveHomePath_rq extends ls_rq {

    public final byte flags = 0x02; // 0x02 = {0,1,0} (bitmask)

    public retrieveHomePath_rq(Object dirPath) {
        super(dirPath);
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        rq ^= (flags << ControlCodes.rq_bit_length);
        return rq;
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/setAttributes_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import it.pgp.xfiles.roothelperclient.ControlCodes;

/**
 * Created by pgp on 22/11/17
 */

public abstract class setAttributes_rq extends SinglePath_rq {

    public static final int bitOffsetForSubrequest = 6;

    public enum SubRequest {
        SET_DATES,
        SET_OWNERSHIP,
        SET_PERMISSIONS
    }

    public int additionalByte = 0;

    public setAttributes_rq(Object pathname) {
        super(ControlCodes.ACTION_SETATTRIBUTES, pathname);
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/setDates_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import android.support.annotation.Nullable;

import java.io.IOException;
import java.io.OutputStream;
import java.util.Date;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 22/11/17
 */

public class setDates_rq extends setAttributes_rq {

    @Nullable Integer accessDateSeconds;
    @Nullable Integer modificationDateSeconds;

    public setDates_rq(Object pathname, @Nullable Date accessDate, @Nullable Date modificationDate) {
        super(pathname);
        if (accessDate != null) accessDateSeconds = (int)(accessDate.getTime()/1000);
        if (modificationDate != null) modificationDateSeconds = (int)(modificationDate.getTime()/1000);
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            additionalByte = ((accessDateSeconds==null)?0:1) + ((modificationDateSeconds==null)?0:2);
            additionalByte += (SubRequest.SET_DATES.ordinal() << setAttributes_rq.bitOffsetForSubrequest);

            // write request byte
            nbf.write(requestType.getValue());

            // write additional byte
            nbf.write(additionalByte); // writes only LSB 8 bits of integer, as expected

            // write len and filename
            nbf.write(Misc.castUnsignedNumberToBytes(this.pathname_len,2));
            nbf.write(this.pathname);

            // write timestamps
            if (accessDateSeconds != null) {
                nbf.write(Misc.castUnsignedNumberToBytes(accessDateSeconds,4));
            }
            if (modificationDateSeconds != null) {
                nbf.write(Misc.castUnsignedNumberToBytes(modificationDateSeconds,4));
            }
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/setOwnership_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import android.support.annotation.Nullable;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 22/11/17
 */

public class setOwnership_rq extends setAttributes_rq {
    @Nullable Integer ownerId;
    @Nullable Integer groupId;

    public setOwnership_rq(Object pathname, @Nullable Integer ownerId, @Nullable Integer groupId) {
        super(pathname);
        this.ownerId = ownerId;
        this.groupId = groupId;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            additionalByte = ((ownerId==null)?0:1) + ((groupId==null)?0:2);
            additionalByte += (SubRequest.SET_OWNERSHIP.ordinal() << setAttributes_rq.bitOffsetForSubrequest);

            // write request byte
            nbf.write(requestType.getValue());

            // write additional byte
            nbf.write(additionalByte); // writes only LSB 8 bits of integer, as expected

            // write len and filename
            nbf.write(Misc.castUnsignedNumberToBytes(pathname_len,2));
            nbf.write(pathname);

            // write ownerships
            if (ownerId != null)
                nbf.write(Misc.castUnsignedNumberToBytes(ownerId,4));
            if (groupId != null)
                nbf.write(Misc.castUnsignedNumberToBytes(groupId,4));
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/setPermission_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;

import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 22/11/17
 */

public class setPermission_rq extends setAttributes_rq {
    int permissions;

    public setPermission_rq(Object pathname, int permissions) {
        super(pathname);
        this.permissions = permissions;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            additionalByte = SubRequest.SET_PERMISSIONS.ordinal() << setAttributes_rq.bitOffsetForSubrequest;

            // write request byte
            nbf.write(requestType.getValue());

            // write additional byte
            nbf.write(additionalByte); // writes only LSB 8 bits of integer, as expected

            // write len and filename
            nbf.write(Misc.castUnsignedNumberToBytes(pathname_len,2));
            nbf.write(pathname);

            // write permission
            nbf.write(Misc.castUnsignedNumberToBytes(permissions,4));
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/singleStats_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import java.io.IOException;
import java.io.OutputStream;
import java.util.BitSet;

import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.io.FlushingBufferedOutputStream;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 06/02/17
 */

public class singleStats_rq extends SinglePath_rq {
    private BitSet flags; // file/folder/multi
    public singleStats_rq(Object pathname, FileMode fileMode) {
        super(ControlCodes.ACTION_STATS, pathname);
        this.flags = (fileMode==FileMode.FILE ?BitSet.valueOf(new long[]{1}):BitSet.valueOf(new long[]{2})); // 0,0,1 --- 0,1,0
    }

    @Override
    public byte getRequestByteWithFlags() {
        byte rq = requestType.getValue();
        // customize with flag bits
        for (int i=0;i<ControlCodes.flags_bit_length;i++) {
            rq ^= ((flags.get(i)?1:0) << (i+ControlCodes.rq_bit_length));
        }
        return rq;
    }

    @Override
    public void write(OutputStream outputStream) throws IOException {
        try(FlushingBufferedOutputStream nbf = new FlushingBufferedOutputStream(outputStream)) {
            nbf.write(getRequestByteWithFlags());
            // write len and field
            nbf.write(Misc.castUnsignedNumberToBytes(pathname_len,2));
            nbf.write(pathname);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/reqs/test_rq.java`:

```java
package it.pgp.xfiles.roothelperclient.reqs;

import android.support.annotation.Nullable;

import it.pgp.xfiles.roothelperclient.RelativeExtractEntries;

public class test_rq extends extract_rq {
    public test_rq(Object fx, @Nullable Object password, @Nullable RelativeExtractEntries entries) {
        super(fx, "", password, null, entries, false);
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/resps/exists_resp.java`:

```java
package it.pgp.xfiles.roothelperclient.resps;

import java.io.DataInputStream;
import java.io.IOException;
import java.util.BitSet;

/**
 * Created by pgp on 31/01/17
 */

public class exists_resp {
    public byte response;
    public BitSet respFlags;
    public exists_resp(DataInputStream inputStream) throws IOException {
        response = inputStream.readByte();
        if (response == 0) { // unconditionally 0x00 (OK) for this kind of requests
            respFlags = BitSet.valueOf(new byte[]{inputStream.readByte()});
        }
        else throw new RuntimeException("Wrong response byte on exist query, should never happen");
    }
    public boolean getExists() {
        return respFlags.get(0);
    }

    public boolean getIsFile() {
        return respFlags.get(1);
    }

    public boolean getIsDir() {
        return respFlags.get(2);
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/resps/find_resp.java`:

```java
package it.pgp.xfiles.roothelperclient.resps;

import java.io.DataInputStream;
import java.io.IOException;

import it.pgp.xfiles.utils.Misc;

public class find_resp {

    public ls_resp fileItem;
    public byte[] contentAround; // not null only in non-trivial find in content
    public long offset;

    private find_resp() {}

    public static find_resp readNext(DataInputStream inputStream) throws IOException {
        find_resp resp = new find_resp();
        resp.fileItem = ls_resp.readNext(inputStream);
        if(resp.fileItem == null) return null; // end of list indication

        byte[] tmp = new byte[1];
        inputStream.readFully(tmp);
        int contentAround_len = (int) Misc.castBytesToUnsignedNumber(tmp,1);

        if (contentAround_len != 0) {
            resp.contentAround = new byte[contentAround_len];
            inputStream.readFully(resp.contentAround);
            tmp = new byte[8];
            inputStream.readFully(tmp);
            resp.offset = Misc.castBytesToUnsignedNumber(tmp,8);
        }

        return resp;
    }

    @Override
    public String toString() {
        return new String(fileItem.filename);
    }
}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/resps/folderStats_resp.java`:

```java
package it.pgp.xfiles.roothelperclient.resps;

import java.io.DataInputStream;
import java.io.IOException;
import java.io.OutputStream;

public class folderStats_resp {

    public long childrenDirs;
    public long childrenFiles;
    public long totalDirs;
    public long totalFiles;
    public long totalSize;

    public static long castBytesToUnsignedNumber(byte[] b) {
        if (b.length > 8)
            throw new RuntimeException("Max byte array size is 8 (long type), found array length greater!");
        long value = 0;
        int cut = b.length;
        for (int i = cut-1; i >= 0; i--) // replace with decrement for for little endianness compliance
            value = (value << 8) + (b[i] & 0xFF);
        return value;
    }

    public static byte[] castUnsignedNumberToBytes(long l, Integer cut_) {
        byte[] o = (cut_ == null)?new byte[8]:new byte[cut_];
        long mask = 0xFF;
        for (int i=0;i<cut_;i++) {
            o[i] = (byte) (l & mask);
            l >>= 8;
        }
        return o;
    }
    public folderStats_resp(DataInputStream inputStream) throws IOException {
        byte[] tmp;
        tmp = new byte[8];
        inputStream.readFully(tmp);
        this.childrenDirs = castBytesToUnsignedNumber(tmp);
        tmp = new byte[8];
        inputStream.readFully(tmp);
        this.childrenFiles = castBytesToUnsignedNumber(tmp);
        tmp = new byte[8];
        inputStream.readFully(tmp);
        this.totalDirs = castBytesToUnsignedNumber(tmp);
        tmp = new byte[8];
        inputStream.readFully(tmp);
        this.totalFiles = castBytesToUnsignedNumber(tmp);
        tmp = new byte[8];
        inputStream.readFully(tmp);
        this.totalSize = castBytesToUnsignedNumber(tmp);
    }

    public folderStats_resp() {}

    public folderStats_resp(long childrenDirs, long childrenFiles, long totalDirs, long totalFiles, long totalSize)  {
        this.childrenDirs = childrenDirs;
        this.childrenFiles = childrenFiles;
        this.totalDirs = totalDirs;
        this.totalFiles = totalFiles;
        this.totalSize = totalSize;
    }

    public void writefolderStats_resp(OutputStream outputStream) throws IOException {
        byte[] tmp;tmp = castUnsignedNumberToBytes(this.childrenDirs,8);
        outputStream.write(tmp);
        tmp = castUnsignedNumberToBytes(this.childrenFiles,8);
        outputStream.write(tmp);
        tmp = castUnsignedNumberToBytes(this.totalDirs,8);
        outputStream.write(tmp);
        tmp = castUnsignedNumberToBytes(this.totalFiles,8);
        outputStream.write(tmp);
        tmp = castUnsignedNumberToBytes(this.totalSize,8);
        outputStream.write(tmp);
    }



}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/resps/ls_resp.java`:

```java
package it.pgp.xfiles.roothelperclient.resps;

import java.io.DataInputStream;
import java.io.IOException;

import it.pgp.xfiles.utils.Misc;

public class ls_resp {
    public byte[] filename;
    public long date;
    public byte[] permissions;
    public long size;

    private ls_resp() {}

    public static ls_resp readNext(DataInputStream inputStream) throws IOException {
        ls_resp resp = new ls_resp();
        byte[] tmp;
        tmp = new byte[2];
        inputStream.readFully(tmp);
        int filename_len = (int) Misc.castBytesToUnsignedNumber(tmp,2);
        if (filename_len == 0) return null; // end of list indication
        resp.filename = new byte[filename_len];
        inputStream.readFully(resp.filename);
        tmp = new byte[4];
        inputStream.readFully(tmp);
        resp.date = Misc.castBytesToUnsignedNumber(tmp,4);
        tmp = new byte[10];
        inputStream.readFully(tmp);
        resp.permissions = tmp;
        tmp = new byte[8];
        inputStream.readFully(tmp);
        resp.size = Misc.castBytesToUnsignedNumber(tmp,8);
        return resp;
    }

}

```

`app/src/main/java/it/pgp/xfiles/roothelperclient/resps/singleStats_resp.java`:

```java
package it.pgp.xfiles.roothelperclient.resps;

import java.io.DataInputStream;
import java.io.IOException;

import it.pgp.xfiles.utils.Misc;

public class singleStats_resp {

    private int group_len;
    public byte[] group;
    private int owner_len;
    public byte[] owner;
    public long creationTime;
    public long lastAccessTime;
    public long modificationTime;
    public byte[] permissions;
    public long size;

    public singleStats_resp(DataInputStream inputStream) throws IOException {
        byte[] tmp;
        tmp = new byte[1];
        inputStream.readFully(tmp);
        this.group_len = (int) Misc.castBytesToUnsignedNumber(tmp,1);
        this.group = new byte[group_len];
        inputStream.readFully(this.group);
        tmp = new byte[1];
        inputStream.readFully(tmp);
        this.owner_len = (int) Misc.castBytesToUnsignedNumber(tmp,1);
        this.owner = new byte[owner_len];
        inputStream.readFully(this.owner);
        tmp = new byte[4];
        inputStream.readFully(tmp);
        this.creationTime = Misc.castBytesToUnsignedNumber(tmp,4);
        tmp = new byte[4];
        inputStream.readFully(tmp);
        this.lastAccessTime = Misc.castBytesToUnsignedNumber(tmp,4);
        tmp = new byte[4];
        inputStream.readFully(tmp);
        this.modificationTime = Misc.castBytesToUnsignedNumber(tmp,4);
        tmp = new byte[10];
        inputStream.readFully(tmp);
        this.permissions = tmp;
        tmp = new byte[8];
        inputStream.readFully(tmp);
        this.size = Misc.castBytesToUnsignedNumber(tmp,8);
    }

    public singleStats_resp(byte[] group, byte[] owner, long creationTime, long lastAccessTime, long modificationTime, byte[] permissions, long size)  {
        this.group_len = group.length;
        this.group = group;
        this.owner_len = owner.length;
        this.owner = owner;
        this.creationTime = creationTime;
        this.lastAccessTime = lastAccessTime;
        this.modificationTime = modificationTime;
        this.permissions = permissions;
        this.size = size;
    }
}
```

`app/src/main/java/it/pgp/xfiles/roothelperclient/resps/ssh_keygen_resp.java`:

```java
package it.pgp.xfiles.roothelperclient.resps;

import java.io.DataInputStream;
import java.io.IOException;

import it.pgp.xfiles.utils.Misc;

/**
 * Created by pgp on 09/12/17
 */

public class ssh_keygen_resp {
    public String privateKey; // private
    public String publicKey; // public

    public ssh_keygen_resp(DataInputStream inputStream) throws IOException {
        // private key
        byte[] b = new byte[4];
        inputStream.readFully(b);
        int len = (int) Misc.castBytesToUnsignedNumber(b,4);
        b = new byte[len];
        inputStream.readFully(b);
        privateKey = new String(b);

        // public key
        b = new byte[4];
        inputStream.readFully(b);
        len = (int) Misc.castBytesToUnsignedNumber(b,4);
        b = new byte[len];
        inputStream.readFully(b);
        publicKey = new String(b);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/BaseBackgroundService.java`:

```java
package it.pgp.xfiles.service;

import android.app.AlertDialog;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.PendingIntent;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Build;
import android.os.IBinder;
import android.os.PowerManager;
import android.support.v4.app.NotificationCompat;
import android.widget.Toast;

import java.io.Serializable;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;
import it.pgp.xfiles.service.visualization.ViewType;

/**
onStartCommand's intent must contain at least:
 FOREGROUND_SERVICE_NOTIFICATION_ID (assigned from corresponding static field of subclasses)
 BROADCAST_ACTION (assigned from subclasses as well)
 sub-class dependent params
 */

public abstract class BaseBackgroundService extends Service {

    public static final String START_ACTION = "Start";
    public static final String PAUSE_ACTION = "Pause"; // pause, on next activity open, show results found so far
    public static final String CANCEL_ACTION = "Cancel"; // cancel, on next activity open, show results found so far
	String currentAction;

	NotificationManager notificationManager;
    PowerManager mgr;
    PowerManager.WakeLock wakeLock;
	
	public BaseBackgroundTask task;
    public Serializable params;

    public static final String BROADCAST_ACTION = "base_service_broadcast_action";

    public String foreground_content_text;
    public String foreground_ticker;
    public String foreground_pause_action_label;
    public String foreground_stop_action_label;

    public static final int pendingIntentFlag = Build.VERSION.SDK_INT >= Build.VERSION_CODES.S ? PendingIntent.FLAG_IMMUTABLE : 0;

    public abstract int getServiceIconRes();

    public abstract int getForegroundServiceNotificationId();

    public abstract ForegroundServiceType getFgServiceType();
	
	@Override
    public IBinder onBind(Intent intent) {
        return null;
    }
	
	private void abortServiceWithConfirmation() {
        AlertDialog.Builder bld = new AlertDialog.Builder(this);
        bld.setTitle("Cancel "+getClass().getName()+"?");
        bld.setNegativeButton(android.R.string.cancel, null);
        bld.setPositiveButton(android.R.string.ok, (dialog, which) -> task.cancelTask());
        AlertDialog alertDialog = bld.create();
        alertDialog.getWindow().setType(ViewType.OVERLAY_WINDOW_TYPE);
        alertDialog.show();
    }
	
	protected abstract void prepareLabels();

    public NotificationCompat.Builder getForegroundNotificationBuilder() {
        Intent notificationIntent = new Intent(this, MainActivity.class);
        notificationIntent.setAction(BROADCAST_ACTION);
        notificationIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                | Intent.FLAG_ACTIVITY_CLEAR_TASK);

        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,
                notificationIntent, pendingIntentFlag);

        Intent pauseIntent = new Intent(this, getClass());
        pauseIntent.setAction(PAUSE_ACTION);
        PendingIntent ppauseIntent = PendingIntent.getService(this, 0,
                pauseIntent, pendingIntentFlag);

        Intent stopIntent = new Intent(this, getClass());
        stopIntent.setAction(CANCEL_ACTION);
        PendingIntent pstopIntent = PendingIntent.getService(this, 0,
                stopIntent, pendingIntentFlag);

        Bitmap icon = Bitmap.createScaledBitmap(
                BitmapFactory.decodeResource(
                        getResources(),
                        getServiceIconRes()),
                128, 128, false);

        return new NotificationCompat.Builder(this, getPackageName())
                .setContentTitle("XFiles")
                .setTicker(foreground_ticker)
                .setContentText(foreground_content_text)
                .setSmallIcon(R.drawable.xfiles_new_app_icon)
                .setLargeIcon(icon)
                .setContentIntent(pendingIntent)
                .setOngoing(true)
                .addAction(android.R.drawable.ic_media_pause, foreground_pause_action_label,
                        ppauseIntent)
                .addAction(R.drawable.ic_media_stop, foreground_stop_action_label,
                        pstopIntent);
    }


    protected static NotificationChannel notificationChannel;
    protected void createNotificationChannelForService() {
        if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.O) {
            if (notificationChannel == null) {
                notificationChannel = new NotificationChannel(getPackageName(), "nch", NotificationManager.IMPORTANCE_LOW);
                notificationChannel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);
                notificationManager.createNotificationChannel(notificationChannel);
            }
        }
    }
	
	@Override
    public void onDestroy() {
	    if (wakeLock.isHeld()) wakeLock.release();
        super.onDestroy();
    }
	
	@Override
    public void onCreate()
    {
        super.onCreate();
        mgr  = (PowerManager)getApplicationContext().getSystemService(Context.POWER_SERVICE);
        wakeLock = mgr.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, getPackageName()+":theWakeLock");
        notificationManager = (NotificationManager) getSystemService(Service.NOTIFICATION_SERVICE);
    }
	
	public void startAndShowNotificationBar() {
        switch (currentAction) {
            case START_ACTION:
                task = getTask();
                if (!task.init(this)) {
                    Toast.makeText(getApplicationContext(), "Cannot start service, overlay is busy", Toast.LENGTH_SHORT).show();
                    stopSelf();
                    return;
                }
                wakeLock.acquire();
                break;
            // Forbidden zone
            case CANCEL_ACTION:
            case PAUSE_ACTION:
                Toast.makeText(getApplicationContext(),
                        "Service not running, pause/cancel command should not arrive here",
                        Toast.LENGTH_SHORT).show();
                return;
            default:
                // DEBUG Forbidden zone
                Toast.makeText(getApplicationContext(),
                        "Unknown action in onStartCommand",
                        Toast.LENGTH_SHORT).show();
                return;
        }

        /************************** build notification **************************/

        Notification notification = getForegroundNotificationBuilder().build();
        createNotificationChannelForService();
        startForeground(getForegroundServiceNotificationId(),notification);
        task.execute((Void[])null);
    }

    protected abstract BaseBackgroundTask getTask();

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if(currentAction == null) {
            currentAction = intent.getAction();

            if (!START_ACTION.equals(currentAction)) {
                Toast.makeText(this, "Service not yet started, expected start action", Toast.LENGTH_SHORT).show();
                stopForeground(true);
                stopSelf();
                return START_NOT_STICKY;
            }

            params = EffectActivity.serviceParams;
            if (params == null) {
                throw new RuntimeException("Null params not allowed in start action");
            }

            prepareLabels();
            startAndShowNotificationBar();
        }
        else {
            // trying to abort?
            if (intent.getAction().equals(CANCEL_ACTION)) {
                abortServiceWithConfirmation();
            }
            else if (intent.getAction().equals(PAUSE_ACTION)) {
                task.pauseTask();
                Toast.makeText(getApplicationContext(),"Service paused",Toast.LENGTH_LONG).show();
            }
            // trying to start another concurrent task?
            else {
                Toast.makeText(getApplicationContext(),
                        "Service already running!",
                        Toast.LENGTH_SHORT).show();
            }
        }
        return START_NOT_STICKY;
    }
	
}
```

`app/src/main/java/it/pgp/xfiles/service/BaseBackgroundTask.java`:

```java
package it.pgp.xfiles.service;

import android.app.NotificationManager;
import android.content.Context;
import android.os.AsyncTask;
import android.support.v4.app.NotificationCompat;
import android.util.Log;

import java.io.Serializable;
import java.util.ArrayDeque;
import java.util.Deque;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ForegroundServiceType;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.service.visualization.ProgressIndicator;
import it.pgp.xfiles.utils.Pair;

public abstract class BaseBackgroundTask extends AsyncTask<Object,Pair<Long,Long>,Object> {
	
	protected NotificationCompat.Builder builder;
    // for notifying progress on foreground service progress bar
    protected NotificationManager nm;

    public ProgressIndicator mr;

    protected BaseBackgroundService service;
	public ServiceStatus status;

    public FileOpsErrorCodes result;

    public Serializable params; // to be down-casted in subclasses

    public static final Deque<Runnable> nextAutoTasks = new ArrayDeque<>();

    public BaseBackgroundTask(Serializable params) {
        this.params = params;
    }

    // FIXME circular dependency (task <-> service), cannot set in constructor, since service constructor needs task instance as input param
    /* invocation order:
    t = new Task();
    s = new Service(t);
    t.init(s);
     */
	public boolean init(BaseBackgroundService service) {
        this.service = service;
        builder = service.getForegroundNotificationBuilder();
        nm = (NotificationManager) service.getSystemService(Context.NOTIFICATION_SERVICE);
        // initialized in subclasses (MovingRibbon for Compress and extract tasks, MovingRibbonTwoBars for copy/move tasks
//        mr = new MovingRibbon(service,windowManager);

        // before initializing ribbon overlay, ensure to lock that resource (check if already locked)

        // progress interface lock to be done in subclasses
//        return ProgressIndicator.busy.compareAndSet(false,true); // compareAndSet true -> ok

        ForegroundServiceType f = service.getFgServiceType();
        return f != null && ProgressIndicator.acquire(f);
    }
	
	public void cancelTask() {
		status = ServiceStatus.CANCELLED;
		// to be explicitly overriden, task has to exit from doInBackground in order to stop foreground notification in onPostExecute
	}
	
	public void pauseTask() {
		status = ServiceStatus.PAUSED;
	}
	
	@Override
    protected void onPreExecute() {
        super.onPreExecute();
        builder.setProgress(100,0,false);
        nm.notify(service.getForegroundServiceNotificationId(), builder.build());
        status = ServiceStatus.ACTIVE;
    }

    /**
     * throttle UI progress update in order to make the buttons "easily" clickable
     * Web source:
     * https://stackoverflow.com/questions/6390016/android-notification-progressbar-freezing/28336857
     */

    protected long lastProgressUpdate = 0; // for overlay ribbon (fine)
    protected long lastProgressUpdateFgNotif = 0; // for foreground notification (coarse)

    public static final int OVERLAY_UPDATE_INTERVAL = 25;
    public static final int FGNOTIF_UPDATE_INTERVAL = 500;

    @Override
    protected void onProgressUpdate(Pair<Long,Long>... values) {
        // Update progress
        long current = System.currentTimeMillis();
        if(current - lastProgressUpdate > OVERLAY_UPDATE_INTERVAL) { // milliseconds
            mr.setProgress(values);
            lastProgressUpdate = current;
        }
        if(current - lastProgressUpdateFgNotif > FGNOTIF_UPDATE_INTERVAL) {
            builder.setProgress(100, (int) Math.round(values[0].i * 100.0 / values[0].j), false);
            nm.notify(service.getForegroundServiceNotificationId(), builder.build());
            lastProgressUpdateFgNotif = current;
        }

        super.onProgressUpdate(values);
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);
        mr.destroy();
        // in case of user cancelling task, cancel status is set before this
        if (status != ServiceStatus.CANCELLED)
            status = ServiceStatus.COMPLETED;
        service.stopForeground(true);
        service.stopSelf();

        // unlock ribbon overlay resource
        ProgressIndicator.release();

        if(!nextAutoTasks.isEmpty()) {
            if(result == null || result == FileOpsErrorCodes.OK) {
                Log.d(getClass().getName(),"Starting next auto task...");
                new Thread(nextAutoTasks.pop()).start();
            }
            else {
                Log.d(getClass().getName(),"Current task failed, clearing next auto tasks...");
                nextAutoTasks.clear();
            }
        }

        EffectActivity.serviceParams = null;
    }

    @Override
    protected abstract Object doInBackground(Object[] params);

    public void publishProgressWrapper(Pair<Long,Long>... values) {
        publishProgress(values);
    }
}
```

`app/src/main/java/it/pgp/xfiles/service/CompressService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

/**
 * Created by pgp on 05/06/17
 */

public class CompressService extends BaseBackgroundService {
    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0x123AB;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xfiles_archive;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.FILE_ARCHIVING;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles compress";
        foreground_content_text="Compress in progress...";
        foreground_pause_action_label="Pause compress";
        foreground_stop_action_label="Stop compress";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new CompressTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/CompressTask.java`:

```java
package it.pgp.xfiles.service;

import android.content.Intent;
import android.widget.Toast;

import java.io.IOException;
import java.io.Serializable;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.service.params.CompressParams;
import it.pgp.xfiles.service.visualization.MovingRibbon;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 05/06/17
 */

public class CompressTask extends RootHelperClientTask {

    // direct input to compressArchive
    public CompressParams params;

    private static final FileOpsErrorCodes defaultErrorResult = FileOpsErrorCodes.TRANSFER_ERROR;

    private BasePathContent currentDir;

    CompressTask(Serializable params_) {
        super(params_);
        this.params = (CompressParams) params_;
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;

        mr = new MovingRibbon(service);
        return true;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        resolver = service.getApplicationContext().getContentResolver();
        try {
            currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
        }
        catch (Exception e) {
            // standalone CompressActivity, no path view to update after end of task
        }
    }

    @Override
    protected Object doInBackground(Object[] unused) {
        if (rh == null) {
            result = FileOpsErrorCodes.ROOTHELPER_INIT_ERROR;
            return null;
        }
        try {

            rh.initProgressSupport(this);

            int ret = (params.uris==null)?
                    rh.compressToArchive(
                            params.srcDirectory,
                            params.destArchive,
                            params.compressionLevel,
                            params.encryptHeaders,
                            params.solidMode,
                            params.password,
                            params.filenames):
                    rh.compressToArchiveFromFds(
                            params.uris,
                            params.destArchive,
                            params.compressionLevel,
                            params.encryptHeaders,
                            params.solidMode,
                            params.password,
                            resolver);
            if (ret != 0) result = FileOpsErrorCodes.COMPRESS_ERROR;
        } catch (IOException e) {
            e.printStackTrace();
            result = defaultErrorResult;
        }
        return null;
    }

    @Override
    protected void onPostExecute(Object o) {
        try {
            if (result == null) {
                // refresh dir only if it's the same of when the task started
                Toast.makeText(service,"Compress completed",Toast.LENGTH_LONG).show();
                MainActivity activity = MainActivity.mainActivity;
                if (activity == null) {
                    if (params.standaloneMode) { // start MainActivity in order to show created archive
                        Intent intent = new Intent(service.getApplicationContext(),MainActivity.class);
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TOP);
                        intent.putExtra("STARTDIR",params.destArchive.getParent().dir);
                        service.startActivity(intent);

                        new Thread(()->{
                            try {Thread.sleep(1000);} catch (InterruptedException ignored) {}
                            MainActivity.showToast("Compress completed");
                        }).start();
                    }
                    // activity closed while service active and not in standalone mode, nothing to refresh
                }
                else {
                    BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
                    if (cd.equals(currentDir))
                        activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),params.destArchive.dir);
                }
            }
            else {
                // show error message only if task was not interrupted by user
                if (status != ServiceStatus.CANCELLED)
                    Toast.makeText(service,"Compress error: "+result.getValue(),Toast.LENGTH_LONG).show();
                else
                    Toast.makeText(service,"Compress cancelled",Toast.LENGTH_LONG).show();
            }
        }
        finally {
            super.onPostExecute(o);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/CopyMoveService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

/**
 * Created by pgp on 23/06/17
 */

public class CopyMoveService extends BaseBackgroundService {
    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0xC01;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xf_copy;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.FILE_TRANSFER;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles file transfer";
        foreground_content_text="Transfer in progress...";
        foreground_pause_action_label="Pause transfer";
        foreground_stop_action_label="Stop transfer";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new CopyMoveTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/CopyMoveTask.java`:

```java
package it.pgp.xfiles.service;

import android.widget.Toast;

import java.io.IOException;
import java.io.Serializable;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.service.params.CopyMoveParams;
import it.pgp.xfiles.service.visualization.MovingRibbonTwoBars;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 23/06/17
 * Using roothelper only
 */

public class CopyMoveTask extends RootHelperClientTask {

    CopyMoveParams params;
    private BasePathContent currentDir; // for refreshing dir listview (if not changed meanwhile) on operation end


    CopyMoveTask(Serializable params) {
        super(params);
        this.params = (CopyMoveParams) params;
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;
        mr = new MovingRibbonTwoBars(service); // TODO try catch RuntimeException
        return true;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
    }

    @Override
    protected Object doInBackground(Object[] unusedParams) {
        if (rh == null) {
            result = FileOpsErrorCodes.ROOTHELPER_INIT_ERROR;
            return null;
        }
        try {
            rh.initProgressSupport(this);
            rh.copyMoveFilesToDirectory(this.params.list,this.params.destPath);

            // reset progress, in case this object has to be used again after file transfer end
//            rh.destroyProgressSupport();
        } catch (IOException e) {
            e.printStackTrace();
            result = FileOpsErrorCodes.TRANSFER_ERROR;
        }
        return null;
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);

        // not needed anymore, rh server is multithreaded
//        if (rh != null) {
//            try {rh.killServer();}
//            catch (IOException ignored) {}
//        }

        if (result == null) {
            // refresh dir only if it's the same of when the task started
            Toast.makeText(service,params.list.copyOrMove.name().toLowerCase()+" completed",Toast.LENGTH_LONG).show();
            MainActivity activity = MainActivity.mainActivity;
            if (activity == null) return; // activity closed while service active, nothing to refresh
            BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
            if (cd.equals(currentDir))
                activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),params.list.files.get(0).getFilename());
        }
        else {
            String errType = params.list.copyOrMove.name().toLowerCase();
            // show error message only if task was not interrupted by user
            if (status != ServiceStatus.CANCELLED)
                Toast.makeText(service,errType+" error: "+result.getValue(),Toast.LENGTH_LONG).show();
            else
                Toast.makeText(service,errType+" cancelled",Toast.LENGTH_LONG).show();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/CreateFileService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

public class CreateFileService extends BaseBackgroundService {
    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0xB01;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xfiles_file_icon;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.CREATE_FILE;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles create file";
        foreground_content_text="File creation in progress...";
        foreground_pause_action_label="Pause create file";
        foreground_stop_action_label="Stop create file";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new CreateFileTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/CreateFileTask.java`:

```java
package it.pgp.xfiles.service;

import android.app.AlertDialog;
import android.graphics.Typeface;
import android.util.TypedValue;
import android.widget.TextView;
import android.widget.Toast;

import java.io.IOException;
import java.io.Serializable;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.service.params.CreateFileParams;
import it.pgp.xfiles.service.visualization.MovingRibbon;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;


public class CreateFileTask extends RootHelperClientTask {

    public CreateFileParams params;
    public String outputHash;

    private static final FileOpsErrorCodes defaultErrorResult = FileOpsErrorCodes.TRANSFER_ERROR;

    private BasePathContent currentDir;

    CreateFileTask(Serializable params_) {
        super(params_);
        this.params = (CreateFileParams) params_;
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if(!super.init(service)) return false;

        mr = new MovingRibbon(service);
        return true;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
    }

    @Override
    protected Object doInBackground(Object[] unused) {
        if(rh == null) {
            result = FileOpsErrorCodes.ROOTHELPER_INIT_ERROR;
            return null;
        }
        try {
            rh.initProgressSupport(this);
            FileCreationAdvancedOptions[] fileOpts = params.opts == null ? new FileCreationAdvancedOptions[0] : new FileCreationAdvancedOptions[]{params.opts};
            outputHash = rh.createFileOrDirectory(params.path, FileMode.FILE, fileOpts);
        }
        catch(IOException e) {
            e.printStackTrace();
            result = defaultErrorResult;
        }
        return null;
    }

    @Override
    protected void onPostExecute(Object o) {
        try {
            if(result == null) {
                // refresh dir only if it's the same of when the task started
                Toast.makeText(service,"File created",Toast.LENGTH_LONG).show();
                MainActivity activity = MainActivity.mainActivity;
                BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
                if(cd.equals(currentDir))
                    activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),params.path.getName());
                if(outputHash != null) {
                    AlertDialog.Builder bld = new AlertDialog.Builder(activity);
                    TextView content = new TextView(MainActivity.mainActivity);
                    content.setText(outputHash);
                    content.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
                    content.setTypeface(Typeface.MONOSPACE);
                    bld.setTitle(params.opts.strategy.outputHashType+" hash");
                    bld.setView(content);
                    bld.setNegativeButton("Copy to clipboard", (d,w) -> Misc.copyToClipboard(service, "Generated file hash", outputHash));
                    bld.setNeutralButton(android.R.string.ok, null);
                    AlertDialog d = bld.create();
                    // prevent dismiss on unintentional touches
                    d.setCancelable(false);
                    d.setCanceledOnTouchOutside(false);
                    d.show();
                }
            }
            else {
                // show error message only if task was not interrupted by user
                if(status != ServiceStatus.CANCELLED)
                    Toast.makeText(service,"File creation error: "+result.getValue(),Toast.LENGTH_LONG).show();
                else
                    Toast.makeText(service,"File creation cancelled",Toast.LENGTH_LONG).show();
            }
        }
        finally {
            super.onPostExecute(o);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/ExtractService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

/**
 * Created by pgp on 05/06/17
 */

public class ExtractService extends BaseBackgroundService {
    static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0x123AC;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xfiles_extract;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.FILE_ARCHIVING;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles extract";
        foreground_content_text="Extract in progress...";
        foreground_pause_action_label="Pause extract";
        foreground_stop_action_label="Stop extract";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new ExtractTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/ExtractTask.java`:

```java
package it.pgp.xfiles.service;

import android.app.Dialog;
import android.widget.ListView;
import android.widget.Toast;

import java.io.IOException;
import java.io.Serializable;
import java.util.List;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.ExtractResultsAdapter;
import it.pgp.xfiles.dialogs.compress.AskPasswordDialogOnExtract;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.service.params.ExtractParams;
import it.pgp.xfiles.service.params.TestParams;
import it.pgp.xfiles.service.visualization.MovingRibbon;
import it.pgp.xfiles.service.visualization.MovingRibbonTwoBars;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 05/06/17
 */

public class ExtractTask extends RootHelperClientTask {

    // direct input to extractArchive
    private List<BasePathContent> srcArchives; // subDir taken from here
    private BasePathContent destDirectory;
    private String password;
    private Iterable<String> filenames;
    private boolean smartDirectoryCreation;

    private static final FileOpsErrorCodes defaultErrorResult = FileOpsErrorCodes.TRANSFER_ERROR;
    private BasePathContent currentDir;

    public String prefix;

    public List<FileOpsErrorCodes> results;
    public boolean allOk;

    public boolean allResultsOk() {
        boolean ok = true;
        for(FileOpsErrorCodes code : results)
            ok &= (code == null || code == FileOpsErrorCodes.OK);
        return ok;
    }

    ExtractTask(Serializable params_) {
        super(params_);
        ExtractParams params = (ExtractParams) params_;
        srcArchives = params.srcArchives;
        destDirectory = params.destDirectory;
        password = params.password;
        filenames = params.filenames;
        smartDirectoryCreation = params.smartDirectoryCreation;
        prefix = (params_ instanceof TestParams)?"Test":"Extract";
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;
        if(srcArchives.size()==1)
            mr = new MovingRibbon(service);
        else {
            mr = new MovingRibbonTwoBars(service);
            ((MovingRibbonTwoBars) mr).recursive = true;
        }
        return true;
    }
    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
    }

    @Override
    protected Object doInBackground(Object[] params) {
        if (rh == null) {
            result = FileOpsErrorCodes.ROOTHELPER_INIT_ERROR;
            return null;
        }
        try {
            rh.initProgressSupport(this);
            results = rh.extractFromArchive(
                    srcArchives,
                    destDirectory,
                    password,
                    filenames,
                    smartDirectoryCreation);
            allOk = allResultsOk();
            if(!allOk) result = results.get(0); // propagate first error for toast message
        }
        catch (IOException e) {
            e.printStackTrace();
            result = defaultErrorResult; // maybe better extract error
        }
        return null;
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);
        MainActivity activity = MainActivity.mainActivity;
        if (allOk) {
            Toast.makeText(service.getApplicationContext(), prefix+" completed", Toast.LENGTH_LONG).show();
        }
        else if (results.size()==1) {
            if (result == FileOpsErrorCodes.NULL_OR_WRONG_PASSWORD) {
                Toast.makeText(service.getApplicationContext(),"Empty or wrong password",Toast.LENGTH_LONG).show();
                if (activity != null)
                    new AskPasswordDialogOnExtract(activity,(ExtractParams)params).show();
                return;
            }
            else if (result == FileOpsErrorCodes.CRC_FAILED) {
                Toast.makeText(service.getApplicationContext(),"CRC failed in data, damaged archive?",Toast.LENGTH_LONG).show();
            }
            else {
                if (status != ServiceStatus.CANCELLED)
                    Toast.makeText(service.getApplicationContext(),prefix+" error: "+result.getValue(),Toast.LENGTH_LONG).show();
                else
                    Toast.makeText(service,prefix+" cancelled",Toast.LENGTH_LONG).show();
            }
        }
        else { // there were errors when extracting from multiple archives, show results dialog
            if(activity != null) {
                Dialog d = new Dialog(activity);
                d.setTitle((params instanceof TestParams ? "Test":"Extract")+" results");
                d.setContentView(R.layout.extract_results_dialog);
                ExtractResultsAdapter a = new ExtractResultsAdapter(activity, srcArchives, results);
                ListView lv = d.findViewById(R.id.extract_results_view);
                lv.setAdapter(a);
                d.show();
            }
            else Toast.makeText(activity, "There were extraction/test errors, unable to display them without an active activity", Toast.LENGTH_SHORT).show();
        }

        // anyway, if we are not testing archives, refresh adapter if we are in the same folder
        if(activity != null && !(params instanceof TestParams)) {
            BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
            if (cd.equals(currentDir))
                activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),null);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/FindService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

/**
 * Foreground service with notification bar for find operation
 */

public class FindService extends BaseBackgroundService {
    public static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0x777ABC;

//    public static final String FIND_ACTION = "Find";
//    public static final String PAUSE_ACTION = "Pause"; // pause, on next activity open, show results found so far
//    public static final String CANCEL_ACTION = "Cancel"; // cancel, on next activity open, show results found so far
//    public static final String TARGETFOLDERPATH_TAG = "targetfolder";
//    public static final String SEARCH_NAME_PATTERN_TAG = "namepattern";
//    public static final String SEARCH_CONTENT_PATTERN_TAG = "contentpattern";
//    public static final String SEARCH_IN_SUBFOLDERS_OPTION_TAG = "searchinsubfolders";
//    public static final String SEARCH_IN_ARCHIVES_OPTION_TAG = "searchinarchives";

    @Override
    public int getServiceIconRes() {
        return R.drawable.xfiles_find;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.FIND;
    }

    protected void prepareLabels() {
        foreground_ticker="XFiles find";
        foreground_content_text="Search in progress...";
        foreground_pause_action_label="";
        foreground_stop_action_label="Stop search";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new FindTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/FindTask.java`:

```java
package it.pgp.xfiles.service;

import java.io.Serializable;

import it.pgp.xfiles.service.params.FindParams;

/**
 * Created by pgp on 22/03/17
 */

public class FindTask extends RootHelperClientTask {

    public FindParams params;

    FindTask(Serializable params_) {
        super(params_);
        params = (FindParams)params_;
//        d = new DirTreeWalker(new File(targetFolder)); // not used anymore, dir tree walk performed by roothelper
    }

    // FIXME String progress collides with RootHelperClientTask definition
    // protected void onProgressUpdate(String... values) {}

    @Override
    protected Object doInBackground(Object[] params) {
        // with AsyncTask<?,String,?>, on each String progress read by local socket,
        // update FindResultsActivity with a new adapter entry
        // use flag for interruption, roothelper thread at the other end exits on socket write error
        return null;
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/HTTPDownloadService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

/**
 * Created by pgp on 05/11/17
 */

public class HTTPDownloadService extends BaseBackgroundService {

    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0xF01;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xf_share;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.URL_DOWNLOAD;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles HTTP download";
        foreground_content_text="Download in progress...";
        foreground_pause_action_label="Pause download";
        foreground_stop_action_label="Stop download";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new HTTPDownloadTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/HTTPDownloadTask.java`:

```java
package it.pgp.xfiles.service;

import android.widget.Toast;

import java.io.IOException;
import java.io.Serializable;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.service.params.DownloadParams;
import it.pgp.xfiles.service.visualization.MovingRibbon;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 05/11/17
 */

public class HTTPDownloadTask extends RootHelperClientTask {

    DownloadParams params;
    private BasePathContent currentDir;

    final String[] targetFileNameOnly = new String[]{null};

    HTTPDownloadTask(Serializable params) {
        super(params);
        this.params = (DownloadParams) params;
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;
        mr = new MovingRibbon(service);
        ((MovingRibbon)mr).pb.setIndeterminate(true); // keep into account the case where server doesn't publish content size
        return true;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
    }

    @Override
    protected void onProgressUpdate(Pair<Long,Long>... values) {
        ((MovingRibbon)mr).pb.setIndeterminate(false);
        super.onProgressUpdate(values);
    }

    @Override
    protected Object doInBackground(Object... unusedParams) {
        rh.initProgressSupport(this);
        // use rh http client for both http and https urls
        if(params.destPath == null || params.destPath.isEmpty()) { // user did not specify a destination path
            if (MainActivity.mainActivity != null) {
                BasePathContent bpc = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
                if (bpc.providerType == ProviderType.LOCAL)
                    params.destPath = bpc.dir;
                else params.destPath = Misc.internalStorageDir.getAbsolutePath();
            }
        }
        targetFileNameOnly[0] = params.filename==null?"":params.filename;
        try {
            rh.downloadHttpsUrl(params.url,params.destPath,targetFileNameOnly,params.httpsOnly); // here pass String array, content will be replaced with guessed or same input filename
        }
        catch (IOException e) {
            e.printStackTrace();
            result = FileOpsErrorCodes.TRANSFER_ERROR;
        }
        return result;
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);

        if (result == null) {
            Toast.makeText(service, "Download completed", Toast.LENGTH_SHORT).show();
            MainActivity activity = MainActivity.mainActivity;
            if (activity == null) return; // activity closed while service active, nothing to refresh
            BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
            if (cd.equals(currentDir))
                activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),targetFileNameOnly[0]);
        }
        else {
            Toast.makeText(service, "Download "+
                    (status == ServiceStatus.CANCELLED ? "cancelled" : "error"), Toast.LENGTH_SHORT).show();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/HTTPUploadService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

public class HTTPUploadService extends BaseBackgroundService {

    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0xF02;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xf_share;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.URL_DOWNLOAD;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="HTTPS upload";
        foreground_content_text="Upload in progress...";
        foreground_pause_action_label="Pause upload";
        foreground_stop_action_label="Stop upload";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new HTTPUploadTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/HTTPUploadTask.java`:

```java
package it.pgp.xfiles.service;

import android.app.AlertDialog;
import android.content.Intent;
import android.graphics.Typeface;
import android.util.TypedValue;
import android.widget.TextView;
import android.widget.Toast;

import java.io.Serializable;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.service.params.DownloadParams;
import it.pgp.xfiles.service.visualization.MovingRibbon;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.Pair;

public class HTTPUploadTask extends RootHelperClientTask {

    DownloadParams params; // actually upload params, only destPath used as full path (destPath is actually a source path)
    String generatedLink;
    Exception lastException;
    public static final String prefix = "Upload ";

    HTTPUploadTask(Serializable params) {
        super(params);
        this.params = (DownloadParams) params;
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;
        mr = new MovingRibbon(service);
        return true;
    }

    @Override
    protected void onProgressUpdate(Pair<Long,Long>... values) {
        ((MovingRibbon)mr).pb.setIndeterminate(false);
        super.onProgressUpdate(values);
    }

    @Override
    protected Object doInBackground(Object... unusedParams) {
        rh.initProgressSupport(this);

        try {
            generatedLink = rh.uploadHttpsUrl(params.url,params.destPath);
            // extract only link (needed for x0.at, which sends additional information as well)
            Matcher matcher = Pattern.compile("^(https?)://[-a-zA-Z0-9+&@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&@#/%=~_|]", Pattern.MULTILINE).matcher(generatedLink);
            if(matcher.find()) {
                generatedLink = matcher.group(); // group 0, a.k.a. entire occurrence
                // take first url found
            }
            // on no matches, return the text as-is
        }
        catch(Exception e) {
            e.printStackTrace();
            lastException = e;
            result = FileOpsErrorCodes.TRANSFER_ERROR;
        }

        return result;
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);

        if (result == null) {
            String label = "Download link";
            Toast.makeText(service, prefix+"completed", Toast.LENGTH_SHORT).show();
            AlertDialog.Builder bld = new AlertDialog.Builder(MainActivity.mainActivity);
            TextView title = new TextView(MainActivity.mainActivity);
            title.setText(label+":\n"+generatedLink);
            title.setTextSize(TypedValue.COMPLEX_UNIT_DIP, 16);
            title.setTypeface(Typeface.MONOSPACE);
            bld.setCustomTitle(title);
            bld.setNegativeButton("Copy to clipboard", (d,w) -> Misc.copyToClipboard(service, label, generatedLink));
            bld.setPositiveButton("Share", (d,w) -> {
                Intent intent = new Intent(Intent.ACTION_SEND);
                intent.setType("text/plain");
                intent.putExtra(Intent.EXTRA_SUBJECT, label);
                intent.putExtra(Intent.EXTRA_TEXT, generatedLink);
                Intent wi = Intent.createChooser(intent,"Share link using");
                wi.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                service.startActivity(wi);
            });
            bld.setNeutralButton(android.R.string.ok, null);
            AlertDialog d = bld.create();
            // prevent dismiss on unintentional touches once the download link has been generated
            d.setCancelable(false);
            d.setCanceledOnTouchOutside(false);
            d.show();
        }
        else {
            Toast.makeText(service, prefix+
                    (status == ServiceStatus.CANCELLED ? "cancelled" :
                            "error, reason: "+(lastException == null ? "" : lastException.getMessage())),
                    Toast.LENGTH_SHORT).show();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/IndeterminateAsyncTask.java`:

```java
package it.pgp.xfiles.service;

import android.app.ProgressDialog;
import android.content.Context;
import android.os.AsyncTask;
import android.widget.Toast;

/**
 * Created by pgp on 21/06/17
 * Generic AsyncTask abstract wrapper, in order to execute arbitrary methods while showing
 * an indeterminate progress dialog
 */

public abstract class IndeterminateAsyncTask extends AsyncTask<Void,Void,Integer> {
    private final Context context;
    private ProgressDialog pd;

    private String successMessage;
    private String errorMessage;
    private String ongoingMessage;

    protected IndeterminateAsyncTask(Context context,
                                     String ongoingMessage,
                                     String successMessage,
                                     String errorMessage) {
        this.context = context;
        this.errorMessage = errorMessage;
        this.successMessage = successMessage;
        this.ongoingMessage = ongoingMessage;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        pd = new ProgressDialog(context);
        pd.setIndeterminate(true);
        pd.setMessage(ongoingMessage);
        pd.show();
    }

    @Override
    protected void onPostExecute(Integer integer) {
        super.onPostExecute(integer);
        pd.dismiss();
        Toast.makeText(context,integer==0?successMessage:errorMessage,Toast.LENGTH_LONG).show();
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/NonInteractiveSftpService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

/**
 * Created by pgp on 07/10/17
 *
 * Conflict-handling-free (fail-fast) service class for downloading/uploading files
 * from/to SFTP server
 */

public class NonInteractiveSftpService extends BaseBackgroundService {
    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0xE01;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xf_copy;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.SFTP_TRANSFER;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles SFTP transfer";
        foreground_content_text="Transfer in progress...";
        foreground_pause_action_label="Pause transfer";
        foreground_stop_action_label="Stop transfer";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new NonInteractiveSftpTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/NonInteractiveSftpTask.java`:

```java
package it.pgp.xfiles.service;

import android.widget.Toast;

import java.io.IOException;
import java.io.Serializable;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.exceptions.InterruptedTransferAsIOException;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.service.params.CopyMoveParams;
import it.pgp.xfiles.sftpclient.SFTPProvider;
import it.pgp.xfiles.sftpclient.XProgress;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 07/10/17
 */

public class NonInteractiveSftpTask extends BaseBackgroundTask {
    /*
     * determine operation type (DOWNLOAD or UPLOAD) by type inspection of CopyMoveParams:
     * - DOWNLOAD:
     *      CopyMoveParams.CopyMoveListPathContent.BasePathContent (parentDir) -> SFTPPathContent
     *      CopyMoveParams.BasePathContent -> LocalPathContent
     * - UPLOAD:
     *      CopyMoveParams.CopyMoveListPathContent.BasePathContent (parentDir) -> LocalPathContent
     *      CopyMoveParams.BasePathContent -> SFTPPathContent
     */
    public CopyMoveParams params;
    public ControlCodes action;

    private BasePathContent currentDir; // for refreshing dir listview (if not changed meanwhile) on operation end
    Exception lastException;

    public NonInteractiveSftpTask(Serializable params_) {
        super(params_);
        params = (CopyMoveParams) params_;

        if (params.list.parentDir.providerType == ProviderType.SFTP &&
                params.destPath.providerType == ProviderType.LOCAL)
            action = ControlCodes.ACTION_DOWNLOAD;
        else if (params.list.parentDir.providerType == ProviderType.LOCAL &&
                params.destPath.providerType == ProviderType.SFTP)
            action = ControlCodes.ACTION_UPLOAD;
        else throw new RuntimeException("Unexpected CopyMoveParams content");
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;
        mr = new XProgress(service);
        return true;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
    }

    @Override
    protected Object doInBackground(Object[] unusedParams) {
        try {
            SFTPProvider sp = MainActivity.sftpProvider;
            sp.initProgressSupport(this);
            sp.copyMoveFilesToDirectory(this.params.list,this.params.destPath);
        }
        catch (IOException e) {
            if (!(e instanceof InterruptedTransferAsIOException)) {
                e.printStackTrace();
                lastException = e;
                result = FileOpsErrorCodes.TRANSFER_ERROR;
            }
            else result = FileOpsErrorCodes.TRANSFER_CANCELLED;
        }
        return result;
    }

    @Override
    public void cancelTask() {
         super.cancelTask();

        // SSHJ IOException by stream copier listener trick, will cancel transfer
        // web source: https://github.com/hierynomus/sshj/issues/288
        ((XProgress)mr).cancelByProgressCrash();
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);

        if (result == null || result == FileOpsErrorCodes.OK) {
            // refresh dir only if it's the same of when the task started
            Toast.makeText(service,"Remote transfer completed",Toast.LENGTH_LONG).show();
            MainActivity activity = MainActivity.mainActivity;
            if (activity == null) return; // activity closed while service active, nothing to refresh
            BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
            if (cd.equals(currentDir))
                activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),params.list.files.get(0).getFilename());
        }
        else if (result == FileOpsErrorCodes.TRANSFER_CANCELLED) {
            Toast.makeText(service,params.list.copyOrMove.name().toLowerCase()+" cancelled",Toast.LENGTH_LONG).show();
        }
        else {
            Toast.makeText(service,params.list.copyOrMove.name().toLowerCase()+" error: "+result.getValue()+
                    "\nReason: "+(lastException==null?"null":lastException.getMessage()),Toast.LENGTH_LONG).show();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/NonInteractiveSmbService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

public class NonInteractiveSmbService extends BaseBackgroundService {
    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0xA01;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xf_copy;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.SMB_TRANSFER;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles SMB transfer";
        foreground_content_text="Transfer in progress...";
        foreground_pause_action_label="Pause transfer";
        foreground_stop_action_label="Stop transfer";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new NonInteractiveSmbTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/NonInteractiveSmbTask.java`:

```java
package it.pgp.xfiles.service;

import android.widget.Toast;

import java.io.Serializable;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.service.params.CopyMoveParams;
import it.pgp.xfiles.sftpclient.XProgress;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class NonInteractiveSmbTask extends BaseBackgroundTask {
    /*
     * determine operation type (DOWNLOAD or UPLOAD) by type inspection of CopyMoveParams:
     * - DOWNLOAD:
     *      CopyMoveParams.CopyMoveListPathContent.BasePathContent (parentDir) -> SMBPathContent
     *      CopyMoveParams.BasePathContent -> LocalPathContent
     * - UPLOAD:
     *      CopyMoveParams.CopyMoveListPathContent.BasePathContent (parentDir) -> LocalPathContent
     *      CopyMoveParams.BasePathContent -> SMBPathContent
     */
    public CopyMoveParams params;
    public ControlCodes action;

    private BasePathContent currentDir; // for refreshing dir listview (if not changed meanwhile) on operation end
    Exception lastException;

    public NonInteractiveSmbTask(Serializable params_) {
        super(params_);
        params = (CopyMoveParams) params_;

        if (params.list.parentDir.providerType == ProviderType.SMB &&
                params.destPath.providerType == ProviderType.LOCAL)
            action = ControlCodes.ACTION_DOWNLOAD;
        else if (params.list.parentDir.providerType == ProviderType.LOCAL &&
                params.destPath.providerType == ProviderType.SMB)
            action = ControlCodes.ACTION_UPLOAD;
        else throw new RuntimeException("Unexpected CopyMoveParams content");
    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;
        mr = new XProgress(service);
        return true;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
    }

    @Override
    protected Object doInBackground(Object[] unusedParams) {
        try {
            MainActivity.smbProvider.initProgressSupport(this);
            MainActivity.smbProvider.copyMoveFilesToDirectory(
                    this.params.list,this.params.destPath);
        }
        catch (Exception e) {
            e.printStackTrace();
            lastException = e;
            result = FileOpsErrorCodes.TRANSFER_ERROR;
        }
        return result;
    }

    // TODO implement if needed
//    @Override
//    public void cancelTask() {
//         super.cancelTask();
//    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);

        if (result == null || result == FileOpsErrorCodes.OK) {
            // refresh dir only if it's the same of when the task started
            Toast.makeText(service,"Remote transfer completed",Toast.LENGTH_LONG).show();
            MainActivity activity = MainActivity.mainActivity;
            if (activity == null) return; // activity closed while service active, nothing to refresh
            BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
            if (cd.equals(currentDir))
                activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),params.list.files.get(0).getFilename());
        }
        else if (result == FileOpsErrorCodes.TRANSFER_CANCELLED) {
            Toast.makeText(service,params.list.copyOrMove.name().toLowerCase()+" cancelled",Toast.LENGTH_LONG).show();
        }
        else {
            Toast.makeText(service,params.list.copyOrMove.name().toLowerCase()+" error: "+result.getValue()+
                    "\nReason: "+(lastException==null?"null":lastException.getMessage()),Toast.LENGTH_LONG).show();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/NonInteractiveXFilesRemoteTransferService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.ForegroundServiceType;

/**
 * Created by pgp on 07/10/17
 *
 * Conflict-handling-free (fail-fast) service class for downloading/uploading files
 * from/to remote roothelper server
 */

public class NonInteractiveXFilesRemoteTransferService extends BaseBackgroundService {
    private static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0xD01;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xf_copy;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    public final ForegroundServiceType getFgServiceType() {
        return ForegroundServiceType.XRE_TRANSFER;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles remote transfer";
        foreground_content_text="Transfer in progress...";
        foreground_pause_action_label="Pause transfer";
        foreground_stop_action_label="Stop transfer";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new NonInteractiveXFilesRemoteTransferTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/NonInteractiveXFilesRemoteTransferTask.java`:

```java
package it.pgp.xfiles.service;

import android.util.Log;
import android.widget.Toast;

import java.io.Serializable;

import it.pgp.xfiles.CopyListUris;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.XREDirectShareActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.enums.ServiceStatus;
import it.pgp.xfiles.roothelperclient.ControlCodes;
import it.pgp.xfiles.roothelperclient.RemoteManager;
import it.pgp.xfiles.service.params.CopyMoveParams;
import it.pgp.xfiles.service.visualization.MovingRibbonTwoBars;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;

/**
 * Created by pgp on 07/10/17
 */

public class NonInteractiveXFilesRemoteTransferTask extends RootHelperClientTask {
    /*
     * determine operation type (DOWNLOAD or UPLOAD) by type inspection of CopyMoveParams:
     * - DOWNLOAD:
     *      CopyMoveParams.CopyMoveListPathContent.BasePathContent (parentDir) -> XREPathContent
     *      CopyMoveParams.BasePathContent -> LocalPathContent
     * - UPLOAD:
     *      CopyMoveParams.CopyMoveListPathContent.BasePathContent (parentDir) -> LocalPathContent
     *      CopyMoveParams.BasePathContent -> XREPathContent
     */
    public CopyMoveParams params;
    public ControlCodes action;

    private BasePathContent currentDir; // for refreshing dir listview (if not changed meanwhile) on operation end

    NonInteractiveXFilesRemoteTransferTask(Serializable params_) {
        super(params_);
        params = (CopyMoveParams) params_;

        try {
            if (params.list.parentDir.providerType == ProviderType.XFILES_REMOTE &&
                    params.destPath.providerType == ProviderType.LOCAL)
                action = ControlCodes.ACTION_DOWNLOAD;
            else if (params.list.parentDir.providerType == ProviderType.LOCAL &&
                    params.destPath.providerType == ProviderType.XFILES_REMOTE)
                action = ControlCodes.ACTION_UPLOAD;
            else throw new RuntimeException("Unexpected CopyMoveParams content");
        }
        catch (NullPointerException n) {
            if (!(params.list instanceof CopyListUris)) throw n;
            Log.d("XRETASK", "params contain content uris, defaulting action to upload...");
            action = ControlCodes.ACTION_UPLOAD;
        }
    }

    /**
     * Partially working
     * TODO close also local RH streams
     */
    @Override
    public void cancelTask() {
//        super.cancelTask();
        status = ServiceStatus.CANCELLED;
        Log.d("XRETASK","Interrupted, closing XRE client connection...");
        try {
            XREPathContent xrePath = (params.destPath instanceof XREPathContent)?
                    (XREPathContent) params.destPath :
                    (XREPathContent) params.list.parentDir;
            RemoteManager client = MainActivity.rootHelperRemoteClientManager.getClient(
                    xrePath.serverHost, false);
            client.close();
        }
        catch (Exception e) {
            e.printStackTrace();
        }

    }

    @Override
    public boolean init(BaseBackgroundService service) {
        if (!super.init(service)) return false;
        mr = new MovingRibbonTwoBars(service);
        return true;
    }

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
        resolver = service.getApplicationContext().getContentResolver();
        try {
            currentDir = MainActivity.mainActivity.getCurrentDirCommander().getCurrentDirectoryPathname();
        }
        catch (Exception e) {
            // standalone activity, no path view to update after end of task
        }
    }

    @Override
    protected Object doInBackground(Object[] unusedParams) {
        result = MainActivity.rootHelperRemoteClientManager.transferItems(this.params.list,this.params.destPath,action,this, resolver);
        return result;
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);
        MainActivity activity = MainActivity.mainActivity;
        if(activity == null) {
            Toast.makeText(service,
                    (result == null || result == FileOpsErrorCodes.OK)?
                            "Remote transfer completed in standalone mode":
                            params.list.copyOrMove.name().toLowerCase()+" error in standalone mode: "+result.getValue()
                    , Toast.LENGTH_SHORT).show();
            MainActivity.rootHelperRemoteClientManager.closeAllSessions();
            // workaround in order to avoid showing again XREDirectShareActivity after opening and closing the app again after transfer end
//            if(params.list instanceof CopyListUris)
            if(XREDirectShareActivity.instance != null)
                XREDirectShareActivity.instance.finishAffinity();
            return;
        }


        if (result == null || result == FileOpsErrorCodes.OK) {
            // refresh dir only if it's the same of when the task started
            Toast.makeText(service,"Remote transfer completed",Toast.LENGTH_LONG).show();
            BasePathContent cd = activity.getCurrentDirCommander().getCurrentDirectoryPathname();
            if (cd.equals(currentDir))
                activity.browserPagerAdapter.showDirContent(activity.getCurrentDirCommander().refresh(),activity.browserPager.getCurrentItem(),params.getFirstFilename(resolver));
        }
        else {
            Toast.makeText(service,params.list.copyOrMove.name().toLowerCase()+" error: "+result.getValue(),Toast.LENGTH_LONG).show();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/RootHelperClientTask.java`:

```java
package it.pgp.xfiles.service;

import android.content.ContentResolver;

import java.io.Serializable;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.roothelperclient.RootHelperClient;

/**
 * Created by pgp on 06/06/17
 * Base class for tasks utilizing roothelper instances
 */

public abstract class RootHelperClientTask extends BaseBackgroundTask {

    public RootHelperClient rh;
    public ContentResolver resolver; // for XRE direct share and compress from 3rd party providers

    public RootHelperClientTask(Serializable params) {
        super(params);

        MainActivity.getRootHelperClient(); // ensure started (not sure if instance can be re-used here)
        rh = new RootHelperClient();
    }


    @Override
    public void cancelTask() {
        super.cancelTask();

        // TODO may be useful in all long-term tasks, change following comment if needed
        // force close RootHelperStreams so that both the AsyncTask and the forked p7zip C++ process terminate
        try {rh.rs.close();}
        catch (Exception ignored) {}
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);

        // if main activity has been closed meanwhile, stop the main RH server instance as well
        if (MainActivity.mainActivity == null) {
            MainActivity.killRHWrapper();
        }
    }

}

```

`app/src/main/java/it/pgp/xfiles/service/SocketNames.java`:

```java
package it.pgp.xfiles.service;

/**
 * Created by pgp on 27/09/17
 */

// e.g. thecompressor is parallel-compatible with thetransferrer in upload mode (no concurrent write load)
public enum SocketNames {
    theroothelper, // Main, persistent, for short-lived operations
//        thecompressor, // READ & WRITE
//        theextractor, // READ & WRITE
//        thetransferrer, // READ & WRITE (READ ONLY IF UPLOAD, WRITE ONLY IF DOWNLOAD)
//        thefinder // READ ONLY
}

```

`app/src/main/java/it/pgp/xfiles/service/TestService.java`:

```java
package it.pgp.xfiles.service;

import it.pgp.xfiles.R;

public class TestService extends ExtractService {
    static final int FOREGROUND_SERVICE_NOTIFICATION_ID = 0x123AD;

    @Override
    public int getServiceIconRes() {
        return R.drawable.xfiles_test;
    }

    @Override
    public int getForegroundServiceNotificationId() {
        return FOREGROUND_SERVICE_NOTIFICATION_ID;
    }

    @Override
    protected void prepareLabels() {
        foreground_ticker="XFiles test";
        foreground_content_text="Test in progress...";
        foreground_pause_action_label="Pause test";
        foreground_stop_action_label="Stop test";
    }

    @Override
    protected BaseBackgroundTask getTask() {
        return new ExtractTask(params);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/params/CompressParams.java`:

```java
package it.pgp.xfiles.service.params;

import android.support.annotation.Nullable;

import java.io.Serializable;
import java.util.List;

import it.pgp.xfiles.CopyListUris;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 05/06/17
 */

public class CompressParams implements Serializable {

    // direct input to compressArchive
    public BasePathContent srcDirectory;
    public BasePathContent destArchive;
    public Integer compressionLevel;
    public Boolean encryptHeaders;
    public Boolean solidMode;
    public String password;
    public List<String> filenames;

    public CopyListUris uris; // for content provider mode

    public boolean standaloneMode;

    public CompressParams(BasePathContent srcDirectory,
                          BasePathContent destArchive,
                          @Nullable Integer compressionLevel,
                          @Nullable Boolean encryptHeaders,
                          @Nullable Boolean solidMode,
                          @Nullable String password,
                          @Nullable List<String> filenames,
                          boolean standaloneMode) {
        this.srcDirectory = srcDirectory;
        this.destArchive = destArchive;
        this.compressionLevel = compressionLevel;
        this.encryptHeaders = encryptHeaders;
        this.solidMode = solidMode;
        this.password = password;
        this.filenames = filenames;
        this.standaloneMode = standaloneMode;
    }

    // constructor for content provider with uri list
    public CompressParams(CopyListUris uris,
                          BasePathContent destArchive,
                          @Nullable Integer compressionLevel,
                          @Nullable Boolean encryptHeaders,
                          @Nullable Boolean solidMode,
                          @Nullable String password,
                          boolean standaloneMode) {
        this.uris = uris;
        this.destArchive = destArchive;
        this.compressionLevel = compressionLevel;
        this.encryptHeaders = encryptHeaders;
        this.solidMode = solidMode;
        this.password = password;
        this.standaloneMode = standaloneMode;
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/params/CopyMoveParams.java`:

```java
package it.pgp.xfiles.service.params;

import android.content.ContentResolver;
import android.net.Uri;
import android.support.annotation.NonNull;

import java.io.Serializable;

import it.pgp.xfiles.CopyListUris;
import it.pgp.xfiles.CopyMoveListPathContent;
import it.pgp.xfiles.utils.ContentProviderUtils;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 23/06/17
 */

public class CopyMoveParams implements Serializable {
    public CopyMoveListPathContent list;
    public BasePathContent destPath;

    public CopyMoveParams(@NonNull CopyMoveListPathContent list, @NonNull BasePathContent destPath) {
        this.list = list;
        this.destPath = destPath;
    }

    public String getFirstFilename(ContentResolver resolver) {
        if (list instanceof CopyListUris)
            return ContentProviderUtils.getName(resolver,
                    Uri.parse(((CopyListUris)list).contentUris.get(0)));
        else
            return list.files.get(0).getFilename();
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/params/CreateFileParams.java`:

```java
package it.pgp.xfiles.service.params;

import java.io.Serializable;

import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class CreateFileParams implements Serializable {
    public BasePathContent path;
    public FileCreationAdvancedOptions opts;

    public CreateFileParams(BasePathContent path, FileCreationAdvancedOptions opts) {
        this.path = path;
        this.opts = opts;
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/params/DownloadParams.java`:

```java
package it.pgp.xfiles.service.params;

import java.io.Serializable;

/**
 * Created by pgp on 05/11/17
 */

public class DownloadParams implements Serializable {
    public String url; // in http download mode, it is the url to download from, in upload mode it is the domain to upload to
    public String destPath; // dir where to download remote file (LocalPathContent, unwrapped); in http upload mode, it is the source path to be uploaded
    public String filename; // desired filename, if null, will try to get remote filename
    public boolean httpsOnly;

    public DownloadParams(String url, String destPath, String filename, boolean httpsOnly) {
        this.url = url;
        this.destPath = destPath;
        this.filename = filename;
        this.httpsOnly = httpsOnly;
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/params/ExtractParams.java`:

```java
package it.pgp.xfiles.service.params;

import android.support.annotation.Nullable;

import java.io.Serializable;
import java.util.List;

import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 05/06/17
 */

public class ExtractParams implements Serializable {

    // direct input to extractArchive
    public List<BasePathContent> srcArchives; // subDir taken from here
    public BasePathContent destDirectory;
    public String password;
    public Iterable<String> filenames;
    public boolean smartDirectoryCreation;

    public ExtractParams(List<BasePathContent> srcArchives,
                         @Nullable BasePathContent destDirectory, // null when testing archive
                         @Nullable String password,
                         @Nullable Iterable<String> filenames,
                         boolean smartDirectoryCreation) {
        this.srcArchives = srcArchives;
        this.destDirectory = destDirectory;
        this.password = password;
        this.filenames = filenames;
        this.smartDirectoryCreation = smartDirectoryCreation;
    }

    public void setPassword(String password) {
        this.password = password;
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/params/FindParams.java`:

```java
package it.pgp.xfiles.service.params;

import android.support.annotation.Nullable;

import java.io.Serializable;

/**
 * Created by pgp on 11/12/17
 */

public class FindParams implements Serializable {

    public String targetFolder;
    public String expr;

    public FindParams(@Nullable String targetFolder, @Nullable String expr) {
        this.targetFolder = targetFolder;
        this.expr = expr;
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/params/TestParams.java`:

```java
package it.pgp.xfiles.service.params;

import android.support.annotation.Nullable;

import java.util.List;

import it.pgp.xfiles.utils.pathcontent.BasePathContent;

public class TestParams extends ExtractParams {
    public TestParams(List<BasePathContent> srcArchives, @Nullable String password, @Nullable List<String> filenames) {
        super(srcArchives, null, password, filenames, false);
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/visualization/MovingRibbon.java`:

```java
package it.pgp.xfiles.service.visualization;

/**
 * Created by pgp on 10/07/17
 * Overlay progress bar (in addition to the foreground service notification)
 */

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Pair;

public class MovingRibbon extends ProgressIndicator {

    public ProgressBar pb;
    public TextView pbSpeed;
    public TextView pbDataAmount;

    public long lastProgressTime;
    public Pair<Long,Long> lastProgress;

    public MovingRibbon(final Context context) {
        super(context);
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        oView = inflater.inflate(R.layout.ribbon_one, null);

        pb = oView.findViewById(R.id.pbInner);
        pbSpeed = oView.findViewById(R.id.pbSpeed);
        pbDataAmount = oView.findViewById(R.id.pbDataAmount);
        lastProgressTime = System.currentTimeMillis();

        pb.setMax(100);
        pb.setIndeterminate(false);
        pb.setBackgroundColor(0x6c00ff00);

        oView.setOnTouchListener(this);

        addViewToOverlay(oView, getDpHeightAdjustedParams(BASE_RIBBON_DP*2, ViewType.CONTAINER));

        topLeftView = new View(context);
        addViewToOverlay(topLeftView, ViewType.ANCHOR.getParams());
    }

    @Override
    public void setProgress(Pair<Long,Long>... values) {
        pb.setProgress((int) Math.round(values[0].i * 100.0 / values[0].j));
        if(lastProgress == null) {
            lastProgressTime = System.currentTimeMillis();
            lastProgress = values[0];
            pbSpeed.setText("0 Mbps");
        }
        else {
            long dt = lastProgressTime;
            lastProgressTime = System.currentTimeMillis();
            dt = lastProgressTime - dt;

            long ds = lastProgress.i;
            lastProgress = values[0];
            ds = lastProgress.i - ds;

            double speedMbps = ds/(dt*1000.0);
            // TODO can we have a single TextView, and a single String.format aligning speed at the start and data amount at line end?
            pbSpeed.setText(String.format("%.2f Mbps",speedMbps));
            pbDataAmount.setText(String.format("%.2f Mb",lastProgress.i/1000000.0));
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/visualization/MovingRibbonTwoBars.java`:

```java
package it.pgp.xfiles.service.visualization;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.widget.ProgressBar;
import android.widget.TextView;

import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Pair;

/**
 * Created by pgp on 10/07/17
 * Overlay with two progress bars (for showing file number and size progress)
 */

public class MovingRibbonTwoBars extends ProgressIndicator {

    public ProgressBar pbOuter;
    public ProgressBar pbInner; // outer progress: current number of files, inner: current size
    public TextView pbSpeed;
    public TextView pbDataAmount;

    public long lastProgressTime;
    public Pair<Long,Long> lastOuterProgress;

    public boolean recursive = false;

    public MovingRibbonTwoBars(Context context) {
        super(context);

        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        oView = inflater.inflate(R.layout.ribbon_two, null);

        pbOuter = oView.findViewById(R.id.pbOuter);
        pbInner = oView.findViewById(R.id.pbInner);
        pbSpeed = oView.findViewById(R.id.pbSpeed);
        pbDataAmount = oView.findViewById(R.id.pbDataAmount);
        lastProgressTime = System.currentTimeMillis();

        pbOuter.setMax(100);
        pbOuter.setIndeterminate(false);
        pbOuter.setBackgroundColor(0x880000ff);

        pbInner.setMax(100);
        pbInner.setIndeterminate(false);
        pbInner.setBackgroundColor(0x8800ff00);

        oView.setOnTouchListener(this);

        addViewToOverlay(oView, getDpHeightAdjustedParams(BASE_RIBBON_DP*3, ViewType.CONTAINER));

        topLeftView = new View(context);
        addViewToOverlay(topLeftView, ViewType.ANCHOR.getParams());
    }

    @Override
    public void setProgress(Pair<Long,Long>... values) {
        Pair<Long, Long> O = values[0];
        Pair<Long, Long> I = values[1];
        if(recursive)
            // in recursive mode, outer progress fraction sent by producer doesn't keep into account inner fraction,
            // so the latter is added to the first before converting to percentage
            // recursive mode is currently used only by multi archive extract/test
            pbOuter.setProgress((int) Math.round(100.0*((1.0*O.i / O.j) + (1.0*I.i/(I.j*O.j)))));
        else
            pbOuter.setProgress((int) Math.round(O.i * 100.0 / O.j));
        pbInner.setProgress((int) Math.round(values[1].i * 100.0 / values[1].j));

        if(lastOuterProgress == null) {
            lastProgressTime = System.currentTimeMillis();
            lastOuterProgress = values[0];
            pbSpeed.setText("0 Mbps");
        }
        else {
            long dt = lastProgressTime;
            lastProgressTime = System.currentTimeMillis();
            dt = lastProgressTime - dt;

            long ds = lastOuterProgress.i;
            lastOuterProgress = values[0];
            ds = lastOuterProgress.i - ds;

            double speedMbps = ds/(dt*1000.0);
            pbSpeed.setText(String.format("%.2f Mbps",speedMbps));
            // TODO show smooth progress also for recursive mode (read above)
            pbDataAmount.setText(String.format("%.2f Mb",lastOuterProgress.i/1000000.0));
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/visualization/ProgressIndicator.java`:

```java
package it.pgp.xfiles.service.visualization;

import android.content.Context;
import android.view.MotionEvent;
import android.view.View;
import android.view.WindowManager;

import java.util.concurrent.atomic.AtomicReference;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.ForegroundServiceType;
import it.pgp.xfiles.utils.Pair;

/**
 * Created by pgp on 21/08/17
 */

public abstract class ProgressIndicator implements View.OnTouchListener {

    public static final AtomicReference<ForegroundServiceType> busy = new AtomicReference<>(null);

    public static boolean acquire(ForegroundServiceType type) {
        return busy.compareAndSet(null,type);
    }

    public static void release() {
        busy.set(null);
    }

    public abstract void setProgress(Pair<Long,Long>... values);

    public void destroy() {
        try{ wm.removeView(oView); } catch(Throwable ignored) {}
        try{ wm.removeView(topLeftView); } catch(Throwable ignored) {}
    }

    public final Runnable destroyRef = this::destroy;
    protected final Context context;
    protected final WindowManager wm;
    protected View oView;
    protected View topLeftView;

    protected ProgressIndicator(Context context) {
        this.context = context;
        this.wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    }

    public void addViewToOverlay(View view, WindowManager.LayoutParams params) {
        try {wm.addView(view, params);}
        catch (Exception e) {
            e.printStackTrace();
            MainActivity.showToast("Unable to draw progress bar as system overlay, ensure you have granted overlay permissions");
        }
    }

    public static final int BASE_RIBBON_DP = 37;

    public WindowManager.LayoutParams getDpHeightAdjustedParams(int dp, ViewType v) {
        WindowManager.LayoutParams params = v.getParams();
        float pixels = dp * context.getResources().getDisplayMetrics().density;
        params.height = (int) pixels;
        return params;
    }

    private float offsetX;
    private float offsetY;
    private int originalXPos;
    private int originalYPos;
    private boolean moving;

    @Override
    public boolean onTouch(View v, MotionEvent event) {

        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            float x = event.getRawX();
            float y = event.getRawY();

            moving = false;

            int[] location = new int[2];
            v.getLocationOnScreen(location);

            originalXPos = location[0];
            originalYPos = location[1];

            offsetX = originalXPos - x;
            offsetY = originalYPos - y;

        }
        else if (event.getAction() == MotionEvent.ACTION_MOVE) {
            int[] topLeftLocationOnScreen = new int[2];
            topLeftView.getLocationOnScreen(topLeftLocationOnScreen);

//            Log.i("onTouch","topLeftY="+topLeftLocationOnScreen[1]);
//            Log.i("onTouch","originalY="+originalYPos);

            float x = event.getRawX();
            float y = event.getRawY();

            WindowManager.LayoutParams params = (WindowManager.LayoutParams) v.getLayoutParams();

            int newX = (int) (offsetX + x);
            int newY = (int) (offsetY + y);

            if (Math.abs(newX - originalXPos) < 1 && Math.abs(newY - originalYPos) < 1 && !moving) {
                return false;
            }

            params.x = newX - (topLeftLocationOnScreen[0]);
            params.y = newY - (topLeftLocationOnScreen[1]);

            wm.updateViewLayout(v, params);
            moving = true;
        }
        else if (event.getAction() == MotionEvent.ACTION_UP) {
            return moving;
        }

        return false;
    }
}

```

`app/src/main/java/it/pgp/xfiles/service/visualization/ViewOverlay.java`:

```java
package it.pgp.xfiles.service.visualization;

import android.content.Context;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.View;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.utils.Pair;
import it.pgp.xfiles.utils.popupwindow.PopupWindowUtils;

// actually NOT a ProgressIndicator, only reusing overlay logic, maybe ProgressIndicator itself should be renamed
public class ViewOverlay extends ProgressIndicator implements View.OnTouchListener {

    private GestureDetector gestureDetector;

    public ViewOverlay(Context context,
                       View builtView) {
        super(context);
        builtView.setOnTouchListener(this);
        this.oView = builtView;
        topLeftView = new View(context);
        MainActivity.handler.post(()->{
            gestureDetector = new GestureDetector(context, PopupWindowUtils.singleTapConfirm);
            addViewToOverlay(oView, ViewType.CONTAINER_WRAP.getParams());
            addViewToOverlay(topLeftView, ViewType.ANCHOR.getParams());
        });
    }

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        if (gestureDetector.onTouchEvent(event)) {
            MainActivity.handler.removeCallbacks(destroyRef);
            return true;
        }

        return super.onTouch(v, event);
    }

    @Override
    public void setProgress(Pair<Long,Long>... values) {}
}

```

`app/src/main/java/it/pgp/xfiles/service/visualization/ViewType.java`:

```java
package it.pgp.xfiles.service.visualization;

import android.graphics.PixelFormat;
import android.os.Build;
import android.view.Gravity;
import android.view.WindowManager;

import java.util.HashMap;
import java.util.Map;

public enum ViewType {

    CONTAINER,
    ANCHOR,
    CONTAINER_WRAP;

    public static final int OVERLAY_WINDOW_TYPE = (Build.VERSION.SDK_INT < 26)?
            WindowManager.LayoutParams.TYPE_SYSTEM_ALERT:
            WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY;

    static final Map<ViewType, WindowManager.LayoutParams> m;

    static {
        m = new HashMap<>();
        WindowManager.LayoutParams params = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.MATCH_PARENT,
                200,
                OVERLAY_WINDOW_TYPE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,
                PixelFormat.TRANSLUCENT);
        params.gravity = Gravity.START | Gravity.TOP;
        params.x = 0;
        params.y = 0;

        m.put(CONTAINER,params);

        params = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.WRAP_CONTENT,
                OVERLAY_WINDOW_TYPE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,
                PixelFormat.TRANSLUCENT);
        params.gravity = Gravity.START | Gravity.TOP;
        params.x = 0;
        params.y = 0;
        params.width = 0;
        params.height = 0;

        m.put(ANCHOR,params);

        params = new WindowManager.LayoutParams(
                WindowManager.LayoutParams.WRAP_CONTENT,
                WindowManager.LayoutParams.WRAP_CONTENT,
                OVERLAY_WINDOW_TYPE,
                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL,
                PixelFormat.TRANSLUCENT);
        params.gravity = Gravity.START | Gravity.TOP;
        params.x = 0;
        params.y = 0;

        m.put(CONTAINER_WRAP,params);
    }

    public WindowManager.LayoutParams getParams() {
        return m.get(this);
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/AuthData.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.support.annotation.Nullable;

import java.io.Serializable;

/**
 * Created by pgp on 11/02/17
 */
public class AuthData implements Serializable {

    // TODO when refactoring SmbAuthData as subclass of AuthData, remember to convert the "instanceof AuthData" checks against the subclass instead of the superclass

    public static final AuthData ref = new AuthData(null,null,0,null); // just for type checking in generic method

    public String username;
    public String domain;
    public int port;
    @Nullable public String password;

    // connection_id: user@domain:port
    public AuthData(String connection_id) {
        RuntimeException r = new RuntimeException("Invalid connection id");
        String[] s1 = connection_id.split("@");
        if (s1.length != 2) throw r;
        String[] s2 = s1[1].split(":");
        if (s2.length != 2) throw r;
        username = s1[0];
        domain = s2[0];
        try {
            port = Integer.parseInt(s2[1]);
        }
        catch (NumberFormatException n) {
            throw r;
        }
    }

    public AuthData(String username, String domain, int port, @Nullable String password) {
        this.username = username;
        this.domain = domain;
        this.port = port;
        this.password = password;
    }

    @Override
    public String toString() {
        return username + "@" + domain + ":" + port;
    }

    @Override
    public boolean equals(Object obj_) {
        if (!(obj_ instanceof AuthData)) return false;
        AuthData obj = (AuthData) obj_;
        boolean usernameE = false, domainE = false;
        if (username == null && obj.username == null) usernameE = true;
        else if (username != null && obj.username != null) {
            usernameE = username.equals(obj.username);
        }
        if (!usernameE) return false;

        if (domain == null && obj.domain == null) domainE = true;
        else if (domain != null && obj.domain != null) {
            domainE = domain.equals(obj.domain);
        }
        return domainE && this.port == obj.port;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        final int prime2 = 271;
        int hash1 = (this.username == null) ? 0 : this.username.hashCode();
        int hash2 = (this.domain == null) ? 0 : this.domain.hashCode();
        return prime2*((prime * (hash1 ^ hash2))^this.port);
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/CustomizedAndroidCipherSuiteConfig.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.util.Log;

import com.hierynomus.sshj.signature.SignatureEdDSA;
import com.hierynomus.sshj.transport.cipher.BlockCiphers;

import net.schmizz.sshj.DefaultConfig;
import net.schmizz.sshj.signature.SignatureDSA;
import net.schmizz.sshj.signature.SignatureRSA;
import net.schmizz.sshj.transport.random.JCERandom;
import net.schmizz.sshj.transport.random.SingletonRandomFactory;

import java.security.Security;

public class CustomizedAndroidCipherSuiteConfig
        extends DefaultConfig {

    static {
        Security.removeProvider("BC"); // disable Android's internal Bouncycastle provider (which has higher priority)
        int k = Security.insertProviderAt(new org.bouncycastle.jce.provider.BouncyCastleProvider(),1);
        Log.d(CustomizedAndroidCipherSuiteConfig.class.getName(),"BouncyCastle registered: "+k);
    }

    @Override
    protected void initSignatureFactories() {
        setSignatureFactories(
                new SignatureEdDSA.Factory(), // also valid for ed25519
                new SignatureRSA.Factory(),
                new SignatureDSA.Factory()); // original
//        setSignatureFactories(new SignatureECDSA.Factory()); // ECDSA not working - invalid key spec
    }

    @Override
    protected void initCipherFactories() {
        setCipherFactories(
                BlockCiphers.AES128CTR(),
                BlockCiphers.AES192CTR(),
                BlockCiphers.AES256CTR(),
                BlockCiphers.AES128CBC(),
                BlockCiphers.AES192CBC(),
                BlockCiphers.AES256CBC()
                );
    }

    @Override
    protected void initRandomFactory(boolean ignored) {
        setRandomFactory(new SingletonRandomFactory(new JCERandom.Factory()));
    }

}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/IdentitiesVaultAdapter.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.TextView;
import android.widget.Toast;

import net.schmizz.sshj.SSHClient;
import net.schmizz.sshj.common.KeyType;
import net.schmizz.sshj.common.SecurityUtils;
import net.schmizz.sshj.userauth.keyprovider.KeyProvider;

import java.io.File;
import java.io.FilenameFilter;
import java.util.ArrayList;
import java.util.List;

import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.Pair;

/**
 * Created by pgp on 12/02/17
 */

public class IdentitiesVaultAdapter extends BaseAdapter implements ListAdapter {
    private final VaultActivity vaultActivity;
    private final List<String> idsFilenames = new ArrayList<>();
    private final List<String> idsHashes = new ArrayList<>();
    private final List<String> idsTypes = new ArrayList<>();
    private final File idsDir;
    private final SSHClient clientForKeyParsing = new SSHClient();

    // TODO on choosing private key, if public one is present, copy it as well
    public static final FilenameFilter idFilter = (dir, name) -> {
        return !name.endsWith(".pub") && !name.equals("known_hosts"); // follow .ssh standard folder content (do not place known_hosts in another directory)
    };

    IdentitiesVaultAdapter(final VaultActivity vaultActivity) {
        this.vaultActivity = vaultActivity;
        idsDir = new File(vaultActivity.getFilesDir(), SFTPProvider.sshIdsDirName);
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return idsFilenames.size();
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

    @Override
    public View getView(final int position, final View convertView, ViewGroup parent) {
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) vaultActivity.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            view = inflater.inflate(R.layout.sftp_id_list_item, null);
        }
        String idFilename = idsFilenames.get(position);
        String idType = idsTypes.get(position);
        String idHash = idsHashes.get(position);

        //Handle TextView and display string from your list
        TextView filename = view.findViewById(R.id.sftp_id_listitem_filename);
        TextView type = view.findViewById(R.id.sftp_id_listitem_type);
        TextView hash = view.findViewById(R.id.sftp_id_listitem_hash);

        filename.setText(idFilename);
        type.setText(idType);
        hash.setText(idHash);

        //Handle buttons and add onClickListeners
        ImageButton showBtn = view.findViewById(R.id.sftp_id_listitem_show);
        ImageButton deleteBtn = view.findViewById(R.id.sftp_id_listitem_delete);

        showBtn.setOnClickListener(v -> new SSHKeyInfoDialog(vaultActivity,idsDir,idsFilenames.get(position)).show());
        deleteBtn.setOnClickListener(v -> {
            String prvkname = idsFilenames.get(position);
            String pubkname = prvkname+".pub";
            File f = new File(idsDir,prvkname);
            File g = new File(idsDir,pubkname);
            g.delete(); // public key may not be present, don't indicate error
            boolean deleted = f.delete();
            String message=deleted?"Deleted!":"Delete error";
            Toast.makeText(vaultActivity,message,Toast.LENGTH_SHORT).show();
            notifyDataSetChanged();
            vaultActivity.runOnUiThread(vaultActivity::showRefreshClientDialog);
        });

        return view;
    }

    @Override
    public void notifyDataSetChanged() {
        idsFilenames.clear();
        idsTypes.clear();
        idsHashes.clear();
        File[] files = idsDir.listFiles(idFilter);
        if (files != null) {
            for (File x : files) {
                idsFilenames.add(x.getName());
                Pair<KeyType, String> p = getKeyTypeAndPubkeyFingerprint(x);
                idsTypes.add(p.i.name());
                idsHashes.add(p.j);
            }
        }

        super.notifyDataSetChanged();
    }

    private Pair<KeyType,String> getKeyTypeAndPubkeyFingerprint(File f) {
        try {
            KeyProvider kprov = clientForKeyParsing.loadKeys(f.getAbsolutePath());
            String fingerprint = SecurityUtils.getFingerprint(kprov.getPublic());
            return new Pair<>(kprov.getType(), fingerprint);
        }
        catch(Exception e) {
            e.printStackTrace();
            return new Pair<>(KeyType.UNKNOWN,"");
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/InsertEditDialog.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.app.Dialog;
import android.content.Context;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.TextView;
import android.widget.Toast;

import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.smbclient.SmbAuthData;
import it.pgp.xfiles.smbclient.SmbVaultAdapter;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 11/02/17 (adapted from KeyGuard)
 * modified on 15/03/19 (common for both SFTP and SMB)
 */

public class InsertEditDialog extends Dialog {

    EditText user,domain,host,port,password;
    TextView hostLabel;
    Button okButton;
    GenericDBHelper dbh;

    final VaultAdapter vaultAdapter;

    public void setCommonDialogLayout(final Context context) {
        dbh = new GenericDBHelper(context);
        this.setContentView(R.layout.sftp_dialog_insert_item);
        this.setTitle("Remote credentials");

        user= findViewById(R.id.insertUsernameEditText);
        domain= findViewById(R.id.insertDomainEditText);
        host= findViewById(R.id.insertHostEditText);
        hostLabel= findViewById(R.id.insertHostLabel);
        port= findViewById(R.id.insertPortEditText);
        password = findViewById(R.id.insertPasswordEditText);

        if(vaultAdapter instanceof SmbVaultAdapter) {
            port.setText(R.string.smb_default_port);
            domain.setText(R.string.smb_default_domain);
        }
        else {
            hostLabel.setVisibility(View.GONE);
            host.setVisibility(View.GONE);
        }

        okButton = findViewById(R.id.insertItemOkButton);
    }

    // insert mode
    public InsertEditDialog(final Context context, final VaultAdapter vaultAdapter) {
        super(context);
        this.vaultAdapter = vaultAdapter;
        setCommonDialogLayout(context); // common layout initialization
        okButton.setOnClickListener(v -> {
            // insert row using DBHelper, then propagate the returned inserted entry to MainActivity
            try {
                Map.Entry<Long,?> entry =
                        dbh.insertCred(
                                vaultAdapter instanceof SmbVaultAdapter?SmbAuthData.ref:AuthData.ref,
                                user.getText().toString(),
                                domain.getText().toString(),
                                Integer.parseInt(port.getText().toString()),
                                password.getText().toString(),
                                vaultAdapter instanceof SmbVaultAdapter?new String[]{host.getText().toString()}:new String[]{});
                vaultAdapter.syncInsertFromDialog(entry.getKey(),entry.getValue());
                Toast.makeText(context,"Insert successful",Toast.LENGTH_SHORT).show();
            }
            catch (InsertFailedException e) {
                Toast.makeText(context,"Insert failed",Toast.LENGTH_SHORT).show();
            }
            dismiss();
        });
    }

    // edit mode
    public InsertEditDialog(final Context context, final VaultAdapter vaultAdapter, final long currentOid, final Object currentItem_) {
        super(context);
        this.vaultAdapter = vaultAdapter;
        setCommonDialogLayout(context); // common layout initialization

        // populate fields with current item content
        if(vaultAdapter instanceof SmbVaultAdapter) {
            SmbAuthData currentItem = (SmbAuthData)currentItem_;
            user.setText(currentItem.username);
            domain.setText(currentItem.domain);
            host.setText(currentItem.host);
            port.setText(currentItem.port+"");
            password.setText(currentItem.password);
        }
        else {
            AuthData currentItem = (AuthData)currentItem_;
            user.setText(currentItem.username);
            domain.setText(currentItem.domain);
            port.setText(currentItem.port+"");
            password.setText(currentItem.password);
        }

        okButton.setOnClickListener(v -> {

            // update only, leave oid unchanged

            Object newAuthData;
            if (vaultAdapter instanceof SmbVaultAdapter)
                newAuthData = new SmbAuthData(
                        user.getText().toString(),
                        domain.getText().toString(),
                        host.getText().toString(),
                        Integer.parseInt(port.getText().toString()),
                        password.getText().toString());
            else
                newAuthData = new AuthData(
                        user.getText().toString(),
                        domain.getText().toString(),
                        Integer.parseInt(port.getText().toString()),
                        password.getText().toString());

            if (dbh.updateCred(currentOid,newAuthData)) {
                // update visualization
                vaultAdapter.syncEditFromDialog(currentOid,currentOid,currentItem_,newAuthData);
                Toast.makeText(context,"Edit successful",Toast.LENGTH_SHORT).show();
            }
            else {
                Toast.makeText(context,"Edit failed",Toast.LENGTH_SHORT).show();
            }

            dismiss();
        });
    }
}


```

`app/src/main/java/it/pgp/xfiles/sftpclient/InsertFailedException.java`:

```java
package it.pgp.xfiles.sftpclient;

/**
 * Created by pgp on 11/02/17 (cloned from KeyGuard)
 */

public class InsertFailedException extends Exception {

    public InsertFailedException()  {
        super("Insert failed");
    }

}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/InteractiveHostKeyVerifier.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.util.Log;

import net.schmizz.sshj.transport.verification.OpenSSHKnownHosts;
import net.schmizz.sshj.common.KeyType;

import java.io.*;
import java.security.PublicKey;

/**
 * Created by pgp on 03/03/17
 */

public class InteractiveHostKeyVerifier extends OpenSSHKnownHosts {

    public static KnownHostEntry oldHostEntry;
    public static PublicKey currentHostKey;
    public static Boolean lastHostKeyHasChanged;

    public InteractiveHostKeyVerifier(File khFile) throws IOException {
        super(khFile);
    }

    @Override
    public boolean verify(final String hostname, final int port, final PublicKey key) {
        // reset current host key, if any, and changed state
        currentHostKey = null;
        lastHostKeyHasChanged = null;

        // DEBUG INFO
        Log.d(getClass().getName(),key.toString());
        Log.d(getClass().getName(),KeyType.fromKey(key).toString());
        Log.d(getClass().getName(),key.getAlgorithm());
        Log.d(getClass().getName(),key.getFormat());

        //////////////////////////////////////////

        final KeyType type = KeyType.fromKey(key);

        if (type == KeyType.UNKNOWN)
            return false;

        final String adjustedHostname = (port != 22) ? "[" + hostname + "]:" + port : hostname;

        // for (KnownHostEntry e : entries) { // sshj 0.23
        for (KnownHostEntry e : entries) {
            try {
                if (e.appliesTo(type, adjustedHostname)) {
                    if (e.verify(key)) return true;
                    // here, host key has changed
                    lastHostKeyHasChanged = true;
                    oldHostEntry = e;
                    currentHostKey = key;
//                    return hostKeyChangedAction(e, adjustedHostname, key); // sshj 0.21.2
                    return hostKeyChangedAction(adjustedHostname, key);
                }
            }
            catch (IOException ioe) {
                log.error("Error with {}: {}", e, ioe);
                return false;
            }
        }

        boolean result = hostKeyUnverifiableAction(adjustedHostname, key);
        if (result) return true;

        //////////////////////////////////////////

        // save current host key in static field and return false
        lastHostKeyHasChanged = false;
        currentHostKey = key;
        return false;
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/SFTPProvider.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.os.StrictMode;
import android.support.annotation.Nullable;
import android.util.Log;

import net.schmizz.sshj.common.Base64;
import net.schmizz.sshj.common.Buffer;
import net.schmizz.sshj.common.DisconnectReason;
import net.schmizz.sshj.common.KeyType;
import net.schmizz.sshj.sftp.FileAttributes;
import net.schmizz.sshj.sftp.OpenMode;
import net.schmizz.sshj.sftp.RemoteResourceInfo;
import net.schmizz.sshj.sftp.SFTPEngine;
import net.schmizz.sshj.sftp.StatefulSFTPClient;
import net.schmizz.sshj.transport.TransportException;
import net.schmizz.sshj.userauth.UserAuthException;
import net.schmizz.sshj.userauth.keyprovider.KeyProvider;
import net.schmizz.sshj.xfer.FilePermission;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.security.PublicKey;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Collections;
import java.util.Date;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.CopyMoveListPathContent;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.CopyMoveMode;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;
import it.pgp.xfiles.roothelperclient.resps.folderStats_resp;
import it.pgp.xfiles.service.BaseBackgroundTask;
import it.pgp.xfiles.utils.FileOperationHelper;
import it.pgp.xfiles.utils.GenericDBHelper;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.dircontent.SftpDirWithContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.SFTPPathContent;

/**
 * Created by pgp on 15/05/17
 * Updated on 03/11/17 (migration to custom XSFTP types for handling transfer progress)
 */

public class SFTPProvider implements FileOperationHelper {

    BaseBackgroundTask task;
    @Override
    public void initProgressSupport(BaseBackgroundTask task) {
        this.task = task;
    }

    @Override
    public void destroyProgressSupport() {
        task = null;
    }

    private final Map<String,XSFTPClient> channels = new ConcurrentHashMap<>(); // TODO to be renamed in clients
    private final Map<String,XSSHClient> xsshclients = new ConcurrentHashMap<>(); // needed for launching count files commands, 1 to 1 with channels

    private final File sshIdsDir;
    private File knownHostsFile;
    private GenericDBHelper dbh;

    static final String sshIdsDirName = ".ssh";
    static final String knownHostsFilename = "known_hosts"; // concat path with sshIdsDirName

    private static final int CONNECT_TIMEOUT_MS = 3000;
    private static final int CHANNEL_TIMEOUT_MS = 1000;

    private final List<File> identities = new ArrayList<>();
    private final MainActivity mainActivity;

    static {
        // TODO restructure code using AsyncTask and remove policy loosening
        StrictMode.setThreadPolicy(StrictMode.ThreadPolicy.LAX);
    }

    public void closeAllSessions() {
        for (XSFTPClient x : channels.values())
            try {x.close();} catch (Exception ignored) {}
        for (XSSHClient x : xsshclients.values())
            try {x.close();} catch (Exception ignored) {}

        // actually not needed, on next onCreate a SFTPProvider is created
//        channels.clear();
//        xsshclients.clear();
    }

    /********************* SSHJ methods ***************************************/

    // adds a host key to known_hosts
    public void addHostKey(String hostname, PublicKey key) throws IOException {
        String keyString = Base64.encodeBytes(new Buffer.PlainBuffer().putPublicKey(key).getCompactData());
        OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(knownHostsFile,true));
        outputStream.write((hostname+" "+ KeyType.fromKey(key)+" "+keyString+"\n").getBytes());
        outputStream.close();
    }

    // reads known_hosts line by line, copying lines to a new file, excluding
    // the one with the given host and host key (if present)
    // then it replaces the old with the new file
    public void removeHostKey(String adjustedHostname, PublicKey key) throws IOException {
        String keyString = Base64.encodeBytes(new Buffer.PlainBuffer().putPublicKey(key).getCompactData());
        String s = adjustedHostname + " " + KeyType.fromKey(key) + " " + keyString;
        BufferedReader r = new BufferedReader(new FileReader(knownHostsFile));
        File g = new File(knownHostsFile.getAbsolutePath()+"_new");
        BufferedWriter w = new BufferedWriter(new FileWriter(g));

        String line;
        while ((line = r.readLine()) != null) {
            if (!line.equals(s)) {
                w.write(line + "\n");
            }
        }
        r.close();
        w.close();

        if (knownHostsFile.delete() && g.renameTo(knownHostsFile))
            Log.d(getClass().getName(),"known_hosts updated");
        else
            Log.e(getClass().getName(),"error replacing old known_hosts file");
    }

    // replaces the key for the (possibly existing) pair (host, host key algorithm) with the current key
    // TODO string split by space and then split by ',' , hostnames can be concatenated for same algorithm and key (eg. IPs and relative hostnames)
    public void updateHostKey(String adjustedHostname, PublicKey key) throws IOException {
        String keyString = Base64.encodeBytes(new Buffer.PlainBuffer().putPublicKey(key).getCompactData());
        String s = adjustedHostname + " " + KeyType.fromKey(key);
        BufferedReader r = new BufferedReader(new FileReader(knownHostsFile));
        File g = new File(knownHostsFile.getAbsolutePath()+"_new");
        BufferedWriter w = new BufferedWriter(new FileWriter(g));

        String line;
        while ((line = r.readLine()) != null) {
            if (line.startsWith(s)) {
                w.write(s+" "+keyString);
            }
            else {
                w.write(line + "\n");
            }
        }
        r.close();
        w.close();

        if (knownHostsFile.delete() && g.renameTo(knownHostsFile))
            Log.d(getClass().getName(),"known_hosts updated");
        else
            Log.e(getClass().getName(),"error replacing old known_hosts file");
    }

    /************************************************************/

    public SFTPProvider(final MainActivity mainActivity) {
        this.mainActivity = mainActivity;
        sshIdsDir = new File(mainActivity.getApplicationContext().getFilesDir(),sshIdsDirName);
        if (!sshIdsDir.exists()) sshIdsDir.mkdirs();
        knownHostsFile = new File(sshIdsDir,knownHostsFilename);
        if (!knownHostsFile.exists()) try {
            knownHostsFile.createNewFile();
        } catch (IOException e) {
            Log.e(getClass().getName(),"Cannot create known_hosts file");
        }

        identities.clear();
        identities.addAll(Arrays.asList(sshIdsDir.listFiles(IdentitiesVaultAdapter.idFilter)));
        dbh = new GenericDBHelper(mainActivity.getApplicationContext());
        channels.clear();
    }

    // better version of getChannel
    // input: SFTPPathContent without dir
    // output: SFTPPathContent with default (home) dir (stat(.) after login) or with FileOpsErrorCodes error
    public SFTPPathContent tryConnectAndGetPath(SFTPPathContent path) {
        // try to get channel, if already connected
        XSFTPClient cSFTP = channels.get(path.authData.toString());

        if (cSFTP != null) { // connection already active, stat home dir in order to get its pathname
            try {
                String fullPath = cSFTP.canonicalize("."); // TODO check if canonicalize works
                return new SFTPPathContent(path.authData,fullPath);
            } catch (IOException e) {
                e.printStackTrace();
                return new SFTPPathContent(path.authData,FileOpsErrorCodes.SFTP_PATH_CANONICALIZE_ERROR);
            }
        }

        XSSHClient c = null;
        try {
            // if not connected
            // try to open a session using all possible identities, and password if available
            c = new XSSHClient(new CustomizedAndroidCipherSuiteConfig());
            c.addHostKeyVerifier(new InteractiveHostKeyVerifier(knownHostsFile));
            AuthData dbData = dbh.find(path.authData);
            if (dbData != null) // found (not necessarily with password)
                path.authData = dbData;

            c.setConnectTimeout(CONNECT_TIMEOUT_MS);
            c.setTimeout(CHANNEL_TIMEOUT_MS);
            c.connect(path.authData.domain,path.authData.port);

            // try auth with every available identity
            if (identities != null && identities.size() != 0) {
                for (File i : identities) {
                    KeyProvider keys = c.loadKeys(i.getAbsolutePath());
                    try {
                        c.authPublickey(path.authData.username,keys);
                        Log.d(getClass().getName(),"Successfully authenticated using private key: "+i.getName());
                        break;
                    }
                    catch (UserAuthException e) {
                        // auth error with the given identity
                        continue;
                    }
                }
            }

            // if every identity-based authentication has failed, try with password (if any)
            if (!c.isAuthenticated() && path.authData.password != null) {
                try {
                    c.authPassword(path.authData.username,path.authData.password);
                }
                catch (UserAuthException ignored) {}
            }

            // exhausted auth methods, no valid credentials found
            if (!c.isAuthenticated()) {
                return new SFTPPathContent(path.authData,FileOpsErrorCodes.AUTHENTICATION_ERROR);
            }

            cSFTP = c.newXSFTPClient();
            if (cSFTP != null) { // SFTP channel successfully created
                channels.put(path.authData.toString(),cSFTP);
                xsshclients.put(path.authData.toString(),c);
                try {
                    String fullPath = cSFTP.canonicalize("."); // TODO check if canonicalize works
                    return new SFTPPathContent(path.authData,fullPath);
                } catch (IOException e) {
                    e.printStackTrace();
                    return new SFTPPathContent(path.authData,FileOpsErrorCodes.SFTP_PATH_CANONICALIZE_ERROR);
                }
            }
            else return new SFTPPathContent(path.authData,FileOpsErrorCodes.CONNECTION_ERROR);
        }
        catch(TransportException e) {
            if (e.getDisconnectReason() == DisconnectReason.HOST_KEY_NOT_VERIFIABLE) {
                if (InteractiveHostKeyVerifier.lastHostKeyHasChanged != null){
                    if (InteractiveHostKeyVerifier.lastHostKeyHasChanged) {
                        return new SFTPPathContent(path.authData,FileOpsErrorCodes.HOST_KEY_CHANGED_ERROR);
                    } else {
                        return new SFTPPathContent(path.authData,FileOpsErrorCodes.HOST_KEY_INEXISTENT_ERROR);
                    }
                }
            }
            else {
                Log.e(getClass().getName(),"transport exception in getChannel: "+e.getMessage());
            }
        }
        catch (IOException e) {
            Log.e(getClass().getName(),"getChannel error");
        }

        // in any failure case, close connection with SSH server and return null
        try {
            cSFTP.close();
            c.disconnect();
        }
        catch (IOException|NullPointerException ignored) {}
        return new SFTPPathContent(path.authData,FileOpsErrorCodes.CONNECTION_ERROR);
    }

    public XSFTPClient getChannelIfAlreadyExists(AuthData authData) throws IOException {
        XSFTPClient cSFTP = channels.get(authData.toString());
        if (cSFTP == null) throw new IOException("No remote channel currently opened for the given remote path");
        return cSFTP;
    }

    /**
     * pendingLsPath: path for doing again ls request in dialog dismiss listener
     * on resolvable failure (host key added/updated, auth retry)
     * Only LS allowed (if starting request is create file or dir (which invokes exists/ is dir)
     * simply show toast error message and don't propagate request
     */
    public Object getChannel(AuthData authData, BasePathContent pendingLsPath) {
        // try to get channel, if already connected
        XSFTPClient cSFTP = channels.get(authData.toString());
        if (cSFTP != null) return cSFTP;
        XSSHClient c = null;

        try {
            // if not connected
            // try to open a session using all possible identities, and password if available
            c = new XSSHClient(new CustomizedAndroidCipherSuiteConfig());
            c.addHostKeyVerifier(new InteractiveHostKeyVerifier(knownHostsFile));

            AuthData completeData = (authData.password == null)?dbh.find(authData):authData;
            if (completeData != null) // found (not necessarily with password)
                authData = completeData;

            c.setConnectTimeout(100000); // 100 seconds timeout for debugging
//            c.setConnectTimeout(CONNECT_TIMEOUT_MS);
//            c.setTimeout(CHANNEL_TIMEOUT_MS);
            c.connect(authData.domain,authData.port);

            // try auth with every available identity
            if (identities != null && identities.size() != 0) {
                for (File i : identities) {
                    KeyProvider keys = c.loadKeys(i.getAbsolutePath());
                    try {
                        c.authPublickey(authData.username,keys);
                        Log.d(getClass().getName(),"Successfully authenticated using private key: "+i.getName());
                        break;
                    }
                    catch (UserAuthException e) {
                        // auth error with the given identity
                        continue;
                    }
                }
            }

            // if every identity-based authentication has failed, try with password (if any)
            if (!c.isAuthenticated() && authData.password != null) {
                try {
                    c.authPassword(authData.username,authData.password);
                }
                catch (UserAuthException ignored) {}
            }

            // No valid auth found
            if (!c.isAuthenticated()) {
                return FileOpsErrorCodes.AUTHENTICATION_ERROR;
            }
            cSFTP = c.newXSFTPClient();
            channels.put(authData.toString(),cSFTP);
            xsshclients.put(authData.toString(),c);
            // no sessionConnectRunnable for now
            return cSFTP;
        }
        catch(TransportException e) {
            if (e.getDisconnectReason() == DisconnectReason.HOST_KEY_NOT_VERIFIABLE) {
                if (InteractiveHostKeyVerifier.lastHostKeyHasChanged != null && pendingLsPath != null){
                    if (InteractiveHostKeyVerifier.lastHostKeyHasChanged) {
                        // show "last host key changed" dialog, containing current getChannel input parameter
                        return FileOpsErrorCodes.HOST_KEY_CHANGED_ERROR;
                    }
                    else {
                        // show "add host key" dialog, containing current getChannel input parameter
                        return FileOpsErrorCodes.HOST_KEY_INEXISTENT_ERROR;
                    }
                }
                 // any way, won't get a list dir response at this request, dismiss listeners in dialogs will do the job by calling main activity methods
            }
            else {
                Log.e(getClass().getName(),"transport exception in getChannel: "+e.getMessage());
            }
        }
        catch (IOException e) {
            Log.e(getClass().getName(),"getChannel error");
        }

        // in any failure case, close connection with SSH server and return null
        try {
            cSFTP.close();
            c.disconnect();
        }
        catch (IOException|NullPointerException ignored) {}
        return FileOpsErrorCodes.CONNECTION_ERROR;
    }

    @Override
    public String createFileOrDirectory(BasePathContent filePath, FileMode fileOrDirectory, FileCreationAdvancedOptions... unused) throws IOException {
        SFTPPathContent g = (SFTPPathContent) filePath;

        // try to get channel, using prefix from last GenericRemotePath object
        Object channelSftp_ = getChannel(g.authData,null);
        if (channelSftp_ instanceof FileOpsErrorCodes) throw new IOException("No channel found, error is "+((FileOpsErrorCodes) channelSftp_).name());
        XSFTPClient channelSftp = (XSFTPClient) channelSftp_;

        if (exists(filePath))
            throw new IOException("File already exists"); // FIXME temporary, remove once changed Fileopshelper interface to boolean return values

        switch (fileOrDirectory) {
            case FILE:
                channelSftp.open(g.dir, EnumSet.of(OpenMode.CREAT));
//                    channelSftp.put("/dev/null",g.remotePath); // not working with dev null
                break;
            case DIRECTORY:
                channelSftp.mkdir(g.dir);
                break;
            default:
                throw new RuntimeException("Unknown file mode");
        }
        return null;
    }

    @Override
    public void createLink(BasePathContent originPath, BasePathContent linkPath, boolean isHardLink) throws IOException {
        SFTPPathContent originPath_,linkPath_;
        try {
            originPath_ = (SFTPPathContent) originPath;
            linkPath_ = (SFTPPathContent) linkPath;
        }
        catch (ClassCastException e) {
            throw new IOException("Only SFTP paths allowed from here");
        }
        if (!originPath_.authData.equals(linkPath_.authData)) throw new IOException("Origin and link must belong to the same SFTP remote filesystem");

        // try to get channel, using prefix from last GenericRemotePath object
        Object channelSftp_ = getChannel(originPath_.authData,null);
        if (channelSftp_ instanceof FileOpsErrorCodes) throw new IOException("No channel found, error is: "+((FileOpsErrorCodes) channelSftp_).name());
        XSFTPClient channelSftp = (XSFTPClient) channelSftp_;

        if (isHardLink) throw new IOException("SFTP Hard links currently not supported");
        channelSftp.symlink(linkPath_.dir,originPath_.dir);
    }

    private void recursiveFolderDelete(SFTPEngine channelSftp_, String path) throws IOException {
        StatefulSFTPClient channelSftp = new StatefulSFTPClient(channelSftp_);
        channelSftp.cd(path); // Change Directory on SFTP Server
        // List source directory structure.
        List<RemoteResourceInfo> fileAndFolderList;
        try {
            fileAndFolderList = channelSftp.ls(path);
        }
        catch (IOException e) {
            return; // folder to be deleted does not exist
        }
        // Iterate objects in the list to get file/folder names.
        for (RemoteResourceInfo item : fileAndFolderList) {
            // If it is a file (not a directory).
            if (item.getAttributes().getType() != net.schmizz.sshj.sftp.FileMode.Type.DIRECTORY) {
                channelSftp.rm(path + "/" + item.getName()); // Remove file.
            }
            else if (!(".".equals(item.getName()) || "..".equals(item.getName()))) { // If it is a subdir.
                recursiveFolderDelete(channelSftp.getSFTPEngine(), path + "/" + item.getName()); // remove listable content first
            }
        }
        channelSftp.rmdir(path); // try to delete the parent directory if emptied successfully
    }

    @Override
    public void deleteFilesOrDirectories(List<BasePathContent> files) throws IOException {
        SFTPPathContent g = null;
        List<String> remotePaths = new ArrayList<>();

        for (BasePathContent x : files) {
            try {
                // parse generic path
                g = (SFTPPathContent)x;
                remotePaths.add(g.dir);
            }
            catch (RuntimeException r) {
                throw new IOException("Malformed path: "+g.toString());
            }
        }
        // try to get channel, using prefix from last GenericRemotePath object
        Object channelSftp_ = getChannel(g.authData,null); // assuming all paths in browseradapter selection having authdata in common
        if (channelSftp_ instanceof FileOpsErrorCodes) throw new IOException("No channel found, error: "+((FileOpsErrorCodes) channelSftp_).name());
        XSFTPClient channelSftp = (XSFTPClient) channelSftp_;

        FileAttributes attrs;
        for (String x : remotePaths) {
            try {
                attrs = channelSftp.stat(x);
//                Log.d(getClass().getName(),"item name: "+x+"\tattr type: "+attrs.getType());
                if (attrs.getType() == net.schmizz.sshj.sftp.FileMode.Type.DIRECTORY)
                     recursiveFolderDelete(channelSftp.getSFTPEngine(),x);
                else channelSftp.rm(x);
            }
            catch (IOException e) {
                Log.e(getClass().getName(),"Unable to delete element "+x);
                throw new IOException("Unable to delete element "+x);
            }
        }
    }

    @Override
    public void copyMoveFilesToDirectory(CopyMoveListPathContent files, BasePathContent dstFolder) throws IOException {
        // needs collaboration of fileopshelper handling operations on files in source folder,
        // discriminate based on prefix (like dircommander performs dispatching)
        // (e.g. local, or other channel in SFTPProvider for remote-to-local-to-remote copy)
        // most interesting case: remote-to-remote copy (protocol-level sftp)

        // supported operations: upload (files from local path, dstFolder remote) and download
        // (files remote, dstFolder local)
        // TODO on download, try listing dstFolder in order to check access on dstFolder

        if (files.parentDir.providerType == ProviderType.LOCAL && dstFolder.providerType == ProviderType.SFTP) {
            // upload (assumes remote directory already listed (connection already open))
            XSFTPClient sftpClient = getChannelIfAlreadyExists(((SFTPPathContent)dstFolder).authData);

            // legacy, without progress & service support
//            for (String localItem : files)
//                sftpClient.put(localItem,dstFolder.dir+"/");

            // with progress & service support
            // for safety, reset progress before counting files
            XProgress xp = (XProgress) task.mr;
            xp.clear();
            sftpClient.setProgressIndicator(xp);

            // count local files via local roothelper or xfilesopshelper and set them in xprogress
//            long totalLocalFiles = 0;
            long totalLocalSize = 0;
            for (BrowserItem localItem : files.files) {
                BasePathContent bpc = files.parentDir.concat(localItem.getFilename());
                if (MainActivity.xFilesUtils.isDir(bpc)) {
                    folderStats_resp fsr = MainActivity.xFilesUtils.statFolder(bpc);
//                    totalLocalFiles+=fsr.totalFiles;
//                    totalLocalFiles+=fsr.totalDirs;
                    totalLocalSize+=fsr.totalSize;
                }
                else {
//                    totalLocalFiles++;
                    totalLocalSize+=MainActivity.xFilesUtils.statFile(bpc).size;
                }
            }

            xp.totalFilesSize = totalLocalSize;
            xp.isDetailedProgress = true;
            for (BrowserItem localItem : files.files)
                sftpClient.put(files.parentDir.concat(localItem.getFilename()).toString(),dstFolder.dir+"/"+localItem.getFilename());
        }
        else if (files.parentDir.providerType == ProviderType.SFTP && dstFolder.providerType == ProviderType.LOCAL) {
            // download
            AuthData authData = ((SFTPPathContent)files.parentDir).authData;
            XSFTPClient sftpClient = getChannelIfAlreadyExists(authData);
            XSSHClient xsshClient = xsshclients.get(authData.toString()); // needed for remote file counting, must exist if the previous line doesn't throw exception
            if (xsshClient == null) throw new IOException("Unexpected null: xsshclient");

            XProgress xp = (XProgress) task.mr;
            xp.clear();
            sftpClient.setProgressIndicator(xp);


            // LEGACY
//            xp.totalFiles = xsshClient.countTotalRegularFilesInItems(files.getSFTPProgressHelperIterable());
//            if (xp.totalFiles < 0) {
//                MainActivity.showToastOnUIWithHandler("Unable to count remote files, external progress will not be available");
//                xp.totalFiles = Long.MAX_VALUE;
//            }

            // first attempt: launch external commands (du, python, dir) to count remote files
            long totalRemoteSize = xsshClient.countTotalSizeInItems(files.getSFTPProgressHelperIterableFilenamesOnly(),files.parentDir.dir);
            if (totalRemoteSize <= 0) {
                MainActivity.showToast("All external commands for remote size count failed, external progress won't be available");
                xp.totalFiles = Long.MAX_VALUE;
            }
            else {
                xp.totalFilesSize = totalRemoteSize;
                xp.isDetailedProgress = true;
            }

            for (BrowserItem remoteItemName : files.files) { // iterator over filenames only
                // remote dir as local path string
                // ending "/" in order to paste a folder as a child of the destination folder
                sftpClient.get(files.parentDir.dir+"/"+remoteItemName.getFilename(),dstFolder.dir+"/");
            }
        }
        else if (files.parentDir.providerType == ProviderType.SFTP && dstFolder.providerType == ProviderType.SFTP) {
            if (files.copyOrMove==CopyMoveMode.MOVE) {
                if (((SFTPPathContent)files.parentDir).authData.equals(((SFTPPathContent)dstFolder).authData)) {
                    XSFTPClient sftpClient = getChannelIfAlreadyExists(((SFTPPathContent)files.parentDir).authData);

                    for (BrowserItem remoteItemName : files.files) { // iterator over filenames only
                        // remote dir as local path string
                        sftpClient.rename(files.parentDir.dir+"/"+remoteItemName.getFilename(),dstFolder.dir+"/"+remoteItemName.getFilename());
                    }
                }
                else {
                    throw new IOException("Unsupported remote-to-remote copy on the same host (only move)");
                }
            }
            else {
                throw new IOException("Unsupported remote-to-remote copy");
            }
        }
        else throw new IOException("Unsupported remote transfer");
    }

    @Override
    public boolean renameFile(BasePathContent oldPathname, BasePathContent newPathname) throws IOException {
        try {
            SFTPPathContent oldPathname_ = (SFTPPathContent) oldPathname;
            SFTPPathContent newPathname_ = (SFTPPathContent) newPathname;
            if (!oldPathname_.authData.equals(newPathname_.authData))
                throw new IOException("Rename paths must belong to the same remote filesystem");

            XSFTPClient sftpClient = channels.get(oldPathname_.authData.toString());
            // copying assumes remote directory already listed (connection already open)
            if (sftpClient == null) throw new IOException("No remote channel currently opened for the given remote path");
            sftpClient.rename(oldPathname_.dir,newPathname_.dir);
            return true; // not really indicative here, SSHJ does not return value for rename
        }
        catch (ClassCastException c) {
            throw new IOException("Both paths have to be remote for renaming");
        }
    }

    public String getPermString(Set<FilePermission> s, boolean isDir) {
        String p = isDir?"d":"-";

        p += s.contains(FilePermission.USR_R)?"r":"-";
        p += s.contains(FilePermission.USR_W)?"w":"-";
        p += s.contains(FilePermission.USR_X)?"x":"-";
        p += s.contains(FilePermission.GRP_R)?"r":"-";
        p += s.contains(FilePermission.GRP_W)?"w":"-";
        p += s.contains(FilePermission.GRP_X)?"x":"-";
        p += s.contains(FilePermission.OTH_R)?"r":"-";
        p += s.contains(FilePermission.OTH_W)?"w":"-";
        p += s.contains(FilePermission.OTH_X)?"x":"-";

        return p;
    }

    @Override
    public SingleStatsItem statFile(BasePathContent pathname) throws IOException {
        SFTPPathContent g = (SFTPPathContent) pathname;

        // try to get channel
        Object channelSftp_ = getChannel(g.authData,null);
        if (channelSftp_ instanceof FileOpsErrorCodes) throw new IOException(((FileOpsErrorCodes) channelSftp_).name()); // abuse of notation

        FileAttributes attrs = ((XSFTPClient)channelSftp_).stat(g.dir);

        return new SingleStatsItem(
                (attrs.getGID()+""), // TODO group string instead of id
                (attrs.getUID()+""), // TODO owner string instead of id
                new Date(0L), // creation time not available
                new Date(attrs.getAtime()*1000L),
                new Date(attrs.getMtime()*1000L),
                getPermString(attrs.getPermissions(),
                        attrs.getType() == net.schmizz.sshj.sftp.FileMode.Type.DIRECTORY),
                attrs.getSize()
        );
    }

    @Override
    public folderStats_resp statFiles(List<BasePathContent> files) throws IOException {
        folderStats_resp resp = new folderStats_resp();
        AuthData a = ((SFTPPathContent) files.get(0)).authData;
        // try to get channel
        Object channelSftp_ = getChannel(a,null);
        if (channelSftp_ instanceof FileOpsErrorCodes) throw new IOException(((FileOpsErrorCodes) channelSftp_).name()); // abuse of notation
        XSFTPClient xsftp = (XSFTPClient) channelSftp_;
        XSSHClient xssh = xsshclients.get(a.toString());
        if(xssh == null) return null;

        for(BasePathContent file : files) {
            SFTPPathContent rpc = (SFTPPathContent) file;
            FileAttributes attrs = xsftp.stat(rpc.dir);
            switch(attrs.getType()) {
                case REGULAR:
                    resp.totalSize += attrs.getSize();
                    resp.totalFiles++;
                    break;
                case DIRECTORY:
                    try {
                        folderStats_resp fs = xssh.statFoldersInPaths(new AbstractMap.SimpleEntry<>(rpc.dir,true));
                        if(fs.totalDirs!=0) fs.totalDirs--; // exclude current directory from find results
                        resp.totalFiles += fs.totalFiles;
                        resp.totalDirs += fs.totalDirs;

                        List<RemoteResourceInfo> lsContent = ((XSFTPClient)channelSftp_).ls(rpc.dir);

                        for (RemoteResourceInfo entry : lsContent) {
                            FileAttributes fa = entry.getAttributes();
                            if (fa.getType() == net.schmizz.sshj.sftp.FileMode.Type.DIRECTORY)
                                resp.childrenDirs++;
                            else resp.childrenFiles++;
                        }
                    }
                    catch (IOException e) {
                        e.printStackTrace();
                    }

                    // total size
                    resp.totalSize += xssh.countTotalSizeInItems(
                            Collections.singletonList(new AbstractMap.SimpleEntry<>(rpc.dir, null)),
                            rpc.getParent().dir);
                    break;
                default:
                    break;
            }
        }

        return resp;
    }

    @Override
    public folderStats_resp statFolder(BasePathContent pathname) throws IOException {
        if (!(pathname instanceof SFTPPathContent)) throw new IOException("Wrong path content type");
        SFTPPathContent rpc = (SFTPPathContent) pathname;
        XSSHClient xsshClient = xsshclients.get(rpc.authData.toString());
        if (xsshClient==null) return null;

        // all items
        folderStats_resp fs = xsshClient.statFoldersInPaths(new AbstractMap.SimpleEntry<>(pathname.dir,true));
        if(fs.totalDirs!=0) fs.totalDirs--; // exclude current directory from find results

        // children items
        SFTPPathContent g = (SFTPPathContent) pathname;
        Object channelSftp_ = getChannel(g.authData,null);
        if (channelSftp_ instanceof FileOpsErrorCodes) return fs;
        try {
            List<RemoteResourceInfo> lsContent = ((XSFTPClient)channelSftp_).ls(g.dir);

            for (RemoteResourceInfo entry : lsContent) {
                FileAttributes fa = entry.getAttributes();
                if (fa.getType() == net.schmizz.sshj.sftp.FileMode.Type.DIRECTORY)
                    fs.childrenDirs++;
                else fs.childrenFiles++;
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }

        // total size
        fs.totalSize = xsshClient.countTotalSizeInItems(
                Collections.singletonList(new AbstractMap.SimpleEntry<>(pathname.dir, null)),
                pathname.getParent().dir);

        return fs;
    }

    @Override
    public boolean exists(BasePathContent pathname) {
        SFTPPathContent g = (SFTPPathContent) pathname;

        // try to get channel
        Object channelSftp_ = getChannel(g.authData,null);
        if (channelSftp_ instanceof FileOpsErrorCodes) return false; // abuse of notation
        try {
            FileAttributes fa = ((XSFTPClient)channelSftp_).statExistence(g.dir);
            return fa != null;
        }
        catch (IOException e) {
            return false;
        }
    }

    @Override
    public boolean isFile(BasePathContent pathname) {
        return !isDir(pathname); // not used for now
    }

    @Override
    public boolean isDir(BasePathContent pathname) {
        SFTPPathContent g = (SFTPPathContent) pathname;

        // try to get channel
        Object channelSftp_ = getChannel(g.authData,null);
        if (channelSftp_ instanceof FileOpsErrorCodes) return false; // abuse of notation

        try {
            FileAttributes fa = ((XSFTPClient)channelSftp_).stat(g.dir);
            return fa.getType() == net.schmizz.sshj.sftp.FileMode.Type.DIRECTORY;
        }
        catch (IOException e) {
            return false;
        }
    }

    @Override
    public byte[] hashFile(BasePathContent pathname,
                           HashRequestCodes hashAlgorithm,
                           BitSet dirHashOpts) throws IOException {
        return new byte[0];
    }

    @Override
    public GenericDirWithContent listDirectory(BasePathContent directory) {
        SFTPPathContent g = (SFTPPathContent) directory;

        // try to get channel
        Object channelSftp_ = getChannel(g.authData,directory);
        if (channelSftp_ instanceof FileOpsErrorCodes) {
            FileOpsErrorCodes fe = (FileOpsErrorCodes) channelSftp_;
            return new SftpDirWithContent(g.authData, fe,
                    (fe==FileOpsErrorCodes.HOST_KEY_CHANGED_ERROR ||
                            fe==FileOpsErrorCodes.HOST_KEY_INEXISTENT_ERROR)?
                            directory.dir:null);
        }
        XSFTPClient channelSftp = (XSFTPClient) channelSftp_;

        // list dir
        try {
            List<RemoteResourceInfo> lsContent = channelSftp.ls(g.dir);
            List<BrowserItem> l = new ArrayList<>();

            for (RemoteResourceInfo entry : lsContent) {
                boolean isLink = false;
                try {
                    FileAttributes fa = entry.getAttributes();
                    if (fa.getType() == net.schmizz.sshj.sftp.FileMode.Type.SYMLINK) {
                        isLink = true;
                        fa = channelSftp.stat(g.dir+"/"+entry.getName());
                    }

                    l.add(new BrowserItem(entry.getName(),
                            fa.getSize(),
                            new Date(fa.getMtime()*1000L),
                            fa.getType() == net.schmizz.sshj.sftp.FileMode.Type.DIRECTORY,
                            isLink));
                }
                catch(Exception e) {
                    e.printStackTrace();
                    Log.e(getClass().getName(),"skipping inaccessible entry: "+entry.getName());
                }
            }

            return new SftpDirWithContent(g.authData,directory.dir,l);
        }
        catch (IOException e) {
            return new SftpDirWithContent(g.authData,FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS,null);
        }
    }

    @Override
    public GenericDirWithContent listArchive(BasePathContent archivePath) {
        return new GenericDirWithContent(FileOpsErrorCodes.NOT_IMPLEMENTED);
    }

    @Override
    public int compressToArchive(BasePathContent srcDirectory,
                                  BasePathContent destArchive,
                                  Integer compressionLevel,
                                  Boolean encryptHeaders,
                                  Boolean solidMode,
                                  String password,
                                  List<String> filenames) throws IOException {
        return -1; // not implemented
    }

    @Override
    public List<FileOpsErrorCodes> extractFromArchive(List<BasePathContent> srcArchives,
                                                BasePathContent destDirectory,
                                                @Nullable String password,
                                                @Nullable Iterable<String> filenames,
                                                boolean smartDirectoryCreation) throws IOException {
        return Collections.singletonList(FileOpsErrorCodes.NOT_IMPLEMENTED);
    }

    @Override
    public int setDates(BasePathContent file, @Nullable Date accessDate, @Nullable Date modificationDate) {
        return -1;
    }

    @Override
    public int setPermissions(BasePathContent file, int permMask) {
        return -1;
    }

    @Override
    public int setOwnership(BasePathContent file, @Nullable Integer ownerId, @Nullable Integer groupId) {
        return -1;
    }

}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/SSHKeyInfoDialog.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.app.Dialog;
import android.support.annotation.NonNull;
import android.view.View;
import android.view.Window;
import android.widget.TextView;
import android.widget.Toast;

import net.schmizz.sshj.SSHClient;
import net.schmizz.sshj.common.KeyType;
import net.schmizz.sshj.userauth.keyprovider.KeyProvider;

import java.io.File;
import java.security.PublicKey;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.SSHKnownHostsBaseDialog;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

public class SSHKeyInfoDialog extends Dialog {

    private final File idsDir;
    private final String idFilename;
    private final VaultActivity vaultActivity;

    SSHKeyInfoDialog(@NonNull VaultActivity vaultActivity, File idsDir, String idFilename) {
        super(vaultActivity);
        requestWindowFeature(Window.FEATURE_NO_TITLE);
        this.vaultActivity = vaultActivity;
        this.idsDir = idsDir;
        this.idFilename = idFilename;
        setContentView(R.layout.ssh_key_info_dialog);

        try {
            KeyProvider kprov = new SSHClient().loadKeys(new File(idsDir, idFilename).getAbsolutePath());
            PublicKey key = kprov.getPublic();
            ((TextView)(findViewById(R.id.sshKeyInfoTypeTextView))).setText(
                    KeyType.fromKey(key)+" "+key.getAlgorithm()+" "+key.getFormat());
            ((TextView)(findViewById(R.id.sshKeyInfoFingerprintTextView))).setText(
                    SSHKnownHostsBaseDialog.getHostkeyFingerprint(key)
            );
            findViewById(R.id.sshKeyInfoLocateButton).setOnClickListener(this::locateKey);
        }
        catch(Exception e) {
            e.printStackTrace();
            Toast.makeText(vaultActivity, "Unable to retrieve key information", Toast.LENGTH_SHORT).show();
            dismiss();
        }
    }

    private void locateKey(View unused) {
        MainActivity.mainActivity.goDir(
                new LocalPathContent(idsDir.getAbsolutePath()),
                MainActivity.mainActivity.browserPager.getCurrentItem(),
                idFilename
        );
        vaultActivity.finish();
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/SSHKeygenDialog.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.app.Dialog;
import android.os.AsyncTask;
import android.support.annotation.NonNull;
import android.view.View;
import android.widget.Button;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ProgressBar;
import android.widget.RadioButton;
import android.widget.RadioGroup;
import android.widget.TextView;
import android.widget.Toast;

import net.schmizz.sshj.common.Base64;
import net.schmizz.sshj.common.Buffer;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemWriter;

import java.io.File;
import java.io.IOException;
import java.io.StringWriter;
import java.security.KeyFactory;
import java.security.interfaces.RSAKey;
import java.security.interfaces.RSAPrivateKey;
import java.security.interfaces.RSAPublicKey;
import java.security.spec.PKCS8EncodedKeySpec;
import java.security.spec.X509EncodedKeySpec;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.SshKeyType;
import it.pgp.xfiles.roothelperclient.resps.ssh_keygen_resp;
import it.pgp.xfiles.utils.Misc;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

/**
 * Created by pgp on 04/12/17
 *      RSA: 2048 - 4096 - custom
 *      ED25519: no options (ECC for public key auth unsupported in SSHJ)
 */

class SSHKeygenDialog extends Dialog {
    EditText name;
    String name_;
    RadioGroup sshKeygenTypeRadioGroup;
    LinearLayout rsaKeygenLayout;

    RadioGroup rsaBitsRadioGroup;
    private EditText bits;
    TextView wait;
    ProgressBar waitPb;
    Button ok;

    int bits_ = -1;
    final VaultActivity vaultActivity;
    final File destDir;

    File destPrv,destPub;

    SshKeyType currentlySelectedKeyType = SshKeyType.RSA;

    SSHKeygenDialog(@NonNull VaultActivity vaultActivity) {
        super(vaultActivity);
        this.vaultActivity = vaultActivity;
        destDir = new File(vaultActivity.getFilesDir(),".ssh");
        setTitle("SSH Keygen"); // RSA only, until SSHJ will support ECC for pubkey auth
        setContentView(R.layout.ssh_keygen_dialog);
        name = findViewById(R.id.sshKeygenNameEditText);
        sshKeygenTypeRadioGroup = findViewById(R.id.sshKeygenTypeRadioGroup);
        rsaKeygenLayout = findViewById(R.id.rsaKeygenLayout);
        sshKeygenTypeRadioGroup.setOnCheckedChangeListener((radioGroup,i) -> {
            currentlySelectedKeyType = i==R.id.rsaKeyTypeRadioButton?SshKeyType.RSA:SshKeyType.ED25519;
            rsaKeygenLayout.setVisibility(currentlySelectedKeyType==SshKeyType.RSA?View.VISIBLE:View.GONE);
        });
        rsaBitsRadioGroup = findViewById(R.id.rsaBitsRadioGroup);
        rsaBitsRadioGroup.setOnCheckedChangeListener((buttonView, isChecked) -> {
            RadioButton rb = buttonView.findViewById(isChecked);
            bits.setText(rb.getText());
        });
        bits = findViewById(R.id.sshKeygenBitsEditText);
        wait = findViewById(R.id.sshKeygenWaitTextView);
        waitPb = findViewById(R.id.sshKeygenWaitProgressBar);
        ok = findViewById(R.id.sshKeygenOkButton);
        ok.setOnClickListener(v -> {
            try { bits_ = Integer.parseInt(bits.getText().toString()); }
            catch (Exception ignored) {}
            // TODO "long time" warning on selecting >= 8192
            if (bits_ < 2048) {
                Toast.makeText(vaultActivity, "Key too weak, please choose at least 2048 bits as length", Toast.LENGTH_SHORT).show();
                return;
            }

            name_ = name.getText().toString();
            String filename = "id_"+currentlySelectedKeyType.name().toLowerCase()+"_"+name_;
            destPrv = new File(destDir,filename);
            destPub = new File(destDir,filename+".pub");
            if (destPrv.exists() || destPub.exists()) {
                Toast.makeText(vaultActivity, "At least a key with with the chosen name already exists, delete it before generating a new keypair", Toast.LENGTH_SHORT).show();
                return;
            }
            new KeygenTask(SSHKeygenDialog.this).execute();
        });
    }

    private static class KeygenTask extends AsyncTask {
        private final SSHKeygenDialog dialog;
        KeygenTask(SSHKeygenDialog dialog) {
            this.dialog = dialog;
        }

        FileOpsErrorCodes result;

        @Override
        protected void onPreExecute() {
            super.onPreExecute();
            dialog.setCancelable(false);
            dialog.ok.setEnabled(false);
            dialog.wait.setText("Generating keys, please wait...");
            dialog.waitPb.setVisibility(View.VISIBLE);
        }

        // without JSCh, with Botan
        @Override
        protected Object doInBackground(Object[] unused) {
            try {
                ssh_keygen_resp keys = MainActivity.getRootHelperClient().generateSSHKeyPair(dialog.currentlySelectedKeyType,dialog.bits_);
                if (keys == null) {
                    result = FileOpsErrorCodes.CONNECTION_ERROR;
                    return null;
                }

                String sshPrvKey,sshPubKey;
                if(dialog.currentlySelectedKeyType == SshKeyType.RSA) {
                    RSAKey[] keypair = PEMToJCEKeypair(keys.privateKey,keys.publicKey);
                    sshPubKey = JCEPubKeyToSSHViaSSHJ((RSAPublicKey) keypair[1], dialog.name_+"@botan");
                    sshPrvKey = JCEPrvKeyToPKCS1((RSAPrivateKey) keypair[0]);
                }
                else {
                    sshPrvKey = keys.privateKey;
                    sshPubKey = keys.publicKey;
                }

                if (!(Misc.writeStringToFilePath(sshPrvKey,dialog.destPrv.getAbsolutePath()) &&
                        Misc.writeStringToFilePath(sshPubKey,dialog.destPub.getAbsolutePath())))
                    result = FileOpsErrorCodes.TRANSFER_ERROR;
            }
            catch(Exception e){
                e.printStackTrace();
                result = FileOpsErrorCodes.CONNECTION_ERROR;
            }
            return null;
        }


        @Override
        protected void onPostExecute(Object o) {
            if (result == null) {
                Toast.makeText(dialog.vaultActivity, "Keys generated successfully", Toast.LENGTH_SHORT).show();
                dialog.vaultActivity.idVaultAdapter.notifyDataSetChanged();
                MainActivity.mainActivity.goDir(
                        new LocalPathContent(dialog.destDir.getAbsolutePath()),
                        MainActivity.mainActivity.browserPager.getCurrentItem(),
                        null);
            }
            else {
                Toast.makeText(dialog.vaultActivity, "Key generation error", Toast.LENGTH_SHORT).show();
            }
            dialog.dismiss();
        }
    }

    // input from response to ACTION_SSH_KEYGEN request
    static RSAKey[] PEMToJCEKeypair(String privateKeyContent, String publicKeyContent) throws Exception {
        privateKeyContent = privateKeyContent.replaceAll("\\n", "").replace("-----BEGIN PRIVATE KEY-----", "").replace("-----END PRIVATE KEY-----", "");
        publicKeyContent = publicKeyContent.replaceAll("\\n", "").replace("-----BEGIN PUBLIC KEY-----", "").replace("-----END PUBLIC KEY-----", "");

        KeyFactory kf = KeyFactory.getInstance("RSA");

        PKCS8EncodedKeySpec keySpecPKCS8 = new PKCS8EncodedKeySpec(Base64.decode(privateKeyContent));
        RSAPrivateKey privKey = (RSAPrivateKey) kf.generatePrivate(keySpecPKCS8);

        X509EncodedKeySpec keySpecX509 = new X509EncodedKeySpec(Base64.decode(publicKeyContent));
        RSAPublicKey pubKey = (RSAPublicKey) kf.generatePublic(keySpecX509);

        return new RSAKey[]{privKey,pubKey};
    }

    static String JCEPubKeyToSSHViaSSHJ(RSAPublicKey key, String comment) {
        return "ssh-rsa " + Base64.encodeBytes(
                new Buffer.PlainBuffer().putPublicKey(key).getCompactData()
        ) + " " + comment;
    }

    /**
     * SSHJ, differently from OpenSSH, seems to have trouble with PKCS8-encoded PEM private keys
     * (the ones that are generated by Botan for performance reasons), so we convert them to
     * "traditional" PKCS1 format
     * Web source:
     * https://stackoverflow.com/questions/7611383/generating-rsa-keys-in-pkcs1-format-in-java
     */
    static String JCEPrvKeyToPKCS1(RSAPrivateKey priv) throws IOException {
        // assemble PKCS1 content
        byte[] privBytes = priv.getEncoded();
        PrivateKeyInfo pkInfo = PrivateKeyInfo.getInstance(privBytes);
        ASN1Encodable encodable = pkInfo.parsePrivateKey();
        ASN1Primitive primitive = encodable.toASN1Primitive();
        byte[] privateKeyPKCS1 = primitive.getEncoded();

        // export in PEM format
        PemObject pemObject = new PemObject("RSA PRIVATE KEY", privateKeyPKCS1);
        StringWriter stringWriter = new StringWriter();
        PemWriter pemWriter = new PemWriter(stringWriter);
        pemWriter.writeObject(pemObject);
        pemWriter.close();
        return stringWriter.toString();
    }

}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/VaultActivity.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.app.AlertDialog;
import android.os.Bundle;
import android.widget.Button;
import android.widget.ListView;
import android.widget.Toast;

import net.schmizz.sshj.SSHClient;
import net.schmizz.sshj.userauth.keyprovider.KeyProvider;

import java.io.File;
import java.io.IOException;
import java.util.Map;

import it.pgp.xfiles.EffectActivity;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.FileSelectFragment;
import it.pgp.xfiles.utils.GenericDBHelper;
import it.pgp.xfiles.utils.XFilesUtils;

/**
 * Created by pgp on 11/02/17 (adapted from KeyGuard)
 */

public class VaultActivity extends EffectActivity implements FileSelectFragment.Callbacks {

    public static Map<Long,?> vault;
    public GenericDBHelper dbh;

    public ListView vaultListView;
    public ListView idVaultListView;

    public VaultAdapter vaultAdapter;
    public IdentitiesVaultAdapter idVaultAdapter;

    public Button addNewItemBtn, addNewIdBtn, genNewIdBtn;

    public void openFileSelector() {
        String fragTag = getResources().getString(R.string.tag_fragment_FileSelect);

        // Set up a selector for file selection rather than directory selection.
        FileSelectFragment fsf = FileSelectFragment.newInstance(FileSelectFragment.Mode.FileSelector,
                android.R.string.ok,
                android.R.string.cancel,
                R.string.alert_file_select,
                R.drawable.xfiles_new_app_icon,
                R.drawable.xf_dir_blu,
                R.drawable.xfiles_file_icon);

        fsf.show(getFragmentManager(), fragTag);
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle("SFTP Key Manager");
        setActivityIcon(R.drawable.xf_xre_server_up);
        setContentView(R.layout.sftp_vault_list_layout);
        dbh = new GenericDBHelper(getApplicationContext());
        vaultListView= findViewById(R.id.sftp_passitem_List);
        idVaultListView= findViewById(R.id.sftp_ids_List);
        addNewItemBtn= findViewById(R.id.sftpAddNewCredsBtn);
        addNewIdBtn = findViewById(R.id.sftpAddNewIdentityBtn);
        genNewIdBtn = findViewById(R.id.sftpGenNewIdentityBtn);

        addNewItemBtn.setOnClickListener(v -> new InsertEditDialog(VaultActivity.this,vaultAdapter).show());

        addNewIdBtn.setOnClickListener(v -> openFileSelector());
        genNewIdBtn.setOnClickListener(v -> new SSHKeygenDialog(VaultActivity.this).show());
    }

    @Override
    protected void onResume() {
        super.onResume();
        vault = dbh.getAllCreds(AuthData.ref);
        vaultAdapter = new VaultAdapter(getApplicationContext(),VaultActivity.this,vault);
        vaultListView.setAdapter(vaultAdapter);
        idVaultAdapter = new IdentitiesVaultAdapter(this);
        idVaultListView.setAdapter(idVaultAdapter);
    }

    @Override
    public void onConfirmSelect(String absolutePath, String fileName) {
        if (absolutePath != null && fileName != null) {
            File inputPrivKey = new File(absolutePath,fileName);
            File destPath = new File(getApplicationContext().getFilesDir(), SFTPProvider.sshIdsDirName);
            if (!destPath.exists()) destPath.mkdirs();
            destPath = new File(destPath,fileName);

            // check private key format before copying
            try {
                KeyProvider kprov = new SSHClient().loadKeys(inputPrivKey.getAbsolutePath());
                switch (kprov.getType()) {
                    case RSA:
                    case ED25519:
                        break;
                    default:
                        Toast.makeText(getApplicationContext(),"Only RSA and ED25519 keys allowed",Toast.LENGTH_SHORT).show();
                        return;
                }
            }
            catch (Exception i) { // wrong key format or read error
                Toast.makeText(getApplicationContext(),"Wrong key format or key read error",Toast.LENGTH_SHORT).show();
                return;
            }

            // TODO in case of already existing filename, show alert dialog and ask what to do (overwrite, rename, cancel), for now simply cancel key import
            if (destPath.exists()) {
                Toast.makeText(getApplicationContext(),"A key file with the same name already exists, remove it before adding this one",Toast.LENGTH_SHORT).show();
                return;
            }

            try {
                XFilesUtils.copyFile(inputPrivKey,destPath);
            }
            catch (IOException e) {
                Toast.makeText(getApplicationContext(),"Key import error",Toast.LENGTH_SHORT).show();
                return;
            }

            idVaultAdapter.notifyDataSetChanged();
            Toast.makeText(getApplicationContext(),"Key imported successfully",Toast.LENGTH_SHORT).show();
            showRefreshClientDialog();
        }
    }

    @Override
    public boolean isValid(String absolutePath, String fileName) {
        return true;
    }

    // FIXME causes crash on Android-x86 VM
    // ask to refresh sftp clients (clear map) after identity add (otherwise public-key auth only attempts will be successful only on not-already connected sftp clients)
    public void showRefreshClientDialog() {
        AlertDialog.Builder b = new AlertDialog.Builder(this);
        b.setTitle("Reset connected clients in order to update private key ids?");
        b.setIcon(R.drawable.xf_xre_server_down);
        b.setNegativeButton(android.R.string.cancel, null);
        b.setPositiveButton(android.R.string.ok, (dialog,which)->MainActivity.sftpProvider.closeAllSessions());
        b.create().show();
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/VaultAdapter.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.app.Activity;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.BaseAdapter;
import android.widget.ImageButton;
import android.widget.ListAdapter;
import android.widget.TextView;
import android.widget.Toast;

import java.util.ArrayList;
import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.GenericDBHelper;

/**
 * Created by pgp on 11/02/17 (adapted from KeyGuard)
 */

public class VaultAdapter extends BaseAdapter implements ListAdapter {
    public final Context context;
    public final Activity mainActivity;
    public ArrayList loginItems;
    public ArrayList<Long> dbIds;
    public GenericDBHelper dbh;


    // TODO generalize or extend class
    public VaultAdapter(final Context context, final Activity mainActivity, Map<Long,?> loginItemsDbMap) {
        this.context = context;
        this.mainActivity = mainActivity;
        this.dbh = new GenericDBHelper(context);
        this.loginItems = new ArrayList(loginItemsDbMap.values());
        this.dbIds = new ArrayList<>(loginItemsDbMap.keySet());
    }

    public void syncInsertFromDialog(Long oid, Object u) {
        dbIds.add(oid);
        loginItems.add(u);
        notifyDataSetChanged();
    }

    public void syncEditFromDialog(Long oldOid, Long newOid, Object oldU, Object newU) {
        dbIds.add(newOid);
        loginItems.add(newU);
        dbIds.remove(oldOid);
        loginItems.remove(oldU);
        notifyDataSetChanged();
    }

    @Override
    public int getCount() {
        return loginItems.size();
    }

    @Override
    public Object getItem(int position) {
        return null;
    }

    @Override
    public long getItemId(int position) {
        return 0;
    }

    @Override
    public View getView(final int position, final View convertView, ViewGroup parent) {
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            view = inflater.inflate(R.layout.sftp_list_item, null);
        }
        final AuthData loginItem = (AuthData) loginItems.get(position);

        //Handle TextView and display string from your list
        TextView user = view.findViewById(R.id.sftp_listitem_user);
        TextView domain = view.findViewById(R.id.sftp_listitem_domain);
        TextView port = view.findViewById(R.id.sftp_listitem_port);
        // Not needed to see passwords within adapter

        user.setText(loginItem.username);
        domain.setText(loginItem.domain);
        port.setText(loginItem.port+"");


        //Handle buttons and add onClickListeners
        ImageButton editBtn = view.findViewById(R.id.passitem_edit);
        ImageButton deleteBtn = view.findViewById(R.id.passitem_delete);

        editBtn.setOnClickListener(v -> new InsertEditDialog(mainActivity,VaultAdapter.this,dbIds.get(position), loginItems.get(position)).show());
        deleteBtn.setOnClickListener(v -> {
            // remove row from db
//            boolean deleted = dbh.deleteRowFromSftpTable(dbIds.get(position));
            boolean deleted = dbh.deleteRowFromTable(AuthData.ref,dbIds.get(position));
            if(deleted) {
                // remove row from loginItems
                dbIds.remove(position);
                loginItems.remove(position);
            }
            String message=deleted?"Deleted!":"Delete error";
            Toast.makeText(context,message,Toast.LENGTH_SHORT).show();
            notifyDataSetChanged();
        });

        return view;
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/XFileSystemFile.java`:

```java
package it.pgp.xfiles.sftpclient;

/**
 * Created by pgp on 21/11/17
 * Adapted from {@link net.schmizz.sshj.xfer.FileSystemFile}
 * SSHJ-compatible wrapper to InputStream and OutputStream using roothelper for read and write
 * (custom Inputstream and Outputstream classes connecting to roothelper only if needed are provided as well)
 */

import android.support.annotation.Nullable;
import android.util.Log;

import net.schmizz.sshj.xfer.LocalDestFile;
import net.schmizz.sshj.xfer.LocalFileFilter;
import net.schmizz.sshj.xfer.LocalSourceFile;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Date;
import java.util.List;
import java.util.Stack;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.io.RobustLocalFileInputStream;
import it.pgp.xfiles.io.RobustLocalFileOutputStream;
import it.pgp.xfiles.roothelperclient.RootHelperClient;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

public class XFileSystemFile implements LocalSourceFile, LocalDestFile {

    protected final Logger log = LoggerFactory.getLogger(getClass());

    private final RootHelperClient rhc = MainActivity.getRootHelperClient();
    private RobustLocalFileInputStream fis;
    private RobustLocalFileOutputStream fos;

    private String file;

    public XFileSystemFile(String path) {
        this.file = path;
    }

    public XFileSystemFile(File file) {
        this.file = file.getAbsolutePath();
    }

    @Override
    public String getName() {
        String[] file_ = file.split("/");
        return file_[file_.length-1];
    }

    @Override
    public boolean isFile() {
        Log.d(getClass().getName(),"isFile");
        BitSet x = rhc.existsIsFileIsDir(new LocalPathContent(file),true,true,true);
        Log.d(getClass().getName(),"isFile completed");
        return x.get(1);
    }

    @Override
    public boolean isDirectory() {
        Log.d(getClass().getName(),"isDirectory");
        BitSet x = rhc.existsIsFileIsDir(new LocalPathContent(file),true,true,true);
        Log.d(getClass().getName(),"isDirectory completed");
        return x.get(2);
    }

    @Override
    public long getLength() {
        try {
            return rhc.statFile(new LocalPathContent(file)).size;
        } catch (IOException e) {
            return -1;
        }
    }

    @Override
    public InputStream getInputStream() throws IOException {
        if (fis==null) fis = new RobustLocalFileInputStream(file);
        return fis;
    }

    @Override
    public OutputStream getOutputStream() throws IOException {
        if (fos==null) fos = new RobustLocalFileOutputStream(file);
        return fos;
    }

    @Override
    public Iterable<XFileSystemFile> getChildren(@Nullable final LocalFileFilter filter) throws IOException {
        // TODO keep into account filter
        GenericDirWithContent gdwc = rhc.listDirectory(new LocalPathContent(file));
        if (gdwc.errorCode != null)
            throw new IOException("Error listing files in directory: " + this);

        List<XFileSystemFile> children = new ArrayList<>();
        for (BrowserItem b : gdwc.content)
            children.add(new XFileSystemFile(gdwc.dir+"/"+b.getFilename()));
        return children;
    }

    @Override
    public boolean providesAtimeMtime() {
        return true;
    }

    @Override
    public long getLastAccessTime() throws IOException {
        return System.currentTimeMillis() / 1000;
    }

    @Override
    public long getLastModifiedTime() throws IOException {
        return rhc.statFile(new LocalPathContent(file)).modificationTime.getTime() / 1000;
    }

    @Override
    public int getPermissions() throws IOException {
        BitSet x = rhc.existsIsFileIsDir(new LocalPathContent(file),true,true,true);
        if (x.get(2)) return FileMode.DIRECTORY.getDefaultMask();
        else if (x.get(1)) return FileMode.FILE.getDefaultMask();
        else throw new IOException("Unsupported file type or non-existing file");
    }

    @Override
    public void setLastAccessedTime(long t) throws IOException {
        if (rhc.setDates(new LocalPathContent(file),new Date(t),null) != 0) {
//            throw new IOException("Unable to set last access time");
            Log.e(getClass().getName(),"Unable to set last access time");
        }
    }

    @Override
    public void setLastModifiedTime(long t) throws IOException {
        if (rhc.setDates(new LocalPathContent(file),null,new Date(t)) != 0) {
//            throw new IOException("Unable to set last modified time");
            Log.e(getClass().getName(),"Unable to set last modified time");
        }
    }

    @Override
    public void setPermissions(int perms) throws IOException {
        if (rhc.setPermissions(new LocalPathContent(file),perms) != 0) {
//            throw new IOException("Unable to set permissions"); // just treat as warning or avoid to call completely, since perms are very limited by default on Android filesystems
            Log.e(getClass().getName(),"Unable to set permissions");
        }
    }

    @Override
    public XFileSystemFile getChild(String name) {
        validateIsChildPath(name);
        return new XFileSystemFile(file+"/"+name);
    }

    private void validateIsChildPath(String name) {
        String[] split = name.split("/");
        Stack<String> s = new Stack<>();
        for (String component : split) {
            if (component == null || component.isEmpty() || ".".equals(component)) {
                continue;
            } else if ("..".equals(component) && !s.isEmpty()) {
                s.pop();
                continue;
            } else if ("..".equals(component)) {
                throw new IllegalArgumentException("Cannot traverse higher than " + file + " to get child " + name);
            }
            s.push(component);
        }
    }

    @Override
    public XFileSystemFile getTargetFile(String filename) throws IOException {
        XFileSystemFile f = this;

        if (f.isDirectory()) {
            f = f.getChild(filename);
        }

        LocalPathContent ffile = new LocalPathContent(f.file);
        BitSet x = rhc.existsIsFileIsDir(ffile,true,true,true);
        if (!x.get(0)) { // not exists
            rhc.createFileOrDirectory(ffile, FileMode.FILE);
        }
        else if (x.get(2))
            throw new IOException("A directory by the same name already exists: " + f);
        return f;
    }

    @Override
    public XFileSystemFile getTargetDirectory(String dirname) throws IOException {
        XFileSystemFile f = this;
        LocalPathContent fdir = new LocalPathContent(f.file);
        BitSet x = rhc.existsIsFileIsDir(fdir,true,true,true);
        if (x.get(0)) { // exists
            if (x.get(2)) // is directory
                if (!f.getName().equals(dirname)) {
                    f = f.getChild(dirname);
                    fdir = new LocalPathContent(f.file);
                }
            else throw new IOException(f + " - already exists as a file; directory required");
        }
        x = rhc.existsIsFileIsDir(fdir,true,true,true);
        if (!x.get(0))
            rhc.createFileOrDirectory(fdir,FileMode.DIRECTORY);
        return f;
    }

    @Override
    public boolean equals(Object other) {
        return (other instanceof XFileSystemFile)
                && file.equals(((XFileSystemFile) other).file);
    }

    @Override
    public int hashCode() {
        return file.hashCode();
    }

    @Override
    public String toString() {
        return file;
    }

}


```

`app/src/main/java/it/pgp/xfiles/sftpclient/XProgress.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.content.Context;

import java.io.IOException;

import it.pgp.xfiles.exceptions.InterruptedTransferAsIOException;
import it.pgp.xfiles.service.visualization.MovingRibbonTwoBars;
import it.pgp.xfiles.utils.Pair;

/**
 * Adapter class preserving external progress state to be used with SSHJ progress listeners
 * 23/02/2018: used also for SMB task, create separate class if needed later
 */

public class XProgress extends MovingRibbonTwoBars {

    public long totalFiles,currentFiles;
    public long totalSize,currentSize,lastShownSize;

    public boolean cancelled = false;

    protected static final long SIZE_THRESHOLD = 1000000;

    public XProgress(Context context) {
        super(context);
    }

    public void clear() {
        this.totalFiles = 0;
        this.currentFiles = 0;
        this.totalSize = 0;
        this.currentSize = 0;
        this.lastShownSize = 0;
    }

    // detailed progress variables and methods
    protected long completedFilesSizeSoFar;
    public long totalFilesSize; // set only in case of upload

    public boolean isDetailedProgress = false; // set to true in case of upload

    protected void publish() {
        if(isDetailedProgress)
            setProgress(
                    new Pair<>(completedFilesSizeSoFar + currentSize, totalFilesSize),
                    new Pair<>(currentSize, totalSize)
            );
        else
            setProgress(
                    new Pair<>(currentFiles, totalFiles),
                    new Pair<>(currentSize, totalSize)
            );
    }

    public void publishInnerProgress(long innerProgress) throws IOException {
        if (cancelled) throw new InterruptedTransferAsIOException();
        currentSize = innerProgress;
        if (currentSize - lastShownSize > SIZE_THRESHOLD) {
            lastShownSize = currentSize;
            publish();
        }
    }

    public void incrementOuterProgressThenPublish(long newFileSize) {
        if(isDetailedProgress) completedFilesSizeSoFar += totalSize;  // increment of last completed file size
        else currentFiles++;

        totalSize = newFileSize;
        currentSize = 0;
        lastShownSize = 0;
        publish();
    }

    public void cancelByProgressCrash() {
        cancelled = true;
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/XSFTPClient.java`:

```java
package it.pgp.xfiles.sftpclient;

import net.schmizz.sshj.sftp.*;
import net.schmizz.sshj.xfer.FilePermission;
import net.schmizz.sshj.xfer.LocalDestFile;
import net.schmizz.sshj.xfer.LocalSourceFile;

import java.io.IOException;
import java.util.*;

public class XSFTPClient
        implements AutoCloseable {

    public final SFTPEngine engine;
    public final XSFTPFileTransfer xfer;

    public XSFTPClient(SFTPEngine engine) {
        this.engine = engine;
        this.xfer = new XSFTPFileTransfer(engine);
    }

    public void setProgressIndicator(XProgress progressIndicator) {
        ((XTransferListener)xfer.transferListener).progressIndicator = progressIndicator;
    }

    public SFTPEngine getSFTPEngine() {
        return engine;
    }

    public SFTPFileTransfer getFileTransfer() {
        return xfer;
    }

    public List<RemoteResourceInfo> ls(String path)
            throws IOException {
        return ls(path, null);
    }

    public List<RemoteResourceInfo> ls(String path, RemoteResourceFilter filter)
            throws IOException {
        try (RemoteDirectory dir = engine.openDir(path)) {
            return dir.scan(filter);
        }
    }

    public RemoteFile open(String filename, Set<OpenMode> mode, FileAttributes attrs)
            throws IOException {
        return engine.open(filename, mode, attrs);
    }

    public RemoteFile open(String filename, Set<OpenMode> mode)
            throws IOException {
        return open(filename, mode, FileAttributes.EMPTY);
    }

    public RemoteFile open(String filename)
            throws IOException {
        return open(filename, EnumSet.of(OpenMode.READ));
    }

    public void mkdir(String dirname)
            throws IOException {
        engine.makeDir(dirname);
    }

    public void mkdirs(String path)
            throws IOException {
        final Deque<String> dirsToMake = new LinkedList<>();
        for (PathComponents current = engine.getPathHelper().getComponents(path); ;
             current = engine.getPathHelper().getComponents(current.getParent())) {
            final FileAttributes attrs = statExistence(current.getPath());
            if (attrs == null) {
                dirsToMake.push(current.getPath());
            } else if (attrs.getType() != FileMode.Type.DIRECTORY) {
                throw new SFTPException(current.getPath() + " exists but is not a directory");
            } else {
                break;
            }
        }
        while (!dirsToMake.isEmpty()) {
            mkdir(dirsToMake.pop());
        }
    }

    public FileAttributes statExistence(String path)
            throws IOException {
        try {
            return engine.stat(path);
        } catch (SFTPException sftpe) {
            if (sftpe.getStatusCode() == Response.StatusCode.NO_SUCH_FILE) {
                return null;
            } else {
                throw sftpe;
            }
        }
    }

    public void rename(String oldpath, String newpath)
            throws IOException {
        engine.rename(oldpath, newpath);
    }

    public void rm(String filename)
            throws IOException {
        engine.remove(filename);
    }

    public void rmdir(String dirname)
            throws IOException {
        engine.removeDir(dirname);
    }

    public void symlink(String linkpath, String targetpath)
            throws IOException {
        engine.symlink(linkpath, targetpath);
    }

    public int version() {
        return engine.getOperativeProtocolVersion();
    }

    public void setattr(String path, FileAttributes attrs)
            throws IOException {
        engine.setAttributes(path, attrs);
    }

    public int uid(String path)
            throws IOException {
        return stat(path).getUID();
    }

    public int gid(String path)
            throws IOException {
        return stat(path).getGID();
    }

    public long atime(String path)
            throws IOException {
        return stat(path).getAtime();
    }

    public long mtime(String path)
            throws IOException {
        return stat(path).getMtime();
    }

    public Set<FilePermission> perms(String path)
            throws IOException {
        return stat(path).getPermissions();
    }

    public FileMode mode(String path)
            throws IOException {
        return stat(path).getMode();
    }

    public FileMode.Type type(String path)
            throws IOException {
        return stat(path).getType();
    }

    public String readlink(String path)
            throws IOException {
        return engine.readLink(path);
    }

    public FileAttributes stat(String path)
            throws IOException {
        return engine.stat(path);
    }

    public FileAttributes lstat(String path)
            throws IOException {
        return engine.lstat(path);
    }

    public void chown(String path, int uid)
            throws IOException {
        setattr(path, new FileAttributes.Builder().withUIDGID(uid, gid(path)).build());
    }

    public void chmod(String path, int perms)
            throws IOException {
        setattr(path, new FileAttributes.Builder().withPermissions(perms).build());
    }

    public void chgrp(String path, int gid)
            throws IOException {
        setattr(path, new FileAttributes.Builder().withUIDGID(uid(path), gid).build());
    }

    public void truncate(String path, long size)
            throws IOException {
        setattr(path, new FileAttributes.Builder().withSize(size).build());
    }

    public String canonicalize(String path)
            throws IOException {
        return engine.canonicalize(path);
    }

    public long size(String path)
            throws IOException {
        return stat(path).getSize();
    }

    public void get(String source, String dest)
            throws IOException {
        xfer.download(source, dest);
    }

    public void put(String source, String dest)
            throws IOException {
        xfer.upload(source, dest);
    }

    public void get(String source, LocalDestFile dest)
            throws IOException {
        xfer.download(source, dest);
    }

    public void put(LocalSourceFile source, String dest)
            throws IOException {
        xfer.upload(source, dest);
    }

    @Override
    public void close()
            throws IOException {
        engine.close();
    }

}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/XSFTPFileTransfer.java`:

```java
package it.pgp.xfiles.sftpclient;

import net.schmizz.sshj.sftp.SFTPEngine;
import net.schmizz.sshj.sftp.SFTPFileTransfer;
import net.schmizz.sshj.xfer.TransferListener;

import java.io.IOException;

public class XSFTPFileTransfer extends SFTPFileTransfer {

    TransferListener transferListener;

    public XSFTPFileTransfer(SFTPEngine engine) {
        super(engine);
        this.transferListener = new XTransferListener();
    }

    @Override
    public TransferListener getTransferListener() {
        return transferListener;
    }

    @Override
    public void setTransferListener(TransferListener transferListener) {
        this.transferListener = transferListener;
    }

    // comment upload and download methods to revert to standard Java code for file IO (no roothelper)
    @Override
    public void upload(String source, String dest) throws IOException {
        upload(new XFileSystemFile(source), dest);
    }

    @Override
    public void download(String source, String dest) throws IOException {
        download(source, new XFileSystemFile(dest));
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/XSSHClient.java`:

```java
package it.pgp.xfiles.sftpclient;

import android.util.Log;

import net.schmizz.sshj.Config;
import net.schmizz.sshj.SSHClient;
import net.schmizz.sshj.common.IOUtils;
import net.schmizz.sshj.connection.ConnectionException;
import net.schmizz.sshj.connection.channel.direct.Session;
import net.schmizz.sshj.sftp.SFTPEngine;
import net.schmizz.sshj.transport.TransportException;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import it.pgp.xfiles.roothelperclient.resps.folderStats_resp;
import it.pgp.xfiles.utils.Misc;

public class XSSHClient extends SSHClient implements AutoCloseable {

    private void checkConnected() {
        if (!isConnected()) {
            throw new IllegalStateException("Not connected");
        }
    }

    private void checkAuthenticated() {
        if (!isAuthenticated()) {
            throw new IllegalStateException("Not authenticated");
        }
    }

    public XSSHClient(Config config) {
        super(config);
    }

    public XSFTPClient newXSFTPClient()
            throws IOException {
        checkConnected();
        checkAuthenticated();
        return new XSFTPClient(new SFTPEngine(this).init());
    }

    /**
     * Accumulates the count of regular files in a list of items (that can contain both files and directories)
     * by recursing on subdirectories if necessary
     */
    public long countTotalRegularFilesInItems(Iterable<Map.Entry<String,Boolean>> paths) {
        long totalFirstLevelRegularFiles = 0;
        long total = -1;
        try (Session helperSession = startSession()) {
            StringBuilder builder = new StringBuilder("(");
            for (Map.Entry<String,Boolean> path : paths) {
                if (path.getValue()) // launch find command only if is directory
                    builder.append("find ").append(path.getKey()).append(" -type f;"); // seek recursively for all files in the directory
                else totalFirstLevelRegularFiles++;
            }
            builder.append(") | wc -l");
            try (Session.Command cmd = helperSession.exec(builder.toString());
                 InputStream is = cmd.getInputStream()) {
                String output = IOUtils.readFully(is).toString().trim();
                long exitStatus = cmd.getExitStatus();
                if (exitStatus==0) {
                    total = Long.parseLong(output);
                    total += totalFirstLevelRegularFiles;
                    Log.d("TOTALTOTAL","Current total is "+total);
                }
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return total;
        }
        catch (ConnectionException | TransportException e) {return total;}
    }

    protected long countTotalSizeInItems_duMethod(Iterable<Map.Entry<String,Boolean>> filenames, String parentDir) {
        long total = 0;
        if (!filenames.iterator().hasNext()) return total;
        try (Session helperSession = startSession()) {
            // try with linux du (all filenames scenarios should be already covered, provided the target shell has enabled UTF-8 support)
            StringBuilder builder = new StringBuilder("cd '"+parentDir.replace("'","'\"'\"'")+"' && du -s -0 --apparent-size -B1 -l ");
            for (Map.Entry<String,Boolean> path : filenames) {
                builder.append("'").append(path.getKey().replace("'","'\"'\"'")).append("' ");
            }

            try (Session.Command cmd = helperSession.exec(builder.toString());
                 InputStream is = cmd.getInputStream()) {
                byte[] commandOutput = IOUtils.readFully(is).toByteArray();
                long exitStatus = cmd.getExitStatus();
                if (exitStatus!=0) {
                    return -1;
                }
                else {
                    List<String> outputLines = Misc.splitByteArrayOverByteAndEncode(commandOutput, (byte)0); // -0 param of du separates lines with \0
                    for (String outputLine : outputLines) {
                        String[] sLine = outputLine.split("[ \t]");
                        if (sLine.length > 1) total += Long.parseLong(sLine[0]); // take only first cell, contains size
                        else Log.w("TOTALSIZE","du returned success, but parsed line with less than 2 cells, ignoring it. Line is:\n"+outputLine);
                    }
                    return total;
                }
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
        catch (ConnectionException | TransportException e) {
            e.printStackTrace();
        }
        return -1;
    }

    // should work fine for all filename scenario at least with Python 3 on Unix OSes (python 2 may fail on utf-8 chars filenames)
    protected long countTotalSizeInItems_pythonMethod(Iterable<Map.Entry<String,Boolean>> filenames, String parentDir) {
        long total = 0;
        if (!filenames.iterator().hasNext()) return total;
        try (Session helperSession = startSession()) {
            StringBuilder builder = new StringBuilder("python -c 'from __future__ import print_function;import os;os.chdir(r\"");
            // add parentDir for chdir
            builder.append(parentDir.replace("\n","\\n").replace("\"","\\\"").replace("'","'\"'\"'"))
                    .append("\");print(sum([sum([sum(map(lambda fname: os.path.getsize(os.path.join(directory, fname)), files)) for directory, folders, files in os.walk(singlePath)]) for singlePath in [");

            for (Map.Entry<String,Boolean> path : filenames) {
                builder.append("r\"").append(path.getKey().replace("\n","\\n").replace("\"","\\\"").replace("'","'\"'\"'")).append("\",");
            }
            builder.append("]]));'"); // non-empty lists with ending comma characters are allowed in python (emptiness checked at the beginning)

            try (Session.Command cmd = helperSession.exec(builder.toString());
                 InputStream is = cmd.getInputStream()) {
                String commandOutput = IOUtils.readFully(is).toString().trim();
                long exitStatus = cmd.getExitStatus();
                return exitStatus!=0?-1:Long.parseLong(commandOutput);
            }
            catch (Exception e) {
                e.printStackTrace();
            }
        }
        catch (ConnectionException | TransportException ignored) {}
        return -1;
    }

    protected long countTotalSizeInItems_dirMethod(Iterable<Map.Entry<String,Boolean>> filenames, String parentDir) {
        long total = 0;
        long totalFiles = 0;
        if (!filenames.iterator().hasNext()) return total;
        try {
            String pdwf = parentDir.substring((parentDir.startsWith("/")?1:0),parentDir.length()-((parentDir.endsWith("/")?1:0)));
            pdwf = pdwf.replace("/","\\");
            if (pdwf.length()<=1 || pdwf.charAt(1) != ':') pdwf = ""+pdwf.charAt(0)+":"+pdwf.substring(1); // actually the operator should be == for length, <= only to avoid app crash in case of malformed paths
            //   C:\example\path or C\example\path
            //   C:\                C               C\

            String changeUnitCommand = pdwf.substring(0,2);

            Pattern pattern = Pattern.compile("([0-9]+)([^0-9]+)([0-9]+)"); // dir output format: nnnnnnnn files, MMMMMMMM bytes

            for (Map.Entry<String,Boolean> path : filenames) {
                try (Session helperSession = startSession()) {
                    final String dircmd = "cmd /V:ON /c \"@echo off & " +
                            changeUnitCommand + " & " +
                            "@cd \"" + pdwf + "\\\" & " + // additional final slash for avoiding cases like |cd "c:"| that don't work (while |cd "c:\"| does work )
                            "@set pline=na & @set cline=na & " +
                            "(@for /F \"delims=\" %i in ( ' dir /s /a /-c \"" + path.getKey() + "\" ' ) do " +
                            "@( @set pline=!cline! & @set cline=%i)) & " +
                            "@echo !pline!\"";
                    Log.d(getClass().getName(),"dir cmd is: "+dircmd);

                    try (Session.Command cmd = helperSession.exec(dircmd);
                         InputStream is = cmd.getInputStream()) {
                        String commandOutput = IOUtils.readFully(is).toString().trim();
                        Log.d(getClass().getName(),"dir cmd output is: "+commandOutput);
                        long exitStatus = cmd.getExitStatus();
                        if (exitStatus != 0) return -1;
                        else {
                            Matcher matcher = pattern.matcher(commandOutput);
                            if (matcher.find()) {
                                totalFiles += Long.parseLong(matcher.group(1));
                                total += Long.parseLong(matcher.group(3));
                            }
                            else Log.e(getClass().getName(),"No match found for dir cmd output: "+commandOutput);
                        }
                    }
                    catch (Exception e) {
                        e.printStackTrace();
                    }
                }
                catch (ConnectionException | TransportException e) {
                    e.printStackTrace();
                    return -1;
                }
            }
            return total;
        }
        catch (Exception e) {
            Log.e(getClass().getName(),"Unhandled exception, leaving size count", e);
            return -1;
        }
    }

    /**
     * Tries to invoke external commands du, python with os.walk script, and dir (in case remote host is a Windows one)
     */
    public long countTotalSizeInItems(Iterable<Map.Entry<String,Boolean>> filenames, String parentDir) throws IOException {
        try {
            long total = countTotalSizeInItems_duMethod(filenames,parentDir);
            if (total >= 0) return total;
            Log.e("TOTALSIZE","du command failed, trying with python command...");

            total = countTotalSizeInItems_pythonMethod(filenames, parentDir);
            if (total >= 0) return total;
            Log.e("TOTALSIZE","python command failed, trying with dir command...");

            // try with dir command (for windows remote hosts running a SSH server, e.g. Windows 10 >=1803 built-in OpenSSH, or Bitvise SSH Server)
            total = countTotalSizeInItems_dirMethod(filenames, parentDir);
            if (total >= 0) return total;
            Log.e("TOTALSIZE","dir command failed, external progress or total size for stats won't be available");

            return -1;
        }
        catch (Exception e) {
            throw new IOException(e);
        }
    }

    public folderStats_resp statFoldersInPaths(Map.Entry<String,Boolean>... paths) {
        folderStats_resp resp = new folderStats_resp();

        long totalFirstLevelRegularFiles = 0;
        final StringBuilder builderD = new StringBuilder("(");
        final StringBuilder builderF = new StringBuilder("(");
        for (Map.Entry<String,Boolean> path : paths) {
            if (path.getValue()) { // launch find command only if is directory
                builderD.append("find ").append(path.getKey()).append(" -type d;"); // all dir nodes in dir
                builderF.append("find ").append(path.getKey()).append(" -type f;"); // all files nodes in dir
            }
            else totalFirstLevelRegularFiles++;
        }
        builderD.append(") | wc -l");
        builderF.append(") | wc -l");

        // TODO refactor duplicated code

        try (Session helperSession = startSession();
             Session.Command cmd = helperSession.exec(builderD.toString());
             InputStream is = cmd.getInputStream()) {
            String output = IOUtils.readFully(is).toString().replace("\n","");
            long exitStatus = cmd.getExitStatus();
            if (exitStatus==0) {
                resp.totalDirs = Long.parseLong(output);
            }
        }
        catch (IOException e) {
            e.printStackTrace();
            return null;
        }

        try (Session helperSession = startSession();
             Session.Command cmd = helperSession.exec(builderF.toString());
             InputStream is = cmd.getInputStream()) {
            String output = IOUtils.readFully(is).toString().replace("\n","");
            long exitStatus = cmd.getExitStatus();
            if (exitStatus==0) {
                resp.totalFiles = Long.parseLong(output);
                resp.totalFiles += totalFirstLevelRegularFiles;
            }
        }
        catch (IOException e) {
            e.printStackTrace();
            return null;
        }

        return resp;

        // TODO childrenDirs, childrenFiles and totalSize
    }
}

```

`app/src/main/java/it/pgp/xfiles/sftpclient/XTransferListener.java`:

```java
package it.pgp.xfiles.sftpclient;

import net.schmizz.sshj.common.StreamCopier;
import net.schmizz.sshj.xfer.TransferListener;

public class XTransferListener implements TransferListener {

    public XProgress progressIndicator;

    // should be already initialized with total files
    public void setProgressIndicator(XProgress progressIndicator) {
        this.progressIndicator = progressIndicator;
    }

    @Override
    public TransferListener directory(String name) {
//        progressIndicator.incrementOuterProgressThenPublish(1); // increment dir progress at the beginning - avoid division by zero with dummy size of 1
        return this;
    }

    @Override
    public StreamCopier.Listener file(String name, long size) {
        progressIndicator.incrementOuterProgressThenPublish(size);
        return progressIndicator::publishInnerProgress;
    }
}

```

`app/src/main/java/it/pgp/xfiles/smbclient/SmbAuthData.java`:

```java
package it.pgp.xfiles.smbclient;

import android.support.annotation.Nullable;

import java.io.Serializable;

public class SmbAuthData implements Serializable {

    public static final SmbAuthData ref = new SmbAuthData(null,null,null,0,null);  // just for type checking in generic method

    public static final String defaultDomain = "WORKGROUP";
    public static final int defaultPort = 445;

    public String username;
    public String domain;
    public String host;
    public int port;
    @Nullable public String password;

    public SmbAuthData(String username, String host, int port, @Nullable String password) {
        this(username,defaultDomain,host,port,password);
    }

    public SmbAuthData(String username, String host, @Nullable String password) {
        this(username,defaultDomain,host,defaultPort,password);
    }

    public SmbAuthData(String username, String host, int port) {
        this(username,defaultDomain,host,port,null);
    }

    public SmbAuthData(String username, String host) {
        this(username,defaultDomain,host,defaultPort,null);
    }

    public SmbAuthData(String username,
                       @Nullable String domain,
                       String host,
                       int port,
                       @Nullable String password) {
        this.username = username;
        this.domain = (domain==null||"".equals(domain))?defaultDomain:domain;
        this.host = host;
        this.port = port<=0?defaultPort:port;
        this.password = password;
    }


    // non-canonical, contains domain(e.g. WORKGROUP)
    @Override
    public String toString() {
        return username + "@" + domain + ":" + host + ":" + port;
    }

    @Override
    public int hashCode() {
        final int prime = 23;
        final int prime2 = 37;
        final int prime3 = 101;
        int hash1 = (this.username == null) ? 0 : this.username.hashCode();
        int hash2 = (this.domain == null) ? 0 : this.domain.hashCode();
        int hash3 = (this.host == null) ? 0 : this.host.hashCode();
        return prime3*((prime2*((prime * (hash1 ^ hash2))^this.port))^hash3);
    }
}

```

`app/src/main/java/it/pgp/xfiles/smbclient/SmbProvider.java`:

```java
package it.pgp.xfiles.smbclient;

import android.content.Context;
import android.os.StrictMode;
import android.support.annotation.Nullable;

import java.io.File;
import java.io.IOException;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.CopyMoveListPathContent;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.io.RobustLocalFileInputStream;
import it.pgp.xfiles.io.RobustLocalFileOutputStream;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;
import it.pgp.xfiles.roothelperclient.resps.folderStats_resp;
import it.pgp.xfiles.service.BaseBackgroundTask;
import it.pgp.xfiles.sftpclient.XProgress;
import it.pgp.xfiles.utils.FileOperationHelper;
import it.pgp.xfiles.utils.GenericDBHelper;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.dircontent.SmbDirWithContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.SMBPathContent;
import jcifs.CIFSContext;
import jcifs.CIFSException;
import jcifs.Configuration;
import jcifs.config.DelegatingConfiguration;
import jcifs.config.PropertyConfiguration;
import jcifs.context.BaseContext;
import jcifs.context.CIFSContextWrapper;
import jcifs.smb.NtlmPasswordAuthentication;
import jcifs.smb.SmbFile;
import jcifs.smb.SmbFileInputStream;
import jcifs.smb.SmbFileOutputStream;

public class SmbProvider implements FileOperationHelper {

    BaseBackgroundTask task;
    @Override
    public void initProgressSupport(BaseBackgroundTask task) {
        this.task = task;
    }

    @Override
    public void destroyProgressSupport() {
        task = null;
    }

    private final CIFSContext baseCtx;
    private final Map<String, CIFSContext> smbclients = new ConcurrentHashMap<>();
    private GenericDBHelper dbh;
    private final MainActivity mainActivity;

    static {
        // TODO restructure code using AsyncTask and remove policy loosening
        StrictMode.setThreadPolicy(StrictMode.ThreadPolicy.LAX);
    }

    // BEGIN copied from JCIFS source
    private static final class CIFSConfigContextWrapper extends CIFSContextWrapper {
        private final DelegatingConfiguration cfg;

        CIFSConfigContextWrapper ( CIFSContext delegate, DelegatingConfiguration cfg ) {
            super(delegate);
            this.cfg = cfg;
        }

        @Override
        protected CIFSContext wrap ( CIFSContext newContext ) {
            return new CIFSConfigContextWrapper(super.wrap(newContext), this.cfg);
        }

        @Override
        public Configuration getConfig () {
            return this.cfg;
        }
    }


    protected static CIFSContext withConfig ( CIFSContext ctx, final DelegatingConfiguration cfg ) {
        return new CIFSConfigContextWrapper(ctx, cfg);
    }
    // END copied from JCIFS source

    public void closeAllSessions() {
        for (CIFSContext x : smbclients.values())
            try {x.close();} catch (Exception ignored) {}
        smbclients.clear();
    }

    public SmbProvider(final Context context, final MainActivity mainActivity) {
        this.mainActivity = mainActivity;
        this.dbh = new GenericDBHelper(context);
        try {
            CIFSContext ctx = new BaseContext(new PropertyConfiguration(System.getProperties()));
            baseCtx = withConfig(ctx,new DelegatingConfiguration(ctx.getConfig()) {
                @Override
                public int getSoTimeout () {
                    return 1000;
                }

                @Override
                public int getConnTimeout () {
                    return 1000;
                }

                @Override
                public int getSessionTimeout () {
                    return 1000;
                }
            });
        } catch (CIFSException e) {
            throw new RuntimeException(e);
        }
    }

    public static SmbFile smbfileConcat(SmbFile dir, String filename, boolean... isDirectory) throws MalformedURLException {
        String a = dir.getURL().toString();
        if (a.endsWith("/")) a = a.substring(0,a.length()-1);
        if (filename.startsWith("/")) filename = filename.substring(1);
        return new SmbFile(a+"/"+filename+((isDirectory.length>0 && isDirectory[0])?"/":""),dir.getContext());
    }

    public void downloadSingleFile(SmbFile file, File localPath) throws IOException {
        try (SmbFileInputStream smbfis = new SmbFileInputStream(file);
             RobustLocalFileOutputStream fos = new RobustLocalFileOutputStream(localPath.getAbsolutePath())) {
            byte[] b = new byte[1048576];
            long prg = 0;
            ((XProgress)(task.mr)).incrementOuterProgressThenPublish(file.getContentLength());
            for(;;) {
                int readbytes = smbfis.read(b);
                if (readbytes <= 0) break;
                System.out.println("Read "+readbytes+" bytes");
                fos.write(b,0,readbytes);
                System.out.println("Written "+readbytes+" bytes");
                prg+=readbytes;
                ((XProgress)(task.mr)).publishInnerProgress(prg);
            }
        }
    }

    public void uploadSingleFile(File localFile, SmbFile file) throws IOException {
        try (RobustLocalFileInputStream fis = new RobustLocalFileInputStream(localFile.getAbsolutePath());
             SmbFileOutputStream smbfos = new SmbFileOutputStream(file)) {
            byte[] b = new byte[1048576];
            long prg = 0;
            ((XProgress)(task.mr)).incrementOuterProgressThenPublish(localFile.length());
            for(;;) {
                int readbytes = fis.read(b);
                if (readbytes <= 0) break;
                System.out.println("Read "+readbytes+" bytes");
                smbfos.write(b,0,readbytes);
                System.out.println("Written "+readbytes+" bytes");
                prg+=readbytes;
                ((XProgress)(task.mr)).publishInnerProgress(prg);
            }
        }
    }

    public void uploadFileOrDirectory(String localPath_, SmbFile remotePath) throws IOException {
        File localPath = new File(localPath_);
        if (localPath.isDirectory()) {
            remotePath.mkdirs();
            File[] dirContent = localPath.listFiles();
            if (dirContent != null)
                for (File f : dirContent)
                    uploadFileOrDirectory(f.getAbsolutePath(), smbfileConcat(remotePath,f.getName()));
        }
        else uploadSingleFile(localPath,remotePath);
    }

    public void downloadFileOrDirectory(SmbFile remotePath, String localPath_) throws IOException {
        File localPath = new File(localPath_);
        if(remotePath.isDirectory()) {
            if (!localPath.exists() && !localPath.mkdirs()) {
                System.err.println("Error creating local directory "+localPath_);
                return;
            }
            for (SmbFile fn : remotePath.listFiles())
                downloadFileOrDirectory(fn, new File(localPath,fn.getName()).getAbsolutePath());
        }
        else downloadSingleFile(remotePath,localPath);
    }

    public CIFSContext getChannel(SmbAuthData smbAuthData) {
        // try to get channel, if already existing
        CIFSContext cSMB = smbclients.get(smbAuthData.toString());
        if (cSMB == null) {
            cSMB = baseCtx.withCredentials(
                    new NtlmPasswordAuthentication(
                            baseCtx,
                            smbAuthData.domain,
                            smbAuthData.username,
                            smbAuthData.password));
            smbclients.put(smbAuthData.toString(),cSMB);
        }
        return cSMB;
    }

    @Override
    public String createFileOrDirectory(BasePathContent filePath, FileMode fileOrDirectory, FileCreationAdvancedOptions... fileOptions) throws IOException {
        return null;
    }

    @Override
    public void createLink(BasePathContent originPath, BasePathContent linkPath, boolean isHardLink) throws IOException {

    }

    @Override
    public void deleteFilesOrDirectories(List<BasePathContent> files) throws IOException {

    }

    @Override
    public void copyMoveFilesToDirectory(CopyMoveListPathContent files, BasePathContent dstFolder) throws IOException {
        if (files.parentDir.providerType == ProviderType.LOCAL && dstFolder.providerType == ProviderType.SMB) { // upload
            CIFSContext cSMB = getChannel(((SMBPathContent)dstFolder).smbAuthData);
            XProgress xp = (XProgress) task.mr;
            xp.clear();

            // count local files via local roothelper or xfilesopshelper and set them in xprogress
            long totalLocalSize = 0;
            for (BrowserItem localItem : files.files) {
                BasePathContent bpc = files.parentDir.concat(localItem.getFilename());
                if (MainActivity.xFilesUtils.isDir(bpc)) {
                    folderStats_resp fsr = MainActivity.xFilesUtils.statFolder(bpc);
                    totalLocalSize+=fsr.totalSize;
                }
                else {
                    totalLocalSize+=MainActivity.xFilesUtils.statFile(bpc).size;
                }
            }

            xp.totalFilesSize = totalLocalSize;
            xp.isDetailedProgress = true;

            try (SmbFile dst = ((SMBPathContent) dstFolder).getSmbFile(cSMB,true)){
                for (BrowserItem localItem : files.files) {
                    String localName = localItem.getFilename();
                    uploadFileOrDirectory(files.parentDir.concat(localName).dir, smbfileConcat(dst,localName, localItem.isDirectory));
                }
            }
        }
        else if (files.parentDir.providerType == ProviderType.SMB && dstFolder.providerType == ProviderType.LOCAL) { // download
            CIFSContext cSMB = getChannel(((SMBPathContent)files.parentDir).smbAuthData);
            ((XProgress)(task.mr)).totalFiles = Long.MAX_VALUE; // FIXME external progress disabled for now
            for (BrowserItem remoteItemName : files.files) { // iterator over filenames only
                // remote dir as local path string
                // ending "/" in order to paste a folder as a child of the destination folder
                try(SmbFile src = ((SMBPathContent)files.parentDir).getSmbFile(cSMB,true)){
                    String remoteName = remoteItemName.getFilename();
                    downloadFileOrDirectory(smbfileConcat(src,remoteName),dstFolder.dir+"/"+remoteName);
                }
            }
        }
        else if (files.parentDir.providerType == ProviderType.SFTP && dstFolder.providerType == ProviderType.SFTP) {
            throw new IOException("To be implemented, if possible, for copy/move on same remote host");
        }
        else throw new IOException("Unsupported remote-to-remote copy");
    }

    @Override
    public boolean renameFile(BasePathContent oldPathname, BasePathContent newPathname) throws IOException {
        return false;
    }

    @Override
    public SingleStatsItem statFile(BasePathContent pathname) throws IOException {
        return null;
    }

    @Override
    public folderStats_resp statFiles(List<BasePathContent> files) throws IOException {
        return null;
    }

    @Override
    public folderStats_resp statFolder(BasePathContent pathname) throws IOException {
        return null;
    }

    @Override
    public boolean exists(BasePathContent pathname) {
        return false;
    }

    @Override
    public boolean isFile(BasePathContent pathname) {
        return false;
    }

    @Override
    public boolean isDir(BasePathContent pathname) {
        return false;
    }

    @Override
    public byte[] hashFile(BasePathContent pathname,
                           HashRequestCodes hashAlgorithm,
                           BitSet dirHashOpts) throws IOException {
        return new byte[0];
    }

    @Override
    public GenericDirWithContent listDirectory(BasePathContent directory) {
        SMBPathContent g = (SMBPathContent) directory;
        CIFSContext cSMB = getChannel(g.smbAuthData);

        try {
            SmbFile dirToList = g.getSmbFile(cSMB,true);
            List<BrowserItem> l = new ArrayList<>();
            for (SmbFile f : dirToList.listFiles()) {
                l.add(new BrowserItem(
                        f.getName(),
                        f.getContentLengthLong(),
                        new Date(f.getLastModified()),
                        f.isDirectory(),
                        false) // TODO get link info
                );
            }

            return new SmbDirWithContent(g.smbAuthData,directory.dir,l);
        }
        catch (Exception e) {
            return new SmbDirWithContent(g.smbAuthData,FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
        }
    }

    @Override
    public GenericDirWithContent listArchive(BasePathContent archivePath) {
        return null;
    }

    @Override
    public int compressToArchive(BasePathContent srcDirectory, BasePathContent destArchive, @Nullable Integer compressionLevel, @Nullable Boolean encryptHeaders, @Nullable Boolean solidMode, @Nullable String password, @Nullable List<String> filenames) throws IOException {
        return 0;
    }

    @Override
    public List<FileOpsErrorCodes> extractFromArchive(List<BasePathContent> srcArchives, BasePathContent destDirectory, @Nullable String password, @Nullable Iterable<String> filenames, boolean smartDirectoryCreation) throws IOException {
        return null;
    }

    @Override
    public int setDates(BasePathContent file, @Nullable Date accessDate, @Nullable Date modificationDate) {
        return 0;
    }

    @Override
    public int setPermissions(BasePathContent file, int permMask) {
        return 0;
    }

    @Override
    public int setOwnership(BasePathContent file, @Nullable Integer ownerId, @Nullable Integer groupId) {
        return 0;
    }
}

```

`app/src/main/java/it/pgp/xfiles/smbclient/SmbVaultActivity.java`:

```java
package it.pgp.xfiles.smbclient;

import android.os.Bundle;

import it.pgp.xfiles.R;
import it.pgp.xfiles.sftpclient.InsertEditDialog;
import it.pgp.xfiles.sftpclient.VaultActivity;
import it.pgp.xfiles.utils.GenericDBHelper;

public class SmbVaultActivity extends VaultActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setTitle("SMB Key Manager");
        setActivityIcon(R.drawable.xf_xre_server_up);
        setContentView(R.layout.smb_vault_list_layout);
        dbh = new GenericDBHelper(getApplicationContext());
        vaultListView= findViewById(R.id.smb_passitem_List);
        addNewItemBtn= findViewById(R.id.smbAddNewCredsBtn);
        addNewItemBtn.setOnClickListener(v -> new InsertEditDialog(SmbVaultActivity.this,vaultAdapter).show());
    }

    @Override
    protected void onResume() {
        super.onResume();
        vault = dbh.getAllCreds(SmbAuthData.ref);
        vaultAdapter = new SmbVaultAdapter(getApplicationContext(),SmbVaultActivity.this,vault);
        vaultListView.setAdapter(vaultAdapter);
    }
}

```

`app/src/main/java/it/pgp/xfiles/smbclient/SmbVaultAdapter.java`:

```java
package it.pgp.xfiles.smbclient;

import android.app.Activity;
import android.content.Context;
import android.view.LayoutInflater;
import android.view.View;
import android.view.ViewGroup;
import android.widget.ImageButton;
import android.widget.TextView;
import android.widget.Toast;

import java.util.Map;

import it.pgp.xfiles.R;
import it.pgp.xfiles.sftpclient.InsertEditDialog;
import it.pgp.xfiles.sftpclient.VaultAdapter;

public class SmbVaultAdapter extends VaultAdapter {

    public SmbVaultAdapter(Context context, Activity mainActivity, Map<Long, ?> loginItemsDbMap) {
        super(context, mainActivity, loginItemsDbMap);
    }

    @Override
    public View getView(final int position, final View convertView, ViewGroup parent) {
        View view = convertView;
        if (view == null) {
            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
            view = inflater.inflate(R.layout.smb_list_item, null);
        }
        final SmbAuthData loginItem = (SmbAuthData) loginItems.get(position);

        //Handle TextView and display string from your list
        TextView user = view.findViewById(R.id.smb_listitem_user);
        TextView domain = view.findViewById(R.id.smb_listitem_domain);
        TextView host = view.findViewById(R.id.smb_listitem_host);
        TextView port = view.findViewById(R.id.smb_listitem_port);
        // Not needed to see passwords within adapter

        user.setText(loginItem.username);
        domain.setText(loginItem.domain);
        host.setText(loginItem.host);
        port.setText(loginItem.port+"");


        //Handle buttons and add onClickListeners
        ImageButton editBtn = view.findViewById(R.id.passitem_edit);
        ImageButton deleteBtn = view.findViewById(R.id.passitem_delete);

        editBtn.setOnClickListener(v -> new InsertEditDialog(mainActivity,SmbVaultAdapter.this,dbIds.get(position), loginItems.get(position)).show());
        deleteBtn.setOnClickListener(v -> {
            // remove row from db
//            boolean deleted = dbh.deleteRowFromSftpTable(dbIds.get(position));
            boolean deleted = dbh.deleteRowFromTable(SmbAuthData.ref,dbIds.get(position));
            if(deleted) {
                // remove row from loginItems
                dbIds.remove(position);
                loginItems.remove(position);
            }
            String message=deleted?"Deleted!":"Delete error";
            Toast.makeText(context,message, Toast.LENGTH_SHORT).show();
            notifyDataSetChanged();
        });

        return view;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/ArchiveVMap.java`:

```java
package it.pgp.xfiles.utils;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.FindActivity;
import it.pgp.xfiles.adapters.FindResultsAdapter;

/**
 * Created by pgp on 23/05/17
 */

public class ArchiveVMap extends VMap {
    public static final String sentinelKeyForNodeProperties = ""; // in practically every filesystem, filenames cannot be empty

    public ArchiveVMap() {
        super();
    }

    public Object getByPath(String inArchivePath) throws ValueAsKeyException {
        return get(inArchivePath.split("/"));
    }

    private static Map ensureNonNullNodeProps(Map nodeProps) {
        // the directory node need not necessarily be present in an archive
        if(nodeProps==null) {
            nodeProps = new HashMap();
            nodeProps.put("date",new Date(0));
            nodeProps.put("size",0L);
            nodeProps.put("isDir",true);
        }
        return nodeProps;
    }

    public Map getNodeProps(String inArchivePath) throws ValueAsKeyException {
        Map nodeProps = (Map) get(Misc.concatAll(inArchivePath.split("/"),
                new String[]{ArchiveVMap.sentinelKeyForNodeProperties}));
        return ensureNonNullNodeProps(nodeProps);
    }

    private static void dfsPaths(Map<String,Object> m, String recursivePrefix, Predicate<String> matcher) {
        for(Map.Entry<String,Object> x : m.entrySet()) {
            String k = x.getKey();
            if(sentinelKeyForNodeProperties.equals(k)) continue; // exclude node props
            Object v = x.getValue();

            // FIXME it would be much better than the condition on recursivePrefix, to add a sanitize/trim slashes method in BasePathContent hierarchy
            String joinedPath = (recursivePrefix==null || recursivePrefix.isEmpty())?k:recursivePrefix+"/"+k;
            if(matcher.test(k)) {
                Map<String,?> nodeProps = ensureNonNullNodeProps((Map)((Map)v).get(sentinelKeyForNodeProperties));
                BrowserItem b = new BrowserItem(joinedPath,
                        (Long)nodeProps.get("size"),
                        (Date)nodeProps.get("date"),
                        (Boolean) nodeProps.get("isDir"),
                        false);

                try {FindActivity.instance.runOnUiThread(() -> FindResultsAdapter.instance.add(b));}
                catch (Exception e) {
                    e.printStackTrace();
                    break;
                }
            }
            if(recursivePrefix != null && v instanceof Map)
                dfsPaths((Map<String, Object>) v,joinedPath, matcher);
        }
    }

    public void findInArchive(Predicate<String> matcher, String recursivePrefix) {
        dfsPaths((Map)h,recursivePrefix, matcher);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/ArrayTextView.java`:

```java
package it.pgp.xfiles.utils;

import android.content.Context;
import android.util.AttributeSet;
import android.widget.TextView;

import java.util.ArrayList;
import java.util.List;

import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

public class ArrayTextView extends TextView {

    final List<BasePathContent> texts = new ArrayList<>();

    public ArrayTextView(Context context) {
        super(context);
    }

    public ArrayTextView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public ArrayTextView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    public List<BasePathContent> getTexts() {
        return texts;
    }

    public void setTexts(List<BasePathContent> bpcs) {
        texts.clear();
        texts.addAll(bpcs);
        StringBuilder sb = new StringBuilder();
        for(BasePathContent bpc : bpcs) sb.append(bpc.toString()).append("\n");
        super.setText(sb.toString());
    }

    public void setText(BasePathContent bpc) {
        texts.clear();
        texts.add(bpc);
        super.setText(bpc.toString());
    }

    public List<String> getMultipleLocalPathsAsStrings() {
        ArrayList<String> l = new ArrayList<>();
        for(BasePathContent bpc : texts) {
            if(bpc instanceof LocalPathContent) l.add(bpc.dir);
        }
        return l;
    }
}
```

`app/src/main/java/it/pgp/xfiles/utils/BidirectionalMap.java`:

```java
package it.pgp.xfiles.utils;

import android.support.annotation.NonNull;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

/*
Web source: http://stackoverflow.com/questions/1670038/does-java-have-a-hashmap-with-reverse-lookup
(Qw3ry's answer - 07/02/2017 - removed loadFactor params)
 */

class BidirectionalMap<K, V> implements Map<K, V> {

    private final Map<K, V> map;
    private final Map<V, K> revMap;

    BidirectionalMap() {
        this.map = new HashMap<>();
        this.revMap = new HashMap<>();
    }

    private BidirectionalMap(Map<K, V> map, Map<V, K> reverseMap) {
        this.map = map;
        this.revMap = reverseMap;
    }

    @Override
    public void clear() {
        map.clear();
        revMap.clear();
    }

    @Override
    public boolean containsKey(Object key) {
        return map.containsKey(key);
    }

    @Override
    public boolean containsValue(Object value) {
        return revMap.containsKey(value);
    }

    @NonNull
    @Override
    public Set<Entry<K, V>> entrySet() {
        return Collections.unmodifiableSet(map.entrySet());
    }

    @Override
    public boolean isEmpty() {
        return map.isEmpty();
    }

    @NonNull
    @Override
    public Set<K> keySet() {
        return Collections.unmodifiableSet(map.keySet());
    }

    @Override
    public void putAll(@NonNull Map<? extends K, ? extends V> m) {
//        m.entrySet().forEach(e -> put(e.getKey(), e.getValue()));

        for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) {
            put(e.getKey(), e.getValue());
        }
    }

    @Override
    public int size() {
        return map.size();
    }

    @NonNull
    @Override
    public Collection<V> values() {
        return Collections.unmodifiableCollection(map.values());
    }

    @Override
    public V get(Object key) {
        return map.get(key);
    }

    @Override
    public V put(K key, V value) {
        V v = remove(key);
        getReverseView().remove(value);
        map.put(key, value);
        revMap.put(value, key);
        return v;
    }

    Map<V, K> getReverseView() {
        return new BidirectionalMap<>(revMap, map);
    }

    @Override
    public V remove(Object key) {
        if (containsKey(key)) {
            V v = map.remove(key);
            revMap.remove(v);
            return v;
        } else {
            return null;
        }
    }

}
```

`app/src/main/java/it/pgp/xfiles/utils/CheckableSingleExecutor.java`:

```java
package it.pgp.xfiles.utils;

import android.content.Context;
import android.widget.Toast;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class CheckableSingleExecutor implements ExecutorService {

    private final Context context;
    private final ThreadPoolExecutor singleThreadExecutor;

    public CheckableSingleExecutor(Context context) {
        this.context = context;
        singleThreadExecutor = (ThreadPoolExecutor) Executors.newFixedThreadPool(1);
    }

    public boolean isBusy() {
        if(singleThreadExecutor.getActiveCount() > 0) {
            Toast.makeText(context, "Current goDir thread is busy", Toast.LENGTH_SHORT).show();
            return true;
        }
        return false;
    }

    @Override
    public void shutdown() {
        singleThreadExecutor.shutdown();
    }

    @Override
    public List<Runnable> shutdownNow() {
        return singleThreadExecutor.shutdownNow();
    }

    @Override
    public boolean isShutdown() {
        return singleThreadExecutor.isShutdown();
    }

    @Override
    public boolean isTerminated() {
        return singleThreadExecutor.isTerminated();
    }

    @Override
    public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
        return singleThreadExecutor.awaitTermination(timeout, unit);
    }

    @Override
    public <T> Future<T> submit(Callable<T> task) {
        return isBusy()?null:singleThreadExecutor.submit(task);
    }

    @Override
    public <T> Future<T> submit(Runnable task, T result) {
        return isBusy()?null:singleThreadExecutor.submit(task, result);
    }

    @Override
    public Future<?> submit(Runnable task) {
        return isBusy()?null:singleThreadExecutor.submit(task);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {
        return isBusy()?null:singleThreadExecutor.invokeAll(tasks);
    }

    @Override
    public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws InterruptedException {
        return isBusy()?null:singleThreadExecutor.invokeAll(tasks, timeout, unit);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks) throws ExecutionException, InterruptedException {
        return isBusy()?null:singleThreadExecutor.invokeAny(tasks);
    }

    @Override
    public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit) throws ExecutionException, InterruptedException, TimeoutException {
        return isBusy()?null:singleThreadExecutor.invokeAny(tasks, timeout, unit);
    }

    @Override
    public void execute(Runnable command) {
        if(isBusy()) throw new RuntimeException("Single thread is busy");
        singleThreadExecutor.execute(command);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/Checksums.java`:

```java
package it.pgp.xfiles.utils;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Security;
import java.util.zip.CRC32;
import java.util.zip.Checksum;

/**
 * Created by pgp on 28/09/16
 */

public class Checksums {

    static {
        Security.addProvider(new BouncyCastleProvider());
    }

    // TODO byte[] or hexstring output
    public static long crc32(Object filepath) throws IOException {
        InputStream inputStream;
        if (filepath instanceof File) {
            inputStream = new BufferedInputStream(new FileInputStream((File)filepath));
        }
        else if (filepath instanceof String) {
            inputStream = new BufferedInputStream(new FileInputStream((String)filepath));
        }
        else {
            throw new IOException("Neither file object nor filepath string");
        }

        Checksum crc = new CRC32();

        int cnt;
        while ((cnt = inputStream.read()) != -1) {
            crc.update(cnt);
        }

        return crc.getValue();
    }

    public static byte[] sha1(String filepath) throws NoSuchAlgorithmException,IOException {
        return sha1(new File(filepath));
    }
    public static byte[] sha1(File file) throws NoSuchAlgorithmException,IOException {
        MessageDigest digest = MessageDigest.getInstance("SHA-1");
        InputStream fis = new FileInputStream(file);
        int n = 0;
        byte[] buffer = new byte[8192];
        while (n != -1) {
            n = fis.read(buffer);
            if (n > 0) {
                digest.update(buffer, 0, n);
            }
        }
        return digest.digest();
    }

    public static byte[] sha256(File file) throws NoSuchAlgorithmException,IOException {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        InputStream fis = new FileInputStream(file);
        int n = 0;
        byte[] buffer = new byte[8192];
        while (n != -1) {
            n = fis.read(buffer);
            if (n > 0) {
                digest.update(buffer, 0, n);
            }
        }
        return digest.digest();
    }

    public static byte[] sha512(File file) throws NoSuchAlgorithmException,IOException {
        MessageDigest digest = MessageDigest.getInstance("SHA-512");
        InputStream fis = new FileInputStream(file);
        int n = 0;
        byte[] buffer = new byte[8192];
        while (n != -1) {
            n = fis.read(buffer);
            if (n > 0) {
                digest.update(buffer, 0, n);
            }
        }
        return digest.digest();
    }

    public static byte[] md5(File file) throws NoSuchAlgorithmException,IOException {
        MessageDigest digest = MessageDigest.getInstance("MD5");
        InputStream fis = new FileInputStream(file);
        int n = 0;
        byte[] buffer = new byte[8192];
        while (n != -1) {
            n = fis.read(buffer);
            if (n > 0) {
                digest.update(buffer, 0, n);
            }
        }
        return digest.digest();
    }

    public static byte[] stdDigest(File file, String algorithm) throws NoSuchAlgorithmException,IOException {
        MessageDigest digest = MessageDigest.getInstance(algorithm);
        InputStream fis = new FileInputStream(file);
        int n = 0;
        byte[] buffer = new byte[8192];
        while (n != -1) {
            n = fis.read(buffer);
            if (n > 0) {
                digest.update(buffer, 0, n);
            }
        }
        return digest.digest();
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/ContentProviderUtils.java`:

```java
package it.pgp.xfiles.utils;

import android.content.ContentResolver;
import android.content.ContentUris;
import android.content.Context;
import android.database.Cursor;
import android.net.LocalSocket;
import android.net.Uri;
import android.os.Build;
import android.provider.DocumentsContract;
import android.provider.MediaStore;
import android.provider.OpenableColumns;
import android.support.v4.content.FileProvider;

import java.io.File;
import java.io.FileDescriptor;
import java.io.IOException;
import java.lang.reflect.Field;

import it.pgp.xfiles.BuildConfig;

/**
 * Created by pgp on 17/07/17
 * Web sources:
 *      https://stackoverflow.com/questions/19985286/convert-content-uri-to-actual-path-in-android-4-4
 *      https://github.com/iPaulPro/aFileChooser/blob/master/aFileChooser/src/com/ipaulpro/afilechooser/utils/FileUtils.java
 */

public class ContentProviderUtils {

    /**
     * Extracts a native descriptor from a LocalSocket
     * @param localSocket the Local socket
     * @return the native descriptor which can be used by the JNI layer
     * @throws NoSuchFieldException
     * @throws IllegalAccessException
     */
    public static int getNativeDescriptor(LocalSocket localSocket) throws IOException {
        try {
            FileDescriptor uds = localSocket.getFileDescriptor();
            Field nativeField = uds.getClass().getDeclaredField("descriptor");
            nativeField.setAccessible(true);
            return (int)nativeField.get(uds);
        }
        catch (Exception e) {
            throw new IOException(e);
        }
    }

    /**
     * Get a file path from a Uri. This will get the the path for Storage Access
     * Framework Documents, as well as the _data field for the MediaStore and
     * other file-based ContentProviders.
     *
     * @param context The context.
     * @param uri The Uri to query.
     * @author paulburke
     */
    public static String getPathFromUri(final Context context, final Uri uri) {
        ContentResolver resolver = context.getContentResolver();

        final boolean isKitKat = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;

        // DocumentProvider
        if (isKitKat && DocumentsContract.isDocumentUri(context, uri)) {
            // ExternalStorageProvider
            if (isExternalStorageDocument(uri)) {
                final String docId = DocumentsContract.getDocumentId(uri);
                final String[] split = docId.split(":");
                final String type = split[0];

                if ("primary".equalsIgnoreCase(type)) {
                    return Misc.internalStorageDir + "/" + split[1];
                }

                // TODO handle non-primary volumes
            }
            // DownloadsProvider
            else if (isDownloadsDocument(uri)) {

                final String id = DocumentsContract.getDocumentId(uri);
                final Uri contentUri = ContentUris.withAppendedId(
                        Uri.parse("content://downloads/public_downloads"), Long.parseLong(id));

                return getDataColumn(resolver, contentUri, null, null);
            }
            // MediaProvider
            else if (isMediaDocument(uri)) {
                final String docId = DocumentsContract.getDocumentId(uri);
                final String[] split = docId.split(":");
                final String type = split[0];

                Uri contentUri = null;
                if ("image".equals(type)) {
                    contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI;
                } else if ("video".equals(type)) {
                    contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI;
                } else if ("audio".equals(type)) {
                    contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;
                }

                final String selection = "_id=?";
                final String[] selectionArgs = new String[] {
                        split[1]
                };

                return getDataColumn(resolver, contentUri, selection, selectionArgs);
            }
        }
        // MediaStore (and general)
        else if ("content".equalsIgnoreCase(uri.getScheme())) {
            return getDataColumn(resolver, uri, null, null);
        }
        // File
        else if ("file".equalsIgnoreCase(uri.getScheme())) {
            return uri.getPath();
        }

        return null;
    }

    public static String getName(ContentResolver resolver, Uri uri) {
        String fileName = null;
        try (Cursor cursor = resolver
                .query(uri, null, null, null, null, null)) {
            if (cursor != null && cursor.moveToFirst()) {
                // get file name
                fileName = cursor.getString(
                        cursor.getColumnIndex(OpenableColumns.DISPLAY_NAME));
            }
        }
        if (fileName == null) {
            fileName = uri.getPath();
            int cut = fileName.lastIndexOf('/');
            if (cut != -1) {
                fileName = fileName.substring(cut + 1);
            }
        }
        return fileName;
    }

    public static long getSize(ContentResolver resolver, Uri uri) {
        String fileSize = null;
        try (Cursor cursor = resolver
                .query(uri, null, null, null, null, null)) {
            if (cursor != null && cursor.moveToFirst()) {

                // get file size
                int sizeIndex = cursor.getColumnIndex(OpenableColumns.SIZE);
                if (!cursor.isNull(sizeIndex)) {
                    fileSize = cursor.getString(sizeIndex);
                }
            }
            return Long.parseLong(fileSize);
        }
        catch (Exception e) {
            e.printStackTrace();
            return Long.MAX_VALUE; // avoid division by zero errors in progress management
        }
    }

    /**
     * Get the value of the data column for this Uri. This is useful for
     * MediaStore Uris, and other file-based ContentProviders.
     *
     * @param resolver The content resolver.
     * @param uri The Uri to query.
     * @param selection (Optional) Filter used in the query.
     * @param selectionArgs (Optional) Selection arguments used in the query.
     * @return The value of the _data column, which is typically a file path.
     */
    public static String getDataColumn(ContentResolver resolver, Uri uri, String selection,
                                       String[] selectionArgs) {
        final String column = "_data";
        final String[] projection = {column};

        try (Cursor cursor = resolver.query(uri, projection, selection, selectionArgs,
                null)) {
            if (cursor != null && cursor.moveToFirst()) {
                final int column_index = cursor.getColumnIndexOrThrow(column);
                return cursor.getString(column_index);
            }
        }
        return null;
    }


    /**
     * @param uri The Uri to check.
     * @return Whether the Uri authority is ExternalStorageProvider.
     */
    public static boolean isExternalStorageDocument(Uri uri) {
        return "com.android.externalstorage.documents".equals(uri.getAuthority());
    }

    /**
     * @param uri The Uri to check.
     * @return Whether the Uri authority is DownloadsProvider.
     */
    public static boolean isDownloadsDocument(Uri uri) {
        return "com.android.providers.downloads.documents".equals(uri.getAuthority());
    }

    /**
     * @param uri The Uri to check.
     * @return Whether the Uri authority is MediaProvider.
     */
    public static boolean isMediaDocument(Uri uri) {
        return "com.android.providers.media.documents".equals(uri.getAuthority());
    }

    public static Uri getUriFromFile(Context context, File file) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            return FileProvider.getUriForFile(context, BuildConfig.APPLICATION_ID + ".provider", file);
        } else {
            return Uri.fromFile(file);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/DirCommander.java`:

```java
package it.pgp.xfiles.utils;

import android.widget.Toast;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.exceptions.DirCommanderException;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.dircontent.LocalDirWithContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

public class DirCommander {
    private Map<Integer,BasePathContent> recentDirs;
    private Map<Integer,Integer> previousListViewPositions; // position of list view when previous directory was listed
    public int currentIndex;

    // before: false, after: true
    public List<Pair<Integer, BasePathContent>> splitPositions(boolean beforeOrAfterCurrentIndex) {
        int target = beforeOrAfterCurrentIndex ? 1 : -1;
        List<Pair<Integer, BasePathContent>> ret = new ArrayList<>();
        for(Map.Entry<Integer,BasePathContent> entry : recentDirs.entrySet()) {
            Integer i = entry.getKey();
            if(i != null && Integer.compare(i,currentIndex) == target) ret.add(new Pair<>(i,entry.getValue()));
        }
        Comparator<Pair<Integer,BasePathContent>> c = beforeOrAfterCurrentIndex ?
                (o1, o2) -> o2.i.compareTo(o1.i) :
                (o1, o2) -> o1.i.compareTo(o2.i);
        Collections.sort(ret,c); // sort the built list by first field (map key, integer)
        return ret;
    }

    // for cleanup of old commander entries when a series of goBack commands is followed by a goDir
    private void truncateListMaps(int maxIndex) {
        Map<Integer,BasePathContent> tmp1 = new HashMap<>();
        for (Integer i : recentDirs.keySet()) {
            if (i <= maxIndex) tmp1.put(i,recentDirs.get(i));
        }
        Map<Integer,Integer> tmp2 = new HashMap<>();
        for (Integer i : previousListViewPositions.keySet()) {
            if (i <= maxIndex) tmp2.put(i,previousListViewPositions.get(i));
        }
        recentDirs = tmp1;
        previousListViewPositions = tmp2;
    }

    private GenericDirWithContent validateDirAccess(BasePathContent dir) {
        FileOperationHelper helper = MainActivity.mainActivity.getFileOpsHelper(dir.providerType);
        switch (dir.providerType) {
            case LOCAL:
            case XFILES_REMOTE:
            case SFTP:
            case SMB:
                return helper.listDirectory(dir);
            case LOCAL_WITHIN_ARCHIVE:
                return helper.listArchive(dir);
            default: // URL_DOWNLOAD is not a goDir label
                throw new RuntimeException("Invalid ProviderType");
        }
    }

    // same as before, returns data provider instead of calling list dir
    public static ProviderType getProviderFromPath(String dir) {
        if (dir.startsWith("/")) {
            return ProviderType.LOCAL;
        }
        else if (dir.startsWith("sftp://")) {
            return ProviderType.SFTP;
        }
        else if (dir.startsWith("xre://")) {
            return ProviderType.XFILES_REMOTE;
        }
        else if (dir.startsWith("smb://")) {
            return ProviderType.SMB;
        }
        else throw new RuntimeException("Unknown data provider");
    }

    public DirCommander(BasePathContent startingDir) throws DirCommanderException {
        currentIndex = 0;
        recentDirs = new HashMap<>();
        previousListViewPositions = new HashMap<>();
        recentDirs.put(currentIndex,startingDir); // expecting valid dir at least on start
        // previousListViewPositions.add(0); // placeholder, no previous dir on start

        GenericDirWithContent dwc = refreshFailFast();
        if (dwc == null || dwc.errorCode != null) throw new DirCommanderException();
    }

    public DirCommander(BasePathContent startingDir, BasePathContent fallbackDir) throws DirCommanderException {
        currentIndex = 0;
        recentDirs = new HashMap<>();
        previousListViewPositions = new HashMap<>();
        recentDirs.put(currentIndex,startingDir);
        GenericDirWithContent dwc = refreshFailFast();
        if (dwc != null && dwc.errorCode == null) return;

        recentDirs.put(currentIndex,fallbackDir);
        dwc = refreshFailFast();
        if (dwc == null || dwc.errorCode != null) throw new DirCommanderException("Unable to set neither standard nor fallback path in dir commander");
    }

    public BasePathContent getCurrentDirectoryPathname() {
        return recentDirs.get(currentIndex);
    }

    public GenericDirWithContent refreshFailFast() {
        // refresh can only be done at the beginning of the list view (scroll down gesture)
        GenericDirWithContent cwd = validateDirAccess(recentDirs.get(currentIndex));
        if (cwd == null || cwd.errorCode != null)
            return new GenericDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_REFRESH);
        return cwd;
    }

    public GenericDirWithContent refresh() {
        GenericDirWithContent cwd;
        int startIndex = currentIndex;

        do {
            cwd = validateDirAccess(recentDirs.get(currentIndex));
            if (cwd != null && cwd.errorCode == null) break;
            currentIndex--;
        } while (currentIndex >= 0);

        if (currentIndex < 0) {
            Toast.makeText(MainActivity.mainActivity, "Current dir was no longer available, unable to go back even to start folder, exiting...", Toast.LENGTH_SHORT).show();

            currentIndex = 0;
            recentDirs.put(currentIndex,new LocalPathContent("/"));
            MainActivity.mainActivity.finishAffinity();
            return new LocalDirWithContent("/",new ArrayList<>()); // dummy return object, just to avoid NPE in Collections.sort before finishAffinity is actually called
        }

        if (currentIndex != startIndex) {
            truncateListMaps(currentIndex);
            Toast.makeText(MainActivity.mainActivity, "Current dir is no longer available, went back of "+(startIndex-currentIndex)+" positions", Toast.LENGTH_SHORT).show();
        }
        return cwd;
    }

    // TODO to be converged in a single method with refresh(), after updating all usages to background + UI part
    public GenericDirWithContent refresh_background() {
        GenericDirWithContent cwd;
        int startIndex = currentIndex;

        do {
            cwd = validateDirAccess(recentDirs.get(currentIndex));
            if (cwd != null && cwd.errorCode == null) break;
            currentIndex--;
        } while (currentIndex >= 0);

        if (currentIndex < 0) {
            currentIndex = 0;
            recentDirs.put(currentIndex,new LocalPathContent("/"));
//            MainActivity.mainActivity.finishAffinity();
//            return new LocalDirWithContent("/",new ArrayList<>()); // dummy return object, just to avoid NPE in Collections.sort before finishAffinity is actually called
            // TODO check for behaviour conflicts/errors after replacing the above return line with the following one
            cwd = new LocalDirWithContent(FileOpsErrorCodes.CURRENT_DIR_NO_LONGER_AVAILABLE);
            cwd.dir = "/";
            cwd.content = new ArrayList<>();
            cwd.listViewPosition = null;
            return cwd;
        }

        if (currentIndex != startIndex) {
            truncateListMaps(currentIndex);
            cwd.errorCode = FileOpsErrorCodes.CURRENT_DIR_NO_LONGER_AVAILABLE; // TODO this requires further refactoring, here we are adding error in a well formed response (to indicate redirection to one previous commander dir)
            cwd.listViewPosition = startIndex-currentIndex; // abuse of notation, just for showing toast message in this case
        }
        return cwd;
    }

    // offset < 0 -> go back, > 0 -> go ahead
    public GenericDirWithContent shiftNPlaces(int offset, int previousPosition) {
        // cannot go back, no previous dir (assume you cannot delete the folder you're in)
        // OR cannot go ahead, already last item of commander
        // in such cases, refresh current dir and also do not set previous positions
        if ((offset < 0 && currentIndex==0) || (offset > 0 && recentDirs.size()==currentIndex+1))
            return validateDirAccess(recentDirs.get(currentIndex));

        int targetIndex = currentIndex + offset;
        BasePathContent bpc = recentDirs.get(targetIndex);
        if(bpc == null)
            return new GenericDirWithContent(FileOpsErrorCodes.ILLEGAL_ARGUMENT);

        GenericDirWithContent cwd = validateDirAccess(bpc);
        if (cwd == null || cwd.errorCode != null)
            return new GenericDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_SHIFT);
        cwd.listViewPosition = previousListViewPositions.get(targetIndex); // may be null when moving ahead

        // set current position
        previousListViewPositions.put(currentIndex,previousPosition);

        currentIndex = targetIndex;
        return cwd;
    }

    public GenericDirWithContent setDir(BasePathContent dir, int previousPosition) {
        GenericDirWithContent cwd;
        if (recentDirs.size()<currentIndex+1) // guard block
            throw new RuntimeException("Commander error");

        cwd = validateDirAccess(dir);
        if (cwd.errorCode != null)
            return cwd;

        // if most recent path now is equal to the one we are trying to set, avoid duplicating it
        if(dir.equals(recentDirs.get(currentIndex)))
            return cwd;

        if (recentDirs.size()>currentIndex+1) {
            // resize array list, set new element (currentIndex remains unchanged)
            truncateListMaps(currentIndex);
        }
        previousListViewPositions.put(currentIndex,previousPosition);
        currentIndex++;
        recentDirs.put(currentIndex,dir);

        return cwd;
    }

}

```

`app/src/main/java/it/pgp/xfiles/utils/DirTreeWalker.java`:

```java
package it.pgp.xfiles.utils;

import android.support.annotation.NonNull;

import java.io.File;
import java.util.Collection;
import java.util.Iterator;
import java.util.Stack;

/**
 * Created by pgp on 02/11/16
 * Last modified on 11/11/2016
 *
 * TODO should become part of FileOperationHelper interface
 */
public class DirTreeWalker implements Iterator<File>{
    private Stack<File> stack;
    public DirTreeWalker(File rootDir) {
        if (!rootDir.isDirectory())
            throw new RuntimeException("Not a directory");
        stack = new Stack<>();
        for (File x : rootDir.listFiles()) stack.push(x);
    }

    public DirTreeWalker() {
        stack = new Stack<>();
    }

    public DirTreeWalker(@NonNull Collection<File> collection) {
        this();
        this.append(collection);
    }

    public DirTreeWalker(@NonNull File... args) {
        this();
        this.append(args);
    }

    public void append(@NonNull File file) {
        stack.push(file);
    }

    public void append(@NonNull Collection<File> collection) {
        for (File x : collection)
            if (x!=null)
                stack.push(x);
    }

    public void append(@NonNull File... args) {
        for (File x : args)
            stack.push(x);
    }

    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    // only adds files, and directories in which subtree there is at least a file as leaf
//    @Override
//    public File next() {
//        // get next regular file from stack (if file is dir, expand it and go on)
//        File f = stack.pop();
//        while (f.isDirectory()) {
//            for (File x : f.listFiles()) stack.push(x);
//            f = stack.pop();
//        }
//
//        return f;
//    }

    @Override
    public File next() {
        // get next regular file from stack (if file is dir, expand it and go on)
        File f = stack.pop();
        if (f.isDirectory()) {
            for (File x : f.listFiles()) stack.push(x);
        }

        return f;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/DirTreeWalkerRel.java`:

```java
package it.pgp.xfiles.utils;

import java.io.File;
import java.util.Collection;
import java.util.Iterator;
import java.util.Stack;

/**
 * Created by pgp on 22/11/16
 */
public class DirTreeWalkerRel implements Iterator<DirTreeWalkerRel.BaseAndTargetFiles>{
    private Stack<BaseAndTargetFiles> stack;
    public DirTreeWalkerRel(File baseDir, File targetDir, Collection<String> filenames) {
        this.stack = new Stack<>();
        for (String fn : filenames) {
            stack.push(new BaseAndTargetFiles(new File(baseDir, fn), new File(targetDir, fn)));
        }
    }

    @Override
    public boolean hasNext() {
        return !stack.isEmpty();
    }

    @Override
    public BaseAndTargetFiles next() {
        // get next regular file from baseStack (if file is dir, expand it and go on)
        BaseAndTargetFiles bt = stack.pop();

        if (bt.startFile.isDirectory()) {
            for (File x : bt.startFile.listFiles()) {
                String fn = x.getName();
                File y = new File(bt.targetFile,fn);
                stack.push(new BaseAndTargetFiles(x, y));
            }
        }

        return bt;
    }

    public static class BaseAndTargetFiles {
        public File startFile;
        public File targetFile;

        public BaseAndTargetFiles(File startFile, File targetFile) {
            this.startFile = startFile;
            this.targetFile = targetFile;
        }

        public String getSrc() {
            return startFile.getAbsolutePath();
        }

        public String getDest() {
            return targetFile.getAbsolutePath();
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/DiskHelper.java`:

```java
package it.pgp.xfiles.utils;

import android.os.Environment;
import android.os.StatFs;

import java.io.InputStream;
import java.util.HashSet;
import java.util.Set;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.dialogs.RamdiskDialog;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.roothelperclient.RootHandler;
import it.pgp.xfiles.roothelperclient.RootHelperClient;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

// Web source:
// https://stackoverflow.com/questions/34375437/get-path-to-the-external-sdcard-in-android

public class DiskHelper {

    public enum MODES {
        MODE_INTERNAL,
        MODE_EXTERNAL,
        MODE_EXTERNAL_SD
    }

    public static final String[] commonInternalStoragePaths = {"/storage/emulated/0", "/sdcard"};

    private StatFs statFs;
    public String path;

    public DiskHelper(MODES mode) {
        try {
            switch(mode) {
                case MODE_INTERNAL:
                    path = Environment.getRootDirectory().getAbsolutePath();
                    statFs = new StatFs(path);
                    statFs.restat(path);
                    break;
                case MODE_EXTERNAL:
                    path = Environment.getExternalStorageDirectory().getAbsolutePath();
                    statFs = new StatFs(path);
                    statFs.restat(path);
                    break;
                case MODE_EXTERNAL_SD:
                    for(String str : getExternalMounts(null)) {
                        path = str;
                        statFs = new StatFs(str);
                        statFs.restat(str);
                        break;
                    }
                    break;
            }
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }

    public long getTotalMemory() {
        if(statFs == null) return 0;
        return statFs.getBlockCountLong() * statFs.getBlockSizeLong();
    }

    public long getFreeMemory() {
        if(statFs == null) return 0;
        return statFs.getAvailableBlocksLong() * statFs.getBlockSizeLong();
    }

    public long getBusyMemory() {
        if(statFs == null) return 0;
        long total = getTotalMemory();
        long free = getFreeMemory();
        return total - free;
    }

    public static Set<String> getExternalMounts(MainActivity activity) {
        FileOperationHelper helper = activity.getFileOpsHelper(ProviderType.LOCAL);
        Set<String> out = new HashSet<>();
        String reg = "(?i).*vold.*(vfat|ntfs|exfat|sdfat|fat32|ext3|ext4|fuseblk).*(rw,|ro,).*";
        StringBuilder sb = new StringBuilder();
        try {
            // root available, granted and enabled -> su -c mount
            // root not available, not granted or not enabled -> mount
            String[] command = (RootHandler.isRootAvailableAndGranted && helper instanceof RootHelperClient) ?
                    new String[]{"su","-c","mount"} : new String[]{"mount"};
            Process process = new ProcessBuilder().command(command).redirectErrorStream(true).start();
            process.waitFor();
            InputStream is = process.getInputStream();
            byte[] buffer = new byte[1024];
            while(is.read(buffer) != -1) {
                sb.append(new String(buffer));
            }
            is.close();
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        String[] lines = sb.toString().split("\n");
        for(String line : lines) {
            if(!line.toLowerCase().contains("asec") && line.matches(reg)) {
                String[] parts = line.split(" ");
                for(String part : parts)
                    if(part.startsWith("/") && !part.toLowerCase().contains("vold")) out.add(part);
            }
        }

        if(activity == null) return out;
        Set<String> out1 = new HashSet<>();
        // probe mount points found so far
        for(String mnt : out) {
            LocalPathContent lmnt = new LocalPathContent(mnt);
            if(!helper.isDir(lmnt)) {
                // try building fallback paths if they are not accessible
                String mnt1 = "/storage/" + lmnt.getName();
                if(!out1.contains(mnt1) && helper.isDir(new LocalPathContent(mnt1))) out1.add(mnt1);
            }
            else out1.add(mnt); // found mount point is readable without root
        }

        /*
        check common pathnames for internal storage
        motivation: on some devices (e.g. some Huawei phones), getExternalStorageDirectory() returns the external memory card, instead of the phone memory
        - indeed, given the API method name, THIS ONE should be the correct behaviour, but on the overwhelming majority of Android devices,
        that method returns the internal mass storage path instead - so in order to have also a bookmark for internal memory, we check commonly used
        path names as well
        */
        for(String mnt : commonInternalStoragePaths) {
            if(helper.isDir(new LocalPathContent(mnt))) {
                out1.add(mnt);
                break; // assume all the commonly used names represent the same partition, even if more than one is available
            }
        }

        /* if RAM disk is mounted, show it as well */
        if(helper.isDir(new LocalPathContent(RamdiskDialog.mountpath)))
            out1.add(RamdiskDialog.mountpath);
        return out1;
    }

    private static final long MEGABYTE = 1048576;

    public static String humanReadableByteCount(long bytes, boolean si, boolean showInMB) {
        if(showInMB) {
            long ret = bytes / MEGABYTE;
            return ret + " MB";
        }
        int unit = si ? 1000 : 1024;
        if (bytes < unit) return bytes + " B";
        int exp = (int) (Math.log(bytes) / Math.log(unit));
        String pre = (si ? "kMGTPE" : "KMGTPE").charAt(exp - 1) + (si ? "" : "i");
        return String.format("%.1f %sB", bytes / Math.pow(unit, exp), pre);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/FavoritesList.java`:

```java
package it.pgp.xfiles.utils;

import java.util.Arrays;
import java.util.Collection;
import java.util.Set;
import java.util.TreeSet;

public class FavoritesList<T> {
    public T a;
    public Set<String> paths; // favorites as remote paths

    public FavoritesList(T a, String... paths) {
        this.a = a;
        this.paths = new TreeSet<>(Arrays.asList(paths));
    }

    public FavoritesList(T a, Collection<String> paths) {
        this.a = a;
        if(paths instanceof TreeSet) this.paths = (Set<String>)paths;
        else this.paths = new TreeSet<>(paths);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/FileOperationHelper.java`:

```java
package it.pgp.xfiles.utils;

import android.support.annotation.Nullable;

import java.io.IOException;
import java.util.BitSet;
import java.util.Date;
import java.util.List;

import it.pgp.xfiles.CopyMoveListPathContent;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;
import it.pgp.xfiles.roothelperclient.resps.folderStats_resp;
import it.pgp.xfiles.service.BaseBackgroundTask;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;

/**
 * Created by pgp on 26/01/17
 */

public interface FileOperationHelper {
    // constants
    String ALREADY_EXIST = "A file or directory with the same name already exists";

    // TODO change return value of every method to boolean or int and remove IOException
    String createFileOrDirectory(BasePathContent filePath, FileMode fileOrDirectory, FileCreationAdvancedOptions... fileOptions) throws IOException;
    void createLink(BasePathContent originPath, BasePathContent linkPath, boolean isHardLink) throws IOException;
    void deleteFilesOrDirectories(List<BasePathContent> files) throws IOException; // files as full pathnames
    void copyMoveFilesToDirectory(CopyMoveListPathContent files, BasePathContent dstFolder) throws IOException;
    boolean renameFile(BasePathContent oldPathname, BasePathContent newPathname) throws IOException; // true: rename ok
    SingleStatsItem statFile(BasePathContent pathname) throws IOException;
    folderStats_resp statFiles(List<BasePathContent> files) throws IOException;
    folderStats_resp statFolder(BasePathContent pathname) throws IOException;

    boolean exists(BasePathContent pathname);
    boolean isFile(BasePathContent pathname);
    boolean isDir(BasePathContent pathname);

    byte[] hashFile(BasePathContent pathname,
                    HashRequestCodes hashAlgorithm,
                    BitSet dirHashOpts) throws IOException;

    GenericDirWithContent listDirectory(BasePathContent directory);
    GenericDirWithContent listArchive(BasePathContent archivePath);

    int compressToArchive(BasePathContent srcDirectory,
                           BasePathContent destArchive,
                           @Nullable Integer compressionLevel,
                           @Nullable Boolean encryptHeaders,
                           @Nullable Boolean solidMode,
                           @Nullable String password,
                           @Nullable List<String> filenames) throws IOException;

    List<FileOpsErrorCodes> extractFromArchive(List<BasePathContent> srcArchives, // subDir taken from here
                                         BasePathContent destDirectory,
                                         @Nullable String password,
                                         @Nullable Iterable<String> filenames,
                                         boolean smartDirectoryCreation) throws IOException;

    int setDates(BasePathContent file,
                     @Nullable Date accessDate,
                     @Nullable Date modificationDate);

    int setPermissions(BasePathContent file, int permMask);

    int setOwnership(BasePathContent file,
                     @Nullable Integer ownerId,
                     @Nullable Integer groupId);

    void initProgressSupport(BaseBackgroundTask task);
    void destroyProgressSupport();

}

```

`app/src/main/java/it/pgp/xfiles/utils/FileSaveFragment.java`:

```java
package it.pgp.xfiles.utils;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.Context;
import android.graphics.Color;
import android.os.Bundle;
import android.text.InputType;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

/** Allow user to select destination directory and to enter filename */
public class FileSaveFragment extends DialogFragment implements OnItemClickListener {

	/*
	 * Use the unicode "back" triangle to indicate there is a parent 
	 * directory rather than an icon to minimise file dependencies.
	 * 
	 * You may have to find an alternative symbol if the font in use 
	 * doesn't support this character. 
	 * */ 
	final String PARENT =  "\u25C0";
	
	private Callbacks mCallbacks;
	private ArrayList<File> directoryList;
	private String defaultExtension;
	
	// The widgets required to provide the UI.
	private TextView currentPath;
	private EditText fileName;
	private ListView directoryView;

	// The directory the user has selected.
	private File currentDirectory;
	
	// Resource IDs
	private int resourceID_OK;
	private int resourceID_Cancel;
	private int resourceID_Title;
	private int resourceID_EditHint;
	private int resourceID_DefaultName;
	private int resourceID_Icon; 
	
	/**  Does file already exist?
	 * */
	public static boolean FileExists(String absolutePath, String fileName) {
		File checkFile = new File(absolutePath, fileName);
		return checkFile.exists();
	}
	
	/** Restrict valid filenames to alpha-numeric (word chars) only. Simplifies reserved 
	 *  path character validation at cost of forbidding spaces, hyphens and underscores.
	 *  
	 *  @param fileName - filename without extension or path information.
	 *  
	 * */
	public static boolean IsAlphaNumeric(String fileName) {
		fileName = NameNoExtension(fileName);
		return (!fileName.matches(".*\\W+.*"));
	}
	
	/** Return the characters following the final full stop
	 *  in the filename.
	 * */
	public static String Extension(String fileName) {
		
		String extension = "";
		
		if (fileName.contains(".")) {
			String[] tokens = fileName.split("\\.(?=[^\\.]+$)");
			extension = tokens[1];
		}		

		return extension;
	}
	
	/** Return the filename without any extension. Extension is taken to be the
	 *  characters following the final full stop (if any) in the filename.
	 * @param fileName - File name with or without extension.
	 * */
	public static String NameNoExtension(String fileName) {
		
		if (fileName.contains(".")) {
			String[] tokens = fileName.split("\\.(?=[^\\.]+$)");
			fileName = tokens[0];
		}		

		return fileName;
	}
	
	
	/** 
	 * Signal to / request action of host activity.
	 * 
	 * */
	public interface Callbacks {

		/** Hand potential file details to context for validation.
		 *  @param absolutePath - Absolute path to target directory.
		 *  @param fileName     - Filename. Not guaranteed to have a type extension.
		 *  
		 * */
		boolean onCanSave(String absolutePath, String fileName);

		/**  
		 * Hand validated path and name to context for use.
		 * If user cancels absolutePath and filename are handed out as null.
		 * 
		 *  @param absolutePath - Absolute path to target directory.
		 *  @param fileName     - Filename. Not guaranteed to have a type extension.
		 * */
		void onConfirmSave(String absolutePath, String fileName);
	}

	/** Create new instance of a file save popup. 
	 * 
	 * @param defaultExtension - Display a default extension for file to be created. Can be null.
	 * @param resourceID_OK - String resource ID for the positive (OK) button.
	 * @param resourceID_Cancel - String resource ID for the negative (Cancel) button.
	 * @param resourceID_Title - String resource ID for the dialogue's title.
	 * @param resourceID_EditHint - String resource ID for the filename edit widget.
	 * @param resourceID_DefaultName - String resource ID for the filename edit widget.
	 * @param resourceID_Icon - Drawable resource ID for the dialogue's title bar icon.
	 * */
    public static FileSaveFragment newInstance(String defaultExtension,
    		                                   int resourceID_OK, 
    		                                   int resourceID_Cancel, 
    		                                   int resourceID_Title, 
    		                                   int resourceID_EditHint,
											   int resourceID_DefaultName,
    		                                   int resourceID_Icon) {
    	FileSaveFragment frag = new FileSaveFragment();
    	
    	Bundle args = new Bundle();
    	args.putString("extensionList", defaultExtension);
    	args.putInt("captionOK", resourceID_OK);
    	args.putInt("captionCancel", resourceID_Cancel);
    	args.putInt("popupTitle", resourceID_Title);
    	args.putInt("editHint", resourceID_EditHint);
		args.putInt("defaultName", resourceID_DefaultName);
    	args.putInt("popupIcon", resourceID_Icon);
    	frag.setArguments(args);
        return frag;
    }

    /** Note the parent activity for callback purposes.
     *  @param activity - parent activity
     * */
	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
        // The containing activity is expected to implement the fragment's 
        // callbacks otherwise it can't react to item changes.
        if (!(activity instanceof Callbacks)) {
            throw new IllegalStateException("Activity must implement fragment's callbacks.");
        }

        mCallbacks = (Callbacks) activity;
        directoryList = new ArrayList<>();
        defaultExtension = getArguments().getString("extensionList");
        resourceID_OK = getArguments().getInt("captionOK");
        resourceID_Cancel = getArguments().getInt("captionCancel");
        resourceID_Title = getArguments().getInt("popupTitle");
        resourceID_EditHint = getArguments().getInt("editHint");
		resourceID_DefaultName = getArguments().getInt("defaultName");
        resourceID_Icon = getArguments().getInt("popupIcon");
        
	}

	/** Build the popup.  
	 * */
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

        /* 
         * Use the same callback for [OK] & [Cancel]. 
         * Hand out nulls to indicate abandonment. 
         * */
       
		/* 
		 * We want to make this a transportable piece of code so don't want an XML
		 * layout dependency so layout is set up in code.
		 * 
		 *   [ListView of directory names                         ]
		 *   [                                                    ]
		 *   [                                                    ]
		 *   [                                                    ]
		 *   ------------------------------------------------------
		 *   {current path}/ [ Enter Filename  ] {default extension}  
		 * 
		 * */
	
		// Set up the container view.
		LinearLayout.LayoutParams rootLayout = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
				                                                             ViewGroup.LayoutParams.WRAP_CONTENT,
				                                                             0.0F);
		LinearLayout root = new LinearLayout(getActivity());
		root.setOrientation(LinearLayout.VERTICAL);
		root.setLayoutParams(rootLayout);

		/* 
		 * Set up initial sub-directory list.
		 * 
		 * */
		currentDirectory = Misc.internalStorageDir;
		directoryList = getSubDirectories(currentDirectory);
		DirectoryDisplay displayFormat = new DirectoryDisplay(getActivity(), directoryList);

		/*
		 * Fix the height of the listview at 150px, enough to show 3 or 4 entries at a time.
		 * Don't want the popup shrinking and growing all the time. Tried it. 
		 * Most disconcerting.
		 * */
		LinearLayout.LayoutParams listViewLayout = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
																				ViewGroup.LayoutParams.MATCH_PARENT,
                                                                                 0.7F);
		directoryView = new ListView(getActivity());
		directoryView.setLayoutParams(listViewLayout);
		directoryView.setAdapter(displayFormat);
		directoryView.setOnItemClickListener(this);
		root.addView(directoryView);
		
		View horizDivider = new View(getActivity()); 
		horizDivider.setBackgroundColor(Color.CYAN);
		root.addView(horizDivider,
				     new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, 2));		

		/*
		 * Now set up the filename entry area.
		 * 
		 * {current path}/ [Enter Filename         ] {default extension}
		 * 
		 * */
		LinearLayout nameArea = new LinearLayout(getActivity());
		nameArea.setOrientation(LinearLayout.HORIZONTAL);
		nameArea.setLayoutParams(rootLayout);
		root.addView(nameArea);
		
	    currentPath = new TextView(getActivity());
		currentPath.setText(currentDirectory.getAbsolutePath() + "/");
		nameArea.addView(currentPath);
		
		/*
		 * We want the filename input area to be as large as possible, but still leave
		 * enough room to show the path and any default extension that may be supplied
		 * so we give it a weight of 1.
		 * */
		LinearLayout.LayoutParams fileNameLayout = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
				                                                                 ViewGroup.LayoutParams.WRAP_CONTENT,
				                                                                 1.0F );
		fileName = new EditText(getActivity());
		fileName.setHint(resourceID_EditHint);
		fileName.setText(getResources().getText(resourceID_DefaultName)+"_"); // TODO Pass filename in constructor
		fileName.setGravity(Gravity.START);
		fileName.setLayoutParams(fileNameLayout);
		fileName.setInputType(InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS);
		nameArea.addView(fileName);
		
		/*
		 *  We only display the default extension if one has been supplied. 
		 *    
		 * */
		if (defaultExtension != null ) {
			TextView defaultExt = new TextView(getActivity());
			defaultExt.setText(defaultExtension);
			defaultExt.setGravity(Gravity.START);
			defaultExt.setPadding(2, 0, 6, 0);
			nameArea.addView(defaultExt);
		}
		
		// Use the standard AlertDialog builder to create the popup. 
		//     Android custom and practice is normally to chain calls from the builder, but
		//     it can become an unreadable and unmaintainable mess very quickly so I don't.
		Builder popupBuilder = new AlertDialog.Builder(getActivity());
		popupBuilder.setView(root);
		popupBuilder.setIcon(resourceID_Icon);
		popupBuilder.setTitle(resourceID_Title);

		// Set up anonymous methods to handle [OK] & [Cancel] click.
		popupBuilder.setPositiveButton(resourceID_OK,
				(dialog, whichButton) -> {/*Empty method. Method defined in onStart();*/});

		popupBuilder.setNegativeButton(resourceID_Cancel,
				(dialog, whichButton) -> {});
		
        return popupBuilder.create();
    }

	
	/** 
	 * Provide the [PositiveButton] with a click listener that doesn't 
	 * dismiss the popup if the user has entered an invalid filename. 
	 * 
	 * */
	@Override
	public void onStart() {
	    super.onStart();    
	    AlertDialog d = (AlertDialog)getDialog();
	    if(d != null) {
	        d.getButton(Dialog.BUTTON_POSITIVE).setOnClickListener(v -> {
                String absolutePath = currentDirectory.getAbsolutePath();
                String filename = fileName.getText().toString();
                if (mCallbacks.onCanSave(absolutePath, filename)) {
                    dismiss();
                    mCallbacks.onConfirmSave(absolutePath, filename);
                }
			});
	    }
	}
	
	/** Identify all sub-directories within a directory. 
	 *  @param directory The directory to walk.
	 * */
	private ArrayList<File> getSubDirectories(File directory) {

		ArrayList<File> directories = new ArrayList<>();

		//////////////////////
		// legacy
//		File[] files = directory.listFiles();

		// Allow navigation back up the tree when the directory is a sub-directory.
		if (directory.getParent() != null) {
			directories.add(new File(PARENT));
		}

		// new
		GenericDirWithContent gdwc = MainActivity.getRootHelperClient().listDirectory(new LocalPathContent(directory.getAbsolutePath()));
		if (gdwc.errorCode != null) {
			Toast.makeText(getActivity(), "Error listing directories: "+gdwc.errorCode.getValue(), Toast.LENGTH_SHORT).show();
			return directories;
		}
		//////////////////////
		
		// Enumerate any sub-directories in this directory.
//		if (files != null) {
//			for (File f : files) {
//				if (f.isDirectory() && !f.isHidden()) {
//					directories.add(f);
//				}
//			}
//		}

		for (BrowserItem b : gdwc.content) {
			if (b.isDirectory)
				directories.add(new File(gdwc.dir+"/"+b.getFilename()));
		}
		
		return directories;
		
	}
	
	/** 
	 * Refresh the listview's display adapter using the content
	 * of the identified directory. 
	 * 
	 * */
	@Override
	public void onItemClick(AdapterView<?> arg0, View list, int pos, long id )
	{
		
		File selected;
		
		if (pos >= 0 || pos < directoryList.size()) {
			selected = directoryList.get(pos);
			String name = selected.getName();

			// Are we going up or down?
			if (name.equals(PARENT)) {
				currentDirectory = currentDirectory.getParentFile();
			}
			else {
				currentDirectory = 	selected;
			}

			// Refresh the listview display for the newly selected directory.
			directoryList = getSubDirectories(currentDirectory);
			DirectoryDisplay displayFormatter = new DirectoryDisplay(getActivity(), directoryList);
			directoryView.setAdapter(displayFormatter);
			
			// Update the path TextView widget.  Tell the user where he or she is.
			String path = currentDirectory.getAbsolutePath();
			if (currentDirectory.getParent() != null) {
				path += "/";
			}
			currentPath.setText(path);	
		}
	}	
	
	/** Display the sub-directories in a selected directory. 
	 * 
	 * */
	private class DirectoryDisplay 
		extends ArrayAdapter<File> {
		
		public DirectoryDisplay(Context context, List<File> displayContent) {
			super(context, android.R.layout.simple_list_item_1, displayContent);
		}
		
		/** Display the name of each sub-directory. 
		 * */
		@Override
		public View getView(int position, View convertView, ViewGroup parent) {

			// We assume that we've got a parent directory...
			TextView textview = (TextView) super.getView( position, convertView, parent );
			
			// If we've got a directory then get its name.
			if ( directoryList.get(position) != null ) {
				textview.setText( directoryList.get(position).getName() );
			}

			return textview;
		}		
		
		
	}

}

```

`app/src/main/java/it/pgp/xfiles/utils/FileSelectFragment.java`:

```java
package it.pgp.xfiles.utils;

import android.app.Activity;
import android.app.AlertDialog;
import android.app.AlertDialog.Builder;
import android.app.Dialog;
import android.app.DialogFragment;
import android.content.Context;
import android.graphics.Color;
import android.graphics.drawable.Drawable;
import android.os.Bundle;
import android.support.annotation.NonNull;
import android.view.Gravity;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.AdapterView.OnItemClickListener;
import android.widget.AdapterView.OnItemLongClickListener;
import android.widget.ArrayAdapter;
import android.widget.LinearLayout;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;

import java.io.File;
import java.io.FilenameFilter;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

/** Select a directory or a file. 
 * 
 * */
public class FileSelectFragment extends DialogFragment 
		implements OnItemClickListener, OnItemLongClickListener {

	/*
	 * Use the unicode "back" triangle to indicate there is a parent 
	 * directory rather than an icon to minimise file dependencies.
	 * 
	 * You may have to find an alternative symbol if the font in use 
	 * doesn't support this character. 
	 * */ 
	final String PARENT =  "\u25C0"; 
	
	private Callbacks mCallbacks;
	private ArrayList<File> fileList;
	
	// The widgets required to provide the UI.
	private TextView selectedPath;
	private TextView selectedFile;
	private LinearLayout root;
	private ListView directoryView;

	// The directory the user has selected.
	private File currentDirectory;
	private File currentFile;
	
	// Resource IDs
	private int resourceID_OK;
	private int resourceID_Cancel;
	private int resourceID_Title;
	private int resourceID_Icon; 
	private int resourceID_Dir;
	private int resourceID_File;

	// How the popup is to be used.
	private Mode selectionMode;
	
	// Filtered view of the directories.
	private FilenameFilter fileFilter;
	
	/** How do we want to use the selector? */
	public enum Mode {
		DirectorySelector,
		FileSelector
	}
	
	/** 
	 * Signal to / request action of host activity.
	 * 
	 * */
	public interface Callbacks {

		/**  
		 * Hand selected path and name to context for use.
		 * If user cancels absolutePath and filename are handed out as null.
		 * 
		 *  @param absolutePath - Absolute path to target directory.
		 *  @param fileName     - Filename. Will be null if Mode = DirectorySelector
		 *    
		 * */
		void onConfirmSelect(String absolutePath, String fileName);
		
		
		/** Allow the client activity to check file content / format whilst the user
		 *  still has the popup in view.
		 *  
		 *  The alternative is to provide a custom filter that examines file content
		 *  as it goes, but that could get very slow very quickly especially for binary
		 *  files. 
		 *  
		 * */
		boolean isValid(String absolutePath, String fileName);
	
	}

	/** Provide a standard filter to match any file with an extension in the supplied list. 
	 *  Case insensitive..
	 *  Directories are always accepted.
	 *  
	 *   @param fileExtensions List of file extensions including full stop. .xml, .txt etc. 
	 * */
	public static FilenameFilter FiletypeFilter(final ArrayList<String> fileExtensions) {
		  return (directory, fileName) -> {

              File f = new File(String.format("%s/%s", directory.getAbsolutePath(), fileName));

              // We let all directories through.
              boolean matched = f.isDirectory();

              if (!matched) {
                  for(String s : fileExtensions) {
                      s = String.format(".{0,}\\%s$", s);
                      s = s.toUpperCase(Locale.getDefault());
                      fileName = fileName.toUpperCase(Locale.getDefault());
                      matched = fileName.matches(s);
                      if (matched) {
                          break;
                      }
                  }
              }

             return matched;

          };
	}
	
	/** Create new instance of a file save popup. 
	 * 
	 * @param selectionMode - Directory selector or File selector?
	 * @param resourceID_OK - String resource ID for the positive (OK) button.
	 * @param resourceID_Cancel - String resource ID for the negative (Cancel) button.
	 * @param resourceID_Title - String resource ID for the dialogue's title.
	 * @param resourceID_Icon - Drawable resource ID for the dialogue's title bar icon.
	 * @param resourceID_Directory - Drawable resource ID for a directory icon. Distinguish dirs from files.
	 * @param resourceID_File - Drawable resource ID for a file icon.
	 * */
    public static FileSelectFragment newInstance(Mode selectionMode,
    		                                     int resourceID_OK,
    		                                     int resourceID_Cancel,
    		                                     int resourceID_Title,
    		                                     int resourceID_Icon,
    		                                     int resourceID_Directory,
    		                                     int resourceID_File,
												 String... startDirectory) {

    	FileSelectFragment frag = new FileSelectFragment();
    	
    	Bundle args = new Bundle();
    	args.putInt("mode", selectionMode.ordinal());
    	args.putInt("captionOK", resourceID_OK);
    	args.putInt("captionCancel", resourceID_Cancel);
    	args.putInt("popupTitle", resourceID_Title);
    	args.putInt("iconPopup", resourceID_Icon);
    	args.putInt("iconDirectory", resourceID_Directory);
    	args.putInt("iconFile", resourceID_File);
    	if (startDirectory.length > 0 && selectionMode == Mode.DirectorySelector)
    		args.putString("currentDirectory",startDirectory[0]);

    	frag.setArguments(args);
        return frag;
    }	
	
    /** Optional. Allow restriction of file names/types displayed for selection. 
     * @param fileFilter - May be null. Custom rule for selecting directories/files.
     * 
     * */
    public void setFilter(FilenameFilter fileFilter) {
    	this.fileFilter = fileFilter;
    }

    /** Note the parent activity for callback purposes.
     *  @param activity - parent activity
     * */
	@Override
	public void onAttach(Activity activity) {
		super.onAttach(activity);
        // The containing activity is expected to implement the fragment's 
        // callbacks otherwise it can't react to item changes.
        if (!(activity instanceof Callbacks)) {
            throw new IllegalStateException("Activity must implement fragment's callbacks.");
        }

        mCallbacks = (Callbacks) activity;
        fileList = new ArrayList<>();
        resourceID_OK = getArguments().getInt("captionOK");
        resourceID_Cancel = getArguments().getInt("captionCancel");
        resourceID_Title = getArguments().getInt("popupTitle");
        resourceID_Icon = getArguments().getInt("iconPopup");
        resourceID_File = getArguments().getInt("iconFile");
        resourceID_Dir = getArguments().getInt("iconDirectory");
        selectionMode = Mode.values()[getArguments().getInt("mode")];

        // current directory provided by user, or default if not provided
		String startDir = getArguments().getString("currentDirectory");
		if (startDir != null)
			currentDirectory = new File(startDir);
	}

	/** Build the popup */
	@Override
    public Dialog onCreateDialog(Bundle savedInstanceState) {

        /* 
         * Use the same callback for [OK] & [Cancel]. 
         * Hand out nulls to indicate abandonment. 
         * */
       
		/* 
		 * We want to make this a transportable piece of code so don't want an XML
		 * layout dependency so layout is set up in code.
		 * 
		 *   [ListView of directory & file names                         ]
		 *   [                                                    ]
		 *   [                                                    ]
		 *   [                                                    ]
		 *   ------------------------------------------------------
		 *   {current path}/ {selected file}  
		 * 
		 * */
	
		// Set up the container view.
		LinearLayout.LayoutParams rootLayout = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
				                                                             ViewGroup.LayoutParams.WRAP_CONTENT, 
				                                                             0.0F);
		root = new LinearLayout(getActivity());
		root.setOrientation(LinearLayout.VERTICAL);
		root.setLayoutParams(rootLayout);

		/* 
		 * Set up initial sub-directory list.
		 * 
		 * */
		if (currentDirectory == null)
			currentDirectory = Misc.internalStorageDir;
		fileList = getDirectoryContent(currentDirectory);
		DirectoryDisplay displayFormat = new DirectoryDisplay(getActivity(), fileList);

		/*
		 * Fix the height of the listview at 150px, enough to show 3 or 4 entries at a time.
		 * Don't want the popup shrinking and growing all the time. Tried it. 
		 * Most disconcerting.
		 * */
		LinearLayout.LayoutParams listViewLayout = new LinearLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
																				ViewGroup.LayoutParams.MATCH_PARENT,
																				0.7F);
		directoryView = new ListView(getActivity());
		directoryView.setLayoutParams(listViewLayout);
		directoryView.setAdapter(displayFormat);
		/* 
		 * Click on file or directory - select
		 * Long click on directory    - open directory
		 *  */
		directoryView.setOnItemClickListener(this);
		directoryView.setOnItemLongClickListener(this);
		root.addView(directoryView);
		
		View horizDivider = new View(getActivity()); 
		horizDivider.setBackgroundColor(Color.CYAN);
		root.addView(horizDivider,
				     new ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, 2));		

		/*
		 * Now set up the filename display area.
		 * 
		 * {current path}/ {selected file}
		 * 
		 * */
		LinearLayout nameArea = new LinearLayout(getActivity());
		nameArea.setOrientation(LinearLayout.HORIZONTAL);
		nameArea.setLayoutParams(rootLayout);
		root.addView(nameArea);
		
	    selectedPath = new TextView(getActivity());
		selectedPath.setText(currentDirectory.getAbsolutePath() + "/");
		nameArea.addView(selectedPath);
		
		// We only display a selected filename in FileSelector mode. 
		if (selectionMode == Mode.FileSelector ) {
			selectedFile = new TextView(getActivity());
			selectedFile.setGravity(Gravity.LEFT);
			selectedFile.setPadding(2, 0, 6, 0);
			nameArea.addView(selectedFile);
		}
		
		// Use the standard AlertDialog builder to create the popup. 
		// Avoid call chaining, keep the code readable and maintainable.
		Builder popupBuilder = new AlertDialog.Builder(getActivity());
		popupBuilder.setView(root);
		popupBuilder.setIcon(resourceID_Icon);
		popupBuilder.setTitle(resourceID_Title);

		// Set up anonymous methods to handle [OK] & [Cancel] clicks.
		popupBuilder.setPositiveButton(resourceID_OK,
				(dialog, whichButton) -> {/* Empty method. See onStart */});

		popupBuilder.setNegativeButton(resourceID_Cancel,
				(dialog, whichButton) -> {});
		
        return popupBuilder.create();
    }
	
	/** 
	 * Provide the [PositiveButton] with a click listener that doesn't 
	 * dismiss the popup if the user has chosen a file (or directory)
	 * that is unsuitable. 
	 * 
	 * */
	@Override
	public void onStart() {
	    super.onStart();    
	    AlertDialog d = (AlertDialog)getDialog();
	    if(d != null) {
	        d.getButton(Dialog.BUTTON_POSITIVE).setOnClickListener(v -> {
                String absolutePath = currentDirectory.getAbsolutePath();
                String filename = null;
                if(currentFile != null) {
                    filename = currentFile.getName();
                }

                if (mCallbacks.isValid(absolutePath, filename)) {
                    dismiss();
                    mCallbacks.onConfirmSelect(absolutePath, filename);
                }
            });
	    }
	}	

	/** Single short click/press selects a file.
	 * */
	@Override
	public void onItemClick(AdapterView<?> arg0, View arg1, int pos, long id) {

		currentFile = null;
		
		String path = currentDirectory.getAbsolutePath();
		if (currentDirectory.getParent() != null) {
			path += "/";
		}
		selectedPath.setText(path);	

		if (pos >= 0 || pos < fileList.size()) {
			currentFile = fileList.get(pos);
			
			String name = currentFile.getName();
			
			if (!currentFile.isDirectory() && 
			    !name.equals(PARENT) &&
			    selectionMode == Mode.FileSelector ) {
				selectedFile.setText(currentFile.getName());
			}
				
			
		}
		
	}

	/** Long click/press on a directory selects and opens that directory. 
	 * */
	@Override
	public boolean onItemLongClick(AdapterView<?> arg0, View arg1, int pos, long id) {
		
		File selected;
		
		if (pos >= 0 || pos < fileList.size()) {
			selected = fileList.get(pos);
			String name = selected.getName();

			if (selected.isDirectory() || name.equals(PARENT)) {

				// Are we going up or down?
				if (name.equals(PARENT)) {
					currentDirectory = currentDirectory.getParentFile();
				}
				else {
					currentDirectory = 	selected;
				}

				// Refresh the listview display for the newly selected directory.
				fileList = getDirectoryContent(currentDirectory);
				DirectoryDisplay displayFormatter = new DirectoryDisplay(getActivity(), fileList);
				directoryView.setAdapter(displayFormatter);
				
				// Update the path TextView widgets.  Tell the user where he or she is and clear the selected file.
				currentFile = null;
				String path = currentDirectory.getAbsolutePath();
				if (currentDirectory.getParent() != null) {
					path += "/";
				}

				selectedPath.setText(path);	
				if (selectionMode == Mode.FileSelector) {
					selectedFile.setText(null);
				}
				
			}
			

		}

		
		return false;
	}

	/** Identify all sub-directories and files within a directory. 
	 *  @param directory The directory to walk.
	 * */
	private ArrayList<File> getDirectoryContent(File directory) {
		
		ArrayList<File> displayedContent = new ArrayList<>();

		// legacy
//		File[] files;
//		if (fileFilter != null) {
//	        files = directory.listFiles(fileFilter);
//		}
//		else {
//			files = directory.listFiles();
//		}

		// Allow navigation back up the tree when the directory is a sub-directory.
		if (directory.getParent() != null) {
			displayedContent.add(new File(PARENT));
		}

		// new
		GenericDirWithContent gdwc = MainActivity.getRootHelperClient().listDirectory(new LocalPathContent(directory.getAbsolutePath()));
		if (gdwc.errorCode != null) {
			Toast.makeText(getActivity(), "Error listing directories: "+gdwc.errorCode.getValue(), Toast.LENGTH_SHORT).show();
			return displayedContent;
		}
		
		// Get the content in this directory.
//		if (files != null) {
//			for (File f : files) {
//
//				boolean canDisplay = true;
//
//				if (selectionMode == Mode.DirectorySelector && !f.isDirectory()) {
//					canDisplay = false;
//				}
//
//				canDisplay = (canDisplay && !f.isHidden());
//
//				if (canDisplay) {
//					displayedContent.add(f);
//				}
//			}
//		}

		for (BrowserItem b : gdwc.content) {
			boolean canDisplay = true;

			if (selectionMode == Mode.DirectorySelector && !b.isDirectory)
				canDisplay = false;

			if (canDisplay) {
				displayedContent.add(new File(gdwc.dir+"/"+b.getFilename()));
			}
		}
		
		return displayedContent;
		
	}
	
	/** Display the sub-directories in a selected directory. 
	 * 
	 * */
	private class DirectoryDisplay 
		extends ArrayAdapter<File> {
		
		public DirectoryDisplay(Context context, List<File> displayContent) {
			super(context, android.R.layout.simple_list_item_1, displayContent);
		}
		
		/** Display the name of each sub-directory. 
		 * */
		@NonNull
		@Override
		public View getView(int position, View convertView, @NonNull ViewGroup parent) {

			int iconID = resourceID_File;
			// We assume that we've got a parent directory...
			TextView textview = (TextView) super.getView( position, convertView, parent );
			
			// If we've got a directory then get its name.
			// If it's a file we show the file icon, if a directory then the directory icon.
			if ( fileList.get(position) != null ) {
				String name = fileList.get(position).getName();
				textview.setText(name);

				if (fileList.get(position).isDirectory()) {
					iconID = resourceID_Dir;
				}

				if (name.equals(PARENT)) {
					iconID = -1;
				}
				
				// Icon to the left of the text.
				if (iconID > 0 ){
					Drawable icon = getActivity().getResources().getDrawable( iconID );
					textview.setCompoundDrawablesWithIntrinsicBounds(icon,null, null, null );	
				}
				
			}

			return textview;
		}		
		
		
	}

	
}

```

`app/src/main/java/it/pgp/xfiles/utils/GenericDBHelper.java`:

```java
package it.pgp.xfiles.utils;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.util.AbstractMap;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

import it.pgp.xfiles.sftpclient.AuthData;
import it.pgp.xfiles.smbclient.SmbAuthData;
import it.pgp.xfiles.sftpclient.InsertFailedException;

/**
 * Created by pgp on 01/07/17
 * For storing both sftp credentials and favorite PathContents
 */

public class GenericDBHelper extends SQLiteOpenHelper {

    private static final String DbName = "XFilesDB";
    private static final int DbVersion = 2;

    private static final String credentialsVaultTableName = "sftpCredentialsAndFavorites";
    private static final String localFavoritesTableName = "localFavorites";
    private static final String xreFavoritesTableName = "xreFavorites";
    private static final String smbCredentialsVaultTableName = "smbCredentialsAndFavorites";


    // fields of credentials & favorites table for sftp
    public static final String username_field = "username";
    public static final String domain_field = "domain";
    public static final String host_field = "host"; // valid only for SMB, equivalent of domain in SFTP
    public static final String port_field = "port";
    public static final String password_field = "password";
    public static final String listOfFavorites_field = "favoritePaths"; // serialized list of remote path strings

    // 1 field for local favorites table (path string)
    private static final String local_favorites_content_field = "path";

    private static final String xre_favorites_server_field = "server";
    private static final String xre_favorites_path_field = "path";

    private static SQLiteDatabase db;

    /*
    username, domain, port: strings (port is integer)
    for sftp access (domain being a domain name or a IP)
    type: password string (can be null, in which case private keys are tried upon authentication)
    */

    private static final String sqlCreateStatement_sftpCredentialsAndFavorites =
            "CREATE TABLE IF NOT EXISTS "+ credentialsVaultTableName +"(" +
                    username_field+" TEXT," +
                    domain_field+" TEXT," +
                    port_field+" INTEGER," +
                    password_field +" TEXT," +
                    listOfFavorites_field+" BLOB," +
                    "PRIMARY KEY ("+username_field+","+domain_field+","+port_field+")" +
                    ");";

    // do not enforce primary key constraints, read all rows into hashset, on add favorite, truncate table and rewrite all rows
    private static final String sqlCreateStatement_localFavorites =
            "CREATE TABLE IF NOT EXISTS "+ localFavoritesTableName +"(" +
                    local_favorites_content_field +" TEXT," +
                    "PRIMARY KEY ("+local_favorites_content_field+"));";

    private static final String sqlCreateStatement_xreFavorites =
            "CREATE TABLE IF NOT EXISTS "+ xreFavoritesTableName +"(" +
                    xre_favorites_server_field +" TEXT," +
                    xre_favorites_path_field +" TEXT," +
                    "PRIMARY KEY ("+xre_favorites_server_field+","+xre_favorites_path_field+"));";

    private static final String sqlCreateStatement_smbCredentialsAndFavorites =
            "CREATE TABLE IF NOT EXISTS "+ smbCredentialsVaultTableName +"(" +
                    username_field+" TEXT," +
                    domain_field+" TEXT," +
                    host_field+" TEXT," +
                    port_field+" INTEGER," +
                    password_field +" TEXT," +
                    listOfFavorites_field+" BLOB," +
                    "PRIMARY KEY ("+username_field+","+domain_field+","+host_field+","+port_field+")" +
                    ");";

    /**********************************
     Operations on local favorites table
     **********************************/

    public Map<Long,String> getAllRowsOfLocalFavoritesTable() {
        String[] cols = new String[] {"oid",local_favorites_content_field};
        Cursor mCursor = db.query(false, localFavoritesTableName,cols,null,null, null, null, null, null);
        Map<Long,String> map = new HashMap<>();
        if (mCursor!=null) {
            while (mCursor.moveToNext()) {
                // 64 bit ints clearly not needed for a few favorites
                map.put(mCursor.getLong(0),mCursor.getString(1));
            }
            mCursor.close();
        }
        return map;
    }

    public Map<Long,Map.Entry<String, String>> getAllRowsOfXreFavoritesTable() {
        String[] cols = new String[] {"oid",xre_favorites_server_field,xre_favorites_path_field};
        Cursor mCursor = db.query(false, xreFavoritesTableName,cols,null,null, null, null, null, null);
        Map<Long,Map.Entry<String,String>> map = new HashMap<>();
        if (mCursor!=null) {
            while (mCursor.moveToNext()) {
                // 64 bit ints clearly not needed for a few favorites
                map.put(mCursor.getLong(0),
                        new AbstractMap.SimpleEntry<>(
                                mCursor.getString(1),
                                mCursor.getString(2))
                );
            }
            mCursor.close();
        }
        return map;
    }

    // get oid by pathname, for update without changing oid (delete & insert changes oid)
    // returns null if value not found in table
//    public Integer getRowOfLocalFavoritesTable(String path) {
//        Cursor mCursor = db.query(true,
//                localFavoritesTableName,
//                new String[] {"oid",local_favorites_content_field},
//                local_favorites_content_field+"=?",
//                new String[]{path},
//                null, null, null, null);
//        Integer ret = null; // remaining to null == not found
//        if (mCursor!=null) {
//            while (mCursor.moveToNext()) {
//                ret = (int)mCursor.getLong(0);
//                break; // only first result needed (anyway there cannot be more than one since there is primary key constraint over the only field in this table
//            }
//            mCursor.close();
//        }
//        return ret;
//    }

//    public void insertAllRowsOfFavoritesTable(Set<BasePathContent> s) throws IOException {
//        // truncate table before insert
//        db.delete(localFavoritesTableName,null,null);
//        // perform bulk insert
//        db.beginTransaction();
//        for (BasePathContent b : s) {
//            ByteArrayOutputStream bos = new ByteArrayOutputStream();
//            ObjectOutput out = new ObjectOutputStream(bos);
//            out.writeObject(b);
//            out.flush();
//            byte[] bytes = bos.toByteArray();
//            ContentValues cv = new ContentValues();
//            cv.put(local_favorites_content_field,bytes);
//            db.insert(localFavoritesTableName,null,cv);
//            db.setTransactionSuccessful();
//        }
//        db.endTransaction();
//    }

    /**
     * @param path to be added to local favorites
     * @return map entry with inserted oid and path string
     * @throws InsertFailedException if that path already exists
     */
    public Map.Entry<Long,String> addLocalFavorite(String path) throws InsertFailedException {
        ContentValues cv = new ContentValues();
        cv.put(local_favorites_content_field,path);
        long oid = db.insert(localFavoritesTableName,null,cv);
        if (oid == -1) throw new InsertFailedException(); // row already exists
        return new AbstractMap.SimpleEntry<>(oid,path);
    }

    /**
     * @param path to be added to XFiles remote favorites
     * @return map entry with: inserted oid and [map entry of server and path string]
     * @throws InsertFailedException if that server-path pair already exists
     */
    public Map.Entry<Long,Map.Entry<String,String>> addXreFavorite(String server, String path) throws InsertFailedException {
        ContentValues cv = new ContentValues();
        cv.put(xre_favorites_server_field,server);
        cv.put(xre_favorites_path_field,path);
        long oid = db.insert(xreFavoritesTableName,null,cv);
        if (oid == -1) throw new InsertFailedException(); // row already exists
        Map.Entry<String,String> me = new AbstractMap.SimpleEntry<>(server,path);
        return new AbstractMap.SimpleEntry<>(oid,me);
    }


    /**
     * @param oldPath old local path favorite
     * @param newPath new local path favorite (to replace old in the same oid)
     * @return true on update ok
     */
    public boolean updateLocalFavorite(String oldPath, String newPath) {
        ContentValues cv = new ContentValues();
        cv.put(local_favorites_content_field,newPath);
        return db.update(localFavoritesTableName,cv,local_favorites_content_field+"=?",new String[]{oldPath}) > 0;
    }

    public boolean updateXreFavorite(String oldServer,
                                     String newServer,
                                     String oldPath,
                                     String newPath) {
        ContentValues cv = new ContentValues();
        cv.put(xre_favorites_server_field,newServer);
        cv.put(xre_favorites_path_field,newPath);
        String whereString = xre_favorites_server_field+"=? AND "+xre_favorites_path_field+"=?";
        String[] whereArgs = new String[]{oldServer,oldPath};
        return db.update(xreFavoritesTableName,cv,whereString,whereArgs) > 0;
    }

    public boolean deleteRowFromLocalFavoritesTable(long oid) {
        return db.delete(localFavoritesTableName,"oid="+oid,null)>0;
    }

    public boolean deleteRowFromXreFavoritesTable(long oid) {
        return db.delete(xreFavoritesTableName,"oid="+oid,null)>0;
    }

    /********************************************************
     Operations on sftp table
     ********************************************************/

//    public Map<Long,AuthData> getAllSftpCreds() {
//        String[] cols = new String[] {"oid",username_field,domain_field,port_field,password_field};
//        Map<Long,AuthData> m = new HashMap<>();
//        Cursor mCursor = db.query(true, credentialsVaultTableName,cols,null,null, null, null, null, null);
//        if (mCursor!=null) {
//            while (mCursor.moveToNext()) {
//                // uid = username@domain:port
//                AuthData a = new AuthData(mCursor.getString(1),mCursor.getString(2),mCursor.getInt(3),mCursor.getString(4));
//                m.put(mCursor.getLong(0),a);
//            }
//            mCursor.close();
//        }
//        return m;
//    }

    public <T> Map<Long,T> getAllCreds(T ref) {
        String[] cols = (ref instanceof AuthData)?
                new String[] {"oid",username_field,domain_field,port_field,password_field}:
                new String[] {"oid",username_field,domain_field,host_field,port_field,password_field};
        String srcTableName = (ref instanceof AuthData)?credentialsVaultTableName:smbCredentialsVaultTableName;
        Map<Long,T> m = new HashMap<>();
        Cursor mCursor = db.query(true, srcTableName,cols,null,null, null, null, null, null);
        if (mCursor!=null) {
            while (mCursor.moveToNext()) {
                // uid = username@domain:port
                T a = (ref instanceof AuthData)?
                        (T)new AuthData(mCursor.getString(1),mCursor.getString(2),mCursor.getInt(3),mCursor.getString(4)):
                        (T)new SmbAuthData(mCursor.getString(1),mCursor.getString(2),mCursor.getString(3),mCursor.getInt(4),mCursor.getString(5));
                m.put(mCursor.getLong(0), a);
            }
            mCursor.close();
        }
        return m;
    }

    public <T> Map<Long,FavoritesList<T>> getAllCredsWithFavs(T ref) {
        String[] cols = (ref instanceof AuthData)?
                new String[] {"oid",username_field,domain_field,port_field,password_field,listOfFavorites_field}:
                new String[] {"oid",username_field,domain_field,host_field,port_field,password_field,listOfFavorites_field};
        String srcTableName = (ref instanceof AuthData)?credentialsVaultTableName:smbCredentialsVaultTableName;
        Map<Long,FavoritesList<T>> m = new HashMap<>();
        Cursor mCursor = db.query(true, srcTableName,cols,null,null, null, null, null, null);
        if (mCursor!=null) {
            while (mCursor.moveToNext()) {
                T a = (ref instanceof AuthData)?
                        (T)new AuthData(mCursor.getString(1),mCursor.getString(2),mCursor.getInt(3),mCursor.getString(4)):
                        (T)new SmbAuthData(mCursor.getString(1),mCursor.getString(2),mCursor.getString(3),mCursor.getInt(4),mCursor.getString(5));
                byte[] b = mCursor.getBlob(5 + ((ref instanceof SmbAuthData)?1:0));
                if (b == null || b.length == 0) {
                    m.put(mCursor.getLong(0),new FavoritesList<>(a));
                }
                else {
                    ObjectInputStream ois;
                    Set<String> favs;
                    try {
                        ois = new ObjectInputStream(new ByteArrayInputStream(b));
                        favs = (Set) ois.readObject();
                        m.put(mCursor.getLong(0),new FavoritesList<>(a,favs));
                    }
                    catch (IOException | ClassNotFoundException e) {
                        Log.e(getClass().getName(),"Exception: "+e.getMessage());
                        e.printStackTrace();
                        m.put(mCursor.getLong(0),new FavoritesList<>(a));
                    }
                }
            }
            mCursor.close();
        }
        return m;
    }

    public <T> Map.Entry<Long,T> insertCred(T ref, String username, String domain, int port, String password, String... host) throws InsertFailedException {
        // password can be null
        ContentValues cv = new ContentValues();
        cv.put(username_field,username);
        cv.put(domain_field,domain);
        cv.put(port_field,port);
        cv.put(password_field,password);
        if(ref instanceof SmbAuthData) {
            cv.put(host_field,host[0]);
            long oid = db.insert(smbCredentialsVaultTableName,null,cv);
            if (oid == -1) throw new InsertFailedException();
            return new AbstractMap.SimpleEntry(oid, new SmbAuthData(username,domain,host[0],port,password)); // for updating list adapter in SmbVaultActivity
        }
        else {
            long oid = db.insert(credentialsVaultTableName,null,cv);
            if (oid == -1) throw new InsertFailedException();
            return new AbstractMap.SimpleEntry(oid, new AuthData(username,domain,port,password)); // for updating list adapter in SmbVaultActivity
        }
    }

    public <T> boolean updateCred(long oldOid, T newAuthData_) {
        ContentValues cv = new ContentValues();
        if (newAuthData_ instanceof SmbAuthData) { // TODO make AuthData and SmbAuthData implement common interface or SmbAuthData subclass of AuthData
            SmbAuthData newAuthData = (SmbAuthData) newAuthData_;
            cv.put(username_field, newAuthData.username);
            cv.put(domain_field, newAuthData.domain);
            cv.put(host_field, newAuthData.host);
            cv.put(port_field, newAuthData.port);
            cv.put(password_field, newAuthData.password == null?"": newAuthData.password);
            return db.update(smbCredentialsVaultTableName,cv,"oid="+oldOid,null)>0;

        }
        else if (newAuthData_ instanceof AuthData){
            AuthData newAuthData = (AuthData) newAuthData_;
            cv.put(username_field, newAuthData.username);
            cv.put(domain_field, newAuthData.domain);
            cv.put(port_field, newAuthData.port);
            cv.put(password_field, newAuthData.password == null?"": newAuthData.password);
            return db.update(credentialsVaultTableName,cv,"oid="+oldOid,null)>0;
        }
        else throw new RuntimeException("invalid authdata type");
//        else {
//            try {
//                Map<String,Object> newAuthData = (Map)newAuthData_;
//                Constructor<ContentValues> ctor = ContentValues.class.getDeclaredConstructor(HashMap.class);
//                ctor.setAccessible(true);
//                cv = ctor.newInstance(new HashMap(newAuthData));
//                // ASSUMPTION: must provide all the kv pairs even if not all are updated
//                return db.update((newAuthData.containsKey("host")?smbCredentialsVaultTableName:credentialsVaultTableName),cv,"oid="+oldOid,null)>0;
//            } catch (Exception e) {
//                throw new RuntimeException(e);
//            }
//        }
    }

    /**
     * delete all favorites: along with credentials (deleteRowFromSftpTable(long))
     * or with empty list as input
     * @param oldOid
     * @param newFavs
     * @return true on update success
     */

    public <T> boolean updateFavs(T ref, long oldOid, Set<String> newFavs) {
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutput out = new ObjectOutputStream(bos);
            out.writeObject(newFavs);
            out.flush();
            byte[] bytes = bos.toByteArray();
            ContentValues cv = new ContentValues();
            cv.put(listOfFavorites_field,bytes);
            return db.update(ref instanceof AuthData?credentialsVaultTableName:smbCredentialsVaultTableName,cv,"oid="+oldOid,null)>0;
        }
        catch (IOException e) {
            e.printStackTrace();
            return false;
        }
    }

    public <T> boolean deleteRowFromTable(T ref, long oid) {
        return db.delete(ref instanceof AuthData?credentialsVaultTableName:smbCredentialsVaultTableName,"oid="+oid,null)>0;
    }

    // input: (Smb)AuthData without password
    // output: (Smb)AuthData (possibly) with password

    public <T> T find(T a_) {
        if(a_ instanceof AuthData) {
            AuthData a = (AuthData) a_;
            String[] cols = new String[] {"oid",username_field,domain_field,port_field,password_field};
            String selection = username_field+"= ? and "+domain_field+" = ? and "+port_field+" = ?";
            String[] selectionArgs = new String[]{a.username,a.domain,a.port+""};
            Cursor mCursor = db.query(true, credentialsVaultTableName,cols,selection,selectionArgs, null, null, null, null);
            if (mCursor!=null) {
                AuthData o = null;
                if (mCursor.moveToNext()) {
                    o = new AuthData(mCursor.getString(1),mCursor.getString(2),mCursor.getInt(3),mCursor.getString(4));
                }
                mCursor.close();
                return (T) o;
            }
        }
        else {
            SmbAuthData a = (SmbAuthData) a_;
            String[] cols = new String[] {"oid",username_field,domain_field,host_field,port_field,password_field};
            String selection = username_field+"= ? and "+domain_field+"= ? and "+host_field+" = ? and "+port_field+" = ?";
            String[] selectionArgs = new String[]{a.username,a.domain,a.host,a.port+""};
            Cursor mCursor = db.query(true, smbCredentialsVaultTableName,cols,selection,selectionArgs, null, null, null, null);
            if (mCursor!=null) {
                SmbAuthData o = null;
                if (mCursor.moveToNext()) {
                    o = new SmbAuthData(mCursor.getString(1),mCursor.getString(2),mCursor.getString(3),mCursor.getInt(4),mCursor.getString(5));
                }
                mCursor.close();
                return (T) o;
            }
        }
        return null;
    }

    public GenericDBHelper(Context context) {
        super(context, DbName, null, DbVersion);
        if (db == null) db = getWritableDatabase();
    }

    @Override
    public void onCreate(SQLiteDatabase db) {
        db.execSQL(sqlCreateStatement_localFavorites);
        db.execSQL(sqlCreateStatement_sftpCredentialsAndFavorites);
        db.execSQL(sqlCreateStatement_xreFavorites);
        db.execSQL(sqlCreateStatement_smbCredentialsAndFavorites);
    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {

    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/GenericMRU.java`:

```java
package it.pgp.xfiles.utils;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Date;
import java.util.List;

/**
 * Created by pgp on 17/05/17
 *
 * MRU cache for archives' VMap representations - generic version
 */

public class GenericMRU<T,U> {

    private List<T> archivePaths;
    private List<U> vMaps;
    private List<Date> modified;

    Integer currentIndex;
    public final Integer maxIndex;

    public void decrementIndex() {
        currentIndex = (currentIndex + maxIndex -1) % maxIndex;
    }

    public void incrementIndex() {
        currentIndex = (currentIndex +1) % maxIndex;
    }

    public GenericMRU(Integer maxIndex) {
        this.maxIndex = maxIndex;
        clear();
    }

    public void clear() {
        vMaps = new ArrayList<>();
        modified = new ArrayList<>();
        archivePaths = new ArrayList<>();
        currentIndex = 0; // least recent index is (currentIndex + maxIndex -1) % maxIndex

        // add maxIndex elements to each list
        for (int i=0;i<maxIndex;i++) {
            vMaps.add(null);
            modified.add(null);
            archivePaths.add(null);
        }
    }

    // find methods
    private int findIndex(T archivePath) {
        for (int i=0;i<maxIndex;i++) {
            if (archivePath.equals(archivePaths.get(i)))
                return i;
        }
        return -1;
    }

    private void swapMruObjects(int i1, int i2) {
        if (i1 == i2) return;
        Collections.swap(archivePaths,i1,i2);
        Collections.swap(vMaps,i1,i2);
        Collections.swap(modified,i1,i2);
    }

    /*
    Return values:
        - true/false if file has/has not been modified since last entries reading
        - null if not present in MRU cache
     */
    public Boolean hasBeenModified(T archivePath, Date modifiedDate) {
        int foundIdx = findIndex(archivePath);
        if (foundIdx < 0) return null;
        return !(modified.get(foundIdx).equals(modifiedDate));
    }

    // tuple {archive, vmap, date}
    public Object[] getLatest() {
        return new Object[]{
                archivePaths.get(currentIndex),
                vMaps.get(currentIndex),
                modified.get(currentIndex)
        };
    }

    /*
    Checks whether a MRU entry exists for archivePath and, if so, whether the underlying file
    has been modified since last cache entry setting
    If not modified, returns the corresponding VMap, and brings the entry position to front,
    else returns null and invalidates that entry
    To be used by client in conjunction with setLatest
     */
    public U getByPath(T archivePath, Date modifiedDate) {
        int foundIdx = findIndex(archivePath);

        if (foundIdx >= 0) { // some entry exists
            if(modifiedDate == null) { // used in find within archive
                // we are not interested in checking whether the archive has been modified meanwhile,
                // we just look for an existing (by construction) mru entry
                return vMaps.get(foundIdx);
            }
            else if(modified.get(foundIdx).equals(modifiedDate)) {
                // OK, no file modification, bring on top...
                swapMruObjects(foundIdx,currentIndex);
                // ...then return the current vMap
                return vMaps.get(currentIndex);
            }
            else { // don't bring on top anything, delete that cache entry
                archivePaths.set(foundIdx,null);
                modified.set(foundIdx,null);
                vMaps.set(foundIdx,null);
                return null;
            }
        }
        else {
            // not found
            return null;
        }
    }

    // unconditionally get by path (for extraction from within archive)
    public U getByPath(T archivePath) {
        int foundIdx = findIndex(archivePath);
        if (foundIdx >= 0) { // some entry exists
            // OK, no file modification, bring on top and return the vMap
            swapMruObjects(foundIdx,currentIndex);
            // then return the current vMap
            return vMaps.get(currentIndex);
        }
        else {
            // not found
            return null;
        }
    }

    // unconditionally set latest
    // assumed to be called after a full archive entries retrieval
    public void setLatest(T archivePath, U vMap, Date modifiedDate) {
        // find current
        int foundIdx = findIndex(archivePath);
        if (foundIdx >= 0) {
            // unconditionally overwrite old cache entry for this archivePath, and bring to top
            vMaps.set(foundIdx,vMap);
            modified.set(foundIdx,modifiedDate);

            // simply bring this cache entry to top, swapping it with the current 0
            if (currentIndex != foundIdx)
                swapMruObjects(foundIdx,currentIndex);
        }
        else {
            // add a new entry, overwriting the least recent one
            incrementIndex();
            archivePaths.set(currentIndex,archivePath);
            vMaps.set(currentIndex,vMap);
            modified.set(currentIndex,modifiedDate);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/HashView.java`:

```java
package it.pgp.xfiles.utils;

import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Paint;
import android.graphics.Rect;
import android.view.View;

import it.pgp.Native;

//import android.graphics.Color;

public class HashView extends View {
//    final int[] colors8 = {Color.RED, Color.GREEN, Color.BLUE, Color.BLACK, Color.YELLOW, Color.CYAN, Color.MAGENTA, Color.WHITE};
//    final int[] colors16 = {0xFF000000,0xFF808080,0xFFC0C0C0,0xFFFFFFFF,
//                            0xFF800000,0xFFFF0000,0xFF808000,0xFFFFFF00,
//                            0xFF008000,0xFF00FF00,0xFF008080,0xFF00FFFF,
//                            0xFF000080,0xFF0000FF,0xFF800080,0xFFFF00FF};

//    final int[] colors1s = {0xFF000000,0xFF7F0000,0xFF7F006E,0xFF1F007F,
//            0xFF007F7F,0xFF007F00,0xFF7F7F00,0xFF7F4400,
//            0xFFFF8800,0xFFFFFF00,0xFF00FF00,0xFF00FFFF,
//            0xFF7F7F7F,0xFFFF00FF,0xFFFF0000,0xFFFFFFFF};

    /*
    2: Black + Red
    4: Black + RGB
    8: Black + RGB + White + CMY
    16: Black + RGB + White + CMY + others
     */

    final int[] colors16_Ordered = {0xFF000000,0xFFFF0000,0xFF00FF00,0xFF1F007F, // Black+RGB
            0xFFFFFFFF,0xFFFFFF00,0xFF00FFFF,0xFFFF00FF, // White + CMY
            0xFF7F0000,0xFF007F7F,0xFF007F00,0xFF7F7F00,
            0xFF7F4400,0xFF7F006E,0xFFFF8800,0xFF7F7F7F};

    PaintRect[][] M;

    private int width,height;
    public HashView(Context context, byte[] in, int gridSize, int bitsPerCell, int width, int height, int... truncateSize) {
        super(context);
        this.width = width;
        this.height = height;
        M = gridCalculator(in, gridSize, bitsPerCell, width, height, truncateSize.length>0 ? truncateSize[0] : gridSize);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        draw2(canvas, M);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(
                MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY),
                MeasureSpec.makeMeasureSpec(height,MeasureSpec.EXACTLY)
        );
    }

    boolean[] byteArrayToBitArray (byte[] b) {
        boolean[] x = new boolean[b.length*8];
        for (int j=0;j<b.length;j++) {
            for(int i=0;i<8;i++) {
                x[j*8+i] = ((b[j] & (1 << i)) > 0);
            }
        }
        return x;
    }

    int getBitSeqFromBooleanArray(int bit_index, int bit_length, boolean[] bb) {
        int a = 0;
        int m=1;
        for(int i=bit_index+bit_length-1;i>=bit_index;i--) {
            a += (bb[i])?m:0;
            m<<=1;
        }
        return a;
    }

    PaintRect[][] gridCalculator(byte[] b, int gridSize, int bitsPerCell, int width, int height, int truncateSize) {
        int rSize = Math.min(width, height) / truncateSize;
        int outSize = gridSize * gridSize * bitsPerCell;
        PaintRect[][] M = new PaintRect[truncateSize][truncateSize];

        byte[] outDigest = Native.spongeForHashViewShake(b,b.length,outSize/8);
        boolean[] bb = byteArrayToBitArray(outDigest);

        for (int i = 0; i < truncateSize; i++)
            for (int j = 0; j < truncateSize; j++) {
                Rect currentRect = new Rect(i * rSize, j * rSize, (i + 1) * rSize, (j + 1) * rSize);
                int rColor = getBitSeqFromBooleanArray(bitsPerCell*(gridSize*i+j),bitsPerCell,bb);

                Paint currentPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
                currentPaint.setStyle(Paint.Style.FILL);
                currentPaint.setColor(colors16_Ordered[rColor]);
                M[i][j] = new PaintRect(currentRect, currentPaint);
            }
        return M;
    }
    
    // optimized for 16 colors (4 bits, two mask operations per byte)
    PaintRect[][] gridCalculator4bit(byte[] b, int gridSize, int width, int height) {
        int rSize = Math.min(width, height) / gridSize;
        int outSize = gridSize * gridSize * 4;
        PaintRect[][] M = new PaintRect[gridSize][gridSize];
        
        byte[] outDigest = Native.spongeForHashViewShake(b,b.length,outSize/8);
        
        int halfByteIndex = 0; // 2 rects per byte

        for (int i = 0; i < gridSize; i++)
            for (int j = 0; j < gridSize; j++) {
                Rect currentRect = new Rect(i * rSize, j * rSize, (i + 1) * rSize, (j + 1) * rSize);
                
                int rColor = (halfByteIndex % 2 == 1)? outDigest[halfByteIndex>>1] & 0x0F : outDigest[halfByteIndex>>1] & 0xF0 >> 4;
                halfByteIndex++;

                Paint currentPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
                currentPaint.setStyle(Paint.Style.FILL);
                currentPaint.setColor(colors16_Ordered[rColor]);
                M[i][j] = new PaintRect(currentRect, currentPaint);
            }
        return M;
    }

    void draw2(Canvas canvas, PaintRect[][] M) {
        for (PaintRect[] aM : M)
            for (PaintRect anAM : aM)
                canvas.drawRect(anAM.rect, anAM.rPaint);
    }

    private static class PaintRect {
        Rect rect;
        Paint rPaint;

        PaintRect(Rect rect, Paint rPaint) {
            this.rect = rect;
            this.rPaint = rPaint;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/IntentUtil.java`:

```java
package it.pgp.xfiles.utils;

import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.ParcelFileDescriptor;
import android.util.Log;

import java.io.IOException;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

import it.pgp.Native;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;

public class IntentUtil {

    public static List<Uri> getShareSelectionFromIntent(Intent intent) {
        List<Uri> imageUris;
        Uri singleUri;

        singleUri = intent.getParcelableExtra(Intent.EXTRA_STREAM);
        if(singleUri == null) imageUris = intent.getParcelableArrayListExtra(Intent.EXTRA_STREAM);
        else imageUris = Collections.singletonList(singleUri);

        return imageUris;
    }

    public static Map.Entry<BasePathContent,List<String>> getCommonAncestorAndItems(Context context, List<Uri> uris) {
        List<String> selectedItems = new ArrayList<>();
        for(Uri uri : uris) {
            String tmp = ContentProviderUtils.getPathFromUri(context,uri);
            selectedItems.add(tmp);
            Log.d("getPath",uri.toString()+"\t"+tmp);
        }

        BasePathContent dirPath = new LocalPathContent(Misc.getLongestCommonPathFromPrefix(
                Misc.getLongestCommonPrefix(selectedItems)
        ));
        // trim prefixes from selectedItems once extracted dirPath
        for(int i=0; i<selectedItems.size(); i++)
            selectedItems.set(i,selectedItems.get(i).substring(dirPath.dir.length()+1));

        return new AbstractMap.SimpleEntry<>(dirPath,selectedItems);
    }

    public static List<String> retrievePathsFromUrisUsingProcFS(ContentResolver resolver, List<Uri> uris) throws IOException {
        List<String> paths = new ArrayList<>();

        for(Uri uri : uris) {
            ParcelFileDescriptor pfd = resolver.openFileDescriptor(uri,"r");
            String fdpath = Native.getPathFromFd(""+pfd.getFd());
            pfd.close();
            if (!fdpath.isEmpty()) paths.add(fdpath);
        }

        return paths;
    }

    public static Map.Entry<BasePathContent,List<String>> getCommonAncestorAndItems_mode2(Context context, List<Uri> uris) throws IOException {
        List<String> selectedItems = retrievePathsFromUrisUsingProcFS(context.getContentResolver(),uris);

        BasePathContent dirPath = new LocalPathContent(Misc.getLongestCommonPathFromPrefix(
                Misc.getLongestCommonPrefix(selectedItems)
        ));
        // trim prefixes from selectedItems once extracted dirPath
        for(int i=0; i<selectedItems.size(); i++)
            selectedItems.set(i,selectedItems.get(i).substring(dirPath.dir.length()+1));

        return new AbstractMap.SimpleEntry<>(dirPath,selectedItems);
    }

}

```

`app/src/main/java/it/pgp/xfiles/utils/MRUArray.java`:

```java
package it.pgp.xfiles.utils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

public class MRUArray<T> implements Iterable<T> {
    final Object[] items;
    final int capacity;
    int size = 0;
    int currentPos = 0; // currentPos: most recently added, older positions: currentPos-1 % size, currentPos-2 % size, ...

    boolean iterationDirection = false; // false: from oldest to current, true: from current to oldest

    private MRUArray(T[] items) {
        this.capacity = this.size = items.length;
        this.items = items;
        currentPos = capacity -1;
    }

    public MRUArray(int capacity) {
        this.capacity = capacity;
        items = new Object[capacity];
    }

    public MRUArray<T> withReverseIteration() {
        this.iterationDirection = true;
        return this;
    }

    // last collection item is treated as newest, first one as oldest
    public static <T> MRUArray<T> fromCollection(Collection<T> c) {
        MRUArray<T> m = new MRUArray<>(c.size());
        int i=0;
        for(T item: c) m.items[i++] = item;
        m.currentPos = m.capacity -1;
        m.size = m.capacity;
        return m;
    }

    // last array item is treated as newest, first one as oldest
    public static <T> MRUArray<T> fromArray(T[] a) {
        MRUArray<T> m = new MRUArray<>(a.length);
        int i=0;
        for(T item: a) m.items[i++] = item;
        m.currentPos = m.capacity -1;
        m.size = m.capacity;
        return m;
    }

    // use an existing array as support
    public static <T> MRUArray<T> fromMutableArray(T[] a) {
        return new MRUArray<>(a);
    }

    public List<T> toList() {
        List<T> l = new ArrayList<>();
        for(T i: this) l.add(i);
        return l;
    }

    // sets the newest, and returns the oldest, which gets removed (reference overwritten) from the array
    public T setCurrent(T item) {
        int pos = Misc.mod(currentPos+1, capacity);
        T oldest = (T) items[pos]; // TODO this will return null as oldest item, until the array is full
        currentPos = pos; // increment current position
        items[currentPos] = item;
        size = Math.min(capacity, size+1);
        return oldest;
    }

    public T get(int relativePos) { // relativePos: 0 to -size+1 (anyway any value is allowed, since we are using unsigned remainder)
        return (T)items[Misc.mod(currentPos+relativePos, capacity)];
    }

    public T getCurrent() {
        return (T)items[currentPos];
    }

    private Iterator<T> getIterator(boolean reverse) {
        return new Iterator<T>() {
            int pos = reverse ? currentPos : Misc.mod(currentPos-size+1, capacity); // currently oldest (or newest in reverse mode) item position
            int iterations = 0;
            final int incr = reverse ? -1 : +1;

            @Override
            public boolean hasNext() {
                return iterations < size;
            }

            @Override
            public T next() {
                T ret = (T)items[pos];
                pos = Misc.mod(pos+incr, capacity);
                iterations++;
                return ret;
            }
        };
    }

    public Iterable<T> fromOldestToCurrent() {
        return () -> getIterator(false);
    }

    public Iterable<T> fromCurrentToOldest() {
        return () -> getIterator(true);
    }

    @Override
    public Iterator<T> iterator() {
        return getIterator(iterationDirection);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        int idx=0;
        for(T i: this) sb.append(idx++==0 ? i.toString() : ","+i.toString());
        return "[" + sb.toString() + "]";
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/Misc.java`:

```java
package it.pgp.xfiles.utils;

import android.animation.ArgbEvaluator;
import android.animation.ObjectAnimator;
import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.content.Intent;
import android.graphics.Color;
import android.graphics.drawable.ColorDrawable;
import android.graphics.drawable.Drawable;
import android.net.ConnectivityManager;
import android.net.Uri;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.os.Environment;
import android.provider.Settings;
import android.telephony.TelephonyManager;
import android.util.Log;
import android.view.View;
import android.widget.AbsListView;
import android.widget.CheckedTextView;
import android.widget.Toast;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.lang.reflect.Method;
import java.math.BigInteger;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import it.pgp.xfiles.roothelperclient.ResponseCodes;

/**
 * Created by pgp on 23/06/17
 * Miscellaneous low-level util methods
 */

public class Misc {
    public static final char[] hexArray = "0123456789ABCDEF".toCharArray();
    public static File internalStorageDir = Environment.getExternalStorageDirectory();
    public static final byte[] EOL = new byte[2]; // end-of-list indication in RH protocol

    // do not confuse with remainder (% operator); mod always returns a non-negative integer
    public static int mod(int dividend, int divisor) {
        int result = dividend % divisor;
        return result < 0 ? result + divisor : result;
    }

    public static String toHexString(byte[] bytes) {
        char[] hexChars = new char[bytes.length * 2];
        for ( int j = 0; j < bytes.length; j++ ) {
            int v = bytes[j] & 0xFF;
            hexChars[j * 2] = hexArray[v >>> 4];
            hexChars[j * 2 + 1] = hexArray[v & 0x0F];
        }
        return new String(hexChars);
    }

    public static long castBytesToUnsignedNumber(byte[] b, Integer cut_) {
        long value = 0;
        int cut = b.length;
        if (cut_ != null) cut = cut_;
        for (int i = cut-1; i >= 0; i--)
            value = (value << 8) + (b[i] & 0xFF);
        return value;
    }

    public static long castBytesToUnsignedNumberWithBigInteger(byte[] b, Integer cut_) {
        BigInteger value = BigInteger.ZERO;
        int cut = b.length;
        if (cut_ != null) cut = cut_;
        for (int i = cut-1; i >= 0; i--) { // replace with decrement for for little endianness compliance
            value = value.shiftLeft(8);
            value = value.add(BigInteger.valueOf(b[i] & 0xFF));
        }
        return value.longValue();
    }

    public static byte[] castUnsignedNumberToBytes(long l, Integer cut_) {
        byte[] o = (cut_ == null)?new byte[8]:new byte[cut_];
        long mask = 0xFF;
        for (int i=0;i<o.length;i++) {
            o[i] = (byte) (l & mask);
            l >>= 8; // FIXME maybe better to replace with unsigned shift >>>
        }
        return o;
    }

    public static int receiveBaseResponse(DataInputStream i) throws IOException {
        byte resp = i.readByte();
        ResponseCodes c = ResponseCodes.getCode(resp);

        if(c != null) {
            switch (c) {
                case RESPONSE_OK:
                    return 0;
                case RESPONSE_ERROR:
                    byte[] errno_ = new byte[4];
                    i.readFully(errno_);
                    int errno = (int) castBytesToUnsignedNumber(errno_,4);
                    Log.e("roothelper", "Error returned from roothelper server: " + errno);
                    return errno;
                default:
                    throw new RuntimeException("Illegal response byte from roothelper server");
            }
        }
        else {
            throw new RuntimeException("Empty response from roothelper server");
        }
    }

    public static long receiveTotalOrProgress(DataInputStream i) throws IOException {
        byte[] b = new byte[8];
        i.readFully(b);
        return castBytesToUnsignedNumber(b,null);
    }

    public static String receiveStringWithLen(DataInputStream i) throws IOException {
        byte[] tmp = new byte[2];
        i.readFully(tmp);
        int len = (int) castBytesToUnsignedNumber(tmp,2);
        tmp = new byte[len];
        i.readFully(tmp);
        return new String(tmp);
    }

    public static void sendStringWithLen(OutputStream o, String s) throws IOException {
        byte[] b = s.getBytes();
        byte[] len = castUnsignedNumberToBytes(b.length,2);
        o.write(len);
        o.write(b);
    }

    @SafeVarargs
    public static <T> T[] concatAll(T[] first, T[]... rest) {
        int totalLength = first.length;
        for (T[] array : rest) {
            totalLength += array.length;
        }
        T[] result = Arrays.copyOf(first, totalLength);
        int offset = first.length;
        for (T[] array : rest) {
            System.arraycopy(array, 0, result, offset, array.length);
            offset += array.length;
        }
        return result;
    }

    public static String wordWrapEveryNChars(String text, int n) {
        String[] x = text.split("(?<=\\G.{" + n + "})");
        StringBuilder sb = new StringBuilder();
        for(String s : x) sb.append(s).append('\n');
        return sb.toString();
    }

    public static boolean writeStringToFilePath(String s, String path) {
        try (OutputStream o = new BufferedOutputStream(
                new FileOutputStream(path))) {
            o.write(s.getBytes());
            return true;
        }
        catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    // TODO TO BE TESTED
//    public static String getLongestCommonPrefix(String... strings) {
//        if (strings.length == 0) return "";
//        if (strings.length == 1) return strings[0];
//        int commonPrefixLength = 0;
//        while (allCharactersAreSame(strings, commonPrefixLength)) {
//            commonPrefixLength++;
//        }
//        return strings[0].substring(0, commonPrefixLength);
//    }
//
//    private static boolean allCharactersAreSame(String[] strings, int pos) {
//        String first = strings[0];
//        for (String curString : strings) {
//            if (curString.length() <= pos
//                    || curString.charAt(pos) != first.charAt(pos)) {
//                return false;
//            }
//        }
//        return true;
//    }

    public static String getLongestCommonPrefix(List<String> strings) {
        if (strings.size() == 0) return "";
        if (strings.size() == 1) return strings.get(0);
        int commonPrefixLength = 0;
        while (allCharactersAreSame(strings, commonPrefixLength)) {
            commonPrefixLength++;
        }
        return strings.get(0).substring(0, commonPrefixLength);
    }

    private static boolean allCharactersAreSame(List<String> strings, int pos) {
        String first = strings.get(0);
        for (String curString : strings) {
            if (curString.length() <= pos
                    || curString.charAt(pos) != first.charAt(pos)) {
                return false;
            }
        }
        return true;
    }

    public static String getLongestCommonPathFromPrefix(String s) {
        if (s.equals("") || s.equals("/")) return "/";
        int i = s.lastIndexOf('/');
        if (i < 0) throw new RuntimeException("Malformed common path prefix");
        return s.substring(0,i); // also valid for single selection, if not malformed (e.g. ending with /)
    }

    public static List<String> splitByteArrayOverByteAndEncode(byte[] b, byte targetByte) {
        List<String> outs = new ArrayList<>();
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        for (byte value : b) {
            if (value != targetByte) baos.write(value);
            else {
                outs.add(new String(baos.toByteArray())); // assumed default charset: UTF-8
                baos.reset();
            }
        }
        return outs;
    }

    // CSV escape (for checksum export)
    public static final String[] csvToBeEscaped = {"\"",",","\n"};

    public static final byte[] crlf = new byte[]{'\r','\n'};

    /**
     * - if filename contains any between { \n " , }, use enclosing quotes
     * - if filename contains " escape it as ""
     */
    public static String escapeForCSV(String filename) {
        boolean enclosingQuotes = false;
        for(String x : csvToBeEscaped)
            if(filename.contains(x)) {
                enclosingQuotes = true;
                break;
            }

        return enclosingQuotes?"\""+filename.replace("\"","\"\"")+"\"":filename;
    }

    public static void csvWriteRow(OutputStream o, List<String> row) throws IOException {
        for(int i=0;i<row.size()-1;i++)
            o.write((escapeForCSV(row.get(i))+",").getBytes(StandardCharsets.UTF_8));

        // fine to have IndexOutOfBounds with empty list
        o.write(escapeForCSV(row.get(row.size()-1)).getBytes(StandardCharsets.UTF_8));
        o.write(crlf);
    }

    public static View getViewByPosition(int pos, AbsListView listView) {
        final int firstListItemPosition = listView.getFirstVisiblePosition();
        final int lastListItemPosition = firstListItemPosition + listView.getChildCount() - 1;

        if (pos < firstListItemPosition || pos > lastListItemPosition ) {
            return listView.getAdapter().getView(pos, null, listView);
        } else {
            final int childIndex = pos - firstListItemPosition;
            return listView.getChildAt(childIndex);
        }
    }

    /**
     * Web source:
     * https://stackoverflow.com/questions/1247772/is-there-an-equivalent-of-java-util-regex-for-glob-type-patterns
     *
     * Converts a standard POSIX Shell globbing pattern into a regular expression
     * pattern. The result can be used with the standard {@link java.util.regex} API to
     * recognize strings which match the glob pattern.
     * <p/>
     * See also, the POSIX Shell language:
     * http://pubs.opengroup.org/onlinepubs/009695399/utilities/xcu_chap02.html#tag_02_13_01
     *
     * @param pattern A glob pattern.
     * @return A regex pattern to recognize the given glob pattern.
     */
    public static String convertGlobToRegex(String pattern) {
        StringBuilder sb = new StringBuilder(pattern.length());
        int inGroup = 0;
        int inClass = 0;
        int firstIndexInClass = -1;
        char[] arr = pattern.toCharArray();
        for (int i = 0; i < arr.length; i++) {
            char ch = arr[i];
            switch (ch) {
                case '\\':
                    if (++i >= arr.length) {
                        sb.append('\\');
                    } else {
                        char next = arr[i];
                        switch (next) {
                            case ',':
                                // escape not needed
                                break;
                            case 'Q':
                            case 'E':
                                // extra escape needed
                                sb.append('\\');
                            default:
                                sb.append('\\');
                        }
                        sb.append(next);
                    }
                    break;
                case '*':
                    if (inClass == 0)
                        sb.append(".*");
                    else
                        sb.append('*');
                    break;
                case '?':
                    if (inClass == 0)
                        sb.append('.');
                    else
                        sb.append('?');
                    break;
                case '[':
                    inClass++;
                    firstIndexInClass = i+1;
                    sb.append('[');
                    break;
                case ']':
                    inClass--;
                    sb.append(']');
                    break;
                case '.':
                case '(':
                case ')':
                case '+':
                case '|':
                case '^':
                case '$':
                case '@':
                case '%':
                    if (inClass == 0 || (firstIndexInClass == i && ch == '^'))
                        sb.append('\\');
                    sb.append(ch);
                    break;
                case '!':
                    if (firstIndexInClass == i)
                        sb.append('^');
                    else
                        sb.append('!');
                    break;
                case '{':
                    inGroup++;
                    sb.append('(');
                    break;
                case '}':
                    inGroup--;
                    sb.append(')');
                    break;
                case ',':
                    if (inGroup > 0)
                        sb.append('|');
                    else
                        sb.append(',');
                    break;
                default:
                    sb.append(ch);
            }
        }
        return sb.toString();
    }

    // discriminant for item duplication is type T's hashCode implementation
    public static <T> Map<T, Set<Integer>> createOccurrencesMap(Iterable<T> input) {
        Map<T,Set<Integer>> m = new HashMap<>();
        int i=0;
        for(T t : input) {
            Set<Integer> li = m.get(t);
            if(li==null) {
                li = new HashSet<>();
                li.add(i);
                m.put(t,li);
            }
            else li.add(i);
            i++;
        }
        return m;
    }

    // web source:
    // https://ssaurel.medium.com/create-a-blink-effect-on-android-3c76b5e0e36b
    public static void highlightListViewItem(int pos, AbsListView absListView) {
        final View view = getViewByPosition(pos, absListView);
        final Drawable oldBg = view.getBackground();
        int oldBgColor = (oldBg instanceof ColorDrawable) ? ((ColorDrawable) oldBg).getColor() : Color.TRANSPARENT;
        ObjectAnimator anim = ObjectAnimator.ofInt(view,"backgroundColor", oldBgColor, Color.GREEN, oldBgColor);
        anim.setDuration(2000);
        anim.setEvaluator(new ArgbEvaluator());
        anim.setRepeatCount(0);
        anim.start();
    }

    public static String escapeHtml(String s) {
        byte[] bb = s.getBytes(StandardCharsets.UTF_8);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        try {
            for(byte b : bb) {
                char c = (char)b;
                switch(c) {
                    case '&':  baos.write("&amp;".getBytes(StandardCharsets.UTF_8)); break;
                    case '\"': baos.write("&quot;".getBytes(StandardCharsets.UTF_8)); break;
                    case '\'': baos.write("&apos;".getBytes(StandardCharsets.UTF_8)); break;
                    case '<':  baos.write("&lt;".getBytes(StandardCharsets.UTF_8)); break;
                    case '>':  baos.write("&gt;".getBytes(StandardCharsets.UTF_8)); break;
                    default:   baos.write(b); break;
                }
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return new String(baos.toByteArray(),StandardCharsets.UTF_8);
    }

    public static boolean isWithinViewBounds(int xPoint, int yPoint, View v) {
        int[] l = new int[2];
        v.getLocationOnScreen(l);
        int x = l[0];
        int y = l[1];
        int w = v.getWidth();
        int h = v.getHeight();
        return xPoint >= x && xPoint <= x + w && yPoint >= y && yPoint <= y + h;
    }

    public static String getHumanReadableFileSize(long size) {
        if (size <= 0)
            return "0";

        String[] units = new String[] { "B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB" };
        int digitGroups = (int) (Math.log10(size) / Math.log10(1024));

        return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];
    }

    public static final View.OnClickListener ctvListener = v -> ((CheckedTextView)v).toggle();

    public static void copyToClipboard(Context context, String label, String content) {
        ClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
        clipboard.setPrimaryClip(ClipData.newPlainText(label, content));
        Toast.makeText(context, "Copied to clipboard", Toast.LENGTH_SHORT).show();
    }

    public static void launchWriteSettings(Context context) {
        Toast.makeText(context, "Please grant system settings write permission in order to use this toggle", Toast.LENGTH_SHORT).show();
        Intent i = new Intent(Settings.ACTION_MANAGE_WRITE_SETTINGS, Uri.parse("package:" + context.getPackageName()));
        i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
        context.startActivity(i);
    }

    public static boolean isHotspotEnabled(Context context) {
        /*
        public static int AP_STATE_DISABLING = 10;
        public static int AP_STATE_DISABLED = 11;
        public static int AP_STATE_ENABLING = 12;
        public static int AP_STATE_ENABLED = 13;
        public static int AP_STATE_FAILED = 14;
        */
        try {
            WifiManager manager = (WifiManager)context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
            Method method = manager.getClass().getDeclaredMethod("getWifiApState");
            method.setAccessible(true);
            return (Integer) method.invoke(manager, (Object[]) null) == 13;
        }
        catch(Exception e) {
            return false;
        }
    }

    // methods copied from CurrentToggles
    public static boolean isDataConnectionEnabled(Context context) {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            TelephonyManager tm = (TelephonyManager)context.getSystemService(Context.TELEPHONY_SERVICE);
            return tm.isDataEnabled();
        }
        else {
            ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
            try {
                Class<?> cmClass = Class.forName(cm.getClass().getName());
                Method method = cmClass.getDeclaredMethod("getMobileDataEnabled");
                method.setAccessible(true);
                return (Boolean)method.invoke(cm);
            }
            catch(Exception e) {
                e.printStackTrace();
            }
            return false;
        }
    }

    public static boolean isWifiEnabled(Context context) {
        WifiManager wifimanager = (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        if(wifimanager == null) return false; // WIFI_STATE.NO_ADAPTER_FOUND;
        return wifimanager.isWifiEnabled();
    }

    public static void pipe(InputStream is, OutputStream os) throws IOException {
        int n;
        byte[] buffer = new byte[4096];
        while((n = is.read(buffer)) > -1) {
            os.write(buffer, 0, n);   // Don't allow any extra bytes to creep in, final write
        }
        os.close();
    }

    public static boolean isValidURL(String urlString) {
        try {
            URL url = new URL(urlString);
            url.toURI();
            return true;
        } catch (Exception exception) {
            return false;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/NetworkUtils.java`:

```java
package it.pgp.xfiles.utils;

import android.app.Activity;
import android.content.Context;
import android.net.wifi.WifiManager;
import android.util.Log;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.zip.CRC32;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.adapters.XreAnnouncesAdapter;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;

public class NetworkUtils {

    /**
     * Web source:
     * https://stackoverflow.com/questions/23644997/android-send-udp-broadcast-silently-fails
     */
    public static synchronized void startXreAnnounceListenerThread(Activity activity, XreAnnouncesAdapter xreAnnouncesAdapter) {
        if(xreAnnounceReceiveSocket != null || xreAnnounceMulticastLock != null) {
            MainActivity.showToast("Announce receiver thread already running, updates could be not visible if the adapter has been recreated meanwhile");
            return;
        }

        WifiManager wifi = (WifiManager) activity.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        xreAnnounceMulticastLock = wifi.createMulticastLock("multicastLock");
        xreAnnounceMulticastLock.setReferenceCounted(true);
        xreAnnounceMulticastLock.acquire();

        new Thread(() -> {
            Log.d(xreAnnounceLogTag,"XRE announce receiver thread started");
            try {
                xreAnnounceReceiveSocket = new DatagramSocket(11111);
//                xreAnnounceReceiveSocket = new DatagramSocket(null);
//                xreAnnounceReceiveSocket.setReuseAddress(true);
//                xreAnnounceReceiveSocket.bind(new InetSocketAddress("0.0.0.0",11111));
//                xreAnnounceReceiveSocket.setBroadcast(true);
                for(;;) {
                    DatagramPacket data = new DatagramPacket(new byte[256], 256);
                    xreAnnounceReceiveSocket.receive(data);
                    String received = new String(data.getData(), data.getOffset(), data.getLength(), StandardCharsets.UTF_8);
                    Log.e(xreAnnounceLogTag,received);

                    XREPathContent xrpc = fromXREAnnounce(data);
                    if(xrpc != null) activity.runOnUiThread(()-> xreAnnouncesAdapter.add(new Pair<>(xrpc.serverHost,xrpc.dir)));
                }
            }
            catch(Exception e) {
                e.printStackTrace();
            }
            xreAnnounceReceiveSocket = null; // the dismiss listener or the onPause method in XREDirectShareActivity have closed the socket
            Log.d(xreAnnounceLogTag,"XRE announce receiver thread ended");
        }).start();
    }

    public static void shutdownMulticastListening() {
        if(xreAnnounceReceiveSocket != null) {
            xreAnnounceReceiveSocket.close();
            xreAnnounceReceiveSocket = null;
        }
        if(xreAnnounceMulticastLock != null) {
            xreAnnounceMulticastLock.release();
            xreAnnounceMulticastLock = null;
        }
    }

    public static XREPathContent fromXREAnnounce(DatagramPacket packet) {
        try {
            byte[] origin = packet.getData();
            int o = packet.getOffset();
            int l = packet.getLength();
            byte[] receivedChecksum = new byte[4];
            byte[] payload = new byte[l-4];
            System.arraycopy(origin,o,receivedChecksum,0,4);
            System.arraycopy(origin,o+4,payload,0,l-4);

            // verify checksum
            CRC32 crc = new CRC32();
            crc.update(payload);
            long computedChecksum = crc.getValue();
            if (computedChecksum != Misc.castBytesToUnsignedNumber(receivedChecksum,4)) {
                Log.e(xreAnnounceLogTag,"Verification failed for XRE announce");
                return null;
            }

            // format: 2 bytes for port, 2 bytes string length + host, 2 bytes string length + path
            byte[] tmp = new byte[2];
            System.arraycopy(payload,0,tmp,0,2);
            int port = (int)Misc.castBytesToUnsignedNumber(tmp,2);
            System.arraycopy(payload,2,tmp,0,2);
            int hostLength = (int)Misc.castBytesToUnsignedNumber(tmp,2);
            String host = new String(payload,4,hostLength, StandardCharsets.UTF_8);
            System.arraycopy(payload,4+hostLength,tmp,0,2);
            int pathLength = (int)Misc.castBytesToUnsignedNumber(tmp,2);
            String path = new String(payload,6+hostLength,pathLength, StandardCharsets.UTF_8);

            // while received in the UDP packet, port is still default (11111) hence ignored
            return new XREPathContent(host,path);
        }
        catch(Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    public static Map<String, List<String>> getInterfacesAddresses() {
        Map<String,List<String>> addresses = new HashMap<>();
        try {
            for (Enumeration<NetworkInterface> en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {
                NetworkInterface intf = en.nextElement();
                List<String> addressesOfInterface = new ArrayList<>();
                for (Enumeration<InetAddress> enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {
                    InetAddress inetAddress = enumIpAddr.nextElement();
                    if (!inetAddress.isLoopbackAddress())
                        addressesOfInterface.add(inetAddress.getHostAddress());
                }
                addresses.put(intf.getName(),addressesOfInterface);
            }
        }
        catch (Exception ignored) {}
        return addresses;
    }

    public static String getInterfaceAddressesAsString() {
        StringBuilder s = new StringBuilder();
        Map<String,List<String>> addresses = getInterfacesAddresses();
        for (Map.Entry<String,List<String>> t : addresses.entrySet()) {
            StringBuilder inner = new StringBuilder();
            for (String j : t.getValue())
                if (!j.isEmpty()) inner.append(j).append(" ");
            if (!inner.toString().isEmpty()) {
                s.append(t.getKey()).append(": ").append(inner);
                s.append("\n");
            }
        }
        return s.toString();
    }

    public static final String xreAnnounceLogTag = "XREANNOUNCE";
    public static DatagramSocket xreAnnounceReceiveSocket;
    public static WifiManager.MulticastLock xreAnnounceMulticastLock;
}

```

`app/src/main/java/it/pgp/xfiles/utils/Pair.java`:

```java
package it.pgp.xfiles.utils;

import android.support.annotation.NonNull;

import java.util.Objects;

public class Pair<I,J> implements Comparable<Pair<I,J>> {
    @NonNull public I i;
    @NonNull public J j;

    public Pair(@NonNull I i, @NonNull J j) {
        this.i = i;
        this.j = j;
    }

    public void set(Pair<I,J> p) {
        i = p.i;
        j = p.j;
    }

    public void set(I i, J j) {
        this.i = i;
        this.j = j;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Pair<?, ?> pair = (Pair<?, ?>) o;
        return Objects.equals(i, pair.i) &&
                Objects.equals(j, pair.j);
    }

    @Override
    public String toString() {
        return "("+i+","+j+")";
    }

    @Override
    public int compareTo(Pair<I, J> otherPair) {
        return this.toString().compareTo(otherPair.toString());
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/Predicate.java`:

```java
package it.pgp.xfiles.utils;

public interface Predicate<T> {
    boolean test(T item);
}

```

`app/src/main/java/it/pgp/xfiles/utils/ProgressConflictHandler.java`:

```java
package it.pgp.xfiles.utils;

import android.util.Log;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.dialogs.ConflictDialog;
import it.pgp.xfiles.enums.CopyMoveMode;
import it.pgp.xfiles.enums.conflicthandling.ConflictDecision;
import it.pgp.xfiles.enums.conflicthandling.ConflictType;
import it.pgp.xfiles.enums.conflicthandling.ErrorDecision;
import it.pgp.xfiles.service.BaseBackgroundTask;

/**
 * Class that handles progress and conflict resolution interactions for file copy, based on status map
 * code ported from python fileCopy_socketStatusMap
 */

public class ProgressConflictHandler {

    @FunctionalInterface
    private interface fromStatusInterface {
        void from(ProgressConflictHandler handler) throws IOException;
    }

    /////////////////////////////////////////
    private static void commonTransition(ProgressConflictHandler handler) throws IOException {
        long n = Misc.receiveTotalOrProgress(handler.rs.i);
        // should be equivalent to unsigned comparison: n < 2**64 -5
        Status s = Status.fromNumeric(n);
        if (n >= 0) {
            Log.d("Progress", "Size is: "+n);
            publishAfterSizeReceived(handler,n);
            handler.currentStatus = Status.SIZE;
        }
        else {
            if (handler.mode == CopyMoveMode.COPY) {
                if (s != Status.EOFs && s != Status.ERR && s != Status.CFL && s != Status.SKIP)
                    throw new RuntimeException("Expected EOFs, ERR, CFL or SKIP here, protocol error, n is "+n);
            }
            handler.currentStatus = s;
        }
    }

    private static void publishAfterSizeReceived(ProgressConflictHandler handler, long n) throws IOException {
        handler.currentFileSize = n;
        handler.task.publishProgressWrapper(
                new Pair<>(handler.currentFileCount,handler.totalFileCount),
                new Pair<>(0L,1L)
        );
    }

    // strategy for transition functions
    static fromStatusInterface fromEOF = handler -> {
        // TODO to be tested, increment total file count after receiving EOF
        handler.currentFileCount++;
        handler.totalSizeSoFar += handler.currentFileSize;

        // LEGACY
//        handler.task.publishProgressWrapper(
//                (int)Math.round(handler.currentFileCount*100.0/handler.totalFileCount),
//                0
//        );

        // NEW, uses total size info
        handler.task.publishProgressWrapper(
                new Pair<>(handler.totalSizeSoFar,handler.totalSize),
                new Pair<>(0L,1L)
        );

        commonTransition(handler);
    };

    static fromStatusInterface fromEOFs = handler -> {
        Log.d("Progress", "Received EOFs, all done, exiting...");
        handler.copyRunning = false;
    };

    static fromStatusInterface fromCFL = handler -> {
//        byte cflType = handler.rs.i.readByte();
        String x = Misc.receiveStringWithLen(handler.rs.i);
        String y = Misc.receiveStringWithLen(handler.rs.i);

        // abuse of notation, it is just a file/dir type for src and dest
        ConflictType xtype = ConflictType.fromNumeric(handler.rs.i.readByte()); // == cflType
        ConflictType ytype = ConflictType.fromNumeric(handler.rs.i.readByte());

        Log.d("Progress", "Conflict type is: "+((int)xtype.getValue())+" "+ xtype.name());
        Log.d("Progress", "Conflicting paths are: "+x+" of type "+xtype.name()+", "+y+" of type"+ytype.name());

        // launch conflict decision dialog and wait for it to be dismissed
        MainActivity.mainActivity.runOnUiThread(()->new ConflictDialog(
                MainActivity.mainActivity,
                xtype,
                x,
                ytype,
                y,
                handler // to set taken decision and optionally new filename
        ).show());
        synchronized (ConflictDecision.m) {
            try {
                ConflictDecision.m.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        handler.rs.o.write(handler.lastDecision.getValue());
        if (handler.lastDecision == ConflictDecision.CD_REN_SRC ||
                handler.lastDecision == ConflictDecision.CD_REN_DEST) {
            Misc.sendStringWithLen(handler.rs.o,handler.lastNewName);
        }

        commonTransition(handler);
    };

    static fromStatusInterface fromSKIP = handler -> {
        long outerProgressIncrement = Misc.receiveTotalOrProgress(handler.rs.i);
        long totalSizeProgressIncrement = Misc.receiveTotalOrProgress(handler.rs.i);
        Log.d("Progress", "Outer progress increment for skip item is: "+outerProgressIncrement);
        Log.d("Progress", "Total size progress increment for skip item is: "+totalSizeProgressIncrement);
        handler.currentFileCount += outerProgressIncrement;
        handler.totalSizeSoFar += totalSizeProgressIncrement;

        // update outer progress in MovingRibbonTwoBars
        // LEGACY
//        handler.task.publishProgressWrapper(
//                (int)Math.round(handler.currentFileCount*100.0/handler.totalFileCount),
//                0
//        );

        // END
        handler.task.publishProgressWrapper(
                new Pair<>(handler.totalSizeSoFar,handler.totalSize),
                new Pair<>(0L,1L)
        );

        commonTransition(handler);
    };

    static fromStatusInterface fromERR = handler -> {
        String x = Misc.receiveStringWithLen(handler.rs.i);
        String y = Misc.receiveStringWithLen(handler.rs.i);
        // @@@@@@@@@@@@@@@@@@@@@@@
        // abuse of notation, it is just a file/dir type for src and dest
        ConflictType xtype = ConflictType.fromNumeric(handler.rs.i.readByte());
        ConflictType ytype = ConflictType.fromNumeric(handler.rs.i.readByte());
        // @@@@@@@@@@@@@@@@@@@@@@@
        Log.d("Progress", "Error paths are: "+x+" of type "+xtype.name()+", "+y+" of type"+ytype.name());
        // TODO launch error decision dialog
        ErrorDecision dec = ErrorDecision.ED_CANCEL; // stub

        if (dec == ErrorDecision.ED_CANCEL) {
            Log.d("Progress", "Exiting copy on user cancel after error");
            handler.copyRunning = false;
            return;
        }
        handler.rs.o.write(dec.getValue());
        long n = Misc.receiveTotalOrProgress(handler.rs.i);
        Status s = Status.fromNumeric(n);
        if (n >= 0) {
            Log.d("Progress", "Size is: "+n);
            publishAfterSizeReceived(handler,n);
            handler.currentStatus = Status.SIZE;
        }
        else {
            if (s != Status.EOFs && s != Status.SKIP)
                throw new RuntimeException("Expected EOFs or SKIP here, protocol error");
            handler.currentStatus = Status.EOFs;
        }
    };

    static fromStatusInterface fromPROGRESS = handler -> {
        long n = Misc.receiveTotalOrProgress(handler.rs.i);
        if (n >= 0) {
            Log.d("Progress", "Progress is "+n);
            // update inner progress in MovingRibbonTwoBars
            // LEGACY
//            handler.task.publishProgressWrapper(
//                    (int)Math.round(handler.currentFileCount*100.0/handler.totalFileCount),
//                    (int)Math.round(n*100.0/handler.currentFileSize)
//            );
            // NEW, uses total size info
            handler.task.publishProgressWrapper(
                    new Pair<>((handler.totalSizeSoFar+n),handler.totalSize),
                    new Pair<>(n,handler.currentFileSize)
            );

            handler.currentStatus = Status.PROGRESS;
        }
        else handler.currentStatus = Status.fromNumeric(n);
    };

    static fromStatusInterface fromSIZE = handler -> fromPROGRESS.from(handler);
    /////////////////////////////////////////

    public enum Status {
        EOF(-1L,fromEOF),
        EOFs(-2L, fromEOFs),
        CFL(-3L, fromCFL),
        ERR(-4L, fromERR),
        SKIP(-5L, fromSKIP),
        SIZE(null, fromSIZE),
        PROGRESS(null, fromPROGRESS);

        final Long status;
        final fromStatusInterface transition;

        Status(Long status, fromStatusInterface transition) {
            this.status = status;
            this.transition = transition;
        }

        public Long getStatus() {
            return status;
        }

        public fromStatusInterface getTransition() {
            return transition;
        }

        private static final Map<Long,Status> m = new HashMap<Long,Status>(){{
            for (Status s : Status.values()) put(s.getStatus(),s); // just ignore null key overwrite
        }};

        public static Status fromNumeric(long n) {
            return m.get(n);
        }
    }

    //////////////////////////////////////

    private final CopyMoveMode mode; // for dealing with EOF-after-EOF behaviour only in move mode

    private final StreamsPair rs;
    private final BaseBackgroundTask task;
    private boolean copyRunning = true;
    private Status currentStatus = Status.SIZE;

    private long currentFileCount = 0;
    private long currentFileSize;
    private final long totalFileCount;

    private final long totalSize;
    private long totalSizeSoFar = 0; // rounded to last completed file

    public String lastNewName;
    public ConflictDecision lastDecision;

    public ProgressConflictHandler(StreamsPair rs,
                                   BaseBackgroundTask task,
                                   long totalFileCount,
                                   long totalSize,
                                   CopyMoveMode mode) {
        this.rs = rs;
        this.task = task;
        this.totalFileCount = totalFileCount;
        this.totalSize = totalSize;
        this.mode = mode;
    }

    public void start() throws IOException {
        commonTransition(this); // needed to receive first size info as size and not as progress
        while(copyRunning)
            currentStatus.getTransition().from(this);

        // check global return value at the end, show toast if there were errors
        int globalRet = Misc.receiveBaseResponse(rs.i);
        if (globalRet != 0) {
            String errOrWarn = "There were errors during "+mode.name().toLowerCase()+", please check output files/dirs";
            if (mode == CopyMoveMode.MOVE) errOrWarn += "\nPlease be aware that conflict resolution and cross-device transfers are not implemented yet for "+mode.name()+" mode";
            MainActivity.showToast(errOrWarn);
        }

    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/SelectImageButtonListener.java`:

```java
package it.pgp.xfiles.utils;

import android.content.Context;
import android.graphics.PorterDuff;
import android.view.MotionEvent;
import android.view.View;
import android.widget.ImageButton;

public class SelectImageButtonListener implements View.OnTouchListener {

    private final int color;

    public ImageButton startV;

    public SelectImageButtonListener(Context context, int color) {
        this.color = context.getResources().getColor(color);
    }

    @Override
    public boolean onTouch(View v, MotionEvent event) {
        if(v instanceof ImageButton) {
            switch (event.getAction()) {
                case MotionEvent.ACTION_DOWN:
                    startV = (ImageButton) v;
                    startV.getDrawable().setColorFilter(color, PorterDuff.Mode.SRC_ATOP);
                    v.invalidate();
                    break;
                case MotionEvent.ACTION_UP:
                    if (startV != null) {
                        // interceptor view has changed due to a too rapid gesture, clear state on the old view in that case
                        startV.getDrawable().clearColorFilter();
                        startV.invalidate();
                    }
                    if (v != startV) { // should never happen
                        ((ImageButton) v).getDrawable().clearColorFilter();
                        v.invalidate();
                    }
                    startV = null;
                    break;
            }
        }
        return false;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/StreamsPair.java`:

```java
package it.pgp.xfiles.utils;

import java.io.DataInputStream;
import java.io.OutputStream;

import it.pgp.xfiles.roothelperclient.RootHelperClient;

/**
 * Common supertype for {@link it.pgp.xfiles.roothelperclient.RemoteManager}
 * and {@link RootHelperClient.RootHelperStreams}
 */
public abstract class StreamsPair implements AutoCloseable {

    public DataInputStream i;
    public OutputStream o;

    @Override
    public void close() {
        try {i.close();} catch (Exception ignored) {}
        try {o.close();} catch (Exception ignored) {}
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/VMap.java`:

```java
package it.pgp.xfiles.utils;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import it.pgp.xfiles.utils.iterators.VMapAbstractIterable;
import it.pgp.xfiles.utils.iterators.VMapChildParentIterable;
import it.pgp.xfiles.utils.iterators.VMapFullTreeIterable;
import it.pgp.xfiles.utils.iterators.VMapSubTreeIterable;

/**
 * Created by pgp on 30/03/17
 * Java equivalent of auto-vivified dictionary in Python.
 * Provides getter and setter with varargs input for arbitrary-depth map nesting
 *
 * Used in XFiles to provide an internal tree representation of an archive's entries
 * (retrieved altogether on archive open)
 */
public class VMap {

    public Map<Object,Object> h; // nested map

    public VMap() {
        h = new HashMap<>();
    }

    public static class ValueAsKeyException extends RuntimeException {
        public ValueAsKeyException() {
            super("Tried to access value as key!");
        }
    }

    // containsKey: true if key exists, false if the key or any of its ancestors do not exist, or if any ancestor is already not a map

    public boolean containsKey(Collection<Object> keys) {
        return containsKey(keys.toArray());
    }

    public boolean containsKey(Object[] keys) {
        if (h==null) h = new HashMap<>();
        Map<Object,Object> currentLevelMap = h;
        for (int i=0;i<keys.length-1;i++) {
            if (currentLevelMap.get(keys[i]) == null) {
                return false;
            }
            try {
                currentLevelMap = (Map<Object, Object>) currentLevelMap.get(keys[i]);
            }
            catch (Exception e) {
                return false;
            }
        }

        return (currentLevelMap.get(keys[keys.length-1]) != null);
    }

    public void setEmpty(Collection<Object> keys) {
        set(new HashMap<>(),keys.toArray());
    }

    public void set(Object v, Object[] keys) throws ValueAsKeyException {
        if (h==null) h = new HashMap<>();
        Map<Object,Object> currentLevelMap = h;

        for (int i=0;i<keys.length-1;i++) {
            if (currentLevelMap.get(keys[i]) == null) {
                currentLevelMap.put(keys[i],new HashMap<>());
            }
            try {
                currentLevelMap = (Map<Object, Object>) currentLevelMap.get(keys[i]);
            }
            catch (Exception e) {
                throw new ValueAsKeyException();
            }
        }

        currentLevelMap.put(keys[keys.length-1],v);
    }

    public Object get(Object[] keys) throws ValueAsKeyException {
        if (h==null) h = new HashMap<>();
        Map<Object,Object> currentLevelMap = h;
        if(keys.length == 0) return currentLevelMap;
        for (int i=0;i<keys.length-1;i++) {
            if (currentLevelMap.get(keys[i]) == null) {
                return null;
            }
            try {
                currentLevelMap = (Map<Object, Object>) currentLevelMap.get(keys[i]);
            }
            catch (Exception e) {
                throw new ValueAsKeyException();
            }
        }

        return currentLevelMap.get(keys[keys.length-1]);
    }

    // removes if present, returning the value, otherwise returns null
    public Object remove(Object[] keys) {
        if (h == null) return null;
        List<Map> mapRefs = new ArrayList<>();
        Map<Object,Object> currentLevelMap = h;
//        mapRefs.add(currentLevelMap);
        for (int i=0;i<keys.length-1;i++) {
            if (currentLevelMap.get(keys[i]) == null) {
                return null;
            }
            currentLevelMap = (Map<Object, Object>) currentLevelMap.get(keys[i]);
            mapRefs.add(currentLevelMap);
        }

        Object x = currentLevelMap.remove(keys[keys.length-1]);

        // backward deletion of empty ancestors
        boolean deleteFromParent = currentLevelMap.isEmpty();
        for (int i=keys.length-2;i>=0;i--) {
            if (deleteFromParent) mapRefs.get(i).remove(keys[i+1]);

            deleteFromParent = mapRefs.get(i).isEmpty(); // set current map to be deleted in next iteration from its parent (if empty)
        }

        if(deleteFromParent) h.remove(keys[0]);

        return x;
    }

    public void clear() {
        h = new HashMap<>();
    }

    public VMapAbstractIterable getChildParentIterable() {
        return new VMapChildParentIterable(this);
    }

    public VMapAbstractIterable getFullTreeIterable() {
        return new VMapFullTreeIterable(this);
    }

    public VMapAbstractIterable getSubTreeIterable(Object[] keys) {
        return new VMapSubTreeIterable(this,keys);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/XFilesUtils.java`:

```java
package it.pgp.xfiles.utils;

import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.support.annotation.Nullable;
import android.util.Log;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import it.pgp.Native;
import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.CopyMoveListPathContent;
import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.enums.FileMode;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.items.FileCreationAdvancedOptions;
import it.pgp.xfiles.items.SingleStatsItem;
import it.pgp.xfiles.roothelperclient.HashRequestCodes;
import it.pgp.xfiles.roothelperclient.RootHelperClient;
import it.pgp.xfiles.roothelperclient.resps.folderStats_resp;
import it.pgp.xfiles.service.BaseBackgroundTask;
import it.pgp.xfiles.utils.dircontent.GenericDirWithContent;
import it.pgp.xfiles.utils.dircontent.LocalDirWithContent;
import it.pgp.xfiles.utils.pathcontent.BasePathContent;
import it.pgp.xfiles.utils.pathcontent.LocalPathContent;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;

/**
 * Created by pgp on 27/09/16
 */

// Java-only equivalent to RootHelperClient (in final implementation, these classes should implement the common interface FileOperationHelper)
public class XFilesUtils implements FileOperationHelper {

    // for publishing progress from within a long term task (copy/move/compress/extract/upload/download)
    BaseBackgroundTask task;
    long totalFilesForProgress,currentFilesForProgress;

    private RootHelperClient rhc;

    private void refreshRHClient() throws IOException {
        rhc = MainActivity.getRootHelperClient();
        if(rhc == null) throw new IOException("Unable to connect to RootHelper");
    }

    @Override
    public void initProgressSupport(BaseBackgroundTask task) {
        this.task = task;
    }

    @Override
    public void destroyProgressSupport() {
        task = null;
        totalFilesForProgress = 0;
        currentFilesForProgress = 0;
    }

    public int getTotalFilesCount(File file) {
        File[] files = file.listFiles();
        int count = 0;
        for (File f : files) {
            if (f.isDirectory()) count += getTotalFilesCount(f);
            else count++;
        }
        return count;
    }

    public void copyFileOrDirectory(File srcFileOrDir, File dstFolder) throws IOException {
        if (srcFileOrDir.isDirectory()) {
            File[] files = srcFileOrDir.listFiles();
            for (File file : files) {
                File src1 = new File(srcFileOrDir, file.getName());
                File dst1 = new File(dstFolder,srcFileOrDir.getName());
                copyFileOrDirectory(src1, dst1);
            }
        } else {
            copyFile(srcFileOrDir, new File(dstFolder,srcFileOrDir.getName()));

//            try {Thread.sleep(1000);} catch (InterruptedException ignored) {}

            if(task != null) {
                currentFilesForProgress++;
                task.publishProgressWrapper(new Pair<>(currentFilesForProgress, totalFilesForProgress));
            }
        }
    }

    public static void copyFile(File sourceFile, File destFile) throws IOException {
        if (!destFile.getParentFile().exists()) destFile.getParentFile().mkdirs();
        if (!destFile.exists()) destFile.createNewFile();

        try (FileChannel source = new FileInputStream(sourceFile).getChannel();
             FileChannel destination = new FileOutputStream(destFile).getChannel()) {
            destination.transferFrom(source, 0, source.size());
        }
    }

    // to be merged in Fileopshelper interface
    public FileOpsErrorCodes copyFileOrEmptyDir(String sourceFile_, String destFile_) {
        File sourceFile = new File(sourceFile_);
        File destFile = new File(destFile_);

        if (!destFile.getParentFile().exists()) {
            if (!destFile.getParentFile().mkdirs())
                return FileOpsErrorCodes.TRANSFER_ERROR; // mkdirs error
        }

        if (!destFile.exists()) {
            if (sourceFile.isFile()) {
                try {
                    if (!destFile.createNewFile())
                        return FileOpsErrorCodes.TRANSFER_ERROR; // mkfile error
                }
                catch (IOException i) {
                    return FileOpsErrorCodes.TRANSFER_ERROR; // mkfile error
                }
            }
            else {
                if (!destFile.mkdirs())
                    return FileOpsErrorCodes.TRANSFER_ERROR; // mkdirs error
            }
        }

        try (FileChannel source = new FileInputStream(sourceFile).getChannel();
             FileChannel destination = new FileOutputStream(destFile).getChannel()) {
            destination.transferFrom(source, 0, source.size());
            return FileOpsErrorCodes.OK;
        }
        catch (IOException i) {
            return FileOpsErrorCodes.TRANSFER_ERROR; // copy error
        }
    }

    // copies regular files and empty directories, to be used with DirTreeWalker classes
    public void copyFileOrEmptyDir(File sourceFile, File destFile) throws IOException {
        if (!destFile.getParentFile().exists())
            destFile.getParentFile().mkdirs();

        if (!destFile.exists()) {
            if (sourceFile.isFile()) destFile.createNewFile();
            else {
                destFile.mkdirs();
                return;
            }
        }

        try (FileChannel source  = new FileInputStream(sourceFile).getChannel();
             FileChannel destination = new FileOutputStream(destFile).getChannel()) {
            destination.transferFrom(source, 0, source.size());
        }
    }

    public void copyFilesToDirectory(CopyMoveListPathContent files, File dstFolder) throws IOException {
        totalFilesForProgress = 0;
        for (String pathname : files)
            totalFilesForProgress += getTotalFilesCount(new File(pathname));

        for (String pathname: files)
            copyFileOrDirectory(new File(pathname),dstFolder);
    }

    public void moveFilesToDirectory(CopyMoveListPathContent files, File dstFolder) throws IOException {
        for (String pathname : files) {
            File file = new File(pathname);
            // removed Commons IO, allow only rename-based move
            File destFile = new File(dstFolder,file.getName());
            if (!file.renameTo(destFile)) throw new IOException("Cannot rename filesystem node");
        }
    }

    @Override
    public void copyMoveFilesToDirectory(CopyMoveListPathContent files, BasePathContent dstFolder) throws IOException {
        switch (files.copyOrMove) {
            case COPY:
                copyFilesToDirectory(files,new File(dstFolder.dir));
                break;
            case MOVE:
                moveFilesToDirectory(files,new File(dstFolder.dir));
                break;
        }
    }

    @Override
    public String createFileOrDirectory(BasePathContent filePath, FileMode fileOrDirectory, FileCreationAdvancedOptions... unused) throws IOException {
        File f = new File(filePath.dir);
        boolean ok;
        switch (fileOrDirectory) {
            case FILE:
                ok = f.createNewFile();
                break;
            case DIRECTORY:
                ok = f.mkdirs();
                break;
            default:
                throw new RuntimeException("Undefined file mode"); // Unreachable statement
        }
        if(!ok) throw new IOException(ALREADY_EXIST);
        return null;
    }

    @Override
    public void createLink(BasePathContent originPath, BasePathContent linkPath, boolean isHardLink) throws IOException {
        refreshRHClient();
        rhc.createLink(originPath,linkPath,isHardLink);
    }

    public static void deleteDirectory(File dir) {
        File[] files = dir.listFiles();
        if(files!=null) { //some JVMs return null for empty dirs
            for(File f: files) {
                if(f.isDirectory()) {
                    deleteDirectory(f);
                } else {
                    f.delete();
                }
            }
        }
        dir.delete();
    }

    @Override
    public void deleteFilesOrDirectories(List<BasePathContent> pathnames) throws IOException {
        for (BasePathContent pathname : pathnames) {
            File file = new File(pathname.dir);
            if (file.isDirectory()) deleteDirectory(file);
            else file.delete();
        }
    }

    @Override
    public boolean renameFile(BasePathContent oldPathname, BasePathContent newPathname) {
        File f = new File(oldPathname.dir);
        File g = new File(newPathname.dir);
        return f.renameTo(g);
    }

    @Override
    public SingleStatsItem statFile(BasePathContent pathname) throws IOException {
        // it seems that Java implementation of file stats is only in Java NIO Files (not included in Android)
        // reverting to roothelper
        refreshRHClient();
        return rhc.statFile(pathname);
    }

    @Override
    public folderStats_resp statFiles(List<BasePathContent> files) throws IOException {
        refreshRHClient();
        return rhc.statFiles(files);
    }

    @Override
    public folderStats_resp statFolder(BasePathContent pathname) throws IOException {
        // here one can use DirTreeWalker to count files and folders
        refreshRHClient();
        return rhc.statFolder(pathname);
    }

    @Override
    public boolean exists(BasePathContent pathname) {
        File f = new File(pathname.dir);
        return f.exists();
    }

    @Override
    public boolean isFile(BasePathContent pathname) {
        File f = new File(pathname.dir);
        return f.exists() && f.isFile();
    }

    @Override
    public boolean isDir(BasePathContent pathname) {
        File f = new File(pathname.dir);
        return f.exists() && f.isDirectory();
    }

    @Override
    public byte[] hashFile(BasePathContent pathname,
                           HashRequestCodes hashAlgorithm,
                           BitSet dirHashOpts) throws IOException {
        refreshRHClient();
        return rhc.hashFile(pathname,hashAlgorithm,dirHashOpts);
//        File f = new File(pathname.dir);
//        byte[] digest = null;
//        try {
//            switch (hashAlgorithm) {
//                case md5:
//                    digest = Checksums.md5(f);
//                    break;
//                case sha1:
//                    digest = Checksums.sha1(f);
//                    break;
//                default:
//                    Log.e(XFilesUtils.class.getName(), "Not implemented");
//            }
//        }
//        catch (NoSuchAlgorithmException n) {
//            n.printStackTrace();
//        }
//
//        return digest;
    }

    public static final LocalPathContent dataApp = new LocalPathContent("/data/app");
    public static final String dataAppSlash = "/data/app/";

    private static String dataAppPackageSubPath(String apkPath) {
        int firstIdx = dataAppSlash.length() - 1;
        int lastIdx = apkPath.lastIndexOf('/');
        return firstIdx != lastIdx ? apkPath.substring(firstIdx + 1, lastIdx) : apkPath.substring(firstIdx + 1);
    }

    // web source:
    // https://stackoverflow.com/questions/2695746/how-to-get-a-list-of-installed-android-applications-and-pick-one-to-run
    public static GenericDirWithContent listDataAppWithoutRoot() {
        Log.d("roothelper", "Listing /data/app via PackageManager");
        try {
            List<ApplicationInfo> packages = MainActivity.context.getPackageManager().getInstalledApplications(PackageManager.GET_META_DATA);

            List<BrowserItem> dirContent = new ArrayList<>();
            for(ApplicationInfo packageInfo : packages) {
                String apkPath = packageInfo.sourceDir;
                if(packageInfo.sourceDir.startsWith(dataAppSlash)) {
                    String fn = dataAppPackageSubPath(apkPath);
                    File f = new File(dataAppSlash, fn);
                    BrowserItem bi = new BrowserItem(fn, f.length(), new Date(f.lastModified()), f.isDirectory(), Native.isSymLink(f.getAbsolutePath())>0);
                    if(f.isDirectory() && fn.indexOf('/') >= 0) bi.isNestedDir = true;
                    dirContent.add(bi);
                }
//                Log.e("XF_APPDATA", "Installed package :" + packageInfo.packageName + "\tSource dir : " + packageInfo.sourceDir);
            }
            return new LocalDirWithContent(dataApp.dir, dirContent);
        }
        catch(Exception e) {
            e.printStackTrace();
            return new LocalDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS);
        }
    }

    @Override
    public GenericDirWithContent listDirectory(BasePathContent directory) {
        if(directory.equals(dataApp)) return listDataAppWithoutRoot();
        if(directory instanceof XREPathContent) {
            try {refreshRHClient();}
            catch(IOException e) {return new GenericDirWithContent(FileOpsErrorCodes.ROOTHELPER_INIT_ERROR);}
            return rhc.listDirectory(directory);
        }
        File[] content = new File(directory.dir).listFiles();
        if(content == null)
            return new LocalDirWithContent(FileOpsErrorCodes.COMMANDER_CANNOT_ACCESS); // TODO specialize error code (enum to be created) in callers from dir commander
        ArrayList<BrowserItem> l = new ArrayList<>();
        for(File f : content) {
            l.add(new BrowserItem(f.getName(),f.length(),new Date(f.lastModified()),f.isDirectory(), Native.isSymLink(f.getAbsolutePath())>0)); // getCanonicalPath not enough to fully determine symlink attribute (files in symlinked folders), and Files.isSymbolicLink is available only with minAPI >= 26
        }
        return new LocalDirWithContent(directory.dir, l);
    }

    @Override
    public GenericDirWithContent listArchive(BasePathContent archivePath) {
        try {refreshRHClient();}
        catch(IOException e) {return new GenericDirWithContent(FileOpsErrorCodes.ROOTHELPER_INIT_ERROR);}
        return rhc.listArchive(archivePath);
    }

    @Override
    public int compressToArchive(BasePathContent srcDirectory,
                                  BasePathContent destArchive,
                                  @Nullable Integer compressionLevel,
                                  @Nullable Boolean encryptHeaders,
                                  @Nullable Boolean solidMode,
                                  String password,
                                  List<String> filenames) throws IOException {
        RootHelperClient rh = MainActivity.getRootHelperClient();
        if(rh == null) return -1;
        return rh.compressToArchive(
                srcDirectory,
                destArchive,
                compressionLevel,
                encryptHeaders,
                solidMode,
                password,
                filenames);
    }

    @Override
    public List<FileOpsErrorCodes> extractFromArchive(List<BasePathContent> srcArchives, BasePathContent destDirectory, @Nullable String password, @Nullable Iterable<String> filenames, boolean smartDirectoryCreation) throws IOException {
        RootHelperClient rh = MainActivity.getRootHelperClient();
        if(rh == null) return Collections.singletonList(FileOpsErrorCodes.ROOTHELPER_INIT_ERROR);
        return rh.extractFromArchive(srcArchives,destDirectory,password,filenames,smartDirectoryCreation);
    }

    @Override
    public int setDates(BasePathContent file,
                        @Nullable Date accessDate,
                        @Nullable Date modificationDate) {
        if (file.providerType != ProviderType.LOCAL) return -1;
        File f = new File(file.dir);
        if (!f.exists()) return -1;
        if (modificationDate == null) return 0;
        return f.setLastModified(modificationDate.getTime())?0:-1;
    }

    @Override
    public int setPermissions(BasePathContent file, int permMask) {
        // TODO use NIO setPosixFIlePermissions or use roothelper
        return -1;
    }

    @Override
    public int setOwnership(BasePathContent file,
                            @Nullable Integer ownerId,
                            @Nullable Integer groupId) {
        // TODO use roothelper
        return 0;
    }

}

```

`app/src/main/java/it/pgp/xfiles/utils/dircontent/ArchiveSubDirWithContent.java`:

```java
package it.pgp.xfiles.utils.dircontent;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;

/**
 * Created by pgp on 13/05/17
 */

public class ArchiveSubDirWithContent extends GenericDirWithContent {

    public String archivePath; // archive absolute pathname in the local filesystem

    public ArchiveSubDirWithContent(String archivePath, String dir, List<BrowserItem> content) {
        super(dir, content);
        this.providerType = ProviderType.LOCAL_WITHIN_ARCHIVE;
        this.archivePath = archivePath;
    }

    public ArchiveSubDirWithContent(String archivePath, FileOpsErrorCodes errorCode) {
        super(errorCode);
        this.providerType = ProviderType.LOCAL_WITHIN_ARCHIVE;
        this.archivePath = archivePath;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/dircontent/GenericDirWithContent.java`:

```java
package it.pgp.xfiles.utils.dircontent;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;

/**
 * Created by pgp on 13/05/17
 *
 * represent the response to UI activities, that is, a response to be visualized through an ArrayAdapter or similar
 * the content here must represent ONE level in a filesystem hierarchy (only children of the folder,
 * NOT all the archive entries in case of archive - the VMap caching must be done at FileOpsHelper/RootHelperClient level)
 */

public class GenericDirWithContent {
    public ProviderType providerType;
    /*
    content of dir for providerType:
        - LOCAL: absolute path of the directory in the filesystem
        - LOCAL_WITHIN_ARCHIVE: absolute path of the compressed directory in the archive defined in the subclass
        - REMOTE: absolute path of the directory in the remote filesystem
     */
    public String dir;

    public List<BrowserItem> content; // each BrowserItem contains a filename
    public FileOpsErrorCodes errorCode; // null on success, errno-equivalent or descriptive commander error otherwise
    public Integer listViewPosition;

    public GenericDirWithContent(String dir, List<BrowserItem> content) {
        this.dir = dir;
        this.content = content;
        this.listViewPosition = 0;
    }


    /* TODO
     * in all subclasses errorCode constructors (or equivalently in this one first)
     * add dir as input parameter, to have complete information about error
     */
    public GenericDirWithContent(FileOpsErrorCodes errorCode) {
        this.errorCode = errorCode;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/dircontent/LocalDirWithContent.java`:

```java
package it.pgp.xfiles.utils.dircontent;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;

/**
 * Created by pgp on 13/05/17.
 *
 * LocalDirWithContent has no special attributes with respect to {@link GenericDirWithContent}
 */

public class LocalDirWithContent extends GenericDirWithContent {

    public LocalDirWithContent(String dir, List<BrowserItem> content) {
        super(dir, content);
        this.providerType = ProviderType.LOCAL;
    }

    public LocalDirWithContent(FileOpsErrorCodes errorCode) {
        super(errorCode);
        this.providerType = ProviderType.LOCAL;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/dircontent/SftpDirWithContent.java`:

```java
package it.pgp.xfiles.utils.dircontent;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.sftpclient.AuthData;

/**
 * Created by pgp on 13/05/17.
 *
 * LocalDirWithContent has no special attributes with respect to {@link GenericDirWithContent}
 */

public class SftpDirWithContent extends GenericDirWithContent {

    public AuthData authData; // user@domain:port, to display in address bar
    public String pendingLsPath;

    public SftpDirWithContent(AuthData authData, String dir, List<BrowserItem> content) {
        super(dir, content);
        this.providerType = ProviderType.SFTP;
        this.authData = authData;
    }

    public SftpDirWithContent(AuthData authData, FileOpsErrorCodes errorCode, String pendingLsPath) {
        super(errorCode);
        this.providerType = ProviderType.SFTP;
        this.authData = authData;
        this.pendingLsPath = pendingLsPath;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/dircontent/SmbDirWithContent.java`:

```java
package it.pgp.xfiles.utils.dircontent;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.smbclient.SmbAuthData;

public class SmbDirWithContent extends GenericDirWithContent {
    public SmbAuthData smbAuthData; // user@domain:host:port, to display in address bar

    public SmbDirWithContent(SmbAuthData smbAuthData, String dir, List<BrowserItem> content) {
        super(dir, content);
        this.providerType = ProviderType.SMB;
        this.smbAuthData = smbAuthData;
    }

    public SmbDirWithContent(SmbAuthData smbAuthData, FileOpsErrorCodes errorCode) {
        super(errorCode);
        this.providerType = ProviderType.SMB;
        this.smbAuthData = smbAuthData;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/dircontent/XFilesRemoteDirWithContent.java`:

```java
package it.pgp.xfiles.utils.dircontent;

import java.util.List;

import it.pgp.xfiles.BrowserItem;
import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.utils.pathcontent.XREPathContent;

/**
 * Created by pgp on 20/09/17
 */

public class XFilesRemoteDirWithContent extends GenericDirWithContent {

    public static final int defaultRHRemoteServerPort = XREPathContent.defaultRHRemoteServerPort;

    public String serverHost;
    public int serverPort;

    public XFilesRemoteDirWithContent(String serverHost, String dir, List<BrowserItem> content) {
        super(dir, content);
        this.providerType = ProviderType.XFILES_REMOTE;
        this.serverHost = serverHost;
        this.serverPort = defaultRHRemoteServerPort;
    }

    public XFilesRemoteDirWithContent(String serverHost, int serverPort, String dir, List<BrowserItem> content) {
        super(dir, content);
        this.providerType = ProviderType.XFILES_REMOTE;
        this.serverHost = serverHost;
        this.serverPort = serverPort;
    }

    public XFilesRemoteDirWithContent(String serverHost, FileOpsErrorCodes errorCode) {
        super(errorCode);
        this.providerType = ProviderType.XFILES_REMOTE;
        this.serverHost = serverHost;
        this.serverPort = defaultRHRemoteServerPort;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/iterators/VMapAbstractIterable.java`:

```java
package it.pgp.xfiles.utils.iterators;

import it.pgp.xfiles.utils.VMap;

import java.util.Map;

/**
 * Created by pgp on 12/04/17
 *
 * base class in order to allow for and foreach syntax on different it.pgp.utils.iterators for it.pgp.utils.VMap,
 * without explicitly instantiating iterator objects
 */
public abstract class VMapAbstractIterable implements Iterable<Map.Entry<?,?>> {

    VMap vMap;
    public VMapAbstractIterable(VMap vMap) {
        this.vMap = vMap;
    }

}

```

`app/src/main/java/it/pgp/xfiles/utils/iterators/VMapChildParentIterable.java`:

```java
package it.pgp.xfiles.utils.iterators;

import it.pgp.xfiles.utils.VMap;

import java.util.*;

/**
 * Created by pgp on 12/04/17
 * // Java 8 language support out-of-the-box from Studio 2.4
 */

public class VMapChildParentIterable extends VMapAbstractIterable {
    public VMapChildParentIterable(VMap vMap) {
        super(vMap);
    }

    @Override
    public Iterator<Map.Entry<?, ?>> iterator() {
        return new VMapChildParentIterator();
    }

    // only working correctly if every node name is unique in the tree
    class VMapChildParentIterator implements Iterator<Map.Entry<?,?>> {

        Stack<Map.Entry> S;
        Map parentMap; // for ancestor list retrieval of nodes traversed so far in DFS iteration

        VMapChildParentIterator() {
            parentMap = new HashMap();
            S = new Stack<>();
            for (Object x: vMap.h.keySet()) {
                S.push(new AbstractMap.SimpleEntry(x,null)); // null means root parent
                parentMap.put(x,null); // this should be useless
            }
        }

        @Override
        public boolean hasNext() {
            return !S.isEmpty();
        }

        @Override
        public Map.Entry<?,?> next() {
            Map.Entry t = S.pop();

            // look up in current parent map, and build ancestor list
            ArrayDeque vMapKeysList = new ArrayDeque();

            Object currentParent = parentMap.get(t.getValue());
            while (currentParent != null) {
                vMapKeysList.addFirst(currentParent);
                currentParent = parentMap.get(currentParent);
            }
            if (t.getValue() != null) vMapKeysList.addLast(t.getValue());
            vMapKeysList.addLast(t.getKey());

            // get (ancestor list) from this vmap, if type of value is map, add elements to stack
            Object tmp;
            try {
                tmp = vMap.get(vMapKeysList.toArray());
            } catch (VMap.ValueAsKeyException e) { // not a map, nothing to expand, simply return child-parent pair
                return t;
            }

            if (tmp != null) {
                if (tmp instanceof Map) {
                    for (Object x : ((Map) tmp).keySet()) {
                        S.push(new AbstractMap.SimpleEntry(x,t.getKey()));
                        parentMap.put(x,t.getKey());
                    }
                }
                else {
                    S.push(new AbstractMap.SimpleEntry(tmp,t.getKey()));
                    parentMap.put(tmp,t.getKey());
                }
            }

            return t;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/iterators/VMapFullTreeIterable.java`:

```java
package it.pgp.xfiles.utils.iterators;

import java.util.Iterator;
import java.util.Map;
import java.util.Stack;

import it.pgp.xfiles.utils.VMap;

/**
 * Created by pgp on 12/04/17
 */

public class VMapFullTreeIterable extends VMapAbstractIterable {
    public VMapFullTreeIterable(VMap vMap) {
        super(vMap);
    }

    @Override
    public Iterator<Map.Entry<?, ?>> iterator() {
        return new VMapFullTreeIterator();
    }

    class VMapFullTreeIterator implements Iterator<Map.Entry<?,?>> {

        Stack<Map.Entry> S;

        VMapFullTreeIterator() {
            S = new Stack<>();
            S.addAll(vMap.h.entrySet());
        }

        @Override
        public boolean hasNext() {
            return !S.isEmpty();
        }

        @Override
        public Map.Entry<?,?> next() {
            Map.Entry t = S.pop();
            if (t.getValue() instanceof Map) {
                S.addAll(((Map) t.getValue()).entrySet());
            }
            return t;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/iterators/VMapSubTreeIterable.java`:

```java
package it.pgp.xfiles.utils.iterators;

import java.util.Iterator;
import java.util.Map;
import java.util.Stack;

import it.pgp.xfiles.utils.VMap;

/**
 * Created by pgp on 12/04/17
 */

public class VMapSubTreeIterable extends VMapAbstractIterable {
    private Object[] keys;
    public VMapSubTreeIterable(VMap vMap, Object... keys) {
        super(vMap);
        this.keys = keys;
    }

    @Override
    public Iterator<Map.Entry<?, ?>> iterator() {
        return new VMapSubTreeIterator();
    }

    class VMapSubTreeIterator implements Iterator<Map.Entry<?,?>> {

        Stack<Map.Entry> S;

        VMapSubTreeIterator() {
            S = new Stack<>();
            try {
                S.addAll(((Map)vMap.get(keys)).entrySet());
            }
            catch (NullPointerException|ClassCastException ignored) {}
        }

        @Override
        public boolean hasNext() {
            return !S.isEmpty();
        }

        @Override
        public Map.Entry<?,?> next() {
            Map.Entry t = S.pop();
            if (t.getValue() instanceof Map) {
                S.addAll(((Map) t.getValue()).entrySet());
            }
            return t;
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/oreoap/MyOnStartTetheringCallback.java`:

```java
package it.pgp.xfiles.utils.oreoap;

public class MyOnStartTetheringCallback {
        public void onTetheringStarted() {}

        public void onTetheringFailed() {}
}

```

`app/src/main/java/it/pgp/xfiles/utils/oreoap/MyOreoWifiManager.java`:

```java
package it.pgp.xfiles.utils.oreoap;

import android.content.Context;
import android.net.ConnectivityManager;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;
import android.os.Handler;
import android.util.Log;

import com.android.dx.stock.ProxyBuilder;

import java.io.File;
import java.lang.reflect.Method;
import java.util.Arrays;

// Source: https://github.com/aegis1980/WifiHotSpot

// @RequiresApi(api = Build.VERSION_CODES.O)
public class MyOreoWifiManager {
    private static final String TAG = MyOreoWifiManager.class.getSimpleName();

    private Context mContext;
    private WifiManager mWifiManager;
    private ConnectivityManager mConnectivityManager;

    public MyOreoWifiManager(Context c) {
        mContext = c;
        mWifiManager = (WifiManager) mContext.getSystemService(Context.WIFI_SERVICE);
        mConnectivityManager = (ConnectivityManager) mContext.getSystemService(ConnectivityManager.class);
    }

    /**
     * This sets the Wifi SSID and password
     * Call this before {@code startTethering} if app is a system/privileged app
     * Requires: android.permission.TETHER_PRIVILEGED which is only granted to system apps
     */
    public boolean configureHotspot(String name, String password) {
        WifiConfiguration apConfig = new WifiConfiguration();
        apConfig.SSID = name;
        apConfig.preSharedKey = password;
        apConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);
        try {
            Method setConfigMethod = mWifiManager.getClass().getMethod("setWifiApConfiguration", WifiConfiguration.class);
            boolean status = (boolean) setConfigMethod.invoke(mWifiManager, apConfig);
            Log.d(TAG, "setWifiApConfiguration - success? " + status);
            return true;
        }
        catch (Exception e) {
            Log.e(TAG, "Error in configureHotspot");
            e.printStackTrace();
            return false;
        }
    }

    /**
     * Checks where tethering is on.
     * This is determined by the getTetheredIfaces() method,
     * that will return an empty array if not devices are tethered
     *
     * @return true if a tethered device is found, false if not found
     */
    public boolean isTetherActive() {
        try {
            Method method = mConnectivityManager.getClass().getDeclaredMethod("getTetheredIfaces");
            if (method == null) {
                Log.e(TAG, "getTetheredIfaces is null");
            } else {
                String[] res = (String[]) method.invoke(mConnectivityManager, null);
                Log.d(TAG, "getTetheredIfaces invoked");
                Log.d(TAG, Arrays.toString(res));
                if (res.length > 0) {
                    return true;
                }
            }
        } catch (Exception e) {
            Log.e(TAG, "Error in getTetheredIfaces");
            e.printStackTrace();
        }
        return false;
    }

    /**
     * This enables tethering using the ssid/password defined in Settings App>Hotspot & tethering
     * Does not require app to have system/privileged access
     * Credit: Vishal Sharma - https://stackoverflow.com/a/52219887
     */
    public boolean startTethering(final MyOnStartTetheringCallback callback) {

        // On Pie if we try to start tethering while it is already on, it will
        // be disabled. This is needed when startTethering() is called programmatically.
        if (isTetherActive()) {
            Log.d(TAG, "Tether already active, returning");
            return false;
        }

        File outputDir = mContext.getCodeCacheDir();
        Object proxy;
        try {
            proxy = ProxyBuilder.forClass(OnStartTetheringCallbackClass())
                    .dexCache(outputDir).handler((proxy1, method, args) -> {
                        switch (method.getName()) {
                            case "onTetheringStarted":
                                callback.onTetheringStarted();
                                break;
                            case "onTetheringFailed":
                                callback.onTetheringFailed();
                                break;
                            default:
                                ProxyBuilder.callSuper(proxy1, method, args);
                        }
                        return null;
                    }).build();
        } catch (Exception e) {
            Log.e(TAG, "Error in enableTethering ProxyBuilder");
            e.printStackTrace();
            return false;
        }

        Method method;
        try {
            method = mConnectivityManager.getClass().getDeclaredMethod("startTethering", int.class, boolean.class, OnStartTetheringCallbackClass(), Handler.class);
            if (method == null) {
                Log.e(TAG, "startTetheringMethod is null");
            } else {
                method.invoke(mConnectivityManager, ConnectivityManager.TYPE_MOBILE, false, proxy, null);
                Log.d(TAG, "startTethering invoked");
            }
            return true;
        } catch (Exception e) {
            Log.e(TAG, "Error in enableTethering");
            e.printStackTrace();
        }
        return false;
    }

    public void stopTethering() {
        try {
            Method method = mConnectivityManager.getClass().getDeclaredMethod("stopTethering", int.class);
            if (method == null) {
                Log.e(TAG, "stopTetheringMethod is null");
            } else {
                method.invoke(mConnectivityManager, ConnectivityManager.TYPE_MOBILE);
                Log.d(TAG, "stopTethering invoked");
            }
        } catch (Exception e) {
            Log.e(TAG, "stopTethering error: " + e.toString());
            e.printStackTrace();
        }
    }

    private Class OnStartTetheringCallbackClass() {
        try {
            return Class.forName("android.net.ConnectivityManager$OnStartTetheringCallback");
        } catch (ClassNotFoundException e) {
            Log.e(TAG, "OnStartTetheringCallbackClass error: " + e.toString());
            e.printStackTrace();
        }
        return null;
    }
}


```

`app/src/main/java/it/pgp/xfiles/utils/oreoap/PreOreoWifiManager.java`:

```java
package it.pgp.xfiles.utils.oreoap;

import android.content.Context;
import android.net.wifi.WifiConfiguration;
import android.net.wifi.WifiManager;

import java.lang.reflect.Method;

public class PreOreoWifiManager {
    final Context context;

    public PreOreoWifiManager(Context context) {
        this.context = context;
    }

    public boolean isApOn() {
        WifiManager wifimanager = (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        try {
            Method method = wifimanager.getClass().getDeclaredMethod("isWifiApEnabled");
            method.setAccessible(true);
            return (Boolean) method.invoke(wifimanager);
        }
        catch (Throwable ignored) {}
        return false;
    }

    // toggle wifi hotspot on or off
    public boolean configApState(boolean expectedState) {
        WifiManager wifimanager = (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        WifiConfiguration wificonfiguration = null;
        try {
            // if WiFi is on, turn it off // FIXME isApOn checks ap, not wifi
            if(isApOn()) wifimanager.setWifiEnabled(false);
            Method method = wifimanager.getClass().getMethod("setWifiApEnabled", WifiConfiguration.class, boolean.class);
//            method.invoke(wifimanager, wificonfiguration, !isApOn(context));
            method.invoke(wifimanager, wificonfiguration, expectedState);
            return true;
        }
        catch (Exception e) {
            e.printStackTrace();
        }
        return false;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/pathcontent/ArchivePathContent.java`:

```java
package it.pgp.xfiles.utils.pathcontent;

import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;

/**
 * Created by pgp on 13/05/17
 */

public class ArchivePathContent extends BasePathContent {
    public String archivePath;
    public String password; // to list/extract from password-protected archives

    private static final ProviderType provType = ProviderType.LOCAL_WITHIN_ARCHIVE;

    // archivePath: archive absolute pathname in the local filesystem
    // dir: directory path relative to the archive root
    public ArchivePathContent(String archivePath, String dir) {
        super(provType, dir);
        this.archivePath = archivePath;
    }

    public ArchivePathContent(String archivePath, String dir, String password) {
        super(provType, dir);
        this.archivePath = archivePath;
        this.password = password;
    }

    public ArchivePathContent(String archivePath, FileOpsErrorCodes errorCode) {
        super(provType, errorCode);
        this.archivePath = archivePath;
    }

    @Override
    public String toString() {
        if (dir.equals("") || dir.equals("/"))
            return archivePath;
        return archivePath+"/"+dir;
    }

    @Override
    public BasePathContent concat(String filename) {
        String s;
        if (dir == null || dir.equals("/") || dir.equals("")) s = filename;
        else s = dir+"/"+filename;
        return new ArchivePathContent(archivePath,s);
    }

    @Override
    public BasePathContent getParent() {
        // exit from archive, change subclass type
        if (dir == null || dir.equals("/") || dir.equals(""))
            return new LocalPathContent(archivePath).getParent();
        else {
            int idx = dir.lastIndexOf('/');
            if (idx < 0) return new ArchivePathContent(archivePath,"");
            return new ArchivePathContent(this.archivePath,dir.substring(0,idx));
        }
    }

    @Override
    public BasePathContent getCopy() {
        return new ArchivePathContent(archivePath,dir,password);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/pathcontent/BasePathContent.java`:

```java
package it.pgp.xfiles.utils.pathcontent;

import java.io.Serializable;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;

import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.sftpclient.AuthData;
import it.pgp.xfiles.smbclient.SmbAuthData;

import static it.pgp.Native.nHashCode;

/**
 * Created by pgp on 13/05/17
 */

public abstract class BasePathContent implements Serializable {

    public final ProviderType providerType;
    /*
    content of dir for providerType:
        - LOCAL: absolute path of the directory in the filesystem
        - LOCAL_WITHIN_ARCHIVE: absolute path of the compressed directory in the archive defined in the subclass
        - SFTP: absolute path of the directory in the remote filesystem
        - XFILES_REMOTE: absolute path of the directory in the remote filesystem
        - SMB: absolute path of the directory in the remote filesystem
     */
    public String dir;

    public FileOpsErrorCodes errorCode; // null on success, errno-equivalent or descriptive commander error otherwise

    protected BasePathContent(ProviderType providerType, String dir) {
        this.providerType = providerType;
        // not the best solution (embed subclass logic in the parent class),
        // just to avoid duplicating this check in all subclasses
        if (providerType != ProviderType.XFILES_REMOTE && (dir == null || dir.equals(""))) this.dir = "/";
        else {
            this.dir = dir;
//            if(this.dir.endsWith("/") && !this.dir.equals("/"))
//                this.dir = this.dir.substring(0,this.dir.length()-1);
        }
    }

    protected BasePathContent(ProviderType providerType, FileOpsErrorCodes errorCode) {
        this.providerType = providerType;
        this.errorCode = errorCode;
    }

    public abstract String toString();

    public abstract BasePathContent concat(String filename);

    public abstract BasePathContent getParent();

//    public static boolean isParentOrSamePathNoDuplicateSlashes(String currentDir, String targetDir) {
//        String[] p1 = currentDir.split("/");
//        if(p1.length == 0) return false;
//        String[] p2 = targetDir.split("/");
//        if(p2.length == 0) return false;
//        if(p1.length > p2.length) return false;
//        for(int i=0;i<p1.length;i++) {
//            if(!p1[i].equals(p2[i])) return false;
//        }
//        return true;
//    }

    // FIXME precondition: paths both starting with "/" -> conflicts with dir member in ArchivePathContent
    public static boolean isParentOrSamePath(String currentDir, String targetDir) {
//        if(!currentDir.startsWith("/") || !targetDir.startsWith("/"))
//            throw new RuntimeException("Paths must start with \"/\"");
        String[] p1 = currentDir.split("/");
        String[] p2 = targetDir.split("/");
        List<String> l1 = new ArrayList<>();
        List<String> l2 = new ArrayList<>();
        for(String s : p1) if(!s.isEmpty()) l1.add(s);
        for(String s : p2) if(!s.isEmpty()) l2.add(s);
        int l1s = l1.size();
        int l2s = l2.size();
        if(l1s == 0) return true; // "/" is parent of everyone, at worst it's the same with itself
        if(l1s > l2s) return false;
        for(int i=0;i<l1.size();i++) {
            if(!l1.get(i).equals(l2.get(i))) return false;
        }
        return true;
    }

    // method to avoid copy of parent path into child path (which could cause path overflow or filesystem saturation)
    public boolean isParentOrSameOf(BasePathContent content) {
        if (this.providerType == ProviderType.LOCAL && content.providerType == ProviderType.LOCAL)
            return isParentOrSamePath(this.dir, content.dir);
        if (this.providerType == ProviderType.LOCAL && content.providerType == ProviderType.LOCAL_WITHIN_ARCHIVE)
            return isParentOrSamePath(this.dir, ((ArchivePathContent)content).archivePath);
        if (this.providerType == ProviderType.LOCAL_WITHIN_ARCHIVE
                && content.providerType == ProviderType.LOCAL_WITHIN_ARCHIVE)
            return ((ArchivePathContent)content).archivePath.equals(((ArchivePathContent)this).archivePath)
            && content.dir.startsWith(this.dir);

        if (this.providerType==ProviderType.SFTP && content.providerType==ProviderType.SFTP)
            return ((SFTPPathContent)content).authData.equals(((SFTPPathContent)this).authData)
            && isParentOrSamePath(this.dir, content.dir);

        if (this.providerType==ProviderType.XFILES_REMOTE && content.providerType==ProviderType.XFILES_REMOTE)
            return ((XREPathContent)content).serverHost.equals(((XREPathContent)this).serverHost) &&
                    ((XREPathContent)content).serverPort == ((XREPathContent)this).serverPort &&
                    isParentOrSamePath(this.dir, content.dir);

        if (this.providerType==ProviderType.SMB && content.providerType==ProviderType.SMB)
            return ((SMBPathContent)content).smbAuthData.equals(((SMBPathContent)this).smbAuthData)
                    && isParentOrSamePath(this.dir, content.dir);

        return false;
    }

    public String getName() {
        if (dir.equals("/")) return dir;
        return dir.substring(dir.lastIndexOf('/')+1);
    }

    @Override
    public boolean equals(Object obj_) {
        if (!(obj_ instanceof BasePathContent)) return false;
        BasePathContent obj = (BasePathContent)obj_;
        if (this.providerType != obj.providerType) return false;
        if (this.errorCode != obj.errorCode) return false;
        switch (providerType) {
            case LOCAL_WITHIN_ARCHIVE:
                ArchivePathContent lwa = (ArchivePathContent)this;
                ArchivePathContent lwaobj = (ArchivePathContent)obj;
                if (!lwa.archivePath.equals(lwaobj.archivePath)) return false;
                break;
            case SFTP:
                SFTPPathContent sftpc = (SFTPPathContent)this;
                SFTPPathContent sftpobj = (SFTPPathContent)obj;
                if (!sftpc.authData.equals(sftpobj.authData)) return false;
                break;
            case XFILES_REMOTE:
                XREPathContent xre = (XREPathContent)this;
                XREPathContent xreobj = (XREPathContent)obj;
                if ((!xre.serverHost.equals(xreobj.serverHost)) ||
                        (xre.serverPort != xreobj.serverPort))
                    return false;
                break;
            case SMB:
                SMBPathContent smbc = (SMBPathContent) this;
                SMBPathContent smbobj = (SMBPathContent) obj;
                if (!smbc.smbAuthData.equals(smbobj.smbAuthData)) return false;
                break;
        }
        return dir.equals(obj.dir);
    }

    // does not keep error code field into account (assumes invalid path contents are not stored to be unique)
    @Override
    public int hashCode() {
        ByteBuffer bb;
        byte[] d = dir.getBytes(); // common field
        switch(providerType) {
            case LOCAL:
                return nHashCode(d);
            case LOCAL_WITHIN_ARCHIVE:
                byte[] ap = ((ArchivePathContent)this).archivePath.getBytes();
                bb = ByteBuffer.allocate(d.length+ap.length);
                bb.put(d);
                bb.put(ap);
                return nHashCode(bb.array());
            case SFTP:
                AuthData ad = ((SFTPPathContent)this).authData;
                // it is fine to have same hash code for null fields and empty string fields
                byte[] u = (ad.username==null)?new byte[0]:ad.username.getBytes();
                byte[] dm = (ad.domain==null)?new byte[0]:ad.domain.getBytes();
                // ignore password, store on db without it (stored in sftpCredentials) so ignore in hashcode
                // since for connection, sftpCredentials table is queried anyway
                bb = ByteBuffer.allocate(u.length+dm.length+4+d.length);
                bb.put(u);bb.put(dm);bb.putInt(ad.port);bb.put(d);
                return nHashCode(bb.array());
            case XFILES_REMOTE:
                XREPathContent xpc = (XREPathContent)this;
                byte[] h = (xpc.serverHost==null)?new byte[0]:xpc.serverHost.getBytes();
                bb = ByteBuffer.allocate(h.length+4+d.length);
                bb.put(h);bb.putInt(xpc.serverPort);bb.put(d);
                return nHashCode(bb.array());
            case SMB:
                SmbAuthData smb_ad = ((SMBPathContent)this).smbAuthData;
                // it is fine to have same hash code for null fields and empty string fields
                u = (smb_ad.username==null)?new byte[0]:smb_ad.username.getBytes();
                dm = (smb_ad.domain==null)?new byte[0]:smb_ad.domain.getBytes();
                h = (smb_ad.host==null)?new byte[0]:smb_ad.host.getBytes();
                // ignore password, store on db without it (stored in smbCredentials) so ignore in hashcode
                // since for connection, smbCredentials table is queried anyway
                bb = ByteBuffer.allocate(u.length+dm.length+h.length+4+d.length);
                bb.put(u);bb.put(dm);bb.put(h);bb.putInt(smb_ad.port);bb.put(d);
                return nHashCode(bb.array());
            default:
                throw new RuntimeException("Unexpected path content type");
        }
    }

    public abstract BasePathContent getCopy();

}

```

`app/src/main/java/it/pgp/xfiles/utils/pathcontent/LocalPathContent.java`:

```java
package it.pgp.xfiles.utils.pathcontent;

import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;

/**
 * Created by pgp on 13/05/17
 */

public class LocalPathContent extends BasePathContent {

    private static final ProviderType provType = ProviderType.LOCAL;

    public LocalPathContent(String dir) {
        super(provType, dir);
    }

    public LocalPathContent(FileOpsErrorCodes errorCode) {
        super(provType, errorCode);
    }

    @Override
    public String toString() {
        return dir;
    }

    @Override
    public BasePathContent concat(String filename) {
        String sep = dir.equals("/")?"":"/";
        return new LocalPathContent(dir+sep+filename);
    }

    @Override
    public BasePathContent getParent() {
        if (dir.equals("/")) return null;
        int idx = dir.lastIndexOf('/');
        return new LocalPathContent(dir.substring(0,idx));
    }

    @Override
    public BasePathContent getCopy() {
        return new LocalPathContent(dir);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/pathcontent/SFTPPathContent.java`:

```java
package it.pgp.xfiles.utils.pathcontent;

import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.sftpclient.AuthData;

/**
 * Created by pgp on 13/05/17
 */

public class SFTPPathContent extends BasePathContent {

    private static final ProviderType provType = ProviderType.SFTP;

    public AuthData authData; // user@domain:port, to display in address bar

    public SFTPPathContent(AuthData authData, String dir) {
        super(provType, dir);
        this.authData = authData;
    }

    public SFTPPathContent(AuthData authData, FileOpsErrorCodes errorCode) {
        super(provType, errorCode);
        this.authData = authData;
    }

    @Override
    public String toString() {
        return "sftp://"+authData+dir;
    }

    @Override
    public BasePathContent concat(String filename) {
        String sep = dir.equals("/")?"":"/";
        return new SFTPPathContent(authData,dir+sep+filename);
    }

    @Override
    public BasePathContent getParent() {
        if (dir == null || dir.equals("/") || dir.equals("")) return null;
        int idx = dir.lastIndexOf('/');
        return new SFTPPathContent(authData, dir.substring(0,idx));
    }

    @Override
    public BasePathContent getCopy() {
        return new SFTPPathContent(authData,dir);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/pathcontent/SMBPathContent.java`:

```java
package it.pgp.xfiles.utils.pathcontent;

import java.net.MalformedURLException;

import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;
import it.pgp.xfiles.smbclient.SmbAuthData;
import jcifs.CIFSContext;
import jcifs.smb.SmbFile;

public class SMBPathContent extends BasePathContent {

    private static final ProviderType provType = ProviderType.SMB;

    public SmbAuthData smbAuthData; // user@domain:host:port, to display in address bar

    public SMBPathContent(SmbAuthData smbAuthData, String dir) {
        super(provType, dir);
        this.smbAuthData = smbAuthData;
    }

    public SMBPathContent(SmbAuthData smbAuthData, FileOpsErrorCodes errorCode) {
        super(provType, errorCode);
        this.smbAuthData = smbAuthData;
    }

    @Override
    public String toString() { // non-canonical, contains domain(e.g. WORKGROUP)
        return "smb://"+smbAuthData+dir;
    }

    public String toConnStringFull() { // canonical, can be fed as input into JCFIS SMbClient constructor
        return "smb://"+smbAuthData.username+"@"+
                smbAuthData.host+":"+smbAuthData.port+ // TODO check if access by custom port is canonical
                dir+"/";
    }

    public String toConnString(boolean isDirectory) { // TODO check if port in address is canonical
        return "smb://"+smbAuthData.host+":"+smbAuthData.port+dir+(isDirectory?"/":"");
    }

    public SmbFile getSmbFile(CIFSContext context, boolean isDirectory) throws MalformedURLException {
        return new SmbFile(toConnString(isDirectory),context);
    }

    @Override
    public BasePathContent concat(String filename) {
        String sep = dir.equals("/")?"":"/";
        return new SMBPathContent(smbAuthData,dir+sep+filename);
    }

    @Override
    public BasePathContent getParent() {
        if (dir == null || dir.equals("/") || dir.equals("")) return null;
        int idx = dir.lastIndexOf('/');
        return new SMBPathContent(smbAuthData, dir.substring(0,idx));
    }

    @Override
    public BasePathContent getCopy() {
        return new SMBPathContent(smbAuthData,dir);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/pathcontent/XREPathContent.java`:

```java
package it.pgp.xfiles.utils.pathcontent;

import it.pgp.xfiles.enums.FileOpsErrorCodes;
import it.pgp.xfiles.enums.ProviderType;

/**
 * Created by pgp on 20/09/17
 */

public class XREPathContent extends BasePathContent {

    private static final ProviderType provType = ProviderType.XFILES_REMOTE;

    public static final int defaultRHRemoteServerPort = 11111;

    public String serverHost;
    int serverPort;

    public XREPathContent(String serverHost, String dir) {
        super(provType, dir);
        this.serverHost = serverHost;
        this.serverPort = defaultRHRemoteServerPort;
    }

    public XREPathContent(String serverHost, FileOpsErrorCodes errorCode) {
        super(provType, errorCode);
        this.serverHost = serverHost;
        this.serverPort = defaultRHRemoteServerPort;
    }

    @Override
    public String toString() {
        return "xre://"+serverHost+":"+serverPort+dir;
    }

    @Override
    public BasePathContent concat(String filename) {
        String sep = dir.equals("/")?"":"/";
        return new XREPathContent(serverHost,dir+sep+filename);
    }

    @Override
    public BasePathContent getParent() {
        if (dir==null || dir.equals("/") || dir.equals("")) return null;
        int idx = dir.lastIndexOf('/');
        if(idx==0) return new XREPathContent(serverHost,"/");
        return new XREPathContent(serverHost,dir.substring(0,idx));
    }

    @Override
    public BasePathContent getCopy() {
        return new XREPathContent(serverHost,dir);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/popupwindow/MovablePopupWindowWithAutoClose.java`:

```java
package it.pgp.xfiles.utils.popupwindow;

import android.content.Context;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.View;
import android.widget.PopupWindow;

import it.pgp.xfiles.MainActivity;

public class MovablePopupWindowWithAutoClose extends PopupWindow {

    private final GestureDetector gestureDetector;
    public final Runnable dismissRef = this::dismiss;
    int orgX, orgY;
    int offsetX, offsetY;

    private void makeMovable(View view) {
        view.setOnTouchListener((v,event) -> {
            if (gestureDetector.onTouchEvent(event)) {
                MainActivity.handler.removeCallbacks(dismissRef);
                return true;
            }
            else {
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN:
                        orgX = (int) event.getX();
                        orgY = (int) event.getY();
                        break;
                    case MotionEvent.ACTION_MOVE:
                        offsetX = (int)event.getRawX() - orgX;
                        offsetY = (int)event.getRawY() - orgY;
                        update(offsetX, offsetY, -1, -1, true);
                        break;
                }
            }
            return true;
        });
    }

    public MovablePopupWindowWithAutoClose(View contentView, int width, int height, Context context) {
        super(contentView, width, height);
        gestureDetector = new GestureDetector(context, PopupWindowUtils.singleTapConfirm);
        makeMovable(contentView);
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/popupwindow/PopupWindowUtils.java`:

```java
package it.pgp.xfiles.utils.popupwindow;

import android.app.Activity;
import android.content.Context;
import android.support.annotation.NonNull;
import android.util.DisplayMetrics;
import android.view.GestureDetector;
import android.view.Gravity;
import android.view.LayoutInflater;
import android.view.MotionEvent;
import android.view.View;
import android.view.ViewGroup;
import android.view.WindowManager;
import android.view.inputmethod.InputMethodManager;
import android.widget.Button;
import android.widget.CheckedTextView;
import android.widget.LinearLayout;
import android.widget.TextView;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.service.visualization.ViewOverlay;
import it.pgp.xfiles.utils.HashView;
import it.pgp.xfiles.utils.Misc;

public class PopupWindowUtils {

    public static final int AUTOCLOSE_DELAY_MS = 5000;

    public static final GestureDetector.SimpleOnGestureListener singleTapConfirm = new GestureDetector.SimpleOnGestureListener(){
        @Override
        public boolean onSingleTapUp(MotionEvent e) {
            return true;
        }
    };

    public static void createAndShowHashViewCommon(@NonNull Context context,
                                                               byte[] dataForVisualHash,
                                                               boolean autocloseAfterTimeout,
                                                               View anchor) {
        WindowManager wm = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        DisplayMetrics displayMetrics = new DisplayMetrics();
        // using 50% of screen width
        wm.getDefaultDisplay().getMetrics(displayMetrics);
        // 0: reduced, 1: full (lazy init)
        HashView[] hvs = {new HashView(
                context,
                dataForVisualHash,
                16,3,
                displayMetrics.widthPixels/2,
                displayMetrics.widthPixels/2,
                9), null};

        LayoutInflater layoutInflater = (LayoutInflater)((context instanceof Activity)?((Activity)context).getBaseContext():context).getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        View popupView = layoutInflater.inflate(R.layout.hashview_popup_window, null);

        LinearLayout container = popupView.findViewById(R.id.hvLayout);
        container.addView(hvs[0]);

        TextView htv = popupView.findViewById(R.id.hvTextView);
        TextView tv = popupView.findViewById(R.id.hashview_timeout_alert_textview);
        CheckedTextView hvShowFull = popupView.findViewById(R.id.hvShowFull);

        hvShowFull.setOnClickListener(v -> {
            hvShowFull.toggle();
            int newIndex = hvShowFull.isChecked()?1:0;
            if(newIndex == 1 && hvs[1] == null)
                hvs[1] = new HashView(
                        context,
                        dataForVisualHash,
                        16,3,
                        displayMetrics.widthPixels/2,
                        displayMetrics.widthPixels/2);

            HashView currentHv = hvs[1 - newIndex];
            HashView newHv = hvs[newIndex];

            ViewGroup parent = (ViewGroup) currentHv.getParent();
            int targetIndex = parent.indexOfChild(currentHv);
            container.removeView(currentHv);
            container.addView(newHv,targetIndex);
        });

        Button btnDismiss = popupView.findViewById(R.id.hashview_close_button);

        if(context instanceof Activity) {
            MovablePopupWindowWithAutoClose popupWindow = new MovablePopupWindowWithAutoClose(
                    popupView, ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, context);
            btnDismiss.setOnClickListener(view -> popupWindow.dismiss());

            if (autocloseAfterTimeout) {
                htv.setVisibility(View.GONE);
                MainActivity.handler.postDelayed(popupWindow.dismissRef, AUTOCLOSE_DELAY_MS);
            }
            else {
                tv.setVisibility(View.GONE);
                htv.setText(Misc.toHexString(dataForVisualHash));
            }

            popupWindow.showAtLocation(
                    anchor,
                    Gravity.NO_GRAVITY,
                    displayMetrics.widthPixels/4,
                    displayMetrics.widthPixels/4);
        }
        else {
            ViewOverlay vo = new ViewOverlay(context, popupView);
            btnDismiss.setOnClickListener(view -> vo.destroy());

            if (autocloseAfterTimeout) {
                htv.setVisibility(View.GONE);
                MainActivity.handler.postDelayed(vo.destroyRef, AUTOCLOSE_DELAY_MS);
            }
            else {
                tv.setVisibility(View.GONE);
                htv.setText(Misc.toHexString(dataForVisualHash));
            }
        }
    }

    public static void toggleSoftKeyBoard(View v, boolean showOrHide) {
        InputMethodManager imm = (InputMethodManager)v.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        if(showOrHide) { // show
            imm.toggleSoftInput(InputMethodManager.SHOW_FORCED, 0);
        }
        else { // hide
            imm.hideSoftInputFromWindow(v.getWindowToken(), 0);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/wifi/OreoWifiAPManager.java`:

```java
package it.pgp.xfiles.utils.wifi;

import android.content.Context;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.os.Handler;
import android.support.annotation.RequiresApi;
import android.util.Log;
import android.widget.Toast;

import it.pgp.xfiles.R;

/**
 * Web source:
 * https://stackoverflow.com/questions/45984345/how-to-turn-on-off-wifi-hotspot-programmatically-in-android-8-0-oreo
 * Unused because unpractical, requires APP_COARSE_LOCATION runtime permission (not requested by XFiles), and, moreover, requires that GPS is turned on in order to work
 */

@RequiresApi(api = Build.VERSION_CODES.O)
public class OreoWifiAPManager extends WifiApManager {

    private static final String LOGTAG = "OREOWIFIAP";

    private static WifiManager.LocalOnlyHotspotReservation mReservation;
    private final WifiButtonsLayout wifiButtonsLayout;

    OreoWifiAPManager(Context context, WifiButtonsLayout wifiButtonsLayout) {
        super(context);
        this.wifiButtonsLayout = wifiButtonsLayout;
    }

    @RequiresApi(api = Build.VERSION_CODES.O)
    private void turnOnHotspot() {
        try {
            mWifiManager.startLocalOnlyHotspot(new WifiManager.LocalOnlyHotspotCallback() {

                @Override
                public void onStarted(WifiManager.LocalOnlyHotspotReservation reservation) {
                    super.onStarted(reservation);
                    Log.d(LOGTAG, "Wifi Local Hotspot is ON");
                    mReservation = reservation;
                    wifiButtonsLayout.apBtn.setImageResource(R.drawable.xfiles_hotspot_on);
                }

                @Override
                public void onStopped() { // stopped externally from settings UI
                    super.onStopped();
                    Log.d(LOGTAG, "Wifi Local Hotspot is OFF");
                    wifiButtonsLayout.apBtn.setImageResource(R.drawable.xfiles_hotspot_off);
                    turnOffHotspot();
                    mReservation = null;
                }

                @Override
                public void onFailed(int reason) {
                    super.onFailed(reason);
                    Log.d(LOGTAG, "onFailed: ");
                    wifiButtonsLayout.apBtn.setEnabled(false);
                }
            }, new Handler());

        }
        catch (SecurityException e) { // TODO launch intent for asking runtime permission for coarse location
            Toast.makeText(context, "Location permission not enabled, check app settings", Toast.LENGTH_SHORT).show();
        }
    }

    public void turnOffHotspot() {
        if (mReservation != null) {
            mReservation.close();
            mReservation = null;
        }
    }

    @Override
    public boolean isApOn() {
        return mReservation != null && super.isApOn();
    }

    @Override
    boolean configApState(boolean expectedState) {
        if (expectedState) {
            if (mReservation == null)
                turnOnHotspot();
        }
        else turnOffHotspot();
        return true;
    }
}

```

`app/src/main/java/it/pgp/xfiles/utils/wifi/WifiApManager.java`:

```java
package it.pgp.xfiles.utils.wifi;

import android.content.Context;
import android.net.wifi.WifiInfo;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.provider.Settings;
import android.util.Log;

import java.lang.reflect.Method;

import it.pgp.xfiles.R;
import it.pgp.xfiles.utils.oreoap.MyOnStartTetheringCallback;
import it.pgp.xfiles.utils.oreoap.MyOreoWifiManager;
import it.pgp.xfiles.utils.oreoap.PreOreoWifiManager;

class WifiApManager {

    public enum WIFI_STATE {
        NO_ADAPTER_FOUND(R.drawable.xfiles_wifi_unavailable),
        ADAPTER_OFF(R.drawable.xfiles_wifi_off),
        ADAPTER_ON(R.drawable.xfiles_wifi_enabled_not_connected),
        CONNECTED(R.drawable.xfiles_wifi_on);

        int resId;

        WIFI_STATE(int resId) {
            this.resId = resId;
        }
    }

    private enum AP_STATE {
        WIFI_AP_STATE_DISABLING,
        WIFI_AP_STATE_DISABLED,
        WIFI_AP_STATE_ENABLING,
        WIFI_AP_STATE_ENABLED,
        WIFI_AP_STATE_FAILED
    }

    protected final WifiManager mWifiManager;
    protected final Context context;

    WifiApManager(Context context) {
        this.context = context;
        mWifiManager = (WifiManager)context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
    }

    private AP_STATE getWifiApState() {
        try {
            Method method = mWifiManager.getClass().getMethod("getWifiApState");
            int tmp = ((Integer)method.invoke(mWifiManager));

            // Fix for Android 4
            if(tmp > 10) tmp -= 10;

            return AP_STATE.values()[tmp];
        }
        catch(Exception e) {
            Log.e(getClass().toString(), "", e);
            return AP_STATE.WIFI_AP_STATE_FAILED;
        }
    }

    boolean isWifiApEnabled() {
        return getWifiApState() == AP_STATE.WIFI_AP_STATE_ENABLED;
    }

    //check whether wifi hotspot on or off
    boolean isApOn() {
        WifiManager wifimanager = (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        try {
            Method method = wifimanager.getClass().getDeclaredMethod("isWifiApEnabled");
            method.setAccessible(true);
            return (Boolean)method.invoke(wifimanager);
        }
        catch(Throwable ignored) {}
        return false;
    }

    // toggle wifi hotspot
    boolean configApState(boolean targetState) {
        if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.M && !Settings.System.canWrite(context))
            return false;
        else {
            if(Build.VERSION.SDK_INT < Build.VERSION_CODES.O) {
                PreOreoWifiManager apManager = new PreOreoWifiManager(context);
                // boolean targetState = !apManager.isApOn();
                return apManager.configApState(targetState);
            }
            else {
                MyOreoWifiManager apManager = new MyOreoWifiManager(context);
                if(apManager.isTetherActive()) apManager.stopTethering();
                else apManager.startTethering(new MyOnStartTetheringCallback());
            }
            return true;
        }
    }

    /**
     * Web source:
     * https://stackoverflow.com/questions/3841317/how-do-i-see-if-wi-fi-is-connected-on-android
     */
    WIFI_STATE checkWifiOnAndConnected() {
        WifiManager wifimanager = (WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE);
        if(wifimanager == null) return WIFI_STATE.NO_ADAPTER_FOUND;
        if(wifimanager.isWifiEnabled()) { // Wi-Fi adapter is ON
            WifiInfo wifiInfo = wifimanager.getConnectionInfo();
            if(wifiInfo.getNetworkId() == -1) return WIFI_STATE.ADAPTER_ON; // Not connected to an access point
            else return WIFI_STATE.CONNECTED; // Connected to an access point
        }
        else return WIFI_STATE.ADAPTER_OFF; // Wi-Fi adapter is OFF
    }
}
```

`app/src/main/java/it/pgp/xfiles/utils/wifi/WifiButtonsLayout.java`:

```java
package it.pgp.xfiles.utils.wifi;

import android.app.Activity;
import android.app.Dialog;
import android.content.BroadcastReceiver;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.WifiManager;
import android.os.Build;
import android.util.Log;
import android.view.View;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.Toast;

import it.pgp.xfiles.MainActivity;
import it.pgp.xfiles.PermissionManagementActivity;
import it.pgp.xfiles.R;
import it.pgp.xfiles.dialogs.compress.AskPasswordDialogOnListing;
import it.pgp.xfiles.roothelperclient.RootHandler;
import it.pgp.xfiles.utils.oreoap.MyOreoWifiManager;

public class WifiButtonsLayout extends LinearLayout {

    private final Activity activity;

    private final ImageButton wifiBtn;
    public final ImageButton apBtn;
    public final ImageButton hotspotPswBtn;

    private final BroadcastReceiver wifiReceiver;
    private final WifiApManager ap;
    private final WifiManager wifiManager;
    private final IntentFilter filter;

    private volatile boolean latestApState;

    private LinearLayout.LayoutParams getLayoutParams(int weight) {
        return new LinearLayout.LayoutParams(
                0,
                LayoutParams.MATCH_PARENT,
                weight
        );
    }

    void toggleButtons(boolean on) {
        wifiBtn.setEnabled(on);
        apBtn.setEnabled(on);
    }

    public WifiButtonsLayout(Activity context) {
        super(context);
        activity = context;

        filter = new IntentFilter();
        filter.addAction(ConnectionChangeReceiver.CONN_ACTION);
        filter.addAction(ConnectionChangeReceiver.WIFI_ACTION);
        wifiReceiver = new ConnectionChangeReceiver();
        ap = new WifiApManager(context);
        wifiManager = (WifiManager)activity.getApplicationContext().getSystemService(Context.WIFI_SERVICE);

        setOrientation(HORIZONTAL);
        wifiBtn = new ImageButton(context);
        apBtn = new ImageButton(context);
        hotspotPswBtn = (Build.VERSION.SDK_INT < Build.VERSION_CODES.O) ? new ImageButton(context) : null;
        wifiBtn.setImageResource(R.drawable.xfiles_wifi_off);
        apBtn.setImageResource(R.drawable.xfiles_hotspot_off);
        wifiBtn.setLayoutParams(getLayoutParams(3));
        apBtn.setLayoutParams(getLayoutParams((hotspotPswBtn != null) ? 2 : 3));
        wifiBtn.setOnLongClickListener(this::showWifiNetworkPicker);
        wifiBtn.setOnClickListener(this::switchWifi);
        apBtn.setOnClickListener(this::switchAp);
        apBtn.setOnLongClickListener(this::showHotspotOptions);
        if(hotspotPswBtn != null) {
            hotspotPswBtn.setImageResource(android.R.drawable.ic_lock_lock);
            hotspotPswBtn.setLayoutParams(getLayoutParams(1));
            hotspotPswBtn.setOnClickListener(v -> {
                Dialog dialog = new Dialog(context);
                dialog.setContentView(R.layout.ask_password_dialog);
                dialog.setTitle("Set hotspot password");
                EditText password = dialog.findViewById(R.id.passwordEditText);
                dialog.findViewById(R.id.askPasswordOkButton).setOnClickListener(w -> {
                    MyOreoWifiManager apManager = new MyOreoWifiManager(context);
                    MainActivity.showToast(
                            apManager.configureHotspot("Android Hotspot",
                                    password.getText().toString()) ?
                                    "Password set successfully" : "Unable to set password"
                    );
                    dialog.dismiss();
                });
                dialog.findViewById(R.id.passwordVisibleCtv).setOnClickListener(
                        AskPasswordDialogOnListing.getPasswordCtvListener(password));
                dialog.show();
            });
            addView(hotspotPswBtn);
        }
        addView(apBtn);
        addView(wifiBtn);
        receiveAp();
    }

    public void registerListeners() {
        activity.registerReceiver(wifiReceiver,filter);
    }

    public void unregisterListeners() {
        activity.unregisterReceiver(wifiReceiver);
    }

    private boolean showWifiNetworkPicker(View unused) {
        activity.startActivity(new Intent(WifiManager.ACTION_PICK_WIFI_NETWORK));
        return true;
    }

    private boolean showHotspotOptions(View unused) {
        Intent options = new Intent(Intent.ACTION_MAIN, null);
        options.addCategory(Intent.CATEGORY_LAUNCHER);
        options.setComponent(new ComponentName("com.android.settings", "com.android.settings.TetherSettings"));
        activity.startActivity(options);
        return true;
    }

    private boolean switchWifiUsingRoot(boolean stateToSet) {
        MainActivity.getRootHelperClient();
        if(RootHandler.isRootAvailableAndGranted) {
            String cmd = "svc wifi "+(stateToSet?"enable":"disable");
            try {
                Process p = RootHandler.executeCommandSimple(cmd,null, true, false);
                p.waitFor();
                MainActivity.showToast("WiFi state switched using root");
                return true;
            }
            catch(Exception e) {
                e.printStackTrace();
                MainActivity.showToast("Unable to switch WiFi state using root");
            }
        }
        else {
            if(Build.VERSION.SDK_INT < Build.VERSION_CODES.Q)
                MainActivity.showToast("Unable to switch WiFi state, is airplane mode active?");
        }
        return false;
    }

    private void switchWifi(View unused) {
        toggleButtons(false);
        boolean stateToSet = !wifiManager.isWifiEnabled();
        boolean success;
        if(Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {
            success = wifiManager.setWifiEnabled(stateToSet);
            if(!success) {
                // if unprivileged API-based WiFi switching doesn't work (e.g. due to airplane mode being active),
                // try using root if available
                success = switchWifiUsingRoot(stateToSet);
            }
        }
        else {
            // setWifiEnabled is not supported when targeting API >= 29 and running on API >= 29:
            // try directly with root if available, else open settings activity
            success = switchWifiUsingRoot(stateToSet);
        }
        if(!success) {
            toggleButtons(true);
            showWifiNetworkPicker(null);
        }
    }

    private static final int RECHECK_AP_CHANGED_TIMEOUT_SEC = 10;

//    private void startWifiAPSystemActivity() {
//        Intent intent = new Intent(Intent.ACTION_MAIN, null);
//        intent.addCategory(Intent.CATEGORY_LAUNCHER);
//        intent.setComponent(new ComponentName("com.android.settings", "com.android.settings.TetherSettings"));
//        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
//        activity.startActivity(intent);
//    }

    private void switchAp(View unused) {
        boolean expectedStateAfterSwitch = !ap.isApOn();
        toggleButtons(false);
        if(!ap.configApState(expectedStateAfterSwitch)) {
            MainActivity.showToast(
                    "Could not change WiFi AP status directly from app," +
                            "ensure you have granted system settings permissions");
            activity.startActivity(PermissionManagementActivity.getSystemSettingsIntent(activity));
            toggleButtons(true);
            return;
        }
        // for some reason, ap state change is not detected by broadcast receiver, force query state after a while
        new CountDownAPCheck(activity,RECHECK_AP_CHANGED_TIMEOUT_SEC,expectedStateAfterSwitch).run();
    }

    private void receiveWifi() {
        activity.runOnUiThread(()->wifiBtn.setImageResource(ap.checkWifiOnAndConnected().resId));
    }

    private void receiveAp() {
        latestApState = ap.isWifiApEnabled();
        activity.runOnUiThread(()->apBtn.setImageResource(
                latestApState?R.drawable.xfiles_hotspot_on:R.drawable.xfiles_hotspot_off));
    }

    public class ConnectionChangeReceiver extends BroadcastReceiver {
        public static final String CONN_ACTION = "android.net.conn.CONNECTIVITY_CHANGE";
        public static final String WIFI_ACTION = "android.net.wifi.WIFI_STATE_CHANGED";

        @Override
        public void onReceive(Context context, Intent intent) {
            Log.d("BROADCAST","onReceive "+intent.getAction());
            receiveWifi();
            receiveAp();
            activity.runOnUiThread(()->toggleButtons(true));
        }
    }

    /**
     * Runnable that forces a wifi ap state update every second without thread sleep
     */
    public class CountDownAPCheck implements Runnable {

        final Context context;
        final int count;
        final boolean expectedState;

        private CountDownAPCheck(Context context, int count, boolean expectedState) {
            this.context = context;
            this.count = count;
            this.expectedState = expectedState;
        }

        @Override
        public void run() {
            receiveAp();

            String errMsg = null;
            if (count <= 0) { // this should crash if initialCount is 0 (first runnable is not submitted on UI thread)
                errMsg = "Timeout AP check";
            }
            else if (latestApState == expectedState) {
                errMsg = "expected AP change detected, periodic AP check ended";
            }

            if(errMsg!=null) {
                Toast.makeText(context, errMsg, Toast.LENGTH_SHORT).show();
                toggleButtons(true);
                return;
            }

            MainActivity.handler.postDelayed(new CountDownAPCheck(context,count-1,expectedState),1000);
        }
    }
}

```

`app/src/main/java/it/pgp/xfiles/viewmodels/PasteableEditText.java`:

```java
package it.pgp.xfiles.viewmodels;

import android.content.ClipData;
import android.content.ClipboardManager;
import android.content.Context;
import android.support.annotation.Nullable;
import android.text.Editable;
import android.util.AttributeSet;
import android.view.LayoutInflater;
import android.widget.EditText;
import android.widget.ImageButton;
import android.widget.LinearLayout;
import android.widget.Toast;

import it.pgp.xfiles.R;

public class PasteableEditText extends LinearLayout {
    EditText editText;
    ImageButton pasteButton;
    ClipboardManager clipboard;

    private void init(Context context) {
        clipboard = (ClipboardManager)getContext().getSystemService(Context.CLIPBOARD_SERVICE);
        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
        inflater.inflate(R.layout.pasteable_edittext, this);
    }

    public PasteableEditText(Context context) {
        super(context);
        init(context);
    }

    public PasteableEditText(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context);
    }

    // click: paste with append
    // long click: paste with overwrite
    boolean doPaste(boolean isLongClick) {
        ClipData clipData = clipboard.getPrimaryClip();
        if(clipData == null) Toast.makeText(getContext(), "Clipboard is empty", Toast.LENGTH_SHORT).show();
        else {
            ClipData.Item item = clipData.getItemAt(0);
            String s = item.getText().toString();
            if(!isLongClick) s = editText.getText().toString() + s;
            editText.setText(s);
        }
        return true;
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        editText = findViewById(R.id.pasteable_edittext_et);
        pasteButton = findViewById(R.id.pasteable_edittext_ib);
        pasteButton.setOnClickListener(v -> doPaste(false));
        pasteButton.setOnLongClickListener(v -> doPaste(true));
    }

    public Editable getText() {
        return editText.getText();
    }

    public void setText(CharSequence text) {
        editText.setText(text);
    }
}

```

`app/src/main/java/it/pgp/xfiles/viewmodels/TouchImageView.java`:

```java
package it.pgp.xfiles.viewmodels;

import android.annotation.TargetApi;
import android.content.Context;
import android.content.res.Configuration;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Matrix;
import android.graphics.PointF;
import android.graphics.RectF;
import android.graphics.drawable.Drawable;
import android.net.Uri;
import android.os.Build;
import android.os.Bundle;
import android.os.Parcelable;
import android.util.AttributeSet;
import android.util.Log;
import android.view.GestureDetector;
import android.view.MotionEvent;
import android.view.ScaleGestureDetector;
import android.view.View;
import android.view.animation.AccelerateDecelerateInterpolator;
import android.widget.ImageView;
import android.widget.OverScroller;
import android.widget.Scroller;


public class TouchImageView extends ImageView {

    private static final String DEBUG = "DEBUG";

    //
    // SuperMin and SuperMax multipliers. Determine how much the image can be
    // zoomed below or above the zoom boundaries, before animating back to the
    // min/max zoom boundary.
    //
    private static final float SUPER_MIN_MULTIPLIER = .75f;
    private static final float SUPER_MAX_MULTIPLIER = 1.25f;

    //
    // Scale of image ranges from minScale to maxScale, where minScale == 1
    // when the image is stretched to fit view.
    //
    private float normalizedScale;

    //
    // Matrix applied to image. MSCALE_X and MSCALE_Y should always be equal.
    // MTRANS_X and MTRANS_Y are the other values used. prevMatrix is the matrix
    // saved prior to the screen rotating.
    //
    private Matrix matrix, prevMatrix;

    private enum State { NONE, DRAG, ZOOM, FLING, ANIMATE_ZOOM }
    private State state;

    private float minScale;
    private float maxScale;
    private float superMinScale;
    private float superMaxScale;
    private float[] m;

    private Context context;
    private Fling fling;

    private ScaleType mScaleType;

    private boolean imageRenderedAtLeastOnce;
    private boolean onDrawReady;

    private ZoomVariables delayedZoomVariables;

    //
    // Size of view and previous view size (ie before rotation)
    //
    private int viewWidth, viewHeight, prevViewWidth, prevViewHeight;

    //
    // Size of image when it is stretched to fit view. Before and After rotation.
    //
    private float matchViewWidth, matchViewHeight, prevMatchViewWidth, prevMatchViewHeight;

    private ScaleGestureDetector mScaleDetector;
    private GestureDetector mGestureDetector;
    private GestureDetector.OnDoubleTapListener doubleTapListener = null;
    private OnTouchListener userTouchListener = null;
    private OnTouchImageViewListener touchImageViewListener = null;

    public TouchImageView(Context context) {
        super(context);
        sharedConstructing(context);
    }

    public TouchImageView(Context context, AttributeSet attrs) {
        super(context, attrs);
        sharedConstructing(context);
    }

    public TouchImageView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
        sharedConstructing(context);
    }

    private void sharedConstructing(Context context) {
        super.setClickable(true);
        this.context = context;
        mScaleDetector = new ScaleGestureDetector(context, new ScaleListener());
        mGestureDetector = new GestureDetector(context, new GestureListener());
        matrix = new Matrix();
        prevMatrix = new Matrix();
        m = new float[9];
        normalizedScale = 1;
        if (mScaleType == null) {
            mScaleType = ScaleType.FIT_CENTER;
        }
        minScale = 1;
        maxScale = 3;
        superMinScale = SUPER_MIN_MULTIPLIER * minScale;
        superMaxScale = SUPER_MAX_MULTIPLIER * maxScale;
        setImageMatrix(matrix);
        setScaleType(ScaleType.MATRIX);
        setState(State.NONE);
        onDrawReady = false;
        super.setOnTouchListener(new PrivateOnTouchListener());
    }

    @Override
    public void setOnTouchListener(OnTouchListener l) {
        userTouchListener = l;
    }

    public void setOnTouchImageViewListener(OnTouchImageViewListener l) {
        touchImageViewListener = l;
    }

    public void setOnDoubleTapListener(GestureDetector.OnDoubleTapListener l) {
        doubleTapListener = l;
    }

    @Override
    public void setImageResource(int resId) {
        super.setImageResource(resId);
        savePreviousImageValues();
        fitImageToView();
    }

    @Override
    public void setImageBitmap(Bitmap bm) {
        super.setImageBitmap(bm);
        savePreviousImageValues();
        fitImageToView();
    }

    @Override
    public void setImageDrawable(Drawable drawable) {
        super.setImageDrawable(drawable);
        savePreviousImageValues();
        fitImageToView();
    }

    @Override
    public void setImageURI(Uri uri) {
        super.setImageURI(uri);
        savePreviousImageValues();
        fitImageToView();
    }

    @Override
    public void setScaleType(ScaleType type) {
        if (type == ScaleType.FIT_START || type == ScaleType.FIT_END) {
            throw new UnsupportedOperationException("TouchImageView does not support FIT_START or FIT_END");
        }
        if (type == ScaleType.MATRIX) {
            super.setScaleType(ScaleType.MATRIX);

        } else {
            mScaleType = type;
            if (onDrawReady) {
                //
                // If the image is already rendered, scaleType has been called programmatically
                // and the TouchImageView should be updated with the new scaleType.
                //
                setZoom(this);
            }
        }
    }

    @Override
    public ScaleType getScaleType() {
        return mScaleType;
    }

    /**
     * Returns false if image is in initial, unzoomed state. False, otherwise.
     * @return true if image is zoomed
     */
    public boolean isZoomed() {
        return normalizedScale != 1;
    }

    /**
     * Return a Rect representing the zoomed image.
     * @return rect representing zoomed image
     */
    public RectF getZoomedRect() {
        if (mScaleType == ScaleType.FIT_XY) {
            throw new UnsupportedOperationException("getZoomedRect() not supported with FIT_XY");
        }
        PointF topLeft = transformCoordTouchToBitmap(0, 0, true);
        PointF bottomRight = transformCoordTouchToBitmap(viewWidth, viewHeight, true);

        float w = getDrawable().getIntrinsicWidth();
        float h = getDrawable().getIntrinsicHeight();
        return new RectF(topLeft.x / w, topLeft.y / h, bottomRight.x / w, bottomRight.y / h);
    }

    /**
     * Save the current matrix and view dimensions
     * in the prevMatrix and prevView variables.
     */
    private void savePreviousImageValues() {
        if (matrix != null && viewHeight != 0 && viewWidth != 0) {
            matrix.getValues(m);
            prevMatrix.setValues(m);
            prevMatchViewHeight = matchViewHeight;
            prevMatchViewWidth = matchViewWidth;
            prevViewHeight = viewHeight;
            prevViewWidth = viewWidth;
        }
    }

    @Override
    public Parcelable onSaveInstanceState() {
        Bundle bundle = new Bundle();
        bundle.putParcelable("instanceState", super.onSaveInstanceState());
        bundle.putFloat("saveScale", normalizedScale);
        bundle.putFloat("matchViewHeight", matchViewHeight);
        bundle.putFloat("matchViewWidth", matchViewWidth);
        bundle.putInt("viewWidth", viewWidth);
        bundle.putInt("viewHeight", viewHeight);
        matrix.getValues(m);
        bundle.putFloatArray("matrix", m);
        bundle.putBoolean("imageRendered", imageRenderedAtLeastOnce);
        return bundle;
    }

    @Override
    public void onRestoreInstanceState(Parcelable state) {
        if (state instanceof Bundle) {
            Bundle bundle = (Bundle) state;
            normalizedScale = bundle.getFloat("saveScale");
            m = bundle.getFloatArray("matrix");
            prevMatrix.setValues(m);
            prevMatchViewHeight = bundle.getFloat("matchViewHeight");
            prevMatchViewWidth = bundle.getFloat("matchViewWidth");
            prevViewHeight = bundle.getInt("viewHeight");
            prevViewWidth = bundle.getInt("viewWidth");
            imageRenderedAtLeastOnce = bundle.getBoolean("imageRendered");
            super.onRestoreInstanceState(bundle.getParcelable("instanceState"));
            return;
        }

        super.onRestoreInstanceState(state);
    }

    @Override
    protected void onDraw(Canvas canvas) {
        onDrawReady = true;
        imageRenderedAtLeastOnce = true;
        if (delayedZoomVariables != null) {
            setZoom(delayedZoomVariables.scale, delayedZoomVariables.focusX, delayedZoomVariables.focusY, delayedZoomVariables.scaleType);
            delayedZoomVariables = null;
        }
        super.onDraw(canvas);
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        savePreviousImageValues();
    }

    /**
     * Get the max zoom multiplier.
     * @return max zoom multiplier.
     */
    public float getMaxZoom() {
        return maxScale;
    }

    /**
     * Set the max zoom multiplier. Default value: 3.
     * @param max max zoom multiplier.
     */
    public void setMaxZoom(float max) {
        maxScale = max;
        superMaxScale = SUPER_MAX_MULTIPLIER * maxScale;
    }

    /**
     * Get the min zoom multiplier.
     * @return min zoom multiplier.
     */
    public float getMinZoom() {
        return minScale;
    }

    /**
     * Get the current zoom. This is the zoom relative to the initial
     * scale, not the original resource.
     * @return current zoom multiplier.
     */
    public float getCurrentZoom() {
        return normalizedScale;
    }

    /**
     * Set the min zoom multiplier. Default value: 1.
     * @param min min zoom multiplier.
     */
    public void setMinZoom(float min) {
        minScale = min;
        superMinScale = SUPER_MIN_MULTIPLIER * minScale;
    }

    /**
     * Reset zoom and translation to initial state.
     */
    public void resetZoom() {
        normalizedScale = 1;
        fitImageToView();
    }

    /**
     * Set zoom to the specified scale. Image will be centered by default.
     * @param scale
     */
    public void setZoom(float scale) {
        setZoom(scale, 0.5f, 0.5f);
    }

    /**
     * Set zoom to the specified scale. Image will be centered around the point
     * (focusX, focusY). These floats range from 0 to 1 and denote the focus point
     * as a fraction from the left and top of the view. For example, the top left
     * corner of the image would be (0, 0). And the bottom right corner would be (1, 1).
     * @param scale
     * @param focusX
     * @param focusY
     */
    public void setZoom(float scale, float focusX, float focusY) {
        setZoom(scale, focusX, focusY, mScaleType);
    }

    /**
     * Set zoom to the specified scale. Image will be centered around the point
     * (focusX, focusY). These floats range from 0 to 1 and denote the focus point
     * as a fraction from the left and top of the view. For example, the top left
     * corner of the image would be (0, 0). And the bottom right corner would be (1, 1).
     * @param scale
     * @param focusX
     * @param focusY
     * @param scaleType
     */
    public void setZoom(float scale, float focusX, float focusY, ScaleType scaleType) {
        //
        // setZoom can be called before the image is on the screen, but at this point,
        // image and view sizes have not yet been calculated in onMeasure. Thus, we should
        // delay calling setZoom until the view has been measured.
        //
        if (!onDrawReady) {
            delayedZoomVariables = new ZoomVariables(scale, focusX, focusY, scaleType);
            return;
        }

        if (scaleType != mScaleType) {
            setScaleType(scaleType);
        }
        resetZoom();
        scaleImage(scale, viewWidth / 2, viewHeight / 2, true);
        matrix.getValues(m);
        m[Matrix.MTRANS_X] = -((focusX * getImageWidth()) - (viewWidth * 0.5f));
        m[Matrix.MTRANS_Y] = -((focusY * getImageHeight()) - (viewHeight * 0.5f));
        matrix.setValues(m);
        fixTrans();
        setImageMatrix(matrix);
    }

    /**
     * Set zoom parameters equal to another TouchImageView. Including scale, position,
     * and ScaleType.
     * @param img
     */
    public void setZoom(TouchImageView img) {
        PointF center = img.getScrollPosition();
        setZoom(img.getCurrentZoom(), center.x, center.y, img.getScaleType());
    }

    /**
     * Return the point at the center of the zoomed image. The PointF coordinates range
     * in value between 0 and 1 and the focus point is denoted as a fraction from the left
     * and top of the view. For example, the top left corner of the image would be (0, 0).
     * And the bottom right corner would be (1, 1).
     * @return PointF representing the scroll position of the zoomed image.
     */
    public PointF getScrollPosition() {
        Drawable drawable = getDrawable();
        if (drawable == null) {
            return null;
        }
        int drawableWidth = drawable.getIntrinsicWidth();
        int drawableHeight = drawable.getIntrinsicHeight();

        PointF point = transformCoordTouchToBitmap(viewWidth / 2, viewHeight / 2, true);
        point.x /= drawableWidth;
        point.y /= drawableHeight;
        return point;
    }

    /**
     * Set the focus point of the zoomed image. The focus points are denoted as a fraction from the
     * left and top of the view. The focus points can range in value between 0 and 1.
     * @param focusX
     * @param focusY
     */
    public void setScrollPosition(float focusX, float focusY) {
        setZoom(normalizedScale, focusX, focusY);
    }

    /**
     * Performs boundary checking and fixes the image matrix if it
     * is out of bounds.
     */
    private void fixTrans() {
        matrix.getValues(m);
        float transX = m[Matrix.MTRANS_X];
        float transY = m[Matrix.MTRANS_Y];

        float fixTransX = getFixTrans(transX, viewWidth, getImageWidth());
        float fixTransY = getFixTrans(transY, viewHeight, getImageHeight());

        if (fixTransX != 0 || fixTransY != 0) {
            matrix.postTranslate(fixTransX, fixTransY);
        }
    }

    /**
     * When transitioning from zooming from focus to zoom from center (or vice versa)
     * the image can become unaligned within the view. This is apparent when zooming
     * quickly. When the content size is less than the view size, the content will often
     * be centered incorrectly within the view. fixScaleTrans first calls fixTrans() and
     * then makes sure the image is centered correctly within the view.
     */
    private void fixScaleTrans() {
        fixTrans();
        matrix.getValues(m);
        if (getImageWidth() < viewWidth) {
            m[Matrix.MTRANS_X] = (viewWidth - getImageWidth()) / 2;
        }

        if (getImageHeight() < viewHeight) {
            m[Matrix.MTRANS_Y] = (viewHeight - getImageHeight()) / 2;
        }
        matrix.setValues(m);
    }

    private float getFixTrans(float trans, float viewSize, float contentSize) {
        float minTrans, maxTrans;

        if (contentSize <= viewSize) {
            minTrans = 0;
            maxTrans = viewSize - contentSize;

        } else {
            minTrans = viewSize - contentSize;
            maxTrans = 0;
        }

        if (trans < minTrans)
            return -trans + minTrans;
        if (trans > maxTrans)
            return -trans + maxTrans;
        return 0;
    }

    private float getFixDragTrans(float delta, float viewSize, float contentSize) {
        if (contentSize <= viewSize) {
            return 0;
        }
        return delta;
    }

    private float getImageWidth() {
        return matchViewWidth * normalizedScale;
    }

    private float getImageHeight() {
        return matchViewHeight * normalizedScale;
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        Drawable drawable = getDrawable();
        if (drawable == null || drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) {
            setMeasuredDimension(0, 0);
            return;
        }

        int drawableWidth = drawable.getIntrinsicWidth();
        int drawableHeight = drawable.getIntrinsicHeight();
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        viewWidth = setViewSize(widthMode, widthSize, drawableWidth);
        viewHeight = setViewSize(heightMode, heightSize, drawableHeight);

        //
        // Set view dimensions
        //
        setMeasuredDimension(viewWidth, viewHeight);

        //
        // Fit content within view
        //
        fitImageToView();
    }

    /**
     * If the normalizedScale is equal to 1, then the image is made to fit the screen. Otherwise,
     * it is made to fit the screen according to the dimensions of the previous image matrix. This
     * allows the image to maintain its zoom after rotation.
     */
    private void fitImageToView() {
        Drawable drawable = getDrawable();
        if (drawable == null || drawable.getIntrinsicWidth() == 0 || drawable.getIntrinsicHeight() == 0) {
            return;
        }
        if (matrix == null || prevMatrix == null) {
            return;
        }

        int drawableWidth = drawable.getIntrinsicWidth();
        int drawableHeight = drawable.getIntrinsicHeight();

        //
        // Scale image for view
        //
        float scaleX = (float) viewWidth / drawableWidth;
        float scaleY = (float) viewHeight / drawableHeight;

        switch (mScaleType) {
            case CENTER:
                scaleX = scaleY = 1;
                break;

            case CENTER_CROP:
                scaleX = scaleY = Math.max(scaleX, scaleY);
                break;

            case CENTER_INSIDE:
                scaleX = scaleY = Math.min(1, Math.min(scaleX, scaleY));

            case FIT_CENTER:
                scaleX = scaleY = Math.min(scaleX, scaleY);
                break;

            case FIT_XY:
                break;

            default:
                //
                // FIT_START and FIT_END not supported
                //
                throw new UnsupportedOperationException("TouchImageView does not support FIT_START or FIT_END");

        }

        //
        // Center the image
        //
        float redundantXSpace = viewWidth - (scaleX * drawableWidth);
        float redundantYSpace = viewHeight - (scaleY * drawableHeight);
        matchViewWidth = viewWidth - redundantXSpace;
        matchViewHeight = viewHeight - redundantYSpace;
        if (!isZoomed() && !imageRenderedAtLeastOnce) {
            //
            // Stretch and center image to fit view
            //
            matrix.setScale(scaleX, scaleY);
            matrix.postTranslate(redundantXSpace / 2, redundantYSpace / 2);
            normalizedScale = 1;

        } else {
            //
            // These values should never be 0 or we will set viewWidth and viewHeight
            // to NaN in translateMatrixAfterRotate. To avoid this, call savePreviousImageValues
            // to set them equal to the current values.
            //
            if (prevMatchViewWidth == 0 || prevMatchViewHeight == 0) {
                savePreviousImageValues();
            }

            prevMatrix.getValues(m);

            //
            // Rescale Matrix after rotation
            //
            m[Matrix.MSCALE_X] = matchViewWidth / drawableWidth * normalizedScale;
            m[Matrix.MSCALE_Y] = matchViewHeight / drawableHeight * normalizedScale;

            //
            // TransX and TransY from previous matrix
            //
            float transX = m[Matrix.MTRANS_X];
            float transY = m[Matrix.MTRANS_Y];

            //
            // Width
            //
            float prevActualWidth = prevMatchViewWidth * normalizedScale;
            float actualWidth = getImageWidth();
            translateMatrixAfterRotate(Matrix.MTRANS_X, transX, prevActualWidth, actualWidth, prevViewWidth, viewWidth, drawableWidth);

            //
            // Height
            //
            float prevActualHeight = prevMatchViewHeight * normalizedScale;
            float actualHeight = getImageHeight();
            translateMatrixAfterRotate(Matrix.MTRANS_Y, transY, prevActualHeight, actualHeight, prevViewHeight, viewHeight, drawableHeight);

            //
            // Set the matrix to the adjusted scale and translate values.
            //
            matrix.setValues(m);
        }
        fixTrans();
        setImageMatrix(matrix);
    }

    /**
     * Set view dimensions based on layout params
     *
     * @param mode
     * @param size
     * @param drawableWidth
     * @return
     */
    private int setViewSize(int mode, int size, int drawableWidth) {
        int viewSize;
        switch (mode) {
            case MeasureSpec.EXACTLY:
                viewSize = size;
                break;

            case MeasureSpec.AT_MOST:
                viewSize = Math.min(drawableWidth, size);
                break;

            case MeasureSpec.UNSPECIFIED:
                viewSize = drawableWidth;
                break;

            default:
                viewSize = size;
                break;
        }
        return viewSize;
    }

    /**
     * After rotating, the matrix needs to be translated. This function finds the area of image
     * which was previously centered and adjusts translations so that is again the center, post-rotation.
     *
     * @param axis Matrix.MTRANS_X or Matrix.MTRANS_Y
     * @param trans the value of trans in that axis before the rotation
     * @param prevImageSize the width/height of the image before the rotation
     * @param imageSize width/height of the image after rotation
     * @param prevViewSize width/height of view before rotation
     * @param viewSize width/height of view after rotation
     * @param drawableSize width/height of drawable
     */
    private void translateMatrixAfterRotate(int axis, float trans, float prevImageSize, float imageSize, int prevViewSize, int viewSize, int drawableSize) {
        if (imageSize < viewSize) {
            //
            // The width/height of image is less than the view's width/height. Center it.
            //
            m[axis] = (viewSize - (drawableSize * m[Matrix.MSCALE_X])) * 0.5f;

        } else if (trans > 0) {
            //
            // The image is larger than the view, but was not before rotation. Center it.
            //
            m[axis] = -((imageSize - viewSize) * 0.5f);

        } else {
            //
            // Find the area of the image which was previously centered in the view. Determine its distance
            // from the left/top side of the view as a fraction of the entire image's width/height. Use that percentage
            // to calculate the trans in the new view width/height.
            //
            float percentage = (Math.abs(trans) + (0.5f * prevViewSize)) / prevImageSize;
            m[axis] = -((percentage * imageSize) - (viewSize * 0.5f));
        }
    }

    private void setState(State state) {
        this.state = state;
    }

    public boolean canScrollHorizontallyFroyo(int direction) {
        return canScrollHorizontally(direction);
    }

    @Override
    public boolean canScrollHorizontally(int direction) {
        matrix.getValues(m);
        float x = m[Matrix.MTRANS_X];

        if (getImageWidth() < viewWidth) {
            return false;

        } else if (x >= -1 && direction < 0) {
            return false;

        } else if (Math.abs(x) + viewWidth + 1 >= getImageWidth() && direction > 0) {
            return false;
        }

        return true;
    }

    /**
     * Gesture Listener detects a single click or long click and passes that on
     * to the view's listener.
     * @author Ortiz
     *
     */
    private class GestureListener extends GestureDetector.SimpleOnGestureListener {

        @Override
        public boolean onSingleTapConfirmed(MotionEvent e)
        {
            if(doubleTapListener != null) {
                return doubleTapListener.onSingleTapConfirmed(e);
            }
            return performClick();
        }

        @Override
        public void onLongPress(MotionEvent e)
        {
            performLongClick();
        }

        @Override
        public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)
        {
            if (fling != null) {
                //
                // If a previous fling is still active, it should be cancelled so that two flings
                // are not run simultaenously.
                //
                fling.cancelFling();
            }
            fling = new Fling((int) velocityX, (int) velocityY);
            compatPostOnAnimation(fling);
            return super.onFling(e1, e2, velocityX, velocityY);
        }

        @Override
        public boolean onDoubleTap(MotionEvent e) {
            boolean consumed = false;
            if(doubleTapListener != null) {
                consumed = doubleTapListener.onDoubleTap(e);
            }
            if (state == State.NONE) {
                float targetZoom = (normalizedScale == minScale) ? maxScale : minScale;
                DoubleTapZoom doubleTap = new DoubleTapZoom(targetZoom, e.getX(), e.getY(), false);
                compatPostOnAnimation(doubleTap);
                consumed = true;
            }
            return consumed;
        }

        @Override
        public boolean onDoubleTapEvent(MotionEvent e) {
            if(doubleTapListener != null) {
                return doubleTapListener.onDoubleTapEvent(e);
            }
            return false;
        }
    }

    public interface OnTouchImageViewListener {
        void onMove();
    }

    /**
     * Responsible for all touch events. Handles the heavy lifting of drag and also sends
     * touch events to Scale Detector and Gesture Detector.
     * @author Ortiz
     *
     */
    private class PrivateOnTouchListener implements OnTouchListener {

        //
        // Remember last point position for dragging
        //
        private PointF last = new PointF();

        @Override
        public boolean onTouch(View v, MotionEvent event) {
            mScaleDetector.onTouchEvent(event);
            mGestureDetector.onTouchEvent(event);
            PointF curr = new PointF(event.getX(), event.getY());

            if (state == State.NONE || state == State.DRAG || state == State.FLING) {
                switch (event.getAction()) {
                    case MotionEvent.ACTION_DOWN:
                        last.set(curr);
                        if (fling != null)
                            fling.cancelFling();
                        setState(State.DRAG);
                        break;

                    case MotionEvent.ACTION_MOVE:
                        if (state == State.DRAG) {
                            float deltaX = curr.x - last.x;
                            float deltaY = curr.y - last.y;
                            float fixTransX = getFixDragTrans(deltaX, viewWidth, getImageWidth());
                            float fixTransY = getFixDragTrans(deltaY, viewHeight, getImageHeight());
                            matrix.postTranslate(fixTransX, fixTransY);
                            fixTrans();
                            last.set(curr.x, curr.y);
                        }
                        break;

                    case MotionEvent.ACTION_UP:
                    case MotionEvent.ACTION_POINTER_UP:
                        setState(State.NONE);
                        break;
                }
            }

            setImageMatrix(matrix);

            //
            // User-defined OnTouchListener
            //
            if(userTouchListener != null) {
                userTouchListener.onTouch(v, event);
            }

            //
            // OnTouchImageViewListener is set: TouchImageView dragged by user.
            //
            if (touchImageViewListener != null) {
                touchImageViewListener.onMove();
            }

            //
            // indicate event was handled
            //
            return true;
        }
    }

    /**
     * ScaleListener detects user two finger scaling and scales image.
     * @author Ortiz
     *
     */
    private class ScaleListener extends ScaleGestureDetector.SimpleOnScaleGestureListener {
        @Override
        public boolean onScaleBegin(ScaleGestureDetector detector) {
            setState(State.ZOOM);
            return true;
        }

        @Override
        public boolean onScale(ScaleGestureDetector detector) {
            scaleImage(detector.getScaleFactor(), detector.getFocusX(), detector.getFocusY(), true);

            //
            // OnTouchImageViewListener is set: TouchImageView pinch zoomed by user.
            //
            if (touchImageViewListener != null) {
                touchImageViewListener.onMove();
            }
            return true;
        }

        @Override
        public void onScaleEnd(ScaleGestureDetector detector) {
            super.onScaleEnd(detector);
            setState(State.NONE);
            boolean animateToZoomBoundary = false;
            float targetZoom = normalizedScale;
            if (normalizedScale > maxScale) {
                targetZoom = maxScale;
                animateToZoomBoundary = true;

            } else if (normalizedScale < minScale) {
                targetZoom = minScale;
                animateToZoomBoundary = true;
            }

            if (animateToZoomBoundary) {
                DoubleTapZoom doubleTap = new DoubleTapZoom(targetZoom, viewWidth / 2, viewHeight / 2, true);
                compatPostOnAnimation(doubleTap);
            }
        }
    }

    private void scaleImage(double deltaScale, float focusX, float focusY, boolean stretchImageToSuper) {

        float lowerScale, upperScale;
        if (stretchImageToSuper) {
            lowerScale = superMinScale;
            upperScale = superMaxScale;

        } else {
            lowerScale = minScale;
            upperScale = maxScale;
        }

        float origScale = normalizedScale;
        normalizedScale *= deltaScale;
        if (normalizedScale > upperScale) {
            normalizedScale = upperScale;
            deltaScale = upperScale / origScale;
        } else if (normalizedScale < lowerScale) {
            normalizedScale = lowerScale;
            deltaScale = lowerScale / origScale;
        }

        matrix.postScale((float) deltaScale, (float) deltaScale, focusX, focusY);
        fixScaleTrans();
    }

    /**
     * DoubleTapZoom calls a series of runnables which apply
     * an animated zoom in/out graphic to the image.
     * @author Ortiz
     *
     */
    private class DoubleTapZoom implements Runnable {

        private long startTime;
        private static final float ZOOM_TIME = 500;
        private float startZoom, targetZoom;
        private float bitmapX, bitmapY;
        private boolean stretchImageToSuper;
        private AccelerateDecelerateInterpolator interpolator = new AccelerateDecelerateInterpolator();
        private PointF startTouch;
        private PointF endTouch;

        DoubleTapZoom(float targetZoom, float focusX, float focusY, boolean stretchImageToSuper) {
            setState(State.ANIMATE_ZOOM);
            startTime = System.currentTimeMillis();
            this.startZoom = normalizedScale;
            this.targetZoom = targetZoom;
            this.stretchImageToSuper = stretchImageToSuper;
            PointF bitmapPoint = transformCoordTouchToBitmap(focusX, focusY, false);
            this.bitmapX = bitmapPoint.x;
            this.bitmapY = bitmapPoint.y;

            //
            // Used for translating image during scaling
            //
            startTouch = transformCoordBitmapToTouch(bitmapX, bitmapY);
            endTouch = new PointF(viewWidth / 2, viewHeight / 2);
        }

        @Override
        public void run() {
            float t = interpolate();
            double deltaScale = calculateDeltaScale(t);
            scaleImage(deltaScale, bitmapX, bitmapY, stretchImageToSuper);
            translateImageToCenterTouchPosition(t);
            fixScaleTrans();
            setImageMatrix(matrix);

            //
            // OnTouchImageViewListener is set: double tap runnable updates listener
            // with every frame.
            //
            if (touchImageViewListener != null) {
                touchImageViewListener.onMove();
            }

            if (t < 1f) {
                //
                // We haven't finished zooming
                //
                compatPostOnAnimation(this);

            } else {
                //
                // Finished zooming
                //
                setState(State.NONE);
            }
        }

        /**
         * Interpolate between where the image should start and end in order to translate
         * the image so that the point that is touched is what ends up centered at the end
         * of the zoom.
         * @param t
         */
        private void translateImageToCenterTouchPosition(float t) {
            float targetX = startTouch.x + t * (endTouch.x - startTouch.x);
            float targetY = startTouch.y + t * (endTouch.y - startTouch.y);
            PointF curr = transformCoordBitmapToTouch(bitmapX, bitmapY);
            matrix.postTranslate(targetX - curr.x, targetY - curr.y);
        }

        /**
         * Use interpolator to get t
         * @return
         */
        private float interpolate() {
            long currTime = System.currentTimeMillis();
            float elapsed = (currTime - startTime) / ZOOM_TIME;
            elapsed = Math.min(1f, elapsed);
            return interpolator.getInterpolation(elapsed);
        }

        /**
         * Interpolate the current targeted zoom and get the delta
         * from the current zoom.
         * @param t
         * @return
         */
        private double calculateDeltaScale(float t) {
            double zoom = startZoom + t * (targetZoom - startZoom);
            return zoom / normalizedScale;
        }
    }

    /**
     * This function will transform the coordinates in the touch event to the coordinate
     * system of the drawable that the imageview contain
     * @param x x-coordinate of touch event
     * @param y y-coordinate of touch event
     * @param clipToBitmap Touch event may occur within view, but outside image content. True, to clip return value
     * 			to the bounds of the bitmap size.
     * @return Coordinates of the point touched, in the coordinate system of the original drawable.
     */
    private PointF transformCoordTouchToBitmap(float x, float y, boolean clipToBitmap) {
        matrix.getValues(m);
        float origW = getDrawable().getIntrinsicWidth();
        float origH = getDrawable().getIntrinsicHeight();
        float transX = m[Matrix.MTRANS_X];
        float transY = m[Matrix.MTRANS_Y];
        float finalX = ((x - transX) * origW) / getImageWidth();
        float finalY = ((y - transY) * origH) / getImageHeight();

        if (clipToBitmap) {
            finalX = Math.min(Math.max(finalX, 0), origW);
            finalY = Math.min(Math.max(finalY, 0), origH);
        }

        return new PointF(finalX , finalY);
    }

    /**
     * Inverse of transformCoordTouchToBitmap. This function will transform the coordinates in the
     * drawable's coordinate system to the view's coordinate system.
     * @param bx x-coordinate in original bitmap coordinate system
     * @param by y-coordinate in original bitmap coordinate system
     * @return Coordinates of the point in the view's coordinate system.
     */
    private PointF transformCoordBitmapToTouch(float bx, float by) {
        matrix.getValues(m);
        float origW = getDrawable().getIntrinsicWidth();
        float origH = getDrawable().getIntrinsicHeight();
        float px = bx / origW;
        float py = by / origH;
        float finalX = m[Matrix.MTRANS_X] + getImageWidth() * px;
        float finalY = m[Matrix.MTRANS_Y] + getImageHeight() * py;
        return new PointF(finalX , finalY);
    }

    /**
     * Fling launches sequential runnables which apply
     * the fling graphic to the image. The values for the translation
     * are interpolated by the Scroller.
     * @author Ortiz
     *
     */
    private class Fling implements Runnable {

        CompatScroller scroller;
        int currX, currY;

        Fling(int velocityX, int velocityY) {
            setState(State.FLING);
            scroller = new CompatScroller(context);
            matrix.getValues(m);

            int startX = (int) m[Matrix.MTRANS_X];
            int startY = (int) m[Matrix.MTRANS_Y];
            int minX, maxX, minY, maxY;

            if (getImageWidth() > viewWidth) {
                minX = viewWidth - (int) getImageWidth();
                maxX = 0;

            } else {
                minX = maxX = startX;
            }

            if (getImageHeight() > viewHeight) {
                minY = viewHeight - (int) getImageHeight();
                maxY = 0;

            } else {
                minY = maxY = startY;
            }

            scroller.fling(startX, startY, (int) velocityX, (int) velocityY, minX,
                    maxX, minY, maxY);
            currX = startX;
            currY = startY;
        }

        public void cancelFling() {
            if (scroller != null) {
                setState(State.NONE);
                scroller.forceFinished(true);
            }
        }

        @Override
        public void run() {

            //
            // OnTouchImageViewListener is set: TouchImageView listener has been flung by user.
            // Listener runnable updated with each frame of fling animation.
            //
            if (touchImageViewListener != null) {
                touchImageViewListener.onMove();
            }

            if (scroller.isFinished()) {
                scroller = null;
                return;
            }

            if (scroller.computeScrollOffset()) {
                int newX = scroller.getCurrX();
                int newY = scroller.getCurrY();
                int transX = newX - currX;
                int transY = newY - currY;
                currX = newX;
                currY = newY;
                matrix.postTranslate(transX, transY);
                fixTrans();
                setImageMatrix(matrix);
                compatPostOnAnimation(this);
            }
        }
    }

    @TargetApi(Build.VERSION_CODES.GINGERBREAD)
    private static class CompatScroller {
        Scroller scroller;
        OverScroller overScroller;
        boolean isPreGingerbread;

        public CompatScroller(Context context) {
            if (Build.VERSION.SDK_INT < Build.VERSION_CODES.GINGERBREAD) {
                isPreGingerbread = true;
                scroller = new Scroller(context);

            } else {
                isPreGingerbread = false;
                overScroller = new OverScroller(context);
            }
        }

        public void fling(int startX, int startY, int velocityX, int velocityY, int minX, int maxX, int minY, int maxY) {
            if (isPreGingerbread) {
                scroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY);
            } else {
                overScroller.fling(startX, startY, velocityX, velocityY, minX, maxX, minY, maxY);
            }
        }

        public void forceFinished(boolean finished) {
            if (isPreGingerbread) {
                scroller.forceFinished(finished);
            } else {
                overScroller.forceFinished(finished);
            }
        }

        public boolean isFinished() {
            if (isPreGingerbread) {
                return scroller.isFinished();
            } else {
                return overScroller.isFinished();
            }
        }

        public boolean computeScrollOffset() {
            if (isPreGingerbread) {
                return scroller.computeScrollOffset();
            } else {
                overScroller.computeScrollOffset();
                return overScroller.computeScrollOffset();
            }
        }

        public int getCurrX() {
            if (isPreGingerbread) {
                return scroller.getCurrX();
            } else {
                return overScroller.getCurrX();
            }
        }

        public int getCurrY() {
            if (isPreGingerbread) {
                return scroller.getCurrY();
            } else {
                return overScroller.getCurrY();
            }
        }
    }

    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
    private void compatPostOnAnimation(Runnable runnable) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN) {
            postOnAnimation(runnable);

        } else {
            postDelayed(runnable, 1000/60);
        }
    }

    private static class ZoomVariables {
        public float scale;
        public float focusX;
        public float focusY;
        public ScaleType scaleType;

        public ZoomVariables(float scale, float focusX, float focusY, ScaleType scaleType) {
            this.scale = scale;
            this.focusX = focusX;
            this.focusY = focusY;
            this.scaleType = scaleType;
        }
    }

    private void printMatrixInfo() {
        float[] n = new float[9];
        matrix.getValues(n);
        Log.d(DEBUG, "Scale: " + n[Matrix.MSCALE_X] + " TransX: " + n[Matrix.MTRANS_X] + " TransY: " + n[Matrix.MTRANS_Y]);
    }
}

```

`app/src/main/java/it/pgp/xfiles/viewmodels/XREDirectoryViewModel.java`:

```java
package it.pgp.xfiles.viewmodels;

import android.app.Activity;
import android.app.Dialog;
import android.content.Context;
import android.os.Build;
import android.text.InputType;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.EditText;
import android.widget.ListView;
import android.widget.Spinner;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;

import it.pgp.xfiles.R;
import it.pgp.xfiles.adapters.XreAnnouncesAdapter;
import it.pgp.xfiles.utils.GenericDBHelper;
import it.pgp.xfiles.utils.Pair;

public class XREDirectoryViewModel {
    // xfiles remote dir
    public Spinner xreStoredData;
    public EditText xreServerHost;
    //    public EditText xreServerPort;
    public EditText xreRemotePath;
    public Map.Entry<String,String>[] xreItems;

    public final XreAnnouncesAdapter xreAnnouncesAdapter;
    public ListView xreAnnouncesListView;

    public final XreAnnouncesAdapter alreadyConnectedAdapter;
    public ListView alreadyConnectedListView;

    final Context a;
    fvbiInterface v;
    final GenericDBHelper dbh;

    final AtomicBoolean currentDirAutofillOverride;

    public static final boolean isRunningOnEmulator = Build.HARDWARE.contains("goldfish") || Build.HARDWARE.contains("ranchu");

    public interface fvbiInterface {
        <T extends View> T findViewById(int id);
    }

    public fvbiInterface getFvbiInterface(Object o) {
        if (o instanceof Activity)
            return ((Activity)o)::findViewById;
        else if (o instanceof Dialog)
            return ((Dialog)o)::findViewById;
        else if (o instanceof View)
            return ((View)o)::findViewById;
        throw new RuntimeException("Unexpected type in getFvbiInterface");
    }

    public static String basicNonEmptyValidation(EditText... fields) {
        boolean valid = true;
        for (EditText field : fields) {
            valid &= (field != null) && !(field.getText().toString().equals(""));
        }
        return valid ? "":"Invalid parameters";
    }

    public static AdapterView.OnItemClickListener getDefaultAnnounceItemSelectListener(EditText xreServerHost, EditText xreRemotePath) {
        return (parent,view,position,id) -> {
            Pair<String,String> item = (Pair<String, String>) parent.getItemAtPosition(position);
            xreServerHost.setText(item.i);
            xreRemotePath.setText(item.j);
        };
    }

    final AdapterView.OnItemSelectedListener defaultSpinnerItemSelectListener = new AdapterView.OnItemSelectedListener() {
        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            if (currentDirAutofillOverride.get()) {
                currentDirAutofillOverride.set(false);
                return;
            }

            Map.Entry<String,String> item = (Map.Entry<String, String>) parent.getItemAtPosition(position);
            xreServerHost.setText(item.getKey());
            xreRemotePath.setText(item.getValue());
        }

        @Override
        public void onNothingSelected(AdapterView<?> parent) {}
    };

    protected XREDirectoryViewModel(Activity activity, GenericDBHelper dbh, AtomicBoolean currentDirAutofillOverride) {
        this.a = activity;
        this.dbh = dbh;
        this.currentDirAutofillOverride = currentDirAutofillOverride;
        xreAnnouncesAdapter = XreAnnouncesAdapter.from(activity);
        alreadyConnectedAdapter = XreAnnouncesAdapter.fromAlreadyOpenedConnections(activity);
    }

    public XREDirectoryViewModel(Activity activity, View v, GenericDBHelper dbh, AtomicBoolean currentDirAutofillOverride) {
        this(activity, dbh, currentDirAutofillOverride);
        this.v = getFvbiInterface(v);
    }

    public XREDirectoryViewModel(Activity activity, Dialog dialog, GenericDBHelper dbh, AtomicBoolean currentDirAutofillOverride) {
        this(activity, dbh, currentDirAutofillOverride);
        this.v = getFvbiInterface(dialog);
    }

    boolean currentNumPadStatus = true;
    public void toggleNumPad(View unused) {
        currentNumPadStatus = !currentNumPadStatus;
        String xreServerHostText = xreServerHost.getText().toString();
        xreServerHost.setRawInputType(currentNumPadStatus ? InputType.TYPE_CLASS_NUMBER : InputType.TYPE_CLASS_TEXT);
        xreServerHost.setText(xreServerHostText);
    }

    public void initViews() {
        xreStoredData = v.findViewById(R.id.storedDataSpinner);
        xreServerHost = v.findViewById(R.id.xreConnectionDomainEditText);
        v.findViewById(R.id.xreConnectionDomainToggleNumPad).setOnClickListener(this::toggleNumPad);
        xreServerHost.setRawInputType(currentNumPadStatus ? InputType.TYPE_CLASS_NUMBER : InputType.TYPE_CLASS_TEXT);
//        xreServerPort = v.findViewById(R.id.xreConnectionPortEditText);
        xreRemotePath = v.findViewById(R.id.xreRemoteDirEditText);

        xreAnnouncesListView = v.findViewById(R.id.xreAnnouncesListView);
        xreAnnouncesListView.setAdapter(xreAnnouncesAdapter);

        alreadyConnectedListView = v.findViewById(R.id.xreAlreadyConnectedListView);
        alreadyConnectedListView.setAdapter(alreadyConnectedAdapter);

        AdapterView.OnItemClickListener selectListener = getDefaultAnnounceItemSelectListener(xreServerHost, xreRemotePath);
        alreadyConnectedListView.setOnItemClickListener(selectListener);
        xreAnnouncesListView.setOnItemClickListener(selectListener);


        ArrayList<Map.Entry<String,String>> xreitems_ = new ArrayList<>();
        xreitems_.add(new AbstractMap.SimpleEntry<>("","")); // empty item for no selection
        xreitems_.add(new AbstractMap.SimpleEntry<>("192.168.43.1","")); // default remote server and default offered home path when server provides network access with its WiFi hotspot
        if(isRunningOnEmulator) xreitems_.add(new AbstractMap.SimpleEntry<>("10.0.2.2", "")); // for being more comfortable if you want to connect to a XRE instance on your PC host while working on the Android Emulator
        xreitems_.addAll(dbh.getAllRowsOfXreFavoritesTable().values());
        xreItems = xreitems_.toArray(new Map.Entry[0]);


        ArrayAdapter<Map.Entry<String,String>> xreAdapter = new ArrayAdapter<>(a,
                android.R.layout.simple_spinner_dropdown_item,
                xreItems);
        xreStoredData.setAdapter(xreAdapter);
        xreStoredData.setOnItemSelectedListener(defaultSpinnerItemSelectListener);
        xreStoredData.setNextFocusDownId(R.id.xreConnectionDomainEditText);
        xreStoredData.setNextFocusUpId(R.id.httpUrlDownload);
    }
}

```

`app/src/main/res/anim/fade_in.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<alpha xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_interpolator"
    android:fromAlpha="0.0" android:toAlpha="1.0"
    android:duration="500" />

```

`app/src/main/res/anim/fade_out.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<alpha xmlns:android="http://schemas.android.com/apk/res/android"
    android:interpolator="@android:anim/accelerate_interpolator"
    android:fromAlpha="1.0" android:toAlpha="0.0"
    android:fillAfter="true"
    android:duration="500" />
```

`app/src/main/res/drawable/about_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="oval">
    <stroke
        android:width="0dp"
        android:color="@android:color/transparent" />
    <solid
        android:color="@color/transparentCobaltBlue"/>
</shape>
```

`app/src/main/res/drawable/hashview_window_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <corners
        android:topLeftRadius="0dp"
        android:topRightRadius="0dp"
        android:bottomRightRadius="0dp"
        android:bottomLeftRadius="0dp" />
    <stroke
        android:width="3dp"
        android:color="@android:color/background_dark" />
    <solid
        android:color="#800000c0"/>
</shape>
```

`app/src/main/res/drawable/ic_image.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="24dp"
    android:width="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path android:fillColor="#fff" android:pathData="M8.5,13.5L11,16.5L14.5,12L19,18H5M21,19V5C21,3.89 20.1,3 19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19Z" />
</vector>
```

`app/src/main/res/drawable/ic_image_remove.xml`:

```xml
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:height="24dp"
    android:width="24dp"
    android:viewportWidth="24"
    android:viewportHeight="24">
    <path android:fillColor="#fff" android:pathData="M5 3C3.9 3 3 3.9 3 5V19C3 20.11 3.9 21 5 21H14.09C14.03 20.67 14 20.34 14 20C14 19.32 14.12 18.64 14.35 18H5L8.5 13.5L11 16.5L14.5 12L16.73 14.97C17.7 14.34 18.84 14 20 14C20.34 14 20.67 14.03 21 14.09V5C21 3.89 20.1 3 19 3H5M16.47 17.88L18.59 20L16.47 22.12L17.88 23.54L20 21.41L22.12 23.54L23.54 22.12L21.41 20L23.54 17.88L22.12 16.46L20 18.59L17.88 16.47L16.46 17.88Z" />
</vector>
```

`app/src/main/res/drawable/media_gallery_placeholder.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <size
        android:width="100dp"
        android:height="100dp"/>
    <solid android:color="#e2e2e2"/>
</shape>
```

`app/src/main/res/drawable/root_background.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<shape
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:shape="rectangle">
    <gradient
        android:angle="270"
        android:startColor="#FF123456"
        android:endColor="#FF456789"
        android:type="linear" />
</shape>
```

`app/src/main/res/layout-television/activity_main_with_pager.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/activity_main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <RelativeLayout
        android:animateLayoutChanges="true"
        android:layout_width="match_parent"
        android:layout_weight="11"
        android:layout_height="0dp">

        <it.pgp.xfiles.BrowserViewPager
            android:id="@+id/browserpager"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/>

        <ProgressBar
            android:scaleType="fitCenter"
            android:adjustViewBounds="true"
            android:background="@null"
            android:id="@+id/progressCircleForGoDirOps"
            android:visibility="gone"
            android:layout_alignParentStart="true"
            android:layout_width="30dp"
            android:layout_height="wrap_content" />

        <ImageButton
            android:src="@drawable/xfiles_new_app_icon"
            android:scaleType="fitCenter"
            android:adjustViewBounds="true"
            android:focusable="true"
            android:focusableInTouchMode="true"
            android:background="?android:attr/selectableItemBackground"
            android:id="@+id/showNavLayoutBtn"
            android:onClick="showNavLayout"
            android:nextFocusDown="@id/xre_op_button"
            android:nextFocusRight="@id/xre_op_button"
            android:layout_alignParentStart="true"
            android:layout_width="30dp"
            android:layout_height="wrap_content" />

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <Space
                android:layout_weight="5"
                android:layout_width="0dp"
                android:layout_height="wrap_content" />

            <LinearLayout
                android:id="@+id/pathViewLayout"
                android:orientation="horizontal"
                android:layout_gravity="end"
                android:layout_weight="5"
                android:layout_width="0dp"
                android:layout_height="wrap_content" >

                <ImageButton
                    android:id="@+id/xre_op_button"
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="?android:attr/selectableItemBackground"
                    android:src="@drawable/xf_share"
                    android:onClick="showStartRHRemoteServerDialog"
                    android:nextFocusUp="@id/showNavLayoutBtn"
                    android:nextFocusLeft="@id/currentDirectoryTextView"
                    android:nextFocusRight="@id/openCredsFavsMenu"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="?android:attr/selectableItemBackground"
                    android:src="@drawable/xfiles_favorites"
                    android:id="@+id/openCredsFavsMenu"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="?android:attr/selectableItemBackground"
                    android:src="@drawable/xfiles_root_off"
                    android:id="@+id/toggleRootHelperButton"
                    android:onClick="toggleRootHelper"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="?android:attr/selectableItemBackground"
                    android:src="@drawable/xf_view_mode"
                    android:id="@+id/chooseBrowserViewButton"
                    android:onClick="changeBrowserViewMode"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="?android:attr/selectableItemBackground"
                    android:src="@drawable/xfiles_sort_icon"
                    android:id="@+id/sortButton"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="?android:attr/selectableItemBackground"
                    android:src="@android:drawable/checkbox_on_background"
                    android:id="@+id/itemSelectionButton"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="?android:attr/selectableItemBackground"
                    android:src="@drawable/xfiles_find"
                    android:id="@+id/quickFindButton"
                    android:nextFocusRight="@id/androidGoBackButton"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />
            </LinearLayout>
        </LinearLayout>

        <LinearLayout
            android:id="@+id/quickpaths_layout"
            android:orientation="vertical"
            android:visibility="gone"
            android:background="@color/transparentCobaltBlue2"
            android:layout_width="250dp"
            android:layout_height="match_parent" >

            <ListView
                android:id="@+id/quickpaths_listview"
                android:divider="#B6DFE4"
                android:dividerHeight="1dp"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
        </LinearLayout>
    </RelativeLayout>

    <LinearLayout
        android:id="@+id/operationButtonsLayout"
        android:orientation="horizontal"
        android:nextFocusDown="@id/showNavLayoutBtn"
        android:layout_width="match_parent"
        android:gravity="bottom"
        android:layout_weight="1"
        android:layout_height="0dp" />

</LinearLayout>

```

`app/src/main/res/layout-television/horizontal_operational_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:gravity="bottom"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <!-- Contains all possible buttons, including Home and Back ones (because in horizontal mode
     there is plenty of available space)-->

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:nextFocusLeft="@id/quickFindButton"
        android:src="@drawable/xfiles_system_back"
        android:id="@+id/androidGoBackButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:id="@+id/upOneLevelButton"
        android:src="@drawable/xf_up_dir"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xfiles_cut"
        android:id="@+id/cutButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xf_copy"
        android:id="@+id/copyButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xfiles_paste"
        android:id="@+id/pasteButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xf_arrow_left"
        android:id="@+id/goBackButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xfiles_system_home"
        android:id="@+id/androidGoHomeButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xf_arrow_right"
        android:id="@+id/goAheadButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xf_new_file"
        android:id="@+id/newFileButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xf_recycle_bin"
        android:id="@+id/deleteButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xfiles_archive"
        android:id="@+id/compressButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="?android:attr/selectableItemBackground"
        android:src="@drawable/xf_share"
        android:id="@+id/shareButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

</LinearLayout>

```

`app/src/main/res/layout/about_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/about_background">

    <ImageView
        android:src="@drawable/xfiles_new_app_icon"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:text="@string/app_name"
        android:textSize="32dp"
        android:gravity="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:text="@string/app_about_desc"
        android:textSize="16dp"
        android:gravity="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:id="@+id/aboutAppVersionName"
        android:gravity="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:id="@+id/aboutAppVersionCode"
        android:gravity="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:text="@string/appWebsite"
        android:autoLink="web"
        android:linksClickable="true"
        android:gravity="center"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:text="Check for updates"
        android:textSize="16dp"
        android:gravity="center"
        android:id="@+id/updateCheckButton"
        android:background="@null"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <!--PADDING-->
    <TextView
        android:text=""
        android:textSize="24sp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/active_remote_servers_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:text="@string/active_servers_on_close_explain"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:id="@+id/active_servers_xre_textview"
            android:textSize="16dp"
            android:text="XRE server"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <Button
            android:id="@+id/active_servers_xre_button"
            android:text="@string/close"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:id="@+id/active_servers_http_textview"
            android:textSize="16dp"
            android:text="@string/http_server"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <Button
            android:id="@+id/active_servers_http_button"
            android:text="@string/close"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:id="@+id/active_servers_ftp_textview"
            android:textSize="16dp"
            android:text="@string/ftp_server"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <Button
            android:id="@+id/active_servers_ftp_button"
            android:text="@string/close"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>
</LinearLayout>

```

`app/src/main/res/layout/activity_find.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="it.pgp.xfiles.FindActivity">

    <LinearLayout
        android:id="@+id/dropdown_layout"
        android:background ="#439ecf"
        android:orientation="vertical"
        android:layout_alignParentTop="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:text="Search directory:"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <ImageView
                android:id="@+id/find_path_type"
                android:layout_weight="1"
                android:layout_width="0dp"
                android:layout_height="match_parent" />

            <it.pgp.xfiles.utils.ArrayTextView
                android:id="@+id/find_path_textview"
                android:layout_width="0dp"
                android:layout_weight="8"
                android:layout_height="match_parent" />

            <Button
                android:text="..."
                android:id="@+id/find_path_choose_button"
                android:layout_width="0dp"
                android:layout_weight="2"
                android:layout_height="match_parent" />

        </LinearLayout>

        <TextView
            android:text="Name pattern:"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <EditText
            android:id="@+id/find_name_pattern_edittext"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <!-- search in files only with non-empty content pattern -->
        <TextView
            android:text="Content pattern:"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <EditText
            android:id="@+id/find_content_pattern_edittext"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <CheckedTextView
            android:id="@+id/find_only_current_folder_checkbox"
            android:text="Search only current folder"
            android:focusable="true"
            android:clickable="true"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        <CheckedTextView
            android:id="@+id/case_insensitive_search_checkbox"
            android:text="Case insensitive search"
            android:focusable="true"
            android:clickable="true"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">
            <Button
                android:id="@+id/startSearch"
                android:text="Start search"
                android:layout_weight="1"
                android:layout_width="0dp"
                android:layout_height="match_parent" />
            <Button
                android:id="@+id/stopSearch"
                android:text="Stop search"
                android:layout_weight="1"
                android:layout_width="0dp"
                android:layout_height="match_parent" />
            <Button
                android:id="@+id/clearResults"
                android:text="Clear results"
                android:layout_weight="1"
                android:layout_width="0dp"
                android:layout_height="match_parent" />
        </LinearLayout>

    </LinearLayout>

    <ImageButton
        android:id="@+id/dropdown_button"
        android:layout_alignParentEnd="true"
        android:layout_alignParentTop="true"
        android:onClick="onSlideViewButtonClick"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

    <ListView
        android:id="@+id/results_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:transcriptMode="alwaysScroll" />

</RelativeLayout>

```

`app/src/main/res/layout/activity_gallery.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#000000"
    android:id="@+id/rl_parent_main"
    android:orientation="vertical">
    <HorizontalScrollView
        android:id="@+id/toolbar_media_gallery"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <it.pgp.xfiles.GalleryViewPager
        android:id="@+id/pager"
        android:fitsSystemWindows="true"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_below="@+id/toolbar_media_gallery" />

    <android.support.v7.widget.RecyclerView
        android:id="@+id/imagesHorizontalList"
        android:layout_width="match_parent"
        android:layout_height="70dp"
        android:layout_alignParentBottom="true"
        android:layout_marginBottom="30dp"
        android:clipToPadding="false"
        android:paddingLeft="40dp"
        android:paddingRight="40dp" />

    <ImageButton
        android:id="@+id/showImageOnLockScreen"
        android:src="@android:drawable/ic_lock_idle_lock"
        android:onClick="setShowImageOnLockScreen"
        android:background="@null"
        android:layout_alignParentTop="true"
        android:layout_alignParentEnd="true"
        android:layout_width="50dp"
        android:layout_height="50dp" />
</RelativeLayout>
```

`app/src/main/res/layout/activity_main_with_pager.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/activity_main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <RelativeLayout
        android:animateLayoutChanges="true"
        android:layout_width="match_parent"
        android:layout_weight="11"
        android:layout_height="0dp">

        <it.pgp.xfiles.BrowserViewPager
            android:id="@+id/browserpager"
            android:layout_width="match_parent"
            android:layout_height="match_parent"/>

        <ProgressBar
            android:scaleType="fitCenter"
            android:adjustViewBounds="true"
            android:background="@null"
            android:id="@+id/progressCircleForGoDirOps"
            android:visibility="gone"
            android:layout_alignParentStart="true"
            android:layout_width="30dp"
            android:layout_height="wrap_content" />

        <ImageButton
            android:src="@drawable/xfiles_new_app_icon"
            android:scaleType="fitCenter"
            android:adjustViewBounds="true"
            android:background="@null"
            android:id="@+id/showNavLayoutBtn"
            android:onClick="showNavLayout"
            android:nextFocusUp="@id/operationButtonsLayout"
            android:nextFocusRight="@id/currentDirectoryTextView"
            android:layout_alignParentStart="true"
            android:layout_width="30dp"
            android:layout_height="wrap_content" />

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <Space
                android:layout_weight="5"
                android:layout_width="0dp"
                android:layout_height="wrap_content" />

            <LinearLayout
                android:id="@+id/pathViewLayout"
                android:orientation="horizontal"
                android:layout_gravity="end"
                android:layout_weight="5"
                android:layout_width="0dp"
                android:layout_height="wrap_content" >

                <ImageButton
                    android:id="@+id/xre_op_button"
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="@null"
                    android:src="@drawable/xf_share"
                    android:onClick="showStartRHRemoteServerDialog"
                    android:nextFocusLeft="@id/currentDirectoryTextView"
                    android:nextFocusRight="@id/openCredsFavsMenu"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="@null"
                    android:src="@drawable/xfiles_favorites"
                    android:id="@+id/openCredsFavsMenu"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="@null"
                    android:src="@drawable/xfiles_root_off"
                    android:id="@+id/toggleRootHelperButton"
                    android:onClick="toggleRootHelper"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="@null"
                    android:src="@drawable/xf_view_mode"
                    android:id="@+id/chooseBrowserViewButton"
                    android:onClick="changeBrowserViewMode"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="@null"
                    android:src="@drawable/xfiles_sort_icon"
                    android:id="@+id/sortButton"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="@null"
                    android:src="@android:drawable/checkbox_on_background"
                    android:id="@+id/itemSelectionButton"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />

                <ImageButton
                    android:scaleType="fitCenter"
                    android:adjustViewBounds="true"
                    android:background="@null"
                    android:src="@drawable/xfiles_find"
                    android:id="@+id/quickFindButton"
                    android:nextFocusRight="@id/androidGoBackButton"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="wrap_content" />
            </LinearLayout>
        </LinearLayout>

        <LinearLayout
            android:id="@+id/quickpaths_layout"
            android:orientation="vertical"
            android:visibility="gone"
            android:background="@color/transparentCobaltBlue2"
            android:layout_width="250dp"
            android:layout_height="match_parent" >

            <ListView
                android:id="@+id/quickpaths_listview"
                android:divider="#B6DFE4"
                android:dividerHeight="1dp"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
        </LinearLayout>
    </RelativeLayout>

    <LinearLayout
        android:id="@+id/operationButtonsLayout"
        android:orientation="horizontal"
        android:nextFocusDown="@id/showNavLayoutBtn"
        android:layout_width="match_parent"
        android:gravity="bottom"
        android:layout_weight="1"
        android:layout_height="0dp" />

</LinearLayout>

```

`app/src/main/res/layout/activity_permission_management.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".PermissionManagementActivity">

    <TextView
        android:textSize="15dp"
        android:gravity="center_horizontal"
        android:text="@string/permission_storage_explain"
        android:textColor="@color/green"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:onClick="requestStoragePermissions"
        android:id="@+id/storagePermissions"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Request Storage permission" />

    <TextView
        android:visibility="gone"
        android:id="@+id/notifs13PermissionsExplain"
        android:textSize="15dp"
        android:gravity="center_horizontal"
        android:text="@string/permission_notifs13_explain"
        android:textColor="@color/green"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:visibility="gone"
        android:onClick="requestNotifs13Permissions"
        android:id="@+id/notifs13Permissions"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Request Notifications permission (Android 13+)" />

    <TextView
        android:textSize="15dp"
        android:gravity="center_horizontal"
        android:text="@string/permission_sysSettings_explain"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:onClick="openSystemSettingsPermissionsManagement"
        android:id="@+id/sysSettingsPermissions"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Request System Settings permission" />

    <TextView
        android:textSize="15dp"
        android:gravity="center_horizontal"
        android:text="@string/permission_overlay_explain"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:onClick="openOverlayPermissionsManagement"
        android:id="@+id/overlayPermissions"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Request Overlay permission" />

    <TextView
        android:textSize="15dp"
        android:gravity="center_horizontal"
        android:text="@string/permission_install_unknown_apps_explain"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:onClick="openInstallUnknownAppsPermissionsManagement"
        android:id="@+id/installUnknownAppsPermissions"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Request Install Unknown Apps permission" />

    <Button
        android:onClick="completePermissions"
        android:id="@+id/completePermissions"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK" />

</LinearLayout>
```

`app/src/main/res/layout/activity_xre_direct_share.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" >

        <TextView
            android:text="Toggle wifi and hotstop state from here, long click on wifi icon to show networks"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <LinearLayout
            android:orientation="vertical"
            android:id="@+id/targetWifiButtonsLayout"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

    </LinearLayout>

    <include
        android:id="@+id/xre_embedded_layout"
        android:layout_width="fill_parent"
        android:layout_height="wrap_content"
        layout="@layout/change_directory_dialog_frame_xre" />

    <Button
        android:id="@+id/xreDirectShareOkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>
```

`app/src/main/res/layout/advanced_sorting_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/sortingAttributesDragNDropListView"
        android:layout_alignParentTop="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
    </android.support.v7.widget.RecyclerView>

    <LinearLayout
        android:layout_below="@id/sortingAttributesDragNDropListView"
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <Button
            android:text="Cancel"
            android:id="@+id/advancedSortCancelButton"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="wrap_content" />
        <Button
            android:text="OK"
            android:id="@+id/advancedSortOKButton"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="wrap_content" />
    </LinearLayout>

</RelativeLayout>

```

`app/src/main/res/layout/ask_password_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <EditText
        android:id="@+id/passwordEditText"
        android:inputType="textPassword"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <CheckedTextView
        android:id="@+id/passwordVisibleCtv"
        android:text="Show password"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

    <Button
        android:id="@+id/askPasswordOkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>

```

`app/src/main/res/layout/browser_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <ImageView
        android:id="@+id/fileTypeImage"
        android:layout_weight=".1"
        android:layout_width="0dp"
        android:layout_height="match_parent" />

    <LinearLayout
        android:orientation="vertical"
        android:layout_weight=".8"
        android:layout_width="0dp"
        android:layout_height="match_parent">

        <EditText
            android:id="@+id/browserItemFilename_edit"
            android:visibility="gone"
            android:inputType="text"
            android:imeOptions="actionDone"
            android:maxLines="1"
            android:singleLine="true"
            android:textColor="#CCCCCC"
            android:textSize="18sp"
            android:layout_weight="5"
            android:layout_width="match_parent"
            android:layout_height="0dp" />

        <TextView
            android:id="@+id/browserItemFilename"
            android:textColor="#CCCCCC"
            android:textSize="18sp"
            android:layout_weight="5"
            android:layout_width="match_parent"
            android:layout_height="0dp" />

        <RelativeLayout
            android:layout_weight="2"
            android:layout_width="match_parent"
            android:layout_height="0dp">

            <TextView
                android:id="@+id/browserItemFileSize"
                android:textColor="#9AD1FA"
                android:textSize="12sp"
                android:layout_alignParentStart="true"
                android:layout_width="wrap_content"
                android:layout_height="match_parent" />

            <TextView
                android:id="@+id/browserItemFileDate"
                android:textColor="#B2E1F7"
                android:textSize="12sp"
                android:layout_alignParentEnd="true"
                android:layout_width="wrap_content"
                android:layout_height="match_parent" />

        </RelativeLayout>
    </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/browser_item_grid.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content">
    <!--<CheckBox-->
        <!--android:id="@+id/browserItemSelectedCheckbox"-->
        <!--android:layout_width="wrap_content"-->
        <!--android:layout_height="wrap_content"-->
        <!--android:layout_alignParentTop="true"-->
        <!--android:layout_alignParentEnd="true"-->
        <!--android:focusable="false" />-->

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="match_parent">

        <ImageView
            android:id="@+id/fileTypeImage"
            android:layout_weight="5"
            android:layout_height="0dp"
            android:layout_width="match_parent" />

        <TextView
            android:id="@+id/browserItemFilename"
            android:textSize="15sp"
            android:singleLine="true"
            android:ellipsize="end"
            android:gravity="center"
            android:layout_weight="2"
            android:layout_width="match_parent"
            android:layout_height="0dp" />

    </LinearLayout>
</RelativeLayout>
```

`app/src/main/res/layout/browser_page.xml`:

```xml
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_height="match_parent"
    android:layout_width="match_parent"
    android:orientation="vertical"
    >

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight=".1">

        <!--empty padder originally left for operationButtonsLayoutSwitcher, now for progressCircle -->
        <View
            android:focusable="false"
            android:focusableInTouchMode="false"
            android:background="@null"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="wrap_content" />

        <TextView
            android:id="@+id/currentDirectoryTextView"
            android:background="?android:attr/selectableItemBackground"
            android:nextFocusUp="@id/showNavLayoutBtn"
            android:nextFocusRight="@id/xre_op_button"
            android:nextFocusDown="@id/mainBrowserViewLayout"
            android:ellipsize="end"
            android:singleLine="false"
            android:maxLines="3"
            android:clickable="true"
            android:onClick="showChangeDirectoryDialog"
            android:layout_weight="4"
            android:layout_width="0dp"
            android:layout_height="wrap_content" />

        <!-- dummy view for padding -->
        <Space
            android:layout_weight="5"
            android:layout_width="0dp"
            android:layout_height="wrap_content" />

    </LinearLayout>

    <!-- dynamically populated by layout inflater for multi select mode -->
    <!-- REMOVED FROM HERE, INFLATED WITH ADDVIEW OVER mainBrowserViewLayout-->
    <!--<LinearLayout
        android:id="@+id/multiSelectModeLayout"
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="0">
    </LinearLayout>-->

    <!-- dynamically populated by layout inflater for quick find mode -->
    <LinearLayout
        android:id="@+id/quickFindModeLayout"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="0">
    </LinearLayout>

    <RelativeLayout
        android:id="@+id/mainBrowserViewLayoutParent"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">

        <it.pgp.xfiles.SwipeRefreshLayoutChildCanScroll
            android:id="@+id/activity_main_swipe_refresh_layout"
            android:layout_width="match_parent"
            android:layout_height="match_parent" >
            <RelativeLayout
                android:orientation="vertical"
                android:id="@+id/mainBrowserViewLayout"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
        </it.pgp.xfiles.SwipeRefreshLayoutChildCanScroll>

    </RelativeLayout>

</LinearLayout>
```

`app/src/main/res/layout/bulk_rename_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:id="@+id/inputRenamePatternLabel"
        android:text="Input pattern"
        android:layout_alignParentTop="true"
        android:layout_alignParentStart="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <EditText
        android:layout_below="@id/inputRenamePatternLabel"
        android:id="@+id/inputRenamePattern"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_below="@id/inputRenamePattern"
        android:id="@+id/outputRenamePatternLabel"
        android:text="Output pattern"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <EditText
        android:layout_below="@id/outputRenamePatternLabel"
        android:id="@+id/outputRenamePattern"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <RadioGroup
        android:layout_below="@id/outputRenamePattern"
        android:id="@+id/renameRadioGroup"
        android:orientation="horizontal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" >

        <RadioButton
            android:id="@+id/renameStdRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Standard"
            android:checked="true"/>

        <RadioButton
            android:id="@+id/renameRegexRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Regex" />

        <RadioButton
            android:id="@+id/renameGlobRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Glob" />
    </RadioGroup>

    <LinearLayout
        android:layout_below="@id/renameRadioGroup"
        android:layout_above="@id/renameOpsLayout"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" >

        <ListView
            android:fastScrollEnabled="true"
            android:id="@+id/inputRenameLv"
            android:layout_weight="1"
            android:layout_width="match_parent"
            android:layout_height="0dp" />

        <ListView
            android:fastScrollEnabled="true"
            android:id="@+id/outputRenameLv"
            android:layout_weight="1"
            android:layout_width="match_parent"
            android:layout_height="0dp" />

    </LinearLayout>

    <LinearLayout
        android:id="@+id/renameOpsLayout"
        android:layout_alignParentBottom="true"
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <ProgressBar
            style="?android:attr/progressBarStyleHorizontal"
            android:id="@+id/renameProgressBar"
            android:visibility="gone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <Button
            android:text="Preview"
            android:id="@+id/renamePreviewButton"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <Button
            android:text="@android:string/ok"
            android:id="@+id/renameOkButton"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>

</RelativeLayout>

```

`app/src/main/res/layout/change_directory_dialog_frame_archive.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Archive pathname:"
        android:textSize="18sp" />

    <Spinner
        android:id="@+id/storedDataSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@android:drawable/btn_dropdown"
        android:spinnerMode="dropdown" />

    <AutoCompleteTextView
        android:id="@+id/archivePathnameEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="In-archive directory:"
        android:textSize="18sp" />

    <EditText
        android:id="@+id/archiveSubDirEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/change_directory_dialog_frame_http.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="URL to download:"
        android:textSize="18sp" />

    <it.pgp.xfiles.viewmodels.PasteableEditText
        android:id="@+id/httpUrlEditText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Destination directory (optional):"
        android:textSize="18sp" />

    <EditText
        android:id="@+id/httpDestDirEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Target filename (optional):"
        android:textSize="18sp" />

    <EditText
        android:id="@+id/httpTargetFilenameEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <CheckedTextView
        android:checked="true"
        android:id="@+id/httpForceHttpsCheckbox"
        android:text="Force https"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

</LinearLayout>
```

`app/src/main/res/layout/change_directory_dialog_frame_local.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Local directory:"
        android:textSize="18sp" />

    <Spinner
        android:id="@+id/storedDataSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@android:drawable/btn_dropdown"
        android:nextFocusUp="@id/httpUrlDownload"
        android:nextFocusDown="@id/localDirEditText"
        android:spinnerMode="dropdown" />

    <AutoCompleteTextView
        android:id="@+id/localDirEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/change_directory_dialog_frame_sftp.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stored users:"
        android:textSize="16sp" />

    <Spinner
        android:id="@+id/storedDataSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@android:drawable/btn_dropdown"
        android:spinnerMode="dropdown" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="User:"
        android:textSize="16sp" />

    <EditText
        android:id="@+id/connectionUserEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Password:"
        android:textSize="16sp" />

    <EditText
        android:id="@+id/connectionPasswordEditText"
        android:inputType="textPassword"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Domain:"
        android:textSize="16sp" />

    <EditText
        android:id="@+id/connectionDomainEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Port:"
        android:textSize="16sp" />

    <EditText
        android:id="@+id/connectionPortEditText"
        android:inputType="number"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Remote directory:"
        android:textSize="16sp" />

    <!-- auto-complete using remote path favorites for the chosen auth data -->
    <AutoCompleteTextView
        android:id="@+id/remoteDirEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/change_directory_dialog_frame_smb.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Stored users:"
        android:textSize="14sp" />

    <Spinner
        android:id="@+id/storedDataSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@android:drawable/btn_dropdown"
        android:spinnerMode="dropdown" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="User:"
        android:textSize="14sp" />

    <EditText
        android:id="@+id/connectionUserEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Password:"
        android:textSize="14sp" />

    <EditText
        android:id="@+id/connectionPasswordEditText"
        android:inputType="textPassword"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Domain:"
        android:textSize="14sp" />

    <EditText
        android:id="@+id/connectionDomainEditText"
        android:inputType="text"
        android:text="@string/smb_default_domain"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Host:"
        android:textSize="14sp" />

    <EditText
        android:id="@+id/connectionHostEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Port:"
        android:textSize="14sp" />

    <EditText
        android:id="@+id/connectionPortEditText"
        android:inputType="number"
        android:text="@string/smb_default_port"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Remote directory:"
        android:textSize="14sp" />

    <!-- auto-complete using remote path favorites for the chosen auth data -->
    <AutoCompleteTextView
        android:id="@+id/remoteDirEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/change_directory_dialog_frame_xre.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--<TextView-->
        <!--android:layout_width="match_parent"-->
        <!--android:layout_height="wrap_content"-->
        <!--android:text="Stored servers:"-->
        <!--android:textSize="18sp" />-->

    <Spinner
        android:id="@+id/storedDataSpinner"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@android:drawable/btn_dropdown"
        android:spinnerMode="dropdown" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Domain:"
        android:textSize="14sp" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content" >
        <EditText
            android:id="@+id/xreConnectionDomainEditText"
            android:inputType="text"
            android:text="192.168.43.1"
            android:imeOptions="actionDone"
            android:layout_width="0dp"
            android:layout_weight="8"
            android:layout_height="wrap_content" />
        <ImageButton
            android:src="@drawable/ic_notification_ime_default"
            android:id="@+id/xreConnectionDomainToggleNumPad"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="wrap_content"
            />
    </LinearLayout>

    <!--<TextView-->
        <!--android:layout_width="match_parent"-->
        <!--android:layout_height="wrap_content"-->
        <!--android:text="Port:"-->
        <!--android:textSize="18sp" />-->

    <!--<EditText-->
        <!--android:id="@+id/xreConnectionPortEditText"-->
        <!--android:inputType="number"-->
        <!--android:text="11111"-->
        <!--android:imeOptions="actionDone"-->
        <!--android:layout_width="match_parent"-->
        <!--android:layout_height="wrap_content" />-->

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Remote directory:"
        android:textSize="14sp" />

    <!-- auto-complete using remote path favorites for the chosen auth data -->
    <EditText
        android:id="@+id/xreRemoteDirEditText"
        android:inputType="text"
        android:hint="Leave empty for server's home dir"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <!-- stub textview for testing XRE announce -->

    <!--<TextView-->
        <!--android:text="XRE Announce message"-->
        <!--android:layout_width="match_parent"-->
        <!--android:layout_height="wrap_content" />-->

    <!--<TextView-->
        <!--android:id="@+id/xreAnnounceTextView"-->
        <!--android:layout_width="match_parent"-->
        <!--android:layout_height="wrap_content" />-->


    <!-- Accumulates received XRE server announces (backed by a set structure), to be replaced by a more UI-friendly widget -->
    <TextView
        android:text="Announced XRE servers"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <ListView
        android:id="@+id/xreAnnouncesListView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:text="Already opened connections"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <ListView
        android:id="@+id/xreAlreadyConnectedListView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/change_directory_generic_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:orientation="horizontal"
        android:layout_weight="4"
        android:layout_width="match_parent"
        android:layout_height="0dp">

        <!--TODO smaller radiobuttons-->
        <RadioGroup
            android:id="@+id/pathContentRadioGroup"
            android:orientation="vertical"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" >

            <RadioButton
                android:id="@+id/localFolder"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Local Directory" />

            <RadioButton
                android:id="@+id/localArchive"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Local archive"
                android:checked="true" />

            <RadioButton
                android:id="@+id/sftpRemoteFolder"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="SFTP directory" />

            <RadioButton
                android:id="@+id/xfilesRemoteFolder"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="XFiles remote directory" />

            <RadioButton
                android:id="@+id/smbRemoteFolder"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="SMB directory" />

            <RadioButton
                android:id="@+id/httpUrlDownload"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:nextFocusDown="@id/storedDataSpinner"
                android:text="Download URL" />
        </RadioGroup>

        <LinearLayout
            android:orientation="vertical"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" >

            <TextView
                android:text="Toggle wifi and hotspot state from here, long click on wifi icon to show networks"
                android:focusable="true"
                android:focusableInTouchMode="true"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />

            <LinearLayout
                android:orientation="vertical"
                android:id="@+id/targetWifiButtonsLayout"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />

        </LinearLayout>


    </LinearLayout>

    <LinearLayout
        android:orientation="vertical"
        android:id="@+id/pathContentTypeContainerLayout"
        android:layout_width="match_parent"
        android:layout_weight="8"
        android:layout_height="0dp" />

    <Button
        android:id="@+id/changeDirOkButton"
        android:layout_width="match_parent"
        android:layout_weight="1"
        android:layout_height="0dp"
        android:text="OK"/>

</LinearLayout>
```

`app/src/main/res/layout/checksum_base_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <GridView
        android:id="@+id/hashSelectorView"
        android:numColumns="auto_fit"
        android:columnWidth="100dp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" >
    </GridView>

    <LinearLayout
        android:id="@+id/checksum_dirHashOptsLayout"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:text="Directory hashing options:"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <CheckedTextView
                android:checked="false"
                android:id="@+id/checksum_dirHashWithNames"
                android:text="Include filenames"
                android:focusable="true"
                android:clickable="true"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

            <CheckedTextView
                android:checked="true"
                android:id="@+id/checksum_dirHashIgnoreThumbsFiles"
                android:text="Ignore thumbs files"
                android:focusable="true"
                android:clickable="true"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        </LinearLayout>

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <CheckedTextView
                android:checked="true"
                android:id="@+id/checksum_dirHashIgnoreUnixHiddenFiles"
                android:text="Ignore Unix hidden files"
                android:focusable="true"
                android:clickable="true"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

            <CheckedTextView
                android:checked="true"
                android:id="@+id/checksum_dirHashIgnoreEmptyDirs"
                android:text="Ignore empty sub-directories"
                android:focusable="true"
                android:clickable="true"
                android:layout_width="wrap_content"
                android:layout_height="match_parent"
                android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        </LinearLayout>

    </LinearLayout>

    <ScrollView
        android:scrollbars="horizontal|vertical"
        android:layout_height="0dp"
        android:layout_width="match_parent"
        android:layout_weight="6"
        android:layout_marginTop="5dip"
        android:scrollbarStyle="outsideInset"
        android:fillViewport="true">
        <HorizontalScrollView
            android:layout_height="wrap_content"
            android:scrollbars="horizontal|vertical"
            android:layout_width="wrap_content"
            android:layout_marginTop="5dip">
            <TableLayout
                android:layout_width="match_parent"
                android:layout_height="match_parent"
                android:id="@+id/standardResultsLayout" >
            </TableLayout>
        </HorizontalScrollView>
    </ScrollView>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <Button
            android:id="@+id/computeChecksumsButton"
            android:onClick="ok"
            android:layout_weight="5"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:text="Hash" />

        <Button
            android:id="@+id/exportChecksumsCSVButton"
            android:onClick="openExportOutputSelector"
            android:textSize="14dp"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:text="->CSV" />

        <Button
            android:id="@+id/exportChecksumsJSONButton"
            android:onClick="openExportOutputSelector"
            android:textSize="14dp"
            android:layout_weight="2"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:text="->JSON" />

        <ImageButton
            android:background="@android:color/transparent"
            android:src="@android:drawable/ic_menu_help"
            android:onClick="showLegend"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:text="Compute checksums" />
    </LinearLayout>


</LinearLayout>

```

`app/src/main/res/layout/checksum_label_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content">
        <CheckedTextView
            android:id="@+id/checksum_ctv"
            android:focusable="true"
            android:clickable="true"
            android:layout_height="wrap_content"
            android:layout_width="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />
</LinearLayout>
```

`app/src/main/res/layout/compress_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:text="File path:"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <!--absolute path of LocalPathContent of file-->
        <EditText
            android:id="@+id/outputArchiveFilePath"
            android:layout_weight="9"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <!--onclick: open file chooser for save -->
        <ImageButton
            android:id="@+id/selectOutputArchiveFilePath"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent"
            android:src="@android:drawable/ic_menu_gallery"
            />
    </LinearLayout>

    <RadioGroup
        android:id="@+id/archiveTypeRadioGroup"
        android:orientation="horizontal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" >

        <RadioButton
            android:id="@+id/_7zRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="7Z"
            android:checked="true"/>

        <RadioButton
            android:id="@+id/zipRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="ZIP" />

        <RadioButton
            android:id="@+id/tarRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="TAR" />

        <RadioButton
            android:id="@+id/gzRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="GZ" />

        <RadioButton
            android:id="@+id/bz2RadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="BZ2" />

        <RadioButton
            android:id="@+id/xzRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="XZ" />
    </RadioGroup>

    <CheckedTextView
        android:id="@+id/solidMode"
        android:text="Solid archive"
        android:checked="true"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <TextView
            android:text="Compression level"
            android:layout_width="0dp"
            android:layout_weight="3"
            android:layout_height="match_parent" />

        <SeekBar
            android:id="@+id/compressionLevel"
            android:layout_width="0dp"
            android:layout_weight="6"
            android:layout_height="match_parent" />

        <!-- to show the current value of the SeekBar -->
        <TextView
            android:id="@+id/compressionLevelNum"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <TextView
            android:text="Password:"
            android:layout_weight="3"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <EditText
            android:id="@+id/outputArchivePassword"
            android:inputType="textPassword"
            android:imeOptions="actionDone"
            android:layout_weight="7"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    </LinearLayout>

    <CheckedTextView
        android:id="@+id/encryptFilenames"
        android:text="Encrypt filenames"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

    <Button
        android:text="OK"
        android:onClick="compress_ok"
        android:id="@+id/compressDialogOKButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
</LinearLayout>
```

`app/src/main/res/layout/conflict_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="3">

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1" >

            <ImageView
                android:id="@+id/conflictSrcImage"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1" />

            <TextView
                android:id="@+id/conflictSrcPath"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="4" />
        </LinearLayout>

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="0dp"
            android:layout_weight="1" >

            <ImageView
                android:id="@+id/conflictDestImage"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1" />

            <TextView
                android:id="@+id/conflictDestPath"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="4" />
        </LinearLayout>

    </LinearLayout>

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">
        <TextView
            android:text="New filename"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            />
        <EditText
            android:id="@+id/conflictNewPathnameEditText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
    </LinearLayout>

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="6">
        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <Button
                android:id="@+id/conflictRenameSrc"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Rename source"
                android:textSize="14sp" />

            <Button
                android:id="@+id/conflictAutoRenameSrc"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Auto-rename all sources"
                android:textSize="14sp" />
        </LinearLayout>

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <Button
                android:id="@+id/conflictRenameDest"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Rename target"
                android:textSize="14sp" />

            <Button
                android:id="@+id/conflictAutoRenameDest"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Auto-rename all targets"
                android:textSize="14sp" />
        </LinearLayout>

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <Button
                android:id="@+id/conflictOverwrite"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Overwrite"
                android:textSize="14sp" />

            <Button
                android:id="@+id/conflictOverwriteAll"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Overwrite all"
                android:textSize="14sp" />

        </LinearLayout>

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <Button
                android:id="@+id/conflictSkip"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Skip"
                android:textSize="14sp" />

            <Button
                android:id="@+id/conflictSkipAll"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Skip all"
                android:textSize="14sp" />

        </LinearLayout>

        <!-- merge buttons (to be enabled only in dir conflict) -->
        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <Button
                android:id="@+id/conflictMerge"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Merge"
                android:textSize="14sp" />

            <Button
                android:id="@+id/conflictMergeAll"
                android:layout_width="0dp"
                android:layout_height="match_parent"
                android:layout_weight="1"
                android:text="Merge all"
                android:textSize="14sp" />

        </LinearLayout>


        <!--stop copy/move operation-->
        <Button
            android:id="@+id/conflictCancel"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:text="Cancel"
            android:textSize="14sp" />

    </LinearLayout>

    <!--merge buttons-->

</LinearLayout>
```

`app/src/main/res/layout/cont_sel.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <LinearLayout
        android:orientation="vertical"
        android:background="@color/transparentBlue"
        android:id="@+id/padLayout"
        android:visibility="gone"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <LinearLayout
        android:orientation="horizontal"
        android:background="@color/black"
        android:id="@+id/barLayout"
        android:layout_alignParentBottom="true"
        android:layout_alignParentStart="true"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content">

        <CheckedTextView
            android:id="@+id/toggleSelectMode"
            android:text="Select"
            android:textColor="@color/white"
            android:clickable="true"
            android:focusable="true"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        <CheckedTextView
            android:id="@+id/invertSelection"
            android:text="Invert"
            android:textColor="@color/green"
            android:clickable="true"
            android:focusable="true"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        <CheckedTextView
            android:id="@+id/stickySelection"
            android:text="Sticky"
            android:textColor="@color/green"
            android:clickable="true"
            android:focusable="true"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

    </LinearLayout>

    <LinearLayout
        android:layout_above="@id/barLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <Button
            android:onClick="multiSelectAction"
            android:id="@+id/itemsSelectAll"
            android:text="@string/select_all"
            android:textSize="10sp"
            android:drawableTop="@android:drawable/checkbox_on_background"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:maxLines="2" />

        <Button
            android:onClick="multiSelectAction"
            android:id="@+id/itemsSelectNone"
            android:text="@string/select_none"
            android:textSize="10sp"
            android:drawableTop="@android:drawable/checkbox_off_background"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:maxLines="2" />

        <Button
            android:onClick="multiSelectAction"
            android:id="@+id/itemsInvertSelection"
            android:text="@string/invert_selection"
            android:textSize="10sp"
            android:drawableTop="@android:drawable/checkbox_on_background"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:maxLines="2" />

        <Button
            android:onClick="multiSelectAction"
            android:id="@+id/itemsFilterSelection"
            android:text="@string/filter_selection"
            android:textSize="10sp"
            android:drawableTop="@android:drawable/checkbox_on_background"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:maxLines="2" />

        <Button
            android:onClick="multiSelectAction"
            android:id="@+id/itemsFilterDeselection"
            android:text="@string/filter_deselection"
            android:textSize="10sp"
            android:drawableTop="@android:drawable/checkbox_off_background"
            android:layout_width="wrap_content"
            android:layout_height="match_parent"
            android:maxLines="2" />

    </LinearLayout>

</RelativeLayout>

```

`app/src/main/res/layout/create_file_dir_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:text="Name:"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <EditText
        android:id="@+id/fileDirCreate_filename"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <CheckedTextView
        android:id="@+id/fileDirCreate_advancedOptionsCtv"
        android:text="Advanced file creation options"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

    <LinearLayout
        android:orientation="vertical"
        android:id="@+id/fileDirCreate_advancedOptionsLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <LinearLayout
            android:orientation="horizontal"
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <TextView
                android:text="File size"
                android:layout_width="wrap_content"
                android:layout_height="match_parent" />

            <RadioGroup
                android:id="@+id/sizeUnitRadioGroup"
                android:orientation="horizontal"
                android:layout_width="wrap_content"
                android:layout_height="match_parent">

                <RadioButton
                    android:id="@+id/bRadioButton"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:text="b"
                    android:checked="true"/>

                <RadioButton
                    android:id="@+id/kbRadioButton"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:text="kb" />

                <RadioButton
                    android:id="@+id/MbRadioButton"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:text="Mb" />

                <RadioButton
                    android:id="@+id/GbRadioButton"
                    android:layout_width="wrap_content"
                    android:layout_height="match_parent"
                    android:text="Gb" />
            </RadioGroup>

        </LinearLayout>

        <EditText
            android:id="@+id/fileDirCreate_fileSize"
            android:inputType="number"
            android:text="0"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <TextView
            android:text="File creation strategy"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <RadioGroup
            android:id="@+id/fileDirCreate_fileCreationStrategy"
            android:orientation="horizontal"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:checkedButton="@id/fileCreationStrategy_zeros" >

            <RadioButton
                android:id="@+id/fileCreationStrategy_zeros"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="zeros" />

            <RadioButton
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="random" />

        </RadioGroup>

        <CheckedTextView
            android:id="@+id/fileCreationStrategy_useCustomSeed"
            android:text="Use custom seed"
            android:focusable="true"
            android:clickable="true"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        <EditText
            android:visibility="gone"
            android:id="@+id/fileCreationStrategy_seed"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <CheckedTextView
            android:id="@+id/fileCreationStrategy_enableOutputHash"
            android:text="Compute hash while generating file"
            android:focusable="true"
            android:clickable="true"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        <Spinner
            android:visibility="gone"
            android:id="@+id/fileCreationStrategy_HashTypesSpinner"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@android:drawable/btn_dropdown"
            android:spinnerMode="dropdown" />

        <CheckedTextView
            android:id="@+id/fileCreationStrategy_useCustomBackendCipher"
            android:text="Use custom backend cipher"
            android:focusable="true"
            android:clickable="true"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

        <Spinner
            android:visibility="gone"
            android:id="@+id/fileCreationStrategy_StreamCiphersSpinner"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:background="@android:drawable/btn_dropdown"
            android:spinnerMode="dropdown" />

    </LinearLayout>

    <Button
        android:id="@+id/fileDirCreate_OkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>

```

`app/src/main/res/layout/create_link_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:text="Target path:"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />
    <EditText
        android:id="@+id/linkCreate_targetPath"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <RadioGroup
        android:id="@+id/linkCreate_type"
        android:orientation="horizontal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" >

        <RadioButton
            android:id="@+id/linkCreate_type_hard"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="hard link" />

        <RadioButton
            android:id="@+id/linkCreate_type_soft"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="symbolic link" />
    </RadioGroup>

    <Button
        android:id="@+id/linkCreate_OkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>

```

`app/src/main/res/layout/dircommander_popup_window.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="200dp"
    android:layout_height="wrap_content"
    android:background="@color/transparentCobaltBlue2" >

    <ListView
        android:id="@+id/dircommander_positions"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</LinearLayout>
```

`app/src/main/res/layout/dragitem.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>

<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal" >

    <TextView
        android:id="@+id/sortingAttributeLabel"
        android:layout_weight="6"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <CheckBox
        android:id="@+id/sortingAttributeSelectedCheckbox"
        android:focusable="false"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <CheckBox
        android:id="@+id/sortingAttributeReversedCheckbox"
        android:focusable="false"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

</LinearLayout>



```

`app/src/main/res/layout/empty.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

</LinearLayout>
```

`app/src/main/res/layout/extract_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <EditText
            android:id="@+id/extractDirectoryEditText"
            android:inputType="text"
            android:imeOptions="actionDone"
            android:layout_weight="8"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <ImageButton
            android:src="@android:drawable/ic_menu_gallery"
            android:id="@+id/extractDirectorySelectorButton"
            android:onClick="openDestinationFolderSelector"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>


    <TextView
        android:id="@+id/intermediateDirectoryPolicyTextView"
        android:text="Intermediate directory creation policy:"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <RadioGroup
        android:id="@+id/intermediateDirectoryPolicyRadioGroup"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <RadioButton
            android:text="@string/alwaysCreateSubdirectory"
            android:id="@+id/alwaysCreateSubdirectory"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <RadioButton
            android:text="@string/neverCreateSubdirectory"
            android:id="@+id/neverCreateSubdirectory"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <RadioButton
            android:text="@string/smartCreateSubdirectory"
            android:id="@+id/smartCreateSubdirectory"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:checked="true" />


    </RadioGroup>

    <Button
        android:id="@+id/extractOkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:onClick="extract_ok"
        android:text="OK"/>

</LinearLayout>

```

`app/src/main/res/layout/extract_results_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ListView
        android:id="@+id/extract_results_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

</LinearLayout>
```

`app/src/main/res/layout/extract_results_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/extract_results_srcArchive"
        android:textColor="#0061d6"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/extract_results_result"
        android:textColor="#008d69"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/favorites.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <android.support.v4.view.ViewPager
        android:id="@+id/favorites_viewpager"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>

</LinearLayout>
```

`app/src/main/res/layout/favorites_local.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:orientation="horizontal">

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="Path"
            android:textColor="#0061d6"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Edit"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Delete"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

    </LinearLayout>

    <ListView android:id="@+id/favorites_local_list"
        android:fastScrollEnabled="true"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="8" >
    </ListView>

    <Button
        android:text="Add local favorite"
        android:id="@+id/favorites_local_add_button"
        android:nextFocusUp="@id/favorites_local_list_item_edit"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

</LinearLayout>
```

`app/src/main/res/layout/favorites_local_list_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/favorites_local_list_item_path"
        android:textColor="#0061d6"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <ImageButton
        android:contentDescription="Edit item"
        android:id="@+id/favorites_local_list_item_edit"
        android:nextFocusRight="@id/favorites_local_list_item_delete"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_edit" />
    <ImageButton
        android:contentDescription="Delete item"
        android:id="@+id/favorites_local_list_item_delete"
        android:nextFocusLeft="@id/favorites_local_list_item_edit"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_delete"/>
</LinearLayout>
```

`app/src/main/res/layout/favorites_sftp.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
    No explicit header here,
    override getView in sftpFavoritesAdapter with a boolean (header/content)
    header contains: user, domain, port, addButton (for adding a favorite to that credentials)
    content contains: remote path
    (structure is not a matrix!)
    structure is: [header_1, content_11, content_12, ..., content_1m,
                   header_2, content_21, content_22, ..., content_2n,
                   ..................................................
                   header_t, content_t1, content_t2, ..., content_tp]
    -->

    <ListView android:id="@+id/favorites_sftp_list"
        android:fastScrollEnabled="true"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <TextView
        android:id="@+id/favorites_sftp_list_empty_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Please add sftp credentials from manager before adding favorite paths for them" />

</LinearLayout>
```

`app/src/main/res/layout/favorites_smb.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!--
    No explicit header here,
    override getView in smbFavoritesAdapter with a boolean (header/content)
    header contains: user, domain, port, addButton (for adding a favorite to that credentials)
    content contains: remote path
    (structure is not a matrix!)
    structure is: [header_1, content_11, content_12, ..., content_1m,
                   header_2, content_21, content_22, ..., content_2n,
                   ..................................................
                   header_t, content_t1, content_t2, ..., content_tp]
    -->

    <ListView android:id="@+id/favorites_smb_list"
        android:fastScrollEnabled="true"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />

    <TextView
        android:id="@+id/favorites_smb_list_empty_view"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Please add smb credentials from manager before adding favorite paths for them" />

</LinearLayout>
```

`app/src/main/res/layout/favorites_xfiles_remote.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1"
        android:orientation="horizontal">

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="4"
            android:text="Server"
            android:textColor="#0061d6"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="4"
            android:text="Path"
            android:textColor="#0061d6"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Edit"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Delete"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

    </LinearLayout>

    <ListView android:id="@+id/favorites_xre_list"
        android:fastScrollEnabled="true"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="8" >
    </ListView>

    <Button
        android:text="Add XFiles remote favorite"
        android:id="@+id/favorites_xre_add_button"
        android:nextFocusUp="@id/favorites_xre_list_item_edit"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" />

</LinearLayout>
```

`app/src/main/res/layout/favorites_xre_list_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/favorites_xre_list_item_server"
        android:textColor="#0061d6"
        android:layout_weight="4"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/favorites_xre_list_item_path"
        android:textColor="#0061d6"
        android:layout_weight="4"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <ImageButton
        android:contentDescription="Edit item"
        android:id="@+id/favorites_xre_list_item_edit"
        android:nextFocusRight="@id/favorites_xre_list_item_delete"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_edit" />
    <ImageButton
        android:contentDescription="Delete item"
        android:id="@+id/favorites_xre_list_item_delete"
        android:nextFocusLeft="@id/favorites_xre_list_item_edit"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_delete"/>
</LinearLayout>
```

`app/src/main/res/layout/filter_selection_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <EditText
        android:id="@+id/singleFilenameEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <CheckedTextView
        android:checked="true"
        android:id="@+id/ignoreCaseCtv"
        android:text="Ignore case"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

    <Button
        android:id="@+id/singleFilenameOkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>

```

`app/src/main/res/layout/find_results.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent" >

</LinearLayout>
```

`app/src/main/res/layout/gridview_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_weight="1"
    android:layout_width="match_parent"
    android:layout_height="0dp">

    <GridView
        android:id="@+id/mainBrowserGridView"
        android:numColumns="auto_fit"
        android:gravity="center"
        android:columnWidth="100dp"
        android:stretchMode="columnWidth"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        />
    <!--android:fastScrollEnabled="true"-->

    <!--
    Set dynamically on multi select mode switch
        android:paddingBottom="150dp"
        android:clipToPadding="false"
        android:scrollbarStyle="outsideOverlay"
    -->

</LinearLayout>
```

`app/src/main/res/layout/hash_labels_legend.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <TextView
        android:text="Non-cryptographic hash function"
        android:textColor="@android:color/holo_purple"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:text="Broken cryptographic hash function"
        android:textColor="@android:color/holo_red_dark"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:text="Cryptographic hash function"
        android:textColor="@android:color/holo_orange_light"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:text="Cryptographic hash function with length-extension resistance"
        android:textColor="@android:color/holo_green_light"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/hashview_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@drawable/hashview_window_background" >

    <TextView
        android:id="@+id/hashview_timeout_alert_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentStart="true"
        android:layout_alignParentTop="true"
        android:text="Will disappear shortly, click to keep" />

    <LinearLayout
        android:id="@+id/hvLayout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:layout_below="@id/hashview_timeout_alert_textview"
        android:orientation="vertical" />

    <TextView
        android:id="@+id/hvTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentStart="true"
        android:layout_below="@id/hvLayout" />

    <Button
        android:id="@+id/hashview_close_button"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:layout_below="@+id/hvTextView"
        android:text="Close" />

</RelativeLayout>
```

`app/src/main/res/layout/hashview_popup_window.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="@drawable/hashview_window_background" >

    <TextView
        android:id="@+id/hashview_timeout_alert_textview"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="Will disappear shortly, click to keep" />

    <LinearLayout
        android:id="@+id/hvLayout"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:orientation="vertical" />

    <TextView
        android:id="@+id/hvTextView"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

    <CheckedTextView
        android:checked="false"
        android:id="@+id/hvShowFull"
        android:text="Show full"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

    <Button
        android:id="@+id/hashview_close_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Close" />

</LinearLayout>
```

`app/src/main/res/layout/horizontal_operational_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:gravity="bottom"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

<!-- Contains all possible buttons, including Home and Back ones (because in horizontal mode
 there is plenty of available space)-->

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:nextFocusLeft="@id/quickFindButton"
        android:src="@drawable/xfiles_system_back"
        android:id="@+id/androidGoBackButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:id="@+id/upOneLevelButton"
        android:src="@drawable/xf_up_dir"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_cut"
        android:id="@+id/cutButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_copy"
        android:id="@+id/copyButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_paste"
        android:id="@+id/pasteButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_arrow_left"
        android:id="@+id/goBackButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_system_home"
        android:id="@+id/androidGoHomeButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_arrow_right"
        android:id="@+id/goAheadButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_new_file"
        android:id="@+id/newFileButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_recycle_bin"
        android:id="@+id/deleteButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_archive"
        android:id="@+id/compressButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_share"
        android:id="@+id/shareButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

</LinearLayout>

```

`app/src/main/res/layout/item_image.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:background="?android:attr/selectableItemBackground"
    android:clickable="true"
    android:focusable="true"
    android:layout_height="match_parent">

    <ImageView
        android:id="@+id/imageView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:src="@drawable/media_gallery_placeholder"
        android:layout_margin="1dp"
        android:scaleType="centerCrop"/>
</RelativeLayout>
```

`app/src/main/res/layout/item_image_horizontal.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical">

    <ImageView
        android:id="@+id/iv"
        android:layout_width="70dp"
        android:layout_height="70dp"
        android:scaleType="centerCrop"/>
</LinearLayout>
```

`app/src/main/res/layout/jsimpleimageloader_main.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity">

    <android.support.v7.widget.RecyclerView
        android:id="@+id/recycler"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        tools:itemCount="5"
        tools:listitem="@layout/recycler_item" />

</LinearLayout>
```

`app/src/main/res/layout/listview_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_weight="1"
    android:layout_width="match_parent"
    android:layout_height="0dp">

    <ListView
        android:id="@+id/mainBrowserListView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        />
    <!--android:fastScrollEnabled="true"-->

    <!--
    Set dynamically on multi select mode switch
        android:paddingBottom="150dp"
        android:clipToPadding="false"
        android:scrollbarStyle="outsideOverlay"
    -->

</LinearLayout>
```

`app/src/main/res/layout/multiselect_buttons_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <Button
        android:onClick="multiSelectAction"
        android:id="@+id/itemsSelectAll"
        android:text="@string/select_all"
        android:textSize="10sp"
        android:drawableTop="@android:drawable/checkbox_on_background"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:maxLines="2" />

    <Button
        android:onClick="multiSelectAction"
        android:id="@+id/itemsSelectNone"
        android:text="@string/select_none"
        android:textSize="10sp"
        android:drawableTop="@android:drawable/checkbox_off_background"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:maxLines="2" />

    <Button
        android:onClick="multiSelectAction"
        android:id="@+id/itemsInvertSelection"
        android:text="@string/invert_selection"
        android:textSize="10sp"
        android:drawableTop="@android:drawable/checkbox_on_background"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:maxLines="2" />

    <Button
        android:onClick="multiSelectAction"
        android:id="@+id/itemsFilterSelection"
        android:text="@string/filter_selection"
        android:textSize="10sp"
        android:drawableTop="@android:drawable/checkbox_on_background"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:maxLines="2" />

    <Button
        android:onClick="multiSelectAction"
        android:id="@+id/itemsFilterDeselection"
        android:text="@string/filter_deselection"
        android:textSize="10sp"
        android:drawableTop="@android:drawable/checkbox_off_background"
        android:layout_width="wrap_content"
        android:layout_height="match_parent"
        android:maxLines="2" />

</LinearLayout>
```

`app/src/main/res/layout/open_as_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <ListView
        android:id="@+id/openAsListView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:text="Cancel"
        android:id="@+id/openAsCancelButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>

```

`app/src/main/res/layout/open_as_dialog_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal">

        <ImageView
            android:id="@+id/openAsTypeImage"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <TextView
            android:id="@+id/openAsTypeName"
            android:layout_weight="3"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
</LinearLayout>
```

`app/src/main/res/layout/overriding_home_buttons_operational_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:gravity="bottom"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:nextFocusLeft="@id/quickFindButton"
        android:src="@drawable/xfiles_system_back"
        android:id="@+id/androidGoBackButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:id="@+id/upOneLevelButton"
        android:src="@drawable/xf_up_dir"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_paste"
        android:id="@+id/pasteButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_arrow_left"
        android:id="@+id/goBackButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_system_home"
        android:id="@+id/androidGoHomeButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_arrow_right"
        android:id="@+id/goAheadButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_new_file"
        android:id="@+id/newFileButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_archive"
        android:id="@+id/compressButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_share"
        android:id="@+id/shareButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/pager_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <com.davemorrissey.labs.subscaleview.SubsamplingScaleImageView
        android:id="@+id/iv"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <TextView
        android:id="@+id/pager_item_filename"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:layout_alignParentTop="true"
        android:gravity="center" />
</RelativeLayout>
```

`app/src/main/res/layout/pasteable_edittext.xml`:

```xml
<merge xmlns:android="http://schemas.android.com/apk/res/android">
    <EditText
        android:id="@+id/pasteable_edittext_et"
        android:layout_width="0dp"
        android:layout_weight="8"
        android:layout_height="match_parent"
        android:inputType="textUri"
        android:imeOptions="actionDone"
        android:layout_toStartOf="@id/pasteable_edittext_ib"/>
    <ImageButton
        android:src="@drawable/xfiles_paste"
        android:id="@+id/pasteable_edittext_ib"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="match_parent" />
</merge>
```

`app/src/main/res/layout/properties_aggragates_dialog.xml`:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/propertiesAggregatesLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <!-- aggregate folder attributes base layout -->
    <View
        android:layout_width="match_parent"
        android:layout_height="1dp"
        android:background="@android:color/darker_gray"/>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Children files:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesChildrenFilesTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Children folders:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesChildrenFoldersTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Total files:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesTotalFilesTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Total folders:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesTotalFoldersTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Total size:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesTotalSizeTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/properties_base_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/propertiesSingleItemLayout"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <!-- single item stats base layout -->
    
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="File name:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesFileNameTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="File type:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesFileTypeTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="File size:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesFileSizeTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Created:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesFileDateCreatedTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Last modified:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesFileDateLastModifiedTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Last access:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesFileDateLastAccessTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Permissions:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesPermissionsTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Owner:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesOwnerTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">
        <TextView
            android:text="Group:"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
        <TextView
            android:id="@+id/propertiesGroupTextView"
            android:layout_width="wrap_content"
            android:layout_height="match_parent" />
    </LinearLayout>

</LinearLayout>

```

`app/src/main/res/layout/properties_file_dialog.xml`:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="vertical">

    <include layout="@layout/properties_base_dialog" />

    <include layout="@layout/properties_aggragates_dialog" />

    <ProgressBar
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:id="@+id/progressCircle"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:text="Close"
        android:id="@+id/propertiesDismissButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/quickfind_edittext_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <EditText
        android:id="@+id/quickFindEditText"
        android:nextFocusDown="@id/quickFindIgnoreCase"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="text" />

    <CheckedTextView
        android:checked="false"
        android:id="@+id/quickFindIgnoreCase"
        android:nextFocusUp="@id/quickFindEditText"
        android:text="Ignore case"
        android:focusable="true"
        android:clickable="true"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

</LinearLayout>
```

`app/src/main/res/layout/recycler_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal"
    android:padding="5dp">

    <ImageView
        android:id="@+id/image_view"
        android:layout_width="52dp"
        android:layout_height="52dp"
        android:background="@color/grey"
        tools:ignore="ContentDescription" />

    <LinearLayout
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_gravity="center_vertical"
        android:layout_weight="1"
        android:gravity="center_vertical"
        android:orientation="vertical"
        android:paddingStart="10dp"
        android:paddingEnd="0dp">

        <TextView
            android:id="@+id/title_view"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="start|center_vertical"
            android:singleLine="true"
            android:textColor="?android:textColorPrimary"
            android:textSize="17sp"
            android:textStyle="bold"
            tools:text="Title" />

        <TextView
            android:id="@+id/subtitle_view"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="start|center_vertical"
            android:ellipsize="marquee"
            android:marqueeRepeatLimit="marquee_forever"
            android:scrollHorizontally="true"
            android:singleLine="true"
            android:textColor="?android:textColorSecondary"
            android:textSize="15sp"
            tools:text="Subtitle" />

    </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/remote_rh_server_management_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:id="@+id/remote_rh_server_management_dialog"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:focusable="true"
        android:focusableInTouchMode="true"
        android:ems="10"
        android:text="@string/start_rhss_description" />

    <!--toggle hotspot and wifi icons are in WifiButtonsLayout-->
    <LinearLayout
        android:orientation="vertical"
        android:id="@+id/targetWifiButtonsLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <!--temporary layout for testing HTTP/FTP file servers, once ready this dialog will contain a ViewFlipper, as well as the widget-->
    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <Button
            android:id="@+id/ftpServerButton"
            android:text="@string/ftp_server"
            android:textSize="12sp"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="wrap_content" />

        <Button
            android:id="@+id/httpServerButton"
            android:text="@string/http_server"
            android:textSize="12sp"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="wrap_content" />

    </LinearLayout>

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:text="Exposed HTTP/FTP base path:"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <EditText
            android:id="@+id/ftpHttpRootPath"
            android:inputType="text"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

    </LinearLayout>

    <include layout="@layout/xre_rhss_button_and_active_ips" />
</LinearLayout>
```

`app/src/main/res/layout/rhss_server_sessions_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/rhss_session_endpoint_IP_and_port"
        android:textColor="#0061d6"
        android:layout_width="0dp"
        android:layout_weight="6"
        android:layout_height="wrap_content"/>

    <!-- button close disabled until close functionality is implemented in rh server -->
    <ImageButton
        android:contentDescription="Show shared session key"
        android:id="@+id/rhss_session_endpoint_info"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_info_details" />
    <ImageButton
        android:clickable="false"
        android:contentDescription="Close session"
        android:id="@+id/rhss_session_disconnect_endpoint"
        android:layout_width="0dp"
        android:layout_weight="1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_delete"/>
</LinearLayout>
```

`app/src/main/res/layout/ribbon_one.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ProgressBar
        style="@style/ProgressBarStyle"
        android:id="@+id/pbInner"
        android:layout_weight="1"
        android:layout_width="match_parent"
        android:layout_height="0dp" />

    <LinearLayout
        android:background="@color/colorPrimary"
        android:layout_weight="1"
        android:layout_width="match_parent"
        android:layout_height="0dp">

        <TextView
            android:textColor="@color/green"
            android:id="@+id/pbSpeed"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <TextView
            android:textColor="@color/white"
            android:id="@+id/pbDataAmount"
            android:gravity="end"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/ribbon_two.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <ProgressBar
        style="@style/ProgressBarStyle"
        android:id="@+id/pbOuter"
        android:layout_weight="1"
        android:layout_width="match_parent"
        android:layout_height="0dp" />

    <ProgressBar
        style="@style/ProgressBarStyle"
        android:id="@+id/pbInner"
        android:layout_weight="1"
        android:layout_width="match_parent"
        android:layout_height="0dp" />

    <LinearLayout
        android:background="@color/colorPrimary"
        android:layout_weight="1"
        android:layout_width="match_parent"
        android:layout_height="0dp">

        <TextView
            android:textColor="@color/green"
            android:id="@+id/pbSpeed"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <TextView
            android:textColor="@color/white"
            android:id="@+id/pbDataAmount"
            android:gravity="end"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />
    </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/sftp_dialog_insert_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="fill_parent"
    android:layout_height="fill_parent" >

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceMedium"
        android:text="Username:" />

    <EditText
        android:inputType="text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/insertUsernameEditText" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceMedium"
        android:text="Domain" />

    <EditText
        android:inputType="text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/insertDomainEditText" />

    <TextView
        android:id="@+id/insertHostLabel"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceMedium"
        android:text="Host" />

    <EditText
        android:inputType="text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/insertHostEditText" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceMedium"
        android:text="Port" />

    <!-- ssh_default_port is overriden in InsertEditDialog with 445 for SMB -->
    <EditText
        android:inputType="number"
        android:text="@string/ssh_default_port"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:id="@+id/insertPortEditText" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceMedium"
        android:text="Password" />

    <EditText
        android:inputType="textPassword"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:textAppearance="?android:attr/textAppearanceMedium"
        android:id="@+id/insertPasswordEditText" />

    <Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"
        android:id="@+id/insertItemOkButton" />
</LinearLayout>

```

`app/src/main/res/layout/sftp_id_list_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/sftp_id_listitem_filename"
        android:textColor="#0061d6"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/sftp_id_listitem_type"
        android:textColor="#775eff"
        android:layout_weight=".15"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView android:id="@+id/sftp_id_listitem_hash"
        android:textColor="#008d69"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <ImageButton
        android:contentDescription="Show item"
        android:id="@+id/sftp_id_listitem_show"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_info_details" />
    <ImageButton
        android:contentDescription="Delete item"
        android:id="@+id/sftp_id_listitem_delete"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_delete"/>
</LinearLayout>
```

`app/src/main/res/layout/sftp_list_header_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/sftp_listitem_user"
        android:textColor="#0061d6"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/sftp_listitem_domain"
        android:textColor="#008d69"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView android:id="@+id/sftp_listitem_port"
        android:textColor="#557733"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <ImageButton
        android:contentDescription="Add favorite path"
        android:id="@+id/sftp_add_favorite_button"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_add" />
</LinearLayout>
```

`app/src/main/res/layout/sftp_list_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/sftp_listitem_user"
        android:textColor="#0061d6"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/sftp_listitem_domain"
        android:textColor="#008d69"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView android:id="@+id/sftp_listitem_port"
        android:textColor="#557733"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <ImageButton
        android:contentDescription="Edit item"
        android:id="@+id/passitem_edit"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_edit" />
    <ImageButton
        android:contentDescription="Delete item"
        android:id="@+id/passitem_delete"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_delete"/>
</LinearLayout>
```

`app/src/main/res/layout/sftp_vault_list_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="User"
            android:textColor="#0061d6"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="Domain"
            android:textColor="#008d69"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".15"
            android:text="Port"
            android:textColor="#557733"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Edit"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Delete"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

    </LinearLayout>

    <ListView android:id="@+id/sftp_passitem_List"
        android:fastScrollEnabled="true"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" >
    </ListView>

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="Filename"
            android:textColor="#0061d6"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="Type"
            android:textColor="#775eff"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="Hash"
            android:textColor="#008d69"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Show"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Delete"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

    </LinearLayout>

    <ListView android:id="@+id/sftp_ids_List"
        android:fastScrollEnabled="true"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1">
    </ListView>

    <LinearLayout
        style="?android:attr/buttonBarStyle"
        android:orientation="horizontal"
        android:id="@+id/masterButtonsLayout"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <Button
            style="?android:attr/buttonBarButtonStyle"
            android:id="@+id/sftpAddNewIdentityBtn"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:text="Add identity"
            android:layout_height="wrap_content" />
        <Button
            style="?android:attr/buttonBarButtonStyle"
            android:id="@+id/sftpGenNewIdentityBtn"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:text="Generate identity"
            android:layout_height="wrap_content" />
        <Button
            style="?android:attr/buttonBarButtonStyle"
            android:id="@+id/sftpAddNewCredsBtn"
            android:layout_width="0dp"
            android:layout_weight="1"
            android:text="Add credentials"
            android:layout_height="wrap_content" />

    </LinearLayout>

</LinearLayout>

```

`app/src/main/res/layout/single_filename_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <EditText
        android:id="@+id/singleFilenameEditText"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:id="@+id/singleFilenameOkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>

```

`app/src/main/res/layout/smb_list_header_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/smb_listitem_user"
        android:textColor="#0061d6"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/smb_listitem_domain"
        android:textColor="#008d69"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView android:id="@+id/smb_listitem_host"
        android:textColor="#00afec"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView android:id="@+id/smb_listitem_port"
        android:textColor="#557733"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <ImageButton
        android:contentDescription="Add favorite path"
        android:id="@+id/smb_add_favorite_button"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_add" />
</LinearLayout>
```

`app/src/main/res/layout/smb_list_item.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    android:paddingTop="4dip"
    android:paddingBottom="6dip"
    android:layout_width="match_parent"
    android:layout_height="wrap_content"
    android:orientation="horizontal">

    <TextView android:id="@+id/smb_listitem_user"
        android:textColor="#0061d6"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content"/>
    <TextView android:id="@+id/smb_listitem_domain"
        android:textColor="#008d69"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView android:id="@+id/smb_listitem_host"
        android:textColor="#00afec"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView android:id="@+id/smb_listitem_port"
        android:textColor="#557733"
        android:layout_weight=".25"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <ImageButton
        android:contentDescription="Edit item"
        android:id="@+id/passitem_edit"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_edit" />
    <ImageButton
        android:contentDescription="Delete item"
        android:id="@+id/passitem_delete"
        android:layout_width="0dp"
        android:layout_weight=".1"
        android:layout_height="wrap_content"
        android:src="@android:drawable/ic_menu_delete"/>
</LinearLayout>
```

`app/src/main/res/layout/smb_vault_list_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:paddingBottom="@dimen/activity_vertical_margin"
    android:paddingLeft="@dimen/activity_horizontal_margin"
    android:paddingRight="@dimen/activity_horizontal_margin"
    android:paddingTop="@dimen/activity_vertical_margin"
    tools:context="it.pgp.xfiles.smbclient.SmbVaultActivity" >

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="User"
            android:textColor="#0061d6"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".15"
            android:text="Domain"
            android:textColor="#008d69"
            android:textSize="12sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".25"
            android:text="Host"
            android:textColor="#00afec"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".15"
            android:text="Port"
            android:textColor="#557733"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Edit"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

        <TextView
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight=".1"
            android:text="Delete"
            android:textColor="#ff4d00"
            android:textSize="15sp"
            android:gravity="center_horizontal" />

    </LinearLayout>

    <ListView android:id="@+id/smb_passitem_List"
        android:fastScrollEnabled="true"
        android:layout_width="match_parent"
        android:layout_height="0dp"
        android:layout_weight="1" >
    </ListView>

    <Button
        style="?android:attr/buttonBarButtonStyle"
        android:id="@+id/smbAddNewCredsBtn"
        android:layout_width="match_parent"
        android:text="Add credentials"
        android:layout_height="wrap_content" />

</LinearLayout>

```

`app/src/main/res/layout/sorting_dialog_header_view.xml`:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">
    <TextView
        android:id="@+id/sortingAttributeHeaderLabel"
        android:layout_weight="6"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView
        android:id="@+id/sortingReversedHeaderLabel"
        android:text="Sel"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />
    <TextView
        android:id="@+id/sortingSelectedHeaderLabel"
        android:text="Rev"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/ssh_already_in_known_hosts_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Different SSH Host Key already in known host"
        android:textAppearance="@android:style/TextAppearance.DeviceDefault.Medium" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Currently stored hostkey information:"
        android:textAppearance="@android:style/TextAppearance.DeviceDefault.Medium" />

    <TextView
        android:id="@+id/storedHostKeyFingerprintTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="New hostkey information:"
        android:textAppearance="@android:style/TextAppearance.DeviceDefault.Medium" />

    <TextView
        android:id="@+id/currentHostKeyFingerprintTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <Button
            android:id="@+id/hostKeyAcceptOverwriteButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Accept new\n(overwrite old)" />

        <!--temporarily disabled-->
        <Button
            android:enabled="false"
            android:id="@+id/hostKeyTemporarilyAcceptNotOverwriteButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Accept only\nfor this session" />

        <Button
            android:id="@+id/hostKeyKeepOldAndDisconnectButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Keep old\n(disconnect)" />
    </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/ssh_key_info_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Key type"
        android:textAppearance="@android:style/TextAppearance.DeviceDefault.Medium" />

    <TextView
        android:id="@+id/sshKeyInfoTypeTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Fingerprint"
        android:textAppearance="@android:style/TextAppearance.DeviceDefault.Medium" />

    <TextView
        android:id="@+id/sshKeyInfoFingerprintTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:text="Locate"
        android:id="@+id/sshKeyInfoLocateButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/layout/ssh_keygen_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent" >

    <TextView
        android:text="Keypair name"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <EditText
        android:id="@+id/sshKeygenNameEditText"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:inputType="text"
        android:imeOptions="actionDone" />

    <RadioGroup
        android:id="@+id/sshKeygenTypeRadioGroup"
        android:orientation="horizontal"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" >

        <RadioButton
            android:id="@+id/rsaKeyTypeRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="RSA"
            android:checked="true"/>

        <RadioButton
            android:id="@+id/ed25519KeyTypeRadioButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="ed25519" />
    </RadioGroup>

    <LinearLayout
        android:id="@+id/rsaKeygenLayout"
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:text="RSA bits"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <HorizontalScrollView
            android:layout_width="match_parent"
            android:layout_height="wrap_content">
            <RadioGroup
                android:id="@+id/rsaBitsRadioGroup"
                android:orientation="horizontal"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content" >

                <RadioButton
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="2048" />

                <RadioButton
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="3072" />

                <RadioButton
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="4096" />

                <RadioButton
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="6144" />

                <RadioButton
                    android:layout_width="wrap_content"
                    android:layout_height="wrap_content"
                    android:text="8192" />
            </RadioGroup>

        </HorizontalScrollView>

        <EditText
            android:id="@+id/sshKeygenBitsEditText"
            android:inputType="number"
            android:text="2048"
            android:imeOptions="actionDone"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

    </LinearLayout>

    <TextView
        android:id="@+id/sshKeygenWaitTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <ProgressBar
        android:visibility="gone"
        android:id="@+id/sshKeygenWaitProgressBar"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:id="@+id/sshKeygenOkButton"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>
```

`app/src/main/res/layout/ssh_not_in_known_hosts_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="SSH Host Key not in known host"
        android:textAppearance="@android:style/TextAppearance.DeviceDefault.Medium" />

    <TextView
        android:id="@+id/hostKeyFingerprintTextView"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal">

        <Button
            android:id="@+id/hostKeyAcceptButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Accept" />

        <!--temporarily disabled-->
        <Button
            android:enabled="false"
            android:id="@+id/hostKeyTemporarilyAcceptButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Accept only\nfor this session" />

        <Button
            android:id="@+id/hostKeyDiscardButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Discard" />
    </LinearLayout>

</LinearLayout>
```

`app/src/main/res/layout/standard_operational_layout.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="horizontal"
    android:gravity="bottom"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:nextFocusLeft="@id/quickFindButton"
        android:id="@+id/upOneLevelButton"
        android:src="@drawable/xf_up_dir"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_cut"
        android:id="@+id/cutButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_copy"
        android:id="@+id/copyButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_paste"
        android:id="@+id/pasteButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_arrow_left"
        android:id="@+id/goBackButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_arrow_right"
        android:id="@+id/goAheadButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_new_file"
        android:id="@+id/newFileButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_recycle_bin"
        android:id="@+id/deleteButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xfiles_archive"
        android:id="@+id/compressButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

    <ImageButton
        android:onClick="operationBarOnClick"
        android:scaleType="fitCenter"
        android:adjustViewBounds="true"
        android:background="@null"
        android:src="@drawable/xf_share"
        android:id="@+id/shareButton"
        android:layout_weight="1"
        android:layout_width="0dp"
        android:layout_height="wrap_content" />

</LinearLayout>

```

`app/src/main/res/layout/update_check_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <TextView
        android:id="@+id/updateCheckMessage"
        android:gravity="center"
        android:textSize="18sp"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:text="Current version: "
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <TextView
            android:id="@+id/updateCheckCurrentVersion"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <TextView
            android:text="Latest version: "
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <TextView
            android:id="@+id/updateCheckLatestVersion"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <Button
            android:enabled="false"
            android:id="@+id/updateCheckOkButton"
            android:text="Download"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <Button
            android:id="@+id/updateCheckCancelButton"
            android:text="Cancel"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>


</LinearLayout>
```

`app/src/main/res/layout/xfiles_remote_sessions_management.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical" android:layout_width="match_parent"
    android:layout_height="match_parent">

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_weight="1"
        android:layout_height="0dp">

        <TextView
            android:text="Server sessions"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <ListView
            android:id="@+id/currentlyOpenServerSessions"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
    </LinearLayout>

    <LinearLayout
        android:orientation="vertical"
        android:layout_width="match_parent"
        android:layout_weight="1"
        android:layout_height="0dp">

        <TextView
            android:text="Client sessions"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />

        <ListView
            android:id="@+id/currentlyOpenClientSessions"
            android:layout_width="match_parent"
            android:layout_height="wrap_content" />
    </LinearLayout>


</LinearLayout>
```

`app/src/main/res/layout/xre_path_dialog.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical">

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Server"
        />

    <EditText
        android:id="@+id/xre_server_edittext"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="Path"
        />

    <EditText
        android:id="@+id/xre_path_edittext"
        android:inputType="text"
        android:imeOptions="actionDone"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <Button
        android:id="@+id/xre_ok_button"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="OK"/>

</LinearLayout>

```

`app/src/main/res/layout/xre_rhss_button_and_active_ips.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<ScrollView xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical">

            <LinearLayout
                android:orientation="horizontal"
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <ImageButton
                    android:id="@+id/rhss_toggle_rhss_button"
                    android:nextFocusDown="@id/rhssAnnounceOptionCtv"
                    android:src="@drawable/xf_share"
                    android:layout_weight="4"
                    android:layout_width="0dp"
                    android:layout_height="match_parent" />

                <ImageButton
                    android:id="@+id/rhss_show_xre_connections"
                    android:nextFocusDown="@id/rhssAnnounceOptionCtv"
                    android:src="@android:drawable/ic_dialog_info"
                    android:layout_weight="1"
                    android:layout_width="0dp"
                    android:layout_height="match_parent" />

            </LinearLayout>

            <CheckedTextView
                android:checked="true"
                android:id="@+id/rhssAnnounceOptionCtv"
                android:nextFocusDown="@id/setXreHomePathToCurrent"
                android:text="@string/send_xre_announce"
                android:focusable="true"
                android:clickable="true"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:checkMark="?android:attr/listChoiceIndicatorMultiple" />

            <LinearLayout
                android:orientation="vertical"
                android:layout_width="match_parent"
                android:layout_height="wrap_content">

                <TextView
                    android:text="XRE home path (leave empty for OS default):"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content" />

                <LinearLayout
                    android:orientation="horizontal"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <EditText
                        android:id="@+id/xreHomePath"
                        android:inputType="text"
                        android:layout_weight="8"
                        android:layout_width="0dp"
                        android:layout_height="match_parent" />

                    <ImageButton
                        android:id="@+id/setXreHomePathToCurrent"
                        android:nextFocusDown="@id/setXreAnnouncedPathToCurrent"
                        android:nextFocusUp="@id/rhssAnnounceOptionCtv"
                        android:src="@drawable/xf_dir_blu"
                        android:background="?android:attr/selectableItemBackground"
                        android:layout_weight="1"
                        android:layout_width="0dp"
                        android:layout_height="match_parent" />
                </LinearLayout>

                <TextView
                    android:text="XRE announced path:"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content" />

                <LinearLayout
                    android:orientation="horizontal"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <EditText
                        android:id="@+id/xreAnnouncedPath"
                        android:inputType="text"
                        android:layout_weight="8"
                        android:layout_width="0dp"
                        android:layout_height="match_parent" />

                    <ImageButton
                        android:id="@+id/setXreAnnouncedPathToCurrent"
                        android:nextFocusDown="@id/setXreExposedPathToCurrent"
                        android:nextFocusUp="@id/setXreHomePathToCurrent"
                        android:src="@drawable/xf_dir_blu"
                        android:background="?android:attr/selectableItemBackground"
                        android:layout_weight="1"
                        android:layout_width="0dp"
                        android:layout_height="match_parent" />
                </LinearLayout>

                <TextView
                    android:text="XRE exposed path:"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content" />

                <LinearLayout
                    android:orientation="horizontal"
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content">

                    <EditText
                        android:id="@+id/xreExposedPath"
                        android:inputType="text"
                        android:layout_weight="8"
                        android:layout_width="0dp"
                        android:layout_height="match_parent" />

                    <ImageButton
                        android:id="@+id/setXreExposedPathToCurrent"
                        android:nextFocusUp="@id/setXreAnnouncedPathToCurrent"
                        android:src="@drawable/xf_dir_blu"
                        android:background="?android:attr/selectableItemBackground"
                        android:layout_weight="1"
                        android:layout_width="0dp"
                        android:layout_height="match_parent" />
                </LinearLayout>

            </LinearLayout>

            <TextView
                android:text="@string/active_ip_addresses"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />

            <TextView
                android:id="@+id/rhssIPAddresses"
                android:layout_width="match_parent"
                android:layout_height="wrap_content" />

        </LinearLayout>

    </LinearLayout>

</ScrollView>
```

`app/src/main/res/layout/xre_rhss_widget.xml`:

```xml
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:orientation="vertical"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="#09C"
    android:padding="@dimen/widget_margin">

    <!--checkboxes are not inflatable in widgets, cannot use common layout with disabled visibility-->
    <!--<include layout="@layout/xre_rhss_button_and_active_ips" />-->

    <!-- In widget mode, XRE announce is enabled by default -->

    <LinearLayout
        android:orientation="horizontal"
        android:layout_width="match_parent"
        android:layout_height="wrap_content">

        <ImageButton
            android:id="@+id/rhss_toggle_rhss_button"
            android:src="@drawable/xf_share"
            android:layout_weight="4"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

        <ImageButton
            android:id="@+id/rhss_show_xre_connections"
            android:src="@android:drawable/ic_dialog_info"
            android:layout_weight="1"
            android:layout_width="0dp"
            android:layout_height="match_parent" />

    </LinearLayout>

    <TextView
        android:text="@string/active_ip_addresses"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

    <TextView
        android:id="@+id/rhssIPAddresses"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" />

</LinearLayout>
```

`app/src/main/res/menu/menu_2ndlevel_share.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemShare"
        android:icon="@drawable/xf_share"
        android:title="Share to another app" />

    <item android:id="@+id/itemXreShareUnattended"
        android:icon="@drawable/xf_share"
        android:title="XRE Share (unattended)" />

    <item android:id="@+id/itemHttpUpload"
        android:icon="@drawable/xf_share"
        android:title="HTTP upload" />

</menu>

```

`app/src/main/res/menu/menu_2ndlevel_share_local_folder.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemShareOverHTTP"
        android:icon="@drawable/xf_share"
        android:title="Share over HTTP" />

    <item android:id="@+id/itemShareOverFTP"
        android:icon="@drawable/xf_share"
        android:title="Share over FTP" />

    <item android:id="@+id/itemShareOverXRE"
        android:icon="@drawable/xf_share"
        android:title="Share over XRE" />

</menu>

```

`app/src/main/res/menu/menu_browserview.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

        <item android:id="@+id/listBrowserViewMode"
            android:title="List view" />
        <item android:id="@+id/gridBrowserViewMode"
            android:title="Grid view" />
</menu>
```

`app/src/main/res/menu/menu_checkbox.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

        <!--<item android:id="@+id/itemsEnableMultiSelectMode"-->
            <!--android:title="Enable multi-select" />-->

        <item android:id="@+id/itemsSelectAll"
            android:icon="@android:drawable/checkbox_on_background"
            android:title="Select all" />

        <item android:id="@+id/itemsSelectNone"
            android:icon="@android:drawable/checkbox_off_background"
            android:title="Select none" />

        <item android:id="@+id/itemsInvertSelection"
            android:title="Invert selection" />

        <item android:id="@+id/itemsFilterSelection"
            android:title="Filter selection" />

        <item android:id="@+id/itemsFilterDeselection"
            android:title="Filter deselection" />
</menu>
```

`app/src/main/res/menu/menu_checksum.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/checksumCopyHashToClipboard"
        android:title="Copy hash" />

    <item android:id="@+id/checksumCopyFullInfoToClipboard"
        android:title="Copy hash and filename" />
</menu>
```

`app/src/main/res/menu/menu_credentials_favorites.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:id="@+id/openSftpCredManager"
        android:title="SFTP Credentials Manager" />
    <item android:id="@+id/openSmbCredManager"
        android:title="SMB Credentials Manager" />
    <item android:id="@+id/openFavsManager"
        android:title="Favorites manager" />
    <item android:id="@+id/openRamdiskManager"
        android:title="Ramdisk manager" />
    <item android:id="@+id/openPermissionActivity"
        android:title="Permission management" />
    <item android:id="@+id/openAboutDialog"
        android:title="About XFiles" />
</menu>
```

`app/src/main/res/menu/menu_fast_changedir.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/localFolder"
        android:title="Local directory" />

    <item android:id="@+id/localArchive"
        android:title="Local archive" />

    <item android:id="@+id/sftpRemoteFolder"
        android:title="SFTP directory" />

    <item android:id="@+id/xfilesRemoteFolder"
        android:title="XFiles remote directory" />

    <item android:id="@+id/smbRemoteFolder"
        android:title="SMB directory" />

    <item android:id="@+id/httpUrlDownload"
        android:title="Download URL" />

</menu>
```

`app/src/main/res/menu/menu_find.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/findItemLocate"
        android:title="Locate" />

    <item android:id="@+id/findItemProperties"
        android:title="Properties" />

</menu>
```

`app/src/main/res/menu/menu_find_multi.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- TODO for when multi-selection in FindResultsAdapter will be available -->
    <!--expected commands: copy/move, compress, properties -->
</menu>
```

`app/src/main/res/menu/menu_multi.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemsCopy"
        android:icon="@drawable/xf_copy"
        android:title="Copy" />

    <item android:id="@+id/itemsMove"
        android:icon="@drawable/xfiles_cut"
        android:title="Move" />

    <item android:id="@+id/itemsCompress"
        android:icon="@drawable/xfiles_archive"
        android:title="Compress" />

    <item android:id="@+id/itemsExtract"
        android:icon="@drawable/xfiles_extract"
        android:title="Extract" />

    <item android:id="@+id/itemsTest"
        android:icon="@drawable/xfiles_test"
        android:title="Test" />

    <item android:id="@+id/itemsDelete"
        android:icon="@drawable/xf_recycle_bin"
        android:title="Delete" />

    <item android:id="@+id/itemsRename"
        android:icon="@android:drawable/ic_menu_edit"
        android:title="Bulk Rename" />

    <item android:id="@+id/itemsFind"
        android:icon="@drawable/xfiles_find"
        android:title="Find in items" />

    <item android:id="@+id/itemsChecksum"
        android:icon="@drawable/xfiles_root_off"
        android:title="Checksum" />

    <item android:id="@+id/itemsShare"
        android:icon="@drawable/xf_share"
        android:title="Share" />

    <item android:id="@+id/itemsXreShareUnattended"
        android:icon="@drawable/xf_share"
        android:title="XRE Share (unattended)" />

    <item android:id="@+id/itemsShowInGallery"
        android:icon="@drawable/xfiles_image"
        android:title="Show in gallery" />

    <item android:id="@+id/itemsProperties"
        android:icon="@drawable/xfiles_file_icon"
        android:title="Properties" />
</menu>
```

`app/src/main/res/menu/menu_multi_remote.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemsCopy"
        android:icon="@drawable/xf_copy"
        android:title="Copy" />

    <item android:id="@+id/itemsMove"
        android:icon="@drawable/xfiles_cut"
        android:title="Move" />

    <item android:id="@+id/itemsDelete"
        android:icon="@drawable/xf_recycle_bin"
        android:title="Delete" />

    <item android:id="@+id/itemsRename"
        android:icon="@android:drawable/ic_menu_edit"
        android:title="Bulk Rename" />

    <item android:id="@+id/itemsChecksum"
        android:icon="@drawable/xfiles_root_off"
        android:title="Checksum" />

    <item android:id="@+id/itemsProperties"
        android:icon="@drawable/xfiles_file_icon"
        android:title="Properties" />
</menu>
```

`app/src/main/res/menu/menu_multi_within_archive.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemsExtract"
        android:icon="@drawable/xfiles_extract"
        android:title="Extract" />

    <item android:id="@+id/itemsCopy"
        android:icon="@drawable/xf_copy"
        android:title="Copy" />

    <item android:id="@+id/itemsTest"
        android:icon="@drawable/xfiles_test"
        android:title="Test" />

    <item android:id="@+id/itemsProperties"
        android:icon="@drawable/xfiles_file_icon"
        android:title="Properties" />
</menu>
```

`app/src/main/res/menu/menu_new.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/createNewFileAdvanced"
        android:icon="@drawable/xf_new_file"
        android:title="New file (advanced)" />

    <item android:id="@+id/createNewFile"
        android:icon="@drawable/xf_new_file"
        android:title="New file" />

    <item android:id="@+id/createNewDirectory"
        android:icon="@drawable/xf_new_dir"
        android:title="New directory" />

</menu>
```

`app/src/main/res/menu/menu_single.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemOpenAs"
        android:icon="@drawable/xf_dir_blu"
        android:title="Open as" />

    <item android:id="@+id/itemCopy"
        android:icon="@drawable/xf_copy"
        android:title="Copy" />

    <item android:id="@+id/itemMove"
        android:icon="@drawable/xfiles_cut"
        android:title="Move" />

    <item android:id="@+id/itemCreateLink"
        android:icon="@drawable/xfiles_link_icon"
        android:title="Create link" />

    <item android:id="@+id/itemCompress"
        android:icon="@drawable/xfiles_archive"
        android:title="Compress" />

    <item android:id="@+id/itemExtract"
        android:icon="@drawable/xfiles_extract"
        android:title="Extract" />

    <item android:id="@+id/itemTest"
        android:icon="@drawable/xfiles_test"
        android:title="Test" />

    <item android:id="@+id/itemDelete"
        android:icon="@drawable/xf_recycle_bin"
        android:title="Delete" />

    <item android:id="@+id/itemRename"
        android:icon="@android:drawable/ic_menu_edit"
        android:title="Rename" />

    <item android:id="@+id/itemChecksum"
        android:icon="@drawable/xfiles_root_off"
        android:title="Checksum" />

    <item android:id="@+id/itemShare2ndLevel"
        android:actionViewClass="android.widget.ImageButton"
        android:icon="@drawable/xf_share"
        android:title="Share >" />

    <item android:id="@+id/itemShowInGallery"
        android:icon="@drawable/xfiles_image"
        android:title="Show in gallery" />

    <item android:id="@+id/itemProperties"
        android:icon="@drawable/xfiles_file_icon"
        android:title="Properties" />
</menu>

```

`app/src/main/res/menu/menu_single_local_folder.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemPasteIntoFolder"
        android:icon="@drawable/xfiles_paste"
        android:title="Paste into folder" />

    <item android:id="@+id/itemFind"
        android:icon="@drawable/xfiles_find"
        android:title="Find in folder" />

    <item android:id="@+id/itemShareFolder2ndLevel"
        android:actionViewClass="android.widget.ImageButton"
        android:icon="@drawable/xf_share"
        android:title="Share folder >" />

</menu>

```

`app/src/main/res/menu/menu_single_remote.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemCopy"
        android:icon="@drawable/xf_copy"
        android:title="Copy" />

    <item android:id="@+id/itemMove"
        android:icon="@drawable/xfiles_cut"
        android:title="Move" />

    <item android:id="@+id/itemCreateLink"
        android:icon="@drawable/xfiles_link_icon"
        android:title="Create link" />

    <item android:id="@+id/itemDelete"
        android:icon="@drawable/xf_recycle_bin"
        android:title="Delete" />

    <item android:id="@+id/itemRename"
        android:icon="@android:drawable/ic_menu_edit"
        android:title="Rename" />

    <item android:id="@+id/itemChecksum"
        android:icon="@drawable/xfiles_root_off"
        android:title="Checksum" />

    <item android:id="@+id/itemProperties"
        android:icon="@drawable/xfiles_file_icon"
        android:title="Properties" />
</menu>
```

`app/src/main/res/menu/menu_single_remote_folder.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemPasteIntoFolder"
        android:icon="@drawable/xfiles_paste"
        android:title="Paste into folder" />

</menu>

```

`app/src/main/res/menu/menu_single_within_archive.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/itemExtract"
        android:icon="@drawable/xfiles_extract"
        android:title="Extract" />

    <item android:id="@+id/itemCopy"
        android:icon="@drawable/xf_copy"
        android:title="Copy" />

    <item android:id="@+id/itemTest"
        android:icon="@drawable/xfiles_test"
        android:title="Test" />

    <item android:id="@+id/itemProperties"
        android:icon="@drawable/xfiles_file_icon"
        android:title="Properties" />
</menu>
```

`app/src/main/res/menu/menu_sort.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<menu xmlns:android="http://schemas.android.com/apk/res/android">

    <item android:id="@+id/sortByFilename"
        android:title="Sort by name" />

    <item android:id="@+id/sortByFilenameDesc"
        android:title="Sort by name (descending)" />

    <item android:id="@+id/sortByDate"
        android:title="Sort by date" />

    <item android:id="@+id/sortByDateDesc"
        android:title="Sort by date (descending)" />

    <item android:id="@+id/sortBySize"
        android:title="Sort by size" />

    <item android:id="@+id/sortBySizeDesc"
        android:title="Sort by size (descending)" />

    <item android:id="@+id/sortByType"
        android:title="Sort by type" />

    <item android:id="@+id/sortByTypeDesc"
        android:title="Sort by type (descending)" />
</menu>
```

`app/src/main/res/values-v14/dimens.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>

    <!--
Refer to App Widget Documentation for margin information
http://developer.android.com/guide/topics/appwidgets/index.html#CreatingLayout
    -->
    <dimen name="widget_margin">0dp</dimen>

</resources>
```

`app/src/main/res/values-v21/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="AppTheme" parent="android:Theme.Holo">
        <item name="android:windowActivityTransitions">true</item>
    </style>
</resources>
```

`app/src/main/res/values-v24/styles.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="AppTheme" parent="android:Theme.Holo">
        <item name="android:contextPopupMenuStyle">@style/myContextPopupMenuStyle</item>
        <item name="android:windowActivityTransitions">true</item>
    </style>
    <style name="myContextPopupMenuStyle" parent="@android:style/Widget.Holo.PopupMenu">
        <item name="android:overlapAnchor">true</item>
    </style>
</resources>
```

`app/src/main/res/values-w820dp/dimens.xml`:

```xml
<resources>
    <!-- Example customization of dimensions originally defined in res/values/dimens.xml
         (such as screen margins) for screens with more than 820dp of available width. This
         would include 7" and 10" devices in landscape (~960dp and ~1280dp respectively). -->
    <dimen name="activity_horizontal_margin">64dp</dimen>
</resources>

```

`app/src/main/res/values/attrs.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <declare-styleable name="MediaGalleryView">
        <attr name="span_count" format="integer" />
        <attr name="place_holder" format="reference" />
        <attr name="gallery_orientation" format="enum">
            <enum name="horizontal" value="0" />
            <enum name="vertical" value="1" />
        </attr>
        <attr name="image_width" format="dimension"/>
        <attr name="image_height" format="dimension"/>
    </declare-styleable>

    <declare-styleable name="StandardThemeAttrs">
        <attr name="colorPrimary" format="color|reference" />
        <attr name="colorAccent" format="color|reference" />
        <attr name="backgroundTint" format="color|reference" />
    </declare-styleable>

    <declare-styleable name="SubsamplingScaleImageView">
        <attr name="src" format="reference"/>
        <attr name="assetName" format="string"/>
        <attr name="panEnabled" format="boolean"/>
        <attr name="zoomEnabled" format="boolean"/>
        <attr name="quickScaleEnabled" format="boolean"/>
        <attr name="tileBackgroundColor" format="color"/>
    </declare-styleable>
</resources>
```

`app/src/main/res/values/colors.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="colorPrimary">#3F51B5</color>
    <color name="colorPrimaryDark">#303F9F</color>
    <color name="colorAccent">#FF4081</color>

    <color name="c1">#123456</color>
    <color name="c2">#654321</color>

    <color name="transparentBlue">#7C123456</color>
    <color name="transparentCobaltBlue">#7C15679A</color>
    <color name="transparentCobaltBlue2">#D90B3752</color>
    <color name="black">#000000</color>
    <color name="white">#FFFFFF</color>
    <color name="grey">#888888</color>
    <color name="green">#00FF00</color>
    <color name="red">#FF0000</color>
    <color name="imagebuttonselect">#8800BCD4</color>
</resources>

```

`app/src/main/res/values/dimens.xml`:

```xml
<resources>
    <!-- Default screen margins, per the Android Design guidelines. -->
    <dimen name="activity_horizontal_margin">16dp</dimen>
    <dimen name="activity_vertical_margin">0dp</dimen>

    <!--
Refer to App Widget Documentation for margin information
http://developer.android.com/guide/topics/appwidgets/index.html#CreatingLayout
    -->
    <dimen name="widget_margin">8dp</dimen>
</resources>

```

`app/src/main/res/values/strings.xml`:

```xml
<resources>
    <string name="app_name">XFiles</string>
    <string name="tag_fragment_FileSelect">Select file</string>
    <string name="alert_file_select">Select file</string>
    <string name="select_all">Select\nall</string>
    <string name="select_none">Select\nnone</string>
    <string name="invert_selection">Invert\nselection</string>
    <string name="filter_selection">Filter\nselection</string>
    <string name="filter_deselection">Filter\ndeselection</string>
    <string name="alert_supply_filename">Please supply a valid filename</string>
    <string name="alert_bad_filename_chars">Characters not allowed in filename</string>
    <string name="alert_file_exists">File already exists, please choose a different name</string>
    <string name="tag_fragment_FileSave">Save file</string>
    <string name="edit_hint">Insert file name</string>
    <string name="empty_string" />
    <string name="start_rhss_description">Click on the main button to start/stop the remote RH server; additionally you can manage WiFi and WiFi hotspot status</string>
    <string name="ssh_default_port">22</string>
    <string name="smb_default_port">445</string>
    <string name="smb_default_domain">WORKGROUP</string>
    <string name="dest_archive_filename_header">archive</string>
    <string name="checksums_export_filename_header">checksums</string>
    <string name="serve_only_current_directory">Serve only current directory:</string>
    <string name="send_xre_announce">Send XRE server announce</string>
    <string name="appwidget_text">EXAMPLE</string>
    <string name="add_widget">Add widget</string>
    <string name="permission_storage_explain">XFiles is a file explorer, so it obviously needs permissions to access storage. Without this permission, the app will not start</string>
    <string name="permission_notifs13_explain">On Android 13+, this permission is required for showing progress in foreground services, and for showing toast messages when no activity is active. Without this permission, the app will not start</string>
    <string name="permission_sysSettings_explain"><![CDATA[Optional permission, on devices < Android Oreo it allows to toggle the hotspot state without having to open the system UI every time]]></string>
    <string name="permission_overlay_explain">Optional permission, on file transfers it allows to show an overlay with progress bars (otherwise you would have to check from the service foreground notification)</string>
    <string name="close">Close</string>
    <string name="active_servers_on_close_explain">Some remote servers are currently active. You can close them from here if needed, and then press Back once more to exit. Any active transfers will be canceled if servers are closed</string>
    <string name="permission_extsd_explain">Optional permission, for devices having external memory card, requests write access (you have to manually pick the external SD card from the file browser that opens)</string>
    <string name="permission_install_unknown_apps_explain">Optional permission, from Oreo onwards, Android will block installation of apk files opened within XFiles, even if \"Install apps from unknown sources\" global setting is enabled. Granting this permission will allow apks installation from this app</string>
    <string name="storage_perm_denied">Storage permissions denied</string>
    <string name="storage_read_perm_denied">Storage READ permissions denied</string>
    <string name="storage_perm_granted">Storage permissions granted</string>
    <string name="storage_read_perm_granted">Storage READ permissions granted</string>
    <string name="app_about_desc">A general-purpose file explorer for Android</string>
    <string name="appWebsite">https://github.com/pgp/XFiles</string>
    <string name="alwaysCreateSubdirectory">Always create subdirectory</string>
    <string name="neverCreateSubdirectory">Never create subdirectory</string>
    <string name="smartCreateSubdirectory">Smart subdirectory creation</string>
    <string name="ftp_server">FTP Server</string>
    <string name="http_server">HTTP Server</string>
    <string name="active_ip_addresses">Active IP addresses</string>
</resources>

```

`app/src/main/res/values/styles.xml`:

```xml
<resources>
    <style name="AppTheme" parent="android:Theme.Holo">
        <item name="android:popupMenuStyle">@style/popupMenuStyle</item>
    </style>

    <style name="fs_dialog">
        <item name="android:windowAnimationStyle">@android:style/Animation.Dialog</item>
    </style>

    <style name="popupMenuStyle" parent="android:Theme.Holo"/>

    <style name="AppTheme.MediaGalleryToolbar" parent="android:Theme.Holo">
    </style>

    <style name="ProgressBarStyle" parent="@android:style/Widget.Holo.ProgressBar.Horizontal">
        <item name="colorAccent" type="attr">#3FCCFF</item>
        <item name="backgroundTint" type="attr">#3FCCFF</item>
    </style>

</resources>

```

`app/src/main/res/xml/provider_paths.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<!-- Web source: https://inthecheesefactory.com/blog/how-to-share-access-to-file-with-fileprovider-on-android-nougat/en -->
<!-- not needed with StrictMode.VmPolicy.LAX -->
<!-- https://stackoverflow.com/questions/59105199/how-to-install-any-android-app-programmatically-in-android-10 -->
<!-- needed for installing apks on Android 10 onwards -->
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-path
        name="files_root"
        path="Android/data/${applicationId}" />
    <external-path
        name="external_files"
        path="." />
</paths>
```

`app/src/main/res/xml/xre_rhss_widget_info.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<appwidget-provider xmlns:android="http://schemas.android.com/apk/res/android"
    android:initialKeyguardLayout="@layout/xre_rhss_widget"
    android:initialLayout="@layout/xre_rhss_widget"
    android:minWidth="110dp"
    android:minHeight="110dp"
    android:previewImage="@drawable/xf_widget_thumbnail"
    android:resizeMode="horizontal|vertical"
    android:updatePeriodMillis="86400000"
    android:widgetCategory="home_screen" />
```

`build.gradle`:

```gradle
// Top-level build file where you can add configuration options common to all sub-projects/modules.

buildscript {
    repositories {
        mavenCentral()
        google()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:4.2.2'

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}

allprojects {
    repositories {
        mavenCentral()
        google()
    }
}

task clean(type: Delete) {
    delete rootProject.buildDir
}

```

`buildRootHelpersAndroid.bat`:

```bat
setlocal enableextensions enabledelayedexpansion
REM TODO set -e

SET "NDKDIR=%appdata%\..\Local\Android\Sdk\ndk\21.3.6528147"
SET "RHDIR=%cd%\XFilesRootHelper"
SET "XFILES_ASSET_DIR=%cd%\libs"
md %XFILES_ASSET_DIR%

if exist %RHDIR%\NUL (echo rh directory exists) else (git clone https://github.com/pgp/XFilesRootHelper.git)

cd %RHDIR%
SET "MAINDIR=%cd%"

set "FORMAT7ZDIR=%MAINDIR%\ANDROID\Format7zFree\jni"
set "RHDIR=%MAINDIR%\ANDROID\RootHelper\jni"

set "FORMAT7ZLIBDIR=%MAINDIR%\ANDROID\Format7zFree\libs"
set "RHLIBDIR=%MAINDIR%\ANDROID\RootHelper\libs"

set "TLSCERTDIR=%MAINDIR%\cert"

REM build lib7z.so
cd %FORMAT7ZDIR%
REM rd /s /q ..\obj\*
REM rd /s /q ..\libs\*
if defined LOWPERF (call %NDKDIR%\ndk-build -j2) else (call %NDKDIR%\ndk-build -j4)

REM build roothelper executable shared object (r)
cd %RHDIR%
REM rd /s /q ..\obj\*
REM rd /s /q ..\libs\*
if defined LOWPERF (call %NDKDIR%\ndk-build -j2) else (call %NDKDIR%\ndk-build -j4)

REM rename to libr.so (for gradle to accept it as embeddable in apk)
cd %RHLIBDIR%
for /D %%i in (*) do ( cd %%i & ren r libr.so & cd..)

REM copy libraries

robocopy %RHLIBDIR% %XFILES_ASSET_DIR% /s /e
robocopy %FORMAT7ZLIBDIR% %XFILES_ASSET_DIR% /s /e

cd %XFILES_ASSET_DIR%
for /D %%i in (*) do ( cd %%i & copy %TLSCERTDIR%\dummycrt.pem libdummycrt.so /Y & copy %TLSCERTDIR%\dummykey.pem libdummykey.so /Y & cd..)

```

`buildRootHelpersAndroid.sh`:

```sh
set -e

NDKDIR=$HOME/Android/Sdk/ndk/21.3.6528147
RHDIR=$(pwd)/XFilesRootHelper
XFILES_ASSET_DIR=$(pwd)/libs
mkdir -p $XFILES_ASSET_DIR

if [ ! -d "$RHDIR" ]; then
  git clone https://github.com/pgp/XFilesRootHelper.git
fi

cd $RHDIR
MAINDIR=$(pwd)

FORMAT7ZDIR=$MAINDIR/ANDROID/Format7zFree/jni
RHDIR=$MAINDIR/ANDROID/RootHelper/jni

FORMAT7ZLIBDIR=$MAINDIR/ANDROID/Format7zFree/libs
RHLIBDIR=$MAINDIR/ANDROID/RootHelper/libs

TLSCERTDIR=$MAINDIR/cert

export PATH=$PATH:$NDKDIR

# build lib7z.so
cd $FORMAT7ZDIR
# rm -rf ../obj/*
# rm -rf ../libs/*

if [ -z "$LOWPERF" ]; then echo STANDARD BUILD && ndk-build -j4; else echo LOWPERF $LOWPERF && ndk-build -j2; fi

# build roothelper executable shared object (r)
cd $RHDIR
# rm -rf ../obj/*
# rm -rf ../libs/*
if [ -z "$LOWPERF" ]; then echo STANDARD BUILD && ndk-build -j4; else echo LOWPERF $LOWPERF && ndk-build -j1; fi

# rename to libr.so (for gradle to accept it as embeddable in apk)
cd $RHLIBDIR
for i in $(ls); do
mv ./$i/r ./$i/libr.so
done

rm -rf $XFILES_ASSET_DIR/*

######################### copy libraries

cd $RHLIBDIR
for i in $(ls); do
mkdir -p $XFILES_ASSET_DIR/$i
cp ./$i/libr.so $XFILES_ASSET_DIR/$i/libr.so
done

cd $FORMAT7ZLIBDIR
for i in $(ls); do
mkdir -p $XFILES_ASSET_DIR/$i
cp ./$i/lib7z.so $XFILES_ASSET_DIR/$i/lib7z.so
done

cd $XFILES_ASSET_DIR
for i in $(ls); do
cp $TLSCERTDIR/dummycrt.pem ./$i/libdummycrt.so
cp $TLSCERTDIR/dummykey.pem ./$i/libdummykey.so
done

```

`gradle.properties`:

```properties
# Project-wide Gradle settings.

# IDE (e.g. Android Studio) users:
# Gradle settings configured through the IDE *will override*
# any settings specified in this file.

# For more details on how to configure your build environment visit
# http://www.gradle.org/docs/current/userguide/build_environment.html

# Specifies the JVM arguments used for the daemon process.
# The setting is particularly useful for tweaking memory settings.
org.gradle.jvmargs=-Xmx3072m

# When configured, Gradle will run in incubating parallel mode.
# This option should only be used with decoupled projects. More details, visit
# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects
# org.gradle.parallel=true

```

`gradle/wrapper/gradle-wrapper.properties`:

```properties
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-6.7.1-all.zip

```

`gradlew`:

```
#!/usr/bin/env bash

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"

```

`gradlew.bat`:

```bat
@if "%DEBUG%" == "" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS=

set DIRNAME=%~dp0
if "%DIRNAME%" == "" set DIRNAME=.
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if "%ERRORLEVEL%" == "0" goto init

echo.
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto init

echo.
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME%
echo.
echo Please set the JAVA_HOME variable in your environment to match the
echo location of your Java installation.

goto fail

:init
@rem Get command-line arguments, handling Windowz variants

if not "%OS%" == "Windows_NT" goto win9xME_args
if "%@eval[2+2]" == "4" goto 4NT_args

:win9xME_args
@rem Slurp the command line arguments.
set CMD_LINE_ARGS=
set _SKIP=2

:win9xME_args_slurp
if "x%~1" == "x" goto execute

set CMD_LINE_ARGS=%*
goto execute

:4NT_args
@rem Get arguments from the 4NT Shell from JP Software
set CMD_LINE_ARGS=%$

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar

@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %CMD_LINE_ARGS%

:end
@rem End local scope for the variables with windows NT shell
if "%ERRORLEVEL%"=="0" goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
if  not "" == "%GRADLE_EXIT_CONSOLE%" exit 1
exit /b 1

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega

```

`settings.gradle`:

```gradle
include ':app'

```