Project Path: arc_lowleveldesign_comon_c7yx67r5

Source Tree:

```txt
arc_lowleveldesign_comon_c7yx67r5
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── comon
│   ├── CMakeLists.txt
│   ├── arch.cpp
│   ├── arch.h
│   ├── cohelp.cpp
│   ├── cometa.cpp
│   ├── cometa.h
│   ├── cometa_helpers.cpp
│   ├── comon.h
│   ├── comonitor.cpp
│   ├── comonitor.h
│   ├── comonitor_com_breakpoints.cpp
│   ├── dbgsession.cpp
│   ├── dbgsession.h
│   ├── ext.cpp
│   ├── ext.def
│   ├── helpers.cpp
│   ├── lfu_cache.h
│   ├── resource.h
│   └── resource.rc.in
├── comon.gif
├── vcpkg
└── vcpkg.json

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

set(VCPKG_INSTALLED_DIR "${CMAKE_BINARY_DIR}/vcpkg_installed")

project(comon)

if(DEFINED ENV{COMON_VERSION_MAJOR})
    set(comon_VERSION_MAJOR $ENV{COMON_VERSION_MAJOR})
else()
    set(comon_VERSION_MAJOR 1)
endif()

if(DEFINED ENV{COMON_VERSION_MINOR})
    set(comon_VERSION_MINOR $ENV{COMON_VERSION_MINOR})
else()
    set(comon_VERSION_MINOR 0)
endif()

if(DEFINED ENV{COMON_VERSION_PATCH})
    set(comon_VERSION_PATCH $ENV{COMON_VERSION_PATCH})
else()
    set(comon_VERSION_PATCH 0)
endif()

if(DEFINED ENV{COMON_VERSION_TWEAK})
    set(comon_VERSION_TWEAK $ENV{COMON_VERSION_TWEAK})
else()
    set(comon_VERSION_TWEAK 0)
endif()

set(comon_VERSION
  ${comon_VERSION_MAJOR}.${comon_VERSION_MINOR}.${comon_VERSION_PATCH}.${comon_VERSION_TWEAK}
)

message("Building version ${comon_VERSION}")

add_compile_definitions(UNICODE)

set(CMAKE_CXX_STANDARD 23)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /W4 /WX")

add_subdirectory(comon)

```

`CMakePresets.json`:

```json
{
  "version": 3,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 22,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "ninja-x86-debug",
      "displayName": "Ninja (x86) - Debug",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/${presetName}",
      "architecture": {
        "value": "x86",
        "strategy": "external"
      },
      "toolchainFile":  "${sourceDir}/vcpkg/scripts/buildsystems/vcpkg.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": {
          "value": "Debug"
        },
        "VCPKG_TARGET_TRIPLET": {
          "value": "x86-windows-static"
        }
      }
    },
    {
      "name": "ninja-x86-release",
      "displayName": "Ninja (x86) - Release",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/${presetName}",
      "architecture": {
        "value": "x86",
        "strategy": "external"
      },
      "toolchainFile":  "${sourceDir}/vcpkg/scripts/buildsystems/vcpkg.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": {
          "value": "RelWithDebInfo"
        },
        "VCPKG_TARGET_TRIPLET": {
          "value": "x86-windows-static"
        }
      }
    },
    {
      "name": "ninja-x64-debug",
      "displayName": "Ninja (x64) - Debug",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/${presetName}",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "toolchainFile":  "${sourceDir}/vcpkg/scripts/buildsystems/vcpkg.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": {
          "value": "Debug"
        },
        "VCPKG_TARGET_TRIPLET": {
          "value": "x64-windows-static"
        }
      }
    },
    {
      "name": "ninja-x64-release",
      "displayName": "Ninja (x64) - Release",
      "generator": "Ninja",
      "binaryDir": "${sourceDir}/build/${presetName}",
      "architecture": {
        "value": "x64",
        "strategy": "external"
      },
      "toolchainFile":  "${sourceDir}/vcpkg/scripts/buildsystems/vcpkg.cmake",
      "cacheVariables": {
        "CMAKE_BUILD_TYPE": {
          "value": "RelWithDebInfo"
        },
        "VCPKG_TARGET_TRIPLET": {
          "value": "x64-windows-static"
        }
      }
    }
  ],
  "buildPresets": [
    {
      "name": "ninja-x86-debug",
      "configurePreset": "ninja-x86-debug",
      "displayName": "Ninja (x86) - Debug",
      "verbose": true
    },
    {
      "name": "ninja-x86-release",
      "configurePreset": "ninja-x86-release",
      "displayName": "Ninja (x86) - Release",
      "verbose": true
    },
    {
      "name": "ninja-x64-debug",
      "configurePreset": "ninja-x64-debug",
      "displayName": "Ninja (x64) - Debug",
      "verbose": true
    },
    {
      "name": "ninja-x64-release",
      "configurePreset": "ninja-x64-release",
      "displayName": "Ninja (x64) - Release",
      "verbose": true
    }
  ]
}
```

`LICENSE`:

```

                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS


```

`README.md`:

```md
# comon - a WinDbg extension to trace COM calls

![comon](https://github.com/lowleveldesign/comon/workflows/build/badge.svg)

----------------

:information_source: Maintenance note (14.08.2025)

I no longer update this project. This extension works, but it has some issues, such as:

- it traces only the most comon ways of creating COM objects (`DllGetClassObject`, `CoRegisterClassObject`), so it will miss, for example, objects created in out parameters, or objects created using other COM API functions
- as it relies on breakpoints to collect the COM interactions, it slows down the target application significantly

Therefore, I recommend using comon for debugging relatively small applications or rely on [ETW tracing](https://wtrace.net/guides/com-troubleshooting/#observing-com-interactions-outside-windbg).

----------------

**Table of contents**

<!-- MarkdownTOC -->

- [Introduction](#introduction)
- [Loading the extension and starting the monitor](#loading-the-extension-and-starting-the-monitor)
- [Working with COM metadata](#working-with-com-metadata)
- [Tracing COM interactions](#tracing-com-interactions)
- [Stopping the COM monitor](#stopping-the-com-monitor)
- [Errors and limitations](#errors-and-limitations)
- [Building](#building)

<!-- /MarkdownTOC -->

**Please also check my [COM troubleshooting guide](https://wtrace.net/articles/com-troubleshooting/) to learn more about COM debugging with comon (and not only).**

## Introduction

**Comon** is a WinDbg extension that can help you trace COM interactions (COM class creations and interface querying). You may use it to investigate various COM issues and better understand application logic. During a debugging session, comon will record virtual table addresses (for the newly created COM objects) and allow you to query them or even set breakpoints on COM interface methods. If COM metadata is available (either in the registry or in a standalone TLB/DLL file), you may load it into comon, and it will automatically decode COM identifiers. Let's quickly walk through the comon functionalities.

COM objects used in this tutorial come from [my COM example project](https://github.com/lowleveldesign/protoss-com-example) (more information about it are available in [this blog post](https://lowleveldesign.org/2022/01/17/com-revisited/)).

![](comon.gif)

Available commands:

```
  !cometa index
      - indexes COM metadata found in the system (registered type libraries, CLSIDs,
        and interfaces). The results are saved to a cometa.db3 file in the user temporary
        folder. They should be automatically loaded on the next run.
  !cometa index <path_to_tlb_or_dll_file>
      - indexes COM metadata from the provided TLB or DLL file. The results are saved
        to a cometa.db3 file in the user temporary folder. They should be automatically
        loaded on the next run.

  !cometa showi <iid>
      - shows information about a given IID (COM interface ID). This command will show
        interface methods (if available) and virtual tables registered for this IID.
  !cometa showc <clsid>
      - shows virtual tables registered for a given CLSID (COM class ID)
  !cometa showm <module_name>
      - shows virtual tables registered for a given module (DLL or EXE file)

  !comon attach [[-i|-e] {clsid1} {clsid2} ...]
      - starts COM monitor for the active process. If you're debugging a 32-bit WOW64
        process in a 64-bit debugger, make sure you set the effective CPU architecture to x86
        (.effmach x86), use -i to configure an including filter (monitors only the provided CLSIDs)
        or -e to configure an excluding filter (monitors all CLSIDs except for the provided ones)
  !comon detach
      - stops COM monitor for the active process.
  !comon pause
      - pauses COM monitoring for the active process.
  !comon resume
      - resumes COM monitoring for the active process.
  !comon status
      - shows the current monitoring status. It also lists all the virtual tables registered
        for a given process providing their IIDs and CLSIDs

  !cobp [--before|--after|--always|--trace-only] <clsid> <iid> <method_name|method_number>
      - sets a cobreakpoint (COM breakpoint) on a given COM method. When you create a cobreakpoint,
        comon will print the parameter values and return value of the method (if metadata is available).
        Additionally, the cobreakpoint can make the debugger stop before (--before), after (--after), or
        before and after (--always) the method is called. If you only want to see the parameter values,
        use the --trace-only option. To remove a cobreakpoint, use the bc with the cobreakpoint ID.

  !coreg [--force] [--nosave] <clsid> <iid> <vtable_address>
      - manually add a virtual table address to the COM monitor and bind them with
        a given COM interface (IID) and COM class (CLSID). If the --force option is
        provided, the virtual table will be added even if it's already registered. If
        the --nosave option is provided, the virtual table will not be saved to the
        cometa.db3 file.
```

## Loading the extension and starting the monitor

To start using comon, you need to load it as any other extension:
```
.load comon
```
If a metadata file is already created (more about metadata later), comon will load it. The next step is to attach comon to the process(es) we want. When debugging a single process, it is a matter of calling **!comon attach**. In multi-process debugging sessions, switch to the target process (for example, `|1s`) and run the **!comon attach** command. Comon always creates one monitor per process, so when you call any **!comon** subcommand, it will execute on the monitor attached to the currently selected process.

If you're debugging a **32-bit process with 64-bit WinDbg (WOW64)**, ensure the effective architecture is correct (`.effmach` should return `x86`).

If you are interested only in specific CLSIDs or want to exclude some CLSIDs, you need to **define filters** when attaching to a process. The attach command contains **--include** and **--exclude** parameters (use either of them) which accept a comma-separated list of CLSIDs. Filtering improves the debugger and debuggee performance as fewer breakpoints are needed to trace COM calls. "COM-heavy" applications like Excel may not even start if we don't set the valid filters.

## Working with COM metadata

We need COM metadata to resolve CLSIDs and IIDs, identifiers of COM classes, and interfaces. The comon output without metadata contains only raw GUIDs and may be hard to read. Comon uses an SQLite database in the user's temporary folder to save information about indexed type libraries and virtual tables.

The primary command to work with metadata is **!cometa**. The subcommand **index** indexes COM registrations in the registry. Those include type libraries (the newest installed version), CLSIDs, and IIDs. The 64-bit version of the extension scans both 64-bit and 32-bit versions of the CLSID and Interfaces keys. If you provide a path to a TLB or DLL file to the **!cometa index** command, it will index it and add found metadata to the database. When indexing a DLL file, it must contain a type library as one of its resources. Type libraries are the best metadata sources, providing type names, methods, and parent types. With complete metadata for a given interface, you can set breakpoints using its method names instead of ordinal numbers.

Comon also provides commands to query the indexed metadata and virtual table addresses. **!cometa showi** displays information about a given IID, and **!cometa showc** exhibits information about a given CLSID. Example output:

```
0:000> !cometa showi {C5F45CBC-4439-418C-A9F9-05AC67525E43}
Found: {C5F45CBC-4439-418C-A9F9-05AC67525E43} (INexus)

Methods:
- [0] HRESULT QueryInterface(void* this, GUID* riid, void** ppvObject)
- [1] ULONG AddRef(void* this)
- [2] ULONG Release(void* this)
- [3] BAD_TYPE CreateUnit(void* this, BAD_TYPE unit_name, BAD_TYPE* ppUnk)

Registered VTables for IID:
- Module: protoss, CLSID: {F5353C58-CFD9-4204-8D92-D274C7578B53} (Nexus), VTable offset: 0x376f8
```

```
0:000> !cometa showc {F5353C58-CFD9-4204-8D92-D274C7578B53}
Found: {F5353C58-CFD9-4204-8D92-D274C7578B53} (Nexus)

Registered VTables for CLSID:
- module: protoss, IID: {00000001-0000-0000-C000-000000000046} (N/A), VTable offset: 0x3694c
- module: protoss, IID: {59644217-3E52-4202-BA49-F473590CC61A} (IGameObject), VTable offset: 0x37710
- module: protoss, IID: {C5F45CBC-4439-418C-A9F9-05AC67525E43} (INexus), VTable offset: 0x376f8
```

If you are looking for virtual tables registered for a given module, try **!cometa showm**.

## Tracing COM interactions

Comon uses breakpoints to trace COM calls, so don't be surprised if you see hundreds of breakpoints in the `bl` command output :) Breakpoints created by comon will have a comment in the command session describing the purpose of a given breakpoint. Apart from the automatic breakpoints, you may also use "special breakpoints" (called **cobreakpoints**) to break on COM method calls. The **!cobp** command creates such breakpoints. Starting from version 2.1, if COM metadata is available, comon will print method parameter values on cobreakpoint hit and monitor the method's return values (both out parameters values and the return code). It does not support all possible COM types but should print at least a memory address in most cases. When you set a cobreakpoint, you may decide if you want to stop the debugger before the method execution (**--before**), after the method finishes (**--after**), before and after execution (**--always**), or never (**--trace-only**). If you don't specify any parameter, the debugger will stop only before the method execution.

The --after cobreakpoints are especially useful when a method creates a new COM object instance. Comon won't know about it (it monitors only the well-known functions, such as `DllGetClassObject`, `IUnknown::QueryInterface`, and `IClassFactory::CreateInstance`), so you need to update its internal database manually. The command to register a new virtual table is **!coreg**.

A sample output from a debugging session with cobreakpoint set on `IGameUnit::CreateUnit` method:

```
0:000> !comon attach
COM monitor enabled for the current process.

0:000> !cobp --always F5353C58-CFD9-4204-8D92-D274C7578B53 C5F45CBC-4439-418C-A9F9-05AC67525E43 CreateUnit
[comon] Breakpoint 15 (address 0x66c61b72) created / updated

0:000> g
ModLoad: 76220000 7629c000   C:\WINDOWS\SysWOW64\ADVAPI32.dll
ModLoad: 75b30000 75bb2000   C:\WINDOWS\SysWOW64\sechost.dll
ModLoad: 66ae0000 66ae9000   C:\WINDOWS\SysWOW64\ktmw32.dll
[comon] 0:000 [protoss!DllGetClassObject] CLSID: {EFF8970E-C50F-45E0-9284-291CE5A6F771} (Probe), IID: {00000001-0000-0000-C000-000000000046} (N/A) -> SUCCESS (0x0)
[comon] 0:000 [protoss!DllGetClassObject] CLSID: {F5353C58-CFD9-4204-8D92-D274C7578B53} (Nexus), IID: {00000001-0000-0000-C000-000000000046} (N/A) -> SUCCESS (0x0)
[comon breakpoint] INexus::CreateUnit (iid: {C5F45CBC-4439-418C-A9F9-05AC67525E43}, clsid: {F5353C58-CFD9-4204-8D92-D274C7578B53})

Parameters:
- this: 0xe034e8 (void*)
- unit_name: 0xe0b7c4 (BSTR) -> "Probe"
- ppUnk: 0x75fbc8 (IUnknown**) -> 0x0 [out]

66c61b72 e979ae0100      jmp     protoss!Nexus::CreateUnit (66c7c9f0)
0:000> g
[comon breakpoint] INexus::CreateUnit (iid: {C5F45CBC-4439-418C-A9F9-05AC67525E43}, clsid: {F5353C58-CFD9-4204-8D92-D274C7578B53}) return
Result: 0x0 (HRESULT)

Out parameters:
- ppUnk: 0x75fbc8 (IUnknown**) -> 0xe0bbd8

eax=00000000 ebx=00a8d000 ecx=0e796c23 edx=00000001 esi=0075fadc edi=0075fbe8
eip=00813df5 esp=0075fadc ebp=0075fbf4 iopl=0         nv up ei pl zr na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246
ProtossComClient!start_from_nexus+0x195:
00813df5 3bf4            cmp     esi,esp
```

## Stopping the COM monitor

To stop comon monitoring of an active process, run the `!comon detach` command. The collected COM metadata will still be available, but comon will no longer log any details about COM calls.

## Errors and limitations

If **comon can't load a database file** with metadata (it always tries cometa.db3 in the user's temporary folder), it will use an in-memory database. Please make sure that there is no other application locking the cometa.db3 file. 

## Building

Comon is built with CMake, using [vcpkg](https://vcpkg.io) as a package manager.

You may use one of the CMake presets to build a specific configuration, for example:

```
cmake --preset=ninja-x64-release
cmake --build --preset=ninja-x64-release
```

```

`comon/CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.22)

set(BUILD_SHARED_LIBS YES)

find_package(WIL CONFIG REQUIRED)
find_package(SQLiteCpp CONFIG REQUIRED)

configure_file(resource.h resource.h COPYONLY)
configure_file(resource.rc.in resource.rc @ONLY)

add_library(comon
	"cometa.h"
	"cometa.cpp"
	"cometa_helpers.cpp"
	"comon.h"
	"comonitor.h"
	"comonitor.cpp"
	"comonitor_com_breakpoints.cpp"
	"ext.cpp"
	"ext.def"
	"helpers.cpp"
	"cohelp.cpp"
	"dbgsession.h" 
	"dbgsession.cpp"
	"${CMAKE_CURRENT_BINARY_DIR}/resource.rc"
	"arch.h"
	"arch.cpp"
	"lfu_cache.h"
)

set_property(TARGET comon PROPERTY MSVC_RUNTIME_LIBRARY "MultiThreaded$<$<CONFIG:Debug>:Debug>")

target_link_libraries(comon PRIVATE
	WIL::WIL
	SQLiteCpp
	dbgeng
)

target_compile_definitions(comon PRIVATE
	EXT_MAJOR_VER=${comon_VERSION_MAJOR}
	EXT_MINOR_VER=${comon_VERSION_MINOR}
	EXT_PATCH_VER=${comon_VERSION_PATCH}
	EXT_TWEAK_VER=${comon_VERSION_TWEAK}
)

if (VCPKG_TARGET_TRIPLET STREQUAL "x64-windows-static")
	target_compile_definitions(comon PRIVATE
		ARCH_X64
	)
endif()

set_target_properties(comon PROPERTIES
	LINK_OPTIONS LINKER:/MANIFEST:NO
)

install(TARGETS comon RUNTIME DESTINATION ".")
install(FILES $<TARGET_PDB_FILE:comon> DESTINATION ".")


```

`comon/arch.cpp`:

```cpp

#include <array>
#include <vector>
#include <cassert>
#include <string>
#include <format>
#include <variant>
#include <unordered_set>
#include <ranges>

#include "cometa.h"
#include "arch.h"

using namespace comon_ext;

call_context::arch call_context::get_process_arch(IDebugControl4* dbgcontrol, IDebugSymbols3* dbgsymbols, IDebugRegisters2* dbgregisters) {
    auto init_arch_x86 = [dbgcontrol, dbgregisters](bool is_wow64) {
        ULONG eax, esp;
        THROW_IF_FAILED(dbgregisters->GetIndexByName("eax", &eax));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("esp", &esp));
        return arch_x86{ IMAGE_FILE_MACHINE_I386, is_wow64, esp, eax };
    };

    auto init_arch_x64 = [dbgcontrol, dbgregisters]() {
        ULONG rax, rsp, rcx, rdx, r8, r9, xmm0, xmm1, xmm2, xmm3;
        THROW_IF_FAILED(dbgregisters->GetIndexByName("rax", &rax));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("rsp", &rsp));

        THROW_IF_FAILED(dbgregisters->GetIndexByName("rcx", &rcx));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("rdx", &rdx));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("r8", &r8));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("r9", &r9));

        THROW_IF_FAILED(dbgregisters->GetIndexByName("xmm0", &xmm0));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("xmm1", &xmm1));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("xmm2", &xmm2));
        THROW_IF_FAILED(dbgregisters->GetIndexByName("xmm3", &xmm3));

        return arch_x64{ IMAGE_FILE_MACHINE_AMD64, rsp, rax, { rcx, rdx, r8, r9, xmm0, xmm1, xmm2, xmm3 } };
    };

    ULONG effmach{};
    THROW_IF_FAILED(dbgcontrol->GetEffectiveProcessorType(&effmach));

    bool is_wow64{};
    if (ULONG idx;
        SUCCEEDED(dbgsymbols->GetModuleByModuleName2Wide(L"wow64", 0, DEBUG_GETMOD_NO_UNLOADED_MODULES, &idx, nullptr)) && idx >= 0) {
        is_wow64 = true;
    }

    if (effmach == IMAGE_FILE_MACHINE_I386) {
        return init_arch_x86(is_wow64);
    } else if (effmach == IMAGE_FILE_MACHINE_AMD64) {
        return is_wow64 ? arch{ init_arch_x86(true) } : arch{ init_arch_x64() };
    } else {
        throw std::invalid_argument{ "unsupported effective CPU architecture" };
    }
}

call_context::call_context(IDebugControl4* dbgcontrol, IDebugDataSpaces3* dbgdataspaces,
    IDebugRegisters2* dbgregisters, IDebugSymbols3* dbgsymbols): _dbgcontrol{ dbgcontrol }, _dbgdataspaces{ dbgdataspaces },
    _dbgregisters{ dbgregisters }, _arch{ get_process_arch(_dbgcontrol.get(), dbgsymbols, _dbgregisters.get()) },
    _pointer_size{ std::holds_alternative<arch_x86>(_arch) ? 4UL : 8UL } {
}

HRESULT call_context::read_method_return_code(arg_val& return_arg) const {
    // FUTURE: currently, only HRESULT is supported
    if (return_arg.type != L"HRESULT") {
        return E_NOTIMPL;
    }

    if (std::holds_alternative<arch_x86>(_arch)) {
        DEBUG_VALUE r{};
        RETURN_IF_FAILED(_dbgregisters->GetValue(
            std::get<arch_x86>(_arch).eax, &r));
        return_arg.value = r.I32;
        return S_OK;
    } else if (std::holds_alternative<arch_x64>(_arch)) {
        DEBUG_VALUE r{};
        RETURN_IF_FAILED(_dbgregisters->GetValue(
            std::get<arch_x64>(_arch).rax, &r));
        return_arg.value = r.I64;
        return S_OK;
    } else {
        return_arg.value = 0xdeadbeef;
        return E_UNEXPECTED;
    }
}

namespace {

// types that we deal with in the following methods are the same as defined in cometa_helpers.cpp

bool is_primitive_type(std::wstring_view type) {
    static const std::unordered_set<std::wstring_view> primitive_types{
        L"bool", L"char", L"unsigned char", L"short", L"unsigned short", L"long", L"unsigned long",
            L"int", L"unsigned int", L"int64", L"uint64", L"HRESULT", L"DISPID"
    };

    return primitive_types.contains(type);
}

bool is_float_type(std::wstring_view type) {
    return type == L"float" || type == L"double" || type == L"single";
}

bool is_pointer_type(std::wstring_view type) {
    return type.ends_with(L"*") || type == L"LPWSTR" || type == L"LPSTR" || type == L"BSTR";
}

std::wstring get_primitive_arg_value_in_text(std::wstring_view type, ULONG64 raw_val) {
    if (type == L"bool") {
        return std::format(L"{}", raw_val ? L"true" : L"false", type);
    } else if (type == L"char") {
        return std::format(L"'{}'", static_cast<char>(raw_val), type);
    } else if (type == L"unsigned char") {
        return std::format(L"'{}'", static_cast<unsigned char>(raw_val), type);
    } else if (type == L"short") {
        return std::format(L"{}", static_cast<short>(raw_val), type);
    } else if (type == L"unsigned short") {
        return std::format(L"{}", static_cast<short>(raw_val), type);
    } else if (type == L"long") {
        return std::format(L"{}", static_cast<long>(raw_val), type);
    } else if (type == L"unsigned long") {
        return std::format(L"{}", static_cast<unsigned long>(raw_val), type);
    } else if (type == L"int") {
        return std::format(L"{}", static_cast<int>(raw_val), type);
    } else if (type == L"unsigned int") {
        return std::format(L"{}", static_cast<unsigned int>(raw_val), type);
    } else if (type == L"int64") {
        return std::format(L"{}", static_cast<int64_t>(raw_val), type);
    } else if (type == L"uint64") {
        return std::format(L"{}", static_cast<uint64_t>(raw_val), type);
    } else if (type == L"single" || type == L"float") {
        return std::format(L"{}", static_cast<float>(raw_val), type);
    } else if (type == L"double") {
        return std::format(L"{}", static_cast<double>(raw_val), type);
    } else if (type == L"DISPID") {
        return std::format(L"{:#x}", static_cast<unsigned long>(raw_val), type);
    } else if (type == L"HRESULT" || type == L"SCODE") {
        return std::format(L"{:#x}", static_cast<unsigned long>(raw_val), type);
    } else {
        assert(false);
        return std::wstring{ L"??" };
    }
};

}

HRESULT call_context::read_method_frame(CALLCONV cc, std::vector<arg_val>& args, ULONG64& ret_addr) const {

    if (!is_64bit() && cc != CALLCONV::CC_STDCALL) {
        return E_NOTIMPL;
    }

    auto get_stack_base = [this](ULONG64& stack_base) -> HRESULT {
        if (std::holds_alternative<arch_x86>(_arch)) {
            auto& arch = std::get<arch_x86>(_arch);
            DEBUG_VALUE r{};
            RETURN_IF_FAILED(_dbgregisters->GetValue(arch.esp, &r));
            stack_base = r.I32;
            return S_OK;
        } else if (std::holds_alternative<arch_x64>(_arch)) {
            auto& arch = std::get<arch_x64>(_arch);
            DEBUG_VALUE r{};
            RETURN_IF_FAILED(_dbgregisters->GetValue(arch.rsp, &r));
            stack_base = r.I64;
            return S_OK;
        } else {
            assert(false);
            return E_UNEXPECTED;
        }
    };

    DEBUG_VALUE x64_reg_values[8]{};
    if (is_64bit()) {
        auto& arch = std::get<arch_x64>(_arch);
        RETURN_IF_FAILED(_dbgregisters->GetValues(8, const_cast<PULONG>(arch.reg_args), 0, x64_reg_values));
    }

    ULONG64 offset{};
    RETURN_IF_FAILED(get_stack_base(offset));
    RETURN_IF_FAILED(_dbgdataspaces->ReadPointersVirtual(1, offset, &ret_addr));
    offset += _pointer_size; // return address

    auto buffer{ std::make_unique<BYTE[]>(args.size() * _pointer_size) };
    RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(offset, buffer.get(), static_cast<ULONG>(args.size() * _pointer_size), nullptr));

    auto get_nth_arg_value = [this, &buffer, &x64_reg_values](unsigned int n, arg_val& arg, ULONG64& offset) -> HRESULT {
        if (n < 4 && is_64bit()) {
            if (is_primitive_type(arg.type) || is_pointer_type(arg.type)) {
                arg.value = x64_reg_values[n].I64;
                offset += _pointer_size; // shadow space
            } else if (is_float_type(arg.type)) {
                arg.value = x64_reg_values[n + 4].I64;
                offset += _pointer_size; // shadow space
            } else {
                return E_NOTIMPL;
            }
        } else {
            if (!is_primitive_type(arg.type) && !is_pointer_type(arg.type) && !is_float_type(arg.type)) {
                return E_NOTIMPL;
            }

            if (is_64bit()) {
                arg.value = *reinterpret_cast<ULONG64*>(buffer.get() + n * _pointer_size);
            } else {
                arg.value = *reinterpret_cast<ULONG32*>(buffer.get() + n * _pointer_size);
            }
            offset += _pointer_size;
        }
        return S_OK;
    };

    for (unsigned int i = 0; i < args.size(); i++) {
        RETURN_IF_FAILED(get_nth_arg_value(i, args[i], offset));
    }

    return S_OK;
}

HRESULT call_context::get_arg_value_in_text(const arg_val& arg, std::wstring& text) const {
    auto read_wstring = [this](ULONG64 addr, std::wstring& value, int maxlen = 1000) {
        std::unique_ptr<wchar_t[]> buf(new wchar_t[maxlen]);
        ULONG bytes_read{};
        RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(addr, buf.get(), maxlen * sizeof(wchar_t), &bytes_read));
        if (const wchar_t* end = std::char_traits<wchar_t>::find(buf.get(), maxlen, L'\0')) {
            value.assign(buf.get(), end - buf.get());
        } else {
            value.assign(buf.get(), maxlen);
        }
        return S_OK;
    };

    auto read_string = [this](ULONG64 addr, std::string& value, int maxlen = 1000) {
        std::unique_ptr<char[]> buf(new char[maxlen]);
        ULONG bytes_read{};
        RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(addr, buf.get(), maxlen * sizeof(char), &bytes_read));
        if (const char* end = std::char_traits<char>::find(buf.get(), maxlen, '\0')) {
            value.assign(buf.get(), end - buf.get());
        } else {
            value.assign(buf.get(), maxlen);
        }
        return S_OK;
    };

    auto get_pointer_arg_value_in_text = [this, &read_string, &read_wstring](std::wstring_view type, ULONG64 addr, std::wstring& text) {
        constexpr int max_string_len = 100;

        if (addr == 0) {
            text = std::format(L"null ({})", type);
        } else if (type == L"GUID*") {
            GUID guid{};
            RETURN_IF_FAILED(read_object(addr, &guid, sizeof(guid)));
            text = std::format(L"{:#x} ({}) -> {:b}", addr, type, guid);
        } else if (type == L"LPWSTR" || type == L"BSTR") {
            std::wstring str{};
            RETURN_IF_FAILED(read_wstring(addr, str, max_string_len));
            text = std::format(L"{:#x} ({}) -> \"{}\"", addr, type, str);
        } else if (type == L"LPSTR") {
            std::string str{};
            RETURN_IF_FAILED(read_string(addr, str, max_string_len));
            text = std::format(L"{:#x} ({}) -> \"{}\"", addr, type, widen(str));
        } else if (type == L"DISPPARAMS*") {
            auto offset{ addr };
            ULONG64 args{};
            RETURN_IF_FAILED(read_pointer(offset, args));
            offset += _pointer_size;
            ULONG64 named_args{};
            RETURN_IF_FAILED(read_pointer(offset, named_args));
            offset += _pointer_size;
            DWORD arg_count{};
            RETURN_IF_FAILED(read_object(offset, &arg_count, sizeof(arg_count)));
            offset += sizeof(arg_count);
            DWORD named_arg_count{};
            RETURN_IF_FAILED(read_object(offset, &named_arg_count, sizeof(named_arg_count)));
            text = std::format(L"{:#x} ({}) -> {{ {:#x}, {:#x}, {}, {} }}", addr, type, args,
                named_args, arg_count, named_arg_count);
        } else if (is_primitive_type(type.substr(0, type.size() - 1))) {
            ULONG64 val{};
            RETURN_IF_FAILED(read_pointer(addr, val));
            auto val_text{ get_primitive_arg_value_in_text(type.substr(0, type.size() - 1), val) };
            text = std::format(L"{:#x} ({}) -> {}", addr, type, val_text);
        } else if (type.ends_with(L"**")) {
            ULONG64 pval{};
            RETURN_IF_FAILED(read_pointer(addr, pval));
            text = std::format(L"{:#x} ({}) -> {:#x}", addr, type, pval);
        } else {
            text = std::format(L"{:#x} ({})", addr, type);
        }
        return S_OK;
    };

    std::wstring_view type{ arg.type };

    if (type == L"void" || type == L"null" || type == typelib::bad_type_name) {
        text = std::format(L"({})", type);
    } else if (is_primitive_type(type)) {
        text = std::format(L"{} ({})", get_primitive_arg_value_in_text(type, arg.value), type);
    } else if (is_pointer_type(arg.type)) {
        RETURN_IF_FAILED(get_pointer_arg_value_in_text(type, arg.value, text));
    } else {
        text = std::format(L"?? ({})", type);
        return E_NOTIMPL;
    }

    return S_OK;
}
```

`comon/arch.h`:

```h

#pragma once

#include <string>
#include <variant>
#include <vector>
#include <tuple>
#include <memory>
#include <optional>
#include <algorithm>

#include <Windows.h>
#include <DbgEng.h>

#include <wil/com.h>

namespace comon_ext
{

/*
 * This class contains a lot of messy code to read the arguments of a function call
 * and work with the stack. It is in many ways limited and may require some work to
 * make it work to less common architectures/calling conventions/etc.
*/
class call_context
{
    struct arch_x86
    {
        const ULONG effmach_code;
        const bool is_wow64;

        const ULONG esp, eax;
    };

    struct arch_x64
    {
        const ULONG effmach_code;

        const ULONG rsp, rax;

        const ULONG reg_args[8];
    };

    using arch = std::variant<arch_x86, arch_x64>;

    static arch get_process_arch(IDebugControl4* dbgcontrol, IDebugSymbols3* dbgsymbols, IDebugRegisters2* dbgregisters);

    const wil::com_ptr<IDebugControl4> _dbgcontrol;
    const wil::com_ptr<IDebugDataSpaces3> _dbgdataspaces;
    const wil::com_ptr<IDebugRegisters2> _dbgregisters;

    const arch _arch;
    const ULONG _pointer_size;

public:
    struct arg_val {
        std::wstring type;
        ULONG64 value;
    };

    explicit call_context(IDebugControl4* dbgcontrol, IDebugDataSpaces3* dbgdataspaces,
        IDebugRegisters2* dbgregisters, IDebugSymbols3* dbgsymbols);

    HRESULT read_pointer(ULONG64 addr, ULONG64& value) const {
        RETURN_IF_FAILED(_dbgdataspaces->ReadPointersVirtual(1, addr, &value));
        return S_OK;
    }

    HRESULT read_wstring(ULONG64 addr, std::wstring& value, int maxlen = 1000) const {
        std::unique_ptr<wchar_t[]> buf(new wchar_t[maxlen]);
        ULONG bytes_read{};
        RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(addr, buf.get(), maxlen * sizeof(wchar_t), &bytes_read));
        if (const wchar_t* end = std::char_traits<wchar_t>::find(buf.get(), maxlen, L'\0')) {
            value.assign(buf.get(), end - buf.get());
        } else {
            value.assign(buf.get(), maxlen);
        }
        return S_OK;
    }

    HRESULT read_string(ULONG64 addr, std::string& value, int maxlen = 1000) const {
        std::unique_ptr<char[]> buf(new char[maxlen]);
        ULONG bytes_read{};
        RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(addr, buf.get(), maxlen * sizeof(char), &bytes_read));
        if (const char* end = std::char_traits<char>::find(buf.get(), maxlen, '\0')) {
            value.assign(buf.get(), end - buf.get());
        } else {
            value.assign(buf.get(), maxlen);
        }
        return S_OK;
    }

    HRESULT read_object(ULONG64 addr, PVOID obj, ULONG obj_size) const {
        ULONG bytes_read{};
        RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(addr, obj, obj_size, &bytes_read));
        RETURN_HR_IF(E_UNEXPECTED, bytes_read != obj_size);
        return S_OK;
    }

    HRESULT read_method_return_code(arg_val& return_value) const;

    HRESULT read_method_frame(CALLCONV cc, std::vector<arg_val>& args, ULONG64& ret_addr) const;

    HRESULT get_arg_value_in_text(const arg_val& arg, std::wstring& text) const;

    ULONG get_pointer_size() const noexcept {
        return _pointer_size;
    }

    bool is_64bit() const noexcept { return _pointer_size == 8; }

    bool is_wow64() const noexcept {
        if (std::holds_alternative<arch_x86>(_arch)) {
            return std::get<arch_x86>(_arch).is_wow64;
        } else {
            return false;
        }
    }
};

}


```

`comon/cohelp.cpp`:

```cpp
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
#include <format>

#include <DbgEng.h>
#include <Windows.h>

#include <wil/com.h>
#include <wil/result.h>

#include "comon.h"

using namespace comon_ext;

extern "C" HRESULT CALLBACK cohelp(IDebugClient * dbgclient, [[maybe_unused]] PCSTR args) {
    wil::com_ptr_t<IDebugControl4> dbgcontrol;
    RETURN_IF_FAILED(dbgclient->QueryInterface(__uuidof(IDebugControl4), dbgcontrol.put_void()));

    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"==============================================================\n");
    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L" comon v%d.%d.%d.%d - Copyright 2023 Sebastian Solnica\n", EXT_MAJOR_VER, EXT_MINOR_VER,
        EXT_PATCH_VER, EXT_TWEAK_VER);
    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"==============================================================\n\n");

    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, LR"(Available commands:

  !cometa index
      - indexes COM metadata found in the system (registered type libraries, CLSIDs,
        and interfaces). The results are saved to a cometa.db3 file in the user temporary
        folder. They should be automatically loaded on the next run.
  !cometa index <path_to_tlb_or_dll_file>
      - indexes COM metadata from the provided TLB or DLL file. The results are saved
        to a cometa.db3 file in the user temporary folder. They should be automatically
        loaded on the next run.

  !cometa showi <iid>
      - shows information about a given IID (COM interface ID). This command will show
        interface methods (if available) and virtual tables registered for this IID.
  !cometa showc <clsid>
      - shows virtual tables registered for a given CLSID (COM class ID)
  !cometa showm <module_name>
      - shows virtual tables registered for a given module (DLL or EXE file)

  !comon attach [[-i|-e] {clsid1} {clsid2} ...]
      - starts COM monitor for the active process. If you're debugging a 32-bit WOW64
        process in a 64-bit debugger, make sure you set the effective CPU architecture to x86
        (.effmach x86), use -i to configure an including filter (monitors only the provided CLSIDs)
        or -e to configure an excluding filter (monitors all CLSIDs except for the provided ones)
  !comon detach
      - stops COM monitor for the active process.
  !comon pause
      - pauses COM monitoring for the active process.
  !comon resume
      - resumes COM monitoring for the active process.
  !comon status
      - shows the current monitoring status. It also lists all the virtual tables registered
        for a given process providing their IIDs and CLSIDs

  !cobp [--before|--after|--always|--trace-only] <clsid> <iid> <method_name|method_number>
      - sets a cobreakpoint (COM breakpoint) on a given COM method. When you create a cobreakpoint,
        comon will print the parameter values and return value of the method (if metadata is available).
        Additionally, the cobreakpoint can make the debugger stop before (--before), after (--after), or
        before and after (--always) the method is called. If you only want to see the parameter values,
        use the --trace-only option. To remove a cobreakpoint, use the bc with the cobreakpoint ID.

  !coreg [--force] [--nosave] <clsid> <iid> <vtable_address>
      - manually add a virtual table address to the COM monitor and bind them with
        a given COM interface (IID) and COM class (CLSID). If the --force option is
        provided, the virtual table will be added even if it's already registered. If
        the --nosave option is provided, the virtual table will not be saved to the
        cometa.db3 file.
==============================================================
)");

    return S_OK;
}

```

`comon/cometa.cpp`:

```cpp
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <filesystem>
#include <string>
#include <array>
#include <cassert>
#include <ranges>
#include <algorithm>
#include <variant>
#include <functional>
#include <memory>

#include <SQLiteCpp/Database.h>
#include <SQLiteCpp/Statement.h>
#include <SQLiteCpp/Transaction.h>

#include <Windows.h>
#include <wil/com.h>
#include <wil/result.h>
#include <wil/resource.h>

#include "comon.h"
#include "cometa.h"

using namespace comon_ext;

namespace ranges = std::ranges;
namespace fs = std::filesystem;

/* *** COM METADATA *** */

// increment whenever the database schema changes
constexpr int schema_version{ 5 };

std::unique_ptr<SQLite::Database> cometa::init_db(const fs::path& path, IDebugControl4* dbgcontrol) {
    dbgeng_logger log{ dbgcontrol };

    if (path.empty()) {
        log.log_info(L"Could not open the metadata database from the dafault location. Switching to a temporary in-memory database.");
    } else {
        log.log_info(std::format(L"Creating a new metadata database at '{}'.", path.c_str()));
    }

    auto db{ std::make_unique<SQLite::Database>(to_utf8(path.c_str()), SQLite::OPEN_CREATE | SQLite::OPEN_READWRITE) };

    db->exec(R"(create table schema_version (version integer not null);)");
    db->exec(std::format("insert into schema_version (version) values({})", schema_version));

    db->exec(R"(create table cotypes (
iid blob primary key, 
type integer not null,
name text not null,
parent_iid blob not null,
methods_available int not null) without rowid)");

    db->exec(R"(create table cotype_methods (
iid blob not null,
ordinal integer not null,
name text not null,
callconv integer not null,
dispid integer null,
return_type text not null,
primary key (iid, ordinal)) without rowid)");

    db->exec(R"(create table cotype_method_args (
iid blob not null,
method_ordinal integer not null,
name text not null,
ordinal integer not null,
type text not null,
flags int not null,
primary key (iid, method_ordinal, ordinal)) without rowid)");

    db->exec(R"(create table coclasses (
clsid blob primary key, 
name text not null
) without rowid)");

    db->exec(R"(create table vtables (
clsid blob not null, 
iid blob not null,
module_name text not null,
module_timestamp integer not null,
vtable integer not null,
primary key (clsid, iid)) without rowid;
create index IX_vtables_iid on vtables (iid);
create index IX_vtables_module_name on vtables (module_name))");

    return db;
}

std::unique_ptr<SQLite::Database> cometa::open_db(const fs::path& path, IDebugControl4* dbgcontrol) {
    dbgeng_logger log{ dbgcontrol };
    log.log_info(std::format(L"Opening an existing metadata database from '{}'.", path.c_str()));

    auto db{ std::make_unique<SQLite::Database>(to_utf8(path.c_str()), SQLite::OPEN_READWRITE) };
    if (SQLite::Statement query{ *db, "select version from schema_version" };
        !query.executeStep() || query.getColumn("version").getInt() != schema_version) {
        log.log_error(L"Incorrect version of the schema detected.", E_FAIL);
        throw std::invalid_argument{ "incorrect database schema" };
    }
    return db;
}


cometa::cometa(IDebugControl4* dbgcontrol, bool is_wow64, const fs::path& db_path, bool create_new):
    _logger{ dbgcontrol }, _is_wow64{ is_wow64 },
    _db{ create_new ? init_db(db_path, dbgcontrol) : open_db(db_path, dbgcontrol) } {

    if (create_new) {
        fill_known_iids();
    }
}

void cometa::fill_known_iids() {
    // we insert all fundamental COM types here to make sure that they are always available

    SQLite::Transaction transaction{ *_db };

    // IUnknown
    insert_cotype(cotype{ __uuidof(IUnknown), L"IUnknown", cotype_kind::Interface, {}, true });

    insert_cotype_method(comethod{ __uuidof(IUnknown), L"QueryInterface", 0, CC_STDCALL, std::nullopt, L"HRESULT" });
    insert_cotype_method_arg(__uuidof(IUnknown), 0, { L"this", L"void*", 0 }, 0);
    insert_cotype_method_arg(__uuidof(IUnknown), 0, { L"riid", L"GUID*", IDLFLAG_FIN }, 1);
    insert_cotype_method_arg(__uuidof(IUnknown), 0, { L"ppvObject", L"void**", IDLFLAG_FOUT }, 2);

    insert_cotype_method(comethod{ __uuidof(IUnknown), L"AddRef", 1, CC_STDCALL, std::nullopt, L"ULONG" });
    insert_cotype_method_arg(__uuidof(IUnknown), 1, { L"this", L"void*", 0 }, 0);

    insert_cotype_method(comethod{ __uuidof(IUnknown), L"Release", 2, CC_STDCALL, std::nullopt, L"ULONG" });
    insert_cotype_method_arg(__uuidof(IUnknown), 2, { L"this", L"void*", 0 }, 0);

    // IDispatch
    insert_cotype(cotype{ __uuidof(IDispatch), L"IDispatch", cotype_kind::Interface, __uuidof(IUnknown), true });

    insert_cotype_method(comethod{ __uuidof(IDispatch), L"GetTypeInfoCount", 0, CC_STDCALL, std::nullopt, L"HRESULT" });
    insert_cotype_method_arg(__uuidof(IDispatch), 0, { L"this", L"void*", 0 }, 0);
    insert_cotype_method_arg(__uuidof(IDispatch), 0, { L"pctinfo", L"UINT*", IDLFLAG_FOUT }, 1);

    insert_cotype_method(comethod{ __uuidof(IDispatch), L"GetTypeInfo", 1, CC_STDCALL, std::nullopt, L"HRESULT" });
    insert_cotype_method_arg(__uuidof(IDispatch), 1, { L"this", L"void*", 0 }, 0);
    insert_cotype_method_arg(__uuidof(IDispatch), 1, { L"iTInfo", L"UINT", IDLFLAG_FIN }, 1);
    insert_cotype_method_arg(__uuidof(IDispatch), 1, { L"lcid", L"unsigned short", IDLFLAG_FIN }, 2);
    insert_cotype_method_arg(__uuidof(IDispatch), 1, { L"ppTInfo", L"ITypeInfo**", IDLFLAG_FOUT }, 3);

    insert_cotype_method(comethod{ __uuidof(IDispatch), L"GetIDsOfNames", 2, CC_STDCALL, std::nullopt, L"HRESULT" });
    insert_cotype_method_arg(__uuidof(IDispatch), 2, { L"this", L"void*", 0 }, 0);
    insert_cotype_method_arg(__uuidof(IDispatch), 2, { L"riid", L"GUID*", IDLFLAG_FIN }, 1);
    insert_cotype_method_arg(__uuidof(IDispatch), 2, { L"rgszNames", L"LPOLESTR*", IDLFLAG_FIN }, 2);
    insert_cotype_method_arg(__uuidof(IDispatch), 2, { L"cNames", L"UINT", IDLFLAG_FIN }, 3);
    insert_cotype_method_arg(__uuidof(IDispatch), 2, { L"lcid", L"unsigned short", IDLFLAG_FIN }, 4);
    insert_cotype_method_arg(__uuidof(IDispatch), 2, { L"rgDispId", L"DISPID*", IDLFLAG_FOUT }, 5);

    insert_cotype_method(comethod{ __uuidof(IDispatch), L"Invoke", 3, CC_STDCALL, std::nullopt, L"HRESULT" });
    insert_cotype_method_arg(__uuidof(IDispatch), 3, { L"this", L"void*", 0 }, 0);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"dispIdMember", L"DISPID", IDLFLAG_FIN }, 1);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"riid", L"GUID*", IDLFLAG_FIN }, 2);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"lcid", L"unsigned short", IDLFLAG_FIN }, 3);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"wFlags", L"unsigned short", IDLFLAG_FIN }, 4);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"pDispParams", L"DISPPARAMS*", IDLFLAG_FIN }, 5);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"pVarResult", L"VARIANT*", IDLFLAG_FOUT }, 6);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"pExcepInfo", L"EXCEPINFO*", IDLFLAG_FOUT }, 7);
    insert_cotype_method_arg(__uuidof(IDispatch), 3, comethod_arg{ L"puArgErr", L"unsigned int*", IDLFLAG_FOUT }, 8);

    transaction.commit();

    _known_iids.insert_range(std::array<IID, 2> { __uuidof(IUnknown), __uuidof(IDispatch) });
}

bool cometa::is_valid_db(const fs::path& path) {
    try {
        auto db{ std::make_unique<SQLite::Database>(to_utf8(path.c_str()), SQLite::OPEN_READWRITE) };
        SQLite::Statement query{ *db, "select version from schema_version" };
        return query.executeStep() && query.getColumn("version").getInt() == schema_version;
    } catch (...) {
        return false;
    }
}

void cometa::insert_cotype(const cotype& typedesc) {
    if (_known_iids.contains(typedesc.iid)) {
        return;
    }

    assert(_db);
    auto name_u8{ to_utf8(typedesc.name) };

    SQLite::Statement stmt{ *_db, R"(insert or replace into cotypes (iid, type, name, parent_iid, methods_available) 
    values (:iid, :type, :name, :parent_iid, :methods_available))" };
    stmt.bindNoCopy(":iid", &typedesc.iid, sizeof(GUID));
    stmt.bind(":type", static_cast<int>(typedesc.type));
    stmt.bindNoCopy(":name", name_u8);
    stmt.bindNoCopy(":parent_iid", &typedesc.parent_iid, sizeof(GUID));
    stmt.bind(":methods_available", static_cast<int>(typedesc.methods_available));

    stmt.exec();
}

void cometa::insert_cotype_method(const comethod& method) {
    if (_known_iids.contains(method.iid)) {
        return;
    }

    assert(_db);

    auto name_u8{ to_utf8(method.name) };
    auto return_type_u8{ to_utf8(method.return_type) };

    SQLite::Statement stmt{ *_db, R"(insert or replace into cotype_methods (iid, ordinal, name, dispid, callconv, return_type)
    values (:iid, :ordinal, :name, :dispid, :callconv, :return_type))" };
    stmt.bindNoCopy(":iid", &method.iid, sizeof(GUID));
    stmt.bind(":ordinal", method.ordinal);
    stmt.bindNoCopy(":name", name_u8);
    if (method.dispid) {
        stmt.bind(":dispid", static_cast<int>(*method.dispid));
    } else {
        stmt.bind(":dispid");
    }
    stmt.bind(":callconv", static_cast<int>(method.callconv));
    stmt.bindNoCopy(":return_type", return_type_u8);

    stmt.exec();
}

void cometa::insert_cotype_method_arg(const GUID& iid, int method_ordinal, const comethod_arg& arg, int arg_ordinal) {
    if (_known_iids.contains(iid)) {
        return;
    }

    assert(_db);

    auto name_u8{ to_utf8(arg.name) };
    auto type_u8{ to_utf8(arg.type) };

    SQLite::Statement stmt{ *_db, R"(insert or replace into cotype_method_args (iid, method_ordinal, ordinal, name, type, flags)
    values (:iid, :method_ordinal, :ordinal, :name, :type, :flags))" };
    stmt.bindNoCopy(":iid", &iid, sizeof(GUID));
    stmt.bind(":method_ordinal", method_ordinal);
    stmt.bind(":ordinal", arg_ordinal);
    stmt.bindNoCopy(":name", name_u8);
    stmt.bindNoCopy(":type", type_u8);
    stmt.bind(":flags", arg.flags);

    stmt.exec();
}

void cometa::insert_coclass(const coclass& classdesc) {
    assert(_db);
    auto name_u8{ to_utf8(classdesc.name) };

    SQLite::Statement stmt{ *_db, "insert or replace into coclasses (clsid, name) values (:clsid, :name)" };
    stmt.bindNoCopy(":clsid", &classdesc.clsid, sizeof(GUID));
    stmt.bindNoCopy(":name", name_u8);

    stmt.exec();
}

std::vector<covtable> cometa::get_module_vtables(const comodule& comodule) {
    assert(_db);
    auto module_name_u8{ to_utf8(comodule.name) };
    SQLite::Statement query{ *_db,
        "select clsid,iid,vtable from vtables where module_name = :module_name and module_timestamp = :module_timestamp" };
    query.bindNoCopy(":module_name", module_name_u8);
    query.bind(":module_timestamp", static_cast<const uint32_t>(comodule.timestamp));

    std::vector<covtable> vtables{};
    while (query.executeStep()) {
        vtables.push_back({
            *(reinterpret_cast<const GUID*>(query.getColumn("clsid").getBlob())),
            *(reinterpret_cast<const GUID*>(query.getColumn("iid").getBlob())),
            static_cast<ULONG>(query.getColumn("vtable").getInt64())
            });
    }
    return vtables;
}

void cometa::save_module_vtable(const comodule& comodule, const covtable& covtable) {
    assert(_db);
    auto module_name_u8{ to_utf8(comodule.name) };

    SQLite::Statement query{ *_db, R"(insert or replace into vtables (clsid, iid, module_name, module_timestamp, vtable) 
        values (:clsid, :iid, :module_name, :module_timestamp, :vtable))" };

    query.bindNoCopy(":clsid", &covtable.clsid, sizeof(GUID));
    query.bindNoCopy(":iid", &covtable.iid, sizeof(GUID));
    query.bindNoCopy(":module_name", module_name_u8);
    query.bind(":module_timestamp", static_cast<const uint32_t>(comodule.timestamp));
    query.bind(":vtable", static_cast<long long>(covtable.address));

    query.exec();
}

HRESULT cometa::index_tlb(std::wstring_view tlb_path) {
    using namespace std::literals;
    assert(_db);

    wil::com_ptr_t<ITypeLib> typelib{};
    RETURN_IF_FAILED(::LoadTypeLibEx(tlb_path.data(), REGKIND_NONE, typelib.put()));

    auto types_len = typelib->GetTypeInfoCount();
    for (UINT type_num = 0; type_num < types_len; type_num++) {
        wil::com_ptr_t<ITypeInfo> typeinfo{};
        RETURN_IF_FAILED(typelib->GetTypeInfo(type_num, typeinfo.put()));

        wil::unique_bstr name{};
        RETURN_IF_FAILED(typeinfo->GetDocumentation(MEMBERID_NIL, name.put(), nullptr, nullptr, nullptr));

        auto typeattr_res{ typelib::get_typeinfo_attr(typeinfo.get()) };
        if (std::holds_alternative<HRESULT>(typeattr_res)) {
            return std::get<HRESULT>(typeattr_res);
        }

        auto typeattr{ std::move(std::get<typelib::typeattr_t>(typeattr_res)) };
        switch (typeattr->typekind) {
        case TKIND_INTERFACE:
        case TKIND_DISPATCH: {
            auto kind{ typeattr->typekind == TKIND_INTERFACE ? cotype_kind::Interface : cotype_kind::DispInterface };

            auto get_type_name = [typeinfo, kind](const TYPEDESC* tdesc) {
                auto type_name{ typelib::get_type_desc(typeinfo.get(), tdesc) };
                return std::holds_alternative<std::wstring>(type_name) ? std::get<std::wstring>(type_name) :
                    std::wstring{ typelib::bad_type_name };
            };

            auto parent_iid_v{ typelib::get_type_parent_iid(typeinfo.get(), kind, typeattr->cImplTypes) };
            if (std::holds_alternative<HRESULT>(parent_iid_v)) {
                return std::get<HRESULT>(parent_iid_v);
            }
            auto& parent_iid{ std::get<GUID>(parent_iid_v) };

            auto funcdesc_deleter = [typeinfo](FUNCDESC* fd) { typeinfo->ReleaseFuncDesc(fd); };

            SQLite::Transaction transaction{ *_db };

            insert_cotype({ typeattr->guid, name.get(), kind, parent_iid, true });

            // TODO: typeattr->cVars for properties in dispinterfaces

            for (int ordinal = 0; ordinal < typeattr->cFuncs; ) {
                FUNCDESC* p_fd;
                RETURN_IF_FAILED(typeinfo->GetFuncDesc(ordinal, &p_fd));
                typelib::funcdesc_t fd{ p_fd, funcdesc_deleter };

                if (auto names_v{ typelib::get_comethod_names(typeinfo.get(), fd.get()) }; std::holds_alternative<HRESULT>(names_v)) {
                    return std::get<HRESULT>(names_v);
                } else {
                    auto& names = std::get<std::vector<wil::unique_bstr>>(names_v);
                    assert(names.size() > 0);

                    if (ordinal == 0 && names[0].get() == L"QueryInterface"sv) {
                        // skip IUnknown
                        ordinal += 3;
                        continue;
                    }
                    if ((ordinal == 0 || ordinal == 3) && names[0].get() == L"GetTypeInfoCount"sv) {
                        // skip IDispatch
                        ordinal += 4;
                        continue;
                    }

                    std::wstring method_name{ names[0].get() };
                    if (fd->invkind & INVOKE_PROPERTYPUTREF) {
                        method_name.insert(0, L"putref_");
                    } else if (fd->invkind & INVOKE_PROPERTYPUT) {
                        method_name.insert(0, L"put_");
                    } else if (fd->invkind & INVOKE_PROPERTYGET) {
                        method_name.insert(0, L"get_");
                    }
                    std::optional<DISPID> dispid = kind == cotype_kind::DispInterface ? std::make_optional(fd->memid) : std::nullopt;

                    assert((SHORT)names.size() == fd->cParams + 1);

                    // first parameter is this pointer
                    int arg_ordinal{};
                    insert_cotype_method_arg(typeattr->guid, ordinal, { L"this", L"void*", 0 }, arg_ordinal);
                    arg_ordinal += 1;

                    for (int param_num = 0; param_num < fd->cParams; param_num++) {
                        auto elem_desc{ fd->lprgelemdescParam + param_num };
                        comethod_arg arg{
                            std::wstring { names[param_num + 1].get()},
                            get_type_name(&elem_desc->tdesc),
                            elem_desc->idldesc.wIDLFlags
                        };
                        insert_cotype_method_arg(typeattr->guid, ordinal, arg, arg_ordinal);
                        arg_ordinal += 1;
                    }

                    auto result_vt{ fd->elemdescFunc.tdesc.vt & 0xFFF };
                    if (kind == cotype_kind::DispInterface && result_vt != VT_HRESULT && result_vt != VT_VOID) {
                        // the return value is passed as an out parameter
                        TYPEDESC tdesc{ .lptdesc = &fd->elemdescFunc.tdesc, .vt = VT_PTR };
                        comethod_arg arg{
                            std::wstring { L"result" },
                            get_type_name(&tdesc),
                            IDLFLAG_FOUT | IDLFLAG_FRETVAL
                        };
                        insert_cotype_method_arg(typeattr->guid, ordinal, arg, arg_ordinal);

                        insert_cotype_method({ typeattr->guid, method_name, ordinal, fd->callconv, dispid, typelib::vt_to_string(VT_HRESULT) });
                    } else {
                        insert_cotype_method({ typeattr->guid, method_name, ordinal, fd->callconv, dispid, get_type_name(&fd->elemdescFunc.tdesc) });
                    }

                    // TODO: I'm still missing handling of the optional parameters

                    ordinal += 1;
                }
            }

            transaction.commit();
            break;
        }
        case TKIND_COCLASS: {
            insert_coclass({ typeattr->guid, name.get() });
            break;
        }
        default:
            break;
        }
    }

    return S_OK;
}

HRESULT cometa::save([[maybe_unused]] std::wstring_view dbpath) {
    assert(_db);
    try {
        _db->backup(to_utf8(dbpath).c_str(), SQLite::Database::BackupType::Save);
        return S_OK;
    } catch (const SQLite::Exception& ex) {
        _logger.log_error(std::format(L"Error {} when trying to save COM metadata database: '{}'.",
            ex.getErrorCode(), widen(ex.getErrorStr())), E_FAIL);
        return E_FAIL;
    }
}

HRESULT cometa::index() {
    assert(_db);

    auto index_typelibs = [this]() {
        // HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Wow6432Node\Typelib is linked to HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Typelib
        // so we don't need to query it. However, the typelibs may contain both win32 and win64 folders, for example:
        // 
        // Computer\HKEY_CLASSES_ROOT\WOW6432Node\TypeLib\{00000201-0000-0010-8000-00AA006D2EA4}
        // - 2.1
        //   - 0
        //     - win32 -> C:\Program Files (x86)\Common Files\System\ado\msado21.tlb
        //     - win64 -> C:\Program Files\Common Files\System\ado\msado21.tlb
        //   - FLAGS
        _logger.log_info(L"\nIndexing TypeLibraries...");

        wil::unique_hkey typelibs_hkey{};
        RETURN_IF_WIN32_ERROR(::RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\TypeLib", 0, KEY_READ, typelibs_hkey.put()));
        for (const auto& name : registry::get_child_key_names(typelibs_hkey.get())) {
            wil::unique_hkey typelib_hkey{};
            if (auto err{ ::RegOpenKeyEx(typelibs_hkey.get(), name.c_str(), 0, KEY_READ, typelib_hkey.put()) }; err != NO_ERROR) {
                _logger.log_error(name, HRESULT_FROM_WIN32(err));
                continue;
            }

            if (auto ti{ typelib::get_tlbinfo(typelib_hkey.get()) }; std::holds_alternative<HRESULT>(ti)) {
                auto hr = std::get<HRESULT>(ti);
                _logger.log_error(name, hr);
            } else {
                auto& tlbinfo{ std::get<typelib_info>(ti) };
                if (auto hr{ index_tlb(tlbinfo.tlb_path.c_str()) }; SUCCEEDED(hr)) {
                    _logger.log_info_dml(std::format(L"{} ({}) : <col fg=\"srccmnt\">PARSED</col>", name, tlbinfo.name));
                } else {
                    _logger.log_error(std::format(L"{} ({})", name, tlbinfo.name), hr);
                }
            }
        }
        return S_OK;
    };

    auto index_coclasses = [this](bool request_wow6432 = false) {
        _logger.log_info(request_wow6432 ? L"Indexing CLSIDs... (only errors are reported) - 32-bit" :
            L"Indexing CLSIDs... (only errors are reported)");

        auto flags{ request_wow6432 ? KEY_READ | KEY_WOW64_32KEY : KEY_READ };
        wil::unique_hkey clsids_hkey{};
        RETURN_IF_WIN32_ERROR(::RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\CLSID", 0, flags, clsids_hkey.put()));
        for (const auto& name : registry::get_child_key_names(clsids_hkey.get())) {
            if (name == L"CLSID") {
                // special key name to skip
                continue;
            }

            GUID clsid{};
            if (auto hr{ try_parse_guid(name, clsid) }; FAILED(hr)) {
                _logger.log_error(name, hr);
                continue;
            }

            wil::unique_hkey clsid_hkey{};
            if (auto err{ ::RegOpenKeyEx(clsids_hkey.get(), name.c_str(), 0, KEY_READ, clsid_hkey.put()) }; err != NO_ERROR) {
                auto hr{ HRESULT_FROM_WIN32(err) };
                _logger.log_error(name, hr);
                continue;
            }

            if (auto v{ registry::read_text_value(clsid_hkey.get(), nullptr, nullptr) }; std::holds_alternative<HRESULT>(v)) {
                insert_coclass({ .clsid = clsid, .name = L"" });
            } else {
                insert_coclass({ .clsid = clsid, .name = std::get<std::wstring>(v) });
            }
        }
        return S_OK;
    };

    auto index_interfaces = [this](bool request_wow6432 = false) {
        _logger.log_info(request_wow6432 ? L"Indexing interfaces... (only errors are reported) - 32-bit" :
            L"Indexing interfaces... (only errors are reported)");

        auto flags{ request_wow6432 ? KEY_READ | KEY_WOW64_32KEY : KEY_READ };
        wil::unique_hkey interfaces_hkey{};
        RETURN_IF_WIN32_ERROR(::RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Classes\\Interface", 0, flags, interfaces_hkey.put()));
        for (const auto& name : registry::get_child_key_names(interfaces_hkey.get())) {
            GUID iid{};
            if (auto hr{ try_parse_guid(name, iid) }; FAILED(hr)) {
                _logger.log_error(name, hr);
                continue;
            }

            wil::unique_hkey iid_hkey{};
            if (auto err{ ::RegOpenKeyEx(interfaces_hkey.get(), name.c_str(), 0, KEY_READ, iid_hkey.put()) }; err != NO_ERROR) {
                _logger.log_error(name, HRESULT_FROM_WIN32(err));
                continue;
            }

            if (auto v{ registry::read_text_value(iid_hkey.get(), nullptr, nullptr) }; std::holds_alternative<HRESULT>(v)) {
                insert_cotype({ iid, L"", cotype_kind::Interface, __uuidof(IUnknown), false });
            } else {
                insert_cotype({ iid, std::get<std::wstring>(v), cotype_kind::Interface, __uuidof(IUnknown), false });
            }
        }

        invalidate_cache();

        return S_OK;
    };

    // index 32-bit nodes first before indexing 64-bit
    RETURN_IF_FAILED(index_coclasses(_is_wow64));
    RETURN_IF_FAILED(index_interfaces(_is_wow64));

    RETURN_IF_FAILED(index_typelibs());

    return S_OK;
}

std::optional<cotype> cometa::resolve_type(const IID& iid) {
    if (_cotype_cache.contains(iid)) {
        return _cotype_cache.get(iid);
    }

    assert(_db);
    SQLite::Statement query{ *_db, "select * from cotypes where iid = :iid" };
    query.bindNoCopy(":iid", &iid, sizeof(IID));

    auto result{ !query.executeStep() ? std::nullopt :
        std::make_optional(cotype{ iid, from_utf8(query.getColumn("name").getText()),
            static_cast<cotype_kind>(query.getColumn("type").getInt()),
            *(reinterpret_cast<const GUID*>(query.getColumn("parent_iid").getBlob())),
            static_cast<bool>(query.getColumn("methods_available").getInt()) }) };
    _cotype_cache.insert(iid, result);

    return result;
}

std::optional<method_collection> cometa::get_type_methods(const IID& iid) {
    assert(_db);
    auto query_methods = [this](const IID& iid) {
        SQLite::Statement method_query{ *_db, "select * from cotype_methods where iid = :iid order by ordinal" };
        method_query.bindNoCopy(":iid", &iid, sizeof(IID));
        method_collection methods{};
        while (method_query.executeStep()) {
            auto dispid_column{ method_query.getColumn("dispid") };

            methods.push_back({
                .iid = iid,
                .name = from_utf8(method_query.getColumn("name").getText()),
                .ordinal = method_query.getColumn("ordinal").getInt(),
                .callconv = static_cast<CALLCONV>(method_query.getColumn("callconv").getInt()),
                .dispid = !dispid_column.isNull() ? std::optional<DISPID>{ dispid_column.getInt() } : std::nullopt,
                .return_type = from_utf8(method_query.getColumn("return_type").getText()) });
        }
        return methods;
    };

    if (auto type{ resolve_type(iid) }; type && type->methods_available) {
        if (auto methods{ query_methods(iid) }; methods.size() == 0 || methods.at(0).name != L"QueryInterface") {
            // The initial methods must be from the IUnknown interface. We will try to resolve the parent type...
            if (auto parent_methods{ get_type_methods(type->parent_iid) }; parent_methods) {
                std::ranges::copy(std::crbegin(*parent_methods), std::crend(*parent_methods), std::front_inserter(methods));
                return methods;
            } else {
                // we are missing some interface methods - it's safer to show nothing
                return std::nullopt;
            }
        } else {
            return methods;
        }
    }
    return std::nullopt;
}

std::optional<method_arg_collection> cometa::get_type_method_args(const comethod& method) {
    assert(_db);
    if (auto type{ resolve_type(method.iid) }; type && type->methods_available) {
        SQLite::Statement arg_query{ *_db, "select * from cotype_method_args where iid = :iid and method_ordinal = :method_ordinal order by ordinal" };
        arg_query.bindNoCopy(":iid", &method.iid, sizeof(IID));
        arg_query.bind(":method_ordinal", method.ordinal);

        method_arg_collection args{};
        while (arg_query.executeStep()) {
            args.push_back({
                .name = from_utf8(arg_query.getColumn("name").getText()),
                .type = from_utf8(arg_query.getColumn("type").getText()),
                .flags = static_cast<USHORT>(arg_query.getColumn("flags").getUInt()) });
        }
        return args;
    } else {
        return std::nullopt;
    }
}

std::optional<coclass> cometa::resolve_class(const CLSID& clsid) {
    if (_coclass_cache.contains(clsid)) {
        return _coclass_cache.get(clsid);
    }

    assert(_db);
    SQLite::Statement query{ *_db, "select * from coclasses where clsid = :clsid" };
    query.bindNoCopy(":clsid", &clsid, sizeof(CLSID));
    auto result{ !query.executeStep() ? std::nullopt :
        std::make_optional(coclass{ clsid, from_utf8(query.getColumn("name").getText()) })
    };
    return result;
}

std::vector<std::tuple<std::wstring, CLSID, ULONG64>> cometa::find_vtables_by_iid(const IID& iid) {
    SQLite::Statement query{ *_db, "select module_name,clsid,vtable from vtables where iid = :iid" };
    query.bindNoCopy(":iid", &iid, sizeof(IID));

    std::vector<std::tuple<std::wstring, CLSID, ULONG64>> vtables{};
    while (query.executeStep()) {
        vtables.push_back({
            from_utf8(query.getColumn("module_name").getString()),
            *(reinterpret_cast<const GUID*>(query.getColumn("clsid").getBlob())),
            query.getColumn("vtable").getInt64()
            });
    }
    return vtables;
}

std::vector<std::tuple<std::wstring, IID, ULONG64>> cometa::find_vtables_by_clsid(const CLSID& clsid) {
    SQLite::Statement query{ *_db, "select module_name,iid,vtable from vtables where clsid = :clsid" };
    query.bindNoCopy(":clsid", &clsid, sizeof(CLSID));

    std::vector<std::tuple<std::wstring, IID, ULONG64>> vtables{};
    while (query.executeStep()) {
        vtables.push_back({
            from_utf8(query.getColumn("module_name").getString()),
            *(reinterpret_cast<const GUID*>(query.getColumn("iid").getBlob())),
            query.getColumn("vtable").getInt64()
            });
    }
    return vtables;
}

std::vector<std::tuple<ULONG, CLSID>> cometa::find_clsids_by_module_name(const std::wstring& module_name) {
    SQLite::Statement query{ *_db, "select distinct module_timestamp,clsid from vtables where module_name = :module_name" };
    auto module_name_u8{ to_utf8(module_name) };
    query.bindNoCopy(":module_name", module_name_u8.c_str());

    std::vector<std::tuple<ULONG, CLSID>> vtables{};
    while (query.executeStep()) {
        vtables.push_back({
            query.getColumn("module_timestamp").getUInt(),
            *(reinterpret_cast<const GUID*>(query.getColumn("clsid").getBlob()))
            });
    }
    return vtables;
}

```

`comon/cometa.h`:

```h
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once

#include <format>
#include <optional>
#include <deque>
#include <unordered_set>
#include <unordered_map>
#include <filesystem>
#include <variant>
#include <functional>
#include <array>

#include <SQLiteCpp/Database.h>

#include "comon.h"
#include "lfu_cache.h"

namespace fs = std::filesystem;

namespace comon_ext
{
enum class cotype_kind
{
    Interface,
    DispInterface
};

struct covtable
{
    const CLSID clsid;
    const IID iid;
    const ULONG64 address;
};

struct comodule
{
    const std::wstring_view name;
    const ULONG timestamp;
    const bool is_64bit;
};

struct cotype
{
    GUID iid{};
    std::wstring name;
    cotype_kind type{};
    GUID parent_iid{};
    bool methods_available{};
};

struct coclass
{
    GUID clsid{};
    std::wstring name;
};

struct comethod
{
    GUID iid{};
    std::wstring name;
    int ordinal;
    CALLCONV callconv;
    std::optional<DISPID> dispid{};
    std::wstring return_type;
};

struct comethod_arg
{
    std::wstring name;
    std::wstring type;
    USHORT flags; // IDLFLAG_NONE, IDLFLAG_FIN, IDLFLAG_FOUT, IDLFLAG_FRETVAL, etc.
};

struct typelib_info
{
    std::wstring name;
    std::wstring version;
    std::wstring tlb_path;
};

using method_collection = std::deque<comethod>;
using method_arg_collection = std::vector<comethod_arg>;

class cometa
{
    const std::unique_ptr<SQLite::Database> _db;
    const dbgeng_logger _logger;
    const bool _is_wow64;

    std::unordered_set<IID> _known_iids{};

    lfu_cache<IID, const std::optional<const cotype>> _cotype_cache{ 100 };
    lfu_cache<CLSID, const std::optional<const coclass>> _coclass_cache{ 50 };

    HRESULT index_tlb(std::wstring_view tlb_path);

    void fill_known_iids();

    void insert_cotype(const cotype& typedesc);
    void insert_cotype_method(const comethod& method);
    void insert_cotype_method_arg(const GUID& iid, int method_ordinal, const comethod_arg& arg, int arg_ordinal);
    void insert_coclass(const coclass& classdesc);

    static std::unique_ptr<SQLite::Database> init_db(const fs::path& path, IDebugControl4* dbgcontrol);
    static std::unique_ptr<SQLite::Database> open_db(const fs::path& path, IDebugControl4* dbgcontrol);

public:

    static bool is_valid_db(const fs::path& path);

    explicit cometa(IDebugControl4* dbgcontrol, bool is_wow64, const fs::path& db_path, bool create_new);

    void invalidate_cache() {
        _cotype_cache.clear();
        _coclass_cache.clear();
    }

    HRESULT index();

    HRESULT index(std::wstring_view tlb_path) {
        if (!_db) {
            _logger.log_error(L"no open database", E_FAIL);
            return E_FAIL;
        }

        if (auto hr{ index_tlb(tlb_path) }; SUCCEEDED(hr)) {
            _logger.log_info_dml(std::format(L"'{}' : <col fg=\"srccmnt\">PARSED</col>", tlb_path));

            invalidate_cache();

            return S_OK;
        } else {
            _logger.log_error_dml(std::format(L"'{}'", tlb_path), hr);
            return hr;
        }
    }

    HRESULT save(std::wstring_view dbpath);

    std::optional<std::wstring> resolve_type_name(const IID& iid) {
        if (auto t{ resolve_type(iid) }; t) {
            return t->name;
        }
        return std::nullopt;
    }

    std::optional<cotype> resolve_type(const IID& iid);

    std::optional<coclass> resolve_class(const CLSID& clsid);

    std::vector<std::tuple<std::wstring, CLSID, ULONG64>> find_vtables_by_iid(const IID& iid);

    std::vector<std::tuple<std::wstring, IID, ULONG64>> find_vtables_by_clsid(const CLSID& clsid);
    
    std::vector<std::tuple<ULONG, CLSID>> find_clsids_by_module_name(const std::wstring& module_name);

    std::optional<method_collection> get_type_methods(const IID& iid);
    std::optional<method_arg_collection> get_type_method_args(const comethod& method);

    std::optional<std::wstring> resolve_class_name(const CLSID& clsid) {
        if (auto c{ resolve_class(clsid) }; c) {
            return c->name;
        }
        return std::nullopt;
    }

    void save_module_vtable(const comodule& comodule, const covtable& covtable);

    std::vector<covtable> get_module_vtables(const comodule& comodule);
};

namespace registry
{
std::vector<std::wstring> get_child_key_names(HKEY parent_hkey);

std::variant<std::wstring, HRESULT> read_text_value(HKEY hkey, const wchar_t* subkey, const wchar_t* value_name);
}

namespace typelib
{

using typeattr_t = std::unique_ptr<TYPEATTR, std::function<void(TYPEATTR*)>>;
using funcdesc_t = std::unique_ptr<FUNCDESC, std::function<void(FUNCDESC*)>>;

constexpr std::wstring_view bad_type_name{ L"BAD_TYPE" };

std::variant<typelib_info, HRESULT> get_tlbinfo(HKEY typelib_hkey);

std::variant<typeattr_t, HRESULT> get_typeinfo_attr(ITypeInfo* typeinfo);

std::variant<GUID, HRESULT> get_type_parent_iid(ITypeInfo* typeinfo, cotype_kind kind, WORD parent_type_cnt);

std::wstring vt_to_string(VARTYPE vt);

std::variant<HRESULT, std::wstring> get_type_desc(ITypeInfo* typeinfo, const TYPEDESC* desc);

std::variant<HRESULT, std::vector<wil::unique_bstr>> get_comethod_names(ITypeInfo* typeinfo, const FUNCDESC* fd);
}

}

```

`comon/cometa_helpers.cpp`:

```cpp

#include <array>
#include <functional>
#include <ranges>
#include <sstream>
#include <string>
#include <format>
#include <compare>

#include "cometa.h"
#include "arch.h"

namespace ranges = std::ranges;

using namespace comon_ext;

namespace {

class version
{
    std::array<int32_t, 4> _version_nums{};

public:
    version(const std::wstring& version): _version{ version } {
        std::wistringstream wss{ version };
        std::wstring token{};

        for (size_t i = 0; wss.good() && i < _version_nums.size(); i++) {
            std::getline(wss, token, L'.');
            _version_nums[i] = std::stoi(token, nullptr, 16);
        }
    }

    [[nodiscard]] bool operator==(const version& rhs) const {
        return std::lexicographical_compare_three_way(_version_nums.cbegin(), _version_nums.cend(),
            rhs._version_nums.cbegin(), rhs._version_nums.cend()) == std::strong_ordering::equal;
    }

    std::strong_ordering operator<=>(const version& rhs) const {
        return std::lexicographical_compare_three_way(_version_nums.cbegin(), _version_nums.cend(),
            rhs._version_nums.cbegin(), rhs._version_nums.cend());
    }

    std::wstring _version;
};

}

std::vector<std::wstring> registry::get_child_key_names(HKEY parent_hkey) {
    std::vector<std::wstring> key_names{};

    std::array<wchar_t, 256> key_name{};
    for (DWORD i = 0; ; i++) {
        auto len{ static_cast<DWORD>(key_name.size()) };
        auto enum_result{ ::RegEnumKeyEx(parent_hkey, i, key_name.data(), &len, nullptr, nullptr, nullptr, nullptr) };
        if (enum_result == ERROR_NO_MORE_ITEMS) {
            break;
        }
        assert(enum_result != ERROR_MORE_DATA);
        if (enum_result != NO_ERROR) {
            LOG_WIN32(enum_result);
            break;
        }

        key_names.push_back(std::wstring{ key_name.data(), len });
    }

    return key_names;
}

std::variant<std::wstring, HRESULT> registry::read_text_value(HKEY hkey, const wchar_t* subkey, const wchar_t* value_name) {
    DWORD len = 1024;
    auto buffer{ std::make_unique<wchar_t[]>(len) };

    auto win32err{ ::RegGetValue(hkey, subkey, value_name, RRF_RT_REG_SZ | RRF_RT_REG_EXPAND_SZ, nullptr, buffer.get(), &len) };
    if (win32err == ERROR_MORE_DATA) {
        buffer = std::make_unique<wchar_t[]>(len);
        win32err = ::RegGetValue(hkey, subkey, value_name, RRF_RT_REG_SZ | RRF_RT_REG_EXPAND_SZ, nullptr, buffer.get(), &len);
    }

    RETURN_IF_WIN32_ERROR(win32err);

    return std::wstring{ buffer.get() };
}

std::variant<typelib_info, HRESULT> typelib::get_tlbinfo(HKEY typelib_hkey) {
    std::vector<version> versions{};
    ranges::transform(registry::get_child_key_names(typelib_hkey), std::back_inserter(versions),
        [](const std::wstring& v) { return version{ v }; });

    auto latest_version{ ranges::max_element(versions) };
    if (latest_version != std::end(versions)) {
        wil::unique_hkey latest_version_hkey{};
        RETURN_IF_WIN32_ERROR(::RegOpenKeyEx(typelib_hkey, latest_version->_version.c_str(), 0, KEY_READ, latest_version_hkey.put()));
        auto name_kv{ registry::read_text_value(latest_version_hkey.get(), nullptr, nullptr) };
        if (std::holds_alternative<HRESULT>(name_kv)) {
            return std::get<HRESULT>(name_kv);
        }

#if ARCH_X64
        auto path_kv{ registry::read_text_value(latest_version_hkey.get(), L"0\\win64", nullptr) };
#else
        auto path_kv{ registry::read_text_value(latest_version_hkey.get(), L"0\\win32", nullptr) };
#endif

        if (std::holds_alternative<HRESULT>(path_kv)) {
            return std::get<HRESULT>(path_kv);
        }

        return typelib_info{ std::get<std::wstring>(name_kv), latest_version->_version, std::get<std::wstring>(path_kv) };
    }

    return E_INVALIDARG;
}

std::variant<typelib::typeattr_t, HRESULT> typelib::get_typeinfo_attr(ITypeInfo* typeinfo) {
    auto typeattr_deleter = [typeinfo](TYPEATTR* ta) { typeinfo->ReleaseTypeAttr(ta); };

    TYPEATTR* pypeattr;
    RETURN_IF_FAILED(typeinfo->GetTypeAttr(&pypeattr));

    return typeattr_t{ pypeattr, typeattr_deleter };
}

std::variant<GUID, HRESULT> typelib::get_type_parent_iid(ITypeInfo* typeinfo, cotype_kind kind, WORD parentype_cnt) {
    if (parentype_cnt == 0) {
        return kind == cotype_kind::DispInterface ? __uuidof(IDispatch) : __uuidof(IUnknown);
    }
    assert(parentype_cnt == 1);
    HREFTYPE href = NULL;
    RETURN_IF_FAILED(typeinfo->GetRefTypeOfImplType(0, &href));

    wil::com_ptr<ITypeInfo> parenti{};
    RETURN_IF_FAILED(typeinfo->GetRefTypeInfo(href, parenti.put()));

    auto attr_res{ get_typeinfo_attr(parenti.get()) };
    if (std::holds_alternative<HRESULT>(attr_res)) {
        return std::get<HRESULT>(attr_res);
    }
    return std::get<typeattr_t>(attr_res)->guid;
};

std::variant<HRESULT, std::vector<wil::unique_bstr>> typelib::get_comethod_names(ITypeInfo* typeinfo, const FUNCDESC* fd) {
    // max parameters to a function
    constexpr int max_method_args_number{ 64 };

    if (fd->cParams >= max_method_args_number) {
        return E_INVALIDARG;
    }

    std::array<BSTR, max_method_args_number> names{};

    // This is a comment from the source code of oleview (one of VS samples) - it explains
    // the logic behind the following code.

    // Problem:  If a property has the propput or propputref attributes the
    // 'right hand side' (rhs) is *always* the last parameter and MkTypeLib
    // strips the parameter name.  Thus you will always get 1 less name
    // back from ::GetNames than normal.

    // Thus for the example below
    //  [propput] void Color([in] VARIANT rgb, [in] VARIANT rgb2 );
    // without taking this into consderation the output would be
    //  [propput] void Color([in] VARIANT rgb, [in] VARIANT );
    // when it should be
    //  [propput] void Color([in] VARIANT rgb, [in] VARIANT rhs );

    // Another weirdness comes from a bug (which will never be fixed)
    // where optional parameters on property functions were allowed.
    // Because they were allowed by accident people used them, so they
    // are still allowed.

    UINT names_count{};
    RETURN_IF_FAILED(typeinfo->GetNames(fd->memid, names.data(), static_cast<UINT>(names.size()), &names_count));

    // fix for 'rhs' problem
    if ((SHORT)names_count <= fd->cParams) {
        names[names_count] = ::SysAllocString(L"rhs");
        names_count++;
    }

    std::vector<wil::unique_bstr> result{};
    result.reserve(names_count);
    std::transform(std::begin(names), std::begin(names) + names_count, std::back_inserter(result),
        [](BSTR bstr) { return wil::unique_bstr{ bstr }; });

    return result;
}

std::wstring typelib::vt_to_string(VARTYPE vt)
{
    static const std::unordered_map<int, std::wstring_view> vt_names = {
        { VT_EMPTY, L"void" }, { VT_NULL, L"null" }, { VT_I2, L"short" }, { VT_I4, L"long" },
        { VT_R4, L"single" }, { VT_R8, L"double" }, { VT_CY, L"CURRENCY" }, { VT_DATE, L"DATE" },
        { VT_BSTR, L"BSTR" }, { VT_DISPATCH, L"IDispatch*" }, { VT_ERROR, L"SCODE" }, { VT_BOOL, L"bool" },
        { VT_VARIANT, L"VARIANT" }, { VT_UNKNOWN, L"IUnknown*" }, { VT_DECIMAL, L"DECIMAL" }, { VT_I1, L"char" },
        { VT_UI1, L"unsigned char" }, { VT_UI2, L"unsigned short" }, { VT_UI4, L"unsigned long" }, { VT_I8, L"int64" },
        { VT_UI8, L"uint64" }, { VT_INT, L"int" }, { VT_UINT, L"unsigned int" }, { VT_VOID, L"void" },
        { VT_HRESULT, L"HRESULT" }, { VT_PTR, L"void*" }, { VT_INT_PTR, L"int*" }, { VT_UINT_PTR, L"unsigned int*" },
        { VT_SAFEARRAY, L"SAFEARRAY" }, { VT_CARRAY, L"CARRAY" }, { VT_USERDEFINED, L"USERDEFINED" },
        { VT_LPSTR, L"LPSTR" }, { VT_LPWSTR, L"LPWSTR" }, { VT_FILETIME, L"FILETIME" },
        { VT_BLOB, L"BLOB" }, { VT_STREAM, L"STREAM" }, { VT_STORAGE, L"STORAGE" }, { VT_STREAMED_OBJECT, L"STREAMED_OBJECT" },
        { VT_STORED_OBJECT, L"STORED_OBJECT" }, { VT_BLOB_OBJECT, L"BLOB_OBJECT" }, { VT_CF, L"CF" }, { VT_CLSID, L"GUID" }
    };

    vt &= ~0xF000;
    if (auto it = vt_names.find(vt); it != std::end(vt_names)) {
        return std::wstring { it->second };
    } else {
        return std::wstring { bad_type_name };
    }
}

std::variant<HRESULT, std::wstring> typelib::get_type_desc(ITypeInfo* typeinfo, const TYPEDESC* desc) {
    std::variant<HRESULT, std::wstring> result;
    if (desc->vt == VT_PTR || (desc->vt & 0x0FFF) == VT_SAFEARRAY) {
        if (auto v{ get_type_desc(typeinfo, desc->lptdesc) }; std::holds_alternative<HRESULT>(v)) {
            result = std::get<HRESULT>(v);
        } else if (desc->vt == VT_PTR) {
            result = std::get<std::wstring>(v) + L"*";
        } else if ((desc->vt & 0x0FFF) == VT_SAFEARRAY) {
            result = L"SAFEARRAY(" + std::get<std::wstring>(v) + L"";
        } else {
            assert(false);
        }
    } else if ((desc->vt & 0x0FFF) == VT_CARRAY) {
        if (auto v{ get_type_desc(typeinfo, &desc->lpadesc->tdescElem) }; std::holds_alternative<HRESULT>(v)) {
            result = std::get<HRESULT>(v);
        } else {
            std::wstring type_desc = std::get<std::wstring>(v);
            for (USHORT n = 0; n < desc->lpadesc->cDims; n++)
            {
                type_desc += std::format(L"[{}]", desc->lpadesc->rgbounds[n].cElements);
            }
            result = type_desc;
        }
    } else if (desc->vt == VT_USERDEFINED) {
        wil::com_ptr_t<ITypeInfo> ref_typeinfo{};
        RETURN_IF_FAILED(typeinfo->GetRefTypeInfo(desc->hreftype, ref_typeinfo.put()));

        wil::unique_bstr name{};
        RETURN_IF_FAILED(ref_typeinfo->GetDocumentation(MEMBERID_NIL, name.put(), nullptr, nullptr, nullptr));
        result = std::wstring{ name.get() };
    } else {
        result = vt_to_string(desc->vt);
    }

    return result;
}

```

`comon/comon.h`:

```h
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once

#include <string>
#include <format>
#include <unordered_set>
#include <unordered_map>
#include <span>

#include <Windows.h>
#include <DbgEng.h>

#include <wil/com.h>

namespace comon_ext
{
std::wstring widen(std::string_view s);

std::string narrow(std::wstring_view ws);

std::string to_utf8(std::wstring_view ws);

std::wstring from_utf8(std::string_view s);

std::wstring wstring_from_guid(const GUID& guid);

HRESULT try_parse_guid(std::wstring_view ws, GUID& guid);

GUID parse_guid(std::wstring_view ws);
}

// inspired by boost container hash
template <typename T>
inline void hash_combine(std::size_t& seed, const T& v) {
    std::hash<T> hasher;
    seed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
}

template<> struct std::hash<GUID>
{
    std::size_t operator()(const GUID& g) const noexcept {
        const unsigned long* r{ &g.Data1 };
        return *r ^ *(r + 1) ^ *(r + 2) ^ *(r + 3);
    }
};

template<> struct std::hash<std::pair<CLSID, IID>>
{
    std::size_t operator()(const std::pair<CLSID, IID>& p) const noexcept {
        std::hash<GUID> hasher{};
        auto seed{ hasher(p.first) };
        hash_combine(seed, p.second);
        return seed;
    }
};

template<>
class std::formatter<GUID, wchar_t>
{
public:
    constexpr auto parse(auto& context) {
        auto iter{ context.begin() };
        const auto end{ context.end() };
        if (iter == end || *iter == L'}') {  // {} format specifier
            _output_type = L'd';
            return iter;
        }

        switch (*iter) {
        case L'n':
        case L'd':
        case L'b':
            _output_type = *iter;
            break;
        default:
            throw std::format_error{ "Invalid GUID format specifier." };
        }

        ++iter;
        if (iter != end && *iter != L'}') {
            throw format_error{ "Invalid GUID format specifier." };
        }

        return iter;
    }

    auto format(const GUID& g, auto& context) const {
        auto gstr{ comon_ext::wstring_from_guid(g) };

        if (_output_type == L'n') {
            auto iter{ gstr.begin() };
            while (iter != gstr.end()) {
                if (*iter == L'{' || *iter == L'}' || *iter == L'-') {
                    iter = gstr.erase(iter);
                } else {
                    iter++;
                }
            }
        } else if (_output_type != L'b') {
            gstr.erase(0, 1);
            gstr.pop_back();
        }

        return format_to(context.out(), L"{}", gstr.c_str());
    }

private:
    wchar_t _output_type{ L'd' };
};

#define RETURN_VOID_IF_FAILED(hr)  __WI_SUPPRESS_4127_S do { const auto __hrRet = wil::verify_hresult(hr); if (FAILED(__hrRet)) { __R_INFO_ONLY(#hr); return; }} __WI_SUPPRESS_4127_E while ((void)0, 0)

namespace comon_ext
{

class dbgeng_logger
{
private:
    const wil::com_ptr<IDebugControl4> _dbgcontrol;

public:
    static std::wstring_view get_error_msg(HRESULT hr) {
        static std::unordered_map<HRESULT, std::wstring> error_messages{};
        if (!error_messages.contains(hr)) {
            wchar_t error_msg[256];
            auto cnt{ ::FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr,
                hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), error_msg, ARRAYSIZE(error_msg), nullptr) };
            if (cnt == 0) {
                return L"";
            }
            // skip new line at the end
            if (cnt >= 2 && error_msg[cnt - 2] == '\r' && error_msg[cnt - 1] == '\n') {
                cnt -= 2;
            }

            error_messages.insert({ hr, { error_msg, cnt } });
        }
        return error_messages.at(hr);
    };

    dbgeng_logger(IDebugControl4* dbgcontrol):
        _dbgcontrol{ dbgcontrol } {}

    void log_info(std::wstring_view message) const {
        LOG_IF_FAILED(_dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, std::format(L"[comon] {}\n", message).c_str()));
    }

    void log_info_dml(std::wstring_view message) const {
        LOG_IF_FAILED(_dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
            std::format(L"[comon] {}\n", message).c_str()));
    }

    void log_warning(std::wstring_view message) const {
        LOG_IF_FAILED(_dbgcontrol->OutputWide(DEBUG_OUTPUT_WARNING, std::format(L"[comon] {}\n", message).c_str()));
    }

    void log_error(std::wstring_view message, HRESULT hr) const {
        log_error_dml(message, hr);
    }

    void log_error_dml(std::wstring_view message, HRESULT hr) const {
        LOG_IF_FAILED(_dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_ERROR,
            std::format(L"[comon] {}, <col fg=\"srcstr\">error: {:#x} - {}</col>\n",
                message, static_cast<unsigned long>(hr), get_error_msg(hr)).c_str()));
    }
};
}


```

`comon/comonitor.cpp`:

```cpp
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <algorithm>
#include <array>
#include <cassert>
#include <filesystem>
#include <format>
#include <ranges>
#include <string>
#include <utility>
#include <memory>

#include <DbgEng.h>
#include <Windows.h>

#include <wil/com.h>

#include "comon.h"
#include "comonitor.h"

using namespace comon_ext;

namespace views = std::ranges::views;
namespace fs = std::filesystem;

namespace
{
HANDLE get_current_process_handle(IDebugSystemObjects* dbgsystemobjects) {
    ULONG64 handle;
    THROW_IF_FAILED(dbgsystemobjects->GetCurrentProcessHandle(&handle));
    return reinterpret_cast<HANDLE>(handle);
}

ULONG get_current_process_id(IDebugSystemObjects* dbgsystemobjects) {
    ULONG pid{};
    dbgsystemobjects->GetCurrentProcessId(&pid);
    return pid;
}

debuggee_type get_debuggee_type(IDebugControl4* dbgcontrol) {
    ULONG dbgclass, qualifier;
    if (SUCCEEDED(dbgcontrol->GetDebuggeeType(&dbgclass, &qualifier)) && dbgclass == DEBUG_CLASS_USER_WINDOWS) {
        if (qualifier == DEBUG_USER_WINDOWS_PROCESS || qualifier == DEBUG_USER_WINDOWS_PROCESS_SERVER) {
            return debuggee_type::live;
        } else if (qualifier == DEBUG_USER_WINDOWS_SMALL_DUMP || qualifier == DEBUG_USER_WINDOWS_DUMP) {
            return debuggee_type::memory_dump;
        } else if (qualifier == DEBUG_USER_WINDOWS_IDNA) {
            return debuggee_type::time_travel;
        } else {
            return debuggee_type::unknown;
        }
    } else {
        return debuggee_type::unknown;
    }
}

}

comonitor::comonitor(IDebugClient5* dbgclient, cometa& cometa, const call_context& cc, const cofilter& filter)
    : _dbgclient{ dbgclient }, _dbgcontrol{ _dbgclient.query<IDebugControl4>() }, _dbgsymbols{ _dbgclient.query<IDebugSymbols3>() },
    _dbgdataspaces{ _dbgclient.query<IDebugDataSpaces3>() }, _dbgsystemobjects{ _dbgclient.query<IDebugSystemObjects>() },
    _cometa{ cometa }, _logger{ _dbgcontrol.get() }, _cc{ cc }, _dbgtype{ get_debuggee_type(_dbgcontrol.get()) },
    _process_handle{ get_current_process_handle(_dbgsystemobjects.get()) }, _process_id{ get_current_process_id(_dbgsystemobjects.get()) },
    _filter{ filter } {

    if (ULONG loaded_modules_cnt, unloaded_modules_cnt;
        SUCCEEDED(_dbgsymbols->GetNumberModules(&loaded_modules_cnt, &unloaded_modules_cnt))) {
        auto modules{ std::make_unique<DEBUG_MODULE_PARAMETERS[]>(loaded_modules_cnt) };
        if (auto hr{ _dbgsymbols->GetModuleParameters(loaded_modules_cnt, nullptr, 0, modules.get()) }; SUCCEEDED(hr)) {
            for (ULONG i = 0; i < loaded_modules_cnt; i++) {
                auto& m{ modules[i] };
                if (auto buffer{ std::make_unique<wchar_t[]>(m.ModuleNameSize) }; SUCCEEDED(_dbgsymbols->GetModuleNameStringWide(
                    DEBUG_MODNAME_MODULE, DEBUG_ANY_ID, m.Base, buffer.get(), m.ModuleNameSize, nullptr))) {
                    handle_module_load({ buffer.get(), m.ModuleNameSize - 1 }, m.TimeDateStamp, m.Base);
                }
            }
        } else {
            _logger.log_error(L"Error when retrieving information about module.", hr);
        }
    }
}

comonitor::~comonitor() {
    for (auto iter{ std::begin(_breakpoints) }; iter != std::end(_breakpoints);) {
        if (auto hr{ unset_breakpoint(iter) }; FAILED(hr)) {
            LOG_HR(hr);
            iter++;
        }
    }
    _cotype_with_vtables.clear();
}

std::variant<comonitor::module_info, HRESULT> comonitor::get_module_info(ULONG64 base_address) const {
    DEBUG_MODULE_PARAMETERS m{};
    RETURN_IF_FAILED(_dbgsymbols->GetModuleParameters(1, &base_address, DEBUG_ANY_ID /* ignored */, &m));

    auto buffer{ std::make_unique<wchar_t[]>(m.ModuleNameSize) };
    RETURN_IF_FAILED(_dbgsymbols->GetModuleNameStringWide(DEBUG_MODNAME_MODULE, DEBUG_ANY_ID, base_address, buffer.get(),
        m.ModuleNameSize, nullptr));

    return module_info{ std::wstring{ buffer.get(), static_cast<size_t>(m.ModuleNameSize) - 1 }, m.TimeDateStamp, m.Size };
}

HRESULT comonitor::register_vtable(const CLSID& clsid, const IID& iid, ULONG64 vtable_addr, bool save_in_database, bool replace_if_exists) {
    assert(is_clsid_allowed(clsid));

    auto is_breakpoint_for_interface = [&clsid, &iid](const auto& brk) {
        if (std::holds_alternative<cobreakpoint>(brk)) {
            auto& cmbrk{ std::get<cobreakpoint>(brk) };
            return cmbrk.clsid == clsid && cmbrk.iid == iid;
        } else if (std::holds_alternative<coquery_single_return_breakpoint>(brk)) {
            auto& csbrk{ std::get<coquery_single_return_breakpoint>(brk) };
            return csbrk.clsid == clsid && csbrk.iid == iid;
        } else if (std::holds_alternative<coregister_return_breakpoint>(brk)) {
            auto& crbrk{ std::get<coregister_return_breakpoint>(brk) };
            return crbrk.clsid == clsid && crbrk.iid == iid;
        } else {
            assert(std::holds_alternative<function_breakpoint>(brk));
            return false;
        }
    };

    if (auto iter{ _cotype_with_vtables.find({ clsid, iid }) }; iter != std::end(_cotype_with_vtables) && iter->second != vtable_addr && !replace_if_exists) {
        _logger.log_warning(std::format(L"Vtable for CLSID {:b} and IID {:b} is already registered at {:#x} (new proposed address is {:#x}).",
            clsid, iid, iter->second, vtable_addr));
    } else if (iter == std::end(_cotype_with_vtables) || iter->second != vtable_addr) {
        if (iter != std::end(_cotype_with_vtables)) {
            assert(replace_if_exists);
            _cotype_with_vtables.erase(iter);

            for (auto brk_iter{ std::begin(_breakpoints) }; brk_iter != std::end(_breakpoints);) {
                if (is_breakpoint_for_interface(brk_iter->second.brk)) {
                    if (auto hr{ unset_breakpoint(brk_iter) }; FAILED(hr)) {
                        _logger.log_error(std::format(L"Failed to unset breakpoint {}", brk_iter->first), hr);
                        brk_iter++;
                    }
                } else {
                    ++brk_iter;
                }
            }
        }

        // save info about vtable in the database
        if (save_in_database) {
            if (ULONG64 base_addr{}; SUCCEEDED(_dbgsymbols->GetModuleByOffset2(
                vtable_addr, 0, DEBUG_GETMOD_NO_UNLOADED_MODULES, nullptr, &base_addr))) {
                if (auto vmi{ get_module_info(base_addr) }; std::holds_alternative<module_info>(vmi)) {
                    const auto& mi{ std::get<module_info>(vmi) };
                    _cometa.save_module_vtable({ mi.name, mi.timestamp, _cc.is_64bit() }, { clsid, iid, vtable_addr - base_addr });
                } else {
                    LOG_HR(std::get<HRESULT>(vmi));
                }
            } else {
                _logger.log_warning(std::format(L"Virtual table address {:x} does not belong to any module.", vtable_addr));
            }
        }

        // the first method is always the QueryInterface and we need to break on cv_it
        ULONG64 fn_address{};
        RETURN_IF_FAILED(_cc.read_pointer(vtable_addr, fn_address));

        if (auto hr{ set_breakpoint(cobreakpoint{ clsid, iid, L"QueryInterface", CALLCONV::CC_STDCALL },
            fn_address) }; FAILED(hr)) {
            _logger.log_error(std::format(L"Failed to set a breakpoint on QueryInterface method (CLSID: {:b}, IID: {:b})", clsid, iid), hr);
        }

        _cotype_with_vtables.insert({ { clsid, iid }, vtable_addr });

        // special case for IClassFactory when we need to set breakpoint on the CreateInstance (4th method in the vtbl)
        if (iid == __uuidof(IClassFactory)) {
            if (SUCCEEDED((_cc.read_pointer(vtable_addr + 3 * _cc.get_pointer_size(), fn_address)))) {
                if (auto hr{ set_breakpoint(cobreakpoint{ clsid, iid, L"CreateInstance", CALLCONV::CC_STDCALL },
                    fn_address) }; FAILED(hr)) {
                    _logger.log_error(std::format(L"Failed to set a breakpoint on IClassFactory::CreateInstance method (CLSID: {:b})", clsid), hr);
                }
            }
        }
    }

    return S_OK;
}

void comonitor::pause() noexcept {
    for (const auto& [brk_id, brk_data] : _breakpoints) {
        auto& brk = brk_data.brk;
        if (is_onetime_breakpoint(brk)) {
            continue;
        }
        if (auto hr{ modify_breakpoint_flag(brk_id, DEBUG_BREAKPOINT_ENABLED, false) }; FAILED(hr)) {
            _logger.log_error(std::format(L"Error when modifying flag for breakpoint {}", brk_id), hr);
        }
    }
    _is_paused = true;
}

void comonitor::resume() noexcept {
    for (const auto& [brk_id, brk_data] : _breakpoints) {
        auto& brk = brk_data.brk;
        if (is_onetime_breakpoint(brk)) {
            continue;
        }
        if (auto hr{ modify_breakpoint_flag(brk_id, DEBUG_BREAKPOINT_ENABLED, true) }; FAILED(hr)) {
            _logger.log_error(std::format(L"Error when modifying flag for breakpoint {}", brk_id), hr);
        }
    }
    _is_paused = false;
}

std::variant<ULONG64, HRESULT> comonitor::get_exported_function_addr(std::wstring_view module_name, ULONG64 module_base_addr,
    std::string_view function_name) const {

    auto find_in_export_table = [this, module_base_addr, function_name]() -> std::variant<ULONG64, HRESULT> {
        IMAGE_NT_HEADERS64 headers;
        RETURN_IF_FAILED(_dbgdataspaces->ReadImageNtHeaders(module_base_addr, &headers));

        auto export_data_directory = headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
        IMAGE_EXPORT_DIRECTORY export_table;
        RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(module_base_addr + export_data_directory.VirtualAddress, &export_table, sizeof export_table, nullptr));

        ULONG function_name_buffer_len{ static_cast<ULONG>(function_name.size()) + 1 };
        auto function_name_buffer{ std::make_unique<char[]>(function_name_buffer_len) };
        for (DWORD i = 0; i < export_table.NumberOfNames; i++)
        {
            ULONG64 function_name_addr{};
            RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(module_base_addr + export_table.AddressOfNames + i * sizeof(DWORD), &function_name_addr, sizeof(DWORD), nullptr));

            ULONG bytes_read{};
            if (SUCCEEDED(_dbgdataspaces->ReadVirtual(module_base_addr + function_name_addr, function_name_buffer.get(), function_name_buffer_len * sizeof(char), &bytes_read))
                && bytes_read == function_name_buffer_len * sizeof(char) && function_name_buffer[function_name.size()] == '\0'
                && std::string_view{ function_name_buffer.get(), function_name.size() } == function_name) {

                // the name matches, time to find the function ordinal
                WORD ordinal{};
                RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(module_base_addr + export_table.AddressOfNameOrdinals + i * sizeof(WORD), &ordinal, sizeof ordinal, nullptr));

                ULONG64 function_offset{};
                ULONG64 function_offset_addr{ module_base_addr + export_table.AddressOfFunctions + ordinal * sizeof(DWORD) };
                RETURN_IF_FAILED(_dbgdataspaces->ReadVirtual(function_offset_addr, &function_offset, sizeof(DWORD), NULL));

                return module_base_addr + function_offset;
            }
        }
        return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    };

    auto find_using_symbols = [this, module_name, function_name]() -> std::variant<ULONG64, HRESULT> {
        std::wstring sanitized_module_name{ module_name };
        // when there is a dot in the module name, windbg replaces it with underscore - we need to do the same,
        // otherwise, symbol resolution won't work
        // when there is a dot in the module name, windbg replaces it with underscore
        std::replace(std::begin(sanitized_module_name), std::end(sanitized_module_name), L'.', L'_');


        std::wstring function_fullname{ sanitized_module_name };
        function_fullname.append(L"!").append(std::begin(function_name), std::end(function_name));

        ULONG64 offset{};
        if (auto hr{ _dbgsymbols->GetOffsetByNameWide(function_fullname.c_str(), &offset) }; SUCCEEDED(hr)) {
            return offset;
        } else {
            return hr;
        }
    };

    if (_dbgtype == debuggee_type::live) {
        return find_in_export_table();
    } else if (_dbgtype == debuggee_type::time_travel || _dbgtype == debuggee_type::memory_dump) {
        return find_using_symbols();
    } else {
        return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
    }
}

void comonitor::handle_module_load(std::wstring_view module_name, ULONG module_timestamp, ULONG64 module_base_addr) {
    for (auto& [clsid, iid, vtable] :
        _cometa.get_module_vtables({ module_name, module_timestamp, _cc.is_64bit() })) {
        if (is_clsid_allowed(clsid)) {
            auto vtable_addr{ module_base_addr + vtable };
            if (_dbgtype == debuggee_type::live || _dbgtype == debuggee_type::time_travel) {
                // only when debugging a live process or in a time travel session, we will set breakpoints
                if (ULONG64 fn_query_interface{}; SUCCEEDED(_cc.read_pointer(vtable_addr, fn_query_interface))) {
                    if (auto hr{ set_breakpoint(cobreakpoint{ clsid, iid, L"QueryInterface", CALLCONV::CC_STDCALL },
                        fn_query_interface) }; FAILED(hr)) {
                        _logger.log_error(
                            std::format(L"Failed to set a breakpoint on QueryInterface method (CLSID: {:b}, IID: {:b})", clsid, iid), hr);
                    }
                }
            }
            _cotype_with_vtables.insert({ { clsid, iid }, vtable_addr });
        }
    }

    if (_dbgtype == debuggee_type::live || _dbgtype == debuggee_type::time_travel) {
        // only when debugging a live process or in a time travel session, we will set breakpoints

        // if a given module exports DllGetClassObject we will set a breakpoint on it
        constexpr std::wstring_view functions_to_monitor[]{
            L"DllGetClassObject", L"CoRegisterClassObject"
        };
        constexpr std::string_view functions_to_monitor_ansi[]{
            "DllGetClassObject", "CoRegisterClassObject"
        };

        // those arrays must be always in sync
        assert(_countof(functions_to_monitor) == _countof(functions_to_monitor_ansi));

        // additional function breakpoints related to COM are enabled only for specific modules
        int index_limit = (module_name == L"ole32" || module_name == L"combase") ? _countof(functions_to_monitor) : 1;

        for (int i = 0; i < index_limit; i++) {
            std::wstring fn_name{ functions_to_monitor[i] };
            std::wstring fn_fullname{ module_name };
            fn_fullname.append(L"!").append(fn_name);

            if (auto fn_addr{ get_exported_function_addr(module_name, module_base_addr, functions_to_monitor_ansi[i]) }; std::holds_alternative<ULONG64>(fn_addr)) {
                if (auto hr{ set_breakpoint(function_breakpoint{ fn_fullname }, std::get<ULONG64>(fn_addr)) }; FAILED(hr)) {
                    _logger.log_error(std::format(L"Failed to set a breakpoint on function '{}'", fn_fullname), hr);
                }
            }
        }
    }
}

void comonitor::handle_module_unload(ULONG64 base_address) {
    if (auto vmi{ get_module_info(base_address) }; std::holds_alternative<module_info>(vmi)) {
        const auto& mi{ std::get<module_info>(vmi) };
        // remove all function name breakpoints from the specified module
        for (auto iter{ std::begin(_cotype_with_vtables) }; iter != std::end(_cotype_with_vtables);) {
            auto& [key, vtlb] {*iter};
            if (vtlb >= base_address && vtlb <= base_address + mi.size) {
                iter = _cotype_with_vtables.erase(iter);
            } else {
                iter++;
            }
        }

        for (auto iter{ std::begin(_breakpoints) }; iter != std::end(_breakpoints);) {
            auto address{ iter->second.addr };
            if (address >= base_address && address <= base_address + mi.size) {
                if (auto hr{ unset_breakpoint(iter) }; FAILED(hr)) {
                    _logger.log_error(std::format(L"Failed to remove a breakpoint {}", iter->first), hr);
                    iter++;
                }
            } else {
                iter++;
            }
        }
    } else {
        LOG_HR(std::get<HRESULT>(vmi));
    }
}

void comonitor::log_com_call_success(const CLSID& clsid, const IID& iid, std::wstring_view caller_name) {
    ULONG tid{};
    _dbgsystemobjects->GetCurrentThreadId(&tid);

    auto clsid_name{ _cometa.resolve_class_name(clsid) };
    auto iid_name{ _cometa.resolve_type_name(iid) };
    _logger.log_info_dml(std::format(L"<col fg=\"normfg\">{}:{:03} [{}] CLSID: <b>{:b} ({})</b>, IID: <b>{:b} "
        L"({})</b></col> -> <col fg=\"srccmnt\">SUCCESS (0x0)</col>",
        _process_id, tid, caller_name, clsid, clsid_name ? *clsid_name : L"N/A", iid,
        iid_name ? *iid_name : L"N/A"));
}

void comonitor::log_com_call_error(const CLSID& clsid, const IID& iid, std::wstring_view caller_name, HRESULT result_code) {
    ULONG pid{};
    _dbgsystemobjects->GetCurrentProcessId(&pid);
    ULONG tid{};
    _dbgsystemobjects->GetCurrentThreadId(&tid);

    auto clsid_name{ _cometa.resolve_class_name(clsid) };
    auto iid_name = _cometa.resolve_type_name(iid);
    _logger.log_info_dml(std::format(L"<col fg=\"changed\">{}:{:03} [{}] CLSID: <b>{:b} ({})</b>, IID: <b>{:b} "
        L"({})</b></col> -> <col fg=\"srcstr\">ERROR ({:#x}) - {}</col>",
        pid, tid, caller_name, clsid, clsid_name ? *clsid_name : L"N/A", iid,
        iid_name ? *iid_name : L"N/A", static_cast<unsigned long>(result_code),
        dbgeng_logger::get_error_msg(result_code)));
}

std::unordered_map<CLSID, std::vector<std::pair<ULONG64, IID>>> comonitor::list_cotypes() const {
    std::unordered_map<CLSID, std::vector<std::pair<ULONG64, IID>>> result{};

    for (const auto& [key, addr] : _cotype_with_vtables) {
        const auto& [clsid, iid] {key};

        if (!result.contains(clsid)) {
            result.insert({ clsid, std::vector<std::pair<ULONG64, IID>> { { addr, iid } } });
        } else {
            result[clsid].push_back({ addr, iid });
        }
    }

    return result;
}

```

`comon/comonitor.h`:

```h
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once

#include <array>
#include <optional>
#include <unordered_map>
#include <unordered_set>
#include <variant>
#include <vector>

#include <Windows.h>
#include <wil/com.h>
#include <wil/result.h>

#include "arch.h"
#include "cometa.h"
#include "comon.h"

namespace comon_ext {

struct no_filter {};
struct including_filter { const std::unordered_set<CLSID> clsids; };
struct excluding_filter { const std::unordered_set<CLSID> clsids; };
using cofilter = std::variant<no_filter, including_filter, excluding_filter>;

enum class debuggee_type {
    time_travel,
    live,
    memory_dump,
    unknown
};

enum class cobreakpoint_behavior {
    stop_before_call,
    stop_after_call,
    always_stop,
    never_stop
};

class comonitor {
private:

    /* Entry functions (those functions create new class objects):
     *
     * - CoRegisterClassObject
     * - <module>!DllGetClassObject
     *
     * Each entry function creates a return breakpoint if a CLSID should be monitored
     * (is_clsid_allowed). On return, we register the created vtable and place breakpoints
     * on the interface methods, for exampe, IUnknown::QueryInterface or IClassFactory::CreateInstance.
    */

    struct coquery_single_return_breakpoint {
        const CLSID clsid;
        const IID iid;
        const ULONG64 object_address_address;
        const std::wstring create_function_name;
    };

    struct coregister_return_breakpoint {
        const CLSID clsid;
        const IID iid;
        const ULONG64 vtbl_address;
        const std::wstring register_function_name;
    };

    struct function_breakpoint {
        // must be with the module name
        const std::wstring function_name;
    };

    /// Special type of breakpoint that is placed on a method of a COM interface
    struct cobreakpoint {
        const CLSID clsid;
        const IID iid;
        const std::wstring method_name;
        const CALLCONV callconv;
        const std::wstring return_type;
        const method_arg_collection args;
        const cobreakpoint_behavior behavior;
    };

    struct cobreakpoint_return {
        const CLSID clsid;
        const IID iid;
        const std::wstring method_name;
        const std::wstring return_type;
        const method_arg_collection out_args;
        const std::vector<call_context::arg_val> out_arg_values;
        const bool should_stop;
    };

    using breakpoint = std::variant<function_breakpoint, coquery_single_return_breakpoint,
        coregister_return_breakpoint, cobreakpoint, cobreakpoint_return>;

    struct memory_protect {
        DWORD old_protect;
        DWORD new_protect;
    };

    struct breakpoint_data {
        const breakpoint brk;
        const ULONG64 addr;
        const std::optional<memory_protect> mem_protect;
    };

    struct module_info {
        std::wstring name;
        ULONG timestamp;
        ULONG size;
    };

    static wil::com_ptr_t<IDebugClient5> create_IDebugClient() {
        wil::com_ptr_t<IDebugClient5> client;
        THROW_IF_FAILED(::DebugCreate(__uuidof(IDebugClient5), client.put_void()));
        return client;
    }

    const wil::com_ptr<IDebugClient5> _dbgclient;
    const wil::com_ptr<IDebugControl4> _dbgcontrol;
    const wil::com_ptr<IDebugSymbols3> _dbgsymbols;
    const wil::com_ptr<IDebugDataSpaces3> _dbgdataspaces;
    const wil::com_ptr<IDebugSystemObjects> _dbgsystemobjects;
    const dbgeng_logger _logger;
    const HANDLE _process_handle;
    const ULONG _process_id;

    const debuggee_type _dbgtype;

    const call_context& _cc;

    const cofilter _filter;

    cometa& _cometa;

    bool _is_paused{};

    std::unordered_map<ULONG, breakpoint_data> _breakpoints{};
    std::unordered_map<ULONG64, ULONG> _breakpoint_addresses{};
    std::unordered_map<std::pair<CLSID, IID>, ULONG64> _cotype_with_vtables{};

    std::variant<module_info, HRESULT> get_module_info(ULONG64 base_address) const;

    std::variant<ULONG64, HRESULT> get_exported_function_addr(std::wstring_view module_name, ULONG64 module_base_addr, std::string_view function_name) const;

    auto is_clsid_allowed(const CLSID& clsid) {
        if (auto fltr = std::get_if<including_filter>(&_filter); fltr) {
            return fltr->clsids.contains(clsid);
        }
        if (auto fltr = std::get_if<excluding_filter>(&_filter); fltr) {
            return !fltr->clsids.contains(clsid);
        }
        assert(std::holds_alternative<no_filter>(_filter));
        return true;
    }

    bool is_onetime_breakpoint(const breakpoint& brk) {
        return std::holds_alternative<coquery_single_return_breakpoint>(brk) ||
            std::holds_alternative<coregister_return_breakpoint>(brk) ||
            std::holds_alternative<cobreakpoint_return>(brk);
    }

    HRESULT set_breakpoint(const breakpoint& brk, ULONG64 address, PULONG brk_id = nullptr);

    HRESULT unset_breakpoint(decltype(_breakpoints)::iterator& iter);

    void unset_inner_breakpoint(decltype(_breakpoints)::iterator& iter);

    HRESULT modify_breakpoint_flag(ULONG brk_id, ULONG flag, bool enable);

    void log_com_call_success(const CLSID& clsid, const IID& iid, std::wstring_view caller_name);

    void log_com_call_error(const CLSID& clsid, const IID& iid, std::wstring_view caller_name, HRESULT result_code);

    /* Breakpoints handling */
    void handle_coquery_return(const coquery_single_return_breakpoint& brk);

    void handle_coregister_return(const coregister_return_breakpoint& brk);

    bool handle_cobreakpoint(const cobreakpoint& brk);

    bool handle_cobreakpoint_return(const cobreakpoint_return& brk);

    void handle_DllGetClassObject(const function_breakpoint&);

    void handle_CoRegisterClassObject(const function_breakpoint& brk);

    void handle_IUnknown_QueryInterface(const CLSID& clsid);

    void handle_IClassFactory_CreateInstance(const CLSID& clsid);

public:

    // cometa and cc lifetime is controlled by dbgsession - it always survives comonitor
    explicit comonitor(IDebugClient5* dbgclient, cometa& cometa, const call_context& cc, const cofilter& filter);

    comonitor(const comonitor&) = delete;

    comonitor(comonitor&&) = default;

    ~comonitor();

    bool handle_breakpoint(ULONG id);

    void handle_module_load(std::wstring_view module_name, ULONG module_timestamp, ULONG64 module_base_addr);
    void handle_module_unload(ULONG64 base_address);

    HRESULT handle_breakpoint_removed(ULONG id) {
        if (auto found_brk{ _breakpoints.find(id) }; found_brk != std::end(_breakpoints)) {
            unset_inner_breakpoint(found_brk);
            _logger.log_info(std::format(L"Breakpoint {} removed (monitor for #{})", id, _process_id));
            return S_OK;
        } else {
            return HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        }
    }

    std::unordered_map<CLSID, std::vector<std::pair<ULONG64, IID>>> list_cotypes() const;

    HRESULT create_cobreakpoint(const CLSID& clsid, const IID& iid, DWORD method_num, cobreakpoint_behavior behavior);

    HRESULT register_vtable(const CLSID& clsid, const IID& iid, ULONG64 vtable_addr, bool save_in_database, bool replace_if_exists);

    const cofilter& get_filter() const { return _filter; }

    void pause() noexcept;

    void resume() noexcept;

    bool is_paused() const noexcept { return _is_paused; }
};

} // namespace comon_ext

```

`comon/comonitor_com_breakpoints.cpp`:

```cpp
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <algorithm>
#include <array>
#include <cassert>
#include <filesystem>
#include <format>
#include <ranges>
#include <string>
#include <utility>

#include <DbgEng.h>
#include <Windows.h>
#include <wil/com.h>
#include <wil/result.h>

#include "comon.h"
#include "comonitor.h"

using namespace comon_ext;

namespace views = std::ranges::views;
namespace fs = std::filesystem;

HRESULT comonitor::set_breakpoint(const breakpoint& brk, ULONG64 address, [[maybe_unused]] PULONG id) {
    assert(_dbgtype == debuggee_type::live || _dbgtype == debuggee_type::time_travel);

    auto get_breakpoint_command = [this, &brk]() {
        if (std::holds_alternative<coquery_single_return_breakpoint>(brk)) {
            auto& fbrk{ std::get<coquery_single_return_breakpoint>(brk) };
            return std::format(L"* [comon] return breakpoint (CLSID: {:b}, IID: {:b})", fbrk.clsid, fbrk.iid);
        } else if (std::holds_alternative<coregister_return_breakpoint>(brk)) {
            auto& crbrk{ std::get<coregister_return_breakpoint>(brk) };
            return std::format(L"* [comon] register return breakpoint (CLSID: {:b}, IID: {:b}, function: {})",
                crbrk.clsid, crbrk.iid, crbrk.register_function_name);
        } else if (std::holds_alternative<function_breakpoint>(brk)) {
            auto& fbrk{ std::get<function_breakpoint>(brk) };
            return std::format(L"* [comon] function breakpoint (name: {})", fbrk.function_name);
        } else if (std::holds_alternative<cobreakpoint>(brk)) {
            auto& cobrk{ std::get<cobreakpoint>(brk) };
            return std::format(L"* [comon] interface breakpoint (CLSID: {:b}, IID: {:b}, method: {})",
                cobrk.clsid, cobrk.iid, cobrk.method_name);
        } else if (std::holds_alternative<cobreakpoint_return>(brk)) {
            auto& corbrk{ std::get<cobreakpoint_return>(brk) };
            return std::format(L"* [comon] interface return breakpoint (CLSID: {:b}, IID: {:b}, method: {})",
                corbrk.clsid, corbrk.iid, corbrk.method_name);
        } else {
            assert(false);
            return std::wstring{};
        }
    };

    ULONG brk_id{};

    if (auto found_brk_id{ _breakpoint_addresses.find(address) }; found_brk_id != std::end(_breakpoint_addresses)) {
        brk_id = found_brk_id->second;
        // we need to replace the breakpoint data as it may have been updated by the user
        if (auto found_brk{ _breakpoints.find(brk_id) }; found_brk != std::end(_breakpoints)) {
            assert(found_brk->second.addr == address);
            auto mem_protect{ found_brk->second.mem_protect };
            _breakpoints.erase(found_brk);
            _breakpoints.insert({ brk_id, { brk, address, mem_protect } });
        } else {
            assert(false);
            _logger.log_error(std::format(L"Breakpoint {} found in the address map, but not in the breakpoint map.", brk_id), E_UNEXPECTED);
        }
    } else {
        IDebugBreakpoint2* dbgbrk{};
        RETURN_IF_FAILED(_dbgcontrol->AddBreakpoint2(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID, &dbgbrk));

        std::optional<memory_protect> memprotect{};

        if (_dbgtype == debuggee_type::live) {
            /* I discovered that dbgeng from WinDbgX explicitly calls VirtualProtectEx when setting a breakpoint in read-only memory.
               The old engine relies on WriteProcessMemory (and its implicit calls to NtProtectVirtualMemory) and fails on a COM pre-stub
               However, the call to VirtualProtectEx in WinDbgX makes the .NET process thread enter an endless loop, as the call to ComCallPreStub
               is never replaced by JITer. It must have  something to do with the copy-on-write protection that WindDgbX sets on this memory page.

               I try to detect such a situation here and set the memory page protection to PAGE_EXECUTE_READWRITE.
            */
            if (MEMORY_BASIC_INFORMATION meminfo{}; ::VirtualQueryEx(_process_handle, reinterpret_cast<LPCVOID>(address), &meminfo, sizeof(meminfo)) != 0) {
                if (meminfo.State == MEM_COMMIT) {
                    if (meminfo.Type != MEM_IMAGE && (meminfo.Protect & PAGE_EXECUTE_READWRITE) == 0) {
                        memory_protect mp{ .old_protect{}, .new_protect{ PAGE_EXECUTE_READWRITE } };
                        RETURN_IF_WIN32_BOOL_FALSE(::VirtualProtectEx(_process_handle, meminfo.BaseAddress, 1, mp.new_protect, &mp.old_protect));
                        _logger.log_info(std::format(L"Changed memory page ({}) protection ({:#x} -> {:#x}) to set a breakpoint.", meminfo.BaseAddress, mp.old_protect, mp.new_protect));
                        memprotect = mp;
                    }
                } else {
                    _logger.log_warning(std::format(L"Invalid address for a breakpoint (memory is not committed): {:#x}", address));
                    return E_INVALIDARG;
                }
            } else {
                RETURN_LAST_ERROR();
            }
        }

        RETURN_IF_FAILED(dbgbrk->SetOffset(address));
        dbgbrk->SetCommandWide(get_breakpoint_command().c_str());

        RETURN_IF_FAILED(dbgbrk->GetId(&brk_id));
        RETURN_IF_FAILED(dbgbrk->AddFlags(DEBUG_BREAKPOINT_ENABLED | (is_onetime_breakpoint(brk) ? DEBUG_BREAKPOINT_ONE_SHOT : 0)));

        _breakpoints.insert({ brk_id, { brk, address, memprotect } });
        _breakpoint_addresses.insert({ address, brk_id });
    }

    if (id != nullptr) {
        *id = brk_id;
    }
    return S_OK;
}

void comonitor::unset_inner_breakpoint(decltype(_breakpoints)::iterator& iter) {
    auto address{ iter->second.addr };

    if (auto& mp{ iter->second.mem_protect }; mp) {
        if (MEMORY_BASIC_INFORMATION meminfo{}; ::VirtualQueryEx(_process_handle, reinterpret_cast<LPCVOID>(address), &meminfo, sizeof(meminfo)) != 0) {
            // we will revert the memory protection only if it equals the protection we set previously
            if (meminfo.Protect == mp->new_protect) {
                DWORD curr_protect{};
                if (::VirtualProtectEx(_process_handle, meminfo.BaseAddress, 1, mp->old_protect, &curr_protect)) {
                    _logger.log_info(std::format(L"Changed memory page ({}) protection ({:#x} -> {:#x}) when unsetting a breakpoint.",
                        meminfo.BaseAddress, curr_protect, mp->old_protect));
                }
            }
        }
    }

    _breakpoint_addresses.erase(address);
    iter = _breakpoints.erase(iter);
}

HRESULT comonitor::unset_breakpoint(decltype(_breakpoints)::iterator& iter) {
    auto brk_id{ iter->first };

    // the order of operations is important here as dbgsession will get notification about the breakpoint removal
    // and will try to re-remove it from the monitor again
    unset_inner_breakpoint(iter);

    if (IDebugBreakpoint2* bp{}; SUCCEEDED(_dbgcontrol->GetBreakpointById2(brk_id, &bp))) {
        return _dbgcontrol->RemoveBreakpoint2(bp);
    } else {
        return S_OK;
    }
}

HRESULT comonitor::modify_breakpoint_flag(ULONG brk_id, ULONG flag, bool enable) {
    IDebugBreakpoint2* bp;
    RETURN_IF_FAILED(_dbgcontrol->GetBreakpointById2(brk_id, &bp));

    ULONG flags{};
    RETURN_IF_FAILED(bp->GetFlags(&flags));
    flags = enable ? (flags | flag) : (flags & ~flag);
    return bp->SetFlags(flags);
}

HRESULT comonitor::create_cobreakpoint(const CLSID& clsid, const IID& iid, DWORD method_num, cobreakpoint_behavior behavior) {
    if (method_num < 0) {
        return E_INVALIDARG;
    }

    if (auto methods{ _cometa.get_type_methods(iid) }; methods && methods->size() > method_num) {
        auto& method{ methods->at(method_num) };
        if (auto vtable{ _cotype_with_vtables.find({ clsid, iid }) }; vtable != std::end(_cotype_with_vtables)) {
            ULONG64 addr{};
            RETURN_IF_FAILED(_cc.read_pointer(vtable->second + method_num * _cc.get_pointer_size(), addr));

            auto args{ _cometa.get_type_method_args(method) };
            cobreakpoint cobrk{ clsid, iid, method.name, method.callconv, method.return_type,
                args ? *args : method_arg_collection{}, behavior };

            ULONG brk_id{};
            if (auto hr{ set_breakpoint(cobrk, addr, &brk_id) }; SUCCEEDED(hr)) {
                _logger.log_info(std::format(L"Breakpoint {} (address {:#x}) created / updated", brk_id, addr));
                return S_OK;
            } else {
                _logger.log_error(std::format(L"Could not create a breakpoint on address {:#x}", addr), hr);
                return hr;
            }
        } else {
            _logger.log_error(L"No virtual table registered for the given CLSID and IID pair in the current session", E_INVALIDARG);
            return E_INVALIDARG;
        }
    } else {
        _logger.log_error(L"Can't find type information in the metadata", E_INVALIDARG);
        return E_INVALIDARG;
    }
}

bool comonitor::handle_breakpoint(ULONG id) {
    bool handled{};

    if (auto found_brk{ _breakpoints.find(id) }; found_brk != std::end(_breakpoints)) {
        if (auto brk{ found_brk->second.brk }; std::holds_alternative<coquery_single_return_breakpoint>(brk)) {
            handle_coquery_return(std::get<coquery_single_return_breakpoint>(brk));
            handled = true;
        } else if (std::holds_alternative<coregister_return_breakpoint>(brk)) {
            handle_coregister_return(std::get<coregister_return_breakpoint>(brk));
            handled = true;
        } else if (std::holds_alternative<function_breakpoint>(brk)) {
            auto& fbrk{ std::get<function_breakpoint>(brk) };
            if (fbrk.function_name.ends_with(L"!CoRegisterClassObject")) {
                handle_CoRegisterClassObject(fbrk);
                handled = true;
            } else if (fbrk.function_name.ends_with(L"!DllGetClassObject")) {
                handle_DllGetClassObject(fbrk);
                handled = true;
            } else {
                assert(false);
            }
        } else if (std::holds_alternative<cobreakpoint>(brk)) {
            auto& cobrk{ std::get<cobreakpoint>(brk) };
            if (cobrk.method_name == L"QueryInterface") {
                handle_IUnknown_QueryInterface(cobrk.clsid);
                handled = true;
            } else if (cobrk.iid == __uuidof(IClassFactory) && cobrk.method_name == L"CreateInstance") {
                handle_IClassFactory_CreateInstance(cobrk.clsid);
                handled = true;
            } else {
                handled = handle_cobreakpoint(cobrk);
            }
        } else if (std::holds_alternative<cobreakpoint_return>(brk)) {
            handled = handle_cobreakpoint_return(std::get<cobreakpoint_return>(brk));
        } else {
            assert(false);
        }

        if (is_onetime_breakpoint(found_brk->second.brk)) {
            unset_breakpoint(found_brk);
        }
    }

    return handled;
}

void comonitor::handle_coquery_return(const coquery_single_return_breakpoint& brk) {
    call_context::arg_val function_return_code{ L"HRESULT" };
    RETURN_VOID_IF_FAILED(_cc.read_method_return_code(function_return_code));

    if (SUCCEEDED(function_return_code.value)) {
        log_com_call_success(brk.clsid, brk.iid, brk.create_function_name);

        ULONG64 object_addr{};
        RETURN_VOID_IF_FAILED(_cc.read_pointer(brk.object_address_address, object_addr));
        ULONG64 vtbl_addr{};
        RETURN_VOID_IF_FAILED(_cc.read_pointer(object_addr, vtbl_addr));

        register_vtable(brk.clsid, brk.iid, vtbl_addr, true, false);
    } else {
        log_com_call_error(brk.clsid, brk.iid, brk.create_function_name, static_cast<HRESULT>(function_return_code.value));
    }
}

void comonitor::handle_coregister_return(const coregister_return_breakpoint& brk) {
    call_context::arg_val function_return_code{ L"HRESULT" };
    RETURN_VOID_IF_FAILED(_cc.read_method_return_code(function_return_code));

    if (SUCCEEDED(function_return_code.value)) {
        register_vtable(brk.clsid, brk.iid, brk.vtbl_address, true, false);
        log_com_call_success(brk.clsid, brk.iid, brk.register_function_name);
    } else {
        log_com_call_error(brk.clsid, {}, brk.register_function_name, static_cast<HRESULT>(function_return_code.value));
    }
}

bool comonitor::handle_cobreakpoint(const cobreakpoint& brk) {
    std::wstring output_dml{};
    output_dml.reserve(1024);

    if (auto type_name_v{ _cometa.resolve_type_name(brk.iid) }; type_name_v) {
        output_dml.append(std::format(L"[comon breakpoint] <b>{}::{}</b> (iid: {:b}, clsid: {:b})\n", *type_name_v,
            brk.method_name, brk.iid, brk.clsid));
    } else {
        output_dml.append(std::format(L"[comon breakpoint] <b>{:b}::{}</b> (iid: {:b}, clsid: {:b})\n", brk.iid, brk.method_name,
            brk.iid, brk.clsid));
    }

    if (brk.args.size() > 0 && brk.callconv == CALLCONV::CC_STDCALL /* TODO: currently we support only STDCALL */) {
        output_dml.append(L"\nParameters:\n");

        std::vector<call_context::arg_val> arg_vals{};
        arg_vals.reserve(brk.args.size());
        std::ranges::transform(brk.args, std::back_inserter(arg_vals),
            [](const auto& arg) { return call_context::arg_val { arg.type }; });

        ULONG64 return_addr{};
        if (auto hr{ _cc.read_method_frame(brk.callconv, arg_vals, return_addr) }; SUCCEEDED(hr)) {
            std::vector<comethod_arg> out_args{};
            std::vector<call_context::arg_val> out_arg_values{};

            for (auto [arg, arg_val] : views::zip(brk.args, arg_vals)) {
                std::wstring arg_val_text{};
                if (SUCCEEDED(hr = _cc.get_arg_value_in_text(arg_val, arg_val_text))) {
                    output_dml.append(std::format(L"- <b>{}</b>: {}", arg.name, arg_val_text));
                } else {
                    output_dml.append(std::format(L"- <b>{}</b>: error {:#x} when reading the value", arg.name,
                        static_cast<ULONG>(hr)));
                }
                if (arg.flags & (IDLFLAG_FOUT | IDLFLAG_FRETVAL)) {
                    output_dml.append(L" [out]");
                    out_args.push_back(arg);
                    out_arg_values.push_back(arg_val);
                }
                output_dml.append(L"\n");
            }

            bool stop_on_return = brk.behavior == cobreakpoint_behavior::stop_after_call || brk.behavior == cobreakpoint_behavior::always_stop;
            if (FAILED(hr = set_breakpoint(cobreakpoint_return{ brk.clsid, brk.iid, brk.method_name, brk.return_type, out_args,
                out_arg_values, stop_on_return }, return_addr))) {
                _logger.log_error(std::format(L"Error when setting the return breakpoint"), hr);
            }
        } else {
            output_dml.append(std::format(L"Error {:#x} when reading the parameters\n", static_cast<ULONG>(hr)));
        }
    }
    output_dml.append(L"\n");

    _dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL, output_dml.c_str());

    return brk.behavior != cobreakpoint_behavior::stop_before_call && brk.behavior != cobreakpoint_behavior::always_stop;
}

bool comonitor::handle_cobreakpoint_return(const cobreakpoint_return& brk) {
    std::wstring output_dml{};
    output_dml.reserve(1024);

    if (auto type_name_v{ _cometa.resolve_type_name(brk.iid) }; type_name_v) {
        output_dml.append(std::format(L"[comon breakpoint] <b>{}::{}</b> (iid: {:b}, clsid: {:b}) return\n", *type_name_v,
            brk.method_name, brk.iid, brk.clsid));
    } else {
        output_dml.append(std::format(L"[comon breakpoint] <b>{:b}::{}</b> (iid: {:b}, clsid: {:b}) return\n", brk.iid, brk.method_name,
            brk.iid, brk.clsid));
    }

    call_context::arg_val result{ brk.return_type };
    if (auto hr{ _cc.read_method_return_code(result) }; SUCCEEDED(hr)) {
        std::wstring result_val_text{};
        if (SUCCEEDED(hr = _cc.get_arg_value_in_text(result, result_val_text))) {
            output_dml.append(std::format(L"Result: {}\n", result_val_text));
        } else {
            output_dml.append(std::format(L"Result: {:#x}\n", result.value));
        }
    } else {
        output_dml.append(std::format(L"Result: error {:#x} when reading the result\n", hr));
    }

    output_dml.append(L"\nOut parameters:\n");
    assert(brk.out_args.size() == brk.out_arg_values.size());

    for (auto [arg, arg_val] : views::zip(brk.out_args, brk.out_arg_values)) {
        std::wstring arg_val_text{};
        if (auto hr{ _cc.get_arg_value_in_text(arg_val, arg_val_text) }; SUCCEEDED(hr)) {
            output_dml.append(std::format(L"- <b>{}</b>: {}\n", arg.name, arg_val_text));
        } else {
            output_dml.append(std::format(L"- <b>{}</b>: error {:#x} when reading the value\n", arg.name, hr));
        }
    }
    output_dml.append(L"\n");


    _dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL, output_dml.c_str());

    return !brk.should_stop;
}

void comonitor::handle_DllGetClassObject(const function_breakpoint& brk) {
    assert(brk.function_name.ends_with(L"!DllGetClassObject"));
    static const std::vector<std::wstring> arg_types { L"GUID*", L"GUID*", L"void**" };

    std::vector<call_context::arg_val> args{};
    args.reserve(arg_types.size());
    std::ranges::transform(arg_types, std::back_inserter(args), [](const auto& type) { return call_context::arg_val { type }; });

    ULONG64 return_addr{};
    RETURN_VOID_IF_FAILED(_cc.read_method_frame(CALLCONV::CC_STDCALL, args, return_addr));

    CLSID clsid{};
    RETURN_VOID_IF_FAILED(_cc.read_object(args[0].value, &clsid, sizeof clsid));

    if (is_clsid_allowed(clsid)) {
        IID iid{};
        RETURN_VOID_IF_FAILED(_cc.read_object(args[1].value, &iid, sizeof iid));

        if (auto hr{ set_breakpoint(coquery_single_return_breakpoint{ clsid, iid, args[2].value, brk.function_name }, return_addr) }; FAILED(hr)) {
            _logger.log_error_dml(std::format(L"Error when setting return breakpoint from {}", brk.function_name), hr);
        }
    }
}

void comonitor::handle_CoRegisterClassObject(const function_breakpoint& brk) {
    assert(brk.function_name.ends_with(L"!CoRegisterClassObject"));
    static const std::vector<std::wstring> arg_types { L"GUID*", L"IUnknown*" }; // we only need the first two

    std::vector<call_context::arg_val> args{};
    args.reserve(arg_types.size());
    std::ranges::transform(arg_types, std::back_inserter(args), [](const auto& type) { return call_context::arg_val { type }; });

    ULONG64 return_addr{};
    RETURN_VOID_IF_FAILED(_cc.read_method_frame(CALLCONV::CC_STDCALL, args, return_addr));

    CLSID clsid{};
    RETURN_VOID_IF_FAILED(_cc.read_object(args[0].value, &clsid, sizeof clsid));

    if (is_clsid_allowed(clsid)) {
        constexpr IID iid{ __uuidof(IUnknown) };

        ULONG64 vtbl_addr{};
        RETURN_VOID_IF_FAILED(_cc.read_pointer(args[1].value, vtbl_addr));

        if (auto hr{ set_breakpoint(coregister_return_breakpoint{ clsid, iid, vtbl_addr, brk.function_name }, return_addr) }; FAILED(hr)) {
            _logger.log_error_dml(std::format(L"Error when setting return breakpoint from {}", brk.function_name), hr);
        }
    }
}

void comonitor::handle_IUnknown_QueryInterface(const CLSID& clsid) {
    static const std::wstring_view function_name{ L"IUnknown::QueryInterface" };
    static const std::vector<std::wstring> arg_types { L"IUnknown*", L"GUID*", L"void**" };

    std::vector<call_context::arg_val> args{};
    args.reserve(arg_types.size());
    std::ranges::transform(arg_types, std::back_inserter(args), [](const auto& type) { return call_context::arg_val { type }; });

    ULONG64 return_addr{};
    RETURN_VOID_IF_FAILED(_cc.read_method_frame(CALLCONV::CC_STDCALL, args, return_addr));

    IID iid{};
    RETURN_VOID_IF_FAILED(_cc.read_object(args[1].value, &iid, sizeof iid));

    // if the previous calls were successful, this one should be as well, so no need to wait for the query return
    if (!_cotype_with_vtables.contains({ clsid, iid })) {
        if (auto hr{ set_breakpoint(coquery_single_return_breakpoint{ clsid, iid, args[2].value, function_name.data() }, return_addr) }; FAILED(hr)) {
            _logger.log_error_dml(std::format(L"Error when setting return breakpoint from {}", function_name), hr);
        }
    }
};

void comonitor::handle_IClassFactory_CreateInstance(const CLSID& clsid) {
    static const std::wstring_view function_name{ L"IClassFactory::CreateInstance" };
    static const std::vector<std::wstring> arg_types { L"IClassFactory*", L"IUnknown*", L"GUID*", L"void**" };

    std::vector<call_context::arg_val> args{};
    args.reserve(arg_types.size());
    std::ranges::transform(arg_types, std::back_inserter(args), [](const auto& type) { return call_context::arg_val { type }; });

    ULONG64 return_addr{};
    RETURN_VOID_IF_FAILED(_cc.read_method_frame(CALLCONV::CC_STDCALL, args, return_addr));

    IID iid{};
    RETURN_VOID_IF_FAILED(_cc.read_object(args[2].value, &iid, sizeof iid));

    if (auto hr{ set_breakpoint(coquery_single_return_breakpoint{ clsid, iid, args[3].value, function_name.data() }, return_addr) }; FAILED(hr)) {
        _logger.log_error_dml(std::format(L"Error when setting return breakpoint from {}", function_name), hr);
    }
}

```

`comon/dbgsession.cpp`:

```cpp
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <filesystem>

#include <DbgEng.h>

#include "dbgsession.h"

using namespace comon_ext;

namespace fs = std::filesystem;

static const std::wstring_view combase_module_name{ L"combase" };

dbgsession::dbgsession()
    : _dbgclient{ create_IDebugClient() }, _dbgcontrol{ _dbgclient.query<IDebugControl4>() },
    _dbgsymbols{ _dbgclient.query<IDebugSymbols3>() }, _dbgsystemobjects{ _dbgclient.query<IDebugSystemObjects>() },
    _cc{ _dbgcontrol.get(), _dbgclient.query<IDebugDataSpaces3>().get(), _dbgclient.query<IDebugRegisters2>().get(), _dbgsymbols.get() },
    _cometa{ create_cometa(_dbgcontrol.get(), _cc) } {

    THROW_IF_FAILED(_dbgclient->GetEventCallbacksWide(_prev_callback.put()));
    THROW_IF_FAILED(_dbgclient->SetEventCallbacksWide(this));
}

HRESULT dbgsession::Breakpoint(PDEBUG_BREAKPOINT2 bp) {
    ULONG id;
    if (SUCCEEDED(bp->GetId(&id))) {
        if (auto monitor{ _monitors.find(get_active_process_id()) }; monitor != std::end(_monitors)) {
            return monitor->second.handle_breakpoint(id) ? DEBUG_STATUS_GO : DEBUG_STATUS_NO_CHANGE;
        }
    }
    return DEBUG_STATUS_NO_CHANGE;
}

STDMETHODIMP_(HRESULT __stdcall) comon_ext::dbgsession::ChangeEngineState(ULONG flags, ULONG64 argument)
{
    if (flags == DEBUG_CES_BREAKPOINTS) {
        int brk_id = static_cast<ULONG>(argument);
        if (wil::com_ptr_t<IDebugBreakpoint2> breakpoint{}; FAILED(_dbgcontrol->GetBreakpointById2(brk_id, breakpoint.put()))) {
            for (auto& monitor : _monitors) {
                monitor.second.handle_breakpoint_removed(brk_id);
            }
        }
    }
    return DEBUG_STATUS_NO_CHANGE;
}

HRESULT dbgsession::LoadModule([[maybe_unused]] ULONG64 image_file_handle, ULONG64 base_offset, [[maybe_unused]] ULONG module_size,
    [[maybe_unused]] PCWSTR module_name, [[maybe_unused]] PCWSTR image_name, [[maybe_unused]] ULONG checksum,
    ULONG timestamp) {

    std::wstring module_name_wstr { module_name == nullptr ? L"" : module_name };
    if (module_name_wstr.empty() && image_name != nullptr) {
        module_name_wstr = fs::path{ image_name }.replace_extension(L"").filename().wstring();
    }

    if (!module_name_wstr.empty()) {
        if (auto monitor{ _monitors.find(get_active_process_id()) }; monitor != std::end(_monitors)) {
            monitor->second.handle_module_load(module_name_wstr, timestamp, base_offset);
        }
    }
    return DEBUG_STATUS_NO_CHANGE;
}

HRESULT dbgsession::UnloadModule([[maybe_unused]] PCWSTR image_base_name, ULONG64 image_base_addr) {
    if (auto monitor{ _monitors.find(get_active_process_id()) }; monitor != std::end(_monitors)) {
        monitor->second.handle_module_unload(image_base_addr);
    }
    return DEBUG_STATUS_NO_CHANGE;
}

HRESULT dbgsession::ExitProcess([[maybe_unused]] ULONG exit_code) {
    detach();
    return DEBUG_STATUS_NO_CHANGE;
}

```

`comon/dbgsession.h`:

```h
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once

#include <array>
#include <functional>
#include <memory>
#include <unordered_map>
#include <unordered_set>
#include <variant>
#include <stdexcept>

#include <Windows.h>
#include <wil/com.h>
#include <wil/result.h>

#include "cometa.h"
#include "comon.h"
#include "arch.h"
#include "comonitor.h"

namespace comon_ext {

class dbgsession: public DebugBaseEventCallbacksWide {
private:
    const wil::com_ptr<IDebugClient5> _dbgclient;
    const wil::com_ptr<IDebugControl4> _dbgcontrol;
    const wil::com_ptr<IDebugSymbols3> _dbgsymbols;
    const wil::com_ptr<IDebugSystemObjects> _dbgsystemobjects;

    const call_context _cc;

    cometa _cometa;

    wil::com_ptr<IDebugEventCallbacksWide> _prev_callback{};

    // maps Engine Process IDs with monitor instances
    std::unordered_map<ULONG, comonitor> _monitors{};

    static wil::com_ptr_t<IDebugClient5> create_IDebugClient() {
        wil::com_ptr_t<IDebugClient5> client;
        THROW_IF_FAILED(::DebugCreate(__uuidof(IDebugClient5), client.put_void()));
        return client;
    }

    static cometa create_cometa(IDebugControl4* dbgcontrol, const call_context& cc) {
        auto name{ cc.is_64bit() ? "cometa_64.db3" : "cometa_32.db3" };
        if (auto path{ fs::temp_directory_path() / name }; fs::exists(path)) {
            if (cometa::is_valid_db(path)) {
                return cometa{ dbgcontrol, cc.is_wow64(), path, false };
            } else {
                return cometa{ dbgcontrol, cc.is_wow64(), "", true };
            }
        } else {
            return cometa{ dbgcontrol, cc.is_wow64(), path, true };
        }
    }

    auto get_active_process_id() const {
        ULONG pid{};
        _dbgsystemobjects->GetCurrentProcessId(&pid);
        return pid;
    }

public:
    dbgsession();

    ~dbgsession() {
        if (_dbgclient) {
            _dbgclient->SetEventCallbacksWide(_prev_callback.get());
        }
    }

    STDMETHOD_(ULONG, AddRef)() override { return 1; }
    STDMETHOD_(ULONG, Release)() override { return 1; }

    STDMETHOD(GetInterestMask)(PULONG mask) override {
        *mask = DEBUG_EVENT_EXIT_PROCESS | DEBUG_EVENT_BREAKPOINT | DEBUG_EVENT_LOAD_MODULE | DEBUG_EVENT_UNLOAD_MODULE |
            DEBUG_EVENT_CHANGE_ENGINE_STATE;
        return S_OK;
    }

    STDMETHOD(Breakpoint)(PDEBUG_BREAKPOINT2 bp) override;

    STDMETHOD(ChangeEngineState)(ULONG Flags, ULONG64 Argument) override;

    STDMETHOD(LoadModule)
        (ULONG64 image_file_handle, ULONG64 base_offset, ULONG module_size, PCWSTR module_name, PCWSTR image_name, ULONG checksum,
            ULONG timestamp) override;

    STDMETHOD(UnloadModule)(PCWSTR image_base_name, ULONG64 base_offset) override;

    STDMETHOD(ExitProcess)(ULONG exit_code) override;

    comonitor* find_active_monitor() {
        if (auto monitor{ _monitors.find(get_active_process_id()) }; monitor != std::end(_monitors)) {
            return &monitor->second;
        }
        return nullptr;
    }

    void attach(const cofilter& filter) {
        if (auto pid{ get_active_process_id() }; !_monitors.contains(pid)) {
            _monitors.insert({ pid, comonitor{ _dbgclient.get(), _cometa, _cc, filter } });
        }
    }

    void detach() {
        if (auto monitor{ _monitors.find(get_active_process_id()) }; monitor != std::end(_monitors)) {
            _monitors.erase(monitor);
        }
    }

    cometa& get_metadata() { return _cometa; }
};

}

```

`comon/ext.cpp`:

```cpp
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <algorithm>
#include <filesystem>
#include <format>
#include <functional>
#include <memory>
#include <tuple>
#include <vector>
#include <span>
#include <ranges>

#include <DbgEng.h>
#include <wil/com.h>

#include "comon.h"
#include "dbgsession.h"

using namespace comon_ext;

namespace fs = std::filesystem;

namespace {
dbgsession g_dbgsession{};

const wchar_t* monitor_not_enabled_error{ L"COM monitor not enabled for the current process. Run !comon attach to enable it.\n" };

std::vector<std::string> split_args(std::string_view args) {
    char citation_char{ '\0' };
    std::vector<std::string> vargs{};
    std::string token{};

    for (auto c : args) {
        if (citation_char != '\0') {
            if (c == citation_char) {
                if (!token.empty()) {
                    vargs.push_back(token);
                    token.clear();
                }
                citation_char = '\0';
            } else {
                token.push_back(c);
            }
        } else if (c == '"' || c == '\'') {
            citation_char = c;
        } else if (std::isspace(c) || c == ',') {
            if (!token.empty()) {
                vargs.push_back(token);
                token.clear();
            }
        } else {
            token.push_back(c);
        }
    }

    if (!token.empty()) {
        vargs.push_back(token);
    }

    return vargs;
}

void cometa_showi(wil::com_ptr_t<IDebugControl4> dbgcontrol, comon_ext::cometa& cometa, const IID& iid) {
    if (auto cotype{ cometa.resolve_type(iid) }; cotype) {
        dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
            std::format(L"Found: {:b} ({})\n\n", iid, cotype->name).c_str());

        if (auto methods{ cometa.get_type_methods(iid) }; methods) {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"Methods:\n");
            for (size_t i = 0; i < methods->size(); i++) {
                auto& method = methods->at(i);
                auto method_args{ cometa.get_type_method_args(method) };
                assert(method_args);

                dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, std::format(L"- [{}] {} {}(", i, method.return_type, method.name).c_str());

                auto arg_iter = method_args->begin();
                if (arg_iter != method_args->end()) {
                    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, std::format(L"{} {}", arg_iter->type, arg_iter->name).c_str());
                    arg_iter++;
                }
                while (arg_iter != method_args->end()) {
                    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, std::format(L", {} {}", arg_iter->type, arg_iter->name).c_str());
                    arg_iter++;
                }
                dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, std::format(L")\n", i, method.return_type, method.name).c_str());
            }
        } else {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"No information about the interface methods :(\n");
        }
    } else {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL,
            std::format(L"Can't find any details on IID: {:b} in the metadata.\n", iid).c_str());
    }

    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\nRegistered VTables for IID:\n");
    for (auto& [module_name, clsid, vtbl] : cometa.find_vtables_by_iid(iid)) {
        auto clsid_name{ cometa.resolve_class_name(clsid) };
        dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL, std::format(
            L"- Module: <link cmd=\"!cometa showm {0}\">{0}</link>, CLSID: <link cmd=\"!cometa showc {1:b}\">{1:b}</link> ({2}), VTable offset: {3:#x}\n",
            module_name, clsid, clsid_name ? *clsid_name : L"N/A", vtbl).c_str());
    }
    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\n");
}

void cometa_showc(wil::com_ptr_t<IDebugControl4> dbgcontrol, comon_ext::cometa& cometa, const CLSID& clsid) {
    if (auto coclass{ cometa.resolve_class(clsid) }; coclass) {
        dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
            std::format(L"Found: {:b} ({})\n", clsid, coclass->name).c_str());
    } else {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL,
            std::format(L"Can't find any details on CLSID: {:b} in the metadata.\n", clsid).c_str());
    }

    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\nRegistered VTables for CLSID:\n");
    for (auto& [module_name, iid, vtbl] : cometa.find_vtables_by_clsid(clsid)) {
        auto iid_name{ cometa.resolve_type_name(iid) };
        dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL, std::format(
            L"- module: <link cmd=\"!cometa showm {0}\">{0}</link>, IID: <link cmd=\"!cometa showi {1:b}\">{1:b}</link> ({2}), VTable offset: {3:#x}\n",
            module_name, iid, iid_name ? *iid_name : L"N/A", vtbl).c_str());
    }
    dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\n");
}

void cometa_showm(wil::com_ptr_t<IDebugControl4> dbgcontrol, comon_ext::cometa& cometa, const std::wstring& module_name) {
    if (auto clsids{ cometa.find_clsids_by_module_name(module_name) }; !clsids.empty()) {
        std::ranges::sort(clsids, std::ranges::greater{}, [](auto& v) { return std::get<0>(v); });

        ULONG timestamp{};
        for (auto& [module_timestamp, clsid] : clsids) {
            if (module_timestamp != timestamp) {
                dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL,
                    std::format(L"\nRegistered CLSIDs for module with timestamp {:#x}:\n", timestamp).c_str());
                timestamp = module_timestamp;
            }
            auto clsid_name{ cometa.resolve_class_name(clsid) };
            dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
                std::format(L"- CLSID: <link cmd=\"!cometa showc {0:b}\">{0:b}</link> ({1})\n",
                    clsid, clsid_name ? *clsid_name : L"N/A").c_str());
        }
        dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\n");
    } else {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL,
            std::format(L"Can't find any details on module '{}' in the metadata.\n", module_name).c_str());
    }
}

HRESULT try_finding_active_monitor(IDebugControl4* dbgcontrol, comonitor** monitor) {
    if (auto m{ g_dbgsession.find_active_monitor() }; m) {
        *monitor = m;
        return S_OK;
    } else {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, monitor_not_enabled_error);
        *monitor = nullptr;
        return E_FAIL;
    }
}

HRESULT evaluate_number(IDebugControl4* dbgeng, std::string_view arg, PULONG64 number) {
    try {
        if (arg.starts_with("0x")) {
            *number = std::stoull(arg.data(), nullptr, 16);
        } else if (arg.starts_with("0y")) {
            *number = std::stoull(arg.data() + 2, nullptr, 2);
        } else if (arg.starts_with("0t")) {
            *number = std::stoull(arg.data() + 2, nullptr, 8);
        } else if (arg.starts_with("0n")) {
            *number = std::stoull(arg.data() + 2, nullptr, 10);
        } else {
            ULONG radix{};
            RETURN_IF_FAILED(dbgeng->GetRadix(&radix));
            size_t pos{};
            *number = std::stoull(arg.data(), &pos, radix);
            return pos == arg.size() ? S_OK : E_INVALIDARG;
        }
        return S_OK;
    } catch (std::exception&) {
        return E_INVALIDARG;
    }
}

}

extern "C" HRESULT CALLBACK DebugExtensionInitialize(PULONG version, PULONG flags) {
    *version = DEBUG_EXTENSION_VERSION(EXT_MAJOR_VER, EXT_MINOR_VER);
    *flags = 0;
    return S_OK;
}

extern "C" void CALLBACK DebugExtensionNotify([[maybe_unused]] ULONG notify, [[maybe_unused]] ULONG64 argument) {}

extern "C" void CALLBACK DebugExtensionUninitialize(void) { g_dbgsession.detach(); }

extern "C" HRESULT CALLBACK cometa(IDebugClient * dbgclient, PCSTR args) {
    wil::com_ptr_t<IDebugControl4> dbgcontrol;
    RETURN_IF_FAILED(dbgclient->QueryInterface(__uuidof(IDebugControl4), dbgcontrol.put_void()));

    auto vargs{ split_args(args) };

    if (vargs.size() == 0) {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
        return E_INVALIDARG;
    }

    auto& cometa{ g_dbgsession.get_metadata() };
    if (vargs[0] == "index") {
        return vargs.size() == 1 ? cometa.index() : cometa.index(widen(vargs[1]));
    } else if (vargs[0] == "save") {
        if (vargs.size() != 2) {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
            return E_INVALIDARG;
        }
        return cometa.save(widen(vargs[1]));
    } else if (vargs[0] == "showi") {
        if (vargs.size() != 2) {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
            return E_INVALIDARG;
        }
        if (IID iid{}; SUCCEEDED(try_parse_guid(widen(vargs[1]), iid))) {
            cometa_showi(dbgcontrol, cometa, iid);
            return S_OK;
        } else {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: incorrect format of IID.\n");
            return E_INVALIDARG;
        }
    } else if (vargs[0] == "showc") {
        if (vargs.size() != 2) {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
            return E_INVALIDARG;
        }
        if (CLSID clsid{}; SUCCEEDED(try_parse_guid(widen(vargs[1]), clsid))) {
            cometa_showc(dbgcontrol, cometa, clsid);
            return S_OK;
        } else {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: incorrect format of CLSID.\n");
            return E_INVALIDARG;
        }
    } else if (vargs[0] == "showm") {
        if (vargs.size() != 2) {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
            return E_INVALIDARG;
        }
        cometa_showm(dbgcontrol, cometa, widen(vargs[1]));
        return S_OK;
    } else {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: unknown subcommand. Run !cohelp to check the syntax.\n");
        return E_INVALIDARG;
    }
}

extern "C" HRESULT CALLBACK comon(IDebugClient * dbgclient, PCSTR args) {
    wil::com_ptr_t<IDebugControl4> dbgcontrol;
    RETURN_IF_FAILED(dbgclient->QueryInterface(__uuidof(IDebugControl4), dbgcontrol.put_void()));

    auto print_filter = [&dbgcontrol](const cofilter& filter) {
        auto print_clsids = [&dbgcontrol](const std::unordered_set<CLSID>& clsids) {
            for (auto& clsid : clsids) {
                dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, std::format(L"- {:b}\n", clsid).c_str());
            }
        };

        if (auto fltr = std::get_if<including_filter>(&filter); fltr) {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\nCLSIDs to monitor:\n");
            print_clsids(fltr->clsids);
            return;
        }
        if (auto fltr = std::get_if<excluding_filter>(&filter); fltr) {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\nCLSIDs to EXCLUDE while monitoring:\n");
            print_clsids(fltr->clsids);
            return;
        }
        assert(std::holds_alternative<no_filter>(filter));
    };

    auto parse_filter = [](std::span<const std::string> args) -> cofilter {
        std::unordered_set<CLSID> clsids{};
        for (auto iter{ std::crbegin(args) }; iter != std::crend(args); iter++) {
            if (*iter == "-i") {
                return including_filter{ clsids };
            }
            if (*iter == "-e") {
                return excluding_filter{ clsids };
            }
            GUID clsid;
            if (SUCCEEDED(try_parse_guid(widen(*iter), clsid))) {
                clsids.insert(clsid);
            }
        }
        if (clsids.size() > 0) {
            return including_filter{ clsids };
        }
        return no_filter{};
    };

    auto vargs{ split_args(args) };
    if (vargs.size() < 1) {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
        return E_INVALIDARG;
    }

    if (vargs[0] == "attach") {
        auto filter = parse_filter(std::span{ vargs }.subspan(1));
        g_dbgsession.attach(filter);
        dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL, L"<b>COM monitor enabled for the current process.</b>\n");
        print_filter(filter);
        return S_OK;
    }

    comonitor* monitor{};
    RETURN_IF_FAILED(try_finding_active_monitor(dbgcontrol.get(), &monitor));

    if (vargs[0] == "attach") {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"COM monitor is already enabled for the current process.");
        return E_FAIL;
    } else if (vargs[0] == "pause") {
        monitor->pause();
    } else if (vargs[0] == "resume") {
        monitor->resume();
    } else if (vargs[0] == "detach") {
        g_dbgsession.detach();
    } else if (vargs[0] == "status") {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, std::format(L"COM monitor is {}\n",
            monitor->is_paused() ? L"PAUSED" : L"RUNNING").c_str());

        auto& cometa{ g_dbgsession.get_metadata() };
        dbgcontrol->OutputWide(DEBUG_OUTPUT_NORMAL, L"\nCOM types recorded for the current process:\n");
        for (auto& [clsid, vtables] : monitor->list_cotypes()) {
            auto clsid_name{ cometa.resolve_class_name(clsid) };
            dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
                std::format(L"\n<col fg=\"srcannot\">CLSID: <b>{:b} ({})</b></col>\n", clsid, clsid_name ? *clsid_name : L"N/A").c_str());
            for (auto& [addr, iid] : vtables) {
                auto iid_name{ cometa.resolve_type_name(iid) };
                dbgcontrol->ControlledOutputWide(DEBUG_OUTCTL_AMBIENT_DML, DEBUG_OUTPUT_NORMAL,
                    std::format(L"  IID: <b>{:b} ({})</b>, address: {:#x}\n", iid, iid_name ? *iid_name : L"N/A", addr).c_str());
            }
        }
    } else {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
        return E_INVALIDARG;
    }
    return S_OK;
}

extern "C" HRESULT CALLBACK coreg(IDebugClient * dbgclient, PCSTR args) {
    wil::com_ptr_t<IDebugControl4> dbgcontrol;
    RETURN_IF_FAILED(dbgclient->QueryInterface(__uuidof(IDebugControl4), dbgcontrol.put_void()));

    auto vargs{ split_args(args) };

    if (vargs.size() < 3) {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
        return E_INVALIDARG;
    }

    comonitor* monitor{};
    RETURN_IF_FAILED(try_finding_active_monitor(dbgcontrol.get(), &monitor));

    bool save_in_database{ true };
    bool replace_if_exists{};
    int arg_start_index = 0;

    if (vargs[arg_start_index] == "--nosave") {
        arg_start_index++;
        save_in_database = false;
    }

    if (vargs[arg_start_index] == "--force") {
        arg_start_index++;
        replace_if_exists = true;
    }

    if (vargs.size() - arg_start_index < 3) {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
        return E_INVALIDARG;
    }

    CLSID clsid;
    RETURN_IF_FAILED(try_parse_guid(widen(vargs[arg_start_index]), clsid));
    IID iid;
    RETURN_IF_FAILED(try_parse_guid(widen(vargs[arg_start_index + 1]), iid));

    ULONG64 vtable_addr{};
    RETURN_IF_FAILED(evaluate_number(dbgcontrol.get(), vargs[arg_start_index + 2], &vtable_addr));

    return monitor->register_vtable(clsid, iid, vtable_addr, save_in_database, replace_if_exists);
}

extern "C" HRESULT CALLBACK cobp(IDebugClient * dbgclient, PCSTR args) {
    auto parse_behavior = [](const std::string& arg) -> std::optional<cobreakpoint_behavior> {
        if (arg == "--before") {
            return cobreakpoint_behavior::stop_before_call;
        }
        if (arg == "--after") {
            return cobreakpoint_behavior::stop_after_call;
        }
        if (arg == "--always") {
            return cobreakpoint_behavior::always_stop;
        }
        if (arg == "--trace-only") {
            return cobreakpoint_behavior::never_stop;
        }
        return std::nullopt;
    };

    wil::com_ptr_t<IDebugControl4> dbgcontrol;
    RETURN_IF_FAILED(dbgclient->QueryInterface(__uuidof(IDebugControl4), reinterpret_cast<LPVOID*>(dbgcontrol.put())));

    auto vargs{ split_args(args) };

    int arg_start = 0;
    cobreakpoint_behavior behavior = cobreakpoint_behavior::stop_before_call;
    if (vargs.size() > 0) {
        if (auto bopt{ parse_behavior(vargs[0]) }; bopt) {
            behavior = *bopt;
            arg_start++;
        }
    }

    if (vargs.size() - arg_start < 3) {
        dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: invalid arguments. Run !cohelp to check the syntax.\n");
        return E_INVALIDARG;
    }

    comonitor* monitor{};
    RETURN_IF_FAILED(try_finding_active_monitor(dbgcontrol.get(), &monitor));

    CLSID clsid;
    RETURN_IF_FAILED(try_parse_guid(widen(vargs[arg_start]), clsid));
    IID iid;
    RETURN_IF_FAILED(try_parse_guid(widen(vargs[arg_start + 1]), iid));

    ULONG64 method_num{};
    if (FAILED(evaluate_number(dbgcontrol.get(), vargs[arg_start + 2], &method_num))) {
        auto& cometa{ g_dbgsession.get_metadata() };
        if (auto methods{ cometa.get_type_methods(iid) }; methods) {
            auto method_name{ widen(vargs[arg_start + 2]) };
            auto matching_method = [&method_name](const comethod& method) { return method.name == method_name; };
            if (auto res{ std::find_if(std::cbegin(*methods), std::cend(*methods), matching_method) };res != std::end(*methods)) {
                method_num = static_cast<DWORD>(res - std::begin(*methods));
                return monitor->create_cobreakpoint(clsid, iid, static_cast<DWORD>(method_num), behavior);
            } else {
                dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: Could not find a method with the given name in the metadata.\n");
                return E_INVALIDARG;
            }
        } else {
            dbgcontrol->OutputWide(DEBUG_OUTPUT_ERROR, L"ERROR: No methods found for a given type in the metadata.\n");
            return E_INVALIDARG;
        }
    } else {
        return monitor->create_cobreakpoint(clsid, iid, static_cast<DWORD>(method_num), behavior);
    }
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved) {
    UNREFERENCED_PARAMETER(lpReserved);

    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        ::DisableThreadLibraryCalls(hModule);
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

```

`comon/ext.def`:

```def

;   lldext.def
;--------------------------------------------------------------------
EXPORTS
     DebugExtensionNotify
     DebugExtensionInitialize
     DebugExtensionUninitialize

     cometa
     cohelp
     comon
     coreg
     cobp
```

`comon/helpers.cpp`:

```cpp
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#include <string>
#include <cassert>
#include <vector>
#include <sstream>
#include <ranges>
#include <format>
#include <functional>
#include <Windows.h>
#include <wil/result.h>

#include "comon.h"

namespace comon_ext
{

std::wstring widen(std::string_view s) {
    std::wstring out{};
    if (!s.empty()) {
        int len = ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s.data(), static_cast<int>(s.size()), nullptr, 0);
        if (len == 0) {
            THROW_LAST_ERROR();
        }

        out.resize(len, '\0');
        assert(static_cast<int>(out.size()) == len);

        if (len != ::MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, s.data(), static_cast<int>(s.size()),
            out.data(), static_cast<int>(out.size()))) {
            THROW_LAST_ERROR();
        }
    }
    return out;
}

std::string narrow(std::wstring_view ws) {
    std::string out{};
    if (!ws.empty()) {
        int len = ::WideCharToMultiByte(CP_ACP, 0, ws.data(), static_cast<int>(ws.size()), nullptr, 0, nullptr, nullptr);
        if (len == 0) {
            THROW_LAST_ERROR();
        }

        out.resize(len, '\0');
        assert(static_cast<int>(out.size()) == len);

        if (len != ::WideCharToMultiByte(CP_ACP, 0, ws.data(), static_cast<int>(ws.size()), out.data(),
            static_cast<int>(out.size()), nullptr, nullptr)) {
            THROW_LAST_ERROR();
        }
    }
    return out;
}


std::string to_utf8(std::wstring_view ws) {
    std::string out{};
    if (!ws.empty()) {
        int len = ::WideCharToMultiByte(CP_UTF8, 0, ws.data(), static_cast<int>(ws.size()), nullptr, 0, nullptr, nullptr);
        if (len == 0) {
            THROW_LAST_ERROR();
        }

        out.resize(len, '\0');
        assert(static_cast<int>(out.size()) == len);

        if (len != ::WideCharToMultiByte(CP_UTF8, 0, ws.data(), static_cast<int>(ws.size()), out.data(),
            static_cast<int>(out.size()), nullptr, nullptr)) {
            THROW_LAST_ERROR();
        }
    }
    return out;
}

std::wstring from_utf8(std::string_view s) {
    std::wstring out{};
    if (!s.empty()) {
        int len = ::MultiByteToWideChar(CP_UTF8, 0, s.data(), static_cast<int>(s.size()), nullptr, 0);
        if (len == 0) {
            THROW_LAST_ERROR();
        }

        out.resize(len, '\0');
        assert(static_cast<int>(out.size()) == len);

        if (len != ::MultiByteToWideChar(CP_UTF8, 0, s.data(), static_cast<int>(s.size()),
            out.data(), static_cast<int>(out.size()))) {
            THROW_LAST_ERROR();
        }
    }
    return out;
}

std::wstring wstring_from_guid(const GUID& guid) {
    wil::unique_cotaskmem_string s{};
    auto hr = ::StringFromIID(guid, s.put());
    if (SUCCEEDED(hr)) {
        return { s.get() };
    }
    return std::format(L"<invalid: {:#x}>", static_cast<DWORD>(hr));
}

GUID parse_guid(std::wstring_view ws) {
    GUID guid;
    THROW_IF_FAILED(try_parse_guid(ws, guid));
    return guid;
}

HRESULT try_parse_guid(std::wstring_view ws, GUID& guid) {
    if (ws.size() > 2 && ws[0] != '{' && ws[ws.size() - 1] != '}') {
        std::wstring nws(ws.size() + 2, '\0');
        nws[0] = '{';
        std::ranges::copy(ws.cbegin(), ws.cend(), nws.begin() + 1);
        nws[nws.size() - 1] = '}';

        return ::IIDFromString(nws.c_str(), &guid);
    }

    return ::IIDFromString(ws.data(), &guid);
}
}

```

`comon/lfu_cache.h`:

```h
/*
   Copyright 2022 Sebastian Solnica

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

#pragma once

#include <tuple>
#include <utility>
#include <map>
#include <unordered_map>
#include <unordered_set>
#include <cassert>
#include <stdexcept>
#include <ranges>
#include <algorithm>

#include <Windows.h>

namespace views = std::ranges::views;

namespace comon_ext
{
template<typename K, typename O>
class lfu_cache
{
    const size_t _capacity;
    std::unordered_map<K, std::pair<O, int32_t>> _cache{};
    std::map<int, std::unordered_set<K>> _cache_freqs{};

    void discard_from_frequency(int32_t freq, const K& key);

    void add_to_frequency(int32_t freq, const K& key);

    K extract_least_frequent();

public:

    lfu_cache(size_t capacity): _capacity{ capacity } {
        if (capacity <= 0) {
            throw std::invalid_argument{ "capacity" };
        }
    }

    bool contains(const K& key) const;

    const O& get(const K& key);

    void insert(const K& key, const O& data);

    void clear() {
        _cache_freqs.clear();
        _cache.clear();
    }
};

template<typename K, typename O>
void lfu_cache<K, O>::discard_from_frequency(int32_t freq, const K& key) {
    assert(_cache_freqs.contains(freq));
    auto& freqs{ _cache_freqs[freq] };
    assert(freqs.contains(key));
    freqs.erase(key);

    if (freqs.empty()) {
        _cache_freqs.erase(freq);
    }
}

template<typename K, typename O>
void lfu_cache<K, O>::add_to_frequency(int32_t freq, const K& key) {
    if (auto freqs_iter{ _cache_freqs.find(freq) }; freqs_iter == std::end(_cache_freqs)) {
        _cache_freqs.emplace(std::make_pair(freq, std::unordered_set<K>{key}));
    } else {
        freqs_iter->second.insert(key);
    }
}

template<typename K, typename O>
K lfu_cache<K, O>::extract_least_frequent() {
    assert(!_cache_freqs.empty());
    auto freqs_iter{ std::begin(_cache_freqs) };

    auto& freqs{ freqs_iter->second };
    assert(!freqs.empty());
    auto key_iter{ std::begin(freqs) };
    auto res{ *key_iter };
    freqs.erase(key_iter);

    if (freqs.empty()) {
        _cache_freqs.erase(freqs_iter);
    }
    return res;
}

template<typename K, typename O>
bool lfu_cache<K, O>::contains(const K& key) const {
    return _cache.contains(key);
}

template<typename K, typename O>
const O& lfu_cache<K, O>::get(const K& key) {
    assert(_cache.contains(key));
    auto& elem{ _cache[key] };

    auto freq{ elem.second };
    auto new_freq{ freq + 1 };

    elem.second = new_freq;
    discard_from_frequency(freq, key);
    add_to_frequency(new_freq, key);

    return elem.first;
}

template<typename K, typename O>
void lfu_cache<K, O>::insert(const K& key, const O& data) {
    if (!_cache.contains(key)) {
        if (_cache.size() >= _capacity) {
            // we need to free some space
            assert(_cache.size() == _capacity);
            _cache.erase(extract_least_frequent());
        }
        _cache.emplace(std::make_pair(key, std::make_pair(data, 1)));
        add_to_frequency(1, key);
    }
}
}

```

`comon/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`comon/resource.rc.in`:

```in
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION @comon_VERSION_MAJOR@,@comon_VERSION_MINOR@,@comon_VERSION_PATCH@,@comon_VERSION_TWEAK@
 PRODUCTVERSION @comon_VERSION_MAJOR@,@comon_VERSION_MINOR@,@comon_VERSION_PATCH@,@comon_VERSION_TWEAK@
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Sebastian Solnica"
            VALUE "FileDescription", "Comon - a WinDbg extension to trace COM"
            VALUE "FileVersion", "@comon_VERSION_MAJOR@.@comon_VERSION_MINOR@.@comon_VERSION_PATCH@.@comon_VERSION_TWEAK@"
            VALUE "InternalName", "comon.dll"
            VALUE "LegalCopyright", "Copyright (C) Sebastian Solnica 2022"
            VALUE "OriginalFilename", "comon.dll"
            VALUE "ProductName", "comon"
            VALUE "ProductVersion", "@comon_VERSION_MAJOR@.@comon_VERSION_MINOR@.@comon_VERSION_PATCH@.@comon_VERSION_TWEAK@"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`vcpkg.json`:

```json
{
  "$schema": "https://raw.githubusercontent.com/microsoft/vcpkg-tool/main/docs/vcpkg.schema.json",
  "name": "comon",
  "version": "1.0.0",
  "dependencies": [
    "wil",
    "sqlitecpp"
  ]
}
```