Project Path: arc_MxIris-Reverse-Engineering_RuntimeViewer_u6hutv0r

Source Tree:

```txt
arc_MxIris-Reverse-Engineering_RuntimeViewer_u6hutv0r
â”œâ”€â”€ AGENTS.md
â”œâ”€â”€ ArchiveExportConfig-Catalyst.plist
â”œâ”€â”€ ArchiveExportConfig.plist
â”œâ”€â”€ ArchiveScript.sh
â”œâ”€â”€ BuildRuntimeViewerServerXCFramework.sh
â”œâ”€â”€ CLAUDE.md
â”œâ”€â”€ Changelogs
â”‚   â””â”€â”€ v2.0.0.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ Resources
â”‚   â”œâ”€â”€ AppIcon.icon
â”‚   â”‚   â”œâ”€â”€ Assets
â”‚   â”‚   â”‚   â””â”€â”€ Background 2.png
â”‚   â”‚   â””â”€â”€ icon.json
â”‚   â”œâ”€â”€ AppIcon.png
â”‚   â”œâ”€â”€ Screenshot-001.png
â”‚   â”œâ”€â”€ Screenshot-002.png
â”‚   â””â”€â”€ Screenshot-003.png
â”œâ”€â”€ RuntimeViewer.xcworkspace
â”‚   â”œâ”€â”€ contents.xcworkspacedata
â”‚   â””â”€â”€ xcshareddata
â”‚       â”œâ”€â”€ IDEWorkspaceChecks.plist
â”‚       â””â”€â”€ WorkspaceSettings.xcsettings
â”œâ”€â”€ RuntimeViewerCore
â”‚   â”œâ”€â”€ Package.swift
â”‚   â”œâ”€â”€ Sources
â”‚   â”‚   â”œâ”€â”€ RuntimeViewerCommunication
â”‚   â”‚   â”‚   â”œâ”€â”€ Connections
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeConnectionBase.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeDirectTCPConnection.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeLocalSocketConnection.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeNetworkConnection.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeStdioConnection.swift
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RuntimeXPCConnection.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ Requests
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FetchEndpointRequest.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ FileOperationRequest.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ InjectApplicationRequest.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ OpenApplicationRequest.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PingRequest.swift
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RegisterEndpointRequest.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeCommunicator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeConnection.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeConnectionState.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeMessageChannel.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeNetwork.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeRequestResponse.swift
â”‚   â”‚   â”‚   â””â”€â”€ RuntimeSource.swift
â”‚   â”‚   â”œâ”€â”€ RuntimeViewerCore
â”‚   â”‚   â”‚   â”œâ”€â”€ Common
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeBookmark.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeImageLoadState.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeImageNode.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeObject+Export.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeObject.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeObjectInterface+GenerationOptions.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeObjectInterface.swift
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RuntimeObjectKind.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ Core
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeObjCSection.swift
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RuntimeSwiftSection.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ Export
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeInterfaceExportConfiguration.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeInterfaceExportEvent.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeInterfaceExportItem.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeInterfaceExportReporter.swift
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RuntimeInterfaceExportWriter.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeEngine.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ Transformer
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Transformer+CType.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Transformer+SwiftEnumLayout.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Transformer+SwiftFieldOffset.swift
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Transformer+SwiftTypeLayout.swift
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Transformer.swift
â”‚   â”‚   â”‚   â””â”€â”€ Utils
â”‚   â”‚   â”‚       â”œâ”€â”€ DyldUtilities.swift
â”‚   â”‚   â”‚       â”œâ”€â”€ ObjCDump+SemanticString.swift
â”‚   â”‚   â”‚       â””â”€â”€ SwiftStdlib+.swift
â”‚   â”‚   â””â”€â”€ RuntimeViewerCoreObjC
â”‚   â”‚       â”œâ”€â”€ RuntimeViewerCoreObjC.m
â”‚   â”‚       â””â”€â”€ include
â”‚   â”‚           â””â”€â”€ RuntimeViewerCoreObjC.h
â”‚   â””â”€â”€ Tests
â”‚       â””â”€â”€ RuntimeViewerCommunicationTests
â”‚           â”œâ”€â”€ RuntimeLocalSocketConnectionTests.swift
â”‚           â””â”€â”€ RuntimeStdioConnectionTests.swift
â”œâ”€â”€ RuntimeViewerMCP
â”‚   â”œâ”€â”€ Package.swift
â”‚   â””â”€â”€ Sources
â”‚       â”œâ”€â”€ RuntimeViewerMCPBridge
â”‚       â”‚   â”œâ”€â”€ MCPBridgeListener.swift
â”‚       â”‚   â”œâ”€â”€ MCPBridgeServer.swift
â”‚       â”‚   â””â”€â”€ MCPBridgeWindowProvider.swift
â”‚       â””â”€â”€ RuntimeViewerMCPShared
â”‚           â”œâ”€â”€ MCPBridgeProtocol.swift
â”‚           â””â”€â”€ MCPBridgeTransport.swift
â”œâ”€â”€ RuntimeViewerPackages
â”‚   â”œâ”€â”€ Package.swift
â”‚   â””â”€â”€ Sources
â”‚       â”œâ”€â”€ RuntimeViewerApplication
â”‚       â”‚   â”œâ”€â”€ AppDefaults.swift
â”‚       â”‚   â”œâ”€â”€ Content
â”‚       â”‚   â”‚   â”œâ”€â”€ ContentPlaceholderViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ ContentRoute.swift
â”‚       â”‚   â”‚   â””â”€â”€ ContentTextViewModel.swift
â”‚       â”‚   â”œâ”€â”€ DocumentState.swift
â”‚       â”‚   â”œâ”€â”€ Extensions.swift
â”‚       â”‚   â”œâ”€â”€ FilterEngine.swift
â”‚       â”‚   â”œâ”€â”€ Inspector
â”‚       â”‚   â”‚   â”œâ”€â”€ InspectorClassViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ InspectorRoute.swift
â”‚       â”‚   â”‚   â””â”€â”€ InspectorViewModel.swift
â”‚       â”‚   â”œâ”€â”€ Sidebar
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRootBookmarkViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRootCellViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRootDirectoryViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRootViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRoutes.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectBookmarkViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectCellViewModel.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectListViewModel.swift
â”‚       â”‚   â”‚   â””â”€â”€ SidebarRuntimeObjectViewModel.swift
â”‚       â”‚   â”œâ”€â”€ Theme
â”‚       â”‚   â”‚   â”œâ”€â”€ SemanticString+ThemeProfile.swift
â”‚       â”‚   â”‚   â””â”€â”€ ThemeProfile.swift
â”‚       â”‚   â”œâ”€â”€ Then.swift
â”‚       â”‚   â”œâ”€â”€ ViewModel.swift
â”‚       â”‚   â””â”€â”€ ViewModelProtocol.swift
â”‚       â”œâ”€â”€ RuntimeViewerArchitectures
â”‚       â”‚   â””â”€â”€ RuntimeViewerArchitectures.swift
â”‚       â”œâ”€â”€ RuntimeViewerCatalystExtensions
â”‚       â”‚   â””â”€â”€ Extensions.swift
â”‚       â”œâ”€â”€ RuntimeViewerHelperClient
â”‚       â”‚   â”œâ”€â”€ HelperServiceManager.swift
â”‚       â”‚   â”œâ”€â”€ RuntimeHelperClient.swift
â”‚       â”‚   â””â”€â”€ RuntimeInjectClient.swift
â”‚       â”œâ”€â”€ RuntimeViewerService
â”‚       â”‚   â””â”€â”€ RuntimeViewerService.swift
â”‚       â”œâ”€â”€ RuntimeViewerServiceHelper
â”‚       â”‚   â”œâ”€â”€ RVLegacyHelperTool.m
â”‚       â”‚   â””â”€â”€ include
â”‚       â”‚       â””â”€â”€ RVLegacyHelperTool.h
â”‚       â”œâ”€â”€ RuntimeViewerSettings
â”‚       â”‚   â”œâ”€â”€ Settings+DependencyValues.swift
â”‚       â”‚   â”œâ”€â”€ Settings+Types.swift
â”‚       â”‚   â”œâ”€â”€ Settings.swift
â”‚       â”‚   â””â”€â”€ SettingsStorage.swift
â”‚       â”œâ”€â”€ RuntimeViewerSettingsUI
â”‚       â”‚   â”œâ”€â”€ AppSettings.swift
â”‚       â”‚   â”œâ”€â”€ Components
â”‚       â”‚   â”‚   â”œâ”€â”€ GeneralSettingsView.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ HelperServiceSettingsView.swift
â”‚       â”‚   â”‚   â”œâ”€â”€ NotificationSettingsView.swift
â”‚       â”‚   â”‚   â””â”€â”€ TransformerSettingsView.swift
â”‚       â”‚   â”œâ”€â”€ Resources
â”‚       â”‚   â”‚   â””â”€â”€ Assets.xcassets
â”‚       â”‚   â”‚       â”œâ”€â”€ AppearanceAuto-Old_AppearanceAuto.imageset
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceAuto-Old_AppearanceAuto@1x.png
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceAuto-Old_AppearanceAuto@2x.png
â”‚       â”‚   â”‚       â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚       â”œâ”€â”€ AppearanceAuto_AppearanceAuto_Normal.imageset
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceAuto_AppearanceAuto_Normal.png
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceAuto_AppearanceAuto_Normal@2x.png
â”‚       â”‚   â”‚       â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚       â”œâ”€â”€ AppearanceDark-Old_AppearanceDark.imageset
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceDark-Old_AppearanceDark@1x.png
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceDark-Old_AppearanceDark@2x.png
â”‚       â”‚   â”‚       â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚       â”œâ”€â”€ AppearanceDark_AppearanceDark_Normal.imageset
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceDark_AppearanceDark_Normal.png
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceDark_AppearanceDark_Normal@2x.png
â”‚       â”‚   â”‚       â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚       â”œâ”€â”€ AppearanceLight-Old_AppearanceLight.imageset
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceLight-Old_AppearanceLight@1x.png
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceLight-Old_AppearanceLight@2x.png
â”‚       â”‚   â”‚       â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚       â”œâ”€â”€ AppearanceLight_AppearanceLight_Normal.imageset
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceLight_AppearanceLight_Normal.png
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ AppearanceLight_AppearanceLight_Normal@2x.png
â”‚       â”‚   â”‚       â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚       â””â”€â”€ Contents.json
â”‚       â”‚   â”œâ”€â”€ RuntimeViewerSettingsStyle.swift
â”‚       â”‚   â”œâ”€â”€ SettingsForm.swift
â”‚       â”‚   â”œâ”€â”€ SettingsIcon.swift
â”‚       â”‚   â”œâ”€â”€ SettingsRootView.swift
â”‚       â”‚   â”œâ”€â”€ SettingsViewModel.swift
â”‚       â”‚   â””â”€â”€ SettingsWindowController.swift
â”‚       â””â”€â”€ RuntimeViewerUI
â”‚           â”œâ”€â”€ AppKit
â”‚           â”‚   â”œâ”€â”€ AreaSegmentedControl.swift
â”‚           â”‚   â”œâ”€â”€ Extensions.swift
â”‚           â”‚   â”œâ”€â”€ HUDView.swift
â”‚           â”‚   â”œâ”€â”€ ItemPopUpButton.swift
â”‚           â”‚   â”œâ”€â”€ MinimapView.swift
â”‚           â”‚   â”œâ”€â”€ NSTextContentStorage+.swift
â”‚           â”‚   â”œâ”€â”€ NSTextLayoutManager+.swift
â”‚           â”‚   â”œâ”€â”€ NSView+Skeleton.swift
â”‚           â”‚   â””â”€â”€ StatefulOutlineView.swift
â”‚           â”œâ”€â”€ RuntimeViewerUI.swift
â”‚           â”œâ”€â”€ SwiftUI
â”‚           â”‚   â””â”€â”€ VisualEffectView.swift
â”‚           â””â”€â”€ Then.swift
â”œâ”€â”€ RuntimeViewerPrecompiledLibraries
â”‚   â””â”€â”€ swift-syntax
â”‚       â”œâ”€â”€ Package.swift
â”‚       â””â”€â”€ Sources
â”‚           â”œâ”€â”€ SwiftBasicFormat_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftBasicFormat_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftCompilerPluginMessageHandling_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftCompilerPluginMessageHandling_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftCompilerPlugin_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftCompilerPlugin_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftDiagnostics_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftDiagnostics_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftIDEUtils_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftIDEUtils_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftIfConfig_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftIfConfig_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftLexicalLookup_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftLexicalLookup_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftLibraryPluginProvider_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftLibraryPluginProvider_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftOperators_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftOperators_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftParserDiagnostics_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftParserDiagnostics_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftParser_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftParser_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftRefactor_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftRefactor_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntax509_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntax509_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntax510_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntax510_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntax600_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntax600_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntax601_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntax601_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntaxBuilder_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntaxBuilder_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntaxMacroExpansion_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntaxMacroExpansion_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntaxMacrosGenericTestSupport_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntaxMacrosGenericTestSupport_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntaxMacrosTestSupport_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntaxMacrosTestSupport_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntaxMacros_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntaxMacros_Aggregation.swift
â”‚           â”œâ”€â”€ SwiftSyntax_Aggregation
â”‚           â”‚   â””â”€â”€ SwiftSyntax_Aggregation.swift
â”‚           â”œâ”€â”€ _SwiftCompilerPluginMessageHandling_Aggregation
â”‚           â”‚   â””â”€â”€ _SwiftCompilerPluginMessageHandling_Aggregation.swift
â”‚           â”œâ”€â”€ _SwiftLibraryPluginProviderCShims_Aggregation
â”‚           â”‚   â””â”€â”€ _SwiftLibraryPluginProviderCShims_Aggregation.swift
â”‚           â”œâ”€â”€ _SwiftLibraryPluginProvider_Aggregation
â”‚           â”‚   â””â”€â”€ _SwiftLibraryPluginProvider_Aggregation.swift
â”‚           â”œâ”€â”€ _SwiftSyntaxCShims_Aggregation
â”‚           â”‚   â””â”€â”€ _SwiftSyntaxCShims_Aggregation.swift
â”‚           â””â”€â”€ _SwiftSyntaxGenericTestSupport_Aggregation
â”‚               â””â”€â”€ _SwiftSyntaxGenericTestSupport_Aggregation.swift
â”œâ”€â”€ RuntimeViewerServer
â”‚   â”œâ”€â”€ RuntimeViewerServer
â”‚   â”‚   â”œâ”€â”€ RuntimeViewerServerLoader.swift
â”‚   â”‚   â””â”€â”€ main.m
â”‚   â””â”€â”€ RuntimeViewerServer.xcodeproj
â”‚       â”œâ”€â”€ project.pbxproj
â”‚       â””â”€â”€ xcshareddata
â”‚           â””â”€â”€ xcschemes
â”‚               â”œâ”€â”€ RuntimeViewerMobileServer.xcscheme
â”‚               â””â”€â”€ RuntimeViewerServer.xcscheme
â”œâ”€â”€ RuntimeViewerUsingAppKit
â”‚   â”œâ”€â”€ RuntimeViewerCatalystHelper
â”‚   â”‚   â”œâ”€â”€ AppDelegate.swift
â”‚   â”‚   â”œâ”€â”€ AppKitBridge.swift
â”‚   â”‚   â”œâ”€â”€ Assets.xcassets
â”‚   â”‚   â”‚   â”œâ”€â”€ AccentColor.colorset
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚   â”‚   â”‚   â”œâ”€â”€ AppIcon.appiconset
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚   â”‚   â”œâ”€â”€ Info.plist
â”‚   â”‚   â”œâ”€â”€ RuntimeViewerCatalystHelper.entitlements
â”‚   â”‚   â””â”€â”€ SceneDelegate.swift
â”‚   â”œâ”€â”€ RuntimeViewerCatalystHelperPlugin
â”‚   â”‚   â”œâ”€â”€ AppKitPlugin.swift
â”‚   â”‚   â””â”€â”€ AppKitPluginImpl.swift
â”‚   â”œâ”€â”€ RuntimeViewerMCPServer
â”‚   â”‚   â”œâ”€â”€ MCPBridgeClient.swift
â”‚   â”‚   â”œâ”€â”€ MCPBridgeConnection.swift
â”‚   â”‚   â””â”€â”€ main.swift
â”‚   â”œâ”€â”€ RuntimeViewerUsingAppKit
â”‚   â”‚   â”œâ”€â”€ App
â”‚   â”‚   â”‚   â”œâ”€â”€ AppDelegate.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ AppMCPBridgeWindowProvider.swift
â”‚   â”‚   â”‚   â””â”€â”€ Document.swift
â”‚   â”‚   â”œâ”€â”€ Assets.xcassets
â”‚   â”‚   â”‚   â”œâ”€â”€ AccentColor.colorset
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚   â”‚   â”‚   â”œâ”€â”€ Contents.json
â”‚   â”‚   â”‚   â”œâ”€â”€ app.fill.symbolset
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Contents.json
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ app.fill.svg
â”‚   â”‚   â”‚   â”œâ”€â”€ app.symbolset
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Contents.json
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ app.svg
â”‚   â”‚   â”‚   â””â”€â”€ inject.symbolset
â”‚   â”‚   â”‚       â”œâ”€â”€ Contents.json
â”‚   â”‚   â”‚       â””â”€â”€ syringe.svg
â”‚   â”‚   â”œâ”€â”€ Attach Process
â”‚   â”‚   â”‚   â”œâ”€â”€ AttachToProcessViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ AttachToProcessViewModel.swift
â”‚   â”‚   â”œâ”€â”€ Base
â”‚   â”‚   â”‚   â”œâ”€â”€ CommonLoadingView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ TabViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ ViewControllers.swift
â”‚   â”‚   â”œâ”€â”€ Base.lproj
â”‚   â”‚   â”‚   â””â”€â”€ MainMenu.xib
â”‚   â”‚   â”œâ”€â”€ Content
â”‚   â”‚   â”‚   â”œâ”€â”€ ContentCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ContentNavigationController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ContentPlaceholderViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ContentTextView.swift
â”‚   â”‚   â”‚   â””â”€â”€ ContentTextViewController.swift
â”‚   â”‚   â”œâ”€â”€ Debug.xcconfig
â”‚   â”‚   â”œâ”€â”€ Exporting
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingCompletionViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingCompletionViewModel.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingConfigurationViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingConfigurationViewModel.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingProgressViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingProgressViewModel.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ExportingState.swift
â”‚   â”‚   â”‚   â””â”€â”€ ExportingViewController.swift
â”‚   â”‚   â”œâ”€â”€ Generation Options
â”‚   â”‚   â”‚   â”œâ”€â”€ GenerationOptionsViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ GenerationOptionsViewModel.swift
â”‚   â”‚   â”œâ”€â”€ Info.plist
â”‚   â”‚   â”œâ”€â”€ Inspector
â”‚   â”‚   â”‚   â”œâ”€â”€ InspectorClassHierarchyView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ InspectorClassViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ InspectorCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ InspectorDisclosureView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ InspectorNavigationController.swift
â”‚   â”‚   â”‚   â””â”€â”€ InspectorPlaceholderViewController.swift
â”‚   â”‚   â”œâ”€â”€ Load Frameworks
â”‚   â”‚   â”‚   â”œâ”€â”€ LoadFrameworksViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ LoadFrameworksViewController.xib
â”‚   â”‚   â”œâ”€â”€ Main
â”‚   â”‚   â”‚   â”œâ”€â”€ MainCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ MainRoute.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ MainSplitViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ MainToolbarController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ MainViewModel.swift
â”‚   â”‚   â”‚   â””â”€â”€ MainWindowController.swift
â”‚   â”‚   â”œâ”€â”€ Release.xcconfig
â”‚   â”‚   â”œâ”€â”€ Resources
â”‚   â”‚   â”‚   â”œâ”€â”€ AppIcon.icon
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Assets
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Background 2.png
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ icon.json
â”‚   â”‚   â”‚   â””â”€â”€ RuntimeViewerSymbols.swift
â”‚   â”‚   â”œâ”€â”€ RuntimeViewerUsingAppKit.entitlements
â”‚   â”‚   â”œâ”€â”€ Sidebar
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarNavigationController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootBookmarkViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootDirectoryViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootTabViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootTableCellView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootTableRowView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectBookmarkViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectCellView.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectListViewController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRuntimeObjectTabViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ SidebarRuntimeObjectViewController.swift
â”‚   â”‚   â”œâ”€â”€ UXKit.xcframework
â”‚   â”‚   â”‚   â”œâ”€â”€ Info.plist
â”‚   â”‚   â”‚   â””â”€â”€ macos-arm64e-arm64-x86_64
â”‚   â”‚   â”‚       â””â”€â”€ UXKit.framework
â”‚   â”‚   â”‚           â”œâ”€â”€ Headers
â”‚   â”‚   â”‚           â”œâ”€â”€ Modules
â”‚   â”‚   â”‚           â”œâ”€â”€ UXKit.tbd
â”‚   â”‚   â”‚           â””â”€â”€ Versions
â”‚   â”‚   â”‚               â”œâ”€â”€ A
â”‚   â”‚   â”‚               â”‚   â”œâ”€â”€ Headers
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXBar.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXBarButtonItem.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXBarCommon.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXBarItem.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXBase.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXImageView.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXKit.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXKitAppearance.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXKitDefines.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXLabel.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXLayoutSupport.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXNavigationBar.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXNavigationController.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXNavigationItem.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXToolbar.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXView.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXViewController.h
â”‚   â”‚   â”‚               â”‚   â”‚   â”œâ”€â”€ UXViewControllerTransitionCoordinator.h
â”‚   â”‚   â”‚               â”‚   â”‚   â””â”€â”€ UXViewControllerTransitioning.h
â”‚   â”‚   â”‚               â”‚   â”œâ”€â”€ Modules
â”‚   â”‚   â”‚               â”‚   â”‚   â””â”€â”€ module.modulemap
â”‚   â”‚   â”‚               â”‚   â”œâ”€â”€ Resources
â”‚   â”‚   â”‚               â”‚   â”‚   â””â”€â”€ Info.plist
â”‚   â”‚   â”‚               â”‚   â””â”€â”€ UXKit.tbd
â”‚   â”‚   â”‚               â””â”€â”€ Current
â”‚   â”‚   â”œâ”€â”€ Utils
â”‚   â”‚   â”‚   â”œâ”€â”€ CheckboxButton+.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ EventMonitor.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeConnectionNotificationService.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeEngineManager.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ RuntimeSource+.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SIPChecker.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ Then.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ UIDebugger.h
â”‚   â”‚   â”‚   â””â”€â”€ UIDebugger.m
â”‚   â”‚   â”œâ”€â”€ com.mxiris.runtimeviewer.service.plist
â”‚   â”‚   â””â”€â”€ launchd.plist
â”‚   â”œâ”€â”€ RuntimeViewerUsingAppKit.xcodeproj
â”‚   â”‚   â”œâ”€â”€ project.pbxproj
â”‚   â”‚   â””â”€â”€ xcshareddata
â”‚   â”‚       â””â”€â”€ xcschemes
â”‚   â”‚           â”œâ”€â”€ RuntimeViewer macOS.xcscheme
â”‚   â”‚           â””â”€â”€ RuntimeViewerCatalystHelper.xcscheme
â”‚   â”œâ”€â”€ Shared-Debug.xcconfig
â”‚   â”œâ”€â”€ Shared-Release.xcconfig
â”‚   â”œâ”€â”€ Shared.xcconfig
â”‚   â”œâ”€â”€ com.JH.RuntimeViewerService
â”‚   â”‚   â”œâ”€â”€ Config.xcconfig
â”‚   â”‚   â”œâ”€â”€ Debug.xcconfig
â”‚   â”‚   â”œâ”€â”€ Info.plist
â”‚   â”‚   â”œâ”€â”€ Release.xcconfig
â”‚   â”‚   â”œâ”€â”€ launchd.plist
â”‚   â”‚   â””â”€â”€ main.swift
â”‚   â””â”€â”€ com.mxiris.runtimeviewer.service
â”‚       â””â”€â”€ main.swift
â”œâ”€â”€ RuntimeViewerUsingUIKit
â”‚   â”œâ”€â”€ RuntimeViewerUsingUIKit
â”‚   â”‚   â”œâ”€â”€ App
â”‚   â”‚   â”‚   â”œâ”€â”€ AppDelegate.swift
â”‚   â”‚   â”‚   â””â”€â”€ SceneDelegate.swift
â”‚   â”‚   â”œâ”€â”€ Assets.xcassets
â”‚   â”‚   â”‚   â”œâ”€â”€ AccentColor.colorset
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚   â”‚   â”œâ”€â”€ Base
â”‚   â”‚   â”‚   â”œâ”€â”€ ViewControllers.swift
â”‚   â”‚   â”‚   â””â”€â”€ XiblessView.swift
â”‚   â”‚   â”œâ”€â”€ Content
â”‚   â”‚   â”‚   â”œâ”€â”€ ContentCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ContentNavigationController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ ContentPlaceholderViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ ContentTextViewController.swift
â”‚   â”‚   â”œâ”€â”€ Info.plist
â”‚   â”‚   â”œâ”€â”€ Inspector
â”‚   â”‚   â”‚   â”œâ”€â”€ InspectorCoordinator.swift
â”‚   â”‚   â”‚   â””â”€â”€ InspectorNavigationController.swift
â”‚   â”‚   â”œâ”€â”€ LaunchScreen.storyboard
â”‚   â”‚   â”œâ”€â”€ Main
â”‚   â”‚   â”‚   â”œâ”€â”€ MainCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ MainSplitViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ MainViewModel.swift
â”‚   â”‚   â”œâ”€â”€ RuntimeViewerUsingUIKit.entitlements
â”‚   â”‚   â”œâ”€â”€ Sidebar
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarCoordinator.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarNavigationController.swift
â”‚   â”‚   â”‚   â”œâ”€â”€ SidebarRootViewController.swift
â”‚   â”‚   â”‚   â””â”€â”€ SidebarRuntimeObjectViewController.swift
â”‚   â”‚   â””â”€â”€ Utils
â”‚   â”‚       â”œâ”€â”€ Extensions.swift
â”‚   â”‚       â””â”€â”€ Then.swift
â”‚   â”œâ”€â”€ RuntimeViewerUsingUIKit.xcodeproj
â”‚   â”‚   â”œâ”€â”€ project.pbxproj
â”‚   â”‚   â””â”€â”€ xcshareddata
â”‚   â”‚       â””â”€â”€ xcschemes
â”‚   â”‚           â”œâ”€â”€ RuntimeViewer iOS.xcscheme
â”‚   â”‚           â””â”€â”€ RuntimeViewer visionOS.xcscheme
â”‚   â””â”€â”€ RuntimeViewerUsingVision
â”‚       â”œâ”€â”€ Assets.xcassets
â”‚       â”‚   â”œâ”€â”€ AppIcon.solidimagestack
â”‚       â”‚   â”‚   â”œâ”€â”€ Back.solidimagestacklayer
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Content.imageset
â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Contents.json
â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Rectangle 108.png
â”‚       â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚   â”œâ”€â”€ Contents.json
â”‚       â”‚   â”‚   â”œâ”€â”€ Front.solidimagestacklayer
â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Content.imageset
â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Contents.json
â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ Frame 122.png
â”‚       â”‚   â”‚   â”‚   â””â”€â”€ Contents.json
â”‚       â”‚   â”‚   â””â”€â”€ Middle.solidimagestacklayer
â”‚       â”‚   â”‚       â”œâ”€â”€ Content.imageset
â”‚       â”‚   â”‚       â”‚   â”œâ”€â”€ Contents.json
â”‚       â”‚   â”‚       â”‚   â””â”€â”€ Frame 124.png
â”‚       â”‚   â”‚       â””â”€â”€ Contents.json
â”‚       â”‚   â””â”€â”€ Contents.json
â”‚       â””â”€â”€ Info.plist
â””â”€â”€ docs
    â””â”€â”€ plans
        â”œâ”€â”€ 2026-02-16-interface-export-design.md
        â”œâ”€â”€ 2026-02-17-export-wizard-enhancement-design.md
        â””â”€â”€ 2026-02-17-export-wizard-enhancement-plan.md

```

`AGENTS.md`:

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Runtime Viewer is a macOS/iOS application for inspecting Objective-C and Swift runtime interfaces. It serves as a modern alternative to RuntimeBrowser with features like Swift interface support, type-defined jumps, Xcode-style syntax highlighting, and code injection capabilities.

## Build Commands

```bash
# Debug build (x86_64 and arm64e)
./BuildScript.sh

# Or directly via xcodebuild
xcodebuild build -scheme RuntimeViewerUsingAppKit -configuration Debug -destination 'generic/platform=macOS'

# Release archive (builds Catalyst helper first, then main app)
./ArchiveScript.sh
```

## Architecture

### Package Structure

The project uses two Swift Package Manager packages:

**Core Package** (`Core/`):
- `RuntimeViewerCore` - Runtime inspection engine using ClassDumpRuntime (ObjC) and MachOSwiftSection (Swift)
- `RuntimeViewerCommunication` - XPC-based IPC layer for cross-process inspection
- `RuntimeViewerObjC` - Objective-C interop utilities

**RuntimeViewerPackages** (`RuntimeViewerPackages/`):
- `RuntimeViewerArchitectures` - MVVM + Coordinator pattern with RxSwift
- `RuntimeViewerApplication` - ViewModels and business logic (Sidebar, Inspector, Content, Theme, FilterEngine)
- `RuntimeViewerUI` - AppKit UI components (MinimapView, StatefulOutlineView, skeleton effects)
- `RuntimeViewerService` - XPC service helpers and code injection

### Application Targets

- `RuntimeViewerUsingAppKit` - Main macOS application (AppKit)
- `RuntimeViewerServer` - XPC background service for inter-process communication
- `RuntimeViewerCatalystHelper` - Mac Catalyst support bridge
- `RuntimeViewerUsingUIKit` - iOS variant (secondary)

### Key Architectural Patterns

- **MVVM-C (MVVM + Coordinator)**: Navigation via CocoaCoordinator (macOS) / XCoordinator (iOS)
- **Reactive Streams**: Heavy RxSwift usage for UI state and data flow
- **Dependency Injection**: Uses swift-dependencies for service injection
- **Multi-Process**: XPC services enable safe inspection of external processes

### UI Technology Stack

- **AppKit**: All UI components except Settings
- **SwiftUI**: Settings module only

## Development Guidelines

When adding new features, you **MUST** follow these rules:

1. **UI Framework**: Use AppKit for all new UI components (except Settings-related features which use SwiftUI)
2. **Architecture**: Follow MVVM-C pattern
   - **Model**: Data structures and business logic
   - **View**: AppKit views (NSView, NSViewController)
   - **ViewModel**: RxSwift-based, handles UI state and logic
   - **Coordinator**: Manages navigation and flow
3. **Reactive**: Use RxSwift for data binding and event handling
4. **No SwiftUI** in non-Settings areas - keep the codebase consistent

### Platform Requirements

- Swift 6.2, Xcode 15+
- Core: macOS 10.15+, iOS 13+
- Main App: macOS 14+, iOS 17+

## Key Source Locations

- Main app entry: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/App/AppDelegate.swift`
- Coordinator/navigation: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainCoordinator.swift`
- Runtime engine: `Core/Sources/RuntimeViewerCore/RuntimeEngine.swift`
- ViewModels: `RuntimeViewerPackages/Sources/RuntimeViewerApplication/`

## MCP Tool Preferences

When MCP servers are available, **MUST** prefer them over shell commands and built-in tools:

### Xcode MCP (Project Operations)
Prefer Xcode MCP tools for all Xcode project-level operations:
- **File reading**: Use `XcodeRead` instead of `Read` / `cat` for files in the Xcode project
- **File writing**: Use `XcodeWrite` instead of `Write` for creating/overwriting files in the project
- **File editing**: Use `XcodeUpdate` instead of `Edit` / `sed` for modifying files in the project
- **File searching**: Use `XcodeGrep` instead of `Grep` / `grep` for searching in project files
- **File discovery**: Use `XcodeGlob` / `XcodeLS` instead of `Glob` / `ls` for browsing project structure
- **File management**: Use `XcodeMakeDir`, `XcodeMV`, `XcodeRM` for directory/file operations
- **Build**: Use `BuildProject` for building the project through Xcode
- **Tests**: Use `GetTestList`, `RunSomeTests`, `RunAllTests` for test operations
- **Diagnostics**: Use `XcodeRefreshCodeIssuesInFile`, `XcodeListNavigatorIssues` for checking issues
- **Preview**: Use `RenderPreview` for SwiftUI preview rendering
- **Snippets**: Use `ExecuteSnippet` for running code snippets in project context
- **Documentation**: Use `DocumentationSearch` for searching Apple Developer Documentation

### Priority Order
1. **Xcode MCP** â€” for project file operations, in-editor builds, diagnostics, and previews
2. **RepoPrompt** â€” for cross-repo context building, code structure analysis, and git operations
3. **Built-in tools** â€” fallback when MCP tools are unavailable or not applicable

## External Dependencies

Core reverse engineering powered by:
- [ClassDumpRuntime](https://github.com/MxIris-Reverse-Engineering/ClassDumpRuntime) - ObjC runtime introspection
- [MachOSwiftSection](https://github.com/MxIris-Reverse-Engineering/MachOSwiftSection) - Swift interface extraction
- [MachInjector](https://github.com/MxIris-Reverse-Engineering/MachInjector) - Code injection (requires SIP disabled)

```

`ArchiveExportConfig-Catalyst.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>method</key>
	<string>debugging</string>
	<key>signingStyle</key>
	<string>automatic</string>
</dict>
</plist>

```

`ArchiveExportConfig.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>method</key>
	<string>developer-id</string>
	<key>signingStyle</key>
	<string>automatic</string>
</dict>
</plist>

```

`ArchiveScript.sh`:

```sh
#!/bin/bash

set -e
set -o pipefail


project_path=$(cd `dirname $0`; pwd)
project_name="RuntimeViewer"
scheme_name="RuntimeViewer macOS"
development_mode="Release"
cpu_cores=$(sysctl -n hw.ncpu 2>/dev/null || echo 8)


build_path=${project_path}/Products/Archives
final_export_path=${build_path}/Products/Export
export_options_plist_path=${project_path}/ArchiveExportConfig.plist

catalyst_export_options_plist_path=${project_path}/ArchiveExportConfig-Catalyst.plist
catalyst_helper_export_path=${project_path}/RuntimeViewerUsingAppKit
catalyst_helper_app_path=${catalyst_helper_export_path}/RuntimeViewerCatalystHelper.app
catalyst_helper_archive_path=${build_path}/RuntimeViewerCatalystHelper.xcarchive

notary_profile_name="notarytool-password"

# Set build number to current date and time (format: YYYYMMDD.HH.MM)
build_number=$(date +"%Y%m%d.%H.%M")

echo '///-----------'
echo '/// Build Number: '${build_number}
echo '/// Parallel compile tasks: '${cpu_cores}
echo '///-----------'
echo ''

echo '///-----------'
echo '/// Archiving RuntimeViewerCatalystHelper: '${development_mode}
echo '///-----------'

xcodebuild \
archive \
-workspace ${project_path}/${project_name}.xcworkspace \
-scheme 'RuntimeViewerCatalystHelper' \
-configuration ${development_mode} \
-destination 'generic/platform=macOS,variant=Mac Catalyst' \
-archivePath ${catalyst_helper_archive_path} \
-jobs ${cpu_cores} \
CURRENT_PROJECT_VERSION=${build_number} | xcbeautify || exit

if [ -d "${catalyst_helper_app_path}" ]; then
    rm -rf "${catalyst_helper_app_path}"
fi

xcodebuild \
-exportArchive -archivePath ${catalyst_helper_archive_path} \
-configuration ${development_mode} \
-exportPath ${catalyst_helper_export_path} \
-exportOptionsPlist ${catalyst_export_options_plist_path} \
-quiet || exit

rm -f "${catalyst_helper_export_path}/Packaging.log"
rm -f "${catalyst_helper_export_path}/DistributionSummary.plist"
rm -f "${catalyst_helper_export_path}/ExportOptions.plist"

echo '///------------'
echo '/// RuntimeViewerCatalystHelper Archive Complete  '
echo '///-----------='
echo ''

echo '///-----------'
echo '/// Archiving '${scheme_name}': '${development_mode}
echo '///-----------'

xcodebuild \
archive \
-workspace ${project_path}/${project_name}.xcworkspace \
-scheme "${scheme_name}" \
-configuration ${development_mode} \
-destination 'generic/platform=macOS' \
-archivePath ${build_path}/${project_name}.xcarchive \
-jobs ${cpu_cores} \
CURRENT_PROJECT_VERSION=${build_number} | xcbeautify || exit

echo '///------------'
echo '/// '${scheme_name}' Archive Complete'
echo '///-----------='
echo ''

echo '///-----------'
echo '/// Exporting '${scheme_name}
echo '///-----------'

if [ -d "${final_export_path}" ]; then
    rm -rf "${final_export_path}"
fi

xcodebuild \
-exportArchive \
-archivePath "${build_path}/${project_name}.xcarchive" \
-configuration ${development_mode} \
-exportPath "${final_export_path}" \
-exportOptionsPlist "${export_options_plist_path}" \
-quiet || exit

app_path="${final_export_path}/${project_name}.app"
zip_path="${final_export_path}/${project_name}.zip"

if [ ! -d "$app_path" ]; then
    echo "Error: App not found at $app_path"
    exit 1
fi

echo '///------------'
echo '/// Export Complete: '${app_path}
echo '///-----------='
echo ''

if [ -z "$notary_profile_name" ]; then
    echo "Warning: notary_profile_name is empty. Skipping notarization."
    open "${final_export_path}"
    exit 0
fi

echo '///-----------'
echo '/// Notarizing...'
echo '///-----------'

echo "Zipping app for notarization..."
/usr/bin/ditto -c -k --keepParent "$app_path" "$zip_path"

echo "Submitting to Apple Notary Service (This may take a few minutes)..."

xcrun notarytool submit "$zip_path" \
--keychain-profile "$notary_profile_name" \
--wait || exit

echo '///------------'
echo '/// Notarization Accepted. Stapling Ticket...'
echo '///-----------='

xcrun stapler staple "$app_path"

echo "Stapling Complete."

spctl --assess --verbose "$app_path"

echo '///------------'
echo '/// All Done! Opening Output Folder.'
echo '///-----------='

open "${final_export_path}"

exit 0
```

`BuildRuntimeViewerServerXCFramework.sh`:

```sh
#!/bin/bash

# ==========================================
# Build RuntimeViewerServer XCFramework
# Supports all Apple platforms:
#   - macOS (using RuntimeViewerServer)
#   - Mac Catalyst (using RuntimeViewerMobileServer)
#   - iOS (Device + Simulator) (using RuntimeViewerMobileServer)
#   - tvOS (Device + Simulator) (using RuntimeViewerMobileServer)
#   - watchOS (Device + Simulator) (using RuntimeViewerMobileServer)
#   - visionOS (Device + Simulator) (using RuntimeViewerMobileServer)
# ==========================================

set -e

# ==========================================
# Configuration
# ==========================================
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
WORKSPACE_NAME="RuntimeViewer"
WORKSPACE_PATH="${SCRIPT_DIR}/${WORKSPACE_NAME}.xcworkspace"
SCHEME_MACOS="RuntimeViewerServer"
SCHEME_MOBILE="RuntimeViewerMobileServer"
FRAMEWORK_NAME="RuntimeViewerServer"
OUTPUT_DIR="${SCRIPT_DIR}/Products"
ARCHIVE_PATH="${OUTPUT_DIR}/Archives"
XCFRAMEWORK_NAME="${FRAMEWORK_NAME}.xcframework"
CONFIGURATION="Distribution"

# Parse arguments
VERBOSE=false
CLEAN_BUILD=true
USER_PLATFORMS=()
CPU_CORES=$(sysctl -n hw.ncpu 2>/dev/null || echo 8)

usage() {
    echo "Usage: $0 [options] [Platforms...]"
    echo ""
    echo "Options:"
    echo "  -v, --verbose      Show detailed build output"
    echo "  --no-clean         Skip cleaning before build"
    echo "  -h, --help         Show this help message"
    echo ""
    echo "Platforms (if none specified, builds all):"
    echo "  macOS, macCatalyst, iOS, tvOS, watchOS, visionOS"
    echo ""
    echo "Schemes:"
    echo "  macOS uses:  $SCHEME_MACOS"
    echo "  Others use:  $SCHEME_MOBILE (macCatalyst, iOS, tvOS, watchOS, visionOS)"
    echo ""
    echo "Examples:"
    echo "  $0                     # Build all platforms"
    echo "  $0 iOS macOS           # Build only iOS and macOS"
    echo "  $0 -v iOS              # Build iOS with verbose output"
    exit 0
}

while [[ $# -gt 0 ]]; do
    case "$1" in
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --no-clean)
            CLEAN_BUILD=false
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            USER_PLATFORMS+=("$1")
            shift
            ;;
    esac
done

# ==========================================
# Platform Configurations
# Format: "PlatformName|Scheme|DeviceDestination|SimulatorDestination"
# ==========================================
PLATFORM_CONFIGS=(
    "macOS|${SCHEME_MACOS}|generic/platform=macOS|"
    # "macCatalyst|${SCHEME_MOBILE}|generic/platform=macOS,variant=Mac Catalyst|"
    "iOS|${SCHEME_MOBILE}|generic/platform=iOS|generic/platform=iOS Simulator"
    "tvOS|${SCHEME_MOBILE}|generic/platform=tvOS|generic/platform=tvOS Simulator"
    "watchOS|${SCHEME_MOBILE}|generic/platform=watchOS|generic/platform=watchOS Simulator"
    "visionOS|${SCHEME_MOBILE}|generic/platform=visionOS|generic/platform=visionOS Simulator"
)

# Determine Target Platforms
TARGET_PLATFORMS=()

if [ ${#USER_PLATFORMS[@]} -eq 0 ]; then
    echo "ğŸŒ No platforms specified. Building for ALL supported platforms..."
    for config in "${PLATFORM_CONFIGS[@]}"; do
        TARGET_PLATFORMS+=("${config%%|*}")
    done
else
    for arg in "${USER_PLATFORMS[@]}"; do
        found=false
        for config in "${PLATFORM_CONFIGS[@]}"; do
            p_name="${config%%|*}"
            if echo "$p_name" | grep -iq "^$arg$"; then
                TARGET_PLATFORMS+=("$p_name")
                found=true
                break
            fi
        done
        if [ "$found" = false ]; then
            echo "âš ï¸  Warning: Unknown platform '$arg', skipping."
        fi
    done
fi

if [ ${#TARGET_PLATFORMS[@]} -eq 0 ]; then
    echo "âŒ Error: No valid platforms to build."
    exit 1
fi

# ==========================================
# Print Build Configuration
# ==========================================
echo "============================================"
echo "ğŸš€ Building RuntimeViewerServer XCFramework"
echo "============================================"
echo "ğŸ“‚ Project: $WORKSPACE_PATH"
echo "ğŸ“‹ Schemes:"
echo "   - macOS:  $SCHEME_MACOS"
echo "   - Mobile: $SCHEME_MOBILE (macCatalyst, iOS, tvOS, watchOS, visionOS)"
echo "âš™ï¸  Configuration: $CONFIGURATION"
echo "ğŸ“¦ Build for Distribution: $BUILD_FOR_DISTRIBUTION"
echo "ğŸ”§ Parallel compile tasks: $CPU_CORES"
echo "ğŸ¯ Target Platforms: ${TARGET_PLATFORMS[*]}"
echo "============================================"
echo ""

# ==========================================
# Clean up old builds
# ==========================================
if [ "$CLEAN_BUILD" = true ]; then
    echo "ğŸ§¹ Cleaning previous build artifacts..."
    rm -rf "$OUTPUT_DIR"
fi
mkdir -p "$ARCHIVE_PATH"
mkdir -p "$OUTPUT_DIR/DerivedData"

# ==========================================
# Function: Build Archive
# ==========================================
build_archive() {
    local scheme=$1
    local destination=$2
    local archive_name=$3
    shift 3
    local extra_build_settings=("$@")
    local derived_data_path="$OUTPUT_DIR/DerivedData"

    echo "ğŸ›   [$(date +%T)] Building: $archive_name (scheme: $scheme) ..."

    local redirect="/dev/null"
    if [ "$VERBOSE" = true ]; then
        redirect="/dev/stdout"
    fi

    local job_args=("-jobs" "$CPU_CORES")

    if ! xcodebuild archive \
        -workspace "$WORKSPACE_PATH" \
        -scheme "$scheme" \
        -destination "$destination" \
        -archivePath "$ARCHIVE_PATH/$archive_name.xcarchive" \
        -derivedDataPath "$derived_data_path" \
        -configuration "$CONFIGURATION" \
        "${job_args[@]}" \
        "${extra_build_settings[@]}" \
        > "$redirect" 2>&1; then
        echo "âŒ Build Failed: $archive_name"
        echo "   Run with -v flag to see detailed error log"
        exit 1
    fi

    # Verify framework exists
    local framework_path="$ARCHIVE_PATH/$archive_name.xcarchive/Products/Library/Frameworks/${FRAMEWORK_NAME}.framework"
    if [ ! -d "$framework_path" ]; then
        echo "âŒ Error: Framework not found at expected path:"
        echo "   $framework_path"
        exit 1
    fi

    echo "âœ… Build Success: $archive_name"
}


# ==========================================
# Main Loop: Generate Archives (Sequential)
# ==========================================
echo "ğŸ“¦ Starting archive builds..."
echo ""

FRAMEWORK_PATHS=()
DSYM_PATHS=()

for platform in "${TARGET_PLATFORMS[@]}"; do
    for config in "${PLATFORM_CONFIGS[@]}"; do
        if [[ "$config" == "$platform|"* ]]; then
            IFS='|' read -r p_name p_scheme dest_device dest_sim <<< "$config"

            # Build Device Slice
            if [ -n "$dest_device" ]; then
                build_archive "$p_scheme" "$dest_device" "${p_name}_Device"
                FRAMEWORK_PATHS+=("$ARCHIVE_PATH/${p_name}_Device.xcarchive/Products/Library/Frameworks/${FRAMEWORK_NAME}.framework")
                DSYM_PATHS+=("$ARCHIVE_PATH/${p_name}_Device.xcarchive/dSYMs/${FRAMEWORK_NAME}.framework.dSYM")
            fi

            # Build Simulator Slice (if applicable)
            if [ -n "$dest_sim" ]; then
                build_archive "$p_scheme" "$dest_sim" "${p_name}_Simulator"
                FRAMEWORK_PATHS+=("$ARCHIVE_PATH/${p_name}_Simulator.xcarchive/Products/Library/Frameworks/${FRAMEWORK_NAME}.framework")
                DSYM_PATHS+=("$ARCHIVE_PATH/${p_name}_Simulator.xcarchive/dSYMs/${FRAMEWORK_NAME}.framework.dSYM")
            fi
        fi
    done
done

FRAMEWORK_ARGS=()
for i in "${!FRAMEWORK_PATHS[@]}"; do
    FRAMEWORK_ARGS+=("-framework" "${FRAMEWORK_PATHS[$i]}")
    if [ -d "${DSYM_PATHS[$i]}" ]; then
        FRAMEWORK_ARGS+=("-debug-symbols" "${DSYM_PATHS[$i]}")
    fi
done

# ==========================================
# Create XCFramework
# ==========================================
echo ""
echo "ğŸ“¦ Creating XCFramework..."

# Remove existing xcframework if present
rm -rf "$OUTPUT_DIR/$XCFRAMEWORK_NAME"

if ! xcodebuild -create-xcframework \
    "${FRAMEWORK_ARGS[@]}" \
    -output "$OUTPUT_DIR/$XCFRAMEWORK_NAME"; then
    echo "âŒ Failed to create XCFramework."
    exit 1
fi

if [ -d "$OUTPUT_DIR/$XCFRAMEWORK_NAME" ]; then
    echo ""
    echo "============================================"
    echo "ğŸ‰ Success! XCFramework created at:"
    echo "   $OUTPUT_DIR/$XCFRAMEWORK_NAME"
    echo "============================================"
    echo ""

    # Print framework info
    echo "ğŸ“‹ XCFramework Contents:"
    ls -la "$OUTPUT_DIR/$XCFRAMEWORK_NAME/"
    echo ""

    # Print supported platforms from Info.plist
    echo "ğŸ¯ Supported Platforms:"
    plutil -p "$OUTPUT_DIR/$XCFRAMEWORK_NAME/Info.plist" | grep -E "LibraryIdentifier|SupportedPlatform|SupportedArchitectures" | head -30
    echo ""

    # Open output directory
    open "$OUTPUT_DIR"
else
    echo "âŒ Failed to create XCFramework."
    exit 1
fi

```

`CLAUDE.md`:

```md
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Runtime Viewer is a macOS/iOS document-based (NSDocument) application for inspecting Objective-C and Swift runtime interfaces. It serves as a modern alternative to RuntimeBrowser with features like Swift interface support, type-defined jumps, Xcode-style syntax highlighting, code injection capabilities, and MCP (Model Context Protocol) integration for LLM clients.

## Build Commands

```bash
# Debug build (x86_64 and arm64e)
./BuildScript.sh

# Or directly via xcodebuild (debug scheme)
xcodebuild build -scheme RuntimeViewerUsingAppKit -configuration Debug -destination 'generic/platform=macOS'

# Release archive (builds Catalyst helper first, then main app, with notarization)
# Uses scheme "RuntimeViewer macOS"
./ArchiveScript.sh

# Build RuntimeViewerServer XCFramework (all platforms)
./BuildRuntimeViewerServerXCFramework.sh
```

**Build Schemes**:
- `RuntimeViewerUsingAppKit` â€” Debug builds
- `RuntimeViewer macOS` â€” Release archives

## Architecture

### Package Structure

The project uses three Swift Package Manager packages:

**RuntimeViewerCore** (`RuntimeViewerCore/`):
- `RuntimeViewerCore` â€” Runtime inspection engine using MachOObjCSection (ObjC) and MachOSwiftSection (Swift)
- `RuntimeViewerCommunication` â€” XPC/TCP-based IPC layer for cross-process inspection
- `RuntimeViewerCoreObjC` â€” Objective-C interop utilities (internal target)

**RuntimeViewerPackages** (`RuntimeViewerPackages/`):
- `RuntimeViewerArchitectures` â€” MVVM + Coordinator pattern with RxSwift
- `RuntimeViewerApplication` â€” ViewModels and business logic (Sidebar, Inspector, Content, Theme, FilterEngine)
- `RuntimeViewerUI` â€” AppKit UI components (MinimapView, StatefulOutlineView, skeleton effects)
- `RuntimeViewerService` â€” XPC service helpers and code injection
- `RuntimeViewerServiceHelper` â€” Helper utilities
- `RuntimeViewerHelperClient` â€” Helper client for XPC communication
- `RuntimeViewerSettings` â€” Settings models and dependency values
- `RuntimeViewerSettingsUI` â€” Settings UI (SwiftUI)
- `RuntimeViewerCatalystExtensions` â€” Mac Catalyst support

**RuntimeViewerMCP** (`RuntimeViewerMCP/`) â€” MCP integration (macOS 15+ only):
- `RuntimeViewerMCPShared` â€” Shared protocols and transport types
- `RuntimeViewerMCPBridge` â€” Bridge server that runs inside the main app

### Application Targets

- `RuntimeViewerUsingAppKit` â€” Main macOS application (AppKit, document-based)
- `RuntimeViewerMCPServer` â€” MCP server executable (stdio-based, communicates with bridge via TCP)
- `RuntimeViewerServer` â€” XPC background service for inter-process communication
- `RuntimeViewerCatalystHelper` â€” Mac Catalyst support bridge
- `RuntimeViewerUsingUIKit` â€” iOS variant (secondary)

### Key Architectural Patterns

- **Document-Based App**: NSDocument architecture; each document creates its own `DocumentState` instance
- **MVVM-C (MVVM + Coordinator)**: Navigation via CocoaCoordinator (macOS) / XCoordinator (iOS)
- **Reactive Streams**: Heavy RxSwift usage for UI state and data flow
- **Dependency Injection**: Uses swift-dependencies for service injection
- **Multi-Process**: XPC services enable safe inspection of external processes
- **MCP Bridge**: TCP bridge pattern â€” app hosts bridge server, external MCP server connects as client

### MCP Integration

The MCP feature enables LLM clients (e.g., Claude) to inspect runtime information via the Model Context Protocol.

**Architecture**:
```
RuntimeViewerApp (NSDocument)
    â†“ provides DocumentState
AppMCPBridgeWindowProvider
    â†“ bridge (TCP, length-prefixed JSON)
RuntimeViewerMCPBridge (library, in-process)
    â†“ TCP server
RuntimeViewerMCPServer (executable, stdio MCP)
    â†“ MCP protocol
LLM Client
```

- Bridge uses simple length-prefixed JSON over TCP (not RuntimeViewerCommunication framework)
- Port file: `~/Library/Application Support/RuntimeViewer/mcp-bridge-port`
- Bridge starts automatically in `AppDelegate.applicationDidFinishLaunching`
- MCP server entry: `RuntimeViewerUsingAppKit/RuntimeViewerMCPServer/main.swift`

### UI Technology Stack

- **AppKit**: All UI components except Settings
- **SwiftUI**: Settings module only

## Development Guidelines

When adding new features, you **MUST** follow these rules:

1. **UI Framework**: Use AppKit for all new UI components (except Settings-related features which use SwiftUI)
2. **Architecture**: Follow MVVM-C pattern
   - **Model**: Data structures and business logic
   - **View**: AppKit views (NSView, NSViewController)
   - **ViewModel**: RxSwift-based, handles UI state and logic
   - **Coordinator**: Manages navigation and flow
3. **Reactive**: Use RxSwift for data binding and event handling
4. **No SwiftUI** in non-Settings areas â€” keep the codebase consistent
5. **Swift Language Mode**: All packages use `swiftLanguageModes: [.v5]`

## Code Style

### ViewModel Conventions

**Base class**: All ViewModels inherit `ViewModel<Route>`, which provides `documentState`, `router`, `appDefaults`, `errorRelay`, `_commonLoading`.

**State properties** â€” use `@Observed` (NOT `BehaviorRelay`):
```swift
@Observed private(set) var currentPage: Page = .configuration
@Observed private(set) var nodes: [CellViewModel] = []
```
- Exposed as Driver/Signal via `$property.asDriver()` or `$property.asSignal()`
- Mutate by direct assignment: `currentPage = .progress`

**Input/Output transform pattern**:
```swift
@MemberwiseInit(.public)
struct Input {
    let cancelClick: Signal<Void>
    let searchString: Signal<String>
}

struct Output {
    let nodes: Driver<[CellViewModel]>        // State â†’ Driver
    let requestSelection: Signal<Void>         // One-shot events â†’ Signal
}

func transform(_ input: Input) -> Output {
    input.cancelClick.emitOnNext { [weak self] in
        guard let self else { return }
        router.trigger(.dismiss)
    }
    .disposed(by: rx.disposeBag)

    return Output(
        nodes: $nodes.asDriver(),
        requestSelection: requestSelectionRelay.asSignal()
    )
}
```

**One-shot events from ViewModel** â€” use `PublishRelay`:
```swift
private let requestDirectorySelectionRelay = PublishRelay<Void>()
```

**Dependency injection**: `@Dependency(\.appDefaults) var appDefaults`

### ViewController Conventions

**Base classes**: `AppKitViewController<VM>` (simple) or `UXKitViewController<VM>` (with contentView support).

**UI events** â€” use `PublishRelay` at the top, fire from `@objc` actions:
```swift
private let cancelRelay = PublishRelay<Void>()
private let exportRelay = PublishRelay<Void>()

@objc private func cancelClicked() {
    cancelRelay.accept(())
}
```

**setupBindings pattern**:
```swift
override func setupBindings(for viewModel: MyViewModel) {
    super.setupBindings(for: viewModel)
    let input = MyViewModel.Input(cancelClick: cancelRelay.asSignal(), ...)
    let output = viewModel.transform(input)

    output.nodes.drive(outlineView.rx.nodes) { ... }.disposed(by: rx.disposeBag)

    output.currentPage.driveOnNext { [weak self] page in
        guard let self else { return }
        showPage(page)
    }
    .disposed(by: rx.disposeBag)
}
```

### UI Components

**Always use project wrapper types** (from RuntimeViewerUI / UIFoundation), NOT raw AppKit classes:

| Use | Instead of |
|-----|-----------|
| `Label()` / `Label("text")` | `NSTextField(labelWithString:)` |
| `PushButton()` | `NSButton()` |
| `ImageView()` | `NSImageView()` |
| `VStackView(alignment:spacing:) { ... }` | `NSStackView(orientation: .vertical)` |
| `HStackView(spacing:) { ... }` | `NSStackView(orientation: .horizontal)` |
| `ScrollView()` | `NSScrollView()` |

**View initialization** â€” `.then {}` returns the configured object (for assignment):
```swift
let titleLabel = Label("Export").then {
    $0.font = .systemFont(ofSize: 18, weight: .semibold)
}
```

**View configuration** â€” `.do {}` mutates in place (for already-declared properties):
```swift
configRadioButton.do {
    $0.setButtonType(.radio)
    $0.title = "Single File"
    $0.state = .on
}
```

**Adding subviews** â€” use `hierarchy {}` result builder (NOT `addSubview`):
```swift
container.hierarchy {
    contentStack
    buttonStack
}
```

**Stack views** â€” use result builder initializer:
```swift
let contentStack = VStackView(alignment: .leading, spacing: 16) {
    headerStack
    imageNameStack
    formatStack
}

let buttonStack = HStackView(spacing: 8) {
    cancelButton
    exportButton
}
```

### Layout

**All layout uses SnapKit** â€” constraints grouped together after `hierarchy {}`:
```swift
container.hierarchy {
    contentStack
    buttonStack
}

contentStack.snp.makeConstraints { make in
    make.top.leading.trailing.equalToSuperview().inset(20)
}

buttonStack.snp.makeConstraints { make in
    make.trailing.bottom.equalToSuperview().inset(20)
}
```

### RxSwift Subscription Style

**Always use trailing-closure variants** (NOT `.emit(onNext:)` / `.drive(onNext:)` / `.subscribe(onNext:)` label syntax):

| Use (trailing closure) | Instead of (label syntax) |
|------------------------|--------------------------|
| `.emitOnNext { }` | `.emit(onNext: { })` |
| `.emitOnNextMainActor { }` | â€” |
| `.driveOnNext { }` | `.drive(onNext: { })` |
| `.driveOnNextMainActor { }` | â€” |
| `.subscribeOnNext { }` | `.subscribe(onNext: { })` |
| `.subscribeOnNextMainActor { }` | â€” |

```swift
// Signal
input.cancelClick.emitOnNext { [weak self] in
    guard let self else { return }
    router.trigger(.dismiss)
}
.disposed(by: rx.disposeBag)

// Driver
output.currentPage.driveOnNext { [weak self] page in
    guard let self else { return }
    showPage(page)
}
.disposed(by: rx.disposeBag)

// Observable
source.subscribeOnNext { [weak self] value in
    guard let self else { return }
    handleValue(value)
}
.disposed(by: rx.disposeBag)
```

For direct binding without closure logic, `.drive()` / `.bind(to:)` are fine:
```swift
output.imageName.drive(label.rx.stringValue).disposed(by: rx.disposeBag)
```

### Closures & Self Capture

**Always** use `guard let self else { return }` (NOT `strongSelf`, NOT `if let self`):
```swift
output.result.driveOnNext { [weak self] value in
    guard let self else { return }
    handleResult(value)
}
.disposed(by: rx.disposeBag)
```

### Coordinator Conventions

**Route enums** â€” use `@AssociatedValue` and `@CaseCheckable` macros:
```swift
@AssociatedValue(.public)
@CaseCheckable(.public)
public enum MyRoute: Routable {
    case root
    case detail(RuntimeObject)
    case dismiss
}
```

**ViewController creation** â€” always in Coordinator's `prepareTransition`, not in ViewController:
```swift
override func prepareTransition(for route: MainRoute) -> MainTransition {
    case .exportInterfaces:
        let viewController = ExportingViewController()
        let viewModel = ExportingViewModel(documentState: documentState, router: self)
        viewController.setupBindings(for: viewModel)
        return .presentOnRoot(viewController, mode: .asSheet)
}
```

**Delegate pattern** â€” nested protocol inside Coordinator, implemented by parent Coordinator:
```swift
// In child
protocol Delegate: AnyObject {
    func sidebarCoordinator(_ coordinator: SidebarCoordinator, completeTransition route: SidebarRoute)
}
weak var delegate: Delegate?

// In parent
extension MainCoordinator: SidebarCoordinator.Delegate {
    func sidebarCoordinator(_ coordinator: SidebarCoordinator, completeTransition route: SidebarRoute) {
        switch route { ... }
    }
}
```

### MARK Groups

Organize ViewController code with `// MARK: -` sections:
```
// MARK: - Relays
// MARK: - Configuration Page  (or other UI sections)
// MARK: - Lifecycle
// MARK: - Actions
// MARK: - Page Management
// MARK: - Bindings
```

### Error Handling

Use base class `errorRelay` â€” ViewController base class auto-presents alerts:
```swift
// In ViewModel
errorRelay.accept(error)

// In async context
do { ... } catch {
    await MainActor.run { self.errorRelay.accept(error) }
}
```

### Platform Requirements

- Swift 6.2, Xcode 15+
- RuntimeViewerCore: macOS 10.15+, iOS 13+, macCatalyst 13+, watchOS 6+, tvOS 13+, visionOS 1+
- RuntimeViewerPackages: macOS 15+, iOS 18+, macCatalyst 18+, tvOS 18+, visionOS 2+
- RuntimeViewerMCP: macOS 15+

## Key Source Locations

- Main app entry: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/App/AppDelegate.swift`
- Document model: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/App/Document.swift`
- Coordinator/navigation: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainCoordinator.swift`
- Runtime engine: `RuntimeViewerCore/Sources/RuntimeViewerCore/RuntimeEngine.swift`
- Document state: `RuntimeViewerPackages/Sources/RuntimeViewerApplication/DocumentState.swift`
- ViewModels: `RuntimeViewerPackages/Sources/RuntimeViewerApplication/`
- MCP bridge window provider: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/App/AppMCPBridgeWindowProvider.swift`
- MCP server: `RuntimeViewerUsingAppKit/RuntimeViewerMCPServer/`
- MCP bridge: `RuntimeViewerMCP/Sources/RuntimeViewerMCPBridge/`

## MCP Tool Preferences

When MCP servers are available, **MUST** prefer them over shell commands and built-in tools:

### Xcode MCP (Project Operations)
Prefer Xcode MCP tools for all Xcode project-level operations:
- **File reading**: Use `XcodeRead` instead of `Read` / `cat` for files in the Xcode project
- **File writing**: Use `XcodeWrite` instead of `Write` for creating/overwriting files in the project
- **File editing**: Use `XcodeUpdate` instead of `Edit` / `sed` for modifying files in the project
- **File searching**: Use `XcodeGrep` instead of `Grep` / `grep` for searching in project files
- **File discovery**: Use `XcodeGlob` / `XcodeLS` instead of `Glob` / `ls` for browsing project structure
- **File management**: Use `XcodeMakeDir`, `XcodeMV`, `XcodeRM` for directory/file operations
- **Build**: Use `BuildProject` for building the project through Xcode
- **Tests**: Use `GetTestList`, `RunSomeTests`, `RunAllTests` for test operations
- **Diagnostics**: Use `XcodeRefreshCodeIssuesInFile`, `XcodeListNavigatorIssues` for checking issues
- **Preview**: Use `RenderPreview` for SwiftUI preview rendering
- **Snippets**: Use `ExecuteSnippet` for running code snippets in project context
- **Documentation**: Use `DocumentationSearch` for searching Apple Developer Documentation

### Priority Order
1. **Xcode MCP** â€” for project file operations, in-editor builds, diagnostics, and previews
2. **Built-in tools** â€” fallback when MCP tools are unavailable or not applicable

## External Dependencies

Core reverse engineering powered by:
- [MachOKit](https://github.com/MxIris-Reverse-Engineering/MachOKit) â€” Mach-O binary parsing
- [MachOObjCSection](https://github.com/MxIris-Reverse-Engineering/MachOObjCSection) â€” ObjC runtime introspection
- [MachOSwiftSection](https://github.com/MxIris-Reverse-Engineering/MachOSwiftSection) â€” Swift interface extraction
- [MachInjector](https://github.com/MxIris-Reverse-Engineering/MachInjector) â€” Code injection (requires SIP disabled)

Key libraries:
- [RxSwift](https://github.com/ReactiveX/RxSwift) ecosystem (RxSwift, RxCocoa, RxCombine, RxSwiftPlus, RxAppKit)
- [CocoaCoordinator](https://github.com/Mx-Iris/CocoaCoordinator) (macOS) / [XCoordinator](https://github.com/MxIris-Library-Forks/XCoordinator) (iOS)
- [swift-dependencies](https://github.com/pointfreeco/swift-dependencies) â€” Dependency injection
- [swift-navigation](https://github.com/MxIris-Library-Forks/swift-navigation) â€” Navigation and observation

```

`Changelogs/v2.0.0.md`:

```md
# v2.0.0

This is a major release with significant new features, architectural improvements, and platform updates since v1.3.0. The Objective-C runtime inspection engine has been completely replaced, Swift interface support has been added, and a new MCP integration enables LLM clients to inspect runtime information.

---

## Highlights

- **Swift Interface Support** â€” View Swift type interfaces alongside Objective-C, powered by MachOSwiftSection
- **MachOObjCSection Integration** â€” Replaced ClassDumpRuntime with MachOObjCSection for improved ObjC inspection performance, accuracy, and category dumping support
- **MCP (Model Context Protocol) Integration** â€” LLM clients (e.g., Claude) can now inspect runtime information via MCP
- **Export Interface Wizard** â€” Xcode-style multi-step wizard for exporting runtime interfaces to files
- **arm64e Code Injection** â€” Inject into arm64e applications (such as system apps) with helper service support
- **macOS 26 / Xcode 26 Compatibility** â€” Full adaptation for the latest macOS and Xcode

---

## New Features

### Swift Interface Support
- Add initial Swift interface generation support, fully integrated with MachOSwiftSection
- Support Swift section generation options and Swift concurrency
- View Swift type layouts and enum layouts with memory offset display

### MCP Integration (Model Context Protocol)
- Add MCP Server executable for runtime inspection via LLM clients (macOS 15+)
- TCP bridge architecture for seamless communication between app and MCP server
- Automatic port discovery, bridge starts on app launch

### Export Interface Wizard
- Implement Xcode-style multi-step export wizard UI
- Support configuration, selection, progress, and completion steps
- Export single or multiple runtime interfaces (ObjC/Swift) to files

### Runtime Interface Transformer
- Customizable C type replacements in generated interfaces
- ObjC/Swift split transformer configuration with independent settings
- SwiftTypeLayout and SwiftEnumLayout transformers with memory offset display and uppercase hex formatting
- Predefined token template presets in Settings UI

### Settings Panel
- New settings window with general settings, helper service management, and notification preferences
- Install/uninstall helper service directly from settings
- Support for uninstalling legacy helper service
- Configurable connection notification options

### Sidebar Enhancements
- Add reorderable bookmarks with dictionary-indexed storage
- Add interested directories or RuntimeObjects to bookmarks
- Store bookmark dictionaries in Application Support directory (moved from legacy location)
- Automatic one-time migration from old bookmark storage

### Filter Engine
- Implement filter engine and UI for runtime class/protocol filtering
- Add fuzzy search support for type name filtering
- RunningApplicationPicker supports search

### Sandbox App Code Injection
- Add Local Socket connection support for injecting into sandboxed apps
- Communicate with sandboxed apps via local TCP socket

### Connection & Notification System
- Automatic reconnection support with destroy-and-recreate strategy
- System notification when connecting to a new RuntimeSource
- Notification alert on disconnection
- Configurable notification options in settings

### New Helper Service
- Migrate to new SMAppService helper architecture
- Requires reinstalling helper from the settings panel
- Support for uninstalling legacy helper service

### arm64e Architecture Support
- Support arm64e for code injection into arm64e applications (e.g., system apps)
- Main app remains arm64; only daemon and server-side Frameworks are compiled as arm64e
- Fixed crash in arm64e environment

### Other Features
- Text view loading skeleton effect for smoother loading experience
- Jump to definition icon in the interface viewer
- Auto build number based on current date and time
- Open Quickly feature (WIP)

---

## Improvements

### Architecture
- Replace ClassDumpRuntime with MachOObjCSection for Objective-C interface generation â€” improved performance, memory efficiency, and category support
- Simplify coordinator communication with direct routing
- Improve runtime engine lifecycle management and section caching
- Refactor communication layer with local socket and stdio support

### Code Quality
- Improve logging infrastructure with macro-based approach
- Lower minimum deployment target to macOS 10.15 for RuntimeViewerCore
- Comprehensive logging and async-safe locking improvements
- General code cleanup and consistency improvements

### Platform Compatibility
- Full adaptation for macOS 26 / Xcode 26
- Fix iOS platform compatibility issues
- Improve macOS 15 appearance and UI polish
- Fix Text View loading flickering issue

---

## Bug Fixes

- Fix infinite loading issue when opening multiple document windows
- Fix crash when reconnecting XPC connections â€” connections now recover by destroying and recreating instead of reconnecting
- Fix Catalyst side loading failure
- Fix empty list after image loaded
- Fix AppKit autosave name issues causing window state conflicts
- Fix bookmark migration to be one-time with correct storage properties
- Fix bookmark dictionaries stored in wrong directory
- Handle XPC connection errors gracefully
- Optimize text view search experience
- Fix crash in arm64e environment
- Fix various UI issues and crashes
- Fix iOS build errors and compilation issues
- Improve thread safety with proper main actor isolation
- Resolve 16 code review issues from v1.3.0 audit

---

## CI/CD

- Add full macOS archive, export, and notarization release workflow with GitHub Actions
- Self-hosted runner support with configurable runner selection via `workflow_dispatch`
- Import Apple intermediate certificates (WWDRCA, DeveloperID) for self-hosted codesigning
- Add iOS Simulator build to release workflow
- Sign Catalyst helper with Developer ID Application certificate
- Add Claude Code Review and PR Assistant workflows
- Various CI signing, notarization, and permission fixes

## Build & Infrastructure

- Add RuntimeViewerMobileServer target for mobile platforms
- Add Distribution build configuration for XCFramework
- Improve XCFramework build script and fix platform availability
- Update swift-syntax aggregation files and build configurations
- Update build scripts and archive configuration

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 MxIris-Reverse-Engineering

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
<p align="center">
  <img width="30%" src="Resources/AppIcon.png">
</p>

<h1 align="center">Runtime Viewer</h1>

<p align="center">
  A modern alternative to RuntimeBrowser with enhanced UI and extended functionality
</p>

## Powered By

| Language | Library |
|----------|---------|
| Objective-C | [MachOObjCSection](https://github.com/p-x9/MachOObjCSection) |
| Swift | [MachOSwiftSection](https://github.com/MxIris-Reverse-Engineering/MachOSwiftSection) |

## Highlights

- **Swift Interface Support** â€“ View Swift interfaces alongside Objective-C headers
- **Xcode-Style Syntax Highlighting** â€“ Full AppKit/UIKit text view with type-defined jumps and highlighting identical to Xcode
- **Framework Support** â€“ Browse `macOS` frameworks and `iOSSupport` frameworks
- **Easy Export** â€“ Export header or interface files with one click
- **Custom Framework Loading** â€“ Load and inspect custom macOS frameworks
- **Code Injection** â€“ Inject code into running processes (WIP: arm64e support, requires SIP disabled)
- **Multi-Device Support** *(WIP)* â€“ Connect to iOS, watchOS, tvOS, and visionOS devices via Bonjour (requires RuntimeViewerMobileServer)

> [!NOTE]
> Some features marked as *WIP* are only available in beta versions. If you need these features, please download from [Pre-release](../../releases).

## Getting Started

### XPC Helper Installation

On first launch, you need to install the XPC helper for inter-process communication. Click the tool icon in the toolbar to install it.

### Troubleshooting

If Catalyst or code-injected applications don't appear in the directory list, try restarting the application.

## Screenshots

![Screenshot 1](./Resources/Screenshot-001.png)
![Screenshot 2](./Resources/Screenshot-002.png)
![Screenshot 3](./Resources/Screenshot-003.png)

```

`Resources/AppIcon.icon/icon.json`:

```json
{
  "fill" : {
    "automatic-gradient" : "extended-srgb:0.00000,0.53333,1.00000,1.00000"
  },
  "groups" : [
    {
      "blend-mode" : "normal",
      "blur-material" : 0.5,
      "hidden" : false,
      "layers" : [
        {
          "glass" : false,
          "image-name" : "Background 2.png",
          "name" : "Background 2",
          "position" : {
            "scale" : 1.3,
            "translation-in-points" : [
              12.78125,
              3.046875
            ]
          }
        }
      ],
      "lighting" : "individual",
      "shadow" : {
        "kind" : "neutral",
        "opacity" : 0.5
      },
      "specular" : true,
      "translucency" : {
        "enabled" : true,
        "value" : 0.5
      }
    }
  ],
  "supported-platforms" : {
    "circles" : [
      "watchOS"
    ],
    "squares" : "shared"
  }
}
```

`RuntimeViewer.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "container:../MachOKit">
   </FileRef>
   <FileRef
      location = "container:../MachOObjCSection">
   </FileRef>
   <FileRef
      location = "container:../MachOSwiftSection">
   </FileRef>
   <FileRef
      location = "group:RuntimeViewerCore">
   </FileRef>
   <FileRef
      location = "group:RuntimeViewerPackages">
   </FileRef>
   <FileRef
      location = "group:RuntimeViewerMCP">
   </FileRef>
   <FileRef
      location = "group:RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:RuntimeViewerServer/RuntimeViewerServer.xcodeproj">
   </FileRef>
   <FileRef
      location = "group:RuntimeViewerPrecompiledLibraries/swift-syntax">
   </FileRef>
</Workspace>

```

`RuntimeViewer.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

```

`RuntimeViewer.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings`:

```xcsettings
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEWorkspaceSharedSettings_AutocreateContextsIfNeeded</key>
	<false/>
	<key>iOSPackagesShouldBuildARM64e</key>
	<true/>
</dict>
</plist>

```

`RuntimeViewerCore/Package.swift`:

```swift
// swift-tools-version: 6.2
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription
import Foundation

let appkitPlatforms: [Platform] = [.macOS]

let uikitPlatforms: [Platform] = [.iOS, .tvOS, .visionOS, .macCatalyst, .watchOS]

extension Package.Dependency {
    enum LocalSearchPath {
        case package(path: String, isRelative: Bool, isEnabled: Bool)
    }

    static func package(local localSearchPaths: LocalSearchPath..., remote: Package.Dependency) -> Package.Dependency {
        let currentFilePath = #filePath
        let isClonedDependency = currentFilePath.contains("/checkouts/") ||
            currentFilePath.contains("/SourcePackages/") ||
            currentFilePath.contains("/.build/")

        if isClonedDependency {
            return remote
        }
        for local in localSearchPaths {
            switch local {
            case .package(let path, let isRelative, let isEnabled):
                guard isEnabled else { continue }
                let url = if isRelative {
                    URL(fileURLWithPath: path, relativeTo: URL(fileURLWithPath: #filePath))
                } else {
                    URL(fileURLWithPath: path)
                }

                if FileManager.default.fileExists(atPath: url.path) {
                    return .package(path: url.path)
                }
            }
        }
        return remote
    }
}

let package = Package(
    name: "RuntimeViewerCore",
    platforms: [
        .macOS(.v10_15), .iOS(.v13), .macCatalyst(.v13), .watchOS(.v6), .tvOS(.v13), .visionOS(.v1),
    ],
    products: [
        .library(
            name: "RuntimeViewerCore",
            targets: ["RuntimeViewerCore"]
        ),
        .library(
            name: "RuntimeViewerCommunication",
            targets: ["RuntimeViewerCommunication"]
        ),

    ],
    dependencies: [
        .package(
            local: .package(
                path: "../../MachOKit",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/MxIris-Reverse-Engineering/MachOKit.git",
                branch: "main"
            )
        ),
        .package(
            local: .package(
                path: "../../MachOObjCSection",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/MxIris-Reverse-Engineering/MachOObjCSection.git",
                branch: "main"
            )
        ),
        .package(
            local: .package(
                path: "../../MachOSwiftSection",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/MxIris-Reverse-Engineering/MachOSwiftSection",
                branch: "main"
            )
        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/Asynchrone",
            from: "0.23.0-fork"
        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/Semaphore",
            branch: "main"
        ),
        .package(
            url: "https://github.com/Mx-Iris/FrameworkToolbox.git",
            branch: "main"
        ),
        .package(
            url: "https://github.com/MxIris-macOS-Library-Forks/SwiftyXPC",
            branch: "main"
        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/swift-memberwise-init-macro",
            from: "0.5.3-fork"
        ),
        .package(
            url: "https://github.com/mxcl/Version",
            from: "2.2.0"
        ),
        .package(
            url: "https://github.com/SwiftyLab/MetaCodable",
            from: "1.6.0"
        )
    ],
    targets: [
        .target(
            name: "RuntimeViewerCoreObjC"
        ),
        .target(
            name: "RuntimeViewerCore",
            dependencies: [
                "RuntimeViewerCoreObjC",
                "RuntimeViewerCommunication",
                .product(name: "MachOKit", package: "MachOKit"),
                .product(name: "MachOObjCSection", package: "MachOObjCSection"),
                .product(name: "MachOSwiftSection", package: "MachOSwiftSection"),
                .product(name: "SwiftInterface", package: "MachOSwiftSection"),
                .product(name: "MetaCodable", package: "MetaCodable"),
            ],
            swiftSettings: [
                .internalImportsByDefault,
                .immutableWeakCaptures,
            ]
        ),
        .target(
            name: "RuntimeViewerCommunication",
            dependencies: [
                .product(name: "SwiftyXPC", package: "SwiftyXPC", condition: .when(platforms: appkitPlatforms)),
                .product(name: "Asynchrone", package: "Asynchrone"),
                .product(name: "Semaphore", package: "Semaphore"),
                .product(name: "MemberwiseInit", package: "swift-memberwise-init-macro"),
                .product(name: "Version", package: "Version"),
                .product(name: "FoundationToolbox", package: "FrameworkToolbox"),
            ],
            swiftSettings: [
                .internalImportsByDefault,
                .immutableWeakCaptures,
            ]
        ),
        .testTarget(
            name: "RuntimeViewerCommunicationTests",
            dependencies: [
                "RuntimeViewerCommunication",
            ]
        ),
    ],
    swiftLanguageModes: [.v5]
)

extension SwiftSetting {
    static let existentialAny: Self = .enableUpcomingFeature("ExistentialAny") // SE-0335, Swift 5.6,  SwiftPM 5.8+
    static let internalImportsByDefault: Self = .enableUpcomingFeature("InternalImportsByDefault") // SE-0409, Swift 6.0,  SwiftPM 6.0+
    static let memberImportVisibility: Self = .enableUpcomingFeature("MemberImportVisibility") // SE-0444, Swift 6.1,  SwiftPM 6.1+
    static let inferIsolatedConformances: Self = .enableUpcomingFeature("InferIsolatedConformances") // SE-0470, Swift 6.2,  SwiftPM 6.2+
    static let nonisolatedNonsendingByDefault: Self = .enableUpcomingFeature("NonisolatedNonsendingByDefault") // SE-0461, Swift 6.2,  SwiftPM 6.2+
    static let immutableWeakCaptures: Self = .enableUpcomingFeature("ImmutableWeakCaptures") // SE-0481, Swift 6.2,  SwiftPM 6.2+
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Connections/RuntimeConnectionBase.swift`:

```swift
import Foundation
import FoundationToolbox
import Combine

// MARK: - RuntimeConnectionBase

/// Generic base class for RuntimeConnection implementations.
///
/// This class provides a common implementation of the `RuntimeConnection` protocol
/// by delegating to an underlying connection object that handles the actual
/// message sending and receiving.
///
/// ## Usage
///
/// Subclasses should set the `underlyingConnection` property and implement
/// any connection-specific initialization logic.
///
/// ## Type Parameters
///
/// - `Connection`: The underlying connection type that provides `send` and
///   `setMessageHandler` methods.
class RuntimeConnectionBase<Connection: RuntimeUnderlyingConnection>: RuntimeConnection, @unchecked Sendable {
    /// The underlying connection that handles actual communication.
    /// - Note: Thread-safety is managed by the underlying connection itself.
    var underlyingConnection: Connection?

    init() {}

    // MARK: - RuntimeConnection State Properties

    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> {
        underlyingConnection?.statePublisher ?? Just(.disconnected(error: nil)).eraseToAnyPublisher()
    }

    var state: RuntimeConnectionState {
        underlyingConnection?.state ?? .disconnected(error: nil)
    }

    func stop() {
        underlyingConnection?.stop()
    }

    func sendMessage(name: String) async throws {
        guard let connection = underlyingConnection else {
            throw RuntimeConnectionError.notConnected
        }
        try await connection.send(requestData: RuntimeRequestData(identifier: name, value: NullPayload.null))
    }

    func sendMessage(name: String, request: some Codable) async throws {
        guard let connection = underlyingConnection else {
            throw RuntimeConnectionError.notConnected
        }
        try await connection.send(requestData: RuntimeRequestData(identifier: name, value: request))
    }

    func sendMessage<Response: Codable>(name: String) async throws -> Response {
        guard let connection = underlyingConnection else {
            throw RuntimeConnectionError.notConnected
        }
        return try await connection.send(requestData: RuntimeRequestData(identifier: name, value: NullPayload.null))
    }

    func sendMessage<Request: RuntimeRequest>(request: Request) async throws -> Request.Response {
        guard let connection = underlyingConnection else {
            throw RuntimeConnectionError.notConnected
        }
        return try await connection.send(request: request)
    }

    func sendMessage<Response: Codable>(name: String, request: some Codable) async throws -> Response {
        guard let connection = underlyingConnection else {
            throw RuntimeConnectionError.notConnected
        }
        return try await connection.send(requestData: RuntimeRequestData(identifier: name, value: request))
    }

    func setMessageHandler(name: String, handler: @escaping @Sendable () async throws -> Void) {
        underlyingConnection?.setMessageHandler(name: name) { @Sendable (_: NullPayload) in
            try await handler()
            return NullPayload.null
        }
    }

    func setMessageHandler<Request: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Void) {
        underlyingConnection?.setMessageHandler(name: name) { @Sendable (request: Request) in
            try await handler(request)
            return NullPayload.null
        }
    }

    func setMessageHandler<Response: Codable>(name: String, handler: @escaping @Sendable () async throws -> Response) {
        underlyingConnection?.setMessageHandler(name: name) { @Sendable (_: NullPayload) in
            return try await handler()
        }
    }

    func setMessageHandler<Request: RuntimeRequest>(requestType: Request.Type, handler: @escaping @Sendable (Request) async throws -> Request.Response) {
        underlyingConnection?.setMessageHandler(handler)
    }

    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) {
        underlyingConnection?.setMessageHandler(name: name, handler: handler)
    }
}

// MARK: - RuntimeUnderlyingConnection

/// Protocol for underlying connection types that can send and receive messages.
///
/// This protocol abstracts the common interface needed by `RuntimeConnectionBase`
/// to delegate message handling to different connection implementations.
protocol RuntimeUnderlyingConnection: Sendable {
    /// Publisher that emits connection state changes.
    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> { get }

    /// The current connection state.
    var state: RuntimeConnectionState { get }

    /// Stops the connection and releases resources.
    func stop()

    /// Sends a request without expecting a response.
    func send(requestData: RuntimeRequestData) async throws

    /// Sends a request and returns the response.
    func send<Response: Codable>(requestData: RuntimeRequestData) async throws -> Response

    /// Sends a typed request and returns its response.
    func send<Request: RuntimeRequest>(request: Request) async throws -> Request.Response

    /// Registers a message handler for the given name.
    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response)

    /// Registers a message handler for a RuntimeRequest type.
    func setMessageHandler<Request: RuntimeRequest>(_ handler: @escaping @Sendable (Request) async throws -> Request.Response)
}

// MARK: - NullPayload

/// A null payload type used when no payload is needed.
///
/// This is used internally by `RuntimeConnectionBase` for messages
/// that don't require a request or response payload.
struct NullPayload: Codable, Sendable {
    static let null = NullPayload()
}


```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Connections/RuntimeDirectTCPConnection.swift`:

```swift
#if canImport(Network)

import Foundation
import FoundationToolbox
import Network
import Combine

// MARK: - RuntimeDirectTCPConnection

/// A bidirectional TCP connection that doesn't require Bonjour or any special permissions.
///
/// `RuntimeDirectTCPConnection` provides direct TCP communication using Apple's
/// Network framework. Unlike Bonjour-based connections, this doesn't require
/// `NSBonjourServices` configuration - just a known host and port.
///
/// ## Why Direct TCP?
///
/// | Method | iOS Permissions Required |
/// |--------|-------------------------|
/// | Bonjour Browse | `NSBonjourServices` + `NSLocalNetworkUsageDescription` |
/// | Bonjour Advertise | `NSLocalNetworkUsageDescription` |
/// | **Direct TCP** | **None** (just needs host:port) |
///
/// ## Architecture
///
/// ```
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
/// â”‚  Client App         â”‚                    â”‚  Server App         â”‚
/// â”‚                     â”‚                    â”‚                     â”‚
/// â”‚  User inputs or     â”‚   TCP Connect      â”‚  Displays IP:Port   â”‚
/// â”‚  scans QR code      â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  or generates QR    â”‚
/// â”‚  for host:port      â”‚                    â”‚                     â”‚
/// â”‚                     â”‚                    â”‚  NWListener         â”‚
/// â”‚  NWConnection       â”‚ â•â•â• Messages â•â•â•â•â•â•â”‚  (listens on port)  â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
/// ```
///
/// ## Message Protocol
///
/// Messages are JSON-encoded `RuntimeRequestData` with `\nOK` terminator:
/// ```
/// {"identifier":"com.example.Request","data":"base64..."}\nOK
/// ```
///
/// ## Example: Server (Advertiser)
///
/// ```swift
/// let server = try await RuntimeDirectTCPServerConnection(port: 0)  // Auto-assign port
/// print("Server listening on \(server.host):\(server.port)")
///
/// server.setMessageHandler(requestType: GetClassListRequest.self) { request in
///     return GetClassListResponse(classes: [...])
/// }
/// ```
///
/// ## Example: Client (Connector)
///
/// ```swift
/// let client = try await RuntimeDirectTCPClientConnection(
///     host: "192.168.1.100",
///     port: 12345
/// )
///
/// let response = try await client.sendMessage(request: GetClassListRequest())
/// ```
@Loggable
final class RuntimeDirectTCPConnection: RuntimeUnderlyingConnection, @unchecked Sendable {
    let id = UUID()

    private let stateSubject = CurrentValueSubject<RuntimeConnectionState, Never>(.connecting)

    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> {
        stateSubject.eraseToAnyPublisher()
    }

    var state: RuntimeConnectionState {
        stateSubject.value
    }

    private let connection: NWConnection
    private let messageChannel = RuntimeMessageChannel()

    private var isStarted = false
    private let queue = DispatchQueue(label: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeDirectTCPConnection")

    // MARK: - Initialization

    /// Creates an outgoing connection to the specified host and port.
    ///
    /// - Parameters:
    ///   - host: The hostname or IP address to connect to.
    ///   - port: The port number to connect to.
    init(host: String, port: UInt16) {
        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.enableKeepalive = true
        tcpOptions.keepaliveIdle = 2
        tcpOptions.noDelay = true

        let parameters = NWParameters(tls: nil, tcp: tcpOptions)
        parameters.includePeerToPeer = true

        self.connection = NWConnection(
            host: NWEndpoint.Host(host),
            port: NWEndpoint.Port(rawValue: port)!,
            using: parameters
        )

        #log(.info, "Created outgoing connection to \(host, privacy: .public):\(port, privacy: .public)")
    }

    /// Creates a connection from an accepted NWConnection.
    ///
    /// - Parameter connection: The accepted connection from NWListener.
    init(connection: NWConnection) {
        self.connection = connection
        #log(.info, "Created incoming connection: \(connection.debugDescription, privacy: .public)")
    }

    // MARK: - Lifecycle

    func start() throws {
        guard !isStarted else { return }
        isStarted = true

        setupStateHandler()
        setupReceiver()
        observeIncomingMessages()

        connection.start(queue: queue)
        #log(.info, "Connection started")
    }

    func stop() {
        guard isStarted else { return }
        isStarted = false

        connection.stateUpdateHandler = nil
        connection.cancel()
        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: nil))

        #log(.info, "Connection stopped")
    }

    func stop(with error: RuntimeConnectionError) {
        guard isStarted else { return }
        isStarted = false

        connection.stateUpdateHandler = nil
        connection.cancel()
        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: error))

        #log(.info, "Connection stopped with error: \(error.localizedDescription, privacy: .public)")
    }

    // MARK: - State Handling

    private func setupStateHandler() {
        connection.stateUpdateHandler = { [weak self] state in
            guard let self else { return }
            self.handleStateChange(state)
        }
    }

    private func handleStateChange(_ nwState: NWConnection.State) {
        switch nwState {
        case .setup:
            #log(.debug, "Connection is setup")
        case .waiting(let error):
            #log(.default, "Connection is waiting: \(error, privacy: .public)")
            stop(with: .networkError("Connection waiting: \(error.localizedDescription)"))
        case .preparing:
            #log(.debug, "Connection is preparing")
        case .ready:
            #log(.info, "Connection is ready")
            stateSubject.send(.connected)
        case .failed(let error):
            #log(.error, "Connection failed: \(error, privacy: .public)")
            stop(with: .networkError("Connection failed: \(error.localizedDescription)"))
        case .cancelled:
            #log(.info, "Connection cancelled")
        @unknown default:
            break
        }
    }

    // MARK: - Receiving

    private func setupReceiver() {
        connection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { [weak self] data, _, isComplete, error in
            guard let self else { return }

            if let error {
                #log(.error, "Receive error: \(error, privacy: .public)")
                self.messageChannel.finishReceiving(throwing: error)
                self.stop()
            } else if isComplete {
                #log(.debug, "Receive complete")
                self.messageChannel.finishReceiving()
                self.stop()
            } else if let data {
                #log(.debug, "Received \(data.count, privacy: .public) bytes")
                self.messageChannel.appendReceivedData(data)
                self.setupReceiver()
            }
        }
    }

    private func observeIncomingMessages() {
        Task {
            do {
                guard let stream = messageChannel.receivedMessages() else { return }
                for try await data in stream {
                    do {
                        let requestData = try JSONDecoder().decode(RuntimeRequestData.self, from: data)

                        // Check if this is a response to a pending request
                        if messageChannel.deliverToPendingRequest(identifier: requestData.identifier, data: data) {
                            continue
                        }

                        guard let handler = messageChannel.handler(for: requestData.identifier) else {
                            #log(.default, "No handler for: \(requestData.identifier, privacy: .public)")
                            continue
                        }

                        #log(.debug, "Handling request: \(requestData.identifier, privacy: .public)")
                        let responseData = try await handler.closure(requestData.data)

                        if handler.responseType != RuntimeMessageNull.self {
                            let response = RuntimeRequestData(identifier: requestData.identifier, data: responseData)
                            try await send(requestData: response)
                        }
                    } catch {
                        #log(.error, "Handler error: \(error, privacy: .public)")
                        let errorResponse = RuntimeNetworkRequestError(message: "\(error)")
                        if let errorData = try? JSONEncoder().encode(errorResponse) {
                            try? await sendRaw(data: errorData + RuntimeMessageChannel.endMarkerData)
                        }
                    }
                }
            } catch {
                #log(.error, "Message observation error: \(error, privacy: .public)")
            }
        }
    }

    // MARK: - RuntimeUnderlyingConnection

    func send(requestData: RuntimeRequestData) async throws {
        let data = try JSONEncoder().encode(requestData)
        try await messageChannel.send(data: data) { [weak self] dataToSend in
            try await self?.sendRaw(data: dataToSend)
        }
        #log(.debug, "Sent request: \(requestData.identifier, privacy: .public)")
    }

    func send<Response: Codable>(requestData: RuntimeRequestData) async throws -> Response {
        try await messageChannel.sendRequest(requestData: requestData) { [weak self] data in
            try await self?.sendRaw(data: data)
        }
    }

    func send<Request: RuntimeRequest>(request: Request) async throws -> Request.Response {
        let requestData = try RuntimeRequestData(request: request)
        return try await send(requestData: requestData)
    }

    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) {
        messageChannel.setMessageHandler(name: name, handler: handler)
    }

    func setMessageHandler<Request: RuntimeRequest>(_ handler: @escaping @Sendable (Request) async throws -> Request.Response) {
        messageChannel.setMessageHandler(handler)
    }

    // MARK: - Private

    private func sendRaw(data: Data) async throws {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            connection.send(content: data, completion: .contentProcessed { error in
                if let error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume()
                }
            })
        }
    }
}

// MARK: - RuntimeDirectTCPClientConnection

/// Client connection that connects directly to a known host and port.
///
/// Use this when you have the server's IP address and port, either from:
/// - User input
/// - QR code scan
/// - Configuration file
///
/// ## Usage
///
/// ```swift
/// let client = try await RuntimeDirectTCPClientConnection(
///     host: "192.168.1.100",
///     port: 12345
/// )
///
/// let classes = try await client.sendMessage(request: GetClassListRequest())
/// ```
final class RuntimeDirectTCPClientConnection: RuntimeConnectionBase<RuntimeDirectTCPConnection>, @unchecked Sendable {
    private var connectionStateCancellable: AnyCancellable?

    /// Creates a client connection to the specified host and port.
    ///
    /// - Parameters:
    ///   - host: The hostname or IP address of the server.
    ///   - port: The port number the server is listening on.
    ///   - timeout: Maximum time to wait for connection (default: 10 seconds).
    init(host: String, port: UInt16, timeout: TimeInterval = 10) async throws {
        super.init()

        let connection = RuntimeDirectTCPConnection(host: host, port: port)
        self.underlyingConnection = connection

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            let didResume = Mutex<Bool>(false)

            // Observe connection state
            self.connectionStateCancellable = connection.statePublisher
                .sink { state in
                    if state.isConnected {
                        if didResume.withLock({ !$0 }) {
                            didResume.withLock { $0 = true }
                            continuation.resume()
                        }
                    } else if state.isDisconnected {
                        if didResume.withLock({ !$0 }) {
                            didResume.withLock { $0 = true }
                            if case .disconnected(let error) = state, let error {
                                continuation.resume(throwing: error)
                            } else {
                                continuation.resume(throwing: RuntimeDirectTCPError.connectionFailed)
                            }
                        }
                    }
                }

            do {
                try connection.start()
            } catch {
                if didResume.withLock({ !$0 }) {
                    didResume.withLock { $0 = true }
                    continuation.resume(throwing: error)
                }
            }

            DispatchQueue.global().asyncAfter(deadline: .now() + timeout) {
                if didResume.withLock({ !$0 }) {
                    didResume.withLock { $0 = true }
                    connection.stop(with: .timeout)
                    continuation.resume(throwing: RuntimeDirectTCPError.timeout)
                }
            }
        }
    }

    override func stop() {
        connectionStateCancellable?.cancel()
        connectionStateCancellable = nil
        underlyingConnection?.stop()
    }
}

// MARK: - RuntimeDirectTCPServerConnection

/// Server connection that listens on a specified port for incoming connections.
///
/// The server can listen on:
/// - Port 0: System assigns an available port (recommended)
/// - Specific port: Use a known port number
///
/// ## Usage
///
/// ```swift
/// let server = try await RuntimeDirectTCPServerConnection(port: 0)
/// print("Listening on \(server.host):\(server.port)")
///
/// // Display this info to user or generate QR code
/// server.setMessageHandler(requestType: GetClassListRequest.self) { request in
///     return GetClassListResponse(classes: [...])
/// }
/// ```
@Loggable
final class RuntimeDirectTCPServerConnection: RuntimeConnectionBase<RuntimeDirectTCPConnection>, @unchecked Sendable {
    private var listener: NWListener?
    private var connectionStateCancellable: AnyCancellable?

    /// The host address the server is listening on.
    private(set) var host: String = ""

    /// The port the server is listening on (available after initialization).
    private(set) var port: UInt16 = 0

    /// Creates a server that listens on the specified port.
    ///
    /// - Parameter port: The port to listen on (0 for auto-assign).
    init(port: UInt16 = 0) async throws {
        super.init()

        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.enableKeepalive = true
        tcpOptions.keepaliveIdle = 2
        tcpOptions.noDelay = true

        let parameters = NWParameters(tls: nil, tcp: tcpOptions)
        parameters.includePeerToPeer = true

        let listener: NWListener
        if port == 0 {
            listener = try NWListener(using: parameters)
        } else {
            listener = try NWListener(using: parameters, on: NWEndpoint.Port(rawValue: port)!)
        }

        self.listener = listener

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            let didResume = Mutex<Bool>(false)

            listener.stateUpdateHandler = { [weak self] listenerState in
                guard let self else { return }

                switch listenerState {
                case .ready:
                    if let port = listener.port {
                        self.port = port.rawValue
                        self.host = Self.getLocalIPAddress() ?? "127.0.0.1"
                        #log(.info, "Server listening on \(self.host, privacy: .public):\(self.port, privacy: .public)")
                    }
                case .failed(let error):
                    if didResume.withLock({ !$0 }) {
                        didResume.withLock { $0 = true }
                        continuation.resume(throwing: error)
                    }
                default:
                    break
                }
            }

            listener.newConnectionHandler = { [weak self] newConnection in
                guard let self else { return }

                #log(.info, "Accepted new connection")

                let tcpConnection = RuntimeDirectTCPConnection(connection: newConnection)
                self.underlyingConnection = tcpConnection

                // Observe connection state
                self.connectionStateCancellable = tcpConnection.statePublisher
                    .sink { [weak self] state in
                        if state.isConnected {
                            if didResume.withLock({ !$0 }) {
                                didResume.withLock { $0 = true }
                                continuation.resume()
                            }
                        } else if state.isDisconnected {
                            if didResume.withLock({ !$0 }) {
                                // Connection failed before becoming ready
                                if case .disconnected(let error) = state, let error {
                                    didResume.withLock { $0 = true }
                                    continuation.resume(throwing: error)
                                }
                            } else {
                                // Connection was ready and then disconnected, restart listening
                                Task { [weak self] in
                                    try await self?.restartListening()
                                }
                            }
                        }
                    }

                do {
                    try tcpConnection.start()
                } catch {
                    #log(.error, "Failed to start connection: \(error, privacy: .public)")
                    Task { [weak self] in
                        try await self?.restartListening()
                    }
                }
            }

            listener.start(queue: .main)
        }
    }

    private func restartListening() async throws {
        listener?.newConnectionHandler = { [weak self] newConnection in
            guard let self else { return }

            #log(.info, "Accepted new connection")

            let tcpConnection = RuntimeDirectTCPConnection(connection: newConnection)
            self.underlyingConnection = tcpConnection

            // Observe connection state to restart listening when disconnected
            self.connectionStateCancellable = tcpConnection.statePublisher
                .filter { $0.isDisconnected }
                .sink { [weak self] _ in
                    Task { [weak self] in
                        try await self?.restartListening()
                    }
                }

            do {
                try tcpConnection.start()
            } catch {
                #log(.error, "Failed to start connection: \(error, privacy: .public)")
            }
        }
    }

    /// Stops the server and closes all connections.
    override func stop() {
        connectionStateCancellable?.cancel()
        connectionStateCancellable = nil
        underlyingConnection?.stop()
        listener?.cancel()
        listener = nil
    }

    deinit {
        stop()
    }

    /// Gets the local IP address of the device.
    private static func getLocalIPAddress() -> String? {
        var address: String?

        var ifaddr: UnsafeMutablePointer<ifaddrs>?
        guard getifaddrs(&ifaddr) == 0, let firstAddr = ifaddr else {
            return nil
        }

        defer { freeifaddrs(ifaddr) }

        for ptr in sequence(first: firstAddr, next: { $0.pointee.ifa_next }) {
            let interface = ptr.pointee
            let addrFamily = interface.ifa_addr.pointee.sa_family

            if addrFamily == UInt8(AF_INET) {
                let name = String(cString: interface.ifa_name)

                if name == "en0" || name == "en1" {
                    var hostname = [CChar](repeating: 0, count: Int(NI_MAXHOST))
                    getnameinfo(
                        interface.ifa_addr,
                        socklen_t(interface.ifa_addr.pointee.sa_len),
                        &hostname,
                        socklen_t(hostname.count),
                        nil,
                        0,
                        NI_NUMERICHOST
                    )
                    address = String(cString: hostname)
                    break
                }
            }
        }

        return address
    }
}

// MARK: - RuntimeDirectTCPError

/// Errors that can occur during direct TCP operations.
enum RuntimeDirectTCPError: Error, LocalizedError {
    case connectionFailed
    case timeout

    var errorDescription: String? {
        switch self {
        case .connectionFailed:
            return "Failed to establish connection"
        case .timeout:
            return "Connection timed out"
        }
    }
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Connections/RuntimeLocalSocketConnection.swift`:

```swift
import Foundation
import FoundationToolbox
import Combine

// MARK: - RuntimeLocalSocketConnection

/// A bidirectional communication channel over TCP localhost socket.
///
/// `RuntimeLocalSocketConnection` provides a universal IPC mechanism that works
/// across all scenarios including sandboxed apps and code injection, without
/// requiring any special entitlements or Info.plist configuration.
///
/// ## Why TCP Localhost?
///
/// | Method | Sandbox Compatible | No Config Required |
/// |--------|-------------------|-------------------|
/// | XPC Mach Service | âŒ | âœ… |
/// | Bonjour/Network | âŒ (needs NSBonjourServices) | âŒ |
/// | Unix Domain Socket | âŒ (path restrictions) | âœ… |
/// | **TCP Localhost** | **âœ…** | **âœ…** |
///
/// ## Role Inversion: Why Socket Roles Are Swapped
///
/// In a typical design, the "server" (data provider) would create a socket server,
/// and the "client" (data consumer) would connect to it. However, sandboxed apps
/// have restrictions on `bind()` system calls, while `connect()` is generally allowed.
///
/// Since the **injected code runs inside sandboxed target apps** (e.g., Numbers, Pages),
/// it cannot create a socket server. Therefore, we **invert the socket roles**:
///
/// | Component | Business Role | Socket Role | Reason |
/// |-----------|---------------|-------------|--------|
/// | Main App (RuntimeViewer) | Client (sends queries) | **Server** (bind/listen) | Has network permissions |
/// | Injected Code | Server (handles queries) | **Client** (connect) | Runs in sandbox, connect() OK |
///
/// ```
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
/// â”‚  RuntimeViewer          â”‚                    â”‚  Target Process         â”‚
/// â”‚  (Main App)             â”‚                    â”‚  (Sandboxed)            â”‚
/// â”‚                         â”‚                    â”‚                         â”‚
/// â”‚  Business: Client       â”‚   1. start server  â”‚                         â”‚
/// â”‚  Socket: SERVER         â”‚   2. inject dylib  â”‚                         â”‚
/// â”‚  (bind/listen OK)       â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  Business: Server       â”‚
/// â”‚                         â”‚                    â”‚  Socket: CLIENT         â”‚
/// â”‚                         â”‚ <â”€â”€â”€â”€ connect â”€â”€â”€â”€â”€â”‚  (connect OK in sandbox)â”‚
/// â”‚                         â”‚                    â”‚                         â”‚
/// â”‚  sendMessage(request)   â”‚ â”€â”€â”€â”€ request â”€â”€â”€â”€â”€>â”‚  handleMessage(request) â”‚
/// â”‚  receive(response)      â”‚ <â”€â”€â”€ response â”€â”€â”€â”€â”€â”‚  return response        â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
/// ```
///
/// ## Port Discovery: Deterministic Hash-Based Calculation
///
/// Since sandboxed apps cannot share files via `/tmp` or other directories,
/// we use a deterministic hash algorithm to compute the port number from the
/// identifier. Both sides independently calculate the same port:
///
/// ```swift
/// port = djb2_hash(identifier) % 16383 + 49152  // Range: 49152-65535
/// ```
///
/// This eliminates the need for file-based port discovery entirely.
///
/// ## Example: Main App (Socket Server, Business Client)
///
/// ```swift
/// // Main app creates socket server before injecting code
/// let connection = RuntimeLocalSocketServerConnection(
///     identifier: "com.myapp.runtime-\(targetPID)"
/// )
/// try await connection.start()
///
/// // Inject dylib into target process...
/// // Injected code will connect as socket client
///
/// // Send queries to injected code (business client role)
/// let classes = try await connection.sendMessage(request: GetClassListRequest())
/// ```
///
/// ## Example: Injected Code (Socket Client, Business Server)
///
/// ```swift
/// @_cdecl("injected_entry")
/// func injectedEntry() {
///     Task {
///         // Connect to main app's socket server
///         let connection = try await RuntimeLocalSocketClientConnection(
///             identifier: "com.myapp.runtime-\(getpid())"
///         )
///
///         // Handle queries from main app (business server role)
///         connection.setMessageHandler(requestType: GetClassListRequest.self) { request in
///             return GetClassListResponse(classes: objc_copyClassList()...)
///         }
///     }
/// }
/// ```
///
@Loggable
final class RuntimeLocalSocketConnection: RuntimeUnderlyingConnection, @unchecked Sendable {
    let id = UUID()

    private let stateSubject = CurrentValueSubject<RuntimeConnectionState, Never>(.connecting)

    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> {
        stateSubject.eraseToAnyPublisher()
    }

    var state: RuntimeConnectionState {
        stateSubject.value
    }

    private var socketFD: Int32 = -1
    private let messageChannel = RuntimeMessageChannel()

    private var isStarted = false

    private let readQueue = DispatchQueue(label: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeLocalSocketConnection.readQueue")
    private let writeQueue = DispatchQueue(label: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeLocalSocketConnection.writeQueue")

    // MARK: - Initialization

    init(socketFD: Int32) {
        self.socketFD = socketFD
    }

    init(port: UInt16) throws {
        #log(.info, "Creating connection to localhost:\(port, privacy: .public)")
        try connectToLocalhost(port: port)
    }

    private func connectToLocalhost(port: UInt16) throws {
        errno = 0
        socketFD = socket(AF_INET, SOCK_STREAM, 0)
        guard socketFD >= 0 else {
            throw RuntimeLocalSocketError.socketCreationFailed(errno: errno)
        }

        var addr = sockaddr_in()
        addr.sin_family = sa_family_t(AF_INET)
        addr.sin_port = port.bigEndian
        addr.sin_addr.s_addr = inet_addr("127.0.0.1")

        errno = 0
        let result = withUnsafePointer(to: &addr) { ptr in
            ptr.withMemoryRebound(to: sockaddr.self, capacity: 1) { sockaddrPtr in
                Darwin.connect(socketFD, sockaddrPtr, socklen_t(MemoryLayout<sockaddr_in>.size))
            }
        }
        let connectErrno = errno

        guard result == 0 else {
            close(socketFD)
            socketFD = -1
            throw RuntimeLocalSocketError.connectFailed(errno: connectErrno, port: port)
        }

        // Disable Nagle algorithm for lower latency
        var noDelay: Int32 = 1
        setsockopt(socketFD, IPPROTO_TCP, TCP_NODELAY, &noDelay, socklen_t(MemoryLayout<Int32>.size))

        #log(.info, "Connected to localhost:\(port, privacy: .public)")
    }

    // MARK: - Lifecycle

    func start() throws {
        guard !isStarted else { return }
        guard socketFD >= 0 else { throw RuntimeLocalSocketError.notConnected }
        isStarted = true

        setupReceiver()
        observeIncomingMessages()

        stateSubject.send(.connected)
        #log(.info, "Connection started")
    }

    func stop() {
        guard isStarted else { return }
        isStarted = false

        if socketFD >= 0 {
            close(socketFD)
            socketFD = -1
        }
        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: nil))

        #log(.info, "Connection stopped")
    }

    func stop(with error: RuntimeConnectionError) {
        guard isStarted else { return }
        isStarted = false

        if socketFD >= 0 {
            close(socketFD)
            socketFD = -1
        }
        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: error))

        #log(.info, "Connection stopped with error: \(error.localizedDescription, privacy: .public)")
    }

    // MARK: - Receiving

    private func setupReceiver() {
        readQueue.async { [weak self] in
            guard let self else { return }
            var buffer = [UInt8](repeating: 0, count: 65536)

            while self.isStarted && self.socketFD >= 0 {
                let bytesRead = recv(self.socketFD, &buffer, buffer.count, 0)

                if bytesRead > 0 {
                    let data = Data(buffer[0..<bytesRead])
                    #log(.debug, "Received \(bytesRead, privacy: .public) bytes")
                    self.messageChannel.appendReceivedData(data)
                } else if bytesRead == 0 {
                    #log(.info, "Connection closed by peer")
                    self.messageChannel.finishReceiving()
                    DispatchQueue.main.async {
                        self.stop(with: .peerClosed)
                    }
                    break
                } else {
                    let recvErrno = errno
                    if recvErrno != EAGAIN && recvErrno != EWOULDBLOCK {
                        #log(.error, "Receive error, errno=\(recvErrno, privacy: .public)")
                        self.messageChannel.finishReceiving()
                        DispatchQueue.main.async {
                            self.stop(with: .socketError("Receive error: errno=\(recvErrno)"))
                        }
                        break
                    }
                }
            }
        }
    }

    private func observeIncomingMessages() {
        Task {
            do {
                guard let stream = messageChannel.receivedMessages() else { return }
                for try await data in stream {
                    do {
                        let requestData = try JSONDecoder().decode(RuntimeRequestData.self, from: data)

                        // Check if this is a response to a pending request
                        if messageChannel.deliverToPendingRequest(identifier: requestData.identifier, data: data) {
                            continue
                        }

                        guard let handler = messageChannel.handler(for: requestData.identifier) else {
                            #log(.default, "No handler for: \(requestData.identifier, privacy: .public)")
                            continue
                        }

                        #log(.debug, "Handling request: \(requestData.identifier, privacy: .public)")
                        let responseData = try await handler.closure(requestData.data)

                        if handler.responseType != RuntimeMessageNull.self {
                            let response = RuntimeRequestData(identifier: requestData.identifier, data: responseData)
                            try await send(requestData: response)
                        }
                    } catch {
                        #log(.error, "Handler error: \(error, privacy: .public)")
                        let errorResponse = RuntimeNetworkRequestError(message: "\(error)")
                        if let errorData = try? JSONEncoder().encode(errorResponse) {
                            try? await sendRaw(data: errorData + RuntimeMessageChannel.endMarkerData)
                        }
                    }
                }
            } catch {
                #log(.error, "Message observation error: \(error, privacy: .public)")
            }
        }
    }

    // MARK: - RuntimeUnderlyingConnection

    func send(requestData: RuntimeRequestData) async throws {
        let data = try JSONEncoder().encode(requestData)
        try await messageChannel.send(data: data) { [weak self] dataToSend in
            try await self?.sendRaw(data: dataToSend)
        }
        #log(.debug, "Sent request: \(requestData.identifier, privacy: .public)")
    }

    func send<Response: Codable>(requestData: RuntimeRequestData) async throws -> Response {
        try await messageChannel.sendRequest(requestData: requestData) { [weak self] data in
            try await self?.sendRaw(data: data)
        }
    }

    func send<Request: RuntimeRequest>(request: Request) async throws -> Request.Response {
        let requestData = try RuntimeRequestData(request: request)
        return try await send(requestData: requestData)
    }

    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) {
        messageChannel.setMessageHandler(name: name, handler: handler)
    }

    func setMessageHandler<Request: RuntimeRequest>(_ handler: @escaping @Sendable (Request) async throws -> Request.Response) {
        messageChannel.setMessageHandler(handler)
    }

    // MARK: - Private

    private func sendRaw(data: Data) async throws {
        guard socketFD >= 0 else { throw RuntimeLocalSocketError.notConnected }

        try await withCheckedThrowingContinuation { [weak self] (continuation: CheckedContinuation<Void, Error>) in
            guard let self, self.socketFD >= 0 else {
                continuation.resume(throwing: RuntimeLocalSocketError.notConnected)
                return
            }

            self.writeQueue.async { [weak self] in
                guard let self, self.socketFD >= 0 else {
                    continuation.resume(throwing: RuntimeLocalSocketError.notConnected)
                    return
                }

                data.withUnsafeBytes { buffer in
                    guard let baseAddress = buffer.baseAddress else {
                        continuation.resume(throwing: RuntimeLocalSocketError.notConnected)
                        return
                    }

                    var totalSent = 0
                    while totalSent < data.count {
                        let sent = Darwin.send(self.socketFD, baseAddress.advanced(by: totalSent), data.count - totalSent, 0)
                        if sent < 0 {
                            let sendErrno = errno
                            continuation.resume(throwing: RuntimeLocalSocketError.sendFailed(errno: sendErrno))
                            return
                        }
                        totalSent += sent
                    }
                    continuation.resume()
                }
            }
        }
    }
}

// MARK: - RuntimeLocalSocketError

/// Errors that can occur during local socket communication.
enum RuntimeLocalSocketError: Error, LocalizedError, CustomStringConvertible, Sendable {
    case notConnected
    case receiveFailed
    case socketCreationFailed(errno: Int32)
    case bindFailed(errno: Int32, port: UInt16)
    case listenFailed(errno: Int32)
    case acceptFailed(errno: Int32)
    case connectFailed(errno: Int32, port: UInt16)
    case sendFailed(errno: Int32)
    case portFileNotFound(path: String, timeout: TimeInterval)
    case invalidPortFile(path: String, content: String?)

    var description: String {
        switch self {
        case .notConnected:
            return "RuntimeLocalSocketError.notConnected: Socket is not connected"
        case .receiveFailed:
            return "RuntimeLocalSocketError.receiveFailed: Failed to receive data from socket"
        case .socketCreationFailed(let errno):
            return "RuntimeLocalSocketError.socketCreationFailed: Failed to create socket - \(Self.errnoDescription(errno))"
        case .bindFailed(let errno, let port):
            return "RuntimeLocalSocketError.bindFailed: Failed to bind to 127.0.0.1:\(port) - \(Self.errnoDescription(errno))"
        case .listenFailed(let errno):
            return "RuntimeLocalSocketError.listenFailed: Failed to listen on socket - \(Self.errnoDescription(errno))"
        case .acceptFailed(let errno):
            return "RuntimeLocalSocketError.acceptFailed: Failed to accept connection - \(Self.errnoDescription(errno))"
        case .connectFailed(let errno, let port):
            return "RuntimeLocalSocketError.connectFailed: Failed to connect to 127.0.0.1:\(port) - \(Self.errnoDescription(errno))"
        case .sendFailed(let errno):
            return "RuntimeLocalSocketError.sendFailed: Failed to send data - \(Self.errnoDescription(errno))"
        case .portFileNotFound(let path, let timeout):
            return "RuntimeLocalSocketError.portFileNotFound: Port file not found at '\(path)' after \(timeout)s timeout"
        case .invalidPortFile(let path, let content):
            return "RuntimeLocalSocketError.invalidPortFile: Invalid port file at '\(path)', content: '\(content ?? "nil")'"
        }
    }

    var errorDescription: String? { description }

    private static func errnoDescription(_ errno: Int32) -> String {
        let name = errnoName(errno)
        let message = String(cString: strerror(errno))
        return "errno=\(errno) (\(name)): \(message)"
    }

    private static func errnoName(_ errno: Int32) -> String {
        switch errno {
        case EPERM: return "EPERM"
        case ENOENT: return "ENOENT"
        case ESRCH: return "ESRCH"
        case EINTR: return "EINTR"
        case EIO: return "EIO"
        case ENXIO: return "ENXIO"
        case E2BIG: return "E2BIG"
        case ENOEXEC: return "ENOEXEC"
        case EBADF: return "EBADF"
        case ECHILD: return "ECHILD"
        case EDEADLK: return "EDEADLK"
        case ENOMEM: return "ENOMEM"
        case EACCES: return "EACCES"
        case EFAULT: return "EFAULT"
        case EBUSY: return "EBUSY"
        case EEXIST: return "EEXIST"
        case EXDEV: return "EXDEV"
        case ENODEV: return "ENODEV"
        case ENOTDIR: return "ENOTDIR"
        case EISDIR: return "EISDIR"
        case EINVAL: return "EINVAL"
        case ENFILE: return "ENFILE"
        case EMFILE: return "EMFILE"
        case ENOTTY: return "ENOTTY"
        case ETXTBSY: return "ETXTBSY"
        case EFBIG: return "EFBIG"
        case ENOSPC: return "ENOSPC"
        case ESPIPE: return "ESPIPE"
        case EROFS: return "EROFS"
        case EMLINK: return "EMLINK"
        case EPIPE: return "EPIPE"
        case EDOM: return "EDOM"
        case ERANGE: return "ERANGE"
        case EAGAIN: return "EAGAIN"
        case EINPROGRESS: return "EINPROGRESS"
        case EALREADY: return "EALREADY"
        case ENOTSOCK: return "ENOTSOCK"
        case EDESTADDRREQ: return "EDESTADDRREQ"
        case EMSGSIZE: return "EMSGSIZE"
        case EPROTOTYPE: return "EPROTOTYPE"
        case ENOPROTOOPT: return "ENOPROTOOPT"
        case EPROTONOSUPPORT: return "EPROTONOSUPPORT"
        case ENOTSUP: return "ENOTSUP"
        case EAFNOSUPPORT: return "EAFNOSUPPORT"
        case EADDRINUSE: return "EADDRINUSE"
        case EADDRNOTAVAIL: return "EADDRNOTAVAIL"
        case ENETDOWN: return "ENETDOWN"
        case ENETUNREACH: return "ENETUNREACH"
        case ENETRESET: return "ENETRESET"
        case ECONNABORTED: return "ECONNABORTED"
        case ECONNRESET: return "ECONNRESET"
        case ENOBUFS: return "ENOBUFS"
        case EISCONN: return "EISCONN"
        case ENOTCONN: return "ENOTCONN"
        case ETIMEDOUT: return "ETIMEDOUT"
        case ECONNREFUSED: return "ECONNREFUSED"
        case ELOOP: return "ELOOP"
        case ENAMETOOLONG: return "ENAMETOOLONG"
        case EHOSTDOWN: return "EHOSTDOWN"
        case EHOSTUNREACH: return "EHOSTUNREACH"
        case ENOTEMPTY: return "ENOTEMPTY"
        case ENOLCK: return "ENOLCK"
        case ENOSYS: return "ENOSYS"
        default: return "UNKNOWN"
        }
    }
}

// MARK: - RuntimeLocalSocketPortDiscovery

/// Handles port discovery using deterministic port calculation.
///
/// Since sandboxed apps cannot share files via `/tmp` or other directories,
/// we use a hash-based algorithm to compute a deterministic port number
/// from the identifier. Both server and client can independently calculate
/// the same port without any file I/O.
@Loggable
enum RuntimeLocalSocketPortDiscovery {

    /// Dynamic/private port range (IANA recommendation)
    private static let portRangeStart: UInt16 = 49152
    private static let portRangeEnd: UInt16 = 65535
    private static let portRangeSize: UInt16 = portRangeEnd - portRangeStart

    /// Computes a deterministic port number from the identifier.
    ///
    /// Uses a simple hash function to map the identifier to a port
    /// in the dynamic/private range (49152-65535).
    ///
    /// - Parameter identifier: Unique identifier for the connection.
    /// - Returns: A port number in the range 49152-65535.
    static func computePort(for identifier: String) -> UInt16 {
        // Use a simple hash: sum of character values with mixing
        var hash: UInt64 = 5381
        for char in identifier.utf8 {
            hash = ((hash << 5) &+ hash) &+ UInt64(char) // hash * 33 + char
        }

        let port = UInt16(hash % UInt64(portRangeSize)) + portRangeStart
        #log(.info, "Computed port \(port, privacy: .public) for identifier '\(identifier, privacy: .public)'")
        return port
    }
}

// MARK: - RuntimeLocalSocketClientConnection

/// Socket client connection for use in **injected code** running inside sandboxed apps.
///
/// ## Role Clarification
///
/// | Aspect | This Class |
/// |--------|------------|
/// | Socket Role | **Client** (connect to server) |
/// | Business Role | **Server** (handles queries, returns data) |
/// | Runs In | Injected dylib inside target (sandboxed) app |
/// | Counterpart | `RuntimeLocalSocketServerConnection` in main app |
///
/// ## Why Socket Client for Business Server?
///
/// This class uses socket client (`connect()`) because:
/// 1. Injected code runs inside sandboxed apps (e.g., Numbers, Pages)
/// 2. Sandboxed apps cannot call `bind()` - returns EPERM
/// 3. `connect()` is allowed even in sandboxed environments
///
/// The main app (RuntimeViewer) creates the socket server, and this class
/// connects to it. Despite being the socket client, this side handles
/// runtime queries and returns data (business server role).
///
/// ## Usage in Injected Code
///
/// ```swift
/// @_cdecl("injected_entry")
/// func injectedEntry() {
///     Task {
///         // Connect to the socket server created by main app
///         let connection = try await RuntimeLocalSocketClientConnection(
///             identifier: "com.myapp.runtime-\(getpid())"
///         )
///
///         // Handle queries from main app (business server role)
///         connection.setMessageHandler(requestType: GetClassesRequest.self) { request in
///             return GetClassesResponse(classes: objc_copyClassList()...)
///         }
///     }
/// }
/// ```
///
/// - Note: The identifier must match what the main app used when creating
///   `RuntimeLocalSocketServerConnection`. Both sides use the same identifier
///   to compute the deterministic port number.
final class RuntimeLocalSocketClientConnection: RuntimeConnectionBase<RuntimeLocalSocketConnection>, @unchecked Sendable {
    private let identifier: String

    /// Creates a client connection using deterministic port calculation.
    ///
    /// - Parameters:
    ///   - identifier: Unique identifier matching the server's identifier.
    ///   - timeout: Maximum time to wait for server to be ready (default: 10 seconds).
    /// - Throws: `RuntimeLocalSocketError` if connection cannot be established.
    init(identifier: String, timeout: TimeInterval = 10) async throws {
        self.identifier = identifier
        super.init()

        // Compute port deterministically (same algorithm as server)
        let port = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)

        // Retry connection until server is ready or timeout
        let startTime = Date()
        var lastError: Error?

        while Date().timeIntervalSince(startTime) < timeout {
            do {
                let connection = try RuntimeLocalSocketConnection(port: port)
                self.underlyingConnection = connection
                try connection.start()
                return
            } catch {
                lastError = error
                // Wait before retry
                try await Task.sleep(nanoseconds: 100_000_000) // 100ms
            }
        }

        throw lastError ?? RuntimeLocalSocketError.connectFailed(errno: ETIMEDOUT, port: port)
    }

    /// Creates a client connection to a known port.
    ///
    /// - Parameters:
    ///   - port: The server port to connect to.
    /// - Throws: `RuntimeLocalSocketError` if connection cannot be established.
    init(port: UInt16) throws {
        self.identifier = ""
        super.init()

        let connection = try RuntimeLocalSocketConnection(port: port)
        self.underlyingConnection = connection
        try connection.start()
    }
}

// MARK: - RuntimeLocalSocketServerConnection

/// Socket server connection for use in the **main app** (RuntimeViewer).
///
/// ## Role Clarification
///
/// | Aspect | This Class |
/// |--------|------------|
/// | Socket Role | **Server** (bind/listen/accept) |
/// | Business Role | **Client** (sends queries, receives data) |
/// | Runs In | Main RuntimeViewer app (non-sandboxed) |
/// | Counterpart | `RuntimeLocalSocketClientConnection` in injected code |
///
/// ## Why Socket Server for Business Client?
///
/// This class uses socket server (`bind()`/`listen()`) because:
/// 1. The main app (RuntimeViewer) has full network permissions
/// 2. The counterpart (injected code) runs in sandboxed apps that cannot `bind()`
/// 3. By hosting the socket server here, the injected code only needs `connect()`
///
/// Despite being the socket server, this side sends runtime queries and
/// receives data (business client role).
///
/// ## Port Discovery
///
/// The port is computed deterministically from the identifier using a hash
/// algorithm. Both this class and `RuntimeLocalSocketClientConnection` use
/// the same algorithm, so no file-based port discovery is needed.
///
/// ## Usage in Main App
///
/// ```swift
/// // 1. Create and start socket server before injecting code
/// let connection = RuntimeLocalSocketServerConnection(
///     identifier: "com.myapp.runtime-\(targetPID)"
/// )
/// try await connection.start()
///
/// // 2. Inject dylib into target process
/// // The injected code will connect using RuntimeLocalSocketClientConnection
///
/// // 3. Send queries to injected code (business client role)
/// let classes = try await connection.sendMessage(request: GetClassesRequest())
/// ```
///
/// - Note: The identifier must match what the injected code uses when creating
///   `RuntimeLocalSocketClientConnection`. Both sides use the same identifier
///   to compute the deterministic port number.
@Loggable
final class RuntimeLocalSocketServerConnection: RuntimeConnectionBase<RuntimeLocalSocketConnection>, @unchecked Sendable {
    private var serverSocketFD: Int32 = -1
    private let identifier: String

    /// Pending message handlers to apply to new connections.
    private var pendingHandlers: [@Sendable (RuntimeLocalSocketConnection) -> Void] = []

    /// Subscription for observing connection state changes.
    private var connectionStateCancellable: AnyCancellable?

    /// The port the server is listening on (available after `start()` is called).
    private(set) var port: UInt16 = 0

    /// Creates a server connection with deterministic port calculation.
    ///
    /// - Parameter identifier: Unique identifier used to compute the port.
    init(identifier: String) {
        self.identifier = identifier
        self.port = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)
        super.init()
    }

    /// Creates a server connection on a specific port.
    ///
    /// - Parameter port: The port to listen on (0 for auto-assign).
    init(port: UInt16 = 0) {
        self.identifier = ""
        self.port = port
        super.init()
    }

    // MARK: - Message Handler Overrides

    override func setMessageHandler(name: String, handler: @escaping @Sendable () async throws -> Void) {
        let setupHandler: @Sendable (RuntimeLocalSocketConnection) -> Void = { connection in
            connection.setMessageHandler(name: name) { @Sendable (_: NullPayload) in
                try await handler()
                return NullPayload.null
            }
        }
        pendingHandlers.append(setupHandler)
        if let connection = underlyingConnection {
            setupHandler(connection)
        }
    }

    override func setMessageHandler<Request>(name: String, handler: @escaping @Sendable (Request) async throws -> Void) where Request: Codable {
        let setupHandler: @Sendable (RuntimeLocalSocketConnection) -> Void = { connection in
            connection.setMessageHandler(name: name) { @Sendable (request: Request) in
                try await handler(request)
                return NullPayload.null
            }
        }
        pendingHandlers.append(setupHandler)
        if let connection = underlyingConnection {
            setupHandler(connection)
        }
    }

    override func setMessageHandler<Response>(name: String, handler: @escaping @Sendable () async throws -> Response) where Response: Codable {
        let setupHandler: @Sendable (RuntimeLocalSocketConnection) -> Void = { connection in
            connection.setMessageHandler(name: name) { @Sendable (_: NullPayload) in
                return try await handler()
            }
        }
        pendingHandlers.append(setupHandler)
        if let connection = underlyingConnection {
            setupHandler(connection)
        }
    }

    override func setMessageHandler<Request>(requestType: Request.Type, handler: @escaping @Sendable (Request) async throws -> Request.Response) where Request: RuntimeRequest {
        let setupHandler: @Sendable (RuntimeLocalSocketConnection) -> Void = { connection in
            connection.setMessageHandler { @Sendable (request: Request) in
                return try await handler(request)
            }
        }
        pendingHandlers.append(setupHandler)
        if let connection = underlyingConnection {
            setupHandler(connection)
        }
    }

    override func setMessageHandler<Request, Response>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) where Request: Codable, Response: Codable {
        let setupHandler: @Sendable (RuntimeLocalSocketConnection) -> Void = { connection in
            connection.setMessageHandler(name: name) { @Sendable (request: Request) in
                return try await handler(request)
            }
        }
        pendingHandlers.append(setupHandler)
        if let connection = underlyingConnection {
            setupHandler(connection)
        }
    }

    /// Applies all pending handlers to a connection.
    private func applyPendingHandlers(to connection: RuntimeLocalSocketConnection) {
        for handler in pendingHandlers {
            handler(connection)
        }
    }

    /// Starts listening for connections.
    ///
    /// After this method returns, the server is ready to accept connections
    /// and the port file has been written for client discovery.
    /// Connections are accepted asynchronously in the background.
    func start() async throws {
        errno = 0
        serverSocketFD = socket(AF_INET, SOCK_STREAM, 0)
        guard serverSocketFD >= 0 else {
            throw RuntimeLocalSocketError.socketCreationFailed(errno: errno)
        }

        var reuseAddr: Int32 = 1
        setsockopt(serverSocketFD, SOL_SOCKET, SO_REUSEADDR, &reuseAddr, socklen_t(MemoryLayout<Int32>.size))

        var addr = sockaddr_in()
        addr.sin_family = sa_family_t(AF_INET)
        addr.sin_port = port.bigEndian
        addr.sin_addr.s_addr = inet_addr("127.0.0.1")

        errno = 0
        let bindResult = withUnsafePointer(to: &addr) { ptr in
            ptr.withMemoryRebound(to: sockaddr.self, capacity: 1) { sockaddrPtr in
                bind(serverSocketFD, sockaddrPtr, socklen_t(MemoryLayout<sockaddr_in>.size))
            }
        }
        let bindErrno = errno

        guard bindResult == 0 else {
            close(serverSocketFD)
            serverSocketFD = -1
            throw RuntimeLocalSocketError.bindFailed(errno: bindErrno, port: port)
        }

        errno = 0
        guard listen(serverSocketFD, 5) == 0 else {
            let listenErrno = errno
            close(serverSocketFD)
            serverSocketFD = -1
            throw RuntimeLocalSocketError.listenFailed(errno: listenErrno)
        }

        #log(.info, "Server listening on 127.0.0.1:\(self.port, privacy: .public)")

        // Start accepting connections in background (non-blocking)
        startAcceptingConnections()
    }

    /// Starts accepting connections asynchronously in background.
    private func startAcceptingConnections() {
        DispatchQueue.global().async { [weak self] in
            self?.acceptConnectionLoop()
        }
    }

    /// Continuously accepts client connections.
    private func acceptConnectionLoop() {
        guard serverSocketFD >= 0 else { return }

        var clientAddr = sockaddr_in()
        var clientAddrLen = socklen_t(MemoryLayout<sockaddr_in>.size)

        let clientFD = withUnsafeMutablePointer(to: &clientAddr) { ptr in
            ptr.withMemoryRebound(to: sockaddr.self, capacity: 1) { sockaddrPtr in
                accept(serverSocketFD, sockaddrPtr, &clientAddrLen)
            }
        }

        guard clientFD >= 0 else {
            // Accept failed, likely server was stopped
            return
        }

        // Disable Nagle algorithm for lower latency
        var noDelay: Int32 = 1
        setsockopt(clientFD, IPPROTO_TCP, TCP_NODELAY, &noDelay, socklen_t(MemoryLayout<Int32>.size))

        let socketConnection = RuntimeLocalSocketConnection(socketFD: clientFD)
        self.underlyingConnection = socketConnection

        // Apply all pending message handlers to the new connection
        applyPendingHandlers(to: socketConnection)

        // Observe connection state to restart accepting when disconnected
        connectionStateCancellable = socketConnection.statePublisher
            .filter { $0.isDisconnected }
            .sink { [weak self] _ in
                self?.startAcceptingConnections()
            }

        do {
            try socketConnection.start()
        } catch {
            #log(.error, "Failed to start connection: \(error, privacy: .public)")
            // Try accepting again
            startAcceptingConnections()
        }
    }

    /// Stops the server and cleans up resources.
    override func stop() {
        connectionStateCancellable?.cancel()
        connectionStateCancellable = nil
        underlyingConnection?.stop()
        if serverSocketFD >= 0 {
            close(serverSocketFD)
            serverSocketFD = -1
        }
    }

    deinit {
        stop()
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Connections/RuntimeNetworkConnection.swift`:

```swift
#if canImport(Network)

import Foundation
import FoundationToolbox
import Network
import Combine

// MARK: - RuntimeNetworkConnection

/// A bidirectional communication channel over the network using Apple's Network framework.
///
/// `RuntimeNetworkConnection` enables communication between devices on the same local
/// network, typically used for iOS device to Mac communication via Bonjour service discovery.
///
/// ## Architecture
///
/// ```
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
/// â”‚  iOS Device         â”‚                    â”‚  Mac                â”‚
/// â”‚                     â”‚                    â”‚                     â”‚
/// â”‚  RuntimeViewer App  â”‚   Bonjour Browse   â”‚  RuntimeViewer App  â”‚
/// â”‚                     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                     â”‚
/// â”‚                     â”‚                    â”‚  NWListener         â”‚
/// â”‚  NetworkClient      â”‚ <â”€â”€ TCP Connect â”€â”€â”€â”‚  (Advertises)       â”‚
/// â”‚                     â”‚                    â”‚                     â”‚
/// â”‚                     â”‚ â•â•â• Messages â•â•â•â•â•â•â”‚  NetworkServer      â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
/// ```
///
/// ## Message Protocol
///
/// Messages are JSON-encoded `RuntimeRequestData` with `\nOK` terminator:
/// ```
/// {"identifier":"com.example.MyRequest","data":"base64..."}\nOK
/// ```
///
/// ## Features
///
/// - Automatic Bonjour service discovery
/// - TCP keepalive for connection health monitoring
/// - Peer-to-peer communication support
/// - Async/await message handling
///
/// ## Use Cases
///
/// - Inspecting iOS app runtime from a Mac
/// - Cross-device debugging and development
/// - Remote runtime exploration
///
/// - Note: Requires both devices to be on the same local network.
///   For sandboxed app injection, use `RuntimeLocalSocketConnection` instead.
@Loggable
final class RuntimeNetworkConnection: RuntimeUnderlyingConnection, @unchecked Sendable {
    let id = UUID()

    private let stateSubject = CurrentValueSubject<RuntimeConnectionState, Never>(.connecting)

    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> {
        stateSubject.eraseToAnyPublisher()
    }

    var state: RuntimeConnectionState {
        stateSubject.value
    }

    private let connection: NWConnection
    private let messageChannel = RuntimeMessageChannel()

    private var isStarted = false
    private let queue = DispatchQueue(label: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeNetworkConnection")

    // MARK: - Initialization

    /// Creates an outgoing connection to the specified endpoint.
    ///
    /// - Parameter endpoint: The Bonjour-discovered endpoint to connect to.
    init(endpoint: NWEndpoint) throws {
        #log(.info, "Creating outgoing connection to: \(endpoint.debugDescription, privacy: .public)")

        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.enableKeepalive = true
        tcpOptions.keepaliveIdle = 2
        tcpOptions.noDelay = true

        let parameters = NWParameters(tls: nil, tcp: tcpOptions)
        parameters.includePeerToPeer = true

        self.connection = NWConnection(to: endpoint, using: parameters)
        try start()
    }

    /// Creates a connection from an accepted NWConnection.
    ///
    /// - Parameter connection: The accepted connection from NWListener.
    init(connection: NWConnection) throws {
        #log(.info, "Creating incoming connection: \(connection.debugDescription, privacy: .public)")
        self.connection = connection
        try start()
    }

    // MARK: - Lifecycle

    func start() throws {
        guard !isStarted else { return }
        isStarted = true

        setupStateHandler()
        setupReceiver()
        observeIncomingMessages()

        connection.start(queue: queue)
        #log(.info, "Connection started")
    }

    func stop() {
        guard isStarted else { return }
        isStarted = false

        connection.stateUpdateHandler = nil
        connection.cancel()
        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: nil))

        #log(.info, "Connection stopped")
    }

    func stop(with error: RuntimeConnectionError) {
        guard isStarted else { return }
        isStarted = false

        connection.stateUpdateHandler = nil
        connection.cancel()
        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: error))

        #log(.info, "Connection stopped with error: \(error.localizedDescription, privacy: .public)")
    }

    // MARK: - State Handling

    private func setupStateHandler() {
        connection.stateUpdateHandler = { [weak self] state in
            guard let self else { return }
            self.handleStateChange(state)
        }
    }

    private func handleStateChange(_ nwState: NWConnection.State) {
        switch nwState {
        case .setup:
            #log(.debug, "Connection is setup")
        case .waiting(let error):
            #log(.default, "Connection is waiting: \(error, privacy: .public)")
            stop(with: .networkError("Connection waiting: \(error.localizedDescription)"))
        case .preparing:
            #log(.debug, "Connection is preparing")
        case .ready:
            #log(.info, "Connection is ready")
            stateSubject.send(.connected)
        case .failed(let error):
            #log(.error, "Connection failed: \(error, privacy: .public)")
            stop(with: .networkError("Connection failed: \(error.localizedDescription)"))
        case .cancelled:
            #log(.info, "Connection cancelled")
        @unknown default:
            break
        }
    }

    // MARK: - Receiving

    private func setupReceiver() {
        connection.receive(minimumIncompleteLength: 1, maximumLength: 65536) { [weak self] data, _, isComplete, error in
            guard let self else { return }

            if let error {
                #log(.error, "Receive error: \(error, privacy: .public)")
                self.messageChannel.finishReceiving(throwing: error)
                self.stop()
            } else if isComplete {
                #log(.debug, "Receive complete")
                self.messageChannel.finishReceiving()
                self.stop()
            } else if let data {
                #log(.debug, "Received \(data.count, privacy: .public) bytes")
                self.messageChannel.appendReceivedData(data)
                self.setupReceiver()
            }
        }
    }

    private func observeIncomingMessages() {
        Task {
            do {
                guard let stream = messageChannel.receivedMessages() else { return }
                for try await data in stream {
                    do {
                        let requestData = try JSONDecoder().decode(RuntimeRequestData.self, from: data)

                        // Check if this is a response to a pending request
                        if messageChannel.deliverToPendingRequest(identifier: requestData.identifier, data: data) {
                            continue
                        }

                        guard let handler = messageChannel.handler(for: requestData.identifier) else {
                            #log(.default, "No handler for: \(requestData.identifier, privacy: .public)")
                            continue
                        }

                        #log(.debug, "Handling request: \(requestData.identifier, privacy: .public)")
                        let responseData = try await handler.closure(requestData.data)

                        if handler.responseType != RuntimeMessageNull.self {
                            let response = RuntimeRequestData(identifier: requestData.identifier, data: responseData)
                            try await send(requestData: response)
                        }
                    } catch {
                        #log(.error, "Handler error: \(error, privacy: .public)")
                        let errorResponse = RuntimeNetworkRequestError(message: "\(error)")
                        if let errorData = try? JSONEncoder().encode(errorResponse) {
                            try? await sendRaw(data: errorData + RuntimeMessageChannel.endMarkerData)
                        }
                    }
                }
            } catch {
                #log(.error, "Message observation error: \(error, privacy: .public)")
            }
        }
    }

    // MARK: - RuntimeUnderlyingConnection

    func send(requestData: RuntimeRequestData) async throws {
        let data = try JSONEncoder().encode(requestData)
        try await messageChannel.send(data: data) { [weak self] dataToSend in
            try await self?.sendRaw(data: dataToSend)
        }
        #log(.debug, "Sent request: \(requestData.identifier, privacy: .public)")
    }

    func send<Response: Codable>(requestData: RuntimeRequestData) async throws -> Response {
        try await messageChannel.sendRequest(requestData: requestData) { [weak self] data in
            try await self?.sendRaw(data: data)
        }
    }

    func send<Request: RuntimeRequest>(request: Request) async throws -> Request.Response {
        let requestData = try RuntimeRequestData(request: request)
        return try await send(requestData: requestData)
    }

    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) {
        messageChannel.setMessageHandler(name: name, handler: handler)
    }

    func setMessageHandler<Request: RuntimeRequest>(_ handler: @escaping @Sendable (Request) async throws -> Request.Response) {
        messageChannel.setMessageHandler(handler)
    }

    // MARK: - Private

    private func sendRaw(data: Data) async throws {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            connection.send(content: data, completion: .contentProcessed { error in
                if let error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume()
                }
            })
        }
    }
}

// MARK: - RuntimeNetworkClientConnection

/// Network client that connects to a Bonjour-discovered server.
///
/// Use this to connect to a `RuntimeNetworkServerConnection` that was discovered
/// via Bonjour service browsing.
///
/// ## Usage
///
/// ```swift
/// // After discovering endpoint via Bonjour browser
/// let client = try RuntimeNetworkClientConnection(endpoint: discoveredEndpoint)
///
/// // Send requests
/// let classes = try await client.sendMessage(request: GetClassListRequest())
/// ```
///
/// - Note: The endpoint is typically obtained from `RuntimeNetworkBrowser`.
final class RuntimeNetworkClientConnection: RuntimeConnectionBase<RuntimeNetworkConnection>, @unchecked Sendable {
    /// Creates a client connection to the specified network endpoint.
    ///
    /// - Parameter endpoint: The Bonjour-discovered endpoint to connect to.
    /// - Throws: `RuntimeNetworkError` if connection cannot be established.
    init(endpoint: RuntimeNetworkEndpoint) throws {
        super.init()
        self.underlyingConnection = try RuntimeNetworkConnection(endpoint: endpoint.endpoint)
    }
}

// MARK: - RuntimeNetworkServerConnection

/// Network server that advertises via Bonjour and accepts incoming connections.
///
/// Use this to create a server that can be discovered by `RuntimeNetworkClientConnection`
/// on other devices via Bonjour.
///
/// ## Usage
///
/// ```swift
/// let server = try await RuntimeNetworkServerConnection(name: "My Mac")
///
/// // Register handlers for incoming requests
/// server.setMessageHandler(requestType: GetClassListRequest.self) { request in
///     return GetClassListResponse(classes: objc_copyClassList()...)
/// }
/// ```
///
/// - Note: The server automatically restarts listening after a client disconnects.
@Loggable
final class RuntimeNetworkServerConnection: RuntimeConnectionBase<RuntimeNetworkConnection>, @unchecked Sendable {
    private var listener: NWListener?
    private var connectionStateCancellable: AnyCancellable?

    init(name: String) async throws {
        super.init()

        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.enableKeepalive = true
        tcpOptions.keepaliveIdle = 2
        tcpOptions.noDelay = true

        let parameters = NWParameters(tls: nil, tcp: tcpOptions)
        parameters.includePeerToPeer = true

        let listener = try NWListener(using: parameters)
        listener.service = NWListener.Service(name: name, type: RuntimeNetworkBonjour.type)
        self.listener = listener

        try await waitForConnection(listener: listener)
    }

    private func waitForConnection(listener: NWListener) async throws {
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in

            let didResume = Mutex<Bool>(false)

            listener.newConnectionHandler = { [weak self] newConnection in
                guard let self, didResume.withLock({ !$0 }) else { return }

                #log(.info, "Accepted new connection")

                do {
                    let connection = try RuntimeNetworkConnection(connection: newConnection)
                    self.underlyingConnection = connection

                    // Observe connection state
                    self.connectionStateCancellable = connection.statePublisher
                        .sink { [weak self] state in
                            if state.isConnected {
                                if didResume.withLock({ !$0 }) {
                                    didResume.withLock { $0 = true }
                                    continuation.resume()
                                }
                            } else if state.isDisconnected {
                                if didResume.withLock({ !$0 }) {
                                    // Connection failed before becoming ready
                                    if case .disconnected(let error) = state, let error {
                                        didResume.withLock { $0 = true }
                                        continuation.resume(throwing: error)
                                    }
                                } else {
                                    // Connection was ready and then disconnected, restart listening
                                    Task { [weak self] in
                                        try await self?.restartListening()
                                    }
                                }
                            }
                        }
                } catch {
                    if didResume.withLock({ !$0 }) {
                        didResume.withLock { $0 = true }
                        continuation.resume(throwing: error)
                    }
                }

                listener.newConnectionHandler = nil
                listener.cancel()
            }

            listener.start(queue: .main)
        }
    }

    private func restartListening() async throws {
        guard let listener else { return }

        listener.newConnectionHandler = { [weak self] newConnection in
            guard let self else { return }

            #log(.info, "Accepted new connection")

            do {
                let connection = try RuntimeNetworkConnection(connection: newConnection)
                self.underlyingConnection = connection

                // Observe connection state to restart listening when disconnected
                self.connectionStateCancellable = connection.statePublisher
                    .filter { $0.isDisconnected }
                    .sink { [weak self] _ in
                        Task { [weak self] in
                            try await self?.restartListening()
                        }
                    }
            } catch {
                #log(.error, "Failed to create connection: \(error, privacy: .public)")
            }
        }
    }

    override func stop() {
        connectionStateCancellable?.cancel()
        connectionStateCancellable = nil
        underlyingConnection?.stop()
        listener?.cancel()
        listener = nil
    }
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Connections/RuntimeStdioConnection.swift`:

```swift
import Foundation
import FoundationToolbox
import Combine

// MARK: - RuntimeStdioConnection

/// A bidirectional communication channel over standard I/O (stdin/stdout).
///
/// `RuntimeStdioConnection` enables inter-process communication using file handles,
/// typically stdin and stdout. This is useful for CLI tools, language servers (LSP),
/// or any scenario where processes communicate via pipes.
///
/// ## Message Protocol
///
/// Messages are JSON-encoded and terminated with `\nOK` marker:
/// ```
/// {"identifier":"MyRequest","data":"..."}\nOK
/// ```
///
/// ## Architecture
///
/// ```
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
/// â”‚  Parent Process â”‚                    â”‚  Child Process  â”‚
/// â”‚                 â”‚                    â”‚                 â”‚
/// â”‚  outputHandle â”€â”€â”¼â”€â”€â”€â”€ stdin â”€â”€â”€â”€â”€â”€â”€â”€>â”‚  inputHandle    â”‚
/// â”‚                 â”‚                    â”‚                 â”‚
/// â”‚  inputHandle  <â”€â”¼â”€â”€â”€â”€ stdout â”€â”€â”€â”€â”€â”€â”€â”€â”‚  outputHandle   â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
/// ```
///
/// ## Example: Parent Process (Client)
///
/// ```swift
/// // Launch child process
/// let process = Process()
/// process.executableURL = URL(fileURLWithPath: "/path/to/server")
///
/// let stdinPipe = Pipe()
/// let stdoutPipe = Pipe()
/// process.standardInput = stdinPipe
/// process.standardOutput = stdoutPipe
///
/// try process.run()
///
/// // Create client connection
/// // Client writes to child's stdin, reads from child's stdout
/// let client = try RuntimeStdioClientConnection(
///     inputHandle: stdoutPipe.fileHandleForReading,   // Read from child's stdout
///     outputHandle: stdinPipe.fileHandleForWriting    // Write to child's stdin
/// )
///
/// // Send request and receive response
/// let response: MyResponse = try await client.sendMessage(request: MyRequest())
/// ```
///
/// ## Example: Child Process (Server)
///
/// ```swift
/// // Server uses standard stdin/stdout
/// let server = try RuntimeStdioServerConnection(
///     inputHandle: .standardInput,
///     outputHandle: .standardOutput
/// )
///
/// // Register message handler
/// server.setMessageHandler(requestType: MyRequest.self) { request in
///     return MyResponse(result: "Processed: \(request.value)")
/// }
///
/// // Keep the process running
/// RunLoop.main.run()
/// ```
///
/// ## Defining Request/Response Types
///
/// ```swift
/// struct MyRequest: RuntimeRequest {
///     static let identifier = "MyRequest"
///     typealias Response = MyResponse
///
///     let value: String
/// }
///
/// struct MyResponse: RuntimeResponse {
///     let result: String
/// }
/// ```
///
@Loggable
final class RuntimeStdioConnection: RuntimeUnderlyingConnection, @unchecked Sendable {
    let id = UUID()

    private let stateSubject = CurrentValueSubject<RuntimeConnectionState, Never>(.connecting)

    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> {
        stateSubject.eraseToAnyPublisher()
    }

    var state: RuntimeConnectionState {
        stateSubject.value
    }

    private let inputHandle: FileHandle
    private let outputHandle: FileHandle
    private let messageChannel = RuntimeMessageChannel()

    private var isStarted = false

    private let readQueue = DispatchQueue(label: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeStdioConnection.readQueue")

    // MARK: - Initialization

    init(inputHandle: FileHandle, outputHandle: FileHandle) {
        self.inputHandle = inputHandle
        self.outputHandle = outputHandle
    }

    // MARK: - Lifecycle

    func start() throws {
        guard !isStarted else { return }
        isStarted = true

        setupReceiver()
        observeIncomingMessages()

        stateSubject.send(.connected)
        #log(.info, "Connection started")
    }

    func stop() {
        guard isStarted else { return }
        isStarted = false

        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: nil))

        #log(.info, "Connection stopped")
    }

    func stop(with error: RuntimeConnectionError) {
        guard isStarted else { return }
        isStarted = false

        messageChannel.finishReceiving()
        stateSubject.send(.disconnected(error: error))

        #log(.info, "Connection stopped with error: \(error.localizedDescription, privacy: .public)")
    }

    // MARK: - Receiving

    private func setupReceiver() {
        readQueue.async { [weak self] in
            guard let self else { return }

            while self.isStarted {
                let data = self.inputHandle.availableData
                if data.isEmpty {
                    #log(.info, "Input stream closed")
                    self.messageChannel.finishReceiving()
                    DispatchQueue.main.async {
                        self.stop(with: .peerClosed)
                    }
                    break
                } else {
                    #log(.debug, "Received \(data.count, privacy: .public) bytes")
                    self.messageChannel.appendReceivedData(data)
                }
            }
        }
    }

    private func observeIncomingMessages() {
        Task {
            do {
                guard let stream = messageChannel.receivedMessages() else { return }
                for try await data in stream {
                    do {
                        let requestData = try JSONDecoder().decode(RuntimeRequestData.self, from: data)

                        // Check if this is a response to a pending request
                        if messageChannel.deliverToPendingRequest(identifier: requestData.identifier, data: data) {
                            continue
                        }

                        guard let handler = messageChannel.handler(for: requestData.identifier) else {
                            #log(.default, "No handler for: \(requestData.identifier, privacy: .public)")
                            continue
                        }

                        #log(.debug, "Handling request: \(requestData.identifier, privacy: .public)")
                        let responseData = try await handler.closure(requestData.data)

                        if handler.responseType != RuntimeMessageNull.self {
                            let response = RuntimeRequestData(identifier: requestData.identifier, data: responseData)
                            try await send(requestData: response)
                        }
                    } catch {
                        #log(.error, "Handler error: \(error, privacy: .public)")
                        let errorResponse = RuntimeNetworkRequestError(message: "\(error)")
                        if let errorData = try? JSONEncoder().encode(errorResponse) {
                            try? await sendRaw(data: errorData + RuntimeMessageChannel.endMarkerData)
                        }
                    }
                }
            } catch {
                #log(.error, "Message observation error: \(error, privacy: .public)")
            }
        }
    }

    // MARK: - RuntimeUnderlyingConnection

    func send(requestData: RuntimeRequestData) async throws {
        let data = try JSONEncoder().encode(requestData)
        try await messageChannel.send(data: data) { [weak self] dataToSend in
            try await self?.sendRaw(data: dataToSend)
        }
        #log(.debug, "Sent request: \(requestData.identifier, privacy: .public)")
    }

    func send<Response: Codable>(requestData: RuntimeRequestData) async throws -> Response {
        try await messageChannel.sendRequest(requestData: requestData) { [weak self] data in
            try await self?.sendRaw(data: data)
        }
    }

    func send<Request: RuntimeRequest>(request: Request) async throws -> Request.Response {
        let requestData = try RuntimeRequestData(request: request)
        return try await send(requestData: requestData)
    }

    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) {
        messageChannel.setMessageHandler(name: name, handler: handler)
    }

    func setMessageHandler<Request: RuntimeRequest>(_ handler: @escaping @Sendable (Request) async throws -> Request.Response) {
        messageChannel.setMessageHandler(handler)
    }

    // MARK: - Private

    private func sendRaw(data: Data) async throws {
        if #available(macOS 10.15.4, iOS 13.4, watchOS 6.2, tvOS 13.4, *) {
            try outputHandle.write(contentsOf: data)
        } else {
            outputHandle.write(data)
        }
    }
}

// MARK: - RuntimeStdioError

/// Errors that can occur during stdio communication.
enum RuntimeStdioError: Error, LocalizedError, Sendable {
    /// The connection is not established or has been closed.
    case notConnected
    /// Failed to receive data from the input stream.
    case receiveFailed

    var errorDescription: String? {
        switch self {
        case .notConnected:
            return "Stdio connection is not established"
        case .receiveFailed:
            return "Failed to receive data from stdio"
        }
    }
}

// MARK: - RuntimeStdioClientConnection

/// Client-side stdio connection for sending requests to a child process.
///
/// Use this when your process launches another process and wants to communicate with it.
///
/// ## Usage
///
/// ```swift
/// let process = Process()
/// process.executableURL = URL(fileURLWithPath: "/path/to/server")
///
/// let stdinPipe = Pipe()
/// let stdoutPipe = Pipe()
/// process.standardInput = stdinPipe
/// process.standardOutput = stdoutPipe
///
/// try process.run()
///
/// let client = try RuntimeStdioClientConnection(
///     inputHandle: stdoutPipe.fileHandleForReading,
///     outputHandle: stdinPipe.fileHandleForWriting
/// )
///
/// // Send typed request
/// let response = try await client.sendMessage(request: MyRequest(value: "hello"))
///
/// // Or send by name
/// let result: String = try await client.sendMessage(name: "echo", request: "hello")
/// ```
final class RuntimeStdioClientConnection: RuntimeConnectionBase<RuntimeStdioConnection>, @unchecked Sendable {
    /// Creates a client connection with the specified file handles.
    ///
    /// - Parameters:
    ///   - inputHandle: File handle to read responses from (typically the child's stdout).
    ///   - outputHandle: File handle to write requests to (typically the child's stdin).
    /// - Throws: `RuntimeStdioError` if connection cannot be started.
    init(inputHandle: FileHandle, outputHandle: FileHandle) throws {
        super.init()
        let connection = RuntimeStdioConnection(inputHandle: inputHandle, outputHandle: outputHandle)
        self.underlyingConnection = connection
        try connection.start()
    }
}

// MARK: - RuntimeStdioServerConnection

/// Server-side stdio connection for handling requests from a parent process.
///
/// Use this when your process is launched by another process and should respond to its requests.
///
/// ## Usage
///
/// ```swift
/// let server = try RuntimeStdioServerConnection(
///     inputHandle: .standardInput,
///     outputHandle: .standardOutput
/// )
///
/// // Register handler for typed requests
/// server.setMessageHandler(requestType: MyRequest.self) { request in
///     return MyResponse(result: "Received: \(request.value)")
/// }
///
/// // Register handler by name
/// server.setMessageHandler(name: "echo") { (input: String) -> String in
///     return "Echo: \(input)"
/// }
///
/// // Keep process alive
/// RunLoop.main.run()
/// ```
final class RuntimeStdioServerConnection: RuntimeConnectionBase<RuntimeStdioConnection>, @unchecked Sendable {
    /// Creates a server connection with the specified file handles.
    ///
    /// - Parameters:
    ///   - inputHandle: File handle to read requests from (typically `.standardInput`).
    ///   - outputHandle: File handle to write responses to (typically `.standardOutput`).
    /// - Throws: `RuntimeStdioError` if connection cannot be started.
    init(inputHandle: FileHandle, outputHandle: FileHandle) throws {
        super.init()
        let connection = RuntimeStdioConnection(inputHandle: inputHandle, outputHandle: outputHandle)
        self.underlyingConnection = connection
        try connection.start()
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Connections/RuntimeXPCConnection.swift`:

```swift
#if os(macOS)

import Foundation
import FoundationToolbox
import Combine
@preconcurrency public import SwiftyXPC

// MARK: - RuntimeXPCConnection

/// XPC-based connection for cross-process communication on macOS.
///
/// `RuntimeXPCConnection` uses XPC Mach services to establish secure, bidirectional
/// communication between processes. This is the recommended approach for communication
/// between an app and its privileged helper tool or XPC service.
///
/// ## Architecture
///
/// ```
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
/// â”‚  Client App         â”‚                    â”‚  XPC Mach Service   â”‚
/// â”‚                     â”‚                    â”‚  (Privileged Helper)â”‚
/// â”‚                     â”‚   1. connect       â”‚                     â”‚
/// â”‚  XPCClientConnectionâ”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚                     â”‚
/// â”‚                     â”‚                    â”‚                     â”‚
/// â”‚                     â”‚   2. register      â”‚  Endpoint Registry  â”‚
/// â”‚                     â”‚      endpoint      â”‚                     â”‚
/// â”‚                     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                     â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
///                                                      â”‚
///                                                      â”‚ 3. broker
///                                                      â”‚    connection
///                                                      â–¼
/// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
/// â”‚  Server Process     â”‚                    â”‚                     â”‚
/// â”‚  (e.g., Catalyst)   â”‚   4. direct XPC    â”‚                     â”‚
/// â”‚                     â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                     â”‚
/// â”‚  XPCServerConnectionâ”‚                    â”‚                     â”‚
/// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
/// ```
///
/// ## Requirements
///
/// - macOS only (XPC is not available on iOS)
/// - Requires a privileged helper tool installed as a Mach service
/// - Both processes must be properly code-signed
///
/// ## Use Cases
///
/// - Communication between main app and Mac Catalyst helper
/// - Privileged operations requiring elevated permissions
/// - Secure IPC with code signing validation
///
/// - Note: For code injection into sandboxed apps, use `RuntimeLocalSocketConnection`
///   instead, as XPC requires the target process to explicitly participate.
@Loggable
class RuntimeXPCConnection: RuntimeConnection, @unchecked Sendable {
    fileprivate let identifier: RuntimeSource.Identifier

    fileprivate let listener: SwiftyXPC.XPCListener

    fileprivate let serviceConnection: SwiftyXPC.XPCConnection

    fileprivate var connection: SwiftyXPC.XPCConnection?

    fileprivate let stateSubject = CurrentValueSubject<RuntimeConnectionState, Never>(.connecting)

    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> {
        stateSubject.eraseToAnyPublisher()
    }

    var state: RuntimeConnectionState {
        stateSubject.value
    }

    init(identifier: RuntimeSource.Identifier, modifier: ((RuntimeXPCConnection) async throws -> Void)? = nil) async throws {
        self.identifier = identifier
        let listener = try SwiftyXPC.XPCListener(type: .anonymous, codeSigningRequirement: nil)
        listener.setMessageHandler(requestType: PingRequest.self) { connection, request in
            return .empty
        }
        self.listener = listener
        self.serviceConnection = try await Self.connectToMachService()
        self.listener.errorHandler = { [weak self] in
            guard let self else { return }
            handleListenerError(connection: $0, error: $1)
        }
        serviceConnection.errorHandler = { [weak self] in
            guard let self else { return }
            handleServiceConnectionError(connection: $0, error: $1)
        }
        try await modifier?(self)

        self.listener.activate()
    }

    private static func connectToMachService() async throws -> SwiftyXPC.XPCConnection {
        let serviceConnection = try XPCConnection(type: .remoteMachService(serviceName: RuntimeViewerMachServiceName, isPrivilegedHelperTool: true))
        serviceConnection.activate()
        try await serviceConnection.sendMessage(request: PingRequest())
        #log(.info, "Ping mach service successfully")
        return serviceConnection
    }

    func handleServiceConnectionError(connection: SwiftyXPC.XPCConnection, error: any Swift.Error) {
        #log(.error, "\(String(describing: connection), privacy: .public) \(String(describing: error), privacy: .public)")
//        stateSubject.send(.disconnected(error: .xpcError("Service connection error: \(error.localizedDescription)")))
    }

    func handleListenerError(connection: SwiftyXPC.XPCConnection, error: any Swift.Error) {
        #log(.error, "\(String(describing: connection), privacy: .public) \(String(describing: error), privacy: .public)")
        stateSubject.send(.disconnected(error: .xpcError("Listener error: \(error.localizedDescription)")))
    }

    func handleClientOrServerConnectionError(connection: SwiftyXPC.XPCConnection, error: any Swift.Error) {
        #log(.error, "\(String(describing: connection), privacy: .public) \(String(describing: error), privacy: .public)")
        stateSubject.send(.disconnected(error: .xpcError("Connection error: \(error.localizedDescription)")))
    }

    func stop() {
        connection?.cancel()
        connection = nil
        serviceConnection.cancel()
        listener.cancel()
        stateSubject.send(.disconnected(error: nil))
        #log(.info, "XPC connection stopped")
    }

    enum Error: Swift.Error {
        case connectionNotAvailable
    }

    func sendMessage(name: String) async throws {
        guard let connection = connection else {
            throw Error.connectionNotAvailable
        }
        try await connection.sendMessage(name: name)
    }

    func sendMessage<Request: RuntimeRequest>(request: Request) async throws -> Request.Response {
        guard let connection = connection else {
            throw Error.connectionNotAvailable
        }
        return try await connection.sendMessage(request: request)
    }

    func sendMessage<Response>(name: String, request: some Codable) async throws -> Response where Response: Decodable, Response: Encodable, Response: Sendable {
        guard let connection = connection else {
            throw Error.connectionNotAvailable
        }
        return try await connection.sendMessage(name: name, request: request)
    }

    func sendMessage<Response>(name: String) async throws -> Response where Response: Decodable, Response: Encodable {
        guard let connection = connection else {
            throw Error.connectionNotAvailable
        }
        return try await connection.sendMessage(name: name)
    }

    func sendMessage(name: String, request: some Codable) async throws {
        guard let connection = connection else {
            throw Error.connectionNotAvailable
        }
        try await connection.sendMessage(name: name, request: request)
    }

    func setMessageHandler<Request: RuntimeRequest>(requestType: Request.Type = Request.self, handler: @escaping @Sendable (Request) async throws -> Request.Response) {
        listener.setMessageHandler(name: Request.identifier) { connection, request in
            try await handler(request)
        }
    }

    func setMessageHandler<Request, Response>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) where Request: Decodable, Request: Encodable, Response: Decodable, Response: Encodable {
        listener.setMessageHandler(name: name) { (_: XPCConnection, request: Request) in
            try await handler(request)
        }
    }

    func setMessageHandler(name: String, handler: @escaping @Sendable () async throws -> Void) {
        listener.setMessageHandler(name: name) { (_: XPCConnection) in
            try await handler()
        }
    }

    func setMessageHandler<Request>(name: String, handler: @escaping @Sendable (Request) async throws -> Void) where Request: Decodable, Request: Encodable {
        listener.setMessageHandler(name: name) { (_: XPCConnection, request: Request) in
            try await handler(request)
        }
    }

    func setMessageHandler<Response>(name: String, handler: @escaping @Sendable () async throws -> Response) where Response: Decodable, Response: Encodable {
        listener.setMessageHandler(name: name) { (_: XPCConnection) in
            try await handler()
        }
    }
}

private enum CommandIdentifiers {
    static let serverLaunched = command("ServerLaunched")

    static let clientConnected = command("ClientConnected")

    static func command(_ command: String) -> String { "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeXPCConnection.\(command)" }
}

// MARK: - RuntimeXPCClientConnection

/// XPC client connection for the main application side.
///
/// Use this when your application needs to communicate with a server process
/// (such as a Mac Catalyst helper) through the XPC Mach service broker.
///
/// ## Initialization Flow
///
/// 1. Connects to the XPC Mach service (privileged helper)
/// 2. Registers its anonymous listener endpoint
/// 3. Optionally requests the helper to launch the Catalyst helper
/// 4. Waits for the server to connect back via `serverLaunched` message
///
/// ## Usage
///
/// ```swift
/// let client = try await RuntimeXPCClientConnection(
///     identifier: .macCatalyst,
///     modifier: { connection in
///         // Configure connection before activation
///     }
/// )
///
/// // Send request to server
/// let response = try await client.sendMessage(request: GetRuntimeInfoRequest())
/// ```
final class RuntimeXPCClientConnection: RuntimeXPCConnection, @unchecked Sendable {
    override init(identifier: RuntimeSource.Identifier, modifier: ((RuntimeXPCConnection) async throws -> Void)? = nil) async throws {
        try await super.init(identifier: identifier, modifier: modifier)
        try await serviceConnection.sendMessage(request: RegisterEndpointRequest(identifier: identifier.rawValue, endpoint: listener.endpoint))

//        if identifier == .macCatalyst {
//            try await serviceConnection.sendMessage(request: LaunchCatalystHelperRequest(helperURL: RuntimeViewerCatalystHelperLauncher.helperURL))
//        }

        listener.setMessageHandler(name: CommandIdentifiers.serverLaunched) { [weak self] (_: XPCConnection, endpoint: SwiftyXPC.XPCEndpoint) in
            guard let self else { return }
            let connection = try XPCConnection(type: .remoteServiceFromEndpoint(endpoint))
            connection.activate()
            connection.errorHandler = { [weak self] in
                guard let self else { return }
                handleClientOrServerConnectionError(connection: $0, error: $1)
            }
            _ = try await connection.sendMessage(request: PingRequest())
            self.connection = connection
            self.stateSubject.send(.connected)
            #log(.info, "Ping server successfully")
        }
    }
}

// MARK: - RuntimeXPCServerConnection

/// XPC server connection for the service provider side.
///
/// Use this in a separate process (such as Mac Catalyst helper) that provides
/// runtime inspection services to the main application.
///
/// ## Initialization Flow
///
/// 1. Connects to the XPC Mach service (privileged helper)
/// 2. Fetches the client's endpoint from the broker
/// 3. Establishes direct connection to the client
/// 4. Registers its own endpoint for bidirectional communication
/// 5. Notifies the client via `serverLaunched` message
///
/// ## Usage
///
/// ```swift
/// let server = try await RuntimeXPCServerConnection(
///     identifier: .macCatalyst,
///     modifier: { connection in
///         // Register message handlers
///         connection.setMessageHandler(requestType: GetRuntimeInfoRequest.self) { request in
///             return GetRuntimeInfoResponse(info: ...)
///         }
///     }
/// )
/// ```
final class RuntimeXPCServerConnection: RuntimeXPCConnection, @unchecked Sendable {
    override init(identifier: RuntimeSource.Identifier, modifier: ((RuntimeXPCConnection) async throws -> Void)? = nil) async throws {
        try await super.init(identifier: identifier, modifier: modifier)
        let response = try await serviceConnection.sendMessage(request: FetchEndpointRequest(identifier: identifier.rawValue))
        let connection = try XPCConnection(type: .remoteServiceFromEndpoint(response.endpoint))
        connection.activate()
        connection.errorHandler = { [weak self] in
            guard let self else { return }
            handleClientOrServerConnectionError(connection: $0, error: $1)
        }
        try await serviceConnection.sendMessage(request: RegisterEndpointRequest(identifier: identifier.rawValue, endpoint: listener.endpoint))
        try await connection.sendMessage(name: CommandIdentifiers.serverLaunched, request: listener.endpoint)
        self.connection = connection
        stateSubject.send(.connected)
        #log(.info, "Ping client successfully")
    }
}

extension SwiftyXPC.XPCConnection {
    @discardableResult
    public func sendMessage<Request: RuntimeRequest>(request: Request) async throws -> Request.Response {
        try await sendMessage(name: type(of: request).identifier, request: request)
    }
}

extension SwiftyXPC.XPCListener {
    public func setMessageHandler<Request: RuntimeRequest>(requestType: Request.Type = Request.self, handler: @escaping (XPCConnection, Request) async throws -> Request.Response) {
        setMessageHandler(name: requestType.identifier) { (connection: XPCConnection, request: Request) -> Request.Response in
            try await handler(connection, request)
        }
    }
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Requests/FetchEndpointRequest.swift`:

```swift
#if os(macOS)

import Foundation
public import SwiftyXPC

public struct FetchEndpointRequest: Codable, RuntimeRequest {
    public static let identifier: String = "com.JH.RuntimeViewerService.FetchEndpoint"

    public struct Response: RuntimeResponse, Codable {
        public let endpoint: SwiftyXPC.XPCEndpoint

        public init(endpoint: SwiftyXPC.XPCEndpoint) {
            self.endpoint = endpoint
        }
    }

    public let identifier: String

    public init(identifier: String) {
        self.identifier = identifier
    }
}
#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Requests/FileOperationRequest.swift`:

```swift
#if os(macOS)

public import Foundation

public enum FileOperation: Codable {
    case createDirectory(url: URL, isIntermediateDirectories: Bool)
    case remove(url: URL)
    case move(from: URL, to: URL)
    case copy(from: URL, to: URL)
    case write(url: URL, data: Data)
}

public struct FileOperationRequest: Codable, RuntimeRequest {
    public typealias Response = VoidResponse

    public static let identifier = "com.JH.RuntimeViewerService.FileOperationRequest"

    public let operation: FileOperation

    public init(operation: FileOperation) {
        self.operation = operation
    }
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Requests/InjectApplicationRequest.swift`:

```swift
#if os(macOS)

public import Foundation

public struct InjectApplicationRequest: Codable, RuntimeRequest {
    public typealias Response = VoidResponse

    public static let identifier: String = "com.JH.RuntimeViewerService.InjectApplication"

    public let pid: pid_t

    public let dylibURL: URL

    public init(pid: pid_t, dylibURL: URL) {
        self.pid = pid
        self.dylibURL = dylibURL
    }
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Requests/OpenApplicationRequest.swift`:

```swift
#if os(macOS)

public import Foundation

public struct OpenApplicationRequest: Codable, RuntimeRequest {
    public static let identifier: String = "com.JH.RuntimeViewerService.OpenApplicationRequest"

    public typealias Response = VoidResponse

    public let url: URL

    public init(url: URL) {
        self.url = url
    }
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Requests/PingRequest.swift`:

```swift
#if os(macOS)

import Foundation
import Version

public struct PingRequest: Codable, RuntimeRequest {
    public typealias Response = VoidResponse

    public static let identifier: String = "com.JH.RuntimeViewerService.Ping"

    public init() {}
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/Requests/RegisterEndpointRequest.swift`:

```swift
#if os(macOS)

import Foundation
public import SwiftyXPC

public struct RegisterEndpointRequest: Codable, RuntimeRequest {
    public static let identifier: String = "com.JH.RuntimeViewerService.RegisterEndpoint"

    public typealias Response = VoidResponse

    public let identifier: String

    public let endpoint: SwiftyXPC.XPCEndpoint

    public init(identifier: String, endpoint: SwiftyXPC.XPCEndpoint) {
        self.identifier = identifier
        self.endpoint = endpoint
    }
}

#endif

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/RuntimeCommunicator.swift`:

```swift
import Foundation
public import FoundationToolbox

/// Factory for creating runtime connections based on the specified source.
///
/// `RuntimeCommunicator` abstracts the complexity of establishing connections
/// to different runtime sources, whether local, remote via XPC, Bonjour, or
/// local socket for code injection scenarios.
///
/// ## Usage
///
/// ```swift
/// let communicator = RuntimeCommunicator()
/// let connection = try await communicator.connect(to: .localSocketClient(
///     name: "Target App",
///     identifier: "com.example.target"
/// ))
/// ```
@Loggable
public final class RuntimeCommunicator {
    public init() {
        #log(.debug, "RuntimeCommunicator initialized")
    }

    /// Establishes a connection to the specified runtime source.
    ///
    /// - Parameters:
    ///   - source: The runtime source to connect to.
    ///   - modifier: Optional closure to configure the connection before use.
    /// - Returns: A configured `RuntimeConnection` ready for communication.
    /// - Throws: An error if the connection cannot be established.
    public func connect(to source: RuntimeSource, modifier: ((RuntimeConnection) async throws -> Void)? = nil) async throws -> RuntimeConnection {
        #log(.info, "Connecting to source: \(String(describing: source), privacy: .public)")
        switch source {
        case .local:
            #log(.error, "Local connection is not supported")
            throw NSError(domain: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeCommunicator", code: 1, userInfo: [NSLocalizedDescriptionKey: "Local connection is not supported"])

        case .remote(_, let identifier, let role):
            #if os(macOS)
            if role.isServer {
                #log(.debug, "Creating XPC server connection with identifier: \(String(describing: identifier), privacy: .public)")
                let connection = try await RuntimeXPCServerConnection(identifier: identifier, modifier: modifier)
                #log(.info, "XPC server connection established")
                return connection
            } else {
                #log(.debug, "Creating XPC client connection with identifier: \(String(describing: identifier), privacy: .public)")
                let connection = try await RuntimeXPCClientConnection(identifier: identifier, modifier: modifier)
                #log(.info, "XPC client connection established")
                return connection
            }
            #else
            #log(.error, "Remote connection is not supported on this platform")
            throw NSError(domain: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeCommunicator", code: 1, userInfo: [NSLocalizedDescriptionKey: "Remote connection is not supported on this platform"])
            #endif

        case .bonjourClient(let endpoint):
            #log(.debug, "Creating Bonjour client connection to endpoint: \(String(describing: endpoint), privacy: .public)")
            let runtimeConnection = try RuntimeNetworkClientConnection(endpoint: endpoint)
            try await modifier?(runtimeConnection)
            #log(.info, "Bonjour client connection established")
            return runtimeConnection

        case .bonjourServer(let name, _):
            #log(.debug, "Creating Bonjour server connection with name: \(name, privacy: .public)")
            let runtimeConnection = try await RuntimeNetworkServerConnection(name: name)
            try await modifier?(runtimeConnection)
            #log(.info, "Bonjour server connection established")
            return runtimeConnection

        case .localSocketClient(_, let identifier):
            // IMPORTANT: Role Inversion for Sandbox Compatibility
            //
            // Despite being the "business client" (sends queries, receives responses),
            // we use RuntimeLocalSocketServerConnection (socket server) here because:
            //
            // 1. This code runs in the main RuntimeViewer app, which has network permissions
            // 2. The counterpart (injected code) runs in sandboxed apps that cannot bind()
            // 3. Socket server requires bind() - only allowed in non-sandboxed apps
            // 4. Socket client only needs connect() - allowed even in sandboxed apps
            //
            // See RuntimeLocalSocketConnection documentation for detailed explanation.
            #log(.debug, "Creating local socket server connection (business client) with identifier: \(identifier.rawValue, privacy: .public)")
            let runtimeConnection = RuntimeLocalSocketServerConnection(identifier: identifier.rawValue)
            try await runtimeConnection.start()
            try await modifier?(runtimeConnection)
            #log(.info, "Local socket server connection established")
            return runtimeConnection

        case .localSocketServer(_, let identifier):
            // IMPORTANT: Role Inversion for Sandbox Compatibility
            //
            // Despite being the "business server" (handles queries, sends responses),
            // we use RuntimeLocalSocketClientConnection (socket client) here because:
            //
            // 1. This code runs inside the injected dylib in the target (sandboxed) app
            // 2. Sandboxed apps cannot call bind() - EPERM error
            // 3. Socket client only needs connect() - allowed in sandboxed apps
            //
            // See RuntimeLocalSocketConnection documentation for detailed explanation.
            #log(.debug, "Creating local socket client connection (business server) with identifier: \(identifier.rawValue, privacy: .public)")
            let runtimeConnection = try await RuntimeLocalSocketClientConnection(identifier: identifier.rawValue)
            try await modifier?(runtimeConnection)
            #log(.info, "Local socket client connection established")
            return runtimeConnection

        case .directTCPClient(_, let host, let port):
            #if canImport(Network)
            // Direct TCP connection to a known host:port.
            // Doesn't require NSBonjourServices or NSLocalNetworkUsageDescription.
            #log(.debug, "Creating direct TCP client connection to \(host, privacy: .public):\(port, privacy: .public)")
            let runtimeConnection = try await RuntimeDirectTCPClientConnection(host: host, port: port)
            try await modifier?(runtimeConnection)
            #log(.info, "Direct TCP client connection established")
            return runtimeConnection
            #else
            #log(.error, "Direct TCP connection is not supported on this platform")
            throw NSError(domain: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeCommunicator", code: 1, userInfo: [NSLocalizedDescriptionKey: "Direct TCP connection is not supported on this platform"])
            #endif

        case .directTCPServer(_, let port):
            #if canImport(Network)
            // Direct TCP server listening on a port.
            // After initialization, server.host and server.port contain the actual address.
            #log(.debug, "Creating direct TCP server connection on port: \(port, privacy: .public)")
            let runtimeConnection = try await RuntimeDirectTCPServerConnection(port: port)
            try await modifier?(runtimeConnection)
            #log(.info, "Direct TCP server connection established")
            return runtimeConnection
            #else
            #log(.error, "Direct TCP connection is not supported on this platform")
            throw NSError(domain: "com.RuntimeViewer.RuntimeViewerCommunication.RuntimeCommunicator", code: 1, userInfo: [NSLocalizedDescriptionKey: "Direct TCP connection is not supported on this platform"])
            #endif
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/RuntimeConnection.swift`:

```swift
import Foundation
public import Combine

/// Protocol defining the unified interface for all runtime communication channels.
///
/// `RuntimeConnection` provides a consistent API for bidirectional message passing
/// regardless of the underlying transport mechanism (XPC, Network, TCP socket, or stdio).
///
/// ## Implementations
///
/// | Implementation | Transport | Use Case |
/// |----------------|-----------|----------|
/// | `RuntimeXPCConnection` | XPC Mach Service | Cross-process on macOS (requires privileged helper) |
/// | `RuntimeNetworkConnection` | Bonjour/TCP | iOS device to Mac via local network |
/// | `RuntimeLocalSocketConnection` | TCP localhost | Code injection into sandboxed apps |
/// | `RuntimeStdioConnection` | stdin/stdout | CLI tools, language servers |
///
/// ## Message Patterns
///
/// The protocol supports several messaging patterns:
///
/// ```swift
/// // Fire-and-forget (no response expected)
/// try await connection.sendMessage(name: "log", request: LogEntry(message: "Hello"))
///
/// // Request-response with typed request
/// let response = try await connection.sendMessage(request: GetClassListRequest())
///
/// // Request-response by name
/// let count: Int = try await connection.sendMessage(name: "getCount")
/// ```
///
/// ## Handler Registration
///
/// Register handlers to process incoming messages:
///
/// ```swift
/// // Typed request handler
/// connection.setMessageHandler(requestType: GetClassListRequest.self) { request in
///     return GetClassListResponse(classes: [...])
/// }
///
/// // Named handler with request and response
/// connection.setMessageHandler(name: "echo") { (input: String) -> String in
///     return "Echo: \(input)"
/// }
/// ```
public protocol RuntimeConnection: Sendable {
    /// Publisher that emits connection state changes.
    ///
    /// Subscribe to this publisher to observe connection lifecycle events.
    var statePublisher: AnyPublisher<RuntimeConnectionState, Never> { get }

    /// The current connection state.
    var state: RuntimeConnectionState { get }

    /// Stops the connection and releases resources.
    ///
    /// After calling this method, the connection will emit `.disconnected` state
    /// and should not be used for sending or receiving messages.
    func stop()

    /// Sends a message with no payload and no expected response.
    /// - Parameter name: The message identifier.
    func sendMessage(name: String) async throws

    /// Sends a message with a payload but no expected response.
    /// - Parameters:
    ///   - name: The message identifier.
    ///   - request: The request payload to send.
    func sendMessage<Request: Codable>(name: String, request: Request) async throws

    /// Sends a message and waits for a response.
    /// - Parameter name: The message identifier.
    /// - Returns: The decoded response.
    func sendMessage<Response: Codable>(name: String) async throws -> Response

    /// Sends a typed request and waits for its associated response.
    /// - Parameter request: The request conforming to `RuntimeRequest`.
    /// - Returns: The response type defined by the request.
    func sendMessage<Request: RuntimeRequest>(request: Request) async throws -> Request.Response

    /// Sends a message with a payload and waits for a response.
    /// - Parameters:
    ///   - name: The message identifier.
    ///   - request: The request payload to send.
    /// - Returns: The decoded response.
    func sendMessage<Response: Codable>(name: String, request: some Codable) async throws -> Response

    /// Registers a handler for messages with no payload and no response.
    /// - Parameters:
    ///   - name: The message identifier to handle.
    ///   - handler: The async closure to execute when the message is received.
    func setMessageHandler(name: String, handler: @escaping @Sendable () async throws -> Void)

    /// Registers a handler for messages with a payload but no response.
    /// - Parameters:
    ///   - name: The message identifier to handle.
    ///   - handler: The async closure receiving the decoded request.
    func setMessageHandler<Request: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Void)

    /// Registers a handler for messages with no payload but expecting a response.
    /// - Parameters:
    ///   - name: The message identifier to handle.
    ///   - handler: The async closure returning the response.
    func setMessageHandler<Response: Codable>(name: String, handler: @escaping @Sendable () async throws -> Response)

    /// Registers a handler for typed requests with associated responses.
    /// - Parameters:
    ///   - requestType: The request type to handle.
    ///   - handler: The async closure processing the request and returning the response.
    func setMessageHandler<Request: RuntimeRequest>(requestType: Request.Type, handler: @escaping @Sendable (Request) async throws -> Request.Response)

    /// Registers a handler for messages with both request payload and response.
    /// - Parameters:
    ///   - name: The message identifier to handle.
    ///   - handler: The async closure receiving the request and returning the response.
    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response)
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/RuntimeConnectionState.swift`:

```swift
public import Foundation

// MARK: - RuntimeConnectionState

/// Represents the current state of a connection.
///
/// This enum provides a unified way to track connection lifecycle across
/// all connection types (XPC, Network, LocalSocket, Stdio, DirectTCP).
public enum RuntimeConnectionState: Sendable, Equatable {
    /// The connection is being established.
    case connecting

    /// The connection is established and ready to send/receive messages.
    case connected

    /// The connection has been terminated, either normally or due to an error.
    case disconnected(error: RuntimeConnectionError?)

    /// Returns `true` if the connection is currently connected and ready.
    public var isConnected: Bool {
        if case .connected = self { return true }
        return false
    }

    /// Returns `true` if the connection is in the process of connecting.
    public var isConnecting: Bool {
        if case .connecting = self { return true }
        return false
    }

    /// Returns `true` if the connection has been disconnected.
    public var isDisconnected: Bool {
        if case .disconnected = self { return true }
        return false
    }
}

// MARK: - RuntimeConnectionError

/// Errors that can occur during connection operations.
///
/// This provides a unified error type that can represent errors from
/// any underlying transport (socket, network, XPC, etc.).
public enum RuntimeConnectionError: Error, Sendable, Equatable, LocalizedError {
    /// An error occurred in the local socket connection.
    case socketError(String)

    /// An error occurred in the network connection (NWConnection).
    case networkError(String)

    /// An error occurred in the XPC connection.
    case xpcError(String)

    /// The connection timed out while waiting.
    case timeout

    /// The remote peer closed the connection.
    case peerClosed

    /// An unknown or unexpected error occurred.
    case unknown(String)

    case notConnected
    
    public var errorDescription: String? {
        switch self {
        case .socketError(let message):
            return "Socket error: \(message)"
        case .networkError(let message):
            return "Network error: \(message)"
        case .xpcError(let message):
            return "XPC error: \(message)"
        case .timeout:
            return "Connection timed out"
        case .peerClosed:
            return "Connection closed by peer"
        case .unknown(let message):
            return "Unknown error: \(message)"
        case .notConnected:
            return "Not connected"
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/RuntimeMessageChannel.swift`:

```swift
import Foundation
import FoundationToolbox
import Semaphore
import Asynchrone

// MARK: - RuntimeMessageHandler

/// Encapsulates a message handler that processes requests and returns responses.
///
/// This class handles the JSON encoding/decoding of requests and responses,
/// allowing handlers to work with typed Swift objects.
///
/// - Note: Uses `@unchecked Sendable` because the stored metatypes (`requestType`, `responseType`)
///   are immutable and inherently thread-safe, but `any Codable.Type` doesn't conform to `Sendable`.
final class RuntimeMessageHandler: @unchecked Sendable {
    typealias RawHandler = @Sendable (Data) async throws -> Data

    /// The wrapped handler that processes raw Data.
    let closure: RawHandler

    /// The type of the request this handler expects.
    let requestType: any Codable.Type

    /// The type of the response this handler returns.
    let responseType: any Codable.Type

    /// Creates a message handler with typed request and response.
    ///
    /// - Parameter closure: The handler closure that receives a typed request
    ///   and returns a typed response.
    init<Request: Codable, Response: Codable>(closure: @escaping @Sendable (Request) async throws -> Response) {
        self.requestType = Request.self
        self.responseType = Response.self

        self.closure = { request in
            let request = try JSONDecoder().decode(Request.self, from: request)
            let response = try await closure(request)
            return try JSONEncoder().encode(response)
        }
    }
}

// MARK: - RuntimeMessageNull

/// A null message type used when no payload is needed.
struct RuntimeMessageNull: Codable, Sendable {
    static let null = RuntimeMessageNull()
}

// MARK: - RuntimeMessageProtocol

/// Protocol defining the message framing and processing logic.
///
/// Implementations handle the low-level details of reading/writing data,
/// while the protocol provides the common message framing logic.
protocol RuntimeMessageProtocol: Sendable {
    /// The end marker used to delimit messages.
    static var endMarkerData: Data { get }
}

extension RuntimeMessageProtocol {
    /// Default end marker: `\nOK`
    static var endMarkerData: Data {
        "\nOK".data(using: .utf8)!
    }
}

// MARK: - RuntimeMessageChannel

/// A bidirectional message channel that handles framing, encoding, and dispatching.
///
/// `RuntimeMessageChannel` provides the common infrastructure for message-based
/// communication, including:
/// - Message framing with `\nOK` delimiter
/// - JSON encoding/decoding of requests and responses
/// - Async message handler registration and dispatch
/// - Thread-safe send/receive with semaphore
///
/// ## Usage
///
/// ```swift
/// let channel = RuntimeMessageChannel()
///
/// // Register handlers
/// channel.setMessageHandler(name: "echo") { (input: String) -> String in
///     return "Echo: \(input)"
/// }
///
/// // Process incoming data
/// channel.appendReceivedData(data)
///
/// // Send messages
/// try await channel.send(data: encodedMessage, writer: { data in
///     // Write data to underlying transport
/// })
/// ```
@Loggable
final class RuntimeMessageChannel: @unchecked Sendable, RuntimeMessageProtocol {
    /// Unique identifier for this channel.
    let id = UUID()

    /// Called when a complete message is received.
    /// - Note: This callback is called from a locked context; avoid long-running operations.
    var onMessageReceived: (@Sendable (Data) -> Void)?

    /// Message handlers keyed by message identifier.
    private let messageHandlers = Mutex<[String: RuntimeMessageHandler]>([:])

    /// Pending request continuations keyed by request identifier.
    private let pendingRequests = Mutex<[String: CheckedContinuation<Data, Error>]>([:])

    /// Buffer for incoming data.
    private let receivingData = Mutex<Data>(Data())

    /// Stream for received messages.
    private var receivedDataStream: SharedAsyncSequence<AsyncThrowingStream<Data, Error>>?

    /// Continuation for yielding received messages.
    private var receivedDataContinuation: AsyncThrowingStream<Data, Error>.Continuation?

    /// Semaphore for serializing send operations.
    private let sendSemaphore = AsyncSemaphore(value: 1)

    init() {
        setupStreams()
        #log(.debug, "RuntimeMessageChannel initialized with id: \(self.id, privacy: .public)")
    }

    // MARK: - Stream Setup

    private func setupStreams() {
        let (stream, continuation) = AsyncThrowingStream<Data, Error>.makeStream()
        self.receivedDataStream = stream.shared()
        self.receivedDataContinuation = continuation
    }

    // MARK: - Handler Registration

    /// Registers a handler for messages with no payload and no response.
    func setMessageHandler(name: String, handler: @escaping @Sendable () async throws -> Void) {
        setMessageHandler(name: name) { @Sendable (_: RuntimeMessageNull) in
            try await handler()
            return RuntimeMessageNull.null
        }
    }

    /// Registers a handler for messages with a payload but no response.
    func setMessageHandler<Request: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Void) {
        setMessageHandler(name: name) { @Sendable (request: Request) in
            try await handler(request)
            return RuntimeMessageNull.null
        }
    }

    /// Registers a handler for messages with no payload but expecting a response.
    func setMessageHandler<Response: Codable>(name: String, handler: @escaping @Sendable () async throws -> Response) {
        setMessageHandler(name: name) { @Sendable (_: RuntimeMessageNull) in
            return try await handler()
        }
    }

    /// Registers a handler for messages with both request payload and response.
    func setMessageHandler<Request: Codable, Response: Codable>(name: String, handler: @escaping @Sendable (Request) async throws -> Response) {
        messageHandlers.withLock { $0[name] = RuntimeMessageHandler(closure: handler) }
        #log(.debug, "Registered message handler for: \(name, privacy: .public)")
    }

    /// Registers a handler for typed requests with associated responses.
    func setMessageHandler<Request: RuntimeRequest>(_ handler: @escaping @Sendable (Request) async throws -> Request.Response) {
        setMessageHandler(name: Request.identifier, handler: handler)
    }

    /// Returns the handler for the given message identifier.
    func handler(for identifier: String) -> RuntimeMessageHandler? {
        messageHandlers.withLock { $0[identifier] }
    }

    /// Checks if there's a pending request waiting for a response with the given identifier.
    /// If found, delivers the data to the pending request and returns true.
    /// - Parameters:
    ///   - identifier: The request identifier to check.
    ///   - data: The response data to deliver.
    /// - Returns: `true` if the data was delivered to a pending request, `false` otherwise.
    func deliverToPendingRequest(identifier: String, data: Data) -> Bool {
        guard let continuation = pendingRequests.withLock({ $0.removeValue(forKey: identifier) }) else {
            return false
        }
        #log(.debug, "Delivered response to pending request: \(identifier, privacy: .public)")
        continuation.resume(returning: data)
        return true
    }

    // MARK: - Receiving Data

    /// Appends data to the receiving buffer and processes complete messages.
    func appendReceivedData(_ data: Data) {
        receivingData.withLock { $0.append(data) }
        processReceivedData()
    }

    /// Processes the receiving buffer and extracts complete messages.
    private func processReceivedData() {
        receivingData.withLock { buffer in
            while true {
                guard let endRange = buffer.range(of: Self.endMarkerData) else {
                    break
                }

                let messageData = buffer.subdata(in: 0 ..< endRange.lowerBound)
                receivedDataContinuation?.yield(messageData)
                onMessageReceived?(messageData)

                if endRange.upperBound < buffer.count {
                    buffer = buffer.subdata(in: endRange.upperBound ..< buffer.count)
                } else {
                    buffer = Data()
                    break
                }
            }
        }
    }

    /// Finishes the received data stream.
    func finishReceiving(throwing error: (any Error)? = nil) {
        if let error {
            #log(.default, "Finishing receiving with error: \(String(describing: error), privacy: .public)")
            receivedDataContinuation?.finish(throwing: error)
        } else {
            #log(.debug, "Finishing receiving stream normally")
            receivedDataContinuation?.finish()
        }
    }

    /// Returns the current size of the receiving buffer.
    var receivingBufferSize: Int {
        receivingData.withLock { $0.count }
    }

    // MARK: - Sending Data

    /// Sends data using the provided writer closure.
    ///
    /// This method serializes send operations using a semaphore to prevent
    /// interleaving of messages.
    func send(data: Data, writer: @Sendable (Data) async throws -> Void) async throws {
        await sendSemaphore.wait()
        defer { sendSemaphore.signal() }

        let dataToSend = data + Self.endMarkerData
        #log(.debug, "Sending \(dataToSend.count, privacy: .public) bytes")
        try await writer(dataToSend)
    }

    /// Sends a request and waits for a response.
    func sendRequest<Response: Codable>(
        requestData: RuntimeRequestData,
        writer: @escaping @Sendable (Data) async throws -> Void
    ) async throws -> Response {
        await sendSemaphore.wait()

        #log(.debug, "Sending request: \(requestData.identifier, privacy: .public)")
        let data = try JSONEncoder().encode(requestData)
        let dataToSend = data + Self.endMarkerData

        // Register pending request before sending
        let responseData: Data = try await withCheckedThrowingContinuation { continuation in
            pendingRequests.withLock { $0[requestData.identifier] = continuation }

            Task {
                do {
                    try await writer(dataToSend)
                } catch {
                    // Remove pending request and resume with error
                    _ = self.pendingRequests.withLock { $0.removeValue(forKey: requestData.identifier) }
                    #log(.error, "Failed to send request \(requestData.identifier, privacy: .public): \(String(describing: error), privacy: .public)")
                    continuation.resume(throwing: error)
                }
            }
        }

        sendSemaphore.signal()

        #log(.debug, "Received response for: \(requestData.identifier, privacy: .public)")
        let response = try JSONDecoder().decode(RuntimeRequestData.self, from: responseData)
        return try JSONDecoder().decode(Response.self, from: response.data)
    }

    /// Sends a request with no expected response.
    func sendRequest(
        requestData: RuntimeRequestData,
        writer: @Sendable (Data) async throws -> Void
    ) async throws {
        await sendSemaphore.wait()
        defer { sendSemaphore.signal() }

        #log(.debug, "Sending fire-and-forget request: \(requestData.identifier, privacy: .public)")
        let data = try JSONEncoder().encode(requestData)
        let dataToSend = data + Self.endMarkerData
        try await writer(dataToSend)
    }

    /// Waits for and returns the next received message.
    func receiveData() async throws -> Data {
        guard let receivedDataStream else {
            #log(.error, "Attempted to receive data but channel is not connected")
            throw RuntimeMessageChannelError.notConnected
        }

        for try await data in receivedDataStream {
            if let error = try? JSONDecoder().decode(RuntimeNetworkRequestError.self, from: data) {
                #log(.default, "Received error response: \(String(describing: error), privacy: .public)")
                throw error
            } else {
                #log(.debug, "Received \(data.count, privacy: .public) bytes")
                return data
            }
        }

        #log(.error, "Receive failed - stream ended unexpectedly")
        throw RuntimeMessageChannelError.receiveFailed
    }

    /// Returns an async sequence of received messages.
    func receivedMessages() -> SharedAsyncSequence<AsyncThrowingStream<Data, Error>>? {
        receivedDataStream
    }
}

// MARK: - RuntimeMessageChannelError

/// Errors that can occur during message channel operations.
enum RuntimeMessageChannelError: Error, LocalizedError, Sendable {
    case notConnected
    case receiveFailed

    var errorDescription: String? {
        switch self {
        case .notConnected:
            return "Message channel is not connected"
        case .receiveFailed:
            return "Failed to receive message"
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/RuntimeNetwork.swift`:

```swift
import Foundation
public import FoundationToolbox
import Network

public enum RuntimeNetworkError: Error {
    case notConnected
    case invalidPort
    case receiveFailed
}

public struct RuntimeNetworkRequestError: Error, Codable {
    public let message: String
}

struct RuntimeRequestData: Codable {
    let identifier: String

    let data: Data

    init(identifier: String, data: Data) {
        self.identifier = identifier
        self.data = data
    }

    init<Value: Codable>(identifier: String, value: Value) throws {
        self.identifier = identifier
        self.data = try JSONEncoder().encode(value)
    }

    init<Request: RuntimeRequest>(request: Request) throws {
        self.identifier = Request.identifier
        self.data = try JSONEncoder().encode(request)
    }
}

public enum RuntimeNetworkBonjour {
    public static let type = "_runtimeviewer._tcp"
}

public struct RuntimeNetworkEndpoint: Sendable, Codable, Hashable {
    public let name: String
    
    let endpoint: NWEndpoint
    
    init(name: String, endpoint: NWEndpoint) {
        self.name = name
        self.endpoint = endpoint
    }
    
    private enum CodableError: Error {
        case unsupported
    }
    
    public init(from decoder: any Decoder) throws {
        throw CodableError.unsupported
    }
    
    public func encode(to encoder: any Encoder) throws {
        throw CodableError.unsupported
    }
}

@Loggable
public class RuntimeNetworkBrowser {
    private let browser: NWBrowser

    public init() {
        let parameters = NWParameters()
        parameters.includePeerToPeer = true

        self.browser = NWBrowser(for: .bonjour(type: RuntimeNetworkBonjour.type, domain: nil), using: parameters)
    }

    public func start(handler: @escaping (RuntimeNetworkEndpoint) -> Void) {
        browser.stateUpdateHandler = { newState in
            #log(.info, "browser.stateUpdateHandler \(String(describing: newState), privacy: .public)")
        }
        browser.browseResultsChangedHandler = { results, changes in
            for result in results {
                switch result.endpoint {
                case .service(let name, _, _, _):
                    handler(.init(name: name, endpoint: result.endpoint))
                default:
                    break
                }
            }
        }
        browser.start(queue: .main)
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/RuntimeRequestResponse.swift`:

```swift
import Foundation
import OSLog

public let RuntimeViewerMachServiceName = "com.mxiris.runtimeviewer.service"

public protocol RuntimeRequest: Codable {
    associatedtype Response: RuntimeResponse

    static var identifier: String { get }
}

public protocol RuntimeResponse: Codable {}

public struct VoidResponse: RuntimeResponse, Codable {
    public init() {}

    public static let empty: VoidResponse = .init()
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCommunication/RuntimeSource.swift`:

```swift
import Foundation

extension RuntimeSource {
    /// The business role in the communication.
    ///
    /// - Note: This represents the **business role**, not the socket role.
    ///   For local socket connections, socket roles are inverted due to sandbox restrictions.
    ///   See `RuntimeLocalSocketConnection` documentation for details.
    public enum Role: Sendable, Codable, Equatable {
        /// The client role: sends requests and receives responses.
        case client
        /// The server role: receives requests and sends responses.
        case server

        public var isClient: Bool { self == .client }
        public var isServer: Bool { self == .server }
    }

    /// A unique identifier for a runtime connection endpoint.
    public struct Identifier: Sendable, Codable, RawRepresentable, ExpressibleByStringLiteral, Hashable {
        public let rawValue: String

        public init(rawValue: String) {
            self.rawValue = rawValue
        }

        public init(stringLiteral value: StringLiteralType) {
            self.init(rawValue: value)
        }
    }
}

/// Represents different sources for runtime inspection.
///
/// `RuntimeSource` defines the various ways to connect to a runtime environment
/// for inspection, whether it's local, remote via XPC, over the network via Bonjour,
/// or through local socket for code injection scenarios.
///
/// ## Source Types
///
/// | Source | Description | Use Case |
/// |--------|-------------|----------|
/// | `local` | Direct local access | Same process inspection |
/// | `remote` | XPC-based connection | Cross-process on same machine |
/// | `bonjourClient/Server` | Network discovery | iOS device to Mac |
/// | `localSocketClient/Server` | TCP localhost | Code injection into sandboxed apps |
///
/// ## Local Socket: Business Role vs Socket Role
///
/// For `localSocketClient` and `localSocketServer`, the naming refers to the
/// **business role** (who sends queries vs who handles them), NOT the socket role:
///
/// | Source | Business Role | Socket Role | Used By |
/// |--------|---------------|-------------|---------|
/// | `localSocketClient` | Client (queries) | **Server** (bind/listen) | Main app |
/// | `localSocketServer` | Server (handles) | **Client** (connect) | Injected code |
///
/// This inversion is necessary because sandboxed apps cannot call `bind()`.
/// See `RuntimeLocalSocketConnection` documentation for detailed explanation.
public enum RuntimeSource: Sendable, CustomStringConvertible, Codable, Hashable {
    /// Local runtime inspection (same process).
    case local

    /// Remote runtime via XPC Mach service.
    ///
    /// - Parameters:
    ///   - name: Display name for the connection.
    ///   - identifier: XPC service identifier.
    ///   - role: Whether this endpoint is client or server.
    case remote(name: String, identifier: Identifier, role: Role)

    /// Network client connecting via Bonjour-discovered endpoint.
    ///
    /// - Parameter endpoint: The discovered network endpoint to connect to.
    case bonjourClient(endpoint: RuntimeNetworkEndpoint)

    /// Network server advertising via Bonjour.
    ///
    /// - Parameters:
    ///   - name: The service name to advertise.
    ///   - identifier: Unique identifier for this server.
    case bonjourServer(name: String, identifier: Identifier)

    /// Local socket business client (main app side).
    ///
    /// Despite the name "client", this uses a **socket server** internally
    /// because the main app has network permissions to call `bind()`.
    /// The injected code (business server) connects to this socket server.
    ///
    /// - Parameters:
    ///   - name: Display name for the target process.
    ///   - identifier: Shared identifier for port calculation.
    case localSocketClient(name: String, identifier: Identifier)

    /// Local socket business server (injected code side).
    ///
    /// Despite the name "server", this uses a **socket client** internally
    /// because injected code runs in sandboxed apps that cannot call `bind()`.
    /// This connects to the socket server created by the main app.
    ///
    /// - Parameters:
    ///   - name: Display name for this service.
    ///   - identifier: Shared identifier for port calculation.
    case localSocketServer(name: String, identifier: Identifier)

    /// Direct TCP client connecting to a known host and port.
    ///
    /// Unlike Bonjour connections, this doesn't require `NSBonjourServices` or
    /// `NSLocalNetworkUsageDescription` - just the server's IP address and port.
    /// The host:port can be obtained via:
    /// - User input
    /// - QR code scan
    /// - Configuration file
    ///
    /// - Parameters:
    ///   - name: Display name for the connection.
    ///   - host: The hostname or IP address of the server.
    ///   - port: The port number the server is listening on.
    case directTCPClient(name: String, host: String, port: UInt16)

    /// Direct TCP server listening on a specified port.
    ///
    /// Creates a server that listens on the specified port. Use port 0 to let
    /// the system assign an available port automatically. After initialization,
    /// the actual host:port can be displayed to the user or encoded as a QR code.
    ///
    /// - Parameters:
    ///   - name: Display name for this server.
    ///   - port: The port to listen on (0 for auto-assign).
    case directTCPServer(name: String, port: UInt16)

    public var description: String {
        switch self {
        case .local: return "My Mac"
        case .remote(let name, _, _): return name
        case .bonjourClient(let endpoint): return endpoint.name
        case .bonjourServer(let name, _): return name
        case .localSocketClient(let name, _): return name
        case .localSocketServer(let name, _): return name
        case .directTCPClient(let name, _, _): return name
        case .directTCPServer(let name, _): return name
        }
    }

    public var isRemote: Bool {
        switch self {
        case .local: return false
        default: return true
        }
    }

    public var remoteRole: Role? {
        switch self {
        case .remote(_, _, let role): return role
        case .bonjourClient,
             .localSocketClient,
             .directTCPClient: return .client
        case .bonjourServer,
             .localSocketServer,
             .directTCPServer: return .server
        default: return nil
        }
    }

    /// Returns `true` if this source uses XPC for communication.
    /// XPC connections cannot be reconnected due to SwiftyXPC limitations,
    /// they must be destroyed and recreated instead.
    public var isXPC: Bool {
        switch self {
        case .remote: return true
        default: return false
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeBookmark.swift`:

```swift
import Foundation
import MemberwiseInit
public import RuntimeViewerCommunication

@MemberwiseInit(.public)
public struct RuntimeImageBookmark: Codable {
    public let source: RuntimeSource
    public let imageNode: RuntimeImageNode
}


@MemberwiseInit(.public)
public struct RuntimeObjectBookmark: Codable {
    public let source: RuntimeSource
    public let object: RuntimeObject
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeImageLoadState.swift`:

```swift
import Foundation

public enum RuntimeImageLoadState {
    case notLoaded
    case loading
    case loaded
    case loadError(Error)
    case unknown
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeImageNode.swift`:

```swift
import Foundation

public final class RuntimeImageNode: Codable {
    private enum CodingKeys: CodingKey {
        case name
        case children
        case absolutePath
    }

    public let name: String

    public weak var parent: RuntimeImageNode?

    public var children: [RuntimeImageNode] = []

    public lazy var absolutePath: String = {
        guard let parent else { return "/" + name }
        let directory = parent.absolutePath
        return directory + "/" + name
    }()

    public init(_ name: String, parent: RuntimeImageNode? = nil) {
        self.parent = parent
        self.name = name
    }

    public var path: String { absolutePath.removeFirstPathComponent() }

    public var isLeaf: Bool { children.isEmpty }

    public func child(named name: String) -> RuntimeImageNode {
        if let existing = children.first(where: { $0.name == name }) {
            return existing
        }
        let child = RuntimeImageNode(name, parent: self)
        children.append(child)
        return child
    }

    public static func rootNode(for imagePaths: [String], name: String = "") -> RuntimeImageNode {
        let root = RuntimeImageNode(name)
        for path in imagePaths {
            var current = root
            for pathComponent in path.split(separator: "/") {
                switch pathComponent {
                case ".":
                    break // current
                case "..":
                    if let parent = current.parent {
                        current = parent
                    }
                default:
                    current = current.child(named: String(pathComponent))
                }
            }
        }
        return root
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(children, forKey: .children)
        try container.encode(absolutePath, forKey: .absolutePath)
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decode(String.self, forKey: .name)
        self.children = try container.decode([RuntimeImageNode].self, forKey: .children)
        self.absolutePath = try container.decode(String.self, forKey: .absolutePath)

        for child in children {
            child.parent = self
        }
    }
}

extension RuntimeImageNode: Hashable {
    public static func == (lhs: RuntimeImageNode, rhs: RuntimeImageNode) -> Bool {
        lhs.name == rhs.name && lhs.children == rhs.children && lhs.absolutePath == rhs.absolutePath
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(children)
        hasher.combine(absolutePath)
    }
}

extension String {
    func removeFirstPathComponent() -> String {
        let isAbsolute = hasPrefix("/")
        var components = split(separator: "/", omittingEmptySubsequences: true)

        guard !components.isEmpty else {
            return isAbsolute ? "/" : ""
        }

        components.removeFirst()

        if components.isEmpty {
            return isAbsolute ? "/" : ""
        }

        return isAbsolute ? "/" + components.joined(separator: "/") : components.joined(separator: "/")
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeObject+Export.swift`:

```swift
import Foundation

extension RuntimeObject {
    public var exportFileName: String {
        let sanitized = displayName
            .replacingOccurrences(of: "/", with: "_")
            .replacingOccurrences(of: ":", with: "_")
        switch kind {
        case .swift:
            return "\(sanitized).swiftinterface"
        case .objc, .c:
            return "\(sanitized).h"
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeObject.swift`:

```swift
import MemberwiseInit
public import SwiftStdlibToolbox

@Equatable
@MemberwiseInit(.public)
public struct RuntimeObject: Codable, Hashable, Identifiable, Sendable {
    public let name: String

    public let displayName: String
    
    public let kind: RuntimeObjectKind

    public let secondaryKind: RuntimeObjectKind?
    
    public let imagePath: String

    public let children: [RuntimeObject]
    
    public var id: RuntimeObject { self }

    public var imageName: String { imagePath.lastPathComponent.deletingPathExtension }
    
    public func withImagePath(_ imagePath: String) -> RuntimeObject {
        .init(name: name, displayName: displayName, kind: kind, secondaryKind: secondaryKind, imagePath: imagePath, children: children)
    }
}

extension RuntimeObject: ComparableBuildable {
    public static let comparableDefinition = makeComparable {
        compare(\.imagePath)
        compare(\.kind)
        compare(\.displayName)
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeObjectInterface+GenerationOptions.swift`:

```swift
import Foundation
import MetaCodable

extension RuntimeObjectInterface {
    @Codable
    public struct GenerationOptions: Sendable {
        @Default(ifMissing: ObjCGenerationOptions())
        public var objcHeaderOptions: ObjCGenerationOptions

        @Default(ifMissing: SwiftGenerationOptions())
        public var swiftInterfaceOptions: SwiftGenerationOptions

        @Default(ifMissing: Transformer.Configuration())
        public var transformer: Transformer.Configuration

        public init() {
            self.objcHeaderOptions = .init()
            self.swiftInterfaceOptions = .init()
            self.transformer = .init()
        }

        public init(
            objcHeaderOptions: ObjCGenerationOptions,
            swiftInterfaceOptions: SwiftGenerationOptions,
            transformer: Transformer.Configuration = .init()
        ) {
            self.objcHeaderOptions = objcHeaderOptions
            self.swiftInterfaceOptions = swiftInterfaceOptions
            self.transformer = transformer
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeObjectInterface.swift`:

```swift
import Foundation
public import Semantic

public struct RuntimeObjectInterface: Codable, Sendable {
    public let object: RuntimeObject
    
    public let interfaceString: SemanticString
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeObjectKind.swift`:

```swift
import SwiftStdlibToolbox

//@AssociatedValue(.public)
//@CaseCheckable(.public)
public enum RuntimeObjectKind: Codable, Hashable, Identifiable, Comparable, CaseIterable, CustomStringConvertible, Sendable {
    public enum C: Codable, Hashable, Identifiable, CaseIterable, Sendable {
        case `struct`
        case `union`
        
        public var id: Self { self }
    }
//    @AssociatedValue(.public)
//    @CaseCheckable(.public)
    public enum ObjectiveC: Codable, Hashable, Identifiable, CaseIterable, Sendable {
        public enum Kind: Codable, Hashable, Identifiable, CaseIterable, Sendable {
            case `class`
            case `protocol`
            public var id: Self { self }
        }

        case type(Kind)
        case category(Kind)
        
        public var id: Self { self }
        
        public static let allCases: [RuntimeObjectKind.ObjectiveC] = Kind.allCases.map { .type($0) } + Kind.allCases.map { .category($0) }
    }
//    @AssociatedValue(.public)
//    @CaseCheckable(.public)
    public enum Swift: Codable, Hashable, Identifiable, CaseIterable, Sendable {
        public enum Kind: Codable, Hashable, Identifiable, CaseIterable, Sendable {
            case `enum`
            case `struct`
            case `class`
            case `protocol`
            case `typeAlias`
            public var id: Self { self }
        }

        case type(Kind)
        case `extension`(Kind)
        case conformance(Kind)
        
        public var id: Self { self }
        
        public static let allCases: [RuntimeObjectKind.Swift] = Kind.allCases.map { .type($0) } + Kind.allCases.map { .extension($0) } + Kind.allCases.map { .conformance($0) }
    }

    case c(C)
    case objc(ObjectiveC)
    case swift(Swift)

    public var id: Self { self }

    private var level: Int {
        switch self {
        case .c(let c):
            switch c {
            case .struct:
                0
            case .union:
                1
            }
        case .objc(let objectiveC):
            switch objectiveC {
            case .type(let kind):
                switch kind {
                case .class:
                    2
                case .protocol:
                    3
                }
            case .category(let kind):
                switch kind {
                case .class:
                    4
                case .protocol:
                    5
                }
            }
        case .swift(let swift):
            switch swift {
            case .type(let kind):
                switch kind {
                case .enum:
                    6
                case .struct:
                    7
                case .class:
                    8
                case .protocol:
                    9
                case .typeAlias:
                    10
                }
            case .extension(let kind):
                switch kind {
                case .enum:
                    11
                case .struct:
                    12
                case .class:
                    13
                case .protocol:
                    14
                case .typeAlias:
                    15
                }
            case .conformance(let kind):
                switch kind {
                case .enum:
                    16
                case .struct:
                    17
                case .class:
                    18
                case .protocol:
                    19
                case .typeAlias:
                    20
                }
            }
        }
    }

    public static func < (lhs: RuntimeObjectKind, rhs: RuntimeObjectKind) -> Bool {
        lhs.level < rhs.level
    }

    public static let allCases: [RuntimeObjectKind] = {
        var cases: [RuntimeObjectKind] = []
        cases.append(contentsOf: C.allCases.map { RuntimeObjectKind.c($0) })
        cases.append(contentsOf: ObjectiveC.allCases.map { RuntimeObjectKind.objc($0) })
        cases.append(contentsOf: Swift.allCases.map { RuntimeObjectKind.swift($0) })
        return cases
    }()

    public var description: String {
        switch self {
        case .c(let c):
            switch c {
            case .struct:
                "C Struct"
            case .union:
                "C Union"
            }
        case .objc(let objectiveC):
            switch objectiveC {
            case .type(let kind):
                switch kind {
                case .class:
                    "Objective-C Class"
                case .protocol:
                    "Objective-C Protocol"
                }
            case .category(let kind):
                switch kind {
                case .class:
                    "Objective-C Class Category"
                case .protocol:
                    "Objective-C Protocol Category"
                }
            }
        case .swift(let swift):
            switch swift {
            case .type(let kind):
                switch kind {
                case .enum:
                    "Swift Enum"
                case .struct:
                    "Swift Struct"
                case .class:
                    "Swift Class"
                case .protocol:
                    "Swift Protocol"
                case .typeAlias:
                    "Swift TypeAlias"
                }
            case .extension(let kind):
                switch kind {
                case .enum:
                    "Swift Enum Extension"
                case .struct:
                    "Swift Struct Extension"
                case .class:
                    "Swift Class Extension"
                case .protocol:
                    "Swift Protocol Extension"
                case .typeAlias:
                    "Swift TypeAlias Extension"
                }
            case .conformance(let kind):
                switch kind {
                case .enum:
                    "Swift Enum Conformance"
                case .struct:
                    "Swift Struct Conformance"
                case .class:
                    "Swift Class Conformance"
                case .protocol:
                    "Swift Protocol Conformance"
                case .typeAlias:
                    "Swift TypeAlias Conformance"
                }
            }
        }
    }
    
    public var isC: Bool {
        switch self {
        case .c: return true
        default: return false
        }
    }
    
    public var isObjC: Bool {
        switch self {
        case .objc: return true
        default: return false
        }
    }
    
    public var isSwift: Bool {
        switch self {
        case .swift: return true
        default: return false
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Core/RuntimeObjCSection.swift`:

```swift
import Foundation
import FoundationToolbox
import MachOObjCSection
import ObjCDump
import ObjCTypeDecodeKit
import OrderedCollections
private import RuntimeViewerCoreObjC
import Semantic
import Utilities
import MetaCodable

@Codable
public struct ObjCGenerationOptions: Sendable, Equatable {
    @Default(ifMissing: false)
    public var stripProtocolConformance: Bool = false
    @Default(ifMissing: false)
    public var stripOverrides: Bool = false
    @Default(ifMissing: false)
    public var stripSynthesizedIvars: Bool = false
    @Default(ifMissing: false)
    public var stripSynthesizedMethods: Bool = false
    @Default(ifMissing: false)
    public var stripCtorMethod: Bool = false
    @Default(ifMissing: false)
    public var stripDtorMethod: Bool = false
    @Default(ifMissing: false)
    public var addIvarOffsetComments: Bool = false
    @Default(ifMissing: false)
    public var addPropertyAttributesComments: Bool = false
}

@Loggable
actor RuntimeObjCSection {
    enum Error: Swift.Error {
        case invalidMachOImage
        case invalidRuntimeObject
    }

    let imagePath: String

    private let machO: MachOImage

    private let factory: RuntimeObjCSectionFactory

    private var classes: [String: ObjCClassGroup] = [:]

    private var protocols: [String: ObjCProtocolGroup] = [:]

    private var categories: [String: ObjCCategoryGroup] = [:]

    private var classInfoCache: [String: ObjCClassInfo] = [:]

    private var structs: [String: CStructOrUnion] = [:]

    private var unions: [String: CStructOrUnion] = [:]

    private typealias ObjCClassGroup = (objcClass: any ObjCClassProtocol, info: [ObjCClassInfo])

    private typealias ObjCProtocolGroup = (objcProtocol: any ObjCProtocolProtocol, info: ObjCProtocolInfo)

    private typealias ObjCCategoryGroup = (objcCategory: any ObjCCategoryProtocol, info: ObjCCategoryInfo)

    private enum ObjCName: Hashable {
        case `class`(String)
        case `protocol`(String)
        case category(String)
    }

    private struct CStructOrUnion: Hashable {
        let name: String

        let fields: [ObjCField]

        var hasBitFieldOnly: Bool {
            fields.allSatisfy { $0.bitWidth != nil }
        }

        var numberOfHasNameFields: Int {
            fields.count { $0.name != nil }
        }

        @SemanticStringBuilder
        func semanticString(isStruct: Bool, context: ObjCDumpContext) -> SemanticString {
            Keyword(isStruct ? "struct" : "union")
            Space()
            TypeName(kind: .other, name)
            Joined {
                MemberList(level: 1) {
                    for (index, field) in fields.enumerated() {
                        field.semanticString(fallbackName: "x\(index)", level: 1, context: context)
                    }
                }
            } prefix: {
                " {"
            } suffix: {
                Indent(level: 0)
                "}"
            }
        }
    }

    init(imagePath: String, factory: RuntimeObjCSectionFactory) async throws {
        #log(.info, "Initializing ObjC section for image: \(imagePath, privacy: .public)")
        let imageName = imagePath.lastPathComponent.deletingPathExtension.deletingPathExtension
        guard let machO = MachOImage(name: imageName) else {
            #log(.error, "Failed to create MachOImage for: \(imageName, privacy: .public)")
            throw Error.invalidMachOImage
        }
        self.machO = machO
        self.imagePath = imagePath
        self.factory = factory
        try await prepare()
    }

    init(machO: MachOImage, factory: RuntimeObjCSectionFactory) async throws {
        #log(.info, "Initializing ObjC section from MachO: \(machO.imagePath, privacy: .public)")
        self.machO = machO
        self.imagePath = machO.imagePath
        self.factory = factory
        try await prepare()
    }

    private func prepare() async throws {
        #log(.debug, "Preparing ObjC section data")
        var classByName: [String: ObjCClassGroup] = [:]
        var protocolByName: [String: ObjCProtocolGroup] = [:]
        var categoryByName: [String: ObjCCategoryGroup] = [:]
        var structsByName: [String: CStructOrUnion] = [:]
        var unionsByName: [String: CStructOrUnion] = [:]

        func setObjCType(_ type: ObjCType, forName objcName: ObjCName) {
            switch type {
            case .struct(let name, let fields):
                if let name {
                    let newStruct = CStructOrUnion(name: name, fields: fields ?? [])
                    guard !newStruct.hasBitFieldOnly else { return }
                    if let existStruct = structsByName[name] {
                        if existStruct.numberOfHasNameFields < newStruct.numberOfHasNameFields {
                            structsByName[name] = newStruct
                        }
                    } else {
                        structsByName[name] = newStruct
                    }
                }
            case .union(let name, let fields):
                if let name {
                    let newUnion = CStructOrUnion(name: name, fields: fields ?? [])
                    guard !newUnion.hasBitFieldOnly else { return }
                    if let existUnion = unionsByName[name] {
                        if existUnion.numberOfHasNameFields < newUnion.numberOfHasNameFields {
                            unionsByName[name] = newUnion
                        }
                    } else {
                        unionsByName[name] = newUnion
                    }
                }
            default:
                break
            }
        }

        func setObjCTypeFromMethods(_ methods: [ObjCMethodInfo], forName objcName: ObjCName) {
            for method in methods {
                if let returnType = method.returnType {
                    setObjCType(returnType, forName: objcName)
                }

                if let argumentInfos = method.argumentInfos {
                    for argumentInfo in argumentInfos {
                        setObjCType(argumentInfo.type, forName: objcName)
                    }
                }
            }
        }

        func setObjCTypeFromProperties(_ properties: [ObjCPropertyInfo], forName objcName: ObjCName) {
            for property in properties {
                for attribute in property.attributes {
                    if let type = attribute.type {
                        setObjCType(type, forName: objcName)
                    }
                }
            }
        }

        let objcClasses: [any ObjCClassProtocol] = machO.objc.classes64.orEmpty + machO.objc.classes32.orEmpty + machO.objc.nonLazyClasses64.orEmpty + machO.objc.nonLazyClasses32.orEmpty

        for objcClass in objcClasses {
            let objcClassGroup: ObjCClassGroup = (objcClass, infoWithSuperclasses(class: objcClass, in: machO))
            guard let objcClassInfo = objcClassGroup.info.first else { continue }
            classByName[objcClassInfo.name] = objcClassGroup

            let objcName = ObjCName.class(objcClassInfo.name)

            for ivar in objcClassInfo.ivars {
                if let type = ivar.type {
                    setObjCType(type, forName: objcName)
                }
            }

            setObjCTypeFromProperties(objcClassInfo.properties + objcClassInfo.classProperties, forName: objcName)
            setObjCTypeFromMethods(objcClassInfo.methods + objcClassInfo.classMethods, forName: objcName)
        }

        let objcProtocols: [any ObjCProtocolProtocol] = machO.objc.protocols64.orEmpty + machO.objc.protocols32.orEmpty

        for objcProtocol in objcProtocols {
            guard let objcProtocolInfo = objcProtocol.info(in: machO) else { continue }
            protocolByName[objcProtocolInfo.name] = (objcProtocol, objcProtocolInfo)
            let objcName = ObjCName.protocol(objcProtocolInfo.name)
            setObjCTypeFromProperties(objcProtocolInfo.properties + objcProtocolInfo.classProperties, forName: objcName)
            setObjCTypeFromMethods(objcProtocolInfo.methods + objcProtocolInfo.classMethods, forName: objcName)
        }

        var objcCategories: [any ObjCCategoryProtocol] = []

        objcCategories.append(contentsOf: machO.objc.categories64.orEmpty)
        objcCategories.append(contentsOf: machO.objc.categories32.orEmpty)
        objcCategories.append(contentsOf: machO.objc.nonLazyCategories64.orEmpty)
        objcCategories.append(contentsOf: machO.objc.nonLazyCategories32.orEmpty)
        objcCategories.append(contentsOf: machO.objc.categories2_64.orEmpty)
        objcCategories.append(contentsOf: machO.objc.categories2_32.orEmpty)

        for objcCategory in objcCategories {
            guard let objcCategoryInfo = objcCategory.info(in: machO) else { continue }
            categoryByName[objcCategoryInfo.uniqueName] = (objcCategory, objcCategoryInfo)
            let objcName = ObjCName.category(objcCategoryInfo.uniqueName)
            setObjCTypeFromProperties(objcCategoryInfo.properties + objcCategoryInfo.classProperties, forName: objcName)
            setObjCTypeFromMethods(objcCategoryInfo.methods + objcCategoryInfo.classMethods, forName: objcName)
        }

        classes = classByName
        protocols = protocolByName
        categories = categoryByName
        structs = structsByName
        unions = unionsByName
        #log(.info, "ObjC section prepared: \(classByName.count, privacy: .public) classes, \(protocolByName.count, privacy: .public) protocols, \(categoryByName.count, privacy: .public) categories, \(structsByName.count, privacy: .public) structs, \(unionsByName.count, privacy: .public) unions")
    }

    private func infoWithSuperclasses<Class: ObjCClassProtocol>(class cls: Class, in machO: MachOImage) -> [ObjCClassInfo] {
        guard let className = cls.name(in: machO) else { return [] }

        var currentInfo: ObjCClassInfo?

        if let cacheInfo = classInfoCache[className] {
            currentInfo = cacheInfo
        } else {
            let info = cls.info(in: machO)
            currentInfo = info
            classInfoCache[className] = info
        }

        guard let currentInfo else { return [] }

        var resultInfos: [ObjCClassInfo] = [currentInfo]

        var machOAndSuperclass = cls.superClass(in: machO) // else { return resultInfos }

        while let currentMachOAndSuperclass = machOAndSuperclass {
            let currentMachO = currentMachOAndSuperclass.0
            let currentSuperclass = currentMachOAndSuperclass.1

            machOAndSuperclass = currentSuperclass.superClass(in: currentMachO)

            guard let superClassName = currentSuperclass.name(in: currentMachO) else { continue }

            var superclassInfo: ObjCClassInfo?
            if let cacheInfo = classInfoCache[superClassName] {
                superclassInfo = cacheInfo
            } else {
                let info = currentSuperclass.info(in: currentMachO)
                superclassInfo = info
                classInfoCache[superClassName] = info
            }
            if let superclassInfo {
                resultInfos.append(superclassInfo)
            }
        }

        return resultInfos
    }

    func allObjects() async throws -> [RuntimeObject] {
        #log(.debug, "Getting all ObjC objects")
        var results: [RuntimeObject] = []

        for structName in structs.keys {
            results.append(.init(name: structName, displayName: structName, kind: .c(.struct), secondaryKind: nil, imagePath: imagePath, children: []))
        }

        for unionName in unions.keys {
            results.append(.init(name: unionName, displayName: unionName, kind: .c(.union), secondaryKind: nil, imagePath: imagePath, children: []))
        }

        for (className, objcClassGroup) in classes {
            results.append(.init(name: className, displayName: className, kind: .objc(.type(.class)), secondaryKind: objcClassGroup.objcClass.isSwiftStable ? .swift(.type(.class)) : nil, imagePath: imagePath, children: []))
        }

        for proto in protocols.keys {
            results.append(.init(name: proto, displayName: proto, kind: .objc(.type(.protocol)), secondaryKind: nil, imagePath: imagePath, children: []))
        }

        for category in categories.keys {
            results.append(.init(name: category, displayName: category, kind: .objc(.category(.class)), secondaryKind: nil, imagePath: imagePath, children: []))
        }

        #log(.debug, "Found \(results.count, privacy: .public) ObjC objects")
        return results
    }

    func interface(for object: RuntimeObject, using options: ObjCGenerationOptions, transformer: Transformer.ObjCConfiguration) async throws -> RuntimeObjectInterface {
        #log(.debug, "Generating interface for: \(object.name, privacy: .public)")
        let name = object.withImagePath(imagePath)
        let cTypeReplacements = transformer.cType.isEnabled ? transformer.cType.replacements : [:]
        let objcDumpContext = ObjCDumpContext(options: options, cTypeReplacements: cTypeReplacements) { name, isStruct in
            guard let name else { return true }
            if isStruct {
                return self.structs[name] == nil
            } else {
                return self.unions[name] == nil
            }
        }

        switch name.kind {
        case .objc(.type(.class)):
            if let classGroup = classes[name.name], let currentClassInfo = classGroup.info.first {
                let superclassInfos = classGroup.info.dropFirst()
                var finalClassInfo = classGroup.info.first
                var needsStripClassProperties: Set<String> = []
                var needsStripProperties: Set<String> = []
                var needsStripClassMethods: Set<String> = []
                var needsStripMethods: Set<String> = []
                var needsStripIvars: Set<String> = []

                if options.stripCtorMethod {
                    needsStripMethods.insert(".cxx_construct")
                }

                if options.stripDtorMethod {
                    needsStripMethods.insert(".cxx_destruct")
                }

                if options.stripOverrides {
                    for superclassInfo in superclassInfos {
                        needsStripClassProperties.insert(contentsOf: superclassInfo.classProperties.map(\.name))
                        needsStripProperties.insert(contentsOf: superclassInfo.properties.map(\.name))
                        needsStripClassMethods.insert(contentsOf: superclassInfo.classMethods.map(\.name))
                        needsStripMethods.insert(contentsOf: superclassInfo.methods.map(\.name))
                    }
                }
                if options.stripProtocolConformance {
                    for protocolInfo in currentClassInfo.protocols {
                        needsStripClassProperties.insert(contentsOf: protocolInfo.classProperties.map(\.name))
                        needsStripProperties.insert(contentsOf: protocolInfo.properties.map(\.name))
                        needsStripClassMethods.insert(contentsOf: protocolInfo.classMethods.map(\.name))
                        needsStripMethods.insert(contentsOf: protocolInfo.methods.map(\.name))
                    }
                }
                if options.stripSynthesizedIvars || options.stripSynthesizedMethods {
                    var needsStripIvarNames: Set<String> = []

                    for property in currentClassInfo.properties + currentClassInfo.classProperties {
                        if options.stripSynthesizedMethods {
                            let propertyName = property.name
                            if let customGetter = property.customGetter {
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(customGetter)
                                } else {
                                    needsStripMethods.insert(customGetter)
                                }
                            } else {
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(propertyName)
                                } else {
                                    needsStripMethods.insert(propertyName)
                                }
                            }

                            if let customSetter = property.customSetter {
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(customSetter)
                                } else {
                                    needsStripMethods.insert(customSetter)
                                }
                            } else {
                                let setterMethodName = "set" + propertyName.uppercasedFirst
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(setterMethodName)
                                } else {
                                    needsStripMethods.insert(setterMethodName)
                                }
                            }
                        }

                        if options.stripSynthesizedIvars, !property.isClassProperty {
                            if let ivar = property.ivar {
                                needsStripIvarNames.insert(ivar)
                            }
                        }
                    }

                    if options.stripSynthesizedIvars {
                        for ivar in currentClassInfo.ivars {
                            if needsStripIvarNames.contains(ivar.name) {
                                needsStripIvars.insert(ivar.name)
                            }
                        }
                    }
                }

                finalClassInfo = ObjCClassInfo(
                    name: currentClassInfo.name,
                    version: currentClassInfo.version,
                    imageName: currentClassInfo.imageName,
                    instanceSize: currentClassInfo.instanceSize,
                    superClassName: currentClassInfo.superClassName,
                    protocols: currentClassInfo.protocols,
                    ivars: currentClassInfo.ivars.removingAll { needsStripIvars.contains($0.name) },
                    classProperties: currentClassInfo.classProperties.removingAll { needsStripClassProperties.contains($0.name) },
                    properties: currentClassInfo.properties.removingAll { needsStripProperties.contains($0.name) },
                    classMethods: currentClassInfo.classMethods.removingAll { needsStripClassMethods.contains($0.name) },
                    methods: currentClassInfo.methods.removingAll { needsStripMethods.contains($0.name) }
                )

                if let finalClassInfo {
                    return .init(object: name, interfaceString: finalClassInfo.semanticString(using: objcDumpContext))
                }
            }
        case .objc(.type(.protocol)):
            if let currentProtocolInfo = protocols[name.name]?.info {
                var finalProtocolInfo = currentProtocolInfo

                var needsStripClassProperties: Set<String> = []
                var needsStripClassMethods: Set<String> = []
                var needsStripProperties: Set<String> = []
                var needsStripMethods: Set<String> = []

                if options.stripCtorMethod {
                    needsStripMethods.insert(".cxx_construct")
                }

                if options.stripDtorMethod {
                    needsStripMethods.insert(".cxx_destruct")
                }

                if options.stripProtocolConformance {
                    for protocolInfo in currentProtocolInfo.protocols {
                        needsStripClassProperties.insert(contentsOf: protocolInfo.classProperties.map(\.name))
                        needsStripProperties.insert(contentsOf: protocolInfo.properties.map(\.name))
                        needsStripClassMethods.insert(contentsOf: protocolInfo.classMethods.map(\.name))
                        needsStripMethods.insert(contentsOf: protocolInfo.methods.map(\.name))

                        needsStripClassProperties.insert(contentsOf: protocolInfo.optionalClassProperties.map(\.name))
                        needsStripProperties.insert(contentsOf: protocolInfo.optionalProperties.map(\.name))
                        needsStripClassMethods.insert(contentsOf: protocolInfo.optionalClassMethods.map(\.name))
                        needsStripMethods.insert(contentsOf: protocolInfo.optionalMethods.map(\.name))
                    }
                }

                if options.stripSynthesizedMethods {
                    for property in currentProtocolInfo.properties + currentProtocolInfo.classProperties + currentProtocolInfo.optionalProperties + currentProtocolInfo.optionalClassProperties {
                        if options.stripSynthesizedMethods {
                            let propertyName = property.name
                            if let customGetter = property.customGetter {
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(customGetter)
                                } else {
                                    needsStripMethods.insert(customGetter)
                                }
                            } else {
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(propertyName)
                                } else {
                                    needsStripMethods.insert(propertyName)
                                }
                            }

                            if let customSetter = property.customSetter {
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(customSetter)
                                } else {
                                    needsStripMethods.insert(customSetter)
                                }
                            } else {
                                let setterMethodName = "set" + propertyName.uppercasedFirst
                                if property.isClassProperty {
                                    needsStripClassMethods.insert(setterMethodName)
                                } else {
                                    needsStripMethods.insert(setterMethodName)
                                }
                            }
                        }
                    }
                }

                finalProtocolInfo = ObjCProtocolInfo(
                    name: currentProtocolInfo.name,
                    protocols: currentProtocolInfo.protocols,
                    classProperties: currentProtocolInfo.classProperties.removingAll { needsStripClassProperties.contains($0.name) },
                    properties: currentProtocolInfo.properties.removingAll { needsStripProperties.contains($0.name) },
                    classMethods: currentProtocolInfo.classMethods.removingAll { needsStripClassMethods.contains($0.name) },
                    methods: currentProtocolInfo.methods.removingAll { needsStripMethods.contains($0.name) },
                    optionalClassProperties: currentProtocolInfo.optionalClassProperties.removingAll { needsStripClassProperties.contains($0.name) },
                    optionalProperties: currentProtocolInfo.optionalProperties.removingAll { needsStripProperties.contains($0.name) },
                    optionalClassMethods: currentProtocolInfo.optionalClassMethods.removingAll { needsStripClassMethods.contains($0.name) },
                    optionalMethods: currentProtocolInfo.optionalMethods.removingAll { needsStripMethods.contains($0.name) }
                )

                return .init(object: name, interfaceString: finalProtocolInfo.semanticString(using: objcDumpContext))
            }
        case .objc(.category(.class)):
            if let interfaceString = categories[name.name]?.info.semanticString(using: objcDumpContext) {
                return .init(object: name, interfaceString: interfaceString)
            }
        case .c(.struct):
            if let interfaceString = structs[name.name]?.semanticString(isStruct: true, context: objcDumpContext) {
                return .init(object: name, interfaceString: interfaceString)
            }
        case .c(.union):
            if let interfaceString = unions[name.name]?.semanticString(isStruct: false, context: objcDumpContext) {
                return .init(object: name, interfaceString: interfaceString)
            }
        default:
            break
        }
        #log(.default, "Invalid runtime object: \(object.name, privacy: .public) kind: \(String(describing: object.kind), privacy: .public)")
        throw Error.invalidRuntimeObject
    }

    func classHierarchy(for object: RuntimeObject) async throws -> [String] {
        #log(.debug, "Getting class hierarchy for: \(object.name, privacy: .public)")
        guard case .objc(.type(.class)) = object.kind,
              let classGroups = classes[object.name]
        else {
            #log(.debug, "No class hierarchy found")
            return []
        }
        let hierarchy = classGroups.info.map(\.name)
        #log(.debug, "Class hierarchy: \(hierarchy.count, privacy: .public) levels")
        return hierarchy
    }
}

@Loggable
actor RuntimeObjCSectionFactory {
    private var sections: [String: RuntimeObjCSection] = [:]

    func existingSection(for imagePath: String) -> RuntimeObjCSection? {
        sections[imagePath]
    }

    func section(for imagePath: String) async throws -> RuntimeObjCSection {
        if let section = sections[imagePath] {
            #log(.debug, "Using cached ObjC section for: \(imagePath, privacy: .public)")
            return section
        }
        #log(.debug, "Creating ObjC section for: \(imagePath, privacy: .public)")
        let section = try await RuntimeObjCSection(imagePath: imagePath, factory: self)
        sections[imagePath] = section
        #log(.debug, "ObjC section created and cached")
        return section
    }

    func section(for name: RuntimeObjCName) async throws -> RuntimeObjCSection? {
        #log(.debug, "Looking up ObjC section for name: \(String(describing: name), privacy: .public)")
        do {
            guard let machO = MachOImage.image(forName: name) else {
                #log(.debug, "No MachO image found for name")
                return nil
            }

            if let existObjCSection = sections[machO.imagePath] {
                #log(.debug, "Using cached ObjC section")
                return existObjCSection
            }

            #log(.debug, "Creating ObjC section from MachO: \(machO.imagePath, privacy: .public)")
            let objcSection = try await RuntimeObjCSection(machO: machO, factory: self)
            sections[machO.imagePath] = objcSection
            return objcSection
        } catch {
            #log(.error, "Failed to create ObjC section: \(error, privacy: .public)")
            return nil
        }
    }

    func removeSection(for imagePath: String) {
        sections.removeValue(forKey: imagePath)
    }

    func removeAllSections() {
        sections.removeAll()
    }
}

enum RuntimeObjCName {
    case `class`(String)
    case `protocol`(String)
}

extension MachOImage {
    static func image(forName name: RuntimeObjCName) -> Self? {
        switch name {
        case .class(let string):
            return .image(forClassName: string)
        case .protocol(let string):
            return .image(forProtocolName: string)
        }
    }

    static func image(forClassName className: String) -> Self? {
        RVClassFromString(className).flatMap { MachOImage.image(for: autoBitCast($0)) }
    }

    static func image(forProtocolName protocolName: String) -> Self? {
        RVProtocolFromString(protocolName).flatMap { MachOImage.image(for: autoBitCast($0)) }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Core/RuntimeSwiftSection.swift`:

```swift
import Demangling
import Foundation
import FoundationToolbox
import FrameworkToolbox
import MachOKit
import MachOSwiftSection
import OrderedCollections
import Semantic
import SwiftDump
import SwiftInspection
@_spi(Support) import SwiftInterface
import MetaCodable

@Codable
public struct SwiftGenerationOptions: Sendable, Equatable {
    @Default(ifMissing: true)
    public var printStrippedSymbolicItem: Bool = true
    @Default(ifMissing: false)
    public var emitOffsetComments: Bool = false
    @Default(ifMissing: false)
    public var printTypeLayout: Bool = false
    @Default(ifMissing: false)
    public var printEnumLayout: Bool = false
    @Default(ifMissing: false)
    public var synthesizeOpaqueType: Bool = false
}

@Loggable(.private)
actor RuntimeSwiftSection {
    enum Error: Swift.Error {
        case invalidMachOImage
        case invalidRuntimeObject
    }

    let imagePath: String

    private let machO: MachOImage

    private let factory: RuntimeSwiftSectionFactory
    
    private var indexer: SwiftInterfaceIndexer<MachOImage>

    private var printer: SwiftInterfacePrinter<MachOImage>

    private var interfaceByName: OrderedDictionary<RuntimeObject, RuntimeObjectInterface> = [:]

    private var lastTransformerConfiguration: Transformer.SwiftConfiguration = .init()

    private var nameToInterfaceDefinitionName: [RuntimeObject: InterfaceDefinitionName] = [:]

    private enum InterfaceDefinitionName {
        case rootType(SwiftInterface.TypeName)
        case childType(SwiftInterface.TypeName)
        case rootProtocol(SwiftInterface.ProtocolName)
        case childProtocol(SwiftInterface.ProtocolName)
        case typeExtension(SwiftInterface.ExtensionName)
        case protocolExtension(SwiftInterface.ExtensionName)
        case typeAliasExtension(SwiftInterface.ExtensionName)
        case conformance(SwiftInterface.ExtensionName)

        var typeName: SwiftInterface.TypeName? {
            switch self {
            case .rootType(let typeName):
                return typeName
            case .childType(let typeName):
                return typeName
            default:
                return nil
            }
        }
    }

    init(imagePath: String, factory: RuntimeSwiftSectionFactory) async throws {
        #log(.info, "Initializing Swift section for image: \(imagePath, privacy: .public)")
        let imageName = imagePath.lastPathComponent.deletingPathExtension.deletingPathExtension
        guard let machO = MachOImage(name: imageName) else {
            #log(.error, "Failed to create MachOImage for: \(imageName, privacy: .public)")
            throw Error.invalidMachOImage
        }
        self.factory = factory
        self.imagePath = imagePath
        self.machO = machO
        #log(.debug, "Creating Swift Interface Components")
        self.indexer = .init(configuration: .init(showCImportedTypes: false), eventHandlers: [], in: machO)
        self.printer = .init(configuration: .init(), eventHandlers: [], in: machO)
        try await indexer.prepare()
        #log(.info, "Swift section initialized successfully")
    }

    func updateConfiguration(using options: SwiftGenerationOptions, transformer: Transformer.SwiftConfiguration) async throws {
        #log(.debug, "Updating Swift section configuration")

        let oldIndexConfiguration = indexer.configuration
        let newIndexConfiguration = SwiftInterfaceIndexConfiguration(showCImportedTypes: false)
        try await indexer.updateConfiguration(newIndexConfiguration)

        let oldPrintConfiguration = printer.configuration

        let transformerChanged = transformer != lastTransformerConfiguration
        lastTransformerConfiguration = transformer

        var fieldOffsetTransformer: FieldOffsetTransformer? = oldPrintConfiguration.fieldOffsetTransformer
        var typeLayoutTransformer: TypeLayoutTransformer? = oldPrintConfiguration.typeLayoutTransformer
        var enumLayoutTransformer: EnumLayoutTransformer? = oldPrintConfiguration.enumLayoutTransformer
        var enumLayoutCaseTransformer: EnumLayoutCaseTransformer? = oldPrintConfiguration.enumLayoutCaseTransformer

        if transformerChanged {
            if transformer.swiftFieldOffset.isEnabled {
                let module = transformer.swiftFieldOffset
                fieldOffsetTransformer = FieldOffsetTransformer { input in
                    let result = module.transform(.init(startOffset: input.startOffset, endOffset: input.endOffset))
                    return Comment(result).asSemanticString()
                }
            } else {
                fieldOffsetTransformer = nil
            }

            if transformer.swiftTypeLayout.isEnabled {
                let module = transformer.swiftTypeLayout
                typeLayoutTransformer = TypeLayoutTransformer { typeLayout in
                    let input = Transformer.SwiftTypeLayout.Input(
                        size: Int(typeLayout.size),
                        stride: Int(typeLayout.stride),
                        alignment: Int(typeLayout.flags.alignment),
                        extraInhabitantCount: Int(typeLayout.extraInhabitantCount),
                        isPOD: typeLayout.flags.isPOD,
                        isInlineStorage: typeLayout.flags.isInlineStorage,
                        isBitwiseTakable: typeLayout.flags.isBitwiseTakable,
                        isBitwiseBorrowable: typeLayout.flags.isBitwiseBorrowable,
                        isCopyable: typeLayout.flags.isCopyable,
                        hasEnumWitnesses: typeLayout.flags.hasEnumWitnesses,
                        isIncomplete: typeLayout.flags.isIncomplete
                    )
                    let result = module.transform(input)
                    return Comment(result).asSemanticString()
                }
            } else {
                typeLayoutTransformer = nil
            }

            if transformer.swiftEnumLayout.isEnabled {
                let module = transformer.swiftEnumLayout
                enumLayoutTransformer = EnumLayoutTransformer { layoutResult in
                    let payloadCaseCount = layoutResult.cases.filter { $0.caseName.hasPrefix("Payload") }.count
                    let emptyCaseCount = layoutResult.cases.filter { $0.caseName.hasPrefix("Empty") }.count
                    let input = Transformer.SwiftEnumLayout.Input(
                        strategy: layoutResult.strategyDescription,
                        bitsNeededForTag: layoutResult.bitsNeededForTag,
                        bitsAvailableForPayload: layoutResult.bitsAvailableForPayload,
                        numTags: layoutResult.numTags,
                        totalCases: layoutResult.cases.count,
                        payloadCaseCount: payloadCaseCount,
                        emptyCaseCount: emptyCaseCount,
                        tagRegionRange: layoutResult.tagRegion.map { "\($0.range)" } ?? "N/A",
                        tagRegionBitCount: layoutResult.tagRegion?.bitCount ?? 0,
                        tagRegionBytesHex: layoutResult.tagRegion.map { $0.bytes.map { String(format: "%02X", $0) }.joined(separator: " ") } ?? "N/A",
                        payloadRegionRange: layoutResult.payloadRegion.map { "\($0.range)" } ?? "N/A",
                        payloadRegionBitCount: layoutResult.payloadRegion?.bitCount ?? 0,
                        payloadRegionBytesHex: layoutResult.payloadRegion.map { $0.bytes.map { String(format: "%02X", $0) }.joined(separator: " ") } ?? "N/A"
                    )
                    let result = module.transform(input)
                    return InlineComment(result).asSemanticString()
                }

                enumLayoutCaseTransformer = EnumLayoutCaseTransformer { input in
                    let caseProjection = input.caseProjection
                    let indentation = input.indentation
                    let caseType: String = caseProjection.caseName.hasPrefix("Payload") ? "Payload" : "Empty"
                    let memoryChangesDetail = caseProjection.memoryChanges
                        .sorted(by: { $0.key < $1.key })
                        .map { "[\($0.key)]=0x\(String(format: "%02X", $0.value))" }
                        .joined(separator: ", ")
                    let caseInput = Transformer.SwiftEnumLayout.CaseInput(
                        caseIndex: caseProjection.caseIndex,
                        caseName: caseProjection.caseName,
                        tagValue: caseProjection.tagValue,
                        payloadValue: caseProjection.payloadValue,
                        tagHex: String(format: "0x%02X", caseProjection.tagValue),
                        payloadHex: String(format: "0x%02X", caseProjection.payloadValue),
                        tagValueBinary: "0b\(String(caseProjection.tagValue, radix: 2))",
                        payloadValueBinary: "0b\(String(caseProjection.payloadValue, radix: 2))",
                        caseType: caseType,
                        memoryChangeCount: caseProjection.memoryChanges.count,
                        memoryChangesDetail: memoryChangesDetail
                    )
                    let header = module.transformCase(caseInput)
                    let indentStr = String(repeating: "    ", count: indentation)
                    var output = ""
                    for line in header.split(separator: "\n", omittingEmptySubsequences: false) {
                        output += "\(indentStr)// \(line)\n"
                    }
                    // Transform memory offsets using the configured template
                    if caseProjection.memoryChanges.isEmpty {
                        output += "\(indentStr)// (No bits set / Zero)\n"
                    } else {
                        for offset in caseProjection.memoryChanges.keys.sorted() {
                            let byteValue = caseProjection.memoryChanges[offset]!
                            let offsetInput = Transformer.SwiftEnumLayout.MemoryOffsetInput(
                                offset: offset,
                                value: byteValue
                            )
                            let formattedOffset = module.transformMemoryOffset(offsetInput)
                            output += "\(indentStr)// \(formattedOffset)\n"
                        }
                    }
                    return AtomicComponent(string: output, type: .comment).asSemanticString()
                }
            } else {
                enumLayoutTransformer = nil
                enumLayoutCaseTransformer = nil
            }
        }

        let newPrintConfiguration = SwiftInterfacePrintConfiguration(
            printStrippedSymbolicItem: options.printStrippedSymbolicItem,
            printFieldOffset: options.emitOffsetComments,
            printTypeLayout: options.printTypeLayout,
            printEnumLayout: options.printEnumLayout,
            fieldOffsetTransformer: fieldOffsetTransformer,
            typeLayoutTransformer: typeLayoutTransformer,
            enumLayoutTransformer: enumLayoutTransformer,
            enumLayoutCaseTransformer: enumLayoutCaseTransformer
        )
        printer.updateConfiguration(newPrintConfiguration)

        if options.synthesizeOpaqueType {
            printer.addTypeNameResolver(SwiftInterfaceBuilderOpaqueTypeProvider(machO: machO))
        } else {
            printer.removeAllTypeNameResolvers()
        }

        if newIndexConfiguration.showCImportedTypes != oldIndexConfiguration.showCImportedTypes {
            #log(.debug, "Index configuration changed, re-preparing builder")
            nameToInterfaceDefinitionName.removeAll()
        }

        if newPrintConfiguration != oldPrintConfiguration {
            #log(.debug, "Print configuration changed, clearing interface cache")
            interfaceByName.removeAll()
        }
    }

    func allObjects() async throws -> [RuntimeObject] {
        #log(.debug, "Getting all Swift objects")
        let rootTypeName = try indexer.rootTypeDefinitions.map { try makeRuntimeObject(for: $0.value, isChild: false) }
        let rootProtocolName = try indexer.rootProtocolDefinitions.map { try makeRuntimeObject(for: $0.value, isChild: false) }
        let typeExtensionName = try indexer.typeExtensionDefinitions.filter { $0.key.typeName.map { indexer.allTypeDefinitions[$0] == nil } ?? false }.map { try makeRuntimeObject(for: $0.value, extensionName: $0.key, kind: $0.key.runtimeObjectKindOfSwiftExtension, definitionName: .typeExtension($0.key)) }
        let protocolExtensionName = try indexer.protocolExtensionDefinitions.filter { $0.key.protocolName.map { indexer.allProtocolDefinitions[$0] == nil } ?? false }.map { try makeRuntimeObject(for: $0.value, extensionName: $0.key, kind: $0.key.runtimeObjectKindOfSwiftExtension, definitionName: .protocolExtension($0.key)) }
        let typeAliasExtensionName = try indexer.typeAliasExtensionDefinitions.map { try makeRuntimeObject(for: $0.value, extensionName: $0.key, kind: $0.key.runtimeObjectKindOfSwiftExtension, definitionName: .typeAliasExtension($0.key)) }
        let conformanceExtensionName = try indexer.conformanceExtensionDefinitions.filter { $0.key.typeName.map { indexer.allTypeDefinitions[$0] == nil } ?? false }.map { try makeRuntimeObject(for: $0.value, extensionName: $0.key, kind: $0.key.runtimeObjectKindOfSwiftConformance, definitionName: .conformance($0.key)) }
        let allObjects = rootTypeName + rootProtocolName + typeExtensionName + protocolExtensionName + typeAliasExtensionName + conformanceExtensionName
        #log(.debug, "Found \(allObjects.count, privacy: .public) Swift objects: \(rootTypeName.count, privacy: .public) types, \(rootProtocolName.count, privacy: .public) protocols, \(typeExtensionName.count, privacy: .public) type extensions")
        return allObjects
    }

    private func makeRuntimeObject(for extensionDefintions: [ExtensionDefinition], extensionName: ExtensionName, kind: RuntimeObjectKind, definitionName: InterfaceDefinitionName) throws -> RuntimeObject {
        let typeChildren = try extensionDefintions.flatMap { $0.types }.map { try makeRuntimeObject(for: $0, isChild: true) }
        let protocolChildren = try extensionDefintions.flatMap { $0.protocols }.map { try makeRuntimeObject(for: $0, isChild: true) }
        let mangledName = try mangleAsString(extensionName.node)
        let runtimeObjectName = RuntimeObject(name: mangledName, displayName: extensionName.name, kind: kind, secondaryKind: nil, imagePath: imagePath, children: typeChildren + protocolChildren)
        nameToInterfaceDefinitionName[runtimeObjectName] = definitionName
        return runtimeObjectName
    }

    private func makeRuntimeObject(for protocolDefintion: ProtocolDefinition, isChild: Bool) throws -> RuntimeObject {
        let mangledName = try mangleAsString(protocolDefintion.protocolName.node)
        let runtimeObjectName: RuntimeObject
        if isChild {
            runtimeObjectName = RuntimeObject(name: mangledName, displayName: protocolDefintion.protocolName.currentName, kind: protocolDefintion.protocolName.runtimeObjectKind, secondaryKind: nil, imagePath: imagePath, children: [])
            nameToInterfaceDefinitionName[runtimeObjectName] = .childProtocol(protocolDefintion.protocolName)
        } else {
            runtimeObjectName = RuntimeObject(name: mangledName, displayName: protocolDefintion.protocolName.name, kind: protocolDefintion.protocolName.runtimeObjectKind, secondaryKind: nil, imagePath: imagePath, children: [])
            nameToInterfaceDefinitionName[runtimeObjectName] = .rootProtocol(protocolDefintion.protocolName)
        }
        return runtimeObjectName
    }

    private func makeRuntimeObject(for typeDefinition: TypeDefinition, isChild: Bool) throws -> RuntimeObject {
        let typeChildren = try typeDefinition.typeChildren.map { try makeRuntimeObject(for: $0, isChild: true) }
        let protocolChildren = try typeDefinition.protocolChildren.map { try makeRuntimeObject(for: $0, isChild: true) }
        let mangledName = try mangleAsString(typeDefinition.typeName.node)
        let runtimeObjectName: RuntimeObject
        if isChild {
            runtimeObjectName = RuntimeObject(name: mangledName, displayName: typeDefinition.typeName.currentName, kind: typeDefinition.typeName.runtimeObjectKind, secondaryKind: nil, imagePath: imagePath, children: typeChildren + protocolChildren)
            nameToInterfaceDefinitionName[runtimeObjectName] = .childType(typeDefinition.typeName)
        } else {
            runtimeObjectName = RuntimeObject(name: mangledName, displayName: typeDefinition.typeName.name, kind: typeDefinition.typeName.runtimeObjectKind, secondaryKind: nil, imagePath: imagePath, children: typeChildren + protocolChildren)
            nameToInterfaceDefinitionName[runtimeObjectName] = .rootType(typeDefinition.typeName)
        }
        return runtimeObjectName
    }

    func interface(for object: RuntimeObject) async throws -> RuntimeObjectInterface {
        #log(.debug, "Generating Swift interface for: \(object.displayName, privacy: .public)")
        if let interface = interfaceByName[object] {
            #log(.debug, "Using cached interface")
            return interface
        }

        guard let interfaceDefinitionName = nameToInterfaceDefinitionName[object] else {
            #log(.default, "Invalid runtime object: \(object.displayName, privacy: .public)")
            throw Error.invalidRuntimeObject
        }
        var newInterfaceString: SemanticString = ""
        switch interfaceDefinitionName {
        case .rootType(let rootTypeName):
            guard let typeDefinition = indexer.rootTypeDefinitions[rootTypeName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(printer.printTypeDefinition(typeDefinition))
            if let typeExtensionDefinitions = indexer.typeExtensionDefinitions[rootTypeName.extensionName] {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(typeExtensionDefinitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
            if let conformanceExtensionDefinitions = indexer.conformanceExtensionDefinitions[rootTypeName.extensionName] {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(conformanceExtensionDefinitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
        case .childType(let childTypeName):
            guard let typeDefinition = indexer.allTypeDefinitions[childTypeName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(printer.printTypeDefinition(typeDefinition))
            if let typeExtensionDefinitions = indexer.typeExtensionDefinitions[childTypeName.extensionName] {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(typeExtensionDefinitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
            if let conformanceExtensionDefinitions = indexer.conformanceExtensionDefinitions[childTypeName.extensionName] {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(conformanceExtensionDefinitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
        case .rootProtocol(let rootProtocolName):
            guard let definition = indexer.rootProtocolDefinitions[rootProtocolName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(printer.printProtocolDefinition(definition))
            if !definition.defaultImplementationExtensions.isEmpty {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(definition.defaultImplementationExtensions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
            if let protocolExtensionDefinitions = indexer.protocolExtensionDefinitions[rootProtocolName.extensionName] {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(protocolExtensionDefinitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
        case .childProtocol(let childProtocolName):
            guard let definition = indexer.allProtocolDefinitions[childProtocolName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(printer.printProtocolDefinition(definition))
            if !definition.defaultImplementationExtensions.isEmpty {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(definition.defaultImplementationExtensions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
            if let protocolExtensionDefinitions = indexer.protocolExtensionDefinitions[childProtocolName.extensionName] {
                newInterfaceString.append(.doubleBreakLine)
                try await newInterfaceString.append(protocolExtensionDefinitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
            }
        case .typeExtension(let typeExtensionName):
            guard let definitions = indexer.typeExtensionDefinitions[typeExtensionName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(definitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
        case .protocolExtension(let protocolExtensionName):
            guard let definitions = indexer.protocolExtensionDefinitions[protocolExtensionName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(definitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
        case .typeAliasExtension(let typeAliasExtensionName):
            guard let definitions = indexer.typeAliasExtensionDefinitions[typeAliasExtensionName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(definitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
        case .conformance(let conformanceExtensionName):
            guard let definitions = indexer.conformanceExtensionDefinitions[conformanceExtensionName] else { throw Error.invalidRuntimeObject }
            try await newInterfaceString.append(definitions.box.asyncMap { try await printer.printExtensionDefinition($0) }.join(separator: .doubleBreakLine))
        }

        let newInterface = RuntimeObjectInterface(object: object, interfaceString: newInterfaceString)
        interfaceByName[object] = newInterface
        #log(.debug, "Interface generated and cached")
        return newInterface
    }

    func classHierarchy(for object: RuntimeObject) async throws -> [String] {
        #log(.debug, "Getting Swift class hierarchy for: \(object.displayName, privacy: .public)")
        guard case .swift(.type(.class)) = object.kind,
              let classDefinitionName = nameToInterfaceDefinitionName[object]?.typeName,
              let classDefinition = indexer.allTypeDefinitions[classDefinitionName],
              case .class(let `class`) = classDefinition.type
        else {
            #log(.debug, "No class hierarchy found")
            return []
        }
        let hierarchy = try ClassHierarchyDumper(machO: machO).dump(for: `class`.descriptor)
        #log(.debug, "Class hierarchy: \(hierarchy.count, privacy: .public) levels")
        return hierarchy
    }
}

extension SwiftInterface.TypeName {
    fileprivate var runtimeObjectKind: RuntimeObjectKind {
        switch kind {
        case .enum:
            return .swift(.type(.enum))
        case .struct:
            return .swift(.type(.struct))
        case .class:
            return .swift(.type(.class))
        }
    }
}

extension SwiftInterface.ProtocolName {
    fileprivate var runtimeObjectKind: RuntimeObjectKind {
        return .swift(.type(.protocol))
    }
}

extension SwiftInterface.ExtensionName {
    fileprivate var runtimeObjectKindOfSwiftExtension: RuntimeObjectKind {
        switch kind {
        case .type(let type):
            switch type {
            case .enum:
                return .swift(.extension(.enum))
            case .struct:
                return .swift(.extension(.struct))
            case .class:
                return .swift(.extension(.class))
            }
        case .protocol:
            return .swift(.extension(.protocol))
        case .typeAlias:
            return .swift(.extension(.typeAlias))
        }
    }

    fileprivate var runtimeObjectKindOfSwiftConformance: RuntimeObjectKind {
        switch kind {
        case .type(let type):
            switch type {
            case .enum:
                return .swift(.conformance(.enum))
            case .struct:
                return .swift(.conformance(.struct))
            case .class:
                return .swift(.conformance(.class))
            }
        case .protocol:
            return .swift(.conformance(.protocol))
        case .typeAlias:
            return .swift(.conformance(.typeAlias))
        }
    }
}

extension Array where Element == SemanticString {
    func join(separator: SemanticString = "") -> Element {
        var result: SemanticString = ""
        for (index, element) in enumerated() {
            result.append(element)
            if index < count - 1 {
                result.append(separator)
            }
        }
        return result
    }
}

extension ExtensionName {
    fileprivate var typeName: SwiftInterface.TypeName? {
        switch kind {
        case .type(let type):
            switch type {
            case .enum:
                return .init(node: node, kind: .enum)
            case .struct:
                return .init(node: node, kind: .struct)
            case .class:
                return .init(node: node, kind: .class)
            }
        default:
            return nil
        }
    }

    fileprivate var protocolName: SwiftInterface.ProtocolName? {
        switch kind {
        case .protocol:
            return .init(node: node)
        default:
            return nil
        }
    }
}

extension SemanticString {
    fileprivate static var doubleBreakLine: SemanticString {
        "\n\n"
    }
}

@Loggable(.private)
actor RuntimeSwiftSectionFactory {
    private var sections: [String: RuntimeSwiftSection] = [:]

    func existingSection(for imagePath: String) -> RuntimeSwiftSection? {
        sections[imagePath]
    }

    func section(for imagePath: String) async throws -> RuntimeSwiftSection {
        if let section = sections[imagePath] {
            #log(.debug, "Using cached Swift section for: \(imagePath, privacy: .public)")
            return section
        }
        #log(.debug, "Creating Swift section for: \(imagePath, privacy: .public)")
        let section = try await RuntimeSwiftSection(imagePath: imagePath, factory: self)
        sections[imagePath] = section
        #log(.debug, "Swift section created and cached")
        return section
    }

    func removeSection(for imagePath: String) {
        sections.removeValue(forKey: imagePath)
    }

    func removeAllSections() {
        sections.removeAll()
    }
}

@FrameworkToolboxExtension(.internal)
extension SwiftInterface.Definition {}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportConfiguration.swift`:

```swift
public import Foundation

public struct RuntimeInterfaceExportConfiguration: Sendable {
    public enum Format: Int, Sendable {
        case singleFile = 0
        case directory = 1
    }

    public let imagePath: String
    public let imageName: String
    public let directory: URL
    public let objcFormat: Format
    public let swiftFormat: Format
    public let generationOptions: RuntimeObjectInterface.GenerationOptions

    public init(
        imagePath: String,
        imageName: String,
        directory: URL,
        objcFormat: Format,
        swiftFormat: Format,
        generationOptions: RuntimeObjectInterface.GenerationOptions
    ) {
        self.imagePath = imagePath
        self.imageName = imageName
        self.directory = directory
        self.objcFormat = objcFormat
        self.swiftFormat = swiftFormat
        self.generationOptions = generationOptions
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportEvent.swift`:

```swift
public import Foundation
public import Semantic

public enum RuntimeInterfaceExportEvent: Sendable {
    case phaseStarted(Phase)
    case phaseCompleted(Phase)
    case phaseFailed(Phase, any Swift.Error & Sendable)

    case objectStarted(RuntimeObject, current: Int, total: Int)
    case objectCompleted(RuntimeObject, SemanticString)
    case objectFailed(RuntimeObject, any Swift.Error & Sendable)

    case completed(RuntimeInterfaceExportResult)

    public enum Phase: Sendable {
        case preparing
        case exporting
        case writing
    }
}

public struct RuntimeInterfaceExportResult: Sendable {
    public let succeeded: Int
    public let failed: Int
    public let totalDuration: TimeInterval
    public let objcCount: Int
    public let swiftCount: Int

    public init(succeeded: Int, failed: Int, totalDuration: TimeInterval, objcCount: Int, swiftCount: Int) {
        self.succeeded = succeeded
        self.failed = failed
        self.totalDuration = totalDuration
        self.objcCount = objcCount
        self.swiftCount = swiftCount
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportItem.swift`:

```swift
import Foundation

struct RuntimeInterfaceExportItem: Sendable {
    let object: RuntimeObject
    let plainText: String
    let suggestedFileName: String

    var fileExtension: String {
        switch object.kind {
        case .swift: return "swiftinterface"
        case .objc, .c: return "h"
        }
    }

    var isSwift: Bool {
        if case .swift = object.kind { return true }
        return false
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportReporter.swift`:

```swift
import Foundation

public final class RuntimeInterfaceExportReporter: Sendable {
    public let events: AsyncStream<RuntimeInterfaceExportEvent>
    
    private let continuation: AsyncStream<RuntimeInterfaceExportEvent>.Continuation

    public init() {
        (events, continuation) = AsyncStream<RuntimeInterfaceExportEvent>.makeStream()
    }

    func send(_ event: RuntimeInterfaceExportEvent) {
        continuation.yield(event)
    }

    func finish() {
        continuation.finish()
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportWriter.swift`:

```swift
import Foundation

enum RuntimeInterfaceExportWriter {
    static func writeSingleFile(
        items: [RuntimeInterfaceExportItem],
        to directory: URL,
        imageName: String
    ) throws {
        let objcItems = items.filter { !$0.isSwift }
        let swiftItems = items.filter { $0.isSwift }

        if !objcItems.isEmpty {
            let combined = objcItems.map(\.plainText).joined(separator: "\n\n")
            let file = directory.appendingPathComponent("\(imageName).h")
            try combined.write(to: file, atomically: true, encoding: .utf8)
        }

        if !swiftItems.isEmpty {
            let combined = swiftItems.map(\.plainText).joined(separator: "\n\n")
            let file = directory.appendingPathComponent("\(imageName).swiftinterface")
            try combined.write(to: file, atomically: true, encoding: .utf8)
        }
    }

    static func writeDirectory(
        items: [RuntimeInterfaceExportItem],
        to directory: URL
    ) throws {
        let objcItems = items.filter { !$0.isSwift }
        let swiftItems = items.filter { $0.isSwift }

        if !objcItems.isEmpty {
            let objcDir = directory.appendingPathComponent("ObjCHeaders")
            try FileManager.default.createDirectory(at: objcDir, withIntermediateDirectories: true)
            for item in objcItems {
                let file = objcDir.appendingPathComponent(item.suggestedFileName)
                try item.plainText.write(to: file, atomically: true, encoding: .utf8)
            }
        }

        if !swiftItems.isEmpty {
            let swiftDir = directory.appendingPathComponent("SwiftInterfaces")
            try FileManager.default.createDirectory(at: swiftDir, withIntermediateDirectories: true)
            for item in swiftItems {
                let file = swiftDir.appendingPathComponent(item.suggestedFileName)
                try item.plainText.write(to: file, atomically: true, encoding: .utf8)
            }
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/RuntimeEngine.swift`:

```swift
import MachOKit
public import FoundationToolbox
import RuntimeViewerCoreObjC
public import Foundation
public import Combine
public import RuntimeViewerCommunication

// public import Version

// MARK: - RuntimeEngine.State

extension RuntimeEngine {
    /// Represents the current state of the RuntimeEngine.
    public enum State: Sendable, Equatable {
        /// The engine is being initialized.
        case initializing

        /// The engine is running locally without a remote connection.
        case localOnly

        /// The engine is attempting to connect to a remote source.
        case connecting

        /// The engine is connected to a remote source.
        case connected

        /// The engine has been disconnected from the remote source.
        case disconnected(error: RuntimeConnectionError?)

        /// Returns `true` if the engine is ready to process requests.
        public var isReady: Bool {
            switch self {
            case .localOnly,
                 .connected:
                return true
            case .initializing,
                 .connecting,
                 .disconnected:
                return false
            }
        }
    }
}

// MARK: - RuntimeEngine

@Loggable(.private)
public actor RuntimeEngine {
    fileprivate enum CommandNames: String, CaseIterable {
        case imageList
        case imageNodes
        case loadImage
        case isImageLoaded
        case patchImagePathForDyld
        case runtimeObjectHierarchy
        case runtimeObjectInfo
        case imageNameOfClassName
        case observeRuntime
        case runtimeInterfaceForRuntimeObjectInImageWithOptions
        case runtimeObjectsOfKindInImage
        case runtimeObjectsInImage
        case reloadData

        var commandName: String {
            "com.RuntimeViewer.RuntimeViewerCore.RuntimeEngine.\(rawValue)"
        }
    }

    public static let local: RuntimeEngine = {
        let runtimeEngine = RuntimeEngine(source: .local)
        Task {
            try await runtimeEngine.connect()
        }
        return runtimeEngine
    }()

    public nonisolated let source: RuntimeSource

    // MARK: - State Management

    private nonisolated let stateSubject = CurrentValueSubject<State, Never>(.initializing)

    private var connectionStateCancellable: AnyCancellable?

    /// Publisher that emits engine state changes.
    public nonisolated var statePublisher: some Publisher<State, Never> {
        stateSubject.eraseToAnyPublisher()
    }

    /// The current engine state.
    public nonisolated var state: State {
        stateSubject.value
    }

    // MARK: - Data Properties

    public private(set) var imageList: [String] = []

    public private(set) var loadedImagePaths: [String] = []

    @Published
    public private(set) var imageNodes: [RuntimeImageNode] = []

    public var reloadDataPublisher: some Publisher<Void, Never> {
        reloadDataSubject.eraseToAnyPublisher()
    }

    private let reloadDataSubject = PassthroughSubject<Void, Never>()

    private let objcSectionFactory: RuntimeObjCSectionFactory

    private let swiftSectionFactory: RuntimeSwiftSectionFactory

    private let communicator = RuntimeCommunicator()

    /// The connection to the sender or receiver
    private var connection: RuntimeConnection?

    public init(source: RuntimeSource) {
        self.source = source
        self.objcSectionFactory = .init()
        self.swiftSectionFactory = .init()
        #log(.info, "Initializing RuntimeEngine with source: \(String(describing: source), privacy: .public)")
    }

    public func connect() async throws {
        if let role = source.remoteRole {
            stateSubject.send(.connecting)

            switch role {
            case .server:
                #log(.info, "Starting as server")
                connection = try await communicator.connect(to: source) { connection in
                    self.connection = connection
                    self.setupMessageHandlerForServer()
                    self.observeConnectionState(connection)
                }
                #log(.info, "Server connection established")
                await observeRuntime()
                stateSubject.send(.connected)
            case .client:
                #log(.info, "Starting as client")
                connection = try await communicator.connect(to: source) { connection in
                    self.connection = connection
                    self.setupMessageHandlerForClient()
                    self.observeConnectionState(connection)
                }
                #log(.info, "Client connected successfully")
                stateSubject.send(.connected)
            }
        } else {
            #log(.debug, "No remote role, observing local runtime")
            await observeRuntime()
            stateSubject.send(.localOnly)
        }
    }

    /// Observes the connection state and updates the engine state accordingly.
    private func observeConnectionState(_ connection: RuntimeConnection) {
        connectionStateCancellable = connection.statePublisher
            .sink { [weak self] state in
                guard let self else { return }
                Task {
                    await self.handleConnectionStateChange(state)
                }
            }
    }

    /// Handles connection state changes and updates the engine state.
    private func handleConnectionStateChange(_ connectionState: RuntimeConnectionState) {
        switch connectionState {
        case .connecting:
            stateSubject.send(.connecting)
        case .connected:
            stateSubject.send(.connected)
        case .disconnected(let error):
            stateSubject.send(.disconnected(error: error))
        }
    }

    /// Stops the engine and its connection.
    public func stop() {
        connectionStateCancellable?.cancel()
        connectionStateCancellable = nil
        connection?.stop()
        stateSubject.send(.disconnected(error: nil))
        #log(.info, "RuntimeEngine stopped")
    }

    private func setupMessageHandlerForServer() {
        #log(.debug, "Setting up server message handlers")
        setMessageHandlerBinding(forName: .isImageLoaded, of: self) { $0.isImageLoaded(path:) }
        setMessageHandlerBinding(forName: .loadImage, of: self) { $0.loadImage(at:) }
        setMessageHandlerBinding(forName: .imageNameOfClassName, of: self) { $0.imageName(ofObjectName:) }

        setMessageHandlerBinding(forName: .runtimeObjectsInImage, of: self) { $0.objects(in:) }
        setMessageHandlerBinding(forName: .runtimeInterfaceForRuntimeObjectInImageWithOptions, of: self) { $0.interface(for:) }
        setMessageHandlerBinding(forName: .runtimeObjectHierarchy, of: self) { $0.hierarchy(for:) }
        #log(.debug, "Server message handlers setup complete")
    }

    private func setupMessageHandlerForClient() {
        #log(.debug, "Setting up client message handlers")
        setMessageHandlerBinding(forName: .imageList) { $0.imageList = $1 }
        setMessageHandlerBinding(forName: .imageNodes) { $0.imageNodes = $1 }
        setMessageHandlerBinding(forName: .reloadData) { $0.reloadDataSubject.send() }
        #log(.debug, "Client message handlers setup complete")
    }

    private func setMessageHandlerBinding<Object: AnyObject, Request: Codable>(forName name: CommandNames, of object: Object, to function: @escaping (Object) -> ((Request) async throws -> Void)) {
        guard let connection else {
            #log(.default, "Connection is nil when setting message handler for \(name.commandName, privacy: .public)")
            return
        }
        connection.setMessageHandler(name: name.commandName) { [unowned object] (request: Request) in
            try await function(object)(request)
        }
    }

    private func setMessageHandlerBinding<Object: AnyObject, Request: Codable, Response: Codable>(forName name: CommandNames, of object: Object, to function: @escaping (Object) -> ((Request) async throws -> Response)) {
        guard let connection else {
            #log(.default, "Connection is nil when setting message handler for \(name.commandName, privacy: .public)")
            return
        }
        connection.setMessageHandler(name: name.commandName) { [unowned object] (request: Request) -> Response in
            let result = try await function(object)(request)
            return result
        }
    }

    private func setMessageHandlerBinding<Response: Codable>(forName name: CommandNames, perform: @escaping (isolated RuntimeEngine, Response) async throws -> Void) {
        guard let connection else {
            #log(.default, "Connection is nil when setting message handler for \(name.commandName, privacy: .public)")
            return
        }
        connection.setMessageHandler(name: name.commandName) { [weak self] (response: Response) in
            guard let self else { return }
            try await perform(self, response)
        }
    }

    private func setMessageHandlerBinding(forName name: CommandNames, perform: @escaping (isolated RuntimeEngine) async throws -> Void) {
        guard let connection else {
            #log(.default, "Connection is nil when setting message handler for \(name.commandName, privacy: .public)")
            return
        }
        connection.setMessageHandler(name: name.commandName) { [weak self] in
            guard let self else { return }
            try await perform(self)
        }
    }

    public func reloadData(isReloadImageNodes: Bool) {
        #log(.info, "Reloading data, isReloadImageNodes=\(isReloadImageNodes, privacy: .public)")
        imageList = DyldUtilities.imageNames()
        #log(.debug, "Loaded \(self.imageList.count, privacy: .public) images")
        if isReloadImageNodes {
            imageNodes = [DyldUtilities.dyldSharedCacheImageRootNode, DyldUtilities.otherImageRootNode]
            #log(.debug, "Reloaded image nodes")
        }
        sendRemoteDataIfNeeded(isReloadImageNodes: isReloadImageNodes)
        #log(.info, "Data reload complete")
    }

    private func observeRuntime() async {
        #log(.info, "Starting runtime observation")
        imageList = DyldUtilities.imageNames()
        #log(.debug, "Initial image list contains \(self.imageList.count, privacy: .public) images")

        await Task.detached {
            await self.setImageNodes([DyldUtilities.dyldSharedCacheImageRootNode, DyldUtilities.otherImageRootNode])
        }.value
        #log(.debug, "Image nodes initialized")

        sendRemoteDataIfNeeded(isReloadImageNodes: true)
        #log(.info, "Runtime observation started")
    }

    private func setImageNodes(_ imageNodes: [RuntimeImageNode]) {
        self.imageNodes = imageNodes
    }

    private func sendRemoteDataIfNeeded(isReloadImageNodes: Bool) {
        Task {
            guard let role = source.remoteRole, role.isServer, let connection else {
                #log(.debug, "No remote connection, sending local reload notification")
                reloadDataSubject.send()
                return
            }
            #log(.debug, "Sending remote data to client")
            try await connection.sendMessage(name: .imageList, request: imageList)
            if isReloadImageNodes {
                try await connection.sendMessage(name: .imageNodes, request: imageNodes)
            }
            try await connection.sendMessage(name: .reloadData)
            #log(.debug, "Remote data sent successfully")
        }
    }

    private func _objects(in image: String) async throws -> [RuntimeObject] {
        #log(.debug, "Getting objects in image: \(image, privacy: .public)")
        let image = DyldUtilities.patchImagePathForDyld(image)
        let objcObjects = try await objcSectionFactory.section(for: image).allObjects()
        let swiftObjects = try await swiftSectionFactory.section(for: image).allObjects()
        #log(.debug, "Found \(objcObjects.count, privacy: .public) ObjC and \(swiftObjects.count, privacy: .public) Swift objects")
        return objcObjects + swiftObjects
    }

    private func _interface(for name: RuntimeObject, options: RuntimeObjectInterface.GenerationOptions) async throws -> RuntimeObjectInterface? {
        let rawInterface: RuntimeObjectInterface?

        switch name.kind {
        case .swift:
            let swiftSection = await swiftSectionFactory.existingSection(for: name.imagePath)
            try await swiftSection?.updateConfiguration(using: options.swiftInterfaceOptions, transformer: options.transformer.swift)
            return try? await swiftSection?.interface(for: name)
        case .c,
             .objc:
            let objcSection = await objcSectionFactory.existingSection(for: name.imagePath)
            let objcTransformer = options.transformer.objc
            if let interface = try? await objcSection?.interface(for: name, using: options.objcHeaderOptions, transformer: objcTransformer) {
                return interface
            } else {
                switch name.kind {
                case .objc(.type(let kind)):
                    switch kind {
                    case .class:
                        return try? await objcSectionFactory.section(for: .class(name.name))?.interface(for: name, using: options.objcHeaderOptions, transformer: objcTransformer)
                    case .protocol:
                        return try? await objcSectionFactory.section(for: .protocol(name.name))?.interface(for: name, using: options.objcHeaderOptions, transformer: objcTransformer)
                    }
                default:
                    rawInterface = nil
                }
            }
        }

        return rawInterface
    }
}

// MARK: - Requests

extension RuntimeEngine {
    enum RequestError: Error {
        case senderConnectionIsLose
    }

    private func request<T>(local: () async throws -> T, remote: (_ senderConnection: RuntimeConnection) async throws -> T) async throws -> T {
        if let remoteRole = source.remoteRole, remoteRole.isClient {
            guard let connection else { throw RequestError.senderConnectionIsLose }
            return try await remote(connection)
        } else {
            return try await local()
        }
    }

    public func isImageLoaded(path: String) async throws -> Bool {
        try await request {
            imageList.contains(DyldUtilities.patchImagePathForDyld(path))
        } remote: {
            return try await $0.sendMessage(name: .isImageLoaded, request: path)
        }
    }

    public func loadImage(at path: String) async throws {
        try await request {
            try DyldUtilities.loadImage(at: path)
            _ = try await objcSectionFactory.section(for: path)
            _ = try await swiftSectionFactory.section(for: path)
            reloadData(isReloadImageNodes: false)
            loadedImagePaths.append(path)
        } remote: {
            try await $0.sendMessage(name: .loadImage, request: path)
        }
    }

    public func imageName(ofObjectName name: RuntimeObject) async throws -> String? {
        try await request {
            nil
        } remote: {
            return try await $0.sendMessage(name: .imageNameOfClassName, request: name)
        }
    }

    private struct InterfaceRequest: Codable {
        let object: RuntimeObject
        let options: RuntimeObjectInterface.GenerationOptions
    }

    public func interface(for object: RuntimeObject, options: RuntimeObjectInterface.GenerationOptions) async throws -> RuntimeObjectInterface? {
        return try await interface(for: .init(object: object, options: options))
    }

    private func interface(for request: InterfaceRequest) async throws -> RuntimeObjectInterface? {
        try await self.request {
            try await _interface(for: request.object, options: request.options)
        } remote: { senderConnection in
            return try await senderConnection.sendMessage(name: .runtimeInterfaceForRuntimeObjectInImageWithOptions, request: InterfaceRequest(object: request.object, options: request.options))
        }
    }

    public func objects(in image: String) async throws -> [RuntimeObject] {
        try await request {
            try await _objects(in: image)
        } remote: {
            return try await $0.sendMessage(name: .runtimeObjectsInImage, request: image)
        }
    }

    public func hierarchy(for object: RuntimeObject) async throws -> [String] {
        try await request { () -> [String] in
            switch object.kind {
            case .c:
                return []
            case .objc:
                return try await objcSectionFactory.existingSection(for: object.imagePath)?.classHierarchy(for: object) ?? []
            case .swift:
                return try await swiftSectionFactory.existingSection(for: object.imagePath)?.classHierarchy(for: object) ?? []
            }
        } remote: {
            return try await $0.sendMessage(name: .runtimeObjectHierarchy, request: object)
        }
    }
}

extension RuntimeConnection {
    fileprivate func sendMessage(name: RuntimeEngine.CommandNames) async throws {
        return try await sendMessage(name: name.commandName)
    }

    fileprivate func sendMessage<Request: Codable>(name: RuntimeEngine.CommandNames, request: Request) async throws {
        return try await sendMessage(name: name.commandName, request: request)
    }

    fileprivate func sendMessage<Response: Codable>(name: RuntimeEngine.CommandNames) async throws -> Response {
        return try await sendMessage(name: name.commandName)
    }

    fileprivate func sendMessage<Response: Codable>(name: RuntimeEngine.CommandNames, request: some Codable) async throws -> Response {
        return try await sendMessage(name: name.commandName, request: request)
    }
}

// MARK: - Export

extension RuntimeEngine {
    public enum RuntimeExportError: Error {
        case interfaceGenerationFailed(RuntimeObject)
    }

    public func exportInterfaces(
        with configuration: RuntimeInterfaceExportConfiguration,
        reporter: RuntimeInterfaceExportReporter
    ) async throws {
        defer { reporter.finish() }
        let startTime = CFAbsoluteTimeGetCurrent()

        reporter.send(.phaseStarted(.preparing))
        let allObjects = try await objects(in: configuration.imagePath)
        reporter.send(.phaseCompleted(.preparing))

        reporter.send(.phaseStarted(.exporting))
        var results: [RuntimeInterfaceExportItem] = []
        var succeeded = 0
        var failed = 0
        var objcCount = 0
        var swiftCount = 0
        let total = allObjects.count

        for (index, object) in allObjects.enumerated() {
            try Task.checkCancellation()
            reporter.send(.objectStarted(object, current: index + 1, total: total))
            do {
                guard let runtimeInterface = try await interface(for: object, options: configuration.generationOptions) else {
                    throw RuntimeExportError.interfaceGenerationFailed(object)
                }
                let item = RuntimeInterfaceExportItem(
                    object: object,
                    plainText: runtimeInterface.interfaceString.string,
                    suggestedFileName: object.exportFileName
                )
                results.append(item)
                succeeded += 1
                if item.isSwift { swiftCount += 1 } else { objcCount += 1 }
                reporter.send(.objectCompleted(object, runtimeInterface.interfaceString))
            } catch {
                failed += 1
                reporter.send(.objectFailed(object, error))
            }
        }
        reporter.send(.phaseCompleted(.exporting))

        reporter.send(.phaseStarted(.writing))

        let objcItems = results.filter { !$0.isSwift }
        let swiftItems = results.filter { $0.isSwift }

        if !objcItems.isEmpty {
            switch configuration.objcFormat {
            case .singleFile:
                try RuntimeInterfaceExportWriter.writeSingleFile(
                    items: objcItems,
                    to: configuration.directory,
                    imageName: configuration.imageName
                )
            case .directory:
                try RuntimeInterfaceExportWriter.writeDirectory(
                    items: objcItems,
                    to: configuration.directory
                )
            }
        }

        if !swiftItems.isEmpty {
            switch configuration.swiftFormat {
            case .singleFile:
                try RuntimeInterfaceExportWriter.writeSingleFile(
                    items: swiftItems,
                    to: configuration.directory,
                    imageName: configuration.imageName
                )
            case .directory:
                try RuntimeInterfaceExportWriter.writeDirectory(
                    items: swiftItems,
                    to: configuration.directory
                )
            }
        }

        reporter.send(.phaseCompleted(.writing))

        let duration = CFAbsoluteTimeGetCurrent() - startTime
        let result = RuntimeInterfaceExportResult(
            succeeded: succeeded,
            failed: failed,
            totalDuration: duration,
            objcCount: objcCount,
            swiftCount: swiftCount
        )
        reporter.send(.completed(result))
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Transformer/Transformer+CType.swift`:

```swift
import Foundation
import MetaCodable
public import Semantic

// MARK: - C Type Transformer Module

extension Transformer {
    /// Replaces C primitive types with custom types.
    ///
    /// Example:
    /// ```swift
    /// var module = Transformer.CType()
    /// module.isEnabled = true
    /// module.replacements[.double] = "CGFloat"
    /// module.replacements[.longLong] = "NSInteger"
    /// ```
    @Codable
    public struct CType: Module {
        public typealias Parameter = Pattern
        public typealias Input = SemanticString
        public typealias Output = SemanticString

        public static let displayName = "C Type Replacement"

        @Default(ifMissing: false)
        public var isEnabled: Bool

        @Default(ifMissing: [:])
        public var replacements: [Pattern: String]

        public init(isEnabled: Bool = false, replacements: [Pattern: String] = [:]) {
            self.isEnabled = isEnabled
            self.replacements = replacements
        }

        public func transform(_ input: SemanticString) -> SemanticString {
            let sorted = sortedReplacements
            guard !sorted.isEmpty else { return input }

            let components = input.components
            guard !components.isEmpty else { return input }

            var result: [AtomicComponent] = []
            var index = 0

            while index < components.count {
                if let (replacement, consumed) = match(in: components, at: index, patterns: sorted) {
                    result.append(AtomicComponent(string: replacement, type: .type(.other, .name)))
                    index += consumed
                } else {
                    result.append(components[index])
                    index += 1
                }
            }

            return SemanticString(components: result)
        }

        // Sorted by pattern length (longest first)
        private var sortedReplacements: [(Pattern, String)] {
            replacements
                .filter { !$0.value.isEmpty }
                .sorted { $0.key.keywords.count > $1.key.keywords.count }
                .map { ($0.key, $0.value) }
        }

        private func match(
            in components: [AtomicComponent],
            at startIndex: Int,
            patterns: [(Pattern, String)]
        ) -> (String, Int)? {
            for (pattern, replacement) in patterns {
                if let consumed = matchKeywords(pattern.keywords, in: components, at: startIndex) {
                    return (replacement, consumed)
                }
            }
            return nil
        }

        private func matchKeywords(
            _ keywords: [String],
            in components: [AtomicComponent],
            at startIndex: Int
        ) -> Int? {
            guard !keywords.isEmpty else { return nil }

            var ci = startIndex
            var ki = 0
            var consumed = 0

            while ki < keywords.count && ci < components.count {
                let c = components[ci]

                // Skip whitespace
                if c.type == .standard && c.string.allSatisfy(\.isWhitespace) {
                    ci += 1
                    consumed += 1
                    continue
                }

                guard c.type == .keyword, c.string == keywords[ki] else { return nil }

                ki += 1
                ci += 1
                consumed += 1
            }

            return ki == keywords.count ? consumed : nil
        }
    }
}

// MARK: - Pattern

extension Transformer.CType {
    /// C primitive type patterns.
    public enum Pattern: String, CaseIterable, Codable, Sendable, Hashable {
        case char
        case uchar
        case short
        case ushort
        case int
        case uint
        case long
        case ulong
        case longLong
        case ulongLong
        case float
        case double
        case longDouble

        public var displayName: String {
            switch self {
            case .char: "char"
            case .uchar: "unsigned char"
            case .short: "short"
            case .ushort: "unsigned short"
            case .int: "int"
            case .uint: "unsigned int"
            case .long: "long"
            case .ulong: "unsigned long"
            case .longLong: "long long"
            case .ulongLong: "unsigned long long"
            case .float: "float"
            case .double: "double"
            case .longDouble: "long double"
            }
        }

        var keywords: [String] {
            switch self {
            case .char: ["char"]
            case .uchar: ["unsigned", "char"]
            case .short: ["short"]
            case .ushort: ["unsigned", "short"]
            case .int: ["int"]
            case .uint: ["unsigned", "int"]
            case .long: ["long"]
            case .ulong: ["unsigned", "long"]
            case .longLong: ["long", "long"]
            case .ulongLong: ["unsigned", "long", "long"]
            case .float: ["float"]
            case .double: ["double"]
            case .longDouble: ["long", "double"]
            }
        }
    }
}

// MARK: - Presets

extension Transformer.CType {
    public enum Presets {
        public static let stdint: [Pattern: String] = [
            .uchar: "uint8_t",
            .ushort: "uint16_t",
            .uint: "uint32_t",
            .ulong: "uint64_t",
            .ulongLong: "uint64_t",
            
            .char: "int8_t",
            .short: "int16_t",
            .int: "int32_t",
            .long: "int64_t",
            .longLong: "int64_t",
        ]

        public static let foundation: [Pattern: String] = [
            .double: "CGFloat",
            .long: "NSInteger",
            .ulong: "NSUInteger",
            .longLong: "NSInteger",
            .ulongLong: "NSUInteger",
        ]
        
        public static let mixed: [Pattern: String] = [
            .uchar: "uint8_t",
            .ushort: "uint16_t",
            .uint: "uint32_t",
            .char: "int8_t",
            .short: "int16_t",
            .int: "int32_t",
            .long: "NSInteger",
            .ulong: "NSUInteger",
            .longLong: "NSInteger",
            .ulongLong: "NSUInteger",
            .double: "CGFloat",
        ]
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Transformer/Transformer+SwiftEnumLayout.swift`:

```swift
import Foundation
import MetaCodable
import Semantic

// MARK: - Swift Enum Layout Transformer Module

extension Transformer {
    /// Customizes Swift enum layout comment format using token templates.
    ///
    /// Supports two template levels:
    /// - `template`: Controls the strategy header comment (e.g., "Multi-Payload (Spare Bits)")
    /// - `caseTemplate`: Controls the per-case header comment (e.g., "Case 0 (0x00) - Payload Case 0:")
    ///
    /// Memory change details per case are kept unchanged.
    @Codable
    public struct SwiftEnumLayout: Module {
        public typealias Parameter = Token
        public typealias Output = String

        public static let displayName = "Enum Layout Comment"

        @Default(ifMissing: false)
        public var isEnabled: Bool

        @Default(ifMissing: Templates.strategyOnly)
        public var template: String

        @Default(ifMissing: CaseTemplates.standard)
        public var caseTemplate: String

        @Default(ifMissing: false)
        public var useHexadecimal: Bool

        @Default(ifMissing: MemoryOffsetTemplates.standard)
        public var memoryOffsetTemplate: String

        public init(
            isEnabled: Bool = false,
            template: String = Templates.strategyOnly,
            caseTemplate: String = CaseTemplates.standard,
            useHexadecimal: Bool = false,
            memoryOffsetTemplate: String = MemoryOffsetTemplates.standard
        ) {
            self.isEnabled = isEnabled
            self.template = template
            self.caseTemplate = caseTemplate
            self.useHexadecimal = useHexadecimal
            self.memoryOffsetTemplate = memoryOffsetTemplate
        }

        /// Renders the strategy header template with actual enum layout values.
        public func transform(_ input: Input) -> String {
            var result = template
            result = result.replacingOccurrences(of: Token.strategy.placeholder, with: input.strategy)
            result = result.replacingOccurrences(of: Token.bitsNeededForTag.placeholder, with: formatNumeric(input.bitsNeededForTag))
            result = result.replacingOccurrences(of: Token.bitsAvailableForPayload.placeholder, with: formatNumeric(input.bitsAvailableForPayload))
            result = result.replacingOccurrences(of: Token.numTags.placeholder, with: formatNumeric(input.numTags))
            result = result.replacingOccurrences(of: Token.totalCases.placeholder, with: formatNumeric(input.totalCases))
            result = result.replacingOccurrences(of: Token.payloadCaseCount.placeholder, with: formatNumeric(input.payloadCaseCount))
            result = result.replacingOccurrences(of: Token.emptyCaseCount.placeholder, with: formatNumeric(input.emptyCaseCount))
            result = result.replacingOccurrences(of: Token.tagRegionRange.placeholder, with: input.tagRegionRange)
            result = result.replacingOccurrences(of: Token.tagRegionBitCount.placeholder, with: formatNumeric(input.tagRegionBitCount))
            result = result.replacingOccurrences(of: Token.tagRegionBytesHex.placeholder, with: input.tagRegionBytesHex)
            result = result.replacingOccurrences(of: Token.payloadRegionRange.placeholder, with: input.payloadRegionRange)
            result = result.replacingOccurrences(of: Token.payloadRegionBitCount.placeholder, with: formatNumeric(input.payloadRegionBitCount))
            result = result.replacingOccurrences(of: Token.payloadRegionBytesHex.placeholder, with: input.payloadRegionBytesHex)
            return result
        }

        /// Renders the per-case template with actual case values.
        public func transformCase(_ input: CaseInput) -> String {
            var result = caseTemplate
            result = result.replacingOccurrences(of: CaseToken.caseIndex.placeholder, with: formatNumeric(input.caseIndex))
            result = result.replacingOccurrences(of: CaseToken.caseHex.placeholder, with: String(format: "0x%02X", input.caseIndex))
            result = result.replacingOccurrences(of: CaseToken.caseName.placeholder, with: input.caseName)
            result = result.replacingOccurrences(of: CaseToken.tagValue.placeholder, with: formatNumeric(input.tagValue))
            result = result.replacingOccurrences(of: CaseToken.payloadValue.placeholder, with: formatNumeric(input.payloadValue))
            result = result.replacingOccurrences(of: CaseToken.tagHex.placeholder, with: input.tagHex)
            result = result.replacingOccurrences(of: CaseToken.payloadHex.placeholder, with: input.payloadHex)
            result = result.replacingOccurrences(of: CaseToken.tagValueBinary.placeholder, with: input.tagValueBinary)
            result = result.replacingOccurrences(of: CaseToken.payloadValueBinary.placeholder, with: input.payloadValueBinary)
            result = result.replacingOccurrences(of: CaseToken.caseType.placeholder, with: input.caseType)
            result = result.replacingOccurrences(of: CaseToken.memoryChangeCount.placeholder, with: formatNumeric(input.memoryChangeCount))
            result = result.replacingOccurrences(of: CaseToken.memoryChangesDetail.placeholder, with: input.memoryChangesDetail)
            return result
        }

        /// Renders the per-memory-offset template with actual offset values.
        public func transformMemoryOffset(_ input: MemoryOffsetInput) -> String {
            var result = memoryOffsetTemplate
            result = result.replacingOccurrences(of: MemoryOffsetToken.offset.placeholder, with: formatNumeric(input.offset))
            result = result.replacingOccurrences(of: MemoryOffsetToken.offsetHex.placeholder, with: String(format: "0x%02X", input.offset))
            result = result.replacingOccurrences(of: MemoryOffsetToken.value.placeholder, with: formatNumeric(Int(input.value)))
            result = result.replacingOccurrences(of: MemoryOffsetToken.valueHex.placeholder, with: String(format: "0x%02X", input.value))
            result = result.replacingOccurrences(of: MemoryOffsetToken.valueBinaryRaw.placeholder, with: input.valueBinaryRaw)
            result = result.replacingOccurrences(of: MemoryOffsetToken.valueBinary.placeholder, with: input.valueBinary)
            result = result.replacingOccurrences(of: MemoryOffsetToken.valueBinaryPaddedRaw.placeholder, with: input.valueBinaryPaddedRaw)
            result = result.replacingOccurrences(of: MemoryOffsetToken.valueBinaryPadded.placeholder, with: input.valueBinaryPadded)
            return result
        }

        private func formatNumeric(_ value: Int) -> String {
            useHexadecimal ? "0x\(String(value, radix: 16, uppercase: true))" : String(value)
        }

        /// Checks if the strategy template contains a specific token.
        public func contains(_ token: Token) -> Bool {
            template.contains(token.placeholder)
        }

        /// Checks if the case template contains a specific case token.
        public func containsCase(_ token: CaseToken) -> Bool {
            caseTemplate.contains(token.placeholder)
        }

        /// Checks if the memory offset template contains a specific token.
        public func containsMemoryOffset(_ token: MemoryOffsetToken) -> Bool {
            memoryOffsetTemplate.contains(token.placeholder)
        }
    }
}

// MARK: - Input (Strategy Header)

extension Transformer.SwiftEnumLayout {
    /// Input for strategy header transformation.
    public struct Input: Sendable {
        public let strategy: String
        public let bitsNeededForTag: Int
        public let bitsAvailableForPayload: Int
        public let numTags: Int
        public let totalCases: Int
        public let payloadCaseCount: Int
        public let emptyCaseCount: Int
        public let tagRegionRange: String
        public let tagRegionBitCount: Int
        public let tagRegionBytesHex: String
        public let payloadRegionRange: String
        public let payloadRegionBitCount: Int
        public let payloadRegionBytesHex: String

        public init(
            strategy: String,
            bitsNeededForTag: Int,
            bitsAvailableForPayload: Int,
            numTags: Int,
            totalCases: Int = 0,
            payloadCaseCount: Int = 0,
            emptyCaseCount: Int = 0,
            tagRegionRange: String = "N/A",
            tagRegionBitCount: Int = 0,
            tagRegionBytesHex: String = "N/A",
            payloadRegionRange: String = "N/A",
            payloadRegionBitCount: Int = 0,
            payloadRegionBytesHex: String = "N/A"
        ) {
            self.strategy = strategy
            self.bitsNeededForTag = bitsNeededForTag
            self.bitsAvailableForPayload = bitsAvailableForPayload
            self.numTags = numTags
            self.totalCases = totalCases
            self.payloadCaseCount = payloadCaseCount
            self.emptyCaseCount = emptyCaseCount
            self.tagRegionRange = tagRegionRange
            self.tagRegionBitCount = tagRegionBitCount
            self.tagRegionBytesHex = tagRegionBytesHex
            self.payloadRegionRange = payloadRegionRange
            self.payloadRegionBitCount = payloadRegionBitCount
            self.payloadRegionBytesHex = payloadRegionBytesHex
        }
    }
}

// MARK: - Case Input

extension Transformer.SwiftEnumLayout {
    /// Input for per-case transformation.
    public struct CaseInput: Sendable {
        public let caseIndex: Int
        public let caseName: String
        public let tagValue: Int
        public let payloadValue: Int
        public let tagHex: String
        public let payloadHex: String
        public let tagValueBinary: String
        public let payloadValueBinary: String
        public let caseType: String
        public let memoryChangeCount: Int
        public let memoryChangesDetail: String

        public init(
            caseIndex: Int,
            caseName: String,
            tagValue: Int,
            payloadValue: Int,
            tagHex: String = "0x00",
            payloadHex: String = "0x00",
            tagValueBinary: String = "0b0",
            payloadValueBinary: String = "0b0",
            caseType: String = "Unknown",
            memoryChangeCount: Int = 0,
            memoryChangesDetail: String = ""
        ) {
            self.caseIndex = caseIndex
            self.caseName = caseName
            self.tagValue = tagValue
            self.payloadValue = payloadValue
            self.tagHex = tagHex
            self.payloadHex = payloadHex
            self.tagValueBinary = tagValueBinary
            self.payloadValueBinary = payloadValueBinary
            self.caseType = caseType
            self.memoryChangeCount = memoryChangeCount
            self.memoryChangesDetail = memoryChangesDetail
        }
    }
}

// MARK: - Memory Offset Input

extension Transformer.SwiftEnumLayout {
    /// Input for per-memory-offset transformation.
    public struct MemoryOffsetInput: Sendable {
        public let offset: Int
        public let value: UInt8
        /// Binary string without prefix (e.g., "1")
        public let valueBinaryRaw: String
        /// Binary string with 0b prefix (e.g., "0b1")
        public let valueBinary: String
        /// Binary string padded to 8 digits without prefix (e.g., "00000001")
        public let valueBinaryPaddedRaw: String
        /// Binary string padded to 8 digits with 0b prefix (e.g., "0b00000001")
        public let valueBinaryPadded: String

        public init(
            offset: Int,
            value: UInt8
        ) {
            self.offset = offset
            self.value = value
            let binaryString = String(value, radix: 2)
            let paddedBinaryString = String(repeating: "0", count: 8 - binaryString.count) + binaryString
            self.valueBinaryRaw = binaryString
            self.valueBinary = "0b\(binaryString)"
            self.valueBinaryPaddedRaw = paddedBinaryString
            self.valueBinaryPadded = "0b\(paddedBinaryString)"
        }
    }
}

// MARK: - Token (Strategy Header)

extension Transformer.SwiftEnumLayout {
    /// Available tokens for strategy header templates.
    public enum Token: String, CaseIterable, Sendable {
        case strategy
        case bitsNeededForTag
        case bitsAvailableForPayload
        case numTags
        case totalCases
        case payloadCaseCount
        case emptyCaseCount
        case tagRegionRange
        case tagRegionBitCount
        case tagRegionBytesHex
        case payloadRegionRange
        case payloadRegionBitCount
        case payloadRegionBytesHex

        public var placeholder: String { "${\(rawValue)}" }
        public var displayName: String {
            switch self {
            case .strategy: "Strategy"
            case .bitsNeededForTag: "Bits Needed For Tag"
            case .bitsAvailableForPayload: "Bits Available For Payload"
            case .numTags: "Number of Tags"
            case .totalCases: "Total Cases"
            case .payloadCaseCount: "Payload Case Count"
            case .emptyCaseCount: "Empty Case Count"
            case .tagRegionRange: "Tag Region Range"
            case .tagRegionBitCount: "Tag Region Bit Count"
            case .tagRegionBytesHex: "Tag Region Bytes (Hex)"
            case .payloadRegionRange: "Payload Region Range"
            case .payloadRegionBitCount: "Payload Region Bit Count"
            case .payloadRegionBytesHex: "Payload Region Bytes (Hex)"
            }
        }
    }
}

// MARK: - Memory Offset Token

extension Transformer.SwiftEnumLayout {
    /// Available tokens for per-memory-offset templates.
    public enum MemoryOffsetToken: String, CaseIterable, Sendable {
        case offset
        case offsetHex
        case value
        case valueHex
        case valueBinaryRaw
        case valueBinary
        case valueBinaryPaddedRaw
        case valueBinaryPadded

        public var placeholder: String { "${\(rawValue)}" }
        public var displayName: String {
            switch self {
            case .offset: "Offset"
            case .offsetHex: "Offset (Hex)"
            case .value: "Value"
            case .valueHex: "Value (Hex)"
            case .valueBinaryRaw: "Value (Binary Raw)"
            case .valueBinary: "Value (Binary)"
            case .valueBinaryPaddedRaw: "Value (Binary Padded Raw)"
            case .valueBinaryPadded: "Value (Binary Padded)"
            }
        }
    }
}

// MARK: - Case Token

extension Transformer.SwiftEnumLayout {
    /// Available tokens for per-case templates.
    public enum CaseToken: String, CaseIterable, Sendable {
        case caseIndex
        case caseHex
        case caseName
        case tagValue
        case payloadValue
        case tagHex
        case payloadHex
        case tagValueBinary
        case payloadValueBinary
        case caseType
        case memoryChangeCount
        case memoryChangesDetail

        public var placeholder: String { "${\(rawValue)}" }
        public var displayName: String {
            switch self {
            case .caseIndex: "Case Index"
            case .caseHex: "Case Hex"
            case .caseName: "Case Name"
            case .tagValue: "Tag Value"
            case .payloadValue: "Payload Value"
            case .tagHex: "Tag Hex"
            case .payloadHex: "Payload Hex"
            case .tagValueBinary: "Tag Value (Binary)"
            case .payloadValueBinary: "Payload Value (Binary)"
            case .caseType: "Case Type"
            case .memoryChangeCount: "Memory Change Count"
            case .memoryChangesDetail: "Memory Changes Detail"
            }
        }
    }
}

// MARK: - Templates (Strategy Header)

extension Transformer.SwiftEnumLayout {
    public enum Templates {
        /// Standard style: "Multi-Payload (Spare Bits + Occupied Bits Overflow) (Tags: 3, Tag Bits: 2)"
        public static let standard = "${strategy} (Tags: ${numTags}, Tag Bits: ${bitsNeededForTag})"

        /// Verbose style: "Multi-Payload (Spare Bits + Occupied Bits Overflow) (Tags: 3, Tag Bits: 2, Payload Bits: 62)"
        public static let verbose = "${strategy} (Tags: ${numTags}, Tag Bits: ${bitsNeededForTag}, Payload Bits: ${bitsAvailableForPayload})"

        /// Strategy only: "Multi-Payload (Spare Bits + Occupied Bits Overflow)"
        public static let strategyOnly = "${strategy}"

        /// Compact style: "Tags: 3, Bits: 2"
        public static let compact = "Tags: ${numTags}, Bits: ${bitsNeededForTag}"

        /// Technical style with tag/payload/case counts
        public static let technical = "${strategy}\nTags: ${numTags} (${bitsNeededForTag}-bit), Payload: ${bitsAvailableForPayload}-bit, Cases: ${totalCases}"

        /// Region detail style showing tag and payload memory regions
        public static let regions = "${strategy}\nTag Region: ${tagRegionRange} (${tagRegionBitCount} bits)\nPayload Region: ${payloadRegionRange} (${payloadRegionBitCount} bits)"

        /// Summary style: strategy with case and tag counts
        public static let summary = "${strategy} â€” ${totalCases} cases, ${numTags} tags"

        /// Bits-focused style showing bit allocation
        public static let bits = "Tag: ${bitsNeededForTag} bits, Payload: ${bitsAvailableForPayload} bits (${numTags} tags)"

        /// Case breakdown style showing payload vs empty case counts
        public static let caseBreakdown = "${strategy} â€” ${payloadCaseCount} payload + ${emptyCaseCount} empty = ${totalCases} cases"

        /// Full detail style with regions and byte patterns
        public static let fullDetail = "${strategy}\nTags: ${numTags} (${bitsNeededForTag}-bit), Payload: ${bitsAvailableForPayload}-bit\nTag Region: ${tagRegionRange} (${tagRegionBitCount} bits) [${tagRegionBytesHex}]\nPayload Region: ${payloadRegionRange} (${payloadRegionBitCount} bits) [${payloadRegionBytesHex}]\nCases: ${payloadCaseCount} payload + ${emptyCaseCount} empty"

        public static let all: [(name: String, template: String)] = [
            ("Standard", standard),
            ("Verbose", verbose),
            ("Strategy Only", strategyOnly),
            ("Compact", compact),
            ("Technical", technical),
            ("Regions", regions),
            ("Summary", summary),
            ("Bits", bits),
            ("Case Breakdown", caseBreakdown),
            ("Full Detail", fullDetail),
        ]
    }
}

// MARK: - Memory Offset Templates

extension Transformer.SwiftEnumLayout {
    public enum MemoryOffsetTemplates {
        /// Standard style: "Memory Offset 0 (0x00) = 0x01 (Bin: 00000001)"
        public static let standard = "Memory Offset ${offset} (${offsetHex}) = ${valueHex} (Bin: ${valueBinaryPaddedRaw})"

        /// Compact style: "[0]=0x01"
        public static let compact = "[${offset}]=${valueHex}"

        /// Hex only style: "0x00: 0x01"
        public static let hexOnly = "${offsetHex}: ${valueHex}"

        /// Binary style: "Offset 0: 0b00000001"
        public static let binary = "Offset ${offset}: ${valueBinaryPadded}"

        /// Verbose style: "Offset 0 (0x00) = 1 (0x01, 0b00000001)"
        public static let verbose = "Offset ${offset} (${offsetHex}) = ${value} (${valueHex}, ${valueBinaryPadded})"

        /// Minimal style: "0: 0x01"
        public static let minimal = "${offset}: ${valueHex}"

        public static let all: [(name: String, template: String)] = [
            ("Standard", standard),
            ("Compact", compact),
            ("Hex Only", hexOnly),
            ("Binary", binary),
            ("Verbose", verbose),
            ("Minimal", minimal),
        ]
    }
}

// MARK: - Case Templates

extension Transformer.SwiftEnumLayout {
    public enum CaseTemplates {
        /// Standard style: "Case 0 (0x00) - Payload Case 0:\nTag: 0"
        public static let standard = "Case ${caseIndex} (${caseHex}) - ${caseName}:\nTag: ${tagValue}"

        /// Verbose style includes payload value: "Case 0 (0x00) - Payload Case 0:\nTag: 0, PayloadValue: 0"
        public static let verbose = "Case ${caseIndex} (${caseHex}) - ${caseName}:\nTag: ${tagValue}, PayloadValue: ${payloadValue}"

        /// Compact style: "[0] Payload Case 0 (tag: 0)"
        public static let compact = "[${caseIndex}] ${caseName} (tag: ${tagValue})"

        /// Index only: "Case 0: Tag 0"
        public static let indexOnly = "Case ${caseIndex}: Tag ${tagValue}"

        /// Hex-all style with tag and payload hex values
        public static let hexAll = "Case ${caseHex}: ${caseName} [tag=${tagHex}, payload=${payloadHex}]"

        /// Named style with case type and tag
        public static let named = "${caseName} (${caseType}, tag: ${tagValue})"

        /// Detailed style with all available information
        public static let detailed = "Case ${caseIndex} (${caseHex}) - ${caseName}:\nType: ${caseType}, Tag: ${tagValue} (${tagHex}), Payload: ${payloadValue} (${payloadHex})\nMemory Changes: ${memoryChangeCount} bytes"

        /// Memory-focused style showing byte change count
        public static let memory = "[${caseHex}] ${caseName} â€” ${memoryChangeCount} byte(s) changed"

        /// Binary style showing tag and payload in binary representation
        public static let binary = "Case ${caseIndex}: ${caseName}\nTag: ${tagValueBinary} (${tagHex}), Payload: ${payloadValueBinary} (${payloadHex})"

        /// Memory detail style with per-offset byte changes
        public static let memoryDetail = "Case ${caseIndex} (${caseHex}) - ${caseName} [${caseType}]:\nTag: ${tagValue} (${tagHex}), Payload: ${payloadValue} (${payloadHex})\n${memoryChangesDetail}"

        public static let all: [(name: String, template: String)] = [
            ("Standard", standard),
            ("Verbose", verbose),
            ("Compact", compact),
            ("Index Only", indexOnly),
            ("Hex All", hexAll),
            ("Named", named),
            ("Detailed", detailed),
            ("Memory", memory),
            ("Binary", binary),
            ("Memory Detail", memoryDetail),
        ]
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Transformer/Transformer+SwiftFieldOffset.swift`:

```swift
import Foundation
import MetaCodable
import Semantic

// MARK: - Swift Field Offset Transformer Module

extension Transformer {
    /// Customizes Swift field offset comment format using token templates.
    ///
    /// Available tokens:
    /// - `${startOffset}` - Field start offset
    /// - `${endOffset}` - Field end offset
    ///
    /// Example:
    /// ```swift
    /// var module = Transformer.FieldOffset()
    /// module.isEnabled = true
    /// module.template = "${startOffset} ..< ${endOffset}"  // "0 ..< 8"
    /// module.template = "offset: ${startOffset}"           // "offset: 0"
    /// ```
    @Codable
    public struct SwiftFieldOffset: Module {
        public typealias Parameter = Token
        public typealias Output = String

        public static let displayName = "Swift Field Offset Comment"

        @Default(ifMissing: false)
        public var isEnabled: Bool

        @Default(ifMissing: Templates.standard)
        public var template: String

        @Default(ifMissing: true)
        public var useHexadecimal: Bool

        public init(isEnabled: Bool = false, template: String = Templates.standard, useHexadecimal: Bool = true) {
            self.isEnabled = isEnabled
            self.template = template
            self.useHexadecimal = useHexadecimal
        }

        /// Renders the template with actual offset values.
        ///
        /// When `endOffset` is `nil` (last field in a type), the `${endOffset}` token
        /// is replaced with `"?"`.
        public func transform(_ input: Input) -> String {
            template
                .replacingOccurrences(of: Token.startOffset.placeholder, with: formatValue(input.startOffset))
                .replacingOccurrences(of: Token.endOffset.placeholder, with: input.endOffset.map(formatValue) ?? "?")
        }

        private func formatValue(_ value: Int) -> String {
            useHexadecimal ? "0x\(String(value, radix: 16, uppercase: true))" : String(value)
        }

        /// Checks if the template contains a specific token.
        public func contains(_ token: Token) -> Bool {
            template.contains(token.placeholder)
        }
    }
}

// MARK: - Input

extension Transformer.SwiftFieldOffset {
    /// Input for field offset transformation.
    public struct Input: Sendable {
        public let startOffset: Int
        public let endOffset: Int?

        public init(startOffset: Int, endOffset: Int?) {
            self.startOffset = startOffset
            self.endOffset = endOffset
        }
    }
}

// MARK: - Token

extension Transformer.SwiftFieldOffset {
    /// Available tokens for field offset templates.
    public enum Token: String, CaseIterable, Sendable {
        case startOffset
        case endOffset

        public var placeholder: String { "${\(rawValue)}" }
        public var displayName: String {
            switch self {
            case .startOffset: "Start Offset"
            case .endOffset: "End Offset"
            }
        }
    }
}

// MARK: - Templates

extension Transformer.SwiftFieldOffset {
    public enum Templates {
        /// Default style matching non-transformed output: "Field Offset: 0x0"
        public static let standard = "Field Offset: ${startOffset}"

        /// Range style: "0 ..< 8"
        public static let range = "${startOffset} ..< ${endOffset}"

        /// Labeled style: "offset: 0"
        public static let labeled = "offset: ${startOffset}"

        /// Interval style: "[0, 8)"
        public static let interval = "[${startOffset}, ${endOffset})"

        /// Start only: "0"
        public static let startOnly = "${startOffset}"

        public static let all: [(name: String, template: String)] = [
            ("Standard", standard),
            ("Range", range),
            ("Labeled", labeled),
            ("Interval", interval),
            ("Start Only", startOnly),
        ]
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Transformer/Transformer+SwiftTypeLayout.swift`:

```swift
import Foundation
import MetaCodable
import Semantic

// MARK: - Swift Type Layout Comment Transformer Module

extension Transformer {
    /// Customizes Swift type layout comment format using token templates.
    ///
    /// Available tokens:
    /// - `${size}` - Type size in bytes
    /// - `${stride}` - Type stride in bytes
    /// - `${alignment}` - Type alignment
    /// - `${extraInhabitantCount}` - Extra inhabitant count
    /// - `${isPOD}` - Whether the type is plain old data
    /// - `${isInlineStorage}` - Whether the type uses inline storage
    /// - `${isBitwiseTakable}` - Whether the type is bitwise takable
    /// - `${isBitwiseBorrowable}` - Whether the type is bitwise borrowable
    /// - `${isCopyable}` - Whether the type is copyable
    /// - `${hasEnumWitnesses}` - Whether the type has enum witnesses
    /// - `${isIncomplete}` - Whether the type layout is incomplete
    ///
    /// Example:
    /// ```swift
    /// var module = Transformer.SwiftTypeLayout()
    /// module.isEnabled = true
    /// module.template = "size: ${size}, stride: ${stride}, alignment: ${alignment}"
    /// ```
    @Codable
    public struct SwiftTypeLayout: Module {
        public typealias Parameter = Token
        public typealias Output = String

        public static let displayName = "Type Layout Comment"

        @Default(ifMissing: false)
        public var isEnabled: Bool

        @Default(ifMissing: Templates.standard)
        public var template: String

        @Default(ifMissing: false)
        public var useHexadecimal: Bool

        public init(isEnabled: Bool = false, template: String = Templates.standard, useHexadecimal: Bool = false) {
            self.isEnabled = isEnabled
            self.template = template
            self.useHexadecimal = useHexadecimal
        }

        /// Renders the template with actual type layout values.
        public func transform(_ input: Input) -> String {
            var result = template
            result = result.replacingOccurrences(of: Token.size.placeholder, with: formatNumeric(input.size))
            result = result.replacingOccurrences(of: Token.stride.placeholder, with: formatNumeric(input.stride))
            result = result.replacingOccurrences(of: Token.alignment.placeholder, with: formatNumeric(input.alignment))
            result = result.replacingOccurrences(of: Token.extraInhabitantCount.placeholder, with: formatNumeric(input.extraInhabitantCount))
            result = result.replacingOccurrences(of: Token.isPOD.placeholder, with: String(input.isPOD))
            result = result.replacingOccurrences(of: Token.isInlineStorage.placeholder, with: String(input.isInlineStorage))
            result = result.replacingOccurrences(of: Token.isBitwiseTakable.placeholder, with: String(input.isBitwiseTakable))
            result = result.replacingOccurrences(of: Token.isBitwiseBorrowable.placeholder, with: String(input.isBitwiseBorrowable))
            result = result.replacingOccurrences(of: Token.isCopyable.placeholder, with: String(input.isCopyable))
            result = result.replacingOccurrences(of: Token.hasEnumWitnesses.placeholder, with: String(input.hasEnumWitnesses))
            result = result.replacingOccurrences(of: Token.isIncomplete.placeholder, with: String(input.isIncomplete))
            return result
        }

        private func formatNumeric(_ value: Int) -> String {
            useHexadecimal ? "0x\(String(value, radix: 16, uppercase: true))" : String(value)
        }

        /// Checks if the template contains a specific token.
        public func contains(_ token: Token) -> Bool {
            template.contains(token.placeholder)
        }
    }
}

// MARK: - Input

extension Transformer.SwiftTypeLayout {
    /// Input for type layout transformation.
    public struct Input: Sendable {
        public let size: Int
        public let stride: Int
        public let alignment: Int
        public let extraInhabitantCount: Int
        public let isPOD: Bool
        public let isInlineStorage: Bool
        public let isBitwiseTakable: Bool
        public let isBitwiseBorrowable: Bool
        public let isCopyable: Bool
        public let hasEnumWitnesses: Bool
        public let isIncomplete: Bool

        public init(
            size: Int,
            stride: Int,
            alignment: Int,
            extraInhabitantCount: Int,
            isPOD: Bool,
            isInlineStorage: Bool,
            isBitwiseTakable: Bool,
            isBitwiseBorrowable: Bool,
            isCopyable: Bool,
            hasEnumWitnesses: Bool,
            isIncomplete: Bool
        ) {
            self.size = size
            self.stride = stride
            self.alignment = alignment
            self.extraInhabitantCount = extraInhabitantCount
            self.isPOD = isPOD
            self.isInlineStorage = isInlineStorage
            self.isBitwiseTakable = isBitwiseTakable
            self.isBitwiseBorrowable = isBitwiseBorrowable
            self.isCopyable = isCopyable
            self.hasEnumWitnesses = hasEnumWitnesses
            self.isIncomplete = isIncomplete
        }
    }
}

// MARK: - Token

extension Transformer.SwiftTypeLayout {
    /// Available tokens for type layout templates.
    public enum Token: String, CaseIterable, Sendable {
        case size
        case stride
        case alignment
        case extraInhabitantCount
        case isPOD
        case isInlineStorage
        case isBitwiseTakable
        case isBitwiseBorrowable
        case isCopyable
        case hasEnumWitnesses
        case isIncomplete

        public var placeholder: String { "${\(rawValue)}" }
        public var displayName: String {
            switch self {
            case .size: "Size"
            case .stride: "Stride"
            case .alignment: "Alignment"
            case .extraInhabitantCount: "Extra Inhabitant Count"
            case .isPOD: "Is POD"
            case .isInlineStorage: "Is Inline Storage"
            case .isBitwiseTakable: "Is Bitwise Takable"
            case .isBitwiseBorrowable: "Is Bitwise Borrowable"
            case .isCopyable: "Is Copyable"
            case .hasEnumWitnesses: "Has Enum Witnesses"
            case .isIncomplete: "Is Incomplete"
            }
        }
    }
}

// MARK: - Templates

extension Transformer.SwiftTypeLayout {
    public enum Templates {
        /// Default style matching non-transformed output:
        /// "Type Layout: (size: 8, stride: 8, alignment: 8, extraInhabitantCount: 0)"
        public static let standard = "Type Layout: (size: ${size}, stride: ${stride}, alignment: ${alignment}, extraInhabitantCount: ${extraInhabitantCount})"

        /// Verbose style includes flags:
        /// "Type Layout: (size: 8, stride: 8, alignment: 8, extraInhabitantCount: 0, isPOD: true, ...)"
        public static let verbose = "Type Layout: (size: ${size}, stride: ${stride}, alignment: ${alignment}, extraInhabitantCount: ${extraInhabitantCount}, isPOD: ${isPOD}, isInlineStorage: ${isInlineStorage}, isBitwiseTakable: ${isBitwiseTakable}, isBitwiseBorrowable: ${isBitwiseBorrowable}, isCopyable: ${isCopyable}, hasEnumWitnesses: ${hasEnumWitnesses}, isIncomplete: ${isIncomplete})"

        /// Compact style: "size: 8, stride: 8, align: 8"
        public static let compact = "size: ${size}, stride: ${stride}, align: ${alignment}"

        /// Size only: "8 bytes"
        public static let sizeOnly = "${size} bytes"

        /// Tuple element style matching non-transformed tuple output:
        /// "Layout: (size: 8, stride: 8, alignment: 8, extraInhabitantCount: 0)"
        public static let tupleElement = "Layout: (size: ${size}, stride: ${stride}, alignment: ${alignment}, extraInhabitantCount: ${extraInhabitantCount})"

        public static let all: [(name: String, template: String)] = [
            ("Standard", standard),
            ("Verbose", verbose),
            ("Compact", compact),
            ("Size Only", sizeOnly),
            ("Tuple Element", tupleElement),
        ]
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Transformer/Transformer.swift`:

```swift
import Foundation
import MetaCodable
import Semantic

// MARK: - Transformer Namespace

/// Namespace for all transformer-related types.
public enum Transformer {}

// MARK: - Module Protocol

extension Transformer {
    /// A transformer module that converts input to output.
    ///
    /// Each module defines:
    /// - `Parameter`: Predefined parameters displayed in Settings UI for user configuration.
    /// - `Input`: Input passed by the caller at runtime.
    /// - `Output`: Output returned to the caller.
    ///
    /// To add a new module:
    /// 1. Create a struct conforming to `Transformer.Module`
    /// 2. Add it as a property in the appropriate configuration
    public protocol Module: Codable, Sendable, Hashable {
        /// Predefined parameters, displayed in Settings UI for user configuration.
        associatedtype Parameter: CaseIterable & Hashable & Sendable

        /// Input passed by the caller at runtime.
        associatedtype Input

        /// Output returned to the caller.
        associatedtype Output

        /// Display name for Settings UI.
        static var displayName: String { get }

        /// Whether this module is enabled.
        var isEnabled: Bool { get set }

        /// Applies this module's transformation.
        func transform(_ input: Input) -> Output
    }
}

// MARK: - ObjC Configuration

extension Transformer {
    /// Configuration for ObjC-specific transformer modules.
    @Codable
    public struct ObjCConfiguration: Sendable, Equatable, Hashable {
        @Default(ifMissing: Transformer.CType())
        public var cType: Transformer.CType

        public init(cType: CType = .init()) {
            self.cType = cType
        }
    }
}

// MARK: - Swift Configuration

extension Transformer {
    /// Configuration for Swift-specific transformer modules.
    @Codable
    public struct SwiftConfiguration: Sendable, Equatable, Hashable {
        @Default(ifMissing: Transformer.SwiftFieldOffset())
        public var swiftFieldOffset: Transformer.SwiftFieldOffset
        @Default(ifMissing: Transformer.SwiftTypeLayout())
        public var swiftTypeLayout: Transformer.SwiftTypeLayout
        @Default(ifMissing: Transformer.SwiftEnumLayout())
        public var swiftEnumLayout: Transformer.SwiftEnumLayout

        public init(
            swiftFieldOffset: SwiftFieldOffset = .init(),
            swiftTypeLayout: SwiftTypeLayout = .init(),
            swiftEnumLayout: SwiftEnumLayout = .init()
        ) {
            self.swiftFieldOffset = swiftFieldOffset
            self.swiftTypeLayout = swiftTypeLayout
            self.swiftEnumLayout = swiftEnumLayout
        }
    }
}

// MARK: - Aggregated Configuration

extension Transformer {
    /// Aggregated configuration for all transformer modules (used for persistence).
    @Codable
    public struct Configuration: Sendable, Equatable, Hashable {
        @Default(ifMissing: Transformer.ObjCConfiguration())
        public var objc: Transformer.ObjCConfiguration
        @Default(ifMissing: Transformer.SwiftConfiguration())
        public var swift: Transformer.SwiftConfiguration

        public init(
            objc: ObjCConfiguration = .init(),
            swift: SwiftConfiguration = .init()
        ) {
            self.objc = objc
            self.swift = swift
        }

        /// Whether any module is enabled.
        public var hasEnabledModules: Bool {
            objc.cType.isEnabled || swift.swiftFieldOffset.isEnabled || swift.swiftTypeLayout.isEnabled || swift.swiftEnumLayout.isEnabled
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Utils/DyldUtilities.swift`:

```swift
import DyldPrivate
package import Foundation
import FoundationToolbox
import MachO.dyld
import MachOKit

public struct DyldOpenError: Error {
    public let message: String?
}

@Loggable
package enum DyldUtilities {
    package static let addImageNotification = Notification.Name("com.JH.RuntimeViewerCore.DyldRegisterObserver.addImageNotification")

    package static let removeImageNotification = Notification.Name("com.JH.RuntimeViewerCore.DyldRegisterObserver.removeImageNotification")

    package static func patchImagePathForDyld(_ imagePath: String) -> String {
        guard imagePath.starts(with: "/") else { return imagePath }
        let rootPath = ProcessInfo.processInfo.environment["DYLD_ROOT_PATH"]
        guard let rootPath else { return imagePath }
        return rootPath.appending(imagePath)
    }

    package static func observeDyldRegisterEvents() {
        #log(.info, "Registering dyld image event observers")
        _dyld_register_func_for_add_image { _, _ in
            NotificationCenter.default.post(name: Self.addImageNotification, object: nil)
        }

        _dyld_register_func_for_remove_image { _, _ in
            NotificationCenter.default.post(name: Self.removeImageNotification, object: nil)
        }
        #log(.debug, "Dyld event observers registered")
    }

    package static func imageNames() -> [String] {
        let names = Array((0...)
            .lazy
            .map(_dyld_get_image_name)
            .prefix { $0 != nil }
            .compactMap { $0 }
            .map { String(cString: $0) })
        #log(.debug, "Retrieved \(names.count, privacy: .public) image names from dyld")
        return names
    }

    package func imagePath(for ptr: UnsafeRawPointer) -> String? {
        var info: Dl_info = .init()
        dladdr(ptr, &info)
        guard let imagePath = info.dli_fname.map({ String(cString: $0) }) else { return nil }
        return imagePath
    }
    
    package static func loadImage(at path: String) throws {
        #log(.info, "Loading image at path: \(path, privacy: .public)")
        try path.withCString { cString in
            let handle = dlopen(cString, RTLD_LAZY)
            // get the error and copy it into an object we control since the error is shared
            let errPtr = dlerror()
            let errStr = errPtr.map { String(cString: $0) }
            guard handle != nil else {
                #log(.error, "Failed to load image: \(errStr ?? "unknown error", privacy: .public)")
                throw DyldOpenError(message: errStr)
            }
            #log(.info, "Image loaded successfully")
        }
    }

    private static var dyldSharedCacheImagePathsCache: [String]?
    
    private static func dyldSharedCacheImagePaths() -> [String] {
        if let dyldSharedCacheImagePathsCache {
            #log(.debug, "Using cached dyld shared cache image paths (\(dyldSharedCacheImagePathsCache.count, privacy: .public) paths)")
            return dyldSharedCacheImagePathsCache
        }
        #log(.debug, "Loading dyld shared cache image paths")
        guard let dyldCache = DyldCacheLoaded.current, let imageInfos = dyldCache.imageInfos else {
            #log(.default, "Failed to load dyld shared cache or image infos")
            return []
        }
        let results = imageInfos.compactMap { $0.path(in: dyldCache) }
        dyldSharedCacheImagePathsCache = results
        #log(.info, "Loaded \(results.count, privacy: .public) dyld shared cache image paths")
        return results
    }

    package static func invalidDyldSharedCacheImagePathsCache() {
        #log(.debug, "Invalidating dyld shared cache image paths cache")
        dyldSharedCacheImagePathsCache = nil
    }

    package static var dyldSharedCacheImageRootNode: RuntimeImageNode {
        #log(.debug, "Building dyld shared cache image root node")
        let paths = dyldSharedCacheImagePaths()
        let node = RuntimeImageNode.rootNode(for: paths, name: "Dyld Shared Cache")
        #log(.debug, "Built dyld shared cache root node with \(paths.count, privacy: .public) images")
        return node
    }

    package static var otherImageRootNode: RuntimeImageNode {
        #log(.debug, "Building other image root node")
        let dyldSharedCacheImagePaths = dyldSharedCacheImagePaths()
        let allImagePaths = imageNames()
        let otherImagePaths = allImagePaths.filter { !dyldSharedCacheImagePaths.contains($0) }
        let node = RuntimeImageNode.rootNode(for: otherImagePaths, name: "Others")
        #log(.debug, "Built other images root node with \(otherImagePaths.count, privacy: .public) images")
        return node
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Utils/ObjCDump+SemanticString.swift`:

```swift
import Foundation
import Semantic
import ObjCDump
import ObjCTypeDecodeKit
import MemberwiseInit

@MemberwiseInit()
final class ObjCDumpContext {
    var options: ObjCGenerationOptions
    var cTypeReplacements: [Transformer.CType.Pattern: String] = [:]
    var currentArray: SemanticString?
    var isExpandHandler: (_ name: String?, _ isStruct: Bool) -> Bool = { _, _ in true }
}

extension ObjCClassInfo {
    @SemanticStringBuilder
    func semanticString(using context: ObjCDumpContext) -> SemanticString {
        Keyword("@interface")
        Space()
        TypeDeclaration(kind: .class, name)

        if let superClassName {
            " : "
            TypeName(kind: .class, superClassName)
        }

        Joined(separator: ", ", prefix: " <", suffix: ">") {
            for `protocol` in protocols {
                TypeName(kind: .protocol, `protocol`.name)
            }
        }

        Joined {
            MemberList(level: 1) {
                for ivar in ivars {
                    ivar.semanticString(using: context)
                }
            }
        } prefix: {
            Space()
            "{"
        } suffix: {
            "}"
        }

        BreakLine()

        Joined(suffix: BreakLine()) {
            BlockList {
                for property in classProperties {
                    property.semanticString(using: context)
                }
            }
            BlockList {
                for property in properties {
                    property.semanticString(using: context)
                }
            }
            BlockList {
                for method in classMethods {
                    method.semanticString(using: context)
                }
            }
            BlockList {
                for method in methods {
                    method.semanticString(using: context)
                }
            }
        }

        Keyword("@end")
    }
}

extension ObjCProtocolInfo {
    @SemanticStringBuilder
    func semanticString(using context: ObjCDumpContext) -> SemanticString {
        Keyword("@protocol")
        Space()
        TypeDeclaration(kind: .protocol, name)

        Joined(separator: ", ", prefix: " <", suffix: ">") {
            for `protocol` in protocols {
                TypeName(kind: .protocol, `protocol`.name)
            }
        }

        BreakLine()

        Joined(separator: BreakLine(), prefix: BreakLine(), suffix: BreakLine()) {
            Joined {
                BlockList {
                    for property in classProperties {
                        property.semanticString(using: context)
                    }
                }
                BlockList {
                    for property in properties {
                        property.semanticString(using: context)
                    }
                }
                BlockList {
                    for method in classMethods {
                        method.semanticString(using: context)
                    }
                }
                BlockList {
                    for method in methods {
                        method.semanticString(using: context)
                    }
                }
            } prefix: {
                Keyword("@required")
                BreakLine()
            }

            Joined {
                BlockList {
                    for property in optionalClassProperties {
                        property.semanticString(using: context)
                    }
                }
                BlockList {
                    for property in optionalProperties {
                        property.semanticString(using: context)
                    }
                }
                BlockList {
                    for method in optionalClassMethods {
                        method.semanticString(using: context)
                    }
                }
                BlockList {
                    for method in optionalMethods {
                        method.semanticString(using: context)
                    }
                }
            } prefix: {
                Keyword("@optional")
                BreakLine()
            }
        }

        Keyword("@end")
    }
}

extension ObjCCategoryInfo {
    @SemanticStringBuilder
    func semanticString(using context: ObjCDumpContext) -> SemanticString {
        Keyword("@interface")
        Space()
        TypeName(kind: .class, className)
        Space()
        "(\(name))"

        Joined(separator: ", ", prefix: " <", suffix: ">") {
            for `protocol` in protocols {
                TypeName(kind: .protocol, `protocol`.name)
            }
        }

        BreakLine()

        Joined(suffix: BreakLine()) {
            BlockList {
                for property in classProperties {
                    property.semanticString(using: context)
                }
            }

            BlockList {
                for property in properties {
                    property.semanticString(using: context)
                }
            }

            BlockList {
                for method in classMethods {
                    method.semanticString(using: context)
                }
            }

            BlockList {
                for method in methods {
                    method.semanticString(using: context)
                }
            }
        }

        Keyword("@end")
    }
}

extension ObjCIvarInfo {
    @SemanticStringBuilder
    func semanticString(using context: ObjCDumpContext) -> SemanticString {
        if let type, case .bitField(let width) = type {
            ObjCField(type: .int, name: name, bitWidth: width)
                .semanticString(fallbackName: name, context: context)
        } else {
            if [.char, .uchar].contains(type) {
                Keyword("BOOL")
                Space()
                Variable(name)
                ";"
            } else {
                if let type = type?.semanticDecoded(context: context) {
                    type
                    if type.string.last != "*" {
                        Space()
                    }
                    Variable(name)
                    if let currentArray = context.currentArray {
                        currentArray
                        context.currentArray = nil
                    }
                    ";"
                } else {
                    UnknownError()
                    Space()
                    Variable(name)
                    ";"
                }
            }
        }

        if context.options.addIvarOffsetComments {
            Space()
            Comment("offset: \(offset)")
        }
    }
}

extension ObjCPropertyInfo {
    @SemanticStringBuilder
    func semanticString(using context: ObjCDumpContext) -> SemanticString {
        Keyword("@property")

        Joined(separator: ", ", prefix: " (", suffix: ")") {
            if attributes.contains(.nonatomic) {
                Keyword("nonatomic")
            }

            if attributes.contains(.weak) {
                Keyword("weak")
            }

            if attributes.contains(.copy) {
                Keyword("copy")
            }

            if attributes.contains(.retain) {
                Keyword("strong")
            }

            if isClassProperty {
                Keyword("class")
            }

            if let getter = attributes.compactMap(\.getter).first {
                Group {
                    Keyword("getter")
                    "="
                    getter
                }
            }

            if let setter = attributes.compactMap(\.setter).first {
                Group {
                    Keyword("setter")
                    "="
                    setter
                }
            }

            if attributes.contains(.readonly) {
                Keyword("readonly")
            }
        }

        Space()

        let typeString = attributes.compactMap(\.type).first?.semanticDecodedForArgument(context: context)

        if let typeString {
            typeString
            if typeString.string.last != "*" {
                Space()
            }
        } else {
            UnknownError()
            Space()
        }

        MemberDeclaration(name)
        ";"

        if context.options.addPropertyAttributesComments {
            Joined(separator: " ", prefix: " ") {
                if attributes.contains(.dynamic) {
                    Comment("@dynamic \(name)")
                }

                if let ivar {
                    if ivar == name {
                        Comment("@synthesize \(ivar)")
                    } else {
                        Comment("@synthesize \(name) = \(ivar)")
                    }
                }
            }
        }
    }
}

extension ObjCMethodInfo {
    @SemanticStringBuilder
    func semanticString(using context: ObjCDumpContext) -> SemanticString {
        if isClassMethod {
            "+"
        } else {
            "-"
        }

        Space()

        "("
        if let returnType = type?.returnType {
            returnType.semanticDecodedForArgument(context: context)
        } else {
            UnknownError()
        }
        ")"

        let numberOfArguments = name.filter { $0 == ":" }.count

        if numberOfArguments == 0 {
            FunctionDeclaration(name)
        } else {
            let nameAndLabels = name.split(separator: ":")
            let argumentInfos = type?.argumentInfos ?? []

            for (index, label) in nameAndLabels.enumerated() {
                if index > 0 {
                    Space()
                }
                let labelString = String(label)
                FunctionDeclaration(labelString)
                ":"
                "("
                if index < argumentInfos.count {
                    argumentInfos[index].type.semanticDecodedForArgument(context: context)
                } else {
                    UnknownError()
                }
                ")"
                Argument(NamingIntelligent.parameterName(from: labelString))
            }
        }

        ";"
    }
}

extension ObjCField {
    @SemanticStringBuilder
    func semanticString(fallbackName: String, level: Int = 1, context: ObjCDumpContext) -> SemanticString {
        type.semanticDecoded(level: level, context: context)
        Space()
        Variable(name ?? fallbackName)
        if let bitWidth {
            " : "
            Numeric(bitWidth)
        }
        ";"
    }
}

extension ObjCModifier {
    @SemanticStringBuilder
    func semanticDecoded(level: Int = 1) -> SemanticString {
        switch self {
        case .complex:
            Keyword("_Complex")
        case .atomic:
            Keyword("_Atomic")
        case .const:
            Keyword("const")
        case .in:
            Keyword("in")
        case .inout:
            Keyword("inout")
        case .out:
            Keyword("out")
        case .bycopy:
            Keyword("bycopy")
        case .byref:
            Keyword("byref")
        case .oneway:
            Keyword("oneway")
        case .register:
            Keyword("register")
        }
    }
}

extension ObjCType {
    @SemanticStringBuilder
    func semanticDecodedForArgument(context: ObjCDumpContext) -> SemanticString {
        switch self {
        case .struct(let name, let fields),
             .union(let name, let fields):
            Keyword(isStruct ? "struct" : "union")
            if let name {
                Space()
                TypeName(kind: isStruct ? .struct : .other, name)
            }

            if context.isExpandHandler(name, isStruct) {
                Joined {
                    if let fields {
                        Joined(separator: " ") {
                            for (index, field) in fields.enumerated() {
                                Group {
                                    field.type.semanticDecodedForArgument(context: context)
                                    Space()
                                    Variable(field.name ?? "x\(index)")
                                    if let bitWidth = field.bitWidth {
                                        " : "
                                        Numeric(bitWidth)
                                    }
                                    ";"
                                }
                            }
                        }
                    }
                } prefix: {
                    " { "
                } suffix: {
                    " }"
                }
            }
        case .char:
            Keyword("BOOL")
        case .pointer(let type):
            type.semanticDecodedForArgument(context: context)
            Space()
            "*"
        case .modified(let modifier, let type):
            modifier.semanticDecoded(level: 0)
            Space()
            type.semanticDecodedForArgument(context: context)
        default:
            semanticDecoded(level: 0, context: context)
        }
    }

    @SemanticStringBuilder
    func semanticDecoded(level: Int = 1, context: ObjCDumpContext) -> SemanticString {
        switch self {
        case .class:
            TypeName(kind: .class, "Class")
        case .selector:
            Keyword("SEL")
        case .char:
            if let r = context.cTypeReplacements[.char] { TypeName(kind: .other, r) } else { Keyword("char") }
        case .uchar:
            if let r = context.cTypeReplacements[.uchar] {
                TypeName(kind: .other, r)
            } else {
                Joined(separator: Space()) {
                    Keyword("unsigned")
                    Keyword("char")
                }
            }
        case .short:
            if let r = context.cTypeReplacements[.short] { TypeName(kind: .other, r) } else { Keyword("short") }
        case .ushort:
            if let r = context.cTypeReplacements[.ushort] {
                TypeName(kind: .other, r)
            } else {
                Joined(separator: Space()) {
                    Keyword("unsigned")
                    Keyword("short")
                }
            }
        case .int:
            if let r = context.cTypeReplacements[.int] { TypeName(kind: .other, r) } else { Keyword("int") }
        case .uint:
            if let r = context.cTypeReplacements[.uint] {
                TypeName(kind: .other, r)
            } else {
                Joined(separator: Space()) {
                    Keyword("unsigned")
                    Keyword("int")
                }
            }
        case .long:
            if let r = context.cTypeReplacements[.long] { TypeName(kind: .other, r) } else { Keyword("long") }
        case .ulong:
            if let r = context.cTypeReplacements[.ulong] {
                TypeName(kind: .other, r)
            } else {
                Joined(separator: Space()) {
                    Keyword("unsigned")
                    Keyword("long")
                }
            }
        case .longLong:
            if let r = context.cTypeReplacements[.longLong] {
                TypeName(kind: .other, r)
            } else {
                Joined(separator: Space()) {
                    Keyword("long")
                    Keyword("long")
                }
            }
        case .ulongLong:
            if let r = context.cTypeReplacements[.ulongLong] {
                TypeName(kind: .other, r)
            } else {
                Joined(separator: Space()) {
                    Keyword("unsigned")
                    Keyword("long")
                    Keyword("long")
                }
            }
        case .int128:
            TypeName(kind: .other, "__int128_t")
        case .uint128:
            TypeName(kind: .other, "__uint128_t")
        case .float:
            if let r = context.cTypeReplacements[.float] { TypeName(kind: .other, r) } else { Keyword("float") }
        case .double:
            if let r = context.cTypeReplacements[.double] { TypeName(kind: .other, r) } else { Keyword("double") }
        case .longDouble:
            if let r = context.cTypeReplacements[.longDouble] {
                TypeName(kind: .other, r)
            } else {
                Joined(separator: Space()) {
                    Keyword("long")
                    Keyword("double")
                }
            }
        case .bool:
            Keyword("BOOL")
        case .void:
            Keyword("void")
        case .unknown:
            UnknownError()
        case .charPtr:
            Keyword("char")
            Space()
            "*"
        case .atom:
            Keyword("atom")
        case .object(let name):
            if let name {
                // eg. id<NSObject>
                if name.first == "<" && name.last == ">" {
                    let components = name.components(separatedBy: "><")
                    Keyword("id")
                    if components.count > 1 {
                        Joined(separator: ", ", prefix: "<", suffix: ">") {
                            for (offset, component) in components.offsetEnumerated() {
                                if offset.isStart {
                                    TypeName(kind: .protocol, String(component.dropFirst(1)))
                                } else if offset.isEnd {
                                    TypeName(kind: .protocol, String(component.dropLast(1)))
                                } else {
                                    TypeName(kind: .protocol, String(component))
                                }
                            }
                        }
                    } else {
                        "<"
                        TypeName(kind: .protocol, String(name.dropFirst(1).dropLast(1)))
                        ">"
                    }
                } else {
                    // eg. NSObject<NSCopying, NSCoding, ...>
                    if let protocolPrefixIndex = name.firstIndex(of: "<"), let protocolSuffixIndex = name.lastIndex(of: ">") {
                        let protocolStartIndex = name.index(after: protocolPrefixIndex)
                        let protocols = name[protocolStartIndex..<protocolSuffixIndex]
                        let components = protocols.components(separatedBy: "><")
                        TypeName(kind: .class, String(name[name.startIndex..<protocolPrefixIndex]))
                        if components.count > 1 {
                            Joined(separator: ", ", prefix: "<", suffix: ">") {
                                for (offset, component) in components.offsetEnumerated() {
                                    if offset.isStart {
                                        TypeName(kind: .protocol, String(component.dropFirst(1)))
                                    } else if offset.isEnd {
                                        TypeName(kind: .protocol, String(component.dropLast(1)))
                                    } else {
                                        TypeName(kind: .protocol, String(component))
                                    }
                                }
                            }
                        } else {
                            // eg. NSObject<NSCopying>
                            "<"
                            TypeName(kind: .protocol, String(protocols))
                            ">"
                        }
                        Space()
                        "*"
                    } else {
                        TypeName(kind: .class, name)
                        Space()
                        "*"
                    }
                }
            } else {
                Keyword("id")
            }
        case .block(let ret, let args):
            if let ret, let args {
                ret.semanticDecoded(level: level, context: context)
                " (^)("
                Joined(separator: ", ") {
                    for arg in args {
                        arg.semanticDecoded(level: level, context: context)
                    }
                }
                ")"
            } else {
                Keyword("id")
                Space()
                InlineComment("block")
            }
        case .functionPointer:
            Keyword("void")
            Space()
            "*"
            Space()
            InlineComment("function pointer")
        case .array(let type, let size):
            type.semanticDecoded(level: level, context: context)
            context.currentArray = SemanticString {
                "["
                if let size {
                    Numeric(size)
                }
                "]"
            }
        case .pointer(let type):
            type.semanticDecoded(level: level, context: context)
            Space()
            "*"
        case .bitField(let width):
            Keyword("int")
            Space()
            Variable("x")
            " : "
            Numeric(width)
        case .struct(let name, let fields),
             .union(let name, let fields):
            Keyword(isStruct ? "struct" : "union")
            if let name {
                Space()
                TypeName(kind: isStruct ? .struct : .other, name)
            }
            if context.isExpandHandler(name, isStruct) {
                Joined {
                    if let fields {
                        MemberList(level: level + 1) {
                            for (index, field) in fields.enumerated() {
                                field.semanticString(fallbackName: "x\(index)", level: level + 1, context: context)
                            }
                        }
                    }
                } prefix: {
                    " {"
                } suffix: {
                    Indent(level: level)
                    "}"
                }.if(fields != nil || name == nil)
            }
        case .modified(let modifier, let type):
            modifier.semanticDecoded(level: level)
            Space()
            type.semanticDecoded(level: level, context: context)
        case .other(let string):
            string
        }
    }
}

extension ObjCCategoryInfo {
    var uniqueName: String {
        "\(className)(\(name))"
    }
}

extension ObjCPropertyInfo {
    var ivar: String? {
        attributes.compactMap(\.ivar).first
    }

    var customGetter: String? {
        attributes.compactMap(\.getter).first
    }

    var customSetter: String? {
        attributes.compactMap(\.setter).first
    }
}

// MARK: - Naming Intelligent

/// A utility for intelligently guessing parameter names from Objective-C method labels.
///
/// Examples:
/// - `initWithTitle` -> `title`
/// - `objectForKey` -> `key`
/// - `valueAtIndex` -> `index`
/// - `setFrame` -> `frame`
/// - `setMaximumNumberOfLines` -> `lines`
/// - `name` -> `name`
private enum NamingIntelligent {
    /// Common prepositions used in Objective-C method names (lowercase).
    /// Ordered by length (longest first) to match longer prepositions before shorter ones.
    private static let prepositions: [String] = [
        "withcontentsof",
        "byappending",
        "byreplacing",
        "fromstring",
        "tostring",
        "containing",
        "including",
        "excluding",
        "replacing",
        "returning",
        "matching",
        "starting",
        "between",
        "through",
        "without",
        "within",
        "during",
        "before",
        "behind",
        "except",
        "under",
        "using",
        "after",
        "about",
        "above",
        "along",
        "among",
        "below",
        "named",
        "called",
        "having",
        "where",
        "until",
        "since",
        "with",
        "from",
        "into",
        "onto",
        "upon",
        "over",
        "like",
        "near",
        "past",
        "for",
        "and",
        "but",
        "nor",
        "yet",
        "via",
        "per",
        "at",
        "by",
        "in",
        "of",
        "on",
        "to",
        "as",
    ]

    /// Prefixes that should be stripped before looking for prepositions.
    private static let prefixes: [String] = [
        "_set",
        "_get",
        "set",
        "get",
    ]

    /// Guesses a parameter name from an Objective-C method label.
    ///
    /// - Parameter label: The method label (e.g., "initWithTitle", "objectForKey")
    /// - Returns: The guessed parameter name (e.g., "title", "key")
    static func parameterName(from label: String) -> String {
        guard !label.isEmpty else { return "arg" }

        var workingLabel = label
        let lowercasedLabel = label.lowercased()

        // First, strip known prefixes like set/get
        for prefix in prefixes {
            if lowercasedLabel.hasPrefix(prefix) && label.count > prefix.count {
                let afterPrefix = label.index(label.startIndex, offsetBy: prefix.count)
                // Make sure the next character is uppercase (word boundary)
                if label[afterPrefix].isUppercase {
                    workingLabel = String(label[afterPrefix...])
                    break
                }
            }
        }

        // Now search for prepositions from the beginning, find the LAST match
        let lowercasedWorking = workingLabel.lowercased()
        var lastMatchEnd: String.Index?

        for preposition in prepositions {
            // Search for all occurrences from the beginning
            var searchStart = lowercasedWorking.startIndex
            while let range = lowercasedWorking.range(of: preposition, range: searchStart ..< lowercasedWorking.endIndex) {
                // Calculate the corresponding range in the working label
                let startDistance = lowercasedWorking.distance(from: lowercasedWorking.startIndex, to: range.lowerBound)
                let endDistance = lowercasedWorking.distance(from: lowercasedWorking.startIndex, to: range.upperBound)
                let originalStart = workingLabel.index(workingLabel.startIndex, offsetBy: startDistance)
                let originalEnd = workingLabel.index(workingLabel.startIndex, offsetBy: endDistance)

                // Check word boundary for camelCase:
                // 1. The preposition must start with uppercase (e.g., "With" in "initWithTitle")
                // 2. After: must be uppercase letter (the next word starts)
                let prepositionStartChar = workingLabel[originalStart]
                let startsWithUppercase = prepositionStartChar.isUppercase

                let hasValidEnd: Bool
                if originalEnd >= workingLabel.endIndex {
                    // Preposition at the end of the label is not valid
                    hasValidEnd = false
                } else {
                    let nextChar = workingLabel[originalEnd]
                    hasValidEnd = nextChar.isUppercase
                }

                if startsWithUppercase && hasValidEnd {
                    // Use the last (rightmost) preposition match
                    if lastMatchEnd == nil || originalEnd > lastMatchEnd! {
                        lastMatchEnd = originalEnd
                    }
                }

                // Move search start forward
                searchStart = range.upperBound
            }
        }

        // Extract the part after the last preposition
        if let end = lastMatchEnd {
            let afterPreposition = String(workingLabel[end...])
            if !afterPreposition.isEmpty {
                return afterPreposition.lowercasedFirst
            }
        }

        // No preposition found, use the working label
        return workingLabel.lowercasedFirst
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCore/Utils/SwiftStdlib+.swift`:

```swift
import Foundation

extension Optional where Wrapped: Collection {
    @inlinable
    var orEmpty: [Wrapped.Element] {
        switch self {
        case .none:
            return []
        case .some(let wrapped):
            return .init(wrapped)
        }
    }
}

extension Array where Element: Equatable {
    @discardableResult
    @inlinable
    mutating func removeFirst(_ element: Element) -> Element? {
        if let index = firstIndex(of: element) {
            return remove(at: index)
        }
        return nil
    }

    @inlinable
    mutating func removeAll(_ element: Element) {
        removeAll(where: { $0 == element })
    }

    @inlinable
    func removingFirst(_ element: Element) -> [Element] {
        var newArray = self
        newArray.removeFirst(element)
        return newArray
    }

    @inlinable
    func removingAll(_ element: Element) -> [Element] {
        return filter { $0 != element }
    }

    @inlinable
    mutating func remove(contentsOf elements: [Element]) {
        removeAll { elements.contains($0) }
    }

    @inlinable
    func removing(contentsOf elements: [Element]) -> [Element] {
        return filter { !elements.contains($0) }
    }
}

extension Array {
    @inlinable
    func removingAll(where shouldBeRemoved: (Element) throws -> Bool) rethrows -> [Element] {
        var copy = self
        try copy.removeAll(where: shouldBeRemoved)
        return copy
    }
}

extension String {
    @inlinable
    var uppercasedFirst: String {
        prefix(1).uppercased() + dropFirst()
    }

    @inlinable
    var lowercasedFirst: String {
        prefix(1).lowercased() + dropFirst()
    }

    @inlinable
    var uppercasedLast: String {
        dropLast() + suffix(1).uppercased()
    }

    @inlinable
    var lowercasedLast: String {
        dropLast() + suffix(1).lowercased()
    }

    func uppercased(at index: Int) -> String {
        return transform(at: index) { $0.uppercased() }
    }

    func lowercased(at index: Int) -> String {
        return transform(at: index) { $0.lowercased() }
    }

    func uppercased(in range: Range<Int>) -> String {
        return transform(in: range) { $0.uppercased() }
    }

    func uppercased(in range: ClosedRange<Int>) -> String {
        return transform(in: Range(range)) { $0.uppercased() }
    }

    func lowercased(in range: Range<Int>) -> String {
        return transform(in: range) { $0.lowercased() }
    }

    func lowercased(in range: ClosedRange<Int>) -> String {
        return transform(in: Range(range)) { $0.lowercased() }
    }

    private func transform(at index: Int, _ transformer: (String) -> String) -> String {
        guard index >= 0 && index < count else { return self }

        let startIdx = self.index(startIndex, offsetBy: index)
        let charRange = startIdx ..< self.index(after: startIdx)
        return replacingCharacters(in: charRange, with: transformer(String(self[startIdx])))
    }

    private func transform(in range: Range<Int>, _ transformer: (String) -> String) -> String {
        let clampedLower = max(0, range.lowerBound)
        let clampedUpper = min(count, range.upperBound)
        guard clampedLower < clampedUpper else { return self }

        let startIdx = index(startIndex, offsetBy: clampedLower)
        let endIdx = index(startIndex, offsetBy: clampedUpper)
        let swiftRange = startIdx ..< endIdx

        let subStr = String(self[swiftRange])
        return replacingCharacters(in: swiftRange, with: transformer(subStr))
    }
}

extension Set {
    @inlinable mutating func insert<S>(contentsOf newElements: S) where S: Sequence, Element == S.Element {
        for newElement in newElements {
            insert(newElement)
        }
    }
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCoreObjC/RuntimeViewerCoreObjC.m`:

```m
//
//  RuntimeViewerObjC.m
//  Core
//
//  Created by JH on 11/12/25.
//

#import "RuntimeViewerCoreObjC.h"

const void * _Nullable RVClassFromString(NSString *className) {
    return (__bridge void * _Nullable)(NSClassFromString(className));
}

const void * _Nullable RVProtocolFromString(NSString *protocolName) {
    return (__bridge void * _Nullable)(NSProtocolFromString(protocolName));
}

```

`RuntimeViewerCore/Sources/RuntimeViewerCoreObjC/include/RuntimeViewerCoreObjC.h`:

```h
//
//  RuntimeViewerObjC.h
//  Core
//
//  Created by JH on 11/12/25.
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

FOUNDATION_EXPORT
const void * _Nullable RVClassFromString(NSString *className);

FOUNDATION_EXPORT
const void * _Nullable RVProtocolFromString(NSString *protocolName);

NS_ASSUME_NONNULL_END

```

`RuntimeViewerCore/Tests/RuntimeViewerCommunicationTests/RuntimeLocalSocketConnectionTests.swift`:

```swift
import Testing
import Foundation
@testable import RuntimeViewerCommunication

// MARK: - RuntimeLocalSocketConnectionTests

@Suite("RuntimeLocalSocketConnection Tests", .serialized)
struct RuntimeLocalSocketConnectionTests {

    @Test("Server starts and listens on auto-assigned port")
    func testServerStartsOnAutoPort() async throws {
        let identifier = "test-server-\(UUID().uuidString)"

        let server = RuntimeLocalSocketServerConnection(identifier: identifier)

        // Start server in background task
        let serverTask = Task {
            try await server.start()
        }

        // Give server time to start
        try await Task.sleep(nanoseconds: 100_000_000)

        // Port should be assigned
        #expect(server.port > 0)

        // Clean up
        serverTask.cancel()
        server.stop()
    }

    @Test("Port discovery uses deterministic hash")
    func testPortDiscovery() async throws {
        let identifier = "test-discovery-\(UUID().uuidString)"

        // Compute port using deterministic hash
        let port1 = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)
        let port2 = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)

        // Port should be the same for the same identifier
        #expect(port1 == port2)

        // Port should be in the valid dynamic port range (49152-65535)
        #expect(port1 >= 49152)
        #expect(port1 <= 65535)
    }

    @Test("Client connects to server via port discovery")
    func testClientServerConnection() async throws {
        let identifier = "test-connection-\(UUID().uuidString)"

        let server = RuntimeLocalSocketServerConnection(identifier: identifier)

        // Start server
        let serverTask = Task {
            try await server.start()
        }

        // Give server time to start and write port file
        try await Task.sleep(nanoseconds: 200_000_000)

        // Setup handler
        server.setMessageHandler(requestType: EchoRequest.self) { request in
            return EchoResponse(message: "Server received: \(request.message)")
        }

        // Connect client using port discovery
        let client = try await RuntimeLocalSocketClientConnection(identifier: identifier, timeout: 5)

        // Send request
        let response = try await client.sendMessage(request: EchoRequest(message: "Hello"))

        #expect(response.message == "Server received: Hello")

        // Clean up
        serverTask.cancel()
        server.stop()
    }

    @Test("Client connects to server via direct port")
    func testDirectPortConnection() async throws {
        let identifier = "test-direct-\(UUID().uuidString)"

        let server = RuntimeLocalSocketServerConnection(identifier: identifier)

        // Start server
        let serverTask = Task {
            try await server.start()
        }

        // Give server time to start
        try await Task.sleep(nanoseconds: 200_000_000)

        let port = server.port
        #expect(port > 0)

        server.setMessageHandler(requestType: AddRequest.self) { request in
            return AddResponse(result: request.a + request.b)
        }

        // Connect client using direct port
        let client = try RuntimeLocalSocketClientConnection(port: port)

        // Send request
        let response = try await client.sendMessage(request: AddRequest(a: 100, b: 200))

        #expect(response.result == 300)

        // Clean up
        serverTask.cancel()
        server.stop()
    }

    @Test("Multiple sequential requests over socket")
    func testMultipleRequests() async throws {
        let identifier = "test-multi-\(UUID().uuidString)"

        let server = RuntimeLocalSocketServerConnection(identifier: identifier)

        let serverTask = Task {
            try await server.start()
        }

        try await Task.sleep(nanoseconds: 200_000_000)

        server.setMessageHandler(requestType: AddRequest.self) { request in
            return AddResponse(result: request.a * request.b)
        }

        let client = try await RuntimeLocalSocketClientConnection(identifier: identifier, timeout: 5)

        // Send multiple requests
        for i in 1...5 {
            let response = try await client.sendMessage(request: AddRequest(a: i, b: i))
            #expect(response.result == i * i)
        }

        serverTask.cancel()
        server.stop()
    }

    @Test("Large message over socket")
    func testLargeMessageOverSocket() async throws {
        let identifier = "test-large-\(UUID().uuidString)"

        let server = RuntimeLocalSocketServerConnection(identifier: identifier)

        let serverTask = Task {
            try await server.start()
        }

        try await Task.sleep(nanoseconds: 200_000_000)

        server.setMessageHandler(requestType: EchoRequest.self) { request in
            return EchoResponse(message: request.message)
        }

        let client = try await RuntimeLocalSocketClientConnection(identifier: identifier, timeout: 5)

        // Send large message (500KB)
        let largeString = String(repeating: "X", count: 500_000)
        let response = try await client.sendMessage(request: EchoRequest(message: largeString))

        #expect(response.message.count == 500_000)
        #expect(response.message == largeString)

        serverTask.cancel()
        server.stop()
    }

    @Test("Server on specific port")
    func testServerOnSpecificPort() async throws {
        let specificPort: UInt16 = 19876

        let server = RuntimeLocalSocketServerConnection(port: specificPort)

        let serverTask = Task {
            try await server.start()
        }

        try await Task.sleep(nanoseconds: 200_000_000)

        #expect(server.port == specificPort)

        server.setMessageHandler(name: "ping") { (_: String) -> String in
            return "pong"
        }

        let client = try RuntimeLocalSocketClientConnection(port: specificPort)

        let response: String = try await client.sendMessage(name: "ping", request: "")
        #expect(response == "pong")

        serverTask.cancel()
        server.stop()
    }
}

// MARK: - RuntimeLocalSocketPortDiscoveryTests

@Suite("RuntimeLocalSocketPortDiscovery Tests", .serialized)
struct RuntimeLocalSocketPortDiscoveryTests {

    @Test("Deterministic port computation")
    func testDeterministicPortComputation() {
        // Same identifier should always produce the same port
        let identifier = "com.example.test.identifier"
        let port1 = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)
        let port2 = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)

        #expect(port1 == port2)
    }

    @Test("Different identifiers produce different ports")
    func testDifferentIdentifiersDifferentPorts() {
        let identifiers = [
            "com.example.app1",
            "com.example.app2",
            "com.example.app3",
            "test-server-123",
            "test-server-456"
        ]

        var ports = Set<UInt16>()
        for identifier in identifiers {
            let port = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)
            ports.insert(port)
        }

        // All ports should be different (with high probability for different identifiers)
        #expect(ports.count == identifiers.count)
    }

    @Test("Port is in valid dynamic range")
    func testPortInValidRange() {
        let testIdentifiers = [
            "short",
            "a-very-long-identifier-that-might-overflow",
            "com.example.app.with.many.components",
            "special!@#$%^&*()characters",
            ""
        ]

        for identifier in testIdentifiers {
            let port = RuntimeLocalSocketPortDiscovery.computePort(for: identifier)
            #expect(port >= 49152, "Port \(port) for '\(identifier)' is below minimum 49152")
            #expect(port <= 65535, "Port \(port) for '\(identifier)' is above maximum 65535")
        }
    }
}

// MARK: - RuntimeLocalSocketError Tests

@Suite("RuntimeLocalSocketError Tests", .serialized)
struct RuntimeLocalSocketErrorTests {

    @Test("Error when connecting to non-existent server")
    func testConnectionRefused() throws {
        // Try to connect to a port that's not listening
        #expect(throws: RuntimeLocalSocketError.self) {
            _ = try RuntimeLocalSocketClientConnection(port: 59999)
        }
    }

    @Test("Error description is informative")
    func testErrorDescriptions() {
        let errors: [RuntimeLocalSocketError] = [
            .notConnected,
            .receiveFailed,
            .socketCreationFailed(errno: EMFILE),
            .bindFailed(errno: EADDRINUSE, port: 8080),
            .listenFailed(errno: EACCES),
            .acceptFailed(errno: EINTR),
            .connectFailed(errno: ECONNREFUSED, port: 9999),
            .sendFailed(errno: EPIPE),
        ]

        for error in errors {
            let description = error.description
            #expect(!description.isEmpty)
            #expect(description.contains("RuntimeLocalSocketError"))
        }
    }
}

```

`RuntimeViewerCore/Tests/RuntimeViewerCommunicationTests/RuntimeStdioConnectionTests.swift`:

```swift
import Testing
import Foundation
@testable import RuntimeViewerCommunication

// MARK: - Test Request/Response Types

struct EchoRequest: RuntimeRequest {
    static let identifier = "EchoRequest"
    typealias Response = EchoResponse
    let message: String
}

struct EchoResponse: RuntimeResponse {
    let message: String
}

struct AddRequest: RuntimeRequest {
    static let identifier = "AddRequest"
    typealias Response = AddResponse
    let a: Int
    let b: Int
}

struct AddResponse: RuntimeResponse {
    let result: Int
}

// MARK: - RuntimeStdioConnectionTests

@Suite("RuntimeStdioConnection Tests", .serialized)
struct RuntimeStdioConnectionTests {

    @Test("Basic message roundtrip through pipes")
    func testBasicMessageRoundtrip() async throws {
        // Create pipes for bidirectional communication
        let clientToServer = Pipe()
        let serverToClient = Pipe()

        // Server reads from clientToServer, writes to serverToClient
        let server = try RuntimeStdioServerConnection(
            inputHandle: clientToServer.fileHandleForReading,
            outputHandle: serverToClient.fileHandleForWriting
        )

        // Client reads from serverToClient, writes to clientToServer
        let client = try RuntimeStdioClientConnection(
            inputHandle: serverToClient.fileHandleForReading,
            outputHandle: clientToServer.fileHandleForWriting
        )

        // Setup echo handler on server
        server.setMessageHandler(requestType: EchoRequest.self) { request in
            return EchoResponse(message: "Echo: \(request.message)")
        }

        // Send request from client
        let response = try await client.sendMessage(request: EchoRequest(message: "Hello"))

        #expect(response.message == "Echo: Hello")
    }

    @Test("Multiple sequential requests")
    func testMultipleSequentialRequests() async throws {
        let clientToServer = Pipe()
        let serverToClient = Pipe()

        let server = try RuntimeStdioServerConnection(
            inputHandle: clientToServer.fileHandleForReading,
            outputHandle: serverToClient.fileHandleForWriting
        )

        let client = try RuntimeStdioClientConnection(
            inputHandle: serverToClient.fileHandleForReading,
            outputHandle: clientToServer.fileHandleForWriting
        )

        server.setMessageHandler(requestType: AddRequest.self) { request in
            return AddResponse(result: request.a + request.b)
        }

        // Send multiple requests sequentially
        let response1 = try await client.sendMessage(request: AddRequest(a: 1, b: 2))
        #expect(response1.result == 3)

        let response2 = try await client.sendMessage(request: AddRequest(a: 10, b: 20))
        #expect(response2.result == 30)

        let response3 = try await client.sendMessage(request: AddRequest(a: -5, b: 5))
        #expect(response3.result == 0)
    }

    @Test("Handler with name-based registration")
    func testNameBasedHandler() async throws {
        let clientToServer = Pipe()
        let serverToClient = Pipe()

        let server = try RuntimeStdioServerConnection(
            inputHandle: clientToServer.fileHandleForReading,
            outputHandle: serverToClient.fileHandleForWriting
        )

        let client = try RuntimeStdioClientConnection(
            inputHandle: serverToClient.fileHandleForReading,
            outputHandle: clientToServer.fileHandleForWriting
        )

        // Register handler by name
        server.setMessageHandler(name: "uppercase") { (input: String) -> String in
            return input.uppercased()
        }

        let result: String = try await client.sendMessage(name: "uppercase", request: "hello world")
        #expect(result == "HELLO WORLD")
    }

    @Test("Large message handling")
    func testLargeMessage() async throws {
        let clientToServer = Pipe()
        let serverToClient = Pipe()

        let server = try RuntimeStdioServerConnection(
            inputHandle: clientToServer.fileHandleForReading,
            outputHandle: serverToClient.fileHandleForWriting
        )

        let client = try RuntimeStdioClientConnection(
            inputHandle: serverToClient.fileHandleForReading,
            outputHandle: clientToServer.fileHandleForWriting
        )

        server.setMessageHandler(requestType: EchoRequest.self) { request in
            return EchoResponse(message: request.message)
        }

        // Create a large message (100KB)
        let largeString = String(repeating: "A", count: 100_000)
        let response = try await client.sendMessage(request: EchoRequest(message: largeString))

        #expect(response.message == largeString)
        #expect(response.message.count == 100_000)
    }

    @Test("Bidirectional communication - both sides can initiate")
    func testBidirectionalCommunication() async throws {
        let pipe1 = Pipe()
        let pipe2 = Pipe()

        // Connection A
        let connectionA = try RuntimeStdioClientConnection(
            inputHandle: pipe2.fileHandleForReading,
            outputHandle: pipe1.fileHandleForWriting
        )

        // Connection B
        let connectionB = try RuntimeStdioServerConnection(
            inputHandle: pipe1.fileHandleForReading,
            outputHandle: pipe2.fileHandleForWriting
        )

        // Both sides register handlers
        connectionA.setMessageHandler(name: "fromB") { (msg: String) -> String in
            return "A received: \(msg)"
        }

        connectionB.setMessageHandler(name: "fromA") { (msg: String) -> String in
            return "B received: \(msg)"
        }

        // A sends to B
        let responseFromB: String = try await connectionA.sendMessage(name: "fromA", request: "Hello from A")
        #expect(responseFromB == "B received: Hello from A")

        // B sends to A
        let responseFromA: String = try await connectionB.sendMessage(name: "fromB", request: "Hello from B")
        #expect(responseFromA == "A received: Hello from B")
    }
}

// MARK: - RuntimeStdioError Tests

@Suite("RuntimeStdioError Tests", .serialized)
struct RuntimeStdioErrorTests {

    @Test("Error when underlying connection is stopped")
    func testErrorAfterConnectionStop() async throws {
        let clientToServer = Pipe()
        let serverToClient = Pipe()

        let server = try RuntimeStdioServerConnection(
            inputHandle: clientToServer.fileHandleForReading,
            outputHandle: serverToClient.fileHandleForWriting
        )

        let client = try RuntimeStdioClientConnection(
            inputHandle: serverToClient.fileHandleForReading,
            outputHandle: clientToServer.fileHandleForWriting
        )

        // Close the pipes to simulate connection failure
        try clientToServer.fileHandleForWriting.close()
        try serverToClient.fileHandleForReading.close()

        // Sending should fail after closing the connection
        // Note: The behavior depends on implementation details
        _ = server
        _ = client
    }
}

```

`RuntimeViewerMCP/Package.swift`:

```swift
// swift-tools-version: 6.2

import PackageDescription

let package = Package(
    name: "RuntimeViewerMCP",
    platforms: [
        .macOS(.v15),
    ],
    products: [
        .library(
            name: "RuntimeViewerMCPShared",
            targets: ["RuntimeViewerMCPShared"]
        ),
        .library(
            name: "RuntimeViewerMCPBridge",
            targets: ["RuntimeViewerMCPBridge"]
        ),
    ],
    dependencies: [
        .package(path: "../RuntimeViewerCore"),
        .package(path: "../RuntimeViewerPackages"),
    ],
    targets: [
        .target(
            name: "RuntimeViewerMCPShared"
        ),
        .target(
            name: "RuntimeViewerMCPBridge",
            dependencies: [
                "RuntimeViewerMCPShared",
                .product(name: "RuntimeViewerCore", package: "RuntimeViewerCore"),
                .product(name: "RuntimeViewerApplication", package: "RuntimeViewerPackages"),
                .product(name: "RuntimeViewerSettings", package: "RuntimeViewerPackages"),
            ]
        ),
    ],
    swiftLanguageModes: [.v5]
)

```

`RuntimeViewerMCP/Sources/RuntimeViewerMCPBridge/MCPBridgeListener.swift`:

```swift
import Foundation
import FoundationToolbox
import Network
import RuntimeViewerMCPShared
import OSLog

private let logger = Logger(subsystem: "com.RuntimeViewer.MCPBridge", category: "Listener")

/// Handles TCP listener setup, connection management, and frame-level I/O.
/// Delegates request processing to a handler closure.
final class MCPBridgeListener: Sendable {
    private let listener: NWListener
    
    private let portFilePath: String

    // Set once via start(), never mutated after
    @Mutex
    private var requestHandler: (@Sendable (MCPBridgeEnvelope) async throws -> Data)?

    @Mutex
    private(set) var port: UInt16 = 0

    init(port: UInt16 = 0) throws {
        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.enableKeepalive = true
        tcpOptions.keepaliveIdle = 2
        tcpOptions.noDelay = true

        let parameters = NWParameters(tls: nil, tcp: tcpOptions)

        if port == 0 {
            self.listener = try NWListener(using: parameters)
        } else {
            self.listener = try NWListener(using: parameters, on: NWEndpoint.Port(rawValue: port)!)
        }

        // Determine port file path
        let appSupportURL = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let runtimeViewerDir = appSupportURL.appendingPathComponent("RuntimeViewer")
        try FileManager.default.createDirectory(at: runtimeViewerDir, withIntermediateDirectories: true)
        self.portFilePath = runtimeViewerDir.appendingPathComponent("mcp-bridge-port").path
    }

    func start(requestHandler: @escaping @Sendable (MCPBridgeEnvelope) async throws -> Data) {
        self.requestHandler = requestHandler
        removePortFile()
        setupListener()
    }

    func stop() {
        listener.cancel()
    }

    // MARK: - Listener Setup

    private func setupListener() {
        listener.stateUpdateHandler = { [weak self] state in
            guard let self else { return }
            switch state {
            case .ready:
                if let port = self.listener.port {
                    self.port = port.rawValue
                    logger.info("MCP Bridge server listening on port \(port.rawValue)")
                    self.writePortFile(port: port.rawValue)
                }
            case .failed(let error):
                logger.error("MCP Bridge server listener failed: \(error)")
            case .cancelled:
                logger.info("MCP Bridge server listener cancelled")
                self.removePortFile()
            default:
                break
            }
        }

        listener.newConnectionHandler = { [weak self] connection in
            guard let self else { return }
            logger.info("MCP Bridge accepted new connection")
            self.handleConnection(connection)
        }

        listener.start(queue: .global(qos: .userInitiated))
    }

    // MARK: - Connection Handling

    private func handleConnection(_ connection: NWConnection) {
        connection.stateUpdateHandler = { state in
            switch state {
            case .ready:
                logger.info("MCP Bridge connection ready")
            case .failed(let error):
                logger.error("MCP Bridge connection failed: \(error)")
            case .cancelled:
                logger.info("MCP Bridge connection cancelled")
            default:
                break
            }
        }

        connection.start(queue: .global(qos: .userInitiated))
        receiveLoop(connection: connection)
    }

    private func receiveLoop(connection: NWConnection) {
        Task {
            do {
                while true {
                    let requestData = try await MCPBridgeFrame.receive(from: connection)
                    let envelope = try JSONDecoder().decode(MCPBridgeEnvelope.self, from: requestData)
                    guard let handler = requestHandler else {
                        logger.warning("No request handler set, dropping request")
                        continue
                    }
                    let responseData = try await handler(envelope)
                    let responseEnvelope = MCPBridgeResponseEnvelope(payload: responseData)
                    let responseJSON = try JSONEncoder().encode(responseEnvelope)
                    try await MCPBridgeFrame.send(responseJSON, on: connection)
                }
            } catch {
                if case MCPBridgeTransportError.connectionClosed = error {
                    logger.info("MCP Bridge client disconnected")
                } else {
                    logger.error("MCP Bridge error: \(error)")
                }
                connection.cancel()
            }
        }
    }

    // MARK: - Port File

    private func writePortFile(port: UInt16) {
        do {
            try "\(port)".write(toFile: portFilePath, atomically: true, encoding: .utf8)
            logger.info("Wrote MCP bridge port \(port) to \(self.portFilePath)")
        } catch {
            logger.error("Failed to write port file: \(error)")
        }
    }

    private func removePortFile() {
        try? FileManager.default.removeItem(atPath: portFilePath)
    }

    deinit {
        stop()
    }
}

```

`RuntimeViewerMCP/Sources/RuntimeViewerMCPBridge/MCPBridgeServer.swift`:

```swift
import Foundation
import RuntimeViewerCore
import RuntimeViewerApplication
import RuntimeViewerMCPShared
import RuntimeViewerSettings
import Dependencies
import OSLog

private let logger = Logger(subsystem: "com.RuntimeViewer.MCPBridge", category: "Server")

public actor MCPBridgeServer {
    private let listener: MCPBridgeListener
    
    private let windowProvider: MCPBridgeWindowProvider

    @Dependency(\.appDefaults)
    private var appDefaults

    public init(windowProvider: MCPBridgeWindowProvider, port: UInt16 = 0) throws {
        self.windowProvider = windowProvider
        self.listener = try MCPBridgeListener(port: port)
    }

    public func start() {
        listener.start { [self] envelope in
            try await self.processRequest(envelope)
        }
    }

    public nonisolated func stop() {
        listener.stop()
    }

    deinit {
        stop()
    }

    private func processRequest(_ envelope: MCPBridgeEnvelope) async throws -> Data {
        guard let command = MCPBridgeCommand(rawValue: envelope.identifier) else {
            throw MCPBridgeTransportError.decodingFailed
        }

        switch command {
        case .listWindows:
            let response = await handleListWindows()
            return try JSONEncoder().encode(response)

        case .selectedType:
            let request = try envelope.decode(MCPSelectedTypeRequest.self)
            let response = await handleSelectedType(request)
            return try JSONEncoder().encode(response)

        case .typeInterface:
            let request = try envelope.decode(MCPTypeInterfaceRequest.self)
            let response = await handleTypeInterface(request)
            return try JSONEncoder().encode(response)

        case .listTypes:
            let request = try envelope.decode(MCPListTypesRequest.self)
            let response = await handleListTypes(request)
            return try JSONEncoder().encode(response)

        case .searchTypes:
            let request = try envelope.decode(MCPSearchTypesRequest.self)
            let response = await handleSearchTypes(request)
            return try JSONEncoder().encode(response)

        case .grepTypeInterface:
            let request = try envelope.decode(MCPGrepTypeInterfaceRequest.self)
            let response = await handleGrepTypeInterface(request)
            return try JSONEncoder().encode(response)
        }
    }

    private func handleListWindows() async -> MCPListWindowsResponse {
        let windows = await MainActor.run {
            windowProvider.allWindowContexts().map { context in
                MCPWindowInfo(
                    identifier: context.identifier,
                    displayName: context.displayName,
                    isKeyWindow: context.isKeyWindow,
                    selectedTypeName: context.selectedRuntimeObject?.displayName,
                    selectedTypeImagePath: context.selectedRuntimeObject?.imagePath
                )
            }
        }
        return MCPListWindowsResponse(windows: windows)
    }

    private func handleSelectedType(_ request: MCPSelectedTypeRequest) async -> MCPSelectedTypeResponse {
        guard let runtimeObject = await MainActor.run(body: {
            windowProvider.windowContext(forIdentifier: request.windowIdentifier)?.selectedRuntimeObject
        }) else {
            return MCPSelectedTypeResponse(
                imagePath: nil,
                typeName: nil,
                displayName: nil,
                typeKind: nil,
                interfaceText: nil
            )
        }

        let engine = await runtimeEngine(forWindowIdentifier: request.windowIdentifier)
        let options = generationOptions()

        do {
            let interface = try await engine.interface(for: runtimeObject, options: options)
            return MCPSelectedTypeResponse(
                imagePath: runtimeObject.imagePath,
                typeName: runtimeObject.name,
                displayName: runtimeObject.displayName,
                typeKind: runtimeObject.kind.description,
                interfaceText: interface?.interfaceString.string
            )
        } catch {
            logger.error("Failed to generate interface for selected type: \(error)")
            return MCPSelectedTypeResponse(
                imagePath: runtimeObject.imagePath,
                typeName: runtimeObject.name,
                displayName: runtimeObject.displayName,
                typeKind: runtimeObject.kind.description,
                interfaceText: nil
            )
        }
    }

    private func handleTypeInterface(_ request: MCPTypeInterfaceRequest) async -> MCPTypeInterfaceResponse {
        let engine = await runtimeEngine(forWindowIdentifier: request.windowIdentifier)
        let options = generationOptions()

        let imagePaths: [String]
        if let imagePath = request.imagePath {
            imagePaths = [imagePath]
        } else {
            imagePaths = await engine.loadedImagePaths
        }

        for imagePath in imagePaths {
            do {
                let objects = try await engine.objects(in: imagePath)
                if let runtimeObject = findObject(named: request.typeName, in: objects) {
                    let interface = try await engine.interface(for: runtimeObject, options: options)
                    return MCPTypeInterfaceResponse(
                        imagePath: runtimeObject.imagePath,
                        typeName: runtimeObject.name,
                        displayName: runtimeObject.displayName,
                        typeKind: runtimeObject.kind.description,
                        interfaceText: interface?.interfaceString.string,
                        error: nil
                    )
                }
            } catch {
                logger.warning("Failed to load objects from image \(imagePath): \(error)")
                continue
            }
        }

        let searchScope = request.imagePath ?? "all loaded images"
        return MCPTypeInterfaceResponse(
            imagePath: request.imagePath,
            typeName: request.typeName,
            displayName: nil,
            typeKind: nil,
            interfaceText: nil,
            error: "Type '\(request.typeName)' not found in \(searchScope)"
        )
    }

    private func handleListTypes(_ request: MCPListTypesRequest) async -> MCPListTypesResponse {
        let engine = await runtimeEngine(forWindowIdentifier: request.windowIdentifier)

        let imagePaths: [String]
        if let imagePath = request.imagePath {
            imagePaths = [imagePath]
        } else {
            imagePaths = await engine.loadedImagePaths
        }

        var allTypes: [MCPRuntimeTypeInfo] = []
        for imagePath in imagePaths {
            do {
                let objects = try await engine.objects(in: imagePath)
                let types = flattenObjects(objects).map { obj in
                    MCPRuntimeTypeInfo(
                        name: obj.name,
                        displayName: obj.displayName,
                        kind: obj.kind.description,
                        imagePath: obj.imagePath
                    )
                }
                allTypes.append(contentsOf: types)
            } catch {
                logger.warning("Failed to load objects from image \(imagePath): \(error)")
                continue
            }
        }
        return MCPListTypesResponse(types: allTypes, error: nil)
    }

    private func handleSearchTypes(_ request: MCPSearchTypesRequest) async -> MCPSearchTypesResponse {
        let engine = await runtimeEngine(forWindowIdentifier: request.windowIdentifier)
        let queryLowercased = request.query.lowercased()

        do {
            var results: [MCPRuntimeTypeInfo] = []

            if let imagePath = request.imagePath {
                // Search within a specific image
                let objects = try await engine.objects(in: imagePath)
                let flattened = flattenObjects(objects)
                for obj in flattened {
                    if obj.name.lowercased().contains(queryLowercased) || obj.displayName.lowercased().contains(queryLowercased) {
                        results.append(MCPRuntimeTypeInfo(
                            name: obj.name,
                            displayName: obj.displayName,
                            kind: obj.kind.description,
                            imagePath: obj.imagePath
                        ))
                    }
                }
            } else {
                // Search across all loaded images
                let imagePaths = await engine.loadedImagePaths
                for imagePath in imagePaths {
                    do {
                        let objects = try await engine.objects(in: imagePath)
                        let flattened = flattenObjects(objects)
                        for obj in flattened {
                            if obj.name.lowercased().contains(queryLowercased) || obj.displayName.lowercased().contains(queryLowercased) {
                                results.append(MCPRuntimeTypeInfo(
                                    name: obj.name,
                                    displayName: obj.displayName,
                                    kind: obj.kind.description,
                                    imagePath: obj.imagePath
                                ))
                            }
                        }
                    } catch {
                        logger.warning("Failed to load objects from image \(imagePath): \(error)")
                        continue
                    }
                }
            }

            return MCPSearchTypesResponse(types: results, error: nil)
        } catch {
            return MCPSearchTypesResponse(types: [], error: error.localizedDescription)
        }
    }

    private func handleGrepTypeInterface(_ request: MCPGrepTypeInterfaceRequest) async -> MCPGrepTypeInterfaceResponse {
        let engine = await runtimeEngine(forWindowIdentifier: request.windowIdentifier)
        let options = generationOptions()
        let patternLowercased = request.pattern.lowercased()

        let imagePaths: [String]
        if let imagePath = request.imagePath {
            imagePaths = [imagePath]
        } else {
            imagePaths = await engine.loadedImagePaths
        }

        var matches: [MCPGrepMatch] = []

        for imagePath in imagePaths {
            do {
                let objects = try await engine.objects(in: imagePath)
                let flattened = flattenObjects(objects)

                for obj in flattened {
                    do {
                        let interface = try await engine.interface(for: obj, options: options)
                        guard let text = interface?.interfaceString.string else { continue }

                        let matchingLines = text.components(separatedBy: .newlines).filter {
                            $0.lowercased().contains(patternLowercased)
                        }

                        if !matchingLines.isEmpty {
                            matches.append(MCPGrepMatch(
                                typeName: obj.name,
                                kind: obj.kind.description,
                                matchingLines: matchingLines
                            ))
                        }
                    } catch {
                        logger.warning("Failed to generate interface for \(obj.name): \(error)")
                        continue
                    }
                }
            } catch {
                logger.warning("Failed to load objects from image \(imagePath): \(error)")
                continue
            }
        }

        return MCPGrepTypeInterfaceResponse(matches: matches, error: nil)
    }

    private func runtimeEngine(forWindowIdentifier identifier: String) async -> RuntimeEngine {
        await MainActor.run {
            windowProvider.windowContext(forIdentifier: identifier)?.runtimeEngine ?? .local
        }
    }

    private func generationOptions() -> RuntimeObjectInterface.GenerationOptions {
        var options = appDefaults.options
        options.transformer = Settings.shared.transformer
        return options
    }

    private func flattenObjects(_ objects: [RuntimeObject]) -> [RuntimeObject] {
        var result: [RuntimeObject] = []
        for obj in objects {
            result.append(obj)
            if !obj.children.isEmpty {
                result.append(contentsOf: flattenObjects(obj.children))
            }
        }
        return result
    }

    private func findObject(named name: String, in objects: [RuntimeObject]) -> RuntimeObject? {
        for obj in objects {
            if obj.name == name || obj.displayName == name {
                return obj
            }
            if let found = findObject(named: name, in: obj.children) {
                return found
            }
        }
        return nil
    }
}

```

`RuntimeViewerMCP/Sources/RuntimeViewerMCPBridge/MCPBridgeWindowProvider.swift`:

```swift
#if os(macOS)
import RuntimeViewerCore
import RuntimeViewerMCPShared

/// A context representing a single window for MCP bridge operations.
public struct MCPBridgeWindowContext {
    public let identifier: String
    public let displayName: String?
    public let isKeyWindow: Bool
    public let selectedRuntimeObject: RuntimeObject?
    public let runtimeEngine: RuntimeEngine

    public init(
        identifier: String,
        displayName: String?,
        isKeyWindow: Bool,
        selectedRuntimeObject: RuntimeObject?,
        runtimeEngine: RuntimeEngine
    ) {
        self.identifier = identifier
        self.displayName = displayName
        self.isKeyWindow = isKeyWindow
        self.selectedRuntimeObject = selectedRuntimeObject
        self.runtimeEngine = runtimeEngine
    }
}

/// Protocol for providing window information to the MCP bridge.
/// The main app should implement this to map its document/window architecture to MCP.
public protocol MCPBridgeWindowProvider: AnyObject, Sendable {
    @MainActor func allWindowContexts() -> [MCPBridgeWindowContext]
    @MainActor func windowContext(forIdentifier identifier: String) -> MCPBridgeWindowContext?
}
#endif

```

`RuntimeViewerMCP/Sources/RuntimeViewerMCPShared/MCPBridgeProtocol.swift`:

```swift
import Foundation

// MARK: - Command identifiers

public enum MCPBridgeCommand: String, Sendable {
    case listWindows = "com.RuntimeViewer.MCP.listWindows"
    case selectedType = "com.RuntimeViewer.MCP.selectedType"
    case typeInterface = "com.RuntimeViewer.MCP.typeInterface"
    case listTypes = "com.RuntimeViewer.MCP.listTypes"
    case searchTypes = "com.RuntimeViewer.MCP.searchTypes"
    case grepTypeInterface = "com.RuntimeViewer.MCP.grepTypeInterface"
}

// MARK: - List Windows

public struct MCPWindowInfo: Codable, Sendable {
    public let identifier: String
    public let displayName: String?
    public let isKeyWindow: Bool
    public let selectedTypeName: String?
    public let selectedTypeImagePath: String?

    public init(
        identifier: String,
        displayName: String?,
        isKeyWindow: Bool,
        selectedTypeName: String?,
        selectedTypeImagePath: String?
    ) {
        self.identifier = identifier
        self.displayName = displayName
        self.isKeyWindow = isKeyWindow
        self.selectedTypeName = selectedTypeName
        self.selectedTypeImagePath = selectedTypeImagePath
    }
}

public struct MCPListWindowsResponse: Codable, Sendable {
    public let windows: [MCPWindowInfo]

    public init(windows: [MCPWindowInfo]) {
        self.windows = windows
    }
}

// MARK: - Selected Type

public struct MCPSelectedTypeRequest: Codable, Sendable {
    public let windowIdentifier: String

    public init(windowIdentifier: String) {
        self.windowIdentifier = windowIdentifier
    }
}

public struct MCPSelectedTypeResponse: Codable, Sendable {
    public let imagePath: String?
    public let typeName: String?
    public let displayName: String?
    public let typeKind: String?
    public let interfaceText: String?

    public init(
        imagePath: String?,
        typeName: String?,
        displayName: String?,
        typeKind: String?,
        interfaceText: String?
    ) {
        self.imagePath = imagePath
        self.typeName = typeName
        self.displayName = displayName
        self.typeKind = typeKind
        self.interfaceText = interfaceText
    }
}

// MARK: - Type Interface

public struct MCPTypeInterfaceRequest: Codable, Sendable {
    public let windowIdentifier: String
    public let imagePath: String?
    public let typeName: String

    public init(windowIdentifier: String, imagePath: String?, typeName: String) {
        self.windowIdentifier = windowIdentifier
        self.imagePath = imagePath
        self.typeName = typeName
    }
}

public struct MCPTypeInterfaceResponse: Codable, Sendable {
    public let imagePath: String?
    public let typeName: String?
    public let displayName: String?
    public let typeKind: String?
    public let interfaceText: String?
    public let error: String?

    public init(
        imagePath: String?,
        typeName: String?,
        displayName: String?,
        typeKind: String?,
        interfaceText: String?,
        error: String?
    ) {
        self.imagePath = imagePath
        self.typeName = typeName
        self.displayName = displayName
        self.typeKind = typeKind
        self.interfaceText = interfaceText
        self.error = error
    }
}

// MARK: - Shared Data Types

public struct MCPRuntimeTypeInfo: Codable, Sendable {
    public let name: String
    public let displayName: String
    public let kind: String
    public let imagePath: String

    public init(name: String, displayName: String, kind: String, imagePath: String) {
        self.name = name
        self.displayName = displayName
        self.kind = kind
        self.imagePath = imagePath
    }
}

public struct MCPGrepMatch: Codable, Sendable {
    public let typeName: String
    public let kind: String
    public let matchingLines: [String]

    public init(typeName: String, kind: String, matchingLines: [String]) {
        self.typeName = typeName
        self.kind = kind
        self.matchingLines = matchingLines
    }
}

// MARK: - List Types

public struct MCPListTypesRequest: Codable, Sendable {
    public let windowIdentifier: String
    public let imagePath: String?

    public init(windowIdentifier: String, imagePath: String?) {
        self.windowIdentifier = windowIdentifier
        self.imagePath = imagePath
    }
}

public struct MCPListTypesResponse: Codable, Sendable {
    public let types: [MCPRuntimeTypeInfo]
    public let error: String?

    public init(types: [MCPRuntimeTypeInfo], error: String?) {
        self.types = types
        self.error = error
    }
}

// MARK: - Search Types

public struct MCPSearchTypesRequest: Codable, Sendable {
    public let windowIdentifier: String
    public let query: String
    public let imagePath: String?

    public init(windowIdentifier: String, query: String, imagePath: String?) {
        self.windowIdentifier = windowIdentifier
        self.query = query
        self.imagePath = imagePath
    }
}

public struct MCPSearchTypesResponse: Codable, Sendable {
    public let types: [MCPRuntimeTypeInfo]
    public let error: String?

    public init(types: [MCPRuntimeTypeInfo], error: String?) {
        self.types = types
        self.error = error
    }
}

// MARK: - Grep Type Interface

public struct MCPGrepTypeInterfaceRequest: Codable, Sendable {
    public let windowIdentifier: String
    public let imagePath: String?
    public let pattern: String

    public init(windowIdentifier: String, imagePath: String?, pattern: String) {
        self.windowIdentifier = windowIdentifier
        self.imagePath = imagePath
        self.pattern = pattern
    }
}

public struct MCPGrepTypeInterfaceResponse: Codable, Sendable {
    public let matches: [MCPGrepMatch]
    public let error: String?

    public init(matches: [MCPGrepMatch], error: String?) {
        self.matches = matches
        self.error = error
    }
}

```

`RuntimeViewerMCP/Sources/RuntimeViewerMCPShared/MCPBridgeTransport.swift`:

```swift
import Foundation
import Network

// MARK: - Simple JSON-over-TCP transport for MCP Bridge communication
//
// Protocol: Each message is a 4-byte big-endian length prefix followed by UTF-8 JSON data.
// Request format:  { "identifier": "<command>", "payload": <json> }
// Response format: { "payload": <json> }

public struct MCPBridgeEnvelope: Codable, Sendable {
    public let identifier: String
    public let payload: Data

    public init(identifier: String, payload: Data) {
        self.identifier = identifier
        self.payload = payload
    }

    public init<T: Encodable>(identifier: String, value: T) throws {
        self.identifier = identifier
        self.payload = try JSONEncoder().encode(value)
    }

    public func decode<T: Decodable>(_ type: T.Type) throws -> T {
        try JSONDecoder().decode(type, from: payload)
    }
}

public struct MCPBridgeResponseEnvelope: Codable, Sendable {
    public let payload: Data

    public init(payload: Data) {
        self.payload = payload
    }

    public init<T: Encodable>(value: T) throws {
        self.payload = try JSONEncoder().encode(value)
    }

    public func decode<T: Decodable>(_ type: T.Type) throws -> T {
        try JSONDecoder().decode(type, from: payload)
    }
}

// MARK: - Frame encoding/decoding

public enum MCPBridgeFrame {
    public static func encode(_ data: Data) -> Data {
        var length = UInt32(data.count).bigEndian
        var frame = Data(bytes: &length, count: 4)
        frame.append(data)
        return frame
    }

    public static func send(_ data: Data, on connection: NWConnection) async throws {
        let frame = encode(data)
        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            connection.send(content: frame, completion: .contentProcessed { error in
                if let error {
                    continuation.resume(throwing: error)
                } else {
                    continuation.resume()
                }
            })
        }
    }

    public static func receive(from connection: NWConnection) async throws -> Data {
        // Read 4-byte length prefix
        let lengthData = try await receiveExact(from: connection, count: 4)
        let length = lengthData.withUnsafeBytes { $0.load(as: UInt32.self).bigEndian }
        guard length > 0, length < 10_000_000 else {
            throw MCPBridgeTransportError.invalidFrameLength(length)
        }
        // Read payload
        return try await receiveExact(from: connection, count: Int(length))
    }

    private static func receiveExact(from connection: NWConnection, count: Int) async throws -> Data {
        var buffer = Data()
        buffer.reserveCapacity(count)
        while buffer.count < count {
            let remaining = count - buffer.count
            let chunk = try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Data, Error>) in
                connection.receive(minimumIncompleteLength: 1, maximumLength: remaining) { content, _, isComplete, error in
                    if let error {
                        continuation.resume(throwing: error)
                    } else if let content, !content.isEmpty {
                        continuation.resume(returning: content)
                    } else if isComplete {
                        continuation.resume(throwing: MCPBridgeTransportError.connectionClosed)
                    } else {
                        continuation.resume(throwing: MCPBridgeTransportError.incompleteRead)
                    }
                }
            }
            buffer.append(chunk)
        }
        return buffer
    }
}

public enum MCPBridgeTransportError: Error, Sendable {
    case invalidFrameLength(UInt32)
    case connectionClosed
    case incompleteRead
    case encodingFailed
    case decodingFailed
    case serverNotRunning
    case connectionFailed
    case timeout
}

```

`RuntimeViewerPackages/Package.swift`:

```swift
// swift-tools-version: 6.2
// The swift-tools-version declares the minimum version of Swift required to build this package.

import PackageDescription
import Foundation

let appkitPlatforms: [Platform] = [.macOS]

let uikitPlatforms: [Platform] = [.iOS, .tvOS, .visionOS]

let usingSystemUXKit = true

var sharedSwiftSettings: [SwiftSetting] = []

if usingSystemUXKit {
    sharedSwiftSettings.append(.define("USING_SYSTEM_UXKIT"))
}

struct MxIrisStudioWorkspace: RawRepresentable, ExpressibleByStringLiteral, CustomStringConvertible {
    let rawValue: String

    init(rawValue value: String) {
        self.rawValue = value
    }

    init(stringLiteral value: StringLiteralType) {
        self.rawValue = value
    }

    static let forkDirectory: MxIrisStudioWorkspace = "../../../../Fork"

    static let forkLibraryDirectory: MxIrisStudioWorkspace = "../../../../Fork/Library"

    static let personalDirectory: MxIrisStudioWorkspace = "../../../../Personal"

    static let personalLibraryDirectory: MxIrisStudioWorkspace = "../../../../Personal/Library"

    static let personalLibraryMacOSDirectory: MxIrisStudioWorkspace = "../../../../Personal/Library/macOS"

    static let personalLibraryIOSDirectory: MxIrisStudioWorkspace = "../../../../Personal/Library/iOS"

    static let personalLibraryMuiltplePlatfromDirectory: MxIrisStudioWorkspace = "../../../../Personal/Library/Multi"

    var description: String {
        rawValue
    }

    func libraryPath(_ libraryName: String) -> String {
        "\(rawValue)/\(libraryName)"
    }
}

extension Package.Dependency {
    enum LocalSearchPath {
        case package(path: String, isRelative: Bool, isEnabled: Bool)
    }

    static func package(local localSearchPaths: LocalSearchPath..., remote: Package.Dependency) -> Package.Dependency {
        let currentFilePath = #filePath
        let isClonedDependency = currentFilePath.contains("/checkouts/") ||
            currentFilePath.contains("/SourcePackages/") ||
            currentFilePath.contains("/.build/")

        if isClonedDependency {
            return remote
        }
        for local in localSearchPaths {
            switch local {
            case .package(let path, let isRelative, let isEnabled):
                guard isEnabled else { continue }
                let url = if isRelative, let resolvedURL = URL(string: path, relativeTo: URL(fileURLWithPath: #filePath)) {
                    resolvedURL
                } else {
                    URL(fileURLWithPath: path)
                }

                if FileManager.default.fileExists(atPath: url.path) {
                    return .package(path: url.path)
                }
            }
        }
        return remote
    }
}

let package = Package(
    name: "RuntimeViewerPackages",
    platforms: [
        .macOS(.v15), .iOS(.v18), .macCatalyst(.v18), .tvOS(.v18), .visionOS(.v2),
    ],
    products: [
        .library(
            name: "RuntimeViewerUI",
            targets: ["RuntimeViewerUI"]
        ),
        .library(
            name: "RuntimeViewerArchitectures",
            targets: ["RuntimeViewerArchitectures"]
        ),
        .library(
            name: "RuntimeViewerApplication",
            targets: ["RuntimeViewerApplication"]
        ),
        .library(
            name: "RuntimeViewerService",
            targets: ["RuntimeViewerService"]
        ),
        .library(
            name: "RuntimeViewerServiceHelper",
            targets: ["RuntimeViewerServiceHelper"]
        ),
        .library(
            name: "RuntimeViewerHelperClient",
            targets: ["RuntimeViewerHelperClient"]
        ),
        .library(
            name: "RuntimeViewerSettings",
            targets: ["RuntimeViewerSettings"]
        ),
        .library(
            name: "RuntimeViewerSettingsUI",
            targets: ["RuntimeViewerSettingsUI"]
        ),
        .library(
            name: "RuntimeViewerCatalystExtensions",
            targets: ["RuntimeViewerCatalystExtensions"]
        ),
    ],
    dependencies: [
        .package(
            path: "../RuntimeViewerCore"
        ),
        .package(
            url: "https://github.com/ChimeHQ/Rearrange.git",
            from: "2.0.0"
        ),
        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryMuiltplePlatfromDirectory.libraryPath("UIFoundation"),
                isRelative: true,
                isEnabled: true
            ),
            .package(
                path: "../../UIFoundation",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/Mx-Iris/UIFoundation",
                branch: "main"
            )
        ),

        .package(
            local: .package(
                path: MxIrisStudioWorkspace.forkLibraryDirectory.libraryPath("XCoordinator"),
                isRelative: true,
                isEnabled: true
            ),
            .package(
                path: "../../XCoordinator",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/MxIris-Library-Forks/XCoordinator",
                branch: "master"
            )
        ),

        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryMacOSDirectory.libraryPath("CocoaCoordinator"),
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/Mx-Iris/CocoaCoordinator",
                branch: "main"
            )
        ),
        .package(
            url: "https://github.com/SnapKit/SnapKit",
            from: "5.0.0"
        ),
        .package(
            url: "https://github.com/ReactiveX/RxSwift",
            from: "6.0.0"
        ),

        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryMuiltplePlatfromDirectory.libraryPath("RxSwiftPlus"),
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/Mx-Iris/RxSwiftPlus",
                branch: "main"
            )
        ),
        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryMacOSDirectory.libraryPath("OpenUXKit"),
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/OpenUXKit/OpenUXKit",
                branch: "main"
            )
        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/NSAttributedStringBuilder",
            branch: "master"
        ),
        .package(
            url: "https://github.com/Mx-Iris/SFSymbols",
            branch: "main"
        ),
        .package(
            url: "https://github.com/CombineCommunity/RxCombine",
            from: "2.0.1"
        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/ide-icons",
            from: "0.1.0"
        ),
        .package(
            url: "https://github.com/gringoireDM/RxEnumKit",
            from: "2.0.0"
        ),
        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryMacOSDirectory.libraryPath("RxAppKit"),
                isRelative: true,
                isEnabled: true
            ),
            .package(
                path: "../../RxAppKit",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/Mx-Iris/RxAppKit",
                branch: "main"
            )
        ),
        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryIOSDirectory.libraryPath("RxUIKit"),
                isRelative: true,
                isEnabled: true
            ),
            .package(
                path: "../../RxUIKit",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/Mx-Iris/RxUIKit",
                branch: "main"
            )
        ),
        .package(
            local: .package(
                path: MxIrisStudioWorkspace.forkLibraryDirectory.libraryPath("filter-ui"),
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/MxIris-macOS-Library-Forks/filter-ui",
                branch: "main"
            )
        ),
        .package(
            url: "https://github.com/TrGiLong/RxConcurrency",
            from: "0.1.1"
        ),
        .package(
            local: .package(
                path: "../../MachInjector",
                isRelative: true,
                isEnabled: true
            ),
            .package(
                path: MxIrisStudioWorkspace.personalLibraryMacOSDirectory.libraryPath("MachInjector"),
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/MxIris-Reverse-Engineering/MachInjector",
                from: "0.1.0"
            )
        ),
        .package(
            url: "https://github.com/MxIris-macOS-Library-Forks/SwiftyXPC",
            branch: "main"
        ),
        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryMacOSDirectory.libraryPath("RunningApplicationKit"),
                isRelative: true,
                isEnabled: true
            ),
            .package(
                path: "../../RunningApplicationKit",
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/Mx-Iris/RunningApplicationKit",
                from: "0.1.1"
            )
        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/swift-memberwise-init-macro",
            from: "0.5.3-fork"
        ),
        .package(
            url: "https://github.com/pointfreeco/swift-dependencies",
            from: "1.9.4"
        ),
//        .package(
//            url: "https://github.com/dagronf/DSFInspectorPanes",
//            from: "3.0.0"
//        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/LateResponders",
            branch: "develop"
        ),
        .package(
            url: "https://github.com/ukushu/Ifrit",
            from: "3.0.0"
        ),
        .package(
            url: "https://github.com/database-utility/fuzzy-search.git",
            branch: "main"
        ),
        .package(
            url: "https://github.com/MxIris-macOS-Library-Forks/AppKitUI",
            branch: "main"
        ),
        .package(
            url: "https://github.com/sindresorhus/KeyboardShortcuts",
            from: "2.4.0"
        ),
        .package(
            local: .package(
                path: "../../DSFQuickActionBar",
                isRelative: true,
                isEnabled: true
            ),
            .package(
                path: MxIrisStudioWorkspace.forkLibraryDirectory.libraryPath("DSFQuickActionBar"),
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/MxIris-macOS-Library-Forks/DSFQuickActionBar",
                branch: "main"
            )
        ),
        .package(
            local: .package(
                path: MxIrisStudioWorkspace.personalLibraryMacOSDirectory.libraryPath("SystemHUD"),
                isRelative: true,
                isEnabled: true
            ),
            remote: .package(
                url: "https://github.com/Mx-Iris/SystemHUD",
                branch: "main"
            )
        ),
        .package(
            url: "https://github.com/Aeastr/SettingsKit",
            from: "2.0.1"
        ),
        .package(
            url: "https://github.com/MxIris-Library-Forks/swift-navigation",
            branch: "main"
        ),
        .package(
            url: "https://github.com/siteline/swiftui-introspect",
            from: "26.0.0"
        ),
    ],
    targets: [
        .target(
            name: "RuntimeViewerArchitectures",
            dependencies: [
                .product(name: "RxSwift", package: "RxSwift"),
                .product(name: "RxCocoa", package: "RxSwift"),
                .product(name: "RxSwiftPlus", package: "RxSwiftPlus"),
                .product(name: "RxDefaultsPlus", package: "RxSwiftPlus"),
                .product(name: "RxAppKit", package: "RxAppKit", condition: .when(platforms: appkitPlatforms)),
                .product(name: "RxUIKit", package: "RxUIKit", condition: .when(platforms: uikitPlatforms)),
                .product(name: "RxCombine", package: "RxCombine"),
                .product(name: "RxEnumKit", package: "RxEnumKit"),
                .product(name: "RxConcurrency", package: "RxConcurrency"),
                .product(name: "XCoordinator", package: "XCoordinator", condition: .when(platforms: uikitPlatforms)),
                .product(name: "XCoordinatorRx", package: "XCoordinator", condition: .when(platforms: uikitPlatforms)),
                .product(name: "CocoaCoordinator", package: "CocoaCoordinator", condition: .when(platforms: appkitPlatforms)),
                .product(name: "RxCocoaCoordinator", package: "CocoaCoordinator", condition: .when(platforms: appkitPlatforms)),
                .product(name: usingSystemUXKit ? "UXKitCoordinator" : "OpenUXKitCoordinator", package: "CocoaCoordinator", condition: .when(platforms: appkitPlatforms)),
                .product(name: "Dependencies", package: "swift-dependencies"),
                .product(name: "SwiftNavigation", package: "swift-navigation"),
//                .product(name: "SwiftUINavigation", package: "swift-navigation"),
                .product(name: "AppKitNavigation", package: "swift-navigation", condition: .when(platforms: appkitPlatforms)),
                .product(name: "UIKitNavigation", package: "swift-navigation", condition: .when(platforms: uikitPlatforms)),
            ],
            swiftSettings: sharedSwiftSettings
        ),

        .target(
            name: "RuntimeViewerUI",
            dependencies: [
                .product(name: "UIFoundation", package: "UIFoundation"),
                .product(name: "UIFoundationToolbox", package: "UIFoundation"),
                .product(name: "SnapKit", package: "SnapKit"),
                .product(name: usingSystemUXKit ? "UXKit" : "OpenUXKit", package: "OpenUXKit", condition: .when(platforms: appkitPlatforms)),
                .product(name: "NSAttributedStringBuilder", package: "NSAttributedStringBuilder"),
                .product(name: "SFSymbols", package: "SFSymbols"),
                .product(name: "IDEIcons", package: "ide-icons"),
                .product(name: "FilterUI", package: "filter-ui", condition: .when(platforms: appkitPlatforms)),
                .product(name: "Rearrange", package: "Rearrange", condition: .when(platforms: appkitPlatforms)),
                .product(name: "RunningApplicationKit", package: "RunningApplicationKit", condition: .when(platforms: appkitPlatforms)),
                .product(name: "UIFoundationAppleInternal", package: "UIFoundation"),
                .product(name: "LateResponders", package: "LateResponders"),
                .product(name: "AppKitUI", package: "AppKitUI", condition: .when(platforms: appkitPlatforms)),
                .product(name: "KeyboardShortcuts", package: "KeyboardShortcuts", condition: .when(platforms: appkitPlatforms)),
                .product(name: "DSFQuickActionBar", package: "DSFQuickActionBar", condition: .when(platforms: appkitPlatforms)),
//                .product(name: "DSFInspectorPanes", package: "DSFInspectorPanes", condition: .when(platforms: appkitPlatforms)),
                .product(name: "SystemHUD", package: "SystemHUD", condition: .when(platforms: appkitPlatforms)),

            ],
            swiftSettings: sharedSwiftSettings
        ),

        .target(
            name: "RuntimeViewerSettings",
            dependencies: [
                .product(name: "RuntimeViewerCore", package: "RuntimeViewerCore"),
                .product(name: "Dependencies", package: "swift-dependencies"),
            ]
        ),

        .target(
            name: "RuntimeViewerSettingsUI",
            dependencies: [
                "RuntimeViewerUI",
                "RuntimeViewerSettings",
                .target(name: "RuntimeViewerHelperClient", condition: .when(platforms: appkitPlatforms)),
                .product(name: "SettingsKit", package: "SettingsKit"),
                .product(name: "SwiftUIIntrospect", package: "swiftui-introspect"),
            ],
            resources: [
                .process("Resources"),
            ]
        ),

        .target(
            name: "RuntimeViewerApplication",
            dependencies: [
                "RuntimeViewerUI",
                "RuntimeViewerArchitectures",
                .target(name: "RuntimeViewerSettings", condition: .when(platforms: appkitPlatforms)),
                .target(name: "RuntimeViewerSettingsUI", condition: .when(platforms: appkitPlatforms)),
                .product(name: "RuntimeViewerCore", package: "RuntimeViewerCore"),
                .product(name: "MemberwiseInit", package: "swift-memberwise-init-macro"),
                .product(name: "IfritStatic", package: "Ifrit"),
                .product(name: "FuzzySearch", package: "fuzzy-search"),
            ]
        ),

        .target(
            name: "RuntimeViewerService",
            dependencies: [
                .product(name: "RuntimeViewerCommunication", package: "RuntimeViewerCore"),
                .product(name: "SwiftyXPC", package: "SwiftyXPC", condition: .when(platforms: appkitPlatforms)),
                .product(name: "MachInjector", package: "MachInjector", condition: .when(platforms: appkitPlatforms)),
            ]
        ),

        .target(
            name: "RuntimeViewerServiceHelper"
        ),

        .target(
            name: "RuntimeViewerHelperClient",
            dependencies: [
                "RuntimeViewerServiceHelper",
                .product(name: "RuntimeViewerCommunication", package: "RuntimeViewerCore"),
                .product(name: "SwiftyXPC", package: "SwiftyXPC", condition: .when(platforms: appkitPlatforms)),
                .product(name: "Dependencies", package: "swift-dependencies"),
            ]
        ),
        .target(
            name: "RuntimeViewerCatalystExtensions",
            dependencies: [
                .product(name: "RuntimeViewerCommunication", package: "RuntimeViewerCore"),
            ]
        ),
    ],
    swiftLanguageModes: [.v5]
)

extension SwiftSetting {
    static let existentialAny: Self = .enableUpcomingFeature("ExistentialAny") // SE-0335, Swift 5.6,  SwiftPM 5.8+
    static let internalImportsByDefault: Self = .enableUpcomingFeature("InternalImportsByDefault") // SE-0409, Swift 6.0,  SwiftPM 6.0+
    static let memberImportVisibility: Self = .enableUpcomingFeature("MemberImportVisibility") // SE-0444, Swift 6.1,  SwiftPM 6.1+
    static let inferIsolatedConformances: Self = .enableUpcomingFeature("InferIsolatedConformances") // SE-0470, Swift 6.2,  SwiftPM 6.2+
    static let nonisolatedNonsendingByDefault: Self = .enableUpcomingFeature("NonisolatedNonsendingByDefault") // SE-0461, Swift 6.2,  SwiftPM 6.2+
    static let immutableWeakCaptures: Self = .enableUpcomingFeature("ImmutableWeakCaptures") // SE-0481, Swift 6.2,  SwiftPM 6.2+
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/AppDefaults.swift`:

```swift
import Foundation
import RxDefaultsPlus
import RuntimeViewerCommunication
import RuntimeViewerCore
import RuntimeViewerArchitectures
import Dependencies
import OrderedCollections

public final class AppDefaults {
    fileprivate static let shared = AppDefaults()

    private init() {
        guard !bookmarkMigrationCompleted else { return }

        // One-time migration from old flat storage to new structured storage
        let oldImageBookmarks = _imageBookmarks.wrappedValue
        if !oldImageBookmarks.isEmpty {
            var dict: [RuntimeSource: [RuntimeImageBookmark]] = [:]
            for bookmark in oldImageBookmarks {
                dict[bookmark.source, default: []].append(bookmark)
            }
            self.imageBookmarksByRuntimeSource = dict
        }

        let oldObjectBookmarks = _objectBookmarks.wrappedValue
        if !oldObjectBookmarks.isEmpty {
            var dict: [RuntimeSource: [String: [RuntimeObjectBookmark]]] = [:]
            for bookmark in oldObjectBookmarks {
                dict[bookmark.source, default: [:]][bookmark.object.imagePath, default: []].append(bookmark)
            }
            self.objectBookmarksBySourceAndImagePath = dict
        }

        // Defer setting the flag to allow FileStorage barrier writes to complete
        DispatchQueue.main.async {
            self.bookmarkMigrationCompleted = true
        }
    }
    
    @UserDefault(key: "generationOptions", defaultValue: .init())
    public var options: RuntimeObjectInterface.GenerationOptions

    @UserDefault(key: "themeProfile", defaultValue: XcodePresentationTheme())
    public var themeProfile: XcodePresentationTheme
    
    @UserDefault(key: "filterMode", defaultValue: nil)
    public var filterMode: FilterMode?

    @UserDefault(key: "bookmarkMigrationCompleted", defaultValue: false)
    private var bookmarkMigrationCompleted: Bool
    
    @available(*, deprecated, renamed: "imageBookmarksByRuntimeSource")
    @FileStorage("imageBookmarks", directory: .applicationSupportDirectory)
    public var imageBookmarks: [RuntimeImageBookmark] = []
    
    @available(*, deprecated, renamed: "objectBookmarksBySourceAndImagePath")
    @FileStorage("objectBookmarks", directory: .applicationSupportDirectory)
    public var objectBookmarks: [RuntimeObjectBookmark] = []
    
    @FileStorage("imageBookmarksByRuntimeSource", directory: .applicationSupportDirectory)
    public var imageBookmarksByRuntimeSource: [RuntimeSource: [RuntimeImageBookmark]] = [:]
    
    @FileStorage("objectBookmarksBySourceAndImagePath", directory: .applicationSupportDirectory)
    public var objectBookmarksBySourceAndImagePath: [RuntimeSource: [String: [RuntimeObjectBookmark]]] = [:]
}

private enum AppDefaultsKey: DependencyKey {
    static let liveValue: AppDefaults = .shared
    static let testValue: AppDefaults = .shared
}

extension DependencyValues {
    public var appDefaults: AppDefaults {
        get { self[AppDefaultsKey.self] }
        set { self[AppDefaultsKey.self] = newValue }
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Content/ContentPlaceholderViewModel.swift`:

```swift
import Foundation

public final class ContentPlaceholderViewModel: ViewModel<ContentRoute> {}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Content/ContentRoute.swift`:

```swift
import Foundation
import FoundationToolbox
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures

@AssociatedValue(.public)
@CaseCheckable(.public)
public enum ContentRoute: Routable {
    case placeholder
    case root(RuntimeObject)
    case next(RuntimeObject)
    case back
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Content/ContentTextViewModel.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
@preconcurrency import RuntimeViewerSettings
#endif

#if canImport(UIKit)
import UIKit
#endif

import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import MemberwiseInit
import Dependencies

public final class ContentTextViewModel: ViewModel<ContentRoute> {
    @Observed
    public private(set) var theme: ThemeProfile

    @Observed
    public private(set) var runtimeObject: RuntimeObject

    @Observed
    public private(set) var imageNameOfRuntimeObject: String?

    @Observed
    public private(set) var attributedString: NSAttributedString?

    public init(runtimeObject: RuntimeObject, documentState: DocumentState, router: any Router<ContentRoute>) {
        self.runtimeObject = runtimeObject
        self.theme = XcodePresentationTheme()
        super.init(documentState: documentState, router: router)

        self.imageNameOfRuntimeObject = runtimeObject.imageName

        let transformerObservable: Observable<Transformer.Configuration>
        #if canImport(AppKit) && !targetEnvironment(macCatalyst)
        transformerObservable = Observable<Transformer.Configuration>.create { observer in
            let settings = Settings.shared
            
            observer.onNext(settings.transformer)
            func observe() {
                withObservationTracking {
                    _ = settings.transformer
                } onChange: {
                    DispatchQueue.main.async {
                        observer.onNext(settings.transformer)
                        observe()
                    }
                }
            }
            observe()
            return Disposables.create()
        }
        #else
        transformerObservable = .just(.init())
        #endif

        Observable.combineLatest($runtimeObject, appDefaults.$options, appDefaults.$themeProfile, transformerObservable)
            .flatMapLatest { [unowned self] runtimeObject, options, theme, transformer in
                var mergedOptions = options
                mergedOptions.transformer = transformer
                return Observable.async {
                    try await self.documentState.runtimeEngine.interface(for: runtimeObject, options: mergedOptions).map { ($0.interfaceString, theme, runtimeObject) }
                }
                .trackActivity(_commonLoading)
            }
            .catchAndReturn(nil)
            .observeOnMainScheduler()
            .map { $0.map { $0.attributedString(for: $1, runtimeObjectName: $2) } }
            .bind(to: $attributedString)
            .disposed(by: rx.disposeBag)
    }

    @MemberwiseInit(.public)
    public struct Input {
        public let runtimeObjectClicked: Signal<RuntimeObject>
    }

    public struct Output {
        public let attributedString: Driver<NSAttributedString>
        public let runtimeObjectName: Driver<String>
        public let theme: Driver<ThemeProfile>
        public let imageNameOfRuntimeObject: Driver<String?>
        public let runtimeObjectNotFound: Signal<Void>
    }

    public func transform(_ input: Input) -> Output {
        let runtimeObjectNotFoundRelay = PublishRelay<Void>()
        
        input.runtimeObjectClicked
            .flatMapLatest { [unowned self] runtimeObject in
                Observable.async {
                    try await self.documentState.runtimeEngine.interface(for: runtimeObject, options: .init())
                }
                .trackActivity(_commonLoading)
                .asSignal(onErrorJustReturn: nil)
            }
            .emit(with: self) { target, interface in
                if let interface {
                    target.router.trigger(.next(interface.object))
                } else {
                    runtimeObjectNotFoundRelay.accept(())
                }
            }
            .disposed(by: rx.disposeBag)
        
        return Output(
            attributedString: $attributedString.asDriver().compactMap { $0 },
            runtimeObjectName: $runtimeObject.asDriver().map { $0.displayName },
            theme: $theme.asDriver(),
            imageNameOfRuntimeObject: $imageNameOfRuntimeObject.asDriver(),
            runtimeObjectNotFound: runtimeObjectNotFoundRelay.asSignal()
        )
    }
}

extension NSAttributedString: @unchecked @retroactive Sendable {}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/DocumentState.swift`:

```swift
import Foundation
import Observation
import RuntimeViewerCore
import RuntimeViewerArchitectures

@MainActor
public final class DocumentState {
    public init() {}

    @Observed
    public var runtimeEngine: RuntimeEngine = .local

    @Observed
    public var selectedRuntimeObject: RuntimeObject?

    @Observed
    public var currentImageName: String?

    @Observed
    public var currentImagePath: String?

    @Observed
    public var currentSubtitle: String = ""
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Extensions.swift`:

```swift
#if os(macOS)
import AppKit
#else
import UIKit
#endif

import RuntimeViewerUI
import RuntimeViewerCore
import RuntimeViewerArchitectures

extension RuntimeObjectKind {

    #if os(macOS)
    public static let defaultIconSize: CGFloat = 18
    #else
    public static let defaultIconSize: CGFloat = 24
    #endif

    public static let defaultIconStyle: IDEIconStyle = .simple

    private struct IconCacheKey: Hashable {
        let text: String
        let color: IDEIconColor
        let style: IDEIconStyle
        let size: CGFloat
    }

    private static var iconCache: [IconCacheKey: NSUIImage] = [:]

    private var iconSpec: (text: String, color: IDEIconColor) {
        switch self {
        case .c(let kind):
            switch kind {
            case .struct: return ("S", .green)
            case .union:  return ("U", .green)
            }
        
        case .objc(.type(let kind)):
            switch kind {
            case .class:    return ("C", .yellow)
            case .protocol: return ("Pr", .purple)
            }
            
        case .objc(.category(.class)):
            return ("Ex", .yellow)
            
        case .swift(.type(let kind)):
            switch kind {
            case .enum:      return ("E", .blue)
            case .struct:    return ("S", .blue)
            case .class:     return ("C", .blue)
            case .protocol:  return ("Pr", .blue)
            case .typeAlias: return ("T", .blue)
            }
            
        case .swift(.extension(_)),
             .swift(.conformance(_)):
            return ("Ex", .blue)
            
        default:
            return ("?", .gray)
        }
    }

    public func icon(size: CGFloat = Self.defaultIconSize, style: IDEIconStyle = Self.defaultIconStyle) -> NSUIImage {
        let spec = self.iconSpec
        
        let key = IconCacheKey(
            text: spec.text,
            color: spec.color,
            style: style,
            size: size
        )
        
        if let cachedImage = Self.iconCache[key] {
            return cachedImage
        }
        
        let image = IDEIcon(
            spec.text,
            color: spec.color,
            style: style,
            size: size
        ).image
        
        Self.iconCache[key] = image
        
        return image
    }

    public var icon: NSUIImage {
        return icon()
    }
}

extension RuntimeImageLoadState: @retroactive CaseAccessible {}

#if canImport(UIKit)

extension UIColor {
    static var labelColor: UIColor { .label }
    static var secondaryLabelColor: UIColor { .secondaryLabel }
    static var tertiaryLabelColor: UIColor { .tertiaryLabel }
    static var quaternaryLabelColor: UIColor { .quaternaryLabel }
}

#endif

extension RuntimeImageNode: @retroactive Sequence {
    public func makeIterator() -> Iterator {
        return Iterator(node: self)
    }

    public struct Iterator: IteratorProtocol {
        var stack: [RuntimeImageNode] = []

        init(node: RuntimeImageNode) {
            self.stack = [node]
        }

        public mutating func next() -> RuntimeImageNode? {
            if let node = stack.popLast() {
                stack.append(contentsOf: node.children.reversed())
                return node
            }
            return nil
        }
    }
}

extension RuntimeImageNode {
    public static let frameworkIcon: NSUIImage = SFSymbols(systemName: .latch2Case).nsuiImgae

    public static let bundleIcon: NSUIImage = SFSymbols(systemName: .shippingbox).nsuiImgae

    public static let imageIcon: NSUIImage = SFSymbols(systemName: .doc).nsuiImgae

    public static let folderIcon: NSUIImage = SFSymbols(systemName: .folder).nsuiImgae

    public var icon: NSUIImage {
        if name.hasSuffix("framework") {
            Self.frameworkIcon
        } else if name.hasSuffix("bundle") {
            Self.bundleIcon
        } else if isLeaf {
            Self.imageIcon
        } else {
            Self.folderIcon
        }
    }
}

extension NSUIColor {
    public convenience init(light: NSUIColor, dark: NSUIColor) {
        #if os(macOS)
        self.init(name: nil) { appearance in
            appearance.isLight ? light : dark
        }
        #else
        self.init { traitCollection in
            traitCollection.userInterfaceStyle == .light ? light : dark
        }
        #endif
    }
}

extension String {
    // MARK: - Index to Int Conversion

    /// Converts String.Index to Int (Integer offset).
    /// - Parameter index: The String.Index to convert.
    /// - Returns: The integer offset corresponding to the index.
    func integerIndex(of index: String.Index) -> Int {
        return distance(from: startIndex, to: index)
    }

    // MARK: - Int to Index Conversion

    /// Converts Int (Integer offset) to String.Index.
    /// - Parameter offset: The integer offset.
    /// - Returns: The corresponding String.Index, or nil if out of bounds.
    func index(at offset: Int) -> String.Index? {
        guard offset >= 0, offset <= count else { return nil }
        return index(startIndex, offsetBy: offset)
    }

    // MARK: - Range<String.Index> to Range<Int>

    /// Converts Range<String.Index> to Range<Int> (NSRange style).
    /// - Parameter range: The range of String.Index.
    /// - Returns: The corresponding Range<Int>.
    func integerRange(from range: Range<String.Index>) -> Range<Int> {
        let start = integerIndex(of: range.lowerBound)
        let end = integerIndex(of: range.upperBound)
        return start ..< end
    }

    // MARK: - Range<Int> to Range<String.Index>

    /// Converts Range<Int> to Range<String.Index>.
    /// - Parameter range: The range of integers.
    /// - Returns: The corresponding Range<String.Index>, or nil if indices are invalid.
    func indexRange(from range: Range<Int>) -> Range<String.Index>? {
        guard let start = index(at: range.lowerBound),
              let end = index(at: range.upperBound) else {
            return nil
        }
        return start ..< end
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/FilterEngine.swift`:

```swift
import Foundation
import FoundationToolbox
import Ifrit
import FuzzySearch

public enum FilterMode: Int, CaseIterable, Codable, CustomStringConvertible {
    case fuzzySearch
    case ifrit
    
    public var description: String {
        switch self {
        case .fuzzySearch:
            "Fuzzy Search"
        case .ifrit:
            "Ifrit"
        }
    }
}

enum FilterEngine {
    @dynamicMemberLookup
    private struct FuzzySearchableBox<Item: FilterableItem>: FuzzySearchable {
        let wrappedValue: Item

        init(_ wrappedValue: Item) {
            self.wrappedValue = wrappedValue
        }

        var fuzzyStringToMatch: String { wrappedValue.filterableString }

        subscript<Value>(dynamicMember keyPath: KeyPath<Item, Value>) -> Value {
            wrappedValue[keyPath: keyPath]
        }
    }

    static func filter<Item: FilterableItem>(_ filter: String, items: [Item], mode: FilterMode?, isCaseInsensitive: Bool) -> [Item] {
        for item in items {
            item.filter = filter
            item.isCaseInsensitive = isCaseInsensitive
            item.filterResult = nil
        }
        guard !filter.isEmpty else {
            for item in items {
                item.filterResult = nil
            }
            return items
        }

        switch mode {
        case .fuzzySearch:
            let results = items.map { FuzzySearchableBox($0) }.fuzzyMatch(filter)
            var filteredItems: [Item] = []
            for result in results {
                let item = result.item.wrappedValue
                item.filterResult = result.result
                filteredItems.append(item)
            }
            return filteredItems
        case .ifrit:
            let fuse = Fuse()
            let results = fuse.searchSync(filter, in: items.map { [FuseProp($0.filterableString)] }).map { FuzzySrchResultWrapper($0) }.sorted()
            var filteredItems: [Item] = []
            for result in results {
                let item = items[result.index]
                item.filterResult = result
                filteredItems.append(item)
            }
            return filteredItems
        case .none:
            return items.filter {
                if isCaseInsensitive {
                    $0.filterableString.contains(filter)
                } else {
                    $0.filterableString.localizedCaseInsensitiveContains(filter)
                }
            }
        }
    }
}

protocol FilterableItem: AnyObject {
    var filter: String { set get }
    var filterResult: FuzzyFilterResult? { set get }
    var filterableString: String { get }
    var isCaseInsensitive: Bool { set get }
}

protocol FuzzyFilterResult {
    var ranges: [NSRange] { get }
}

@dynamicMemberLookup
struct FuzzySrchResultWrapper: ComparableBuildable {
    let wrappedValue: FuzzySrchResult
    
    init(_ wrappedValue: FuzzySrchResult) {
        self.wrappedValue = wrappedValue
    }

    var resultsScore: Double {
        wrappedValue.results.reduce(0) { $0 + $1.diffScore }
    }

    subscript<Value>(dynamicMember keyPath: KeyPath<FuzzySrchResult, Value>) -> Value {
        wrappedValue[keyPath: keyPath]
    }

    static var comparableDefinition: ComparableDefinition<FuzzySrchResultWrapper> = makeComparable {
        compare(\.wrappedValue.diffScore)
        compare(\.resultsScore)
    }
}

extension FuzzySrchResultWrapper: FuzzyFilterResult {
    var ranges: [NSRange] {
        wrappedValue.results.flatMap { $0.ranges.map { NSRange($0) } }
    }
}

extension FuzzySearchResult: FuzzyFilterResult {
    var ranges: [NSRange] {
        parts
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Inspector/InspectorClassViewModel.swift`:

```swift
import Foundation
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import MemberwiseInit

public final class InspectorClassViewModel: ViewModel<InspectorRoute> {
    @Observed
    private var runtimeObject: RuntimeObject

    @MemberwiseInit(.public)
    public struct Input {}

    public struct Output {
        public let classHierarchy: Driver<String>
    }

    public func transform(_ input: Input) -> Output {
        return Output(
            classHierarchy: $runtimeObject.flatMapLatest { [unowned self] runtimeObject in
                do {
                    return try await documentState.runtimeEngine.hierarchy(for: runtimeObject).joined(separator: "\n")
                } catch {
                    logger.error("Failed to fetch class hierarchy for runtime object: \("\(runtimeObject)", privacy: .public) with error: \(error, privacy: .public)")
                    return runtimeObject.displayName
                }
            }.catchAndReturn(runtimeObject.displayName).observeOnMainScheduler().asDriverOnErrorJustComplete()
        )
    }

    public init(runtimeObject: RuntimeObject, documentState: DocumentState, router: any Router<InspectorRoute>) {
        self.runtimeObject = runtimeObject
        super.init(documentState: documentState, router: router)
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Inspector/InspectorRoute.swift`:

```swift
import Foundation
import FoundationToolbox
import RuntimeViewerCore
import RuntimeViewerArchitectures

public enum InspectableObject {
    case node(RuntimeImageNode)
    case object(RuntimeObject)
}

@AssociatedValue(.public)
@CaseCheckable(.public)
public enum InspectorRoute: Routable {
    case placeholder
    case root(InspectableObject)
    case next(InspectableObject)
    case back
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Inspector/InspectorViewModel.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
#endif

#if canImport(UIKit)
import UIKit
#endif

import RuntimeViewerCore
import RuntimeViewerArchitectures

public final class InspectorPlaceholderViewModel: ViewModel<InspectorRoute> {}
//public class InspectorRuntimeObjectViewModel: ViewModel<InspectorRoute> {
//    @Observed
//    var runtimeObject: RuntimeObjCRuntimeObject
//
//    @Observed
//    var runtimeObjectHierarchy: [String] = []
//
//    public struct Input {}
//
//    public struct Output {}
//
//    public func transform(_ input: Input) -> Output {
//        Output()
//    }
//
//    init(runtimeObject: RuntimeObjCRuntimeObject, documentState: DocumentState, router: any Router<InspectorRoute>) {
//        self.runtimeObject = runtimeObject
//        super.init(documentState: documentState, router: router)
////        $runtimeObject.flatMap { appState.runtimeEngine. }
//    }
//}

public final class InspectorRuntimeNodeViewModel: ViewModel<InspectorRoute> {
    @Observed
    var runtimeNode: RuntimeImageNode

    init(runtimeNode: RuntimeImageNode, documentState: DocumentState, router: any Router<InspectorRoute>) {
        self.runtimeNode = runtimeNode
        super.init(documentState: documentState, router: router)
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRootBookmarkViewModel.swift`:

```swift
#if os(macOS)

import Foundation
import RuntimeViewerCore
import RuntimeViewerArchitectures
import MemberwiseInit

public final class SidebarRootBookmarkViewModel: SidebarRootViewModel {
    override var isFilterEmptyNodes: Bool {
        false
    }

    public init(documentState: DocumentState, router: any Router<SidebarRootRoute>) {
        @Dependency(\.appDefaults)
        var appDefaults

        let nodesSource = appDefaults.$imageBookmarksByRuntimeSource.map { $0[documentState.runtimeEngine.source, default: []].map(\.imageNode) }

        super.init(documentState: documentState, router: router, nodesSource: nodesSource)
    }

    @MemberwiseInit(.public)
    public struct Input {
        public let moveBookmark: Signal<OutlineMove>
        public let removeBookmark: Signal<Int>
    }

    public struct Output {
        public let isMoveBookmarkEnabled: Driver<Bool>
        public let isBookmarkEmpty: Driver<Bool>
    }

    public func transform(_ input: Input) -> Output {
        input.moveBookmark.emitOnNext { [weak self] outlineMove in
            guard let self else { return }
            var bookmarks = appDefaults.imageBookmarksByRuntimeSource
            var sourceBookmarks = bookmarks[documentState.runtimeEngine.source, default: []]
            outlineMove.applyToRoots(&sourceBookmarks)
            bookmarks[documentState.runtimeEngine.source] = sourceBookmarks
            appDefaults.imageBookmarksByRuntimeSource = bookmarks
        }
        .disposed(by: rx.disposeBag)

        input.removeBookmark
            .emitOnNext { [weak self] index in
                guard let self else { return }
                var bookmarks = appDefaults.imageBookmarksByRuntimeSource
                bookmarks[documentState.runtimeEngine.source, default: []].remove(at: index)
                appDefaults.imageBookmarksByRuntimeSource = bookmarks
            }
            .disposed(by: rx.disposeBag)
        return Output(
            isMoveBookmarkEnabled: $isFiltering.asDriver().not(),
            isBookmarkEmpty: appDefaults.$imageBookmarksByRuntimeSource.asDriver(onErrorJustReturn: [:]).map { $0[self.documentState.runtimeEngine.source, default: []].isEmpty }
        )
    }
}

extension RuntimeImageBookmark: @retroactive OutlineNodeType {
    public var children: [RuntimeImageBookmark] { imageNode.children.map { .init(source: source, imageNode: $0) } }
}


#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRootCellViewModel.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
import RxAppKit
#endif

#if canImport(UIKit)
import UIKit
#endif

import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures

public final class SidebarRootCellViewModel: NSObject, OutlineNodeType, @unchecked Sendable {
    public let node: RuntimeImageNode

    public var children: [SidebarRootCellViewModel] {
        set {
            _children = newValue
            _filteredChildren = _children
        }
        get {
            _filteredChildren
        }
    }

    public var isLeaf: Bool { children.isEmpty }

    private lazy var _filteredChildren: [SidebarRootCellViewModel] = _children

    private lazy var _children: [SidebarRootCellViewModel] = {
        let children = node.children.map { SidebarRootCellViewModel(node: $0) }
        return children.sorted { $0.node.name < $1.node.name }
    }()

    public private(set) lazy var currentAndChildrenNames: String = {
        let childrenNames = _children.map { $0.currentAndChildrenNames }.joined(separator: " ")
        if childrenNames.isEmpty {
            return node.name
        } else {
            return "\(node.name) \(childrenNames)"
        }
    }()

    var filter: String = "" {
        didSet {
            if filter.isEmpty {
                _children.forEach { $0.filter = filter }
                _filteredChildren = _children
            } else {
                _children.forEach { $0.filter = filter }
                _filteredChildren = _children.filter { $0.currentAndChildrenNames.localizedCaseInsensitiveContains(filter) }
            }
        }
    }
    
    @Observed
    public private(set) var icon: NSUIImage?

    @Observed
    public private(set) var name: NSAttributedString

    public init(node: RuntimeImageNode) {
        self.node = node
        self.name = NSAttributedString {
            AText(node.name)
                .foregroundColor(.labelColor)
                .font(.systemFont(ofSize: 13))
                .paragraphStyle(NSMutableParagraphStyle().then { $0.lineBreakMode = .byTruncatingTail })
        }
        self.icon = node.icon
    }

    public func makeIterator() -> Iterator {
        return Iterator(node: self)
    }
    
//    func applyMove(to roots: inout [Self]) {
//        
//    }

    public struct Iterator: IteratorProtocol {
        var stack: [SidebarRootCellViewModel] = []

        init(node: SidebarRootCellViewModel) {
            self.stack = [node]
        }

        public mutating func next() -> SidebarRootCellViewModel? {
            if let node = stack.popLast() {
                stack.append(contentsOf: node.children.reversed())
                return node
            }
            return nil
        }
    }
}

#if canImport(AppKit) && !targetEnvironment(macCatalyst)

extension SidebarRootCellViewModel: Differentiable {}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRootDirectoryViewModel.swift`:

```swift
import Foundation
import RuntimeViewerCore
import RuntimeViewerArchitectures
import MemberwiseInit

public final class SidebarRootDirectoryViewModel: SidebarRootViewModel {
    
    public let nodesSubject = BehaviorSubject<[RuntimeImageNode]>(value: [])
    
    public init(documentState: DocumentState, router: any Router<SidebarRootRoute>) {
        super.init(documentState: documentState, router: router, nodesSource: nodesSubject.asObservable())
        
        Task {
            await documentState.runtimeEngine
                .$imageNodes
                .asObservable()
                .bind(to: nodesSubject)
                .disposed(by: rx.disposeBag)
        }
    }

    @MemberwiseInit(.public)
    public struct Input {
        public let addBookmark: Signal<SidebarRootCellViewModel>
    }

    public struct Output {}

    public func transform(_ input: Input) -> Output {
        let appDefaults = appDefaults
        let documentState = documentState
        input.addBookmark
            .emitOnNextMainActor { cellViewModel in
                let runtimeSource = documentState.runtimeEngine.source
                let bookmark = RuntimeImageBookmark(source: runtimeSource, imageNode: cellViewModel.node)
                appDefaults.imageBookmarksByRuntimeSource[runtimeSource, default: []].append(bookmark)
            }
            .disposed(by: rx.disposeBag)
        return .init()
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRootViewModel.swift`:

```swift
import Foundation
import RuntimeViewerCore
import RuntimeViewerArchitectures
import MemberwiseInit

public class SidebarRootViewModel: ViewModel<SidebarRootRoute> {
    private let nodesSource: Observable<[RuntimeImageNode]>

    private var nodesIndexed: Signal<Void> = .empty()

    var isFilterEmptyNodes: Bool { true }

    @Observed
    public private(set) var nodes: [SidebarRootCellViewModel] = []

    @Observed
    public private(set) var filteredNodes: [SidebarRootCellViewModel] = []

    @Observed
    public private(set) var allNodes: [String: SidebarRootCellViewModel] = [:]

    @Observed
    public private(set) var isFiltering: Bool = false

    public init(documentState: DocumentState, router: any Router<SidebarRootRoute>, nodesSource: Observable<[RuntimeImageNode]>) {
        self.nodesSource = nodesSource

        super.init(documentState: documentState, router: router)

        nodesSource
            .observe(on: MainScheduler.instance)
            .map { $0.map { SidebarRootCellViewModel(node: $0) } }
            .bind(to: $nodes)
            .disposed(by: rx.disposeBag)

        let indexedNodes = $nodes
            .filter { [weak self] in
                guard let self else { return false }
                return isFilterEmptyNodes ? !$0.isEmpty : true
            }
            .observe(on: ConcurrentDispatchQueueScheduler(qos: .userInteractive))
            .flatMapLatest { nodes -> [String: SidebarRootCellViewModel] in
                Self.logger.info("\(Self.self, privacy: .public) Indexing sidebar nodes...")
                var allNodes: [String: SidebarRootCellViewModel] = [:]
                for rootNode in nodes {
                    allNodes[rootNode.node.name] = rootNode
                    let rootNodeSequence = AnySequence<SidebarRootCellViewModel> {
                        SidebarRootCellViewModel.Iterator(node: rootNode)
                    }
                    for node in rootNodeSequence {
                        allNodes[node.node.absolutePath] = node
                    }
                }
                return allNodes
            }
            .observe(on: MainScheduler.instance)
            .asSignal(onErrorJustReturn: [:])

        indexedNodes.emit(to: $allNodes).disposed(by: rx.disposeBag)

        self.nodesIndexed = indexedNodes.trackActivity(_commonLoading).asSignal().mapToVoid()
        
        
        $nodes
            .bind(to: $filteredNodes)
            .disposed(by: rx.disposeBag)
    }

    @MemberwiseInit(.public)
    public struct Input {
        public let clickedNode: Signal<SidebarRootCellViewModel>
        public let selectedNode: Signal<SidebarRootCellViewModel>
        public let searchString: Signal<String>
    }

    @MemberwiseInit(.public)
    public struct Output {
        public let nodes: Driver<[SidebarRootCellViewModel]>
        public let nodesIndexed: Signal<Void>
        public let didBeginFiltering: Signal<Void>
        public let didChangeFiltering: Signal<Void>
        public let didEndFiltering: Signal<Void>
    }

    public func transform(_ input: Input) -> Output {
        input.clickedNode.emitOnNextMainActor { [weak self] viewModel in
            guard let self else { return }

            if viewModel.node.isLeaf {
                #if os(macOS)
                self.router.trigger(.image(viewModel.node))
                #else
                self.router.trigger(.clickedNode(viewModel.node))
                #endif
            }
        }
        .disposed(by: rx.disposeBag)

        input.searchString
            .debounce(.milliseconds(500))
            .emitOnNextMainActor { [weak self] filter in
                guard let self else { return }
                for node in nodes {
                    node.filter = filter
                }
                if filter.isEmpty {
                    if isFiltering {
                        isFiltering = false
                    }
                    filteredNodes = nodes
                } else {
                    if !isFiltering {
                        isFiltering = true
                    }
                    filteredNodes = nodes.filter { $0.currentAndChildrenNames.localizedCaseInsensitiveContains(filter) }
                }
            }.disposed(by: rx.disposeBag)

        return Output(
            nodes: $filteredNodes.asDriver(),
            nodesIndexed: nodesIndexed,
            didBeginFiltering: $isFiltering.asSignal(onErrorJustReturn: false).filter { $0 }.mapToVoid(),
            didChangeFiltering: $filteredNodes.asSignal(onErrorJustReturn: []).withLatestFrom($isFiltering.asSignal(onErrorJustReturn: false)).filter { $0 }.mapToVoid(),
            didEndFiltering: $isFiltering.skip(1).asSignal(onErrorJustReturn: false).filter { !$0 }.mapToVoid()
        )
    }
}

extension Collection {
    fileprivate var isNotEmpty: Bool { !isEmpty }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRoutes.swift`:

```swift
import Foundation
import FoundationToolbox
import RuntimeViewerCore
import RuntimeViewerArchitectures

@AssociatedValue(.public)
@CaseCheckable(.public)
public enum SidebarRoute: Routable {
    case root
    case back
    case selectedNode(RuntimeImageNode)
    case clickedNode(RuntimeImageNode)
    case selectedObject(RuntimeObject)
    case exportInterface
}

#if os(macOS)
@AssociatedValue(.public)
@CaseCheckable(.public)
public enum SidebarRootRoute: Routable {
    case initial
    case directory
    case bookmarks
    case image(RuntimeImageNode)
}
@AssociatedValue(.public)
@CaseCheckable(.public)
public enum SidebarRuntimeObjectRoute: Routable {
    case initial
    case objects
    case bookmarks
    case selectedObject(RuntimeObject)
    case exportInterface
}
#else
public typealias SidebarRootRoute = SidebarRoute
public typealias SidebarRuntimeObjectRoute = SidebarRoute
#endif






```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRuntimeObjectBookmarkViewModel.swift`:

```swift
#if os(macOS)

import Foundation
import RuntimeViewerCore
import RuntimeViewerArchitectures
import MemberwiseInit

public final class SidebarRuntimeObjectBookmarkViewModel: SidebarRuntimeObjectViewModel, @unchecked Sendable {
    public override init(imageNode: RuntimeImageNode, documentState: DocumentState, router: any Router<SidebarRuntimeObjectRoute>) {
        super.init(imageNode: imageNode, documentState: documentState, router: router)

        appDefaults.$objectBookmarksBySourceAndImagePath
            .asObservable()
            .subscribeOnNext { [weak self] _ in
                guard let self else { return }
                Task {
                    do {
                        try await self.reloadData()
                    } catch {
                        await MainActor.run { self.errorRelay.accept(error) }
                    }
                }
            }
            .disposed(by: rx.disposeBag)
    }

    override func buildRuntimeObjects() async throws -> [RuntimeObject] {
        currentImageObjectBookmarks.map { $0.object }
    }
    
    private var currentImageObjectBookmarks: [RuntimeObjectBookmark] {
        set {
            var dict = appDefaults.objectBookmarksBySourceAndImagePath
            dict[documentState.runtimeEngine.source, default: [:]][imagePath] = newValue
            appDefaults.objectBookmarksBySourceAndImagePath = dict
        }
        get {
            appDefaults.objectBookmarksBySourceAndImagePath[documentState.runtimeEngine.source, default: [:]][imagePath, default: []]
        }
    }
    
    @MemberwiseInit(.public)
    public struct Input {
        public let moveBookmark: Signal<OutlineMove>
        public let removeBookmark: Signal<Int>
    }

    public struct Output {
        public let isMoveBookmarkEnabled: Driver<Bool>
        public let isBookmarkEmpty: Driver<Bool>
    }

    public func transform(_ input: Input) -> Output {
        input.moveBookmark.emitOnNext { [weak self] outlineMove in
            guard let self else { return }
            outlineMove.applyToRoots(&currentImageObjectBookmarks)
        }
        .disposed(by: rx.disposeBag)

        input.removeBookmark
            .emitOnNext { [weak self] index in
                guard let self else { return }
                currentImageObjectBookmarks.remove(at: index)
            }
            .disposed(by: rx.disposeBag)

        return Output(
            isMoveBookmarkEnabled: $isFiltering.asDriver().not(),
            isBookmarkEmpty: appDefaults.$objectBookmarksBySourceAndImagePath.asDriver(onErrorJustReturn: [:]).map { [weak self] _ in self?.currentImageObjectBookmarks.isEmpty ?? true }
        )
    }
}

extension RuntimeObjectBookmark: @retroactive OutlineNodeType {
    public var children: [RuntimeObjectBookmark] { object.children.map { .init(source: source, object: $0) } }
}


#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRuntimeObjectCellViewModel.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
import RxAppKit
#endif

#if canImport(UIKit)
import UIKit
#endif

import RuntimeViewerUI
import RuntimeViewerCore
import RuntimeViewerArchitectures

public final class SidebarRuntimeObjectCellViewModel: NSObject, OutlineNodeType, FilterableItem, @unchecked Sendable {
    public let runtimeObject: RuntimeObject

    public let forOpenQuickly: Bool

    public var children: [SidebarRuntimeObjectCellViewModel] { _filteredChildren }

    public var isLeaf: Bool { children.isEmpty }

    private lazy var _filteredChildren: [SidebarRuntimeObjectCellViewModel] = _children

    private lazy var _children: [SidebarRuntimeObjectCellViewModel] = {
        let children = runtimeObject.children.map { SidebarRuntimeObjectCellViewModel(runtimeObject: $0, forOpenQuickly: forOpenQuickly) }
        return children.sorted { $0.runtimeObject.displayName < $1.runtimeObject.displayName }
    }()

    public private(set) lazy var currentAndChildrenNames: String = {
        let childrenNames = _children.map { $0.currentAndChildrenNames }.joined(separator: " ")
        if childrenNames.isEmpty {
            return runtimeObject.displayName
        } else {
            return "\(runtimeObject.displayName) \(childrenNames)"
        }
    }()

    @Dependency(\.appDefaults)
    private var appDefaults

    var isCaseInsensitive: Bool = false
    
    var filter: String = "" {
        didSet {
            _filteredChildren = FilterEngine.filter(filter, items: _children, mode: appDefaults.filterMode, isCaseInsensitive: isCaseInsensitive)
        }
    }

    var filterResult: FuzzyFilterResult? {
        didSet {
            if let filterResult {
                let name = NSMutableAttributedString {
                    AText(runtimeObject.displayName)
                        .font(.systemFont(ofSize: fontSize))
                        .foregroundColor(forOpenQuickly ? .secondaryLabelColor : .tertiaryLabelColor)
                        .paragraphStyle(NSMutableParagraphStyle().then { $0.lineBreakMode = .byTruncatingTail })
                }

                guard let range = currentAndChildrenNames.ranges(of: runtimeObject.displayName).first else {
                    self.name = name
                    return
                }

                let currentNSRange = NSRange(currentAndChildrenNames.integerRange(from: range))

                filterResult.ranges.forEach { resultNSRange in
                    guard resultNSRange.location >= currentNSRange.location, NSMaxRange(resultNSRange) <= NSMaxRange(currentNSRange) else { return }
                    name.addAttributes([
                        .foregroundColor: NSUIColor.labelColor,
                        .font: NSUIFont.systemFont(ofSize: fontSize, weight: .semibold),
                    ], range: resultNSRange)
                }
                self.name = name
            } else {
                name = defaultAttributedName()
            }
        }
    }

    var filterableString: String {
        currentAndChildrenNames
    }

    private static let normalFontSize: CGFloat = 13
    
    private static let openQuicklyFontSize: CGFloat = 16
    
    private var fontSize: CGFloat {
        forOpenQuickly ? SidebarRuntimeObjectCellViewModel.openQuicklyFontSize : SidebarRuntimeObjectCellViewModel.normalFontSize
    }
    
    @Observed
    public private(set) var primaryIcon: NSUIImage?

    @Observed
    public private(set) var secondaryIcon: NSUIImage?

    @Observed
    public private(set) var name: NSAttributedString = .init()

    @NSAttributedStringBuilder
    private func defaultAttributedName() -> NSAttributedString {
        AText(runtimeObject.displayName)
            .font(.systemFont(ofSize: fontSize))
            .foregroundColor(.labelColor)
            .paragraphStyle(NSMutableParagraphStyle().then { $0.lineBreakMode = .byTruncatingTail })
    }

    public init(runtimeObject: RuntimeObject, forOpenQuickly: Bool) {
        self.runtimeObject = runtimeObject
        self.forOpenQuickly = forOpenQuickly
        super.init()
        if forOpenQuickly {
            self.primaryIcon = runtimeObject.kind.icon(size: 24)
            self.secondaryIcon = runtimeObject.secondaryKind?.icon(size: 24)
        } else {
            self.primaryIcon = runtimeObject.kind.icon
            self.secondaryIcon = runtimeObject.secondaryKind?.icon
        }
        self.name = defaultAttributedName()
    }

//    public override var hash: Int {
//        var hasher = Hasher()
//        hasher.combine(runtimeObject)
//        return hasher.finalize()
//    }
//
//    public override func isEqual(_ object: Any?) -> Bool {
//        guard let object = object as? Self else { return false }
//        return runtimeObject == object.runtimeObject
//    }
}

#if canImport(AppKit) && !targetEnvironment(macCatalyst)

extension SidebarRuntimeObjectCellViewModel: Differentiable {}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRuntimeObjectListViewModel.swift`:

```swift
import Foundation
import RuntimeViewerCore
import RuntimeViewerArchitectures
import MemberwiseInit

public final class SidebarRuntimeObjectListViewModel: SidebarRuntimeObjectViewModel {
    @Observed public private(set) var searchStringForOpenQuickly: String = ""
    @Observed public private(set) var nodesForOpenQuickly: [SidebarRuntimeObjectCellViewModel] = []
    @Observed public private(set) var filteredNodesForOpenQuickly: [SidebarRuntimeObjectCellViewModel] = []
    @Observed public private(set) var isFilteringForOpenQuickly: Bool = false

    override var isSorted: Bool { true }
    
    public override init(imageNode: RuntimeImageNode, documentState: DocumentState, router: any Router<SidebarRuntimeObjectRoute>) {
        super.init(imageNode: imageNode, documentState: documentState, router: router)
    }

    @MemberwiseInit(.public)
    public struct Input {
        public let runtimeObjectClickedForOpenQuickly: Signal<SidebarRuntimeObjectCellViewModel>
        public let searchStringForOpenQuickly: Signal<String>
        public let addBookmark: Signal<SidebarRuntimeObjectCellViewModel>
    }

    public struct Output {
        public let runtimeObjectsForOpenQuickly: Driver<[SidebarRuntimeObjectCellViewModel]>
        public let selectRuntimeObject: Signal<SidebarRuntimeObjectCellViewModel>
    }

    override func buildRuntimeObjects() async throws -> [RuntimeObject] {
        try await runtimeEngine.objects(in: imagePath)
    }

    override func reloadData() async throws {
        try await super.reloadData()

        await MainActor.run {
            self.searchStringForOpenQuickly = ""
            self.nodesForOpenQuickly = nodes.map { $0.runtimeObject }.sorted().map { SidebarRuntimeObjectCellViewModel(runtimeObject: $0, forOpenQuickly: true) }
            self.filteredNodesForOpenQuickly = []
        }
    }

    public func transform(_ input: Input) -> Output {
        input.addBookmark.emitOnNext { [weak self] viewModel in
            guard let self else { return }
            let runtimeSource = documentState.runtimeEngine.source
            appDefaults.objectBookmarksBySourceAndImagePath[runtimeSource, default: [:]][imagePath, default: []].append(.init(source: runtimeSource, object: viewModel.runtimeObject))
        }
        .disposed(by: rx.disposeBag)

        input.searchStringForOpenQuickly
            .skip(1)
            .debounce(.milliseconds(500))
            .emitOnNextMainActor { [weak self] filter in
                guard let self else { return }
                if filter.isEmpty {
                    if isFilteringForOpenQuickly {
                        isFilteringForOpenQuickly = false
                    }
                    filteredNodesForOpenQuickly = []
                } else {
                    if !isFilteringForOpenQuickly {
                        isFilteringForOpenQuickly = true
                    }
                    Task.detached {
                        let filteredNodesForOpenQuickly = await FilterEngine.filter(filter, items: self.nodesForOpenQuickly, mode: .fuzzySearch, isCaseInsensitive: false)
                        await MainActor.run {
                            self.filteredNodesForOpenQuickly = filteredNodesForOpenQuickly
                        }
                    }
                }
            }
            .disposed(by: rx.disposeBag)

        input.runtimeObjectClickedForOpenQuickly
            .emitOnNextMainActor { [weak self] viewModel in
                guard let self else { return }
                self.router.trigger(.selectedObject(viewModel.runtimeObject))
            }
            .disposed(by: rx.disposeBag)

        return Output(
            runtimeObjectsForOpenQuickly: $filteredNodesForOpenQuickly.asDriver().skip(1),
            selectRuntimeObject: input.runtimeObjectClickedForOpenQuickly
        )
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Sidebar/SidebarRuntimeObjectViewModel.swift`:

```swift
import Foundation
import RuntimeViewerCore
import RuntimeViewerArchitectures
import MemberwiseInit

public class SidebarRuntimeObjectViewModel: ViewModel<SidebarRuntimeObjectRoute> {
    public let imageNode: RuntimeImageNode
    public let imagePath: String
    public let imageName: String
    public let runtimeEngine: RuntimeEngine

    var isSorted: Bool { false }
    
    @Observed public private(set) var loadState: RuntimeImageLoadState = .unknown
    @Observed public private(set) var searchString: String = ""
    @Observed public private(set) var nodes: [SidebarRuntimeObjectCellViewModel] = []
    @Observed public private(set) var filteredNodes: [SidebarRuntimeObjectCellViewModel] = []
    @Observed public private(set) var isFiltering: Bool = false
    @Observed public private(set) var isSearchCaseInsensitive: Bool = false

    public init(imageNode: RuntimeImageNode, documentState: DocumentState, router: any Router<SidebarRuntimeObjectRoute>) {
        let imagePath = imageNode.path
        self.runtimeEngine = documentState.runtimeEngine
        self.imageNode = imageNode
        self.imagePath = imagePath
        self.imageName = imageNode.name
        super.init(documentState: documentState, router: router)

        Task {
            await runtimeEngine.reloadDataPublisher
                .asObservable()
                .subscribeOnNext { [weak self] in
                    guard let self else { return }
                    Task {
                        try await self.reloadData()
                    }
                }
                .disposed(by: rx.disposeBag)
            
            do {
                try await reloadData()
            } catch {
                self.loadState = .loadError(error)
                logger.error("\(error)")
            }
        }
    }

    @MemberwiseInit(.public)
    public struct Input {
        public let runtimeObjectClicked: Signal<SidebarRuntimeObjectCellViewModel>
        public let loadImageClicked: Signal<Void>
        public let searchString: Signal<String>
        public let isSearchCaseInsensitive: Driver<Bool>?
    }

    public struct Output {
        public let runtimeObjects: Driver<[SidebarRuntimeObjectCellViewModel]>
        public let loadState: Driver<RuntimeImageLoadState>
        public let notLoadedText: Driver<String>
        public let errorText: Driver<String>
        public let emptyText: Driver<String>
        public let isEmpty: Driver<Bool>
        public let windowInitialTitles: Driver<(title: String, subtitle: String)>
        public let windowSubtitle: Signal<String>
        public let didBeginFiltering: Signal<Void>
        public let didChangeFiltering: Signal<Void>
        public let didEndFiltering: Signal<Void>
    }

    @MainActor
    public func transform(_ input: Input) -> Output {
        input.isSearchCaseInsensitive?.drive($isSearchCaseInsensitive).disposed(by: rx.disposeBag)

        input.searchString
            .debounce(.milliseconds(500))
            .emitOnNextMainActor { [weak self] filter in
                guard let self else { return }
                if filter.isEmpty {
                    if isFiltering {
                        isFiltering = false
                    }
                } else {
                    if !isFiltering {
                        isFiltering = true
                    }
                }
                filteredNodes = FilterEngine.filter(filter, items: nodes, mode: appDefaults.filterMode, isCaseInsensitive: isSearchCaseInsensitive)
            }
            .disposed(by: rx.disposeBag)

        input.runtimeObjectClicked
            .emitOnNextMainActor { [weak self] viewModel in
                guard let self else { return }
                self.router.trigger(.selectedObject(viewModel.runtimeObject))
            }
            .disposed(by: rx.disposeBag)

        input.loadImageClicked.emitOnNextMainActor { [weak self] in
            guard let self else { return }
            tryLoadImage()
        }
        .disposed(by: rx.disposeBag)

        let errorText = $loadState
            .capture(case: RuntimeImageLoadState.loadError).map { [weak self] error in
                guard let self else { return "" }
                if let dyldOpenError = error as? DyldOpenError, let message = dyldOpenError.message {
                    return message
                } else {
                    return "An unknown error occured trying to load '\(imagePath)'"
                }
            }
            .asDriver(onErrorJustReturn: "")

        let runtimeImageName = imageNode.name

        let distinctLoadState = $loadState.asObservable()
            .distinctUntilChanged()
            .flatMapLatest { state -> Observable<RuntimeImageLoadState> in
                switch state {
                case .loading:
                    return Observable.just(state)
                        .delay(.milliseconds(500), scheduler: MainScheduler.instance)
                default:
                    return Observable.just(state)
                }
            }
            .asDriver(onErrorDriveWith: .empty())

        return Output(
            runtimeObjects: $filteredNodes.asDriver(),
            loadState: distinctLoadState,
            notLoadedText: .just("\(imageName) is not yet loaded"),
            errorText: errorText,
            emptyText: .just("\(imageName) is loaded however does not appear to contain any classes or protocols"),
            isEmpty: $nodes.asDriver().map { $0.isEmpty },
            windowInitialTitles: .just((runtimeImageName, "")),
            windowSubtitle: input.runtimeObjectClicked.asSignal().map { "\($0.runtimeObject.displayName)" },
            didBeginFiltering: $isFiltering.asSignal(onErrorJustReturn: false).filter { $0 }.mapToVoid(),
            didChangeFiltering: $filteredNodes.asSignal(onErrorJustReturn: []).withLatestFrom($isFiltering.asSignal(onErrorJustReturn: false)).filter { $0 }.mapToVoid(),
            didEndFiltering: $isFiltering.skip(1).asSignal(onErrorJustReturn: false).filter { !$0 }.mapToVoid()
        )
    }

    func reloadData() async throws {
        let loadState: RuntimeImageLoadState = try await runtimeEngine.isImageLoaded(path: imagePath) ? .loaded : .notLoaded

        if case .notLoaded = loadState {
            await MainActor.run {
                self.loadState = .notLoaded
            }
            return
        }

        await MainActor.run {
            self.loadState = .loading
        }

        let runtimeObjects = try await buildRuntimeObjects()

        await MainActor.run {
            self.loadState = .loaded
            self.searchString = ""
            if isSorted {
                self.nodes = runtimeObjects.sorted().map { SidebarRuntimeObjectCellViewModel(runtimeObject: $0, forOpenQuickly: false) }
            } else {
                self.nodes = runtimeObjects.map { SidebarRuntimeObjectCellViewModel(runtimeObject: $0, forOpenQuickly: false) }
            }
            self.filteredNodes = self.nodes
        }
    }

    func buildRuntimeObjects() async throws -> [RuntimeObject] { [] }

    private func tryLoadImage() {
        Task { @MainActor in
            do {
                loadState = .loading
                try await runtimeEngine.loadImage(at: imagePath)
                loadState = .loaded

            } catch {
                loadState = .loadError(error)
            }
        }
    }
}

extension RuntimeImageLoadState: @retroactive Equatable {
    public static func == (lhs: RuntimeViewerCore.RuntimeImageLoadState, rhs: RuntimeViewerCore.RuntimeImageLoadState) -> Bool {
        switch (lhs, rhs) {
        case (.unknown, .unknown): return true
        case (.loaded, .loaded): return true
        case (.loading, .loading): return true
        case (.notLoaded, .notLoaded): return true
        case (.loadError, .loadError): return true
        default: return false
        }
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Theme/SemanticString+ThemeProfile.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
#endif

#if canImport(UIKit)
import UIKit
#endif

import Semantic
import RuntimeViewerCore

extension SemanticString {
    public func attributedString(for provider: ThemeProfile, runtimeObjectName: RuntimeObject) -> NSAttributedString {
        let attributedString = NSMutableAttributedString(string: "")

        for component in components {
            let string = component.string
            let type = component.type
            var attributes: [NSAttributedString.Key: Any] = [
                .font: provider.font(for: type),
                .foregroundColor: provider.color(for: type),
            ]

            var targetKind: RuntimeObjectKind?

            switch type {
            case .type(let kind, _):
                switch runtimeObjectName.kind {
                case .c, .objc:
                    switch kind {
                    case .class:
                        targetKind = .objc(.type(.class))
                    case .protocol:
                        targetKind = .objc(.type(.protocol))
                    case .struct:
                        targetKind = .c(.struct)
                    case .other:
                        targetKind = .c(.union)
                    default:
                        break
                    }
                case .swift:
                    switch kind {
                    case .enum:
                        targetKind = .swift(.type(.enum))
                    case .struct:
                        targetKind = .swift(.type(.struct))
                    case .class:
                        targetKind = .swift(.type(.class))
                    case .protocol:
                        targetKind = .swift(.type(.protocol))
                    default:
                        break
                    }
                }
            default:
                break
            }

            #if canImport(AppKit) && !targetEnvironment(macCatalyst)
            if let targetKind {
                attributes.updateValue(RuntimeObject(name: string, displayName: string, kind: targetKind, secondaryKind: runtimeObjectName.secondaryKind, imagePath: runtimeObjectName.imagePath, children: runtimeObjectName.children), forKey: .link)
            }
            #endif

            #if canImport(UIKit)
//            if type == .class || type == .protocol {
//                let scheme = type == .class ? "class" : "protocol"
//                let host = string
//                if let url = URL(string: "\(scheme)://\(host)") {
//                    attributes.updateValue(url, forKey: .link)
//                }
//            }
            #endif
            attributedString.append(NSAttributedString(string: string, attributes: attributes))
        }

        return attributedString
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Theme/ThemeProfile.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
#endif

#if canImport(UIKit)
import UIKit
#endif

import Semantic
import UIFoundation
import RuntimeViewerCore

@propertyWrapper
public struct AnyThemeProfile<Theme: ThemeProfile>: Codable {
    public var wrappedValue: Theme
    public init(wrappedValue: Theme) {
        self.wrappedValue = wrappedValue
    }
}

public protocol ThemeProfile: Codable {
    var selectionBackgroundColor: NSUIColor { set get }
    var backgroundColor: NSUIColor { set get }
    var fontSize: CGFloat { set get }
    func font(for type: SemanticType) -> NSUIFont
    func color(for type: SemanticType) -> NSUIColor
    mutating func fontSizeSmaller()
    mutating func fontSizeLarger()
}

public struct XcodePresentationTheme: ThemeProfile {
    public var selectionBackgroundColor: NSUIColor = #colorLiteral(red: 0.3904261589, green: 0.4343567491, blue: 0.5144847631, alpha: 1)

    public var backgroundColor: NSUIColor = .init(light: #colorLiteral(red: 1, green: 0.9999999404, blue: 1, alpha: 1), dark: #colorLiteral(red: 0.1251632571, green: 0.1258862913, blue: 0.1465735137, alpha: 1))

    public var fontSize: CGFloat = 13

    public func font(for type: SemanticType) -> NSUIFont {
        switch type {
        case .keyword:
            return .monospacedSystemFont(ofSize: fontSize, weight: .semibold)
        default:
            return .monospacedSystemFont(ofSize: fontSize, weight: .regular)
        }
    }

    private static var colorCache: [SemanticType: NSUIColor] = [:]

    public func color(for type: SemanticType) -> NSUIColor {
        if let existColor = Self.colorCache[type] {
            return existColor
        }
        let light: NSUIColor
        let dark: NSUIColor
        switch type {
        case .comment:
            light = #colorLiteral(red: 0.4095562398, green: 0.4524990916, blue: 0.4956067801, alpha: 1)
            dark = #colorLiteral(red: 0.4976348877, green: 0.5490466952, blue: 0.6000126004, alpha: 1)
        case .keyword:
            light = #colorLiteral(red: 0.7660875916, green: 0.1342913806, blue: 0.4595085979, alpha: 0.8)
            dark = #colorLiteral(red: 0.9686241746, green: 0.2627249062, blue: 0.6156817079, alpha: 1)
        case .variable,
             .function(.declaration),
             .member(.declaration),
             .type(_, .declaration):
            light = #colorLiteral(red: 0.01979870349, green: 0.4877431393, blue: 0.6895453334, alpha: 1)
            dark = #colorLiteral(red: 0.2426597476, green: 0.7430019975, blue: 0.8773110509, alpha: 1)
        case .type(_, .name),
             .function(.name),
             .member(.name):
            light = #colorLiteral(red: 0.2404940426, green: 0.115125142, blue: 0.5072092414, alpha: 1)
            dark = #colorLiteral(red: 0.853918612, green: 0.730949223, blue: 1, alpha: 1)
        case .numeric:
            light = #colorLiteral(red: 0.01564520039, green: 0.2087542713, blue: 1, alpha: 1)
            dark = #colorLiteral(red: 1, green: 0.9160019755, blue: 0.5006220341, alpha: 1)
        case .error:
            light = #colorLiteral(red: 0.831372549, green: 0.1019607843, blue: 0.1019607843, alpha: 1)
            dark = #colorLiteral(red: 0.831372549, green: 0.1019607843, blue: 0.1019607843, alpha: 1)
        default:
            return .labelColor
        }
        let color = NSUIColor(light: light, dark: dark)
        Self.colorCache[type] = color
        return color
    }

    public mutating func fontSizeSmaller() {
        fontSize -= 1
    }

    public mutating func fontSizeLarger() {
        fontSize += 1
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/Then.swift`:

```swift
import Foundation
#if !os(Linux)
import CoreGraphics
#endif

#if os(macOS) && !targetEnvironment(macCatalyst)
import AppKit
#endif

#if os(iOS) || os(tvOS)
import UIKit.UIGeometry
#endif

protocol Then {}

extension Then where Self: Any {
    /// Makes it available to set properties with closures just after initializing and copying the value types.
    ///
    ///     let frame = CGRect().with {
    ///       $0.origin.x = 10
    ///       $0.size.width = 100
    ///     }
    @inlinable
    func with(_ block: (inout Self) throws -> Void) rethrows -> Self {
        var copy = self
        try block(&copy)
        return copy
    }

    /// Makes it available to execute something with closures.
    ///
    ///     UserDefaults.standard.do {
    ///       $0.set("devxoul", forKey: "username")
    ///       $0.set("devxoul@gmail.com", forKey: "email")
    ///       $0.synchronize()
    ///     }
    @inlinable
    func `do`(_ block: (Self) throws -> Void) rethrows {
        try block(self)
    }
}

extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///       $0.textAlignment = .center
    ///       $0.textColor = UIColor.black
    ///       $0.text = "Hello, World!"
    ///     }
    @inlinable
    @discardableResult
    func then(_ block: (Self) throws -> Void) rethrows -> Self {
        try block(self)
        return self
    }
}

extension Then {
    @inlinable
    func `as`<T>(_ transform: (Self) throws -> T) rethrows -> T {
        try transform(self)
    }
}

extension NSObject: Then {}

extension CGPoint: Then {}
extension CGRect: Then {}
extension CGSize: Then {}
extension CGVector: Then {}

extension Array: Then {}
extension Dictionary: Then {}
extension Set: Then {}
extension JSONDecoder: Then {}
extension JSONEncoder: Then {}

#if os(macOS)
extension NSEdgeInsets: Then {}
extension NSRectEdge: Then {}
extension NSDirectionalRectEdge: Then {}
extension NSDirectionalEdgeInsets: Then {}
@available(macOS 15.0, *)
extension NSHorizontalDirection: Then {}
@available(macOS 15.0, *)
extension NSHorizontalDirection.Set: Then {}
@available(macOS 15.0, *)
extension NSVerticalDirection: Then {}
@available(macOS 15.0, *)
extension NSVerticalDirection.Set: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItem: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse.Highlight: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse.Phase: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemSection: Then {}
@available(macOS 26.0, *)
extension NSItemBadge: Then {}
@available(macOS 26.0, *)
extension NSView.LayoutRegion: Then {}
#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/ViewModel.swift`:

```swift
import Foundation
import FoundationToolbox
import RuntimeViewerArchitectures

#if canImport(RuntimeViewerSettings)
import RuntimeViewerSettings
#endif

@MainActor
open class ViewModel<Route: Routable>: NSObject, ViewModelProtocol, Loggable {
    public let documentState: DocumentState

    public unowned let router: any Router<Route>

    @Dependency(\.appDefaults)
    public var appDefaults
    #if canImport(RuntimeViewerSettings)
    @Dependency(\.settings)
    public var settings
    #endif
    public let errorRelay = PublishRelay<Error>()

    package let _commonLoading = ActivityIndicator()

    public var commonLoading: Driver<Bool> {
        _commonLoading.asDriver()
    }

    public var delayedLoading: Driver<Bool> {
        _commonLoading
            .distinctUntilChanged()
            .flatMapLatest { isLoading -> Driver<Bool> in
                if isLoading {
                    // If loading starts, return a sequence that emits 'true' after a delay.
                    // If 'isLoading' becomes false before the delay finishes,
                    // flatMapLatest will dispose this subscription, cancelling the 'true' emission.
                    return Driver.just(true)
                        .delay(.milliseconds(500))
                } else {
                    // If loading ends, emit 'false' immediately to hide the spinner.
                    return Driver.just(false)
                }
            }
    }

    public init(documentState: DocumentState, router: any Router<Route>) {
        self.documentState = documentState
        self.router = router
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerApplication/ViewModelProtocol.swift`:

```swift
import RuntimeViewerArchitectures

@MainActor
public protocol ViewModelProtocol<Route>: AnyObject {
    associatedtype Route: Routable
    var documentState: DocumentState { get }
    var commonLoading: Driver<Bool> { get }
    var delayedLoading: Driver<Bool> { get }
    var errorRelay: PublishRelay<Error> { get }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerArchitectures/RuntimeViewerArchitectures.swift`:

```swift
@_exported import RxSwift
@_exported import RxCocoa

// @_exported import RxSwiftExt
@_exported import RxSwiftPlus
@_exported import RxCombine
@_exported import RxDefaultsPlus
@_exported import RxEnumKit
@_exported import EnumKit
@_exported import RxConcurrency

@_exported import SwiftNavigation

#if canImport(AppKit) && !targetEnvironment(macCatalyst)
@_exported import RxAppKit
@_exported import CocoaCoordinator
@_exported import RxCocoaCoordinator
#if USING_SYSTEM_UXKIT
@_exported import UXKitCoordinator
#else
@_exported import OpenUXKitCoordinator
#endif
#endif

#if canImport(UIKit) && !os(macOS)
@_exported import RxUIKit
@_exported import XCoordinator
@_exported import XCoordinatorRx

public typealias Routable = Route
#endif


@_exported import Dependencies

public extension ObservableType {
    func observeOnMainScheduler() -> Observable<Element> {
        observe(on: MainScheduler.instance)
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerCatalystExtensions/Extensions.swift`:

```swift
import RuntimeViewerCommunication

extension RuntimeSource {
    public static let macCatalystClient: Self = .remote(name: "My Mac (Mac Catalyst)", identifier: .macCatalyst, role: .client)
    public static let macCatalystServer: Self = .remote(name: "My Mac (Mac Catalyst)", identifier: .macCatalyst, role: .server)
}

extension RuntimeSource.Identifier {
    public static let macCatalyst: Self = "com.RuntimeViewer.RuntimeSource.MacCatalyst"
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerHelperClient/HelperServiceManager.swift`:

```swift
#if os(macOS)

import Foundation
import OSLog
import SwiftyXPC
import ServiceManagement
import RuntimeViewerServiceHelper
import RuntimeViewerCommunication
import Synchronization
import Dependencies

/// Manages the helper service lifecycle including registration, unregistration, and XPC connections.
@Observable
@MainActor
public final class HelperServiceManager {
    public static let shared = HelperServiceManager()

    // MARK: - Static Properties

    public static let legacyPlistFileURL = URL(filePath: "/Library/LaunchDaemons/com.JH.RuntimeViewerService.plist")

    public static let helperServiceDaemon = SMAppService.daemon(plistName: "com.mxiris.runtimeviewer.service.plist")

    // MARK: - Observable State

    public private(set) var status: SMAppService.Status = .notRegistered

    public private(set) var isLoading: Bool = false

    public private(set) var message: String = "Checking..."

    public private(set) var isLegacyServiceInstalled: Bool = false

    public private(set) var isLegacyLoading: Bool = false

    public private(set) var legacyMessage: String = "Checking..."

    // MARK: - Computed Properties

    public var isEnabled: Bool {
        status == .enabled
    }

    public var canUninstallLegacy: Bool {
        status == .enabled
    }

    // MARK: - XPC Connection

    @ObservationIgnored
    private let connectionLock = Mutex<XPCConnection?>(nil)

    @ObservationIgnored
    private static let logger = Logger(subsystem: "com.mxiris.runtimeviewer", category: "HelperServiceManager")

    private init() {}

    /// Invalidates the current connection and establishes a new one.
    public func reconnect() {
        invalidateConnection()
        do {
            _ = try connectionIfNeeded()
            Self.logger.info("Successfully reconnected to helper service")
        } catch {
            Self.logger.error("Failed to reconnect to helper service: \(error.localizedDescription, privacy: .public)")
        }
    }

    /// Invalidates the current connection without reconnecting.
    public func invalidateConnection() {
        connectionLock.withLock { connection in
            connection?.cancel()
            connection = nil
        }
    }

    private func connectionIfNeeded() throws -> XPCConnection {
        try connectionLock.withLock { connection in
            if let currentConnection = connection {
                return currentConnection
            }

            let newConnection = try XPCConnection(type: .remoteMachService(serviceName: RuntimeViewerMachServiceName, isPrivilegedHelperTool: true))
            newConnection.errorHandler = { [weak self] _, error in
                Self.logger.error("XPC connection error: \(error.localizedDescription, privacy: .public)")
                self?.connectionLock.withLock { conn in
                    conn = nil
                }
            }
            newConnection.activate()
            connection = newConnection
            return newConnection
        }
    }

    // MARK: - Status Management

    public func refreshAllStatus() async {
        let previousStatus = status
        checkLegacyServiceStatus()
        await manageHelperService(action: .status)
        logStatusChangeIfNeeded(previousStatus: previousStatus)
    }

    public func checkLegacyServiceStatus() {
        isLegacyServiceInstalled = FileManager.default.fileExists(atPath: Self.legacyPlistFileURL.path)

        if isLegacyServiceInstalled {
            if status == .enabled {
                legacyMessage = "Legacy helper service detected. Click Uninstall to remove it."
            } else {
                legacyMessage = "Legacy helper service detected. Please install the new helper service first, then uninstall the legacy version."
            }
        } else {
            legacyMessage = "No legacy helper service installed."
        }
    }

    // MARK: - Helper Service Management

    public enum Action {
        case status
        case install
        case uninstall
    }

    public func manageHelperService(action: Action = .status) async {
        isLoading = action != .status
        defer { isLoading = false }

        var occurredError: NSError?
        let daemon = Self.helperServiceDaemon
        let previousStatus = daemon.status

        switch action {
        case .install:
            switch daemon.status {
            case .requiresApproval:
                message = "Registered but requires enabling in System Settings > Login Items."
                SMAppService.openSystemSettingsLoginItems()
            case .enabled:
                message = "Service is already enabled."
            default:
                do {
                    try daemon.register()
                    if daemon.status == .requiresApproval {
                        SMAppService.openSystemSettingsLoginItems()
                    }
                } catch let nsError as NSError {
                    occurredError = nsError
                    if nsError.code == 1 {
                        message = "Permission required. Enable in System Settings > Login Items."
                        SMAppService.openSystemSettingsLoginItems()
                    } else {
                        message = "Installation failed: \(nsError.localizedDescription)"
                    }
                }
            }

        case .uninstall:
            do {
                try await daemon.unregister()
            } catch let nsError as NSError {
                occurredError = nsError
            }

        case .status:
            break
        }

        updateStatusMessages(occurredError: occurredError)
        status = daemon.status
        logStatusChangeIfNeeded(previousStatus: previousStatus)
    }

    private func updateStatusMessages(occurredError: NSError?) {
        if let nsError = occurredError {
            switch nsError.code {
            case kSMErrorAlreadyRegistered:
                message = "Service is already registered and enabled."
            case kSMErrorLaunchDeniedByUser:
                message = "User denied permission. Enable in System Settings > Login Items."
            case kSMErrorInvalidSignature:
                message = "Invalid signature, ensure proper signing on the application and helper service."
            case 1:
                message = "Authorization required in Settings > Login Items."
            default:
                message = "Operation failed: \(nsError.localizedDescription)"
            }
        } else {
            let daemon = Self.helperServiceDaemon
            switch daemon.status {
            case .notRegistered:
                message = "Service hasn't been registered. You may register it now."
            case .enabled:
                message = "Service successfully registered and eligible to run."
            case .requiresApproval:
                message = "Service registered but requires user approval in Settings > Login Items."
            case .notFound:
                message = "Service is not installed."
            @unknown default:
                message = "Unknown service status (\(daemon.status))."
            }
        }
    }

    private func logStatusChangeIfNeeded(previousStatus: SMAppService.Status) {
        let currentStatus = Self.helperServiceDaemon.status
        if currentStatus == .enabled && previousStatus != .enabled {
            Self.logger.info("Helper service became enabled")
        }
    }

    // MARK: - Legacy Helper Service Management

    public func uninstallLegacyService() async {
        guard status == .enabled else {
            legacyMessage = "Please install the new helper service first before uninstalling the legacy version."
            return
        }

        isLegacyLoading = true
        defer { isLegacyLoading = false }

        do {
            // Step 1: Stop the legacy service process via SMJobRemove
            try? LegacyHelperTool.uninstall(withServiceName: "com.JH.RuntimeViewerService")

            // Step 2: Delete the legacy plist file via new helper service (requires root)
            let connection = try connectionIfNeeded()
            try await connection.sendMessage(request: FileOperationRequest(operation: .remove(url: Self.legacyPlistFileURL)))

            checkLegacyServiceStatus()
            if !isLegacyServiceInstalled {
                legacyMessage = "Legacy helper service successfully uninstalled."
            }
        } catch {
            legacyMessage = "Failed to uninstall legacy service: \(error.localizedDescription)"
        }
    }

    // MARK: - XPC Operations

    /// Sends a file operation request to the helper service.
    public func performFileOperation(_ operation: FileOperation) async throws {
        let connection = try connectionIfNeeded()
        try await connection.sendMessage(request: FileOperationRequest(operation: operation))
    }
}

// MARK: - Dependencies

private enum HelperServiceManagerKey: @preconcurrency DependencyKey {
    @MainActor static let liveValue = HelperServiceManager.shared
}

extension DependencyValues {
    public var helperServiceManager: HelperServiceManager {
        get { self[HelperServiceManagerKey.self] }
        set { self[HelperServiceManagerKey.self] = newValue }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerHelperClient/RuntimeHelperClient.swift`:

```swift
#if os(macOS)

import Foundation
import SwiftyXPC
import RuntimeViewerCommunication
import OSLog
import Synchronization
import Dependencies
import ServiceManagement

/// Client for communicating with the RuntimeViewer helper service.
public final class RuntimeHelperClient: @unchecked Sendable {
    public enum Error: LocalizedError {
        case message(String)

        public var errorDescription: String? {
            switch self {
            case .message(let message):
                return message
            }
        }
    }

    public static let shared = RuntimeHelperClient()

    private let connectionLock = Mutex<XPCConnection?>(nil)

    private static let logger = Logger(subsystem: "com.mxiris.runtimeviewer", category: "RuntimeHelperClient")

    @Dependency(\.helperServiceManager) private var helperServiceManager

    private init() {
        Task { @MainActor in
            observeStatusChange()
        }
    }

    @MainActor
    private func observeStatusChange() {
        withObservationTracking {
            _ = helperServiceManager.status
        } onChange: { [weak self] in
            Task { @MainActor [weak self] in
                guard let self else { return }
                if helperServiceManager.status == .enabled {
                    reconnect()
                }
                observeStatusChange()
            }
        }
    }

    /// Invalidates the current connection and establishes a new one.
    public func reconnect() {
        invalidateConnection()
        do {
            _ = try connectionIfNeeded()
            Self.logger.info("Successfully reconnected to helper service")
        } catch {
            Self.logger.error("Failed to reconnect to helper service: \(error.localizedDescription, privacy: .public)")
        }
    }

    /// Invalidates the current connection without reconnecting.
    public func invalidateConnection() {
        connectionLock.withLock { connection in
            connection?.cancel()
            connection = nil
        }
    }

    private func connectionIfNeeded() throws -> XPCConnection {
        try connectionLock.withLock { connection in
            if let currentConnection = connection {
                return currentConnection
            }

            let newConnection = try XPCConnection(type: .remoteMachService(serviceName: RuntimeViewerMachServiceName, isPrivilegedHelperTool: true))
            newConnection.errorHandler = { [weak self] _, error in
                Self.logger.error("XPC connection error: \(error.localizedDescription, privacy: .public)")
                self?.connectionLock.withLock { conn in
                    conn = nil
                }
            }
            newConnection.activate()
            connection = newConnection
            return newConnection
        }
    }

    public func launchMacCatalystHelper() async throws {
        try await connectionIfNeeded().sendMessage(request: OpenApplicationRequest(url: RuntimeViewerCatalystHelperLauncher.helperURL))
    }
}

enum RuntimeViewerCatalystHelperLauncher {
    static let appName = "RuntimeViewerCatalystHelper"
    static let helperURL = Bundle.main.bundleURL.appendingPathComponent("Contents").appendingPathComponent("Applications").appendingPathComponent("\(appName).app")
}


// MARK: - Dependencies

private enum RuntimeHelperClientKey: DependencyKey {
    static let liveValue = RuntimeHelperClient.shared
}

extension DependencyValues {
    public var runtimeHelperClient: RuntimeHelperClient {
        get { self[RuntimeHelperClientKey.self] }
        set { self[RuntimeHelperClientKey.self] = newValue }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerHelperClient/RuntimeInjectClient.swift`:

```swift
#if os(macOS)

import Foundation
import SwiftyXPC
import RuntimeViewerCommunication
import OSLog
import Synchronization
import Dependencies
import ServiceManagement

/// Client for injecting code into running applications via the helper service.
public final class RuntimeInjectClient: @unchecked Sendable {
    public static let shared = RuntimeInjectClient()

    private let connectionLock = Mutex<XPCConnection?>(nil)

    private static let logger = Logger(subsystem: "com.mxiris.runtimeviewer", category: "RuntimeInjectClient")

    @Dependency(\.helperServiceManager) private var helperServiceManager

    private init() {
        Task { @MainActor in
            observeStatusChange()
        }
    }

    @MainActor
    private func observeStatusChange() {
        withObservationTracking {
            _ = helperServiceManager.status
        } onChange: { [weak self] in
            Task { @MainActor [weak self] in
                guard let self else { return }
                if helperServiceManager.status == .enabled {
                    reconnect()
                }
                observeStatusChange()
            }
        }
    }

    /// Invalidates the current connection and establishes a new one.
    public func reconnect() {
        invalidateConnection()
        do {
            _ = try connectionIfNeeded()
            Self.logger.info("Successfully reconnected to helper service")
        } catch {
            Self.logger.error("Failed to reconnect to helper service: \(error.localizedDescription, privacy: .public)")
        }
    }

    /// Invalidates the current connection without reconnecting.
    public func invalidateConnection() {
        connectionLock.withLock { connection in
            connection?.cancel()
            connection = nil
        }
    }

    public var isInstalledServerFramework: Bool {
        FileManager.default.fileExists(atPath: serverFrameworkDestinationURL.path)
    }

    public let serverFrameworkDestinationURL = URL(fileURLWithPath: "/Library/Frameworks/RuntimeViewerServer.framework")

    public var serverFrameworkSourceURL: URL? {
        Bundle.main.url(forResource: "RuntimeViewerServer", withExtension: "framework")
    }

    private func connectionIfNeeded() throws -> XPCConnection {
        try connectionLock.withLock { connection in
            if let currentConnection = connection {
                return currentConnection
            }

            let newConnection = try XPCConnection(type: .remoteMachService(serviceName: RuntimeViewerMachServiceName, isPrivilegedHelperTool: true))
            newConnection.errorHandler = { [weak self] _, error in
                Self.logger.error("XPC connection error: \(error.localizedDescription, privacy: .public)")
                self?.connectionLock.withLock { conn in
                    conn = nil
                }
            }
            newConnection.activate()
            connection = newConnection
            return newConnection
        }
    }

    public func injectApplication(pid: pid_t, dylibURL: URL) async throws {
        try await connectionIfNeeded().sendMessage(request: InjectApplicationRequest(pid: pid, dylibURL: dylibURL))
    }

    public enum Error: LocalizedError {
        case serverFrameworkNotFound
        public var errorDescription: String? {
            switch self {
            case .serverFrameworkNotFound:
                return "Server framework not found."
            }
        }
    }

    public func installServerFrameworkIfNeeded() async throws {
        try await installServerFramework()
    }

    public func installServerFramework() async throws {
        guard let serverFrameworkSourceURL else {
            throw Error.serverFrameworkNotFound
        }
        try await connectionIfNeeded().sendMessage(request: FileOperationRequest(operation: .copy(from: serverFrameworkSourceURL, to: serverFrameworkDestinationURL)))
    }
}

// MARK: - Dependencies

private enum RuntimeInjectClientKey: DependencyKey {
    static let liveValue = RuntimeInjectClient.shared
}

extension DependencyValues {
    public var runtimeInjectClient: RuntimeInjectClient {
        get { self[RuntimeInjectClientKey.self] }
        set { self[RuntimeInjectClientKey.self] = newValue }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerService/RuntimeViewerService.swift`:

```swift
#if os(macOS)

import AppKit
import SwiftyXPC
import MachInjector
import RuntimeViewerCommunication
import OSLog

public final class RuntimeViewerService {
    private let listener: SwiftyXPC.XPCListener

    private var catalystHelperApplication: NSRunningApplication?

    private var endpointByIdentifier: [String: SwiftyXPC.XPCEndpoint] = [:]

    private init() throws {
        self.listener = try .init(type: .machService(name: RuntimeViewerMachServiceName), codeSigningRequirement: nil)
        listener.setMessageHandler(handler: registerEndpoint)
        listener.setMessageHandler(handler: fetchEndpoint)
        listener.setMessageHandler(handler: openApplication)
        listener.setMessageHandler(handler: ping)
        listener.setMessageHandler(handler: injectApplication)
        listener.setMessageHandler(handler: fileOperation)
        listener.activate()
    }

    private func ping(_ connection: XPCConnection, request: PingRequest) async throws -> PingRequest.Response {
        return .empty
    }

    private func fetchEndpoint(_ connection: XPCConnection, request: FetchEndpointRequest) async throws -> FetchEndpointRequest.Response {
        guard let endpoint = endpointByIdentifier[request.identifier] else {
            throw XPCError.unknown("No endpoint available")
        }
        return .init(endpoint: endpoint)
    }

    private func registerEndpoint(_ connection: XPCConnection, request: RegisterEndpointRequest) async throws -> RegisterEndpointRequest.Response {
        endpointByIdentifier[request.identifier] = request.endpoint
        return .empty
    }

    private func openApplication(_ connection: XPCConnection, request: OpenApplicationRequest) async throws -> OpenApplicationRequest.Response {
        let configuration = NSWorkspace.OpenConfiguration()
        configuration.createsNewApplicationInstance = false
        configuration.addsToRecentItems = false
        configuration.activates = false
        catalystHelperApplication = try await NSWorkspace.shared.openApplication(at: request.url, configuration: configuration)
        return .empty
    }

    private func fileOperation(_ connection: XPCConnection, request: FileOperationRequest) async throws -> FileOperationRequest.Response {
        let fileManager = FileManager.default
        switch request.operation {
        case let .createDirectory(url, isIntermediateDirectories):
            try fileManager.createDirectory(at: url, withIntermediateDirectories: isIntermediateDirectories)
        case let .remove(url: url):
            try fileManager.removeItem(at: url)
        case let .move(from: from, to: to):
            try fileManager.moveItem(at: from, to: to)
        case let .copy(from: from, to: to):
            if fileManager.fileExists(atPath: to.path) {
                try fileManager.removeItem(at: to)
            }
            try fileManager.copyItem(at: from, to: to)
        case let .write(url: url, data: data):
            try data.write(to: url)
        }
        return .empty
    }

    private func injectApplication(_ connection: XPCConnection, request: InjectApplicationRequest) async throws -> InjectApplicationRequest.Response {
        try await MainActor.run {
            try MachInjector.inject(pid: request.pid, dylibPath: request.dylibURL.path)
        }
        return .empty
    }

    private static let logger = Logger(subsystem: "com.RuntimeViewer.RuntimeViewerService", category: "RuntimeViewerService")
    
    public static func main() throws {
        try autoreleasepool {
            let service = try RuntimeViewerService()
            Task {
                let notifications = NSWorkspace.shared.notificationCenter.notifications(named: NSWorkspace.didTerminateApplicationNotification)
                
                for await notification in notifications {
                    do {
                        try Task.checkCancellation()
                        
                        guard let app = notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication, app.isMainApp else { continue }
                        
                        if NSWorkspace.shared.runningApplications.contains(where: \.isMainApp) { continue }
                        
                        if let catalystHelperApplication = service.catalystHelperApplication, catalystHelperApplication.terminate() { continue }
                        
                        if let macCatalystHelper = NSWorkspace.shared.runningApplications.first(where: { $0.bundleIdentifier == "" }), macCatalystHelper.terminate() { continue }
                        
                    } catch {
                        logger.error("\(error, privacy: .public)")
                    }
                }
            }
            RunLoop.current.run()
        }
    }
}

extension NSRunningApplication {
    fileprivate var isMainApp: Bool {
        [
            "com.JH.RuntimeViewer",
            "dev.JH.RuntimeViewer",
        ].contains(bundleIdentifier)
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerServiceHelper/RVLegacyHelperTool.m`:

```m
//
//  LegacyHelperTool.m
//  RuntimeViewerPackages
//
//  Created by JH on 2026/1/17.
//

#if TARGET_OS_OSX

#import "RVLegacyHelperTool.h"
#import <ServiceManagement/ServiceManagement.h>
#import <Security/Security.h>

@implementation RVLegacyHelperTool

#pragma mark - Public API

+ (BOOL)installWithServiceName:(NSString *)serviceName error:(NSError **)error {
    // kSMRightBlessPrivilegedHelper is the standard right string for installing helpers
    AuthorizationRef authRef = [self createAuthorizationRefForRight:kSMRightBlessPrivilegedHelper error:error];
    
    if (!authRef) {
        return NO;
    }
    
    CFErrorRef cfError = NULL;
    BOOL result = NO;

    /* START IGNORE DEPRECATION
     Reason: SMJobBless is deprecated in macOS 10.10 in favor of SMAppService (macOS 13+).
     However, we wrap this in Objective-C to isolate the legacy logic required for
     older OS support or specific legacy install scenarios.
    */
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wdeprecated-declarations"
    
    result = (BOOL)SMJobBless(kSMDomainSystemLaunchd,
                              (__bridge CFStringRef)serviceName,
                              authRef,
                              &cfError);
    
    #pragma clang diagnostic pop
    /* END IGNORE DEPRECATION */

    // Cleanup authorization reference
    AuthorizationFree(authRef, kAuthorizationFlagDestroyRights);
    
    if (!result && cfError) {
        if (error) {
            *error = (__bridge_transfer NSError *)cfError;
        } else {
            CFRelease(cfError);
        }
        return NO;
    }
    
    return result;
}

+ (BOOL)uninstallWithServiceName:(NSString *)serviceName error:(NSError **)error {
    // kSMRightModifySystemDaemons is required to remove jobs from Launchd
    AuthorizationRef authRef = [self createAuthorizationRefForRight:kSMRightModifySystemDaemons error:error];
    
    if (!authRef) {
        return NO;
    }
    
    CFErrorRef cfError = NULL;
    BOOL result = NO;

    /* START IGNORE DEPRECATION
     Reason: SMJobRemove is deprecated, but Apple has not provided a replacement API
     in the ServiceManagement framework for removing tools installed via SMJobBless.
     We must use this API to clean up legacy helpers to prevent conflicts when
     migrating to SMAppService.
    */
    #pragma clang diagnostic push
    #pragma clang diagnostic ignored "-Wdeprecated-declarations"
    
    result = (BOOL)SMJobRemove(kSMDomainSystemLaunchd,
                               (__bridge CFStringRef)serviceName,
                               authRef,
                               true, // Wait for the process to exit
                               &cfError);
    
    #pragma clang diagnostic pop
    /* END IGNORE DEPRECATION */

    // Cleanup authorization reference
    AuthorizationFree(authRef, kAuthorizationFlagDestroyRights);

    if (!result) {
        if (cfError) {
            if (error) {
                *error = (__bridge_transfer NSError *)cfError;
            } else {
                CFRelease(cfError);
            }
        }
        return NO;
    }
    
    return YES;
}

#pragma mark - Private Helper

+ (AuthorizationRef)createAuthorizationRefForRight:(const char *)rightName error:(NSError **)error {
    OSStatus status;
    AuthorizationRef authRef = NULL;
    
    // 1. Define the item (the right we want to request)
    AuthorizationItem authItem = { rightName, 0, NULL, 0 };
    
    // 2. Wrap it in a rights set
    AuthorizationRights authRights = { 1, &authItem };
    
    // 3. Define flags: Allow UI interaction, extend rights, and pre-authorize
    AuthorizationFlags flags = kAuthorizationFlagInteractionAllowed |
                               kAuthorizationFlagExtendRights |
                               kAuthorizationFlagPreAuthorize;
    
    // 4. Request the authorization
    status = AuthorizationCreate(&authRights, kAuthorizationEmptyEnvironment, flags, &authRef);
    
    if (status != errAuthorizationSuccess) {
        if (error) {
            NSString *errorMessage = (__bridge_transfer NSString *)SecCopyErrorMessageString(status, NULL);
            *error = [NSError errorWithDomain:NSOSStatusErrorDomain
                                         code:status
                                     userInfo:@{NSLocalizedDescriptionKey: errorMessage ?: @"Authorization Failed"}];
        }
        return NULL;
    }
    
    return authRef;
}

@end

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerServiceHelper/include/RVLegacyHelperTool.h`:

```h
//
//  LegacyHelperTool.h
//  RuntimeViewerPackages
//
//  Created by JH on 2026/1/17.
//

#import <TargetConditionals.h>

#if TARGET_OS_OSX

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

NS_SWIFT_NAME(LegacyHelperTool)
@interface RVLegacyHelperTool : NSObject

/**
 * Installs the helper tool using the legacy SMJobBless API.
 * This is primarily used for supporting macOS versions prior to 13.0 or legacy setups.
 *
 * @param serviceName The Mach service name (Label) of the helper tool.
 * @param error If the installation fails, this pointer is set to an NSError object.
 * @return YES if successful, NO otherwise.
 */
+ (BOOL)installWithServiceName:(NSString *)serviceName error:(NSError **)error;

/**
 * Uninstalls the helper tool using the legacy SMJobRemove API.
 *
 * @note IMPORTANT: Even though SMJobRemove is deprecated, it is the ONLY official way
 * to properly remove a helper tool installed via SMJobBless.
 * Use this to clean up old versions before migrating to SMAppService.
 *
 * @param serviceName The Mach service name (Label) of the helper tool.
 * @param error If the removal fails, this pointer is set to an NSError object.
 * @return YES if successful, NO otherwise.
 */
+ (BOOL)uninstallWithServiceName:(NSString *)serviceName error:(NSError **)error;

@end

NS_ASSUME_NONNULL_END

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettings/Settings+DependencyValues.swift`:

```swift
import Dependencies

private enum SettingsKey: DependencyKey {
    static let liveValue = Settings.shared
    static let previewValue = Settings()
}

extension DependencyValues {
    public var settings: Settings {
        get { self[SettingsKey.self] }
        set { self[SettingsKey.self] = newValue }
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettings/Settings+Types.swift`:

```swift
import Foundation
import RuntimeViewerCore

extension Settings {
    /// The appearance of the app
    /// - **system**: uses the system appearance
    /// - **dark**: always uses dark appearance
    /// - **light**: always uses light appearance
    public enum Appearances: String, Codable {
        case system
        case light
        case dark
    }

    public struct General: Codable {
        public var appearance: Appearances = .system
    }

    public struct Notifications: Codable {
        /// Whether notifications are enabled globally
        public var isEnabled: Bool = true

        /// Whether to show notification when connected to a runtime engine
        public var showOnConnect: Bool = true

        /// Whether to show notification when disconnected from a runtime engine
        public var showOnDisconnect: Bool = true
    }

    public typealias TransformerSettings = RuntimeViewerCore.Transformer.Configuration
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettings/Settings.swift`:

```swift
import Foundation
import FoundationToolbox
import Observation
import MetaCodable

@Observable
@Codable
@Loggable
public final class Settings {
    public static let shared = Settings()

    private static var storage: SettingsStorageStrategy = SettingsFileSystemStorage()

    @Default(ifMissing: General())
    public var general: General = .init() {
        didSet { scheduleAutoSave() }
    }

    @Default(ifMissing: Notifications())
    public var notifications: Notifications = .init() {
        didSet { scheduleAutoSave() }
    }

    @Default(ifMissing: TransformerSettings())
    public var transformer: TransformerSettings = .init() {
        didSet { scheduleAutoSave() }
    }

    @IgnoreCoding
    @ObservationIgnored
    private var saveTask: Task<Void, Error>?

    internal init() {
        Task {
            await load()
        }
    }

    private func scheduleAutoSave() {
        saveTask?.cancel()

        saveTask = Task {
            try await Task.sleep(for: .seconds(1))

            await saveNow()
        }
    }

    private func saveNow() async {
        do {
            let data = try JSONEncoder().encode(self)
            try await Self.storage.save(data)
            #log(.debug, "Settings auto-saved successfully.")
        } catch {
            #log(.debug, "Failed to save settings: \(error, privacy: .public)")
        }
    }

    private func load() async {
        do {
            let data = try await Self.storage.load()
            let decoded = try JSONDecoder().decode(Settings.self, from: data)
            general = decoded.general
            notifications = decoded.notifications
            transformer = decoded.transformer
            #log(.debug, "Settings loaded successfully.")
        } catch {
            #log(.debug, "No saved settings found or load failed, using defaults. (\(error, privacy: .public))")
        }
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettings/SettingsStorage.swift`:

```swift
import Foundation

protocol SettingsStorageStrategy {
    func save(_ data: Data) async throws
    func load() async throws -> Data
}

struct SettingsFileSystemStorage: SettingsStorageStrategy {
    let fileName: String
    let directory: FileManager.SearchPathDirectory

    init(fileName: String = "settings.json", directory: FileManager.SearchPathDirectory = .applicationSupportDirectory) {
        self.fileName = fileName
        self.directory = directory
    }

    private var fileURL: URL {
        let paths = FileManager.default.urls(for: directory, in: .userDomainMask)
        let dir = paths[0].appendingPathComponent("RuntimeViewer")

        try? FileManager.default.createDirectory(at: dir, withIntermediateDirectories: true)
        return dir.appendingPathComponent(fileName)
    }

    func save(_ data: Data) async throws {
        try data.write(to: fileURL, options: [.atomic])
    }

    func load() async throws -> Data {
        guard FileManager.default.fileExists(atPath: fileURL.path) else {
            throw SettingsStorageError.noData
        }
        return try Data(contentsOf: fileURL)
    }
}

enum SettingsStorageError: Error {
    case noData
    case encodingFailed
    case decodingFailed
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/AppSettings.swift`:

```swift
import Foundation
import RuntimeViewerUI
import RuntimeViewerSettings
import SwiftUI
import Dependencies

@propertyWrapper
struct AppSettings<Value>: DynamicProperty {
    private let keyPath: ReferenceWritableKeyPath<RuntimeViewerSettings.Settings, Value>
    
    @Dependency(\.settings)
    private var settings
    
    init(_ keyPath: ReferenceWritableKeyPath<RuntimeViewerSettings.Settings, Value>) {
        self.keyPath = keyPath
    }

    var wrappedValue: Value {
        get {
            settings[keyPath: keyPath]
        }
        nonmutating set {
            settings[keyPath: keyPath] = newValue
        }
    }

    var projectedValue: Binding<Value> {
        Binding(
            get: { settings[keyPath: keyPath] },
            set: { settings[keyPath: keyPath] = $0 }
        )
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Components/GeneralSettingsView.swift`:

```swift
#if os(macOS)

import SwiftUI
import SettingsKit
import Dependencies
import RuntimeViewerSettings

struct GeneralSettingsView: SettingsContent {
    @AppSettings(\.general)
    var settings

    var body: some SettingsContent {
        SettingsGroup("General", .navigation) {
            SettingsForm {
                Section {
                    LabeledContent {
                        AppearancePicker(selection: $settings.appearance)
                    } label: {
                        Text("Appearance")
                    }
                }
            }
        } icon: {
            SettingsIcon(symbol: "gearshape", color: .clear)
        }
    }
}

// MARK: - Appearance Picker

private struct AppearancePicker: View {
    @Binding var selection: RuntimeViewerSettings.Settings.Appearances

    var body: some View {
        HStack(spacing: 5) {
            AppearanceOptionView(
                mode: .system,
                imageName: "AppearanceAuto_AppearanceAuto_Normal",
                title: "System",
                isSelected: selection == .system
            ) {
                selection = .system
            }
            AppearanceOptionView(
                mode: .light,
                imageName: "AppearanceLight_AppearanceLight_Normal",
                title: "Light",
                isSelected: selection == .light
            ) {
                selection = .light
            }

            AppearanceOptionView(
                mode: .dark,
                imageName: "AppearanceDark_AppearanceDark_Normal",
                title: "Dark",
                isSelected: selection == .dark
            ) {
                selection = .dark
            }
        }
        .padding(.vertical, 8)
    }
}

// MARK: - Appearance Option View

private struct AppearanceOptionView: View {
    let mode: RuntimeViewerSettings.Settings.Appearances
    let imageName: String
    let title: String
    let isSelected: Bool
    let action: () -> Void

    @State private var isHovering = false

    var body: some View {
        Button(action: action) {
            VStack(spacing: 8) {
                Image(imageName, bundle: .module)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 72, height: 48)
                    .clipShape(RoundedRectangle(cornerRadius: 5))
                    .overlay(
                        RoundedRectangle(cornerRadius: 5)
                            .stroke(
                                isSelected ? Color.accentColor : Color.clear,
                                lineWidth: 3
                            )
                    )
                    .shadow(
                        color: .black.opacity(isHovering ? 0.15 : 0.1),
                        radius: isHovering ? 3 : 2,
                        x: 0,
                        y: 1
                    )

                Text(title)
                    .font(.caption)
                    .foregroundStyle(isSelected ? .primary : .secondary)
            }
        }
        .buttonStyle(.plain)
        .onHover { hovering in
            isHovering = hovering
        }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Components/HelperServiceSettingsView.swift`:

```swift
#if os(macOS)

import SwiftUI
import SettingsKit
import ServiceManagement
import RuntimeViewerHelperClient
import Dependencies

// MARK: - UI Helper Extensions

extension SMAppService.Status {
    var icon: String {
        switch self {
        case .enabled:
            return "checkmark.circle.fill"
        case .requiresApproval:
            return "exclamationmark.triangle.fill"
        case .notRegistered, .notFound:
            return "xmark.circle.fill"
        @unknown default:
            return "questionmark.circle.fill"
        }
    }

    var color: Color {
        switch self {
        case .enabled:
            return .green
        case .requiresApproval:
            return .orange
        case .notRegistered, .notFound:
            return .secondary
        @unknown default:
            return .secondary
        }
    }
}

// MARK: - Settings View

struct HelperServiceSettingsView: SettingsContent {
    @Dependency(\.helperServiceManager) private var manager

    var body: some SettingsContent {
        SettingsGroup("Helper", .navigation) {
            SettingsForm {
                if manager.isLegacyServiceInstalled {
                    Section {
                        LegacyServiceStatusRow()
                    } header: {
                        Text("Legacy Helper Service")
                    } footer: {
                        Text("The legacy helper service uses deprecated APIs. Please uninstall it and install the new version for better stability and security.")
                    }
                }

                Section {
                    HelperServiceStatusRow()
                } header: {
                    Text("Helper Service")
                } footer: {
                    Text("The helper service enables advanced features such as code injection and accessing system-protected processes.")
                }

                Section {
                    QuickActionsRow()
                } header: {
                    Text("Quick Actions")
                }
            }
            .task {
                await manager.refreshAllStatus()
            }
            .onReceive(NotificationCenter.default.publisher(for: NSApplication.didBecomeActiveNotification)) { _ in
                Task { @MainActor in
                    await manager.refreshAllStatus()
                }
            }
        } icon: {
            SettingsIcon(symbol: "wrench.and.screwdriver", color: .clear)
        }
    }
}

// MARK: - Legacy Service Status Row

private struct LegacyServiceStatusRow: View {
    @Dependency(\.helperServiceManager) private var manager

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: manager.isLegacyServiceInstalled ? "exclamationmark.triangle.fill" : "checkmark.circle.fill")
                    .foregroundStyle(manager.isLegacyServiceInstalled ? .orange : .green)
                    .font(.title2)

                VStack(alignment: .leading, spacing: 2) {
                    Text("Legacy Version Detected")
                        .font(.headline)
                    Text(manager.legacyMessage)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }

                Spacer()

                if manager.isLegacyLoading {
                    ProgressView()
                        .controlSize(.small)
                } else {
                    Button("Uninstall", role: .destructive) {
                        Task {
                            await manager.uninstallLegacyService()
                        }
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.red)
                    .disabled(!manager.canUninstallLegacy)
                    .help(manager.canUninstallLegacy ? "Uninstall the legacy helper service" : "Install the new helper service first")
                }
            }
        }
        .padding(.vertical, 4)
    }
}

// MARK: - Helper Service Status Row

private struct HelperServiceStatusRow: View {
    @Dependency(\.helperServiceManager) private var manager

    var body: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Image(systemName: manager.status.icon)
                    .foregroundStyle(manager.status.color)
                    .font(.title2)

                VStack(alignment: .leading, spacing: 2) {
                    Text("Helper Service")
                        .font(.headline)
                    Text(manager.message)
                        .font(.caption)
                        .foregroundStyle(.secondary)
                }

                Spacer()

                if manager.isLoading {
                    ProgressView()
                        .controlSize(.small)
                } else {
                    ServiceActionButtons()
                }
            }
        }
        .padding(.vertical, 4)
    }
}

// MARK: - Service Action Buttons

private struct ServiceActionButtons: View {
    @Dependency(\.helperServiceManager) private var manager

    var body: some View {
        HStack(spacing: 8) {
            switch manager.status {
            case .enabled:
                Button("Uninstall", role: .destructive) {
                    Task {
                        await manager.manageHelperService(action: .uninstall)
                    }
                }
                .buttonStyle(.bordered)

            case .requiresApproval:
                Button("Open Settings") {
                    SMAppService.openSystemSettingsLoginItems()
                }
                .buttonStyle(.borderedProminent)

            case .notRegistered, .notFound:
                Button("Install") {
                    Task {
                        await manager.manageHelperService(action: .install)
                    }
                }
                .buttonStyle(.borderedProminent)

            @unknown default:
                Button("Refresh") {
                    Task {
                        await manager.manageHelperService(action: .status)
                    }
                }
                .buttonStyle(.bordered)
            }
        }
    }
}

// MARK: - Quick Actions Row

private struct QuickActionsRow: View {
    @Dependency(\.helperServiceManager) private var manager

    var body: some View {
        HStack {
            Button {
                Task {
                    await manager.refreshAllStatus()
                }
            } label: {
                Label("Refresh Status", systemImage: "arrow.clockwise")
            }

            Spacer()

            Button {
                SMAppService.openSystemSettingsLoginItems()
            } label: {
                Label("Open Login Items Settings", systemImage: "gear")
            }
        }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Components/NotificationSettingsView.swift`:

```swift
#if os(macOS)

import SwiftUI
import SettingsKit
import Dependencies
import RuntimeViewerSettings

struct NotificationSettingsView: SettingsContent {
    @AppSettings(\.notifications)
    var settings

    var body: some SettingsContent {
        SettingsGroup("Notifications", .navigation) {
            SettingsForm {
                Section {
                    Toggle("Enable Notifications", isOn: $settings.isEnabled)
                } footer: {
                    Text("When enabled, you will receive notifications for connection events.")
                }

                Section {
                    Toggle("Connection Established", isOn: $settings.showOnConnect)
                        .disabled(!settings.isEnabled)

                    Toggle("Connection Lost", isOn: $settings.showOnDisconnect)
                        .disabled(!settings.isEnabled)
                } header: {
                    Text("Connection Events")
                } footer: {
                    Text("Choose which events trigger notifications.")
                }
            }
        } icon: {
            SettingsIcon(symbol: "bell.badge", color: .clear)
        }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Components/TransformerSettingsView.swift`:

```swift
#if os(macOS)

import AppKit
import SwiftUI
import SettingsKit
import Dependencies
import RuntimeViewerSettings
import RuntimeViewerCore

struct TransformerSettingsView: SettingsContent {
    @AppSettings(\.transformer)
    var config

    var body: some SettingsContent {
        SettingsGroup("Transformer", .navigation) {
            SettingsForm {
                // MARK: - C Type Module

                Section {
                    Toggle("Transform C Types", isOn: $config.objc.cType.isEnabled)
                } footer: {
                    Text("Transform C primitive types to custom types in ObjC interfaces.")
                }

                if config.objc.cType.isEnabled {
                    Section {
                        CTypeEditor(module: $config.objc.cType)
                    } header: {
                        HStack {
                            Text("Type Replacements")
                            Spacer()
                            CTypePresets(module: $config.objc.cType)
                        }
                    }
                }

                // MARK: - Swift Field Offset Module

                Section {
                    Toggle("Transform Swift Field Offset Comment", isOn: $config.swift.swiftFieldOffset.isEnabled)
                } footer: {
                    Text("Transform Swift field offset comment format in Swift interfaces.")
                }

                if config.swift.swiftFieldOffset.isEnabled {
                    Section {
                        SwiftFieldOffsetEditor(module: $config.swift.swiftFieldOffset)
                    } header: {
                        Text("Output Format")
                    }
                }

                // MARK: - Swift Type Layout Module

                Section {
                    Toggle("Transform Swift Type Layout Comment", isOn: $config.swift.swiftTypeLayout.isEnabled)
                } footer: {
                    Text("Transform Swift type layout comment format in Swift interfaces.")
                }

                if config.swift.swiftTypeLayout.isEnabled {
                    Section {
                        SwiftTypeLayoutEditor(module: $config.swift.swiftTypeLayout)
                    } header: {
                        Text("Output Format")
                    }
                }

                // MARK: - Swift Enum Layout Module

                Section {
                    Toggle("Transform Swift Enum Layout Comment", isOn: $config.swift.swiftEnumLayout.isEnabled)
                } footer: {
                    Text("Transform Swift enum layout comment format in Swift interfaces.")
                }

                if config.swift.swiftEnumLayout.isEnabled {
                    Section {
                        SwiftEnumLayoutEditor(module: $config.swift.swiftEnumLayout)
                    } header: {
                        Text("Output Format")
                    }
                }
            }
        } icon: {
            SettingsIcon(symbol: "arrow.triangle.2.circlepath", color: .clear)
        }
    }
}

// MARK: - C Type Editor

private struct CTypeEditor: View {
    @Binding var module: Transformer.CType

    var body: some View {
        Grid(alignment: .leading, horizontalSpacing: 8, verticalSpacing: 6) {
            ForEach(Transformer.CType.Pattern.allCases, id: \.self) { pattern in
                GridRow {
                    HStack(spacing: 6) {
                        Text(pattern.displayName)
                            .font(.system(.body, design: .monospaced))
                            .foregroundStyle(.secondary)
                            .lineLimit(1)

                        Image(systemName: "arrow.right")
                            .font(.caption2)
                            .foregroundStyle(.tertiary)
                    }
                    .fixedSize()
                    .gridColumnAlignment(.trailing)

                    TextField(
                        "Replacement",
                        text: Binding(
                            get: {
                                module.replacements[pattern] ?? ""
                            },
                            set: { newValue in
                                if newValue.isEmpty {
                                    module.replacements.removeValue(forKey: pattern)
                                } else {
                                    module.replacements[pattern] = newValue
                                }
                            }
                        )
                    )
                    .textFieldStyle(.roundedBorder)
                    .font(.system(.body, design: .monospaced))
                }
            }
        }
    }
}

// MARK: - C Type Presets

private struct CTypePresets: View {
    @Binding var module: Transformer.CType

    var body: some View {
        HStack(spacing: 6) {
            Button("stdint") {
                module.replacements = Transformer.CType.Presets.stdint
            }
            .buttonStyle(.bordered)
            .controlSize(.small)
            .help("uint32_t, int64_t, etc.")

            Button("Foundation") {
                module.replacements = Transformer.CType.Presets.foundation
            }
            .buttonStyle(.bordered)
            .controlSize(.small)
            .help("CGFloat, NSInteger, etc.")
            
            Button("Mixed") {
                module.replacements = Transformer.CType.Presets.mixed
            }
            .buttonStyle(.bordered)
            .controlSize(.small)

            Button("Clear") {
                module.replacements.removeAll()
            }
            .buttonStyle(.bordered)
            .controlSize(.small)
        }
    }
}

// MARK: - Token Text Attachment

private final class TokenTextAttachment: NSTextAttachment {}

private final class TokenTextAttachmentCell: NSTextAttachmentCell, @unchecked Sendable {
    let tokenName: String
    let tokenPlaceholder: String

    init(tokenName: String) {
        self.tokenName = tokenName
        self.tokenPlaceholder = "${\(tokenName)}"
        super.init(textCell: tokenPlaceholder)
    }

    @available(*, unavailable)
    required init(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    static let effectiveFont: NSFont = .monospacedSystemFont(ofSize: NSFont.systemFontSize, weight: .medium)

    private static let innerPadding: CGFloat = 5

    override func cellSize() -> NSSize {
        let textSize = (tokenName as NSString).size(withAttributes: [.font: Self.effectiveFont])
        return NSSize(width: textSize.width + Self.innerPadding * 2, height: textSize.height + 2)
    }

    override func cellBaselineOffset() -> NSPoint {
        NSPoint(x: 0, y: Self.effectiveFont.descender)
    }

    override func draw(withFrame cellFrame: NSRect, in controlView: NSView?) {
        guard let context = NSGraphicsContext.current else { return }
        let accentColor = NSColor.controlAccentColor

        context.saveGraphicsState()
        accentColor.withAlphaComponent(0.15).setFill()
        let path = NSBezierPath(roundedRect: cellFrame, xRadius: 4, yRadius: 4)
        path.fill()
        context.restoreGraphicsState()

        let attributed = NSAttributedString(string: tokenName, attributes: [
            .font: Self.effectiveFont,
            .foregroundColor: accentColor,
        ])
        let textSize = attributed.size()
        var drawPoint = cellFrame.origin
        drawPoint.x += (cellFrame.width - textSize.width) / 2
        drawPoint.y += (cellFrame.height - textSize.height) / 2
        attributed.draw(at: drawPoint)
    }
}

// MARK: - Token Template Text View

private final class TokenTemplateTextView: NSTextView {
    var didChangeTextHandler: ((String) -> Void)?
    var didChangeHeightHandler: ((CGFloat) -> Void)?

    override var string: String {
        didSet { tokenize() }
    }

    /// Returns the raw template string with ${...} placeholders restored.
    var templateString: String {
        attributedString().untokenized.string
    }

    func commonInit() {
        font = .monospacedSystemFont(ofSize: NSFont.systemFontSize, weight: .regular)
        textColor = .textColor
        isEditable = true
        isSelectable = true
        isRichText = true
        allowsUndo = true
        isAutomaticQuoteSubstitutionEnabled = false
        isAutomaticDashSubstitutionEnabled = false
        isAutomaticTextReplacementEnabled = false
        isAutomaticSpellingCorrectionEnabled = false
        isVerticallyResizable = true
        isHorizontallyResizable = false
        textContainer?.widthTracksTextView = true
        textContainer?.lineFragmentPadding = 4
        drawsBackground = false
        textContainerInset = NSSize(width: 0, height: 2)
        typingAttributes = [
            .font: font as Any,
            .foregroundColor: NSColor.textColor,
        ]
    }

    /// Computes the content height based on the text layout.
    var contentHeight: CGFloat {
        guard let layoutManager, let textContainer else { return 24 }
        layoutManager.ensureLayout(for: textContainer)
        let usedRect = layoutManager.usedRect(for: textContainer)
        return usedRect.height + textContainerInset.height * 2
    }

    override func didChangeText() {
        super.didChangeText()
        tokenize()
        didChangeTextHandler?(templateString)
        didChangeHeightHandler?(contentHeight)
    }

    override func writeSelection(to pboard: NSPasteboard, types: [NSPasteboard.PasteboardType]) -> Bool {
        let selected = attributedString().attributedSubstring(from: selectedRange())
        pboard.clearContents()
        pboard.writeObjects([selected.untokenized])
        return true
    }

    private func tokenize() {
        guard let textStorage else { return }
        let pattern = #"\$\{([^}]+)\}"#
        guard let regex = try? NSRegularExpression(pattern: pattern) else { return }
        let string = textStorage.string
        let range = NSRange(string.startIndex..., in: string)
        let matches = regex.matches(in: string, range: range)

        let defaultAttributes: [NSAttributedString.Key: Any] = [
            .font: NSFont.monospacedSystemFont(ofSize: NSFont.systemFontSize, weight: .regular),
            .foregroundColor: NSColor.textColor,
        ]

        textStorage.beginEditing()
        textStorage.setAttributes(defaultAttributes, range: range)
        for match in matches.reversed() {
            let nsString = string as NSString
            let fullMatch = nsString.substring(with: match.range)
            let tokenName = fullMatch
                .replacingOccurrences(of: "${", with: "")
                .replacingOccurrences(of: "}", with: "")
            let attachment = TokenTextAttachment()
            let cell = TokenTextAttachmentCell(tokenName: tokenName)
            attachment.attachmentCell = cell
            textStorage.replaceCharacters(in: match.range, with: NSAttributedString(attachment: attachment))
        }
        textStorage.endEditing()
    }
}

extension NSAttributedString {
    /// Converts attachment-based tokens back to ${...} placeholder strings.
    fileprivate var untokenized: NSAttributedString {
        let result = mutableCopy() as! NSMutableAttributedString
        let fullRange = NSRange(string.startIndex..., in: string)
        enumerateAttribute(.attachment, in: fullRange, options: .reverse) { value, range, _ in
            guard let attachment = value as? TokenTextAttachment,
                  let cell = attachment.attachmentCell as? TokenTextAttachmentCell else { return }
            result.replaceCharacters(in: range, with: NSAttributedString(string: cell.tokenPlaceholder))
        }
        return result
    }
}

// MARK: - Token Template Text Field (SwiftUI wrapper)

private struct TokenTemplateTextField: NSViewRepresentable {
    @Binding var text: String
    @Binding var height: CGFloat

    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }

    func makeNSView(context: Context) -> NSScrollView {
        let scrollView = TokenTemplateTextView.scrollableTextView()
        let textView = scrollView.documentView as! TokenTemplateTextView
        textView.commonInit()
        textView.didChangeTextHandler = { [weak coordinator = context.coordinator] newTemplate in
            guard let coordinator, !coordinator.isUpdatingFromSwiftUI else { return }
            coordinator.parent.text = newTemplate
        }
        textView.didChangeHeightHandler = { [weak coordinator = context.coordinator] newHeight in
            guard let coordinator, !coordinator.isUpdatingFromSwiftUI else { return }
            coordinator.parent.height = newHeight
        }
        context.coordinator.textView = textView

        scrollView.hasVerticalScroller = false
        scrollView.hasHorizontalScroller = false
        scrollView.drawsBackground = true
        scrollView.backgroundColor = .textBackgroundColor
        scrollView.wantsLayer = true
        scrollView.layer?.cornerRadius = 6
        scrollView.layer?.masksToBounds = true
        scrollView.borderType = .noBorder

        textView.string = text

        DispatchQueue.main.async {
            self.height = textView.contentHeight
        }

        return scrollView
    }

    func updateNSView(_ scrollView: NSScrollView, context: Context) {
        guard let textView = context.coordinator.textView else { return }
        if textView.templateString != text {
            context.coordinator.isUpdatingFromSwiftUI = true
            textView.string = text
            context.coordinator.isUpdatingFromSwiftUI = false
            DispatchQueue.main.async {
                self.height = textView.contentHeight
            }
        }
    }

    final class Coordinator: NSObject {
        var parent: TokenTemplateTextField
        weak var textView: TokenTemplateTextView?
        var isUpdatingFromSwiftUI = false

        init(parent: TokenTemplateTextField) {
            self.parent = parent
        }
    }
}

// MARK: - Copyable Token Chip

private struct CopyableTokenChip<Token: RawRepresentable & Hashable>: View where Token.RawValue == String {
    let token: Token
    let placeholder: String

    @State private var copied = false

    var body: some View {
        Button {
            copyToClipboard(placeholder)
            copied = true
            DispatchQueue.main.asyncAfter(deadline: .now() + 1.5) {
                copied = false
            }
        } label: {
            HStack(spacing: 4) {
                Text(token.rawValue)
                    .font(.system(.caption, design: .monospaced))
                Image(systemName: copied ? "checkmark" : "doc.on.doc")
                    .font(.caption2)
                    .foregroundStyle(copied ? .green : .secondary)
            }
            .padding(.horizontal, 8)
            .padding(.vertical, 4)
            .background(.quaternary)
            .clipShape(RoundedRectangle(cornerRadius: 5))
        }
        .buttonStyle(.plain)
        .help(copied ? "Copied!" : "Click to copy \(placeholder)")
        .animation(.easeInOut(duration: 0.2), value: copied)
    }

    private func copyToClipboard(_ string: String) {
        NSPasteboard.general.clearContents()
        NSPasteboard.general.setString(string, forType: .string)
    }
}

// MARK: - Swift Field Offset Editor

private struct SwiftFieldOffsetEditor: View {
    @Binding var module: Transformer.SwiftFieldOffset
    @State private var textFieldHeight: CGFloat = 24

    var body: some View {
        Grid(alignment: .leading, horizontalSpacing: 8, verticalSpacing: 10) {
            // Token-styled template editor
            GridRow {
                Text("Template")
                    .foregroundStyle(.secondary)
                    .gridColumnAlignment(.trailing)

                TokenTemplateTextField(text: $module.template, height: $textFieldHeight)
                    .frame(height: max(24, textFieldHeight))
            }

            // Radix picker
            GridRow {
                Text("Radix")
                    .foregroundStyle(.secondary)

                Picker("", selection: $module.useHexadecimal) {
                    Text("Decimal").tag(false)
                    Text("Hexadecimal").tag(true)
                }
                .pickerStyle(.segmented)
                .labelsHidden()
                .fixedSize()
            }

            // Copyable token chips
            GridRow {
                Text("Tokens")
                    .foregroundStyle(.secondary)

                HStack(spacing: 8) {
                    ForEach(Transformer.SwiftFieldOffset.Token.allCases, id: \.self) { token in
                        CopyableTokenChip(token: token, placeholder: token.placeholder)
                    }
                }
            }

            // Preset buttons
            GridRow {
                Text("Presets")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftFieldOffset.Templates.all, id: \.name) { preset in
                        Button(preset.name) {
                            module.template = preset.template
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.small)
                    }
                }
            }
        }
    }
}

// MARK: - Swift Type Layout Editor

private struct SwiftTypeLayoutEditor: View {
    @Binding var module: Transformer.SwiftTypeLayout
    @State private var textFieldHeight: CGFloat = 24

    var body: some View {
        Grid(alignment: .leading, horizontalSpacing: 8, verticalSpacing: 10) {
            // Token-styled template editor
            GridRow {
                Text("Template")
                    .foregroundStyle(.secondary)
                    .gridColumnAlignment(.trailing)

                TokenTemplateTextField(text: $module.template, height: $textFieldHeight)
                    .frame(height: max(24, textFieldHeight))
            }

            // Radix picker
            GridRow {
                Text("Radix")
                    .foregroundStyle(.secondary)

                Picker("", selection: $module.useHexadecimal) {
                    Text("Decimal").tag(false)
                    Text("Hexadecimal").tag(true)
                }
                .pickerStyle(.segmented)
                .labelsHidden()
                .fixedSize()
            }

            // Copyable token chips
            GridRow {
                Text("Tokens")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftTypeLayout.Token.allCases, id: \.self) { token in
                        CopyableTokenChip(token: token, placeholder: token.placeholder)
                    }
                }
            }

            // Preset buttons
            GridRow {
                Text("Presets")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftTypeLayout.Templates.all, id: \.name) { preset in
                        Button(preset.name) {
                            module.template = preset.template
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.small)
                    }
                }
            }
        }
    }
}

// MARK: - Swift Enum Layout Editor

private struct SwiftEnumLayoutEditor: View {
    @Binding var module: Transformer.SwiftEnumLayout
    @State private var strategyFieldHeight: CGFloat = 24
    @State private var caseFieldHeight: CGFloat = 24
    @State private var memoryOffsetFieldHeight: CGFloat = 24

    var body: some View {
        Grid(alignment: .leading, horizontalSpacing: 8, verticalSpacing: 10) {
            // Strategy header template editor
            GridRow {
                Text("Strategy\nTemplate")
                    .foregroundStyle(.secondary)
                    .gridColumnAlignment(.trailing)

                TokenTemplateTextField(text: $module.template, height: $strategyFieldHeight)
                    .frame(height: max(24, strategyFieldHeight))
            }

            // Strategy token chips
            GridRow {
                Text("Tokens")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftEnumLayout.Token.allCases, id: \.self) { token in
                        CopyableTokenChip(token: token, placeholder: token.placeholder)
                    }
                }
            }

            // Strategy preset buttons
            GridRow {
                Text("Presets")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftEnumLayout.Templates.all, id: \.name) { preset in
                        Button(preset.name) {
                            module.template = preset.template
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.small)
                    }
                }
            }

            Divider()
                .gridCellColumns(2)

            // Per-case template editor
            GridRow {
                Text("Case\nTemplate")
                    .foregroundStyle(.secondary)
                    .gridColumnAlignment(.trailing)

                TokenTemplateTextField(text: $module.caseTemplate, height: $caseFieldHeight)
                    .frame(height: max(24, caseFieldHeight))
            }

            // Case token chips
            GridRow {
                Text("Tokens")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftEnumLayout.CaseToken.allCases, id: \.self) { token in
                        CopyableTokenChip(token: token, placeholder: token.placeholder)
                    }
                }
            }

            // Case preset buttons
            GridRow {
                Text("Presets")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftEnumLayout.CaseTemplates.all, id: \.name) { preset in
                        Button(preset.name) {
                            module.caseTemplate = preset.template
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.small)
                    }
                }
            }

            Divider()
                .gridCellColumns(2)

            // Memory offset template editor
            GridRow {
                Text("Memory\nOffset")
                    .foregroundStyle(.secondary)
                    .gridColumnAlignment(.trailing)

                TokenTemplateTextField(text: $module.memoryOffsetTemplate, height: $memoryOffsetFieldHeight)
                    .frame(height: max(24, memoryOffsetFieldHeight))
            }

            // Memory offset token chips
            GridRow {
                Text("Tokens")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftEnumLayout.MemoryOffsetToken.allCases, id: \.self) { token in
                        CopyableTokenChip(token: token, placeholder: token.placeholder)
                    }
                }
            }

            // Memory offset preset buttons
            GridRow {
                Text("Presets")
                    .foregroundStyle(.secondary)

                FlowLayout(spacing: 6) {
                    ForEach(Transformer.SwiftEnumLayout.MemoryOffsetTemplates.all, id: \.name) { preset in
                        Button(preset.name) {
                            module.memoryOffsetTemplate = preset.template
                        }
                        .buttonStyle(.bordered)
                        .controlSize(.small)
                    }
                }
            }

            Divider()
                .gridCellColumns(2)

            // Radix picker (shared)
            GridRow {
                Text("Radix")
                    .foregroundStyle(.secondary)

                Picker("", selection: $module.useHexadecimal) {
                    Text("Decimal").tag(false)
                    Text("Hexadecimal").tag(true)
                }
                .pickerStyle(.segmented)
                .labelsHidden()
                .fixedSize()
            }
        }
    }
}

// MARK: - Flow Layout

private struct FlowLayout: Layout {
    var spacing: CGFloat = 6

    func sizeThatFits(proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) -> CGSize {
        let result = layout(proposal: proposal, subviews: subviews)
        return result.size
    }

    func placeSubviews(in bounds: CGRect, proposal: ProposedViewSize, subviews: Subviews, cache: inout ()) {
        let result = layout(proposal: proposal, subviews: subviews)
        for (index, position) in result.positions.enumerated() {
            subviews[index].place(at: CGPoint(x: bounds.minX + position.x, y: bounds.minY + position.y), proposal: .unspecified)
        }
    }

    private func layout(proposal: ProposedViewSize, subviews: Subviews) -> (size: CGSize, positions: [CGPoint]) {
        let maxWidth = proposal.width ?? .infinity
        var positions: [CGPoint] = []
        var currentX: CGFloat = 0
        var currentY: CGFloat = 0
        var lineHeight: CGFloat = 0
        var maxX: CGFloat = 0

        for subview in subviews {
            let size = subview.sizeThatFits(.unspecified)
            if currentX + size.width > maxWidth, currentX > 0 {
                currentX = 0
                currentY += lineHeight + spacing
                lineHeight = 0
            }
            positions.append(CGPoint(x: currentX, y: currentY))
            lineHeight = max(lineHeight, size.height)
            currentX += size.width + spacing
            maxX = max(maxX, currentX - spacing)
        }

        return (CGSize(width: maxX, height: currentY + lineHeight), positions)
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Resources/Assets.xcassets/AppearanceAuto-Old_AppearanceAuto.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "AppearanceAuto-Old_AppearanceAuto@1x.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "AppearanceAuto-Old_AppearanceAuto@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Resources/Assets.xcassets/AppearanceAuto_AppearanceAuto_Normal.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "AppearanceAuto_AppearanceAuto_Normal.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "AppearanceAuto_AppearanceAuto_Normal@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Resources/Assets.xcassets/AppearanceDark-Old_AppearanceDark.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "AppearanceDark-Old_AppearanceDark@1x.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "AppearanceDark-Old_AppearanceDark@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Resources/Assets.xcassets/AppearanceDark_AppearanceDark_Normal.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "AppearanceDark_AppearanceDark_Normal.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "AppearanceDark_AppearanceDark_Normal@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Resources/Assets.xcassets/AppearanceLight-Old_AppearanceLight.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "AppearanceLight-Old_AppearanceLight@1x.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "AppearanceLight-Old_AppearanceLight@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Resources/Assets.xcassets/AppearanceLight_AppearanceLight_Normal.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "AppearanceLight_AppearanceLight_Normal.png",
      "idiom" : "universal",
      "scale" : "1x"
    },
    {
      "filename" : "AppearanceLight_AppearanceLight_Normal@2x.png",
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/Resources/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/RuntimeViewerSettingsStyle.swift`:

```swift
import SwiftUI
import SettingsKit
import Dependencies
import RuntimeViewerSettings

struct RuntimeViewerSettingsStyle: SettingsStyle {
    init() {}

    func makeContainer(configuration: ContainerConfiguration) -> some View {
        SidebarContainer(configuration: configuration)
    }

    func makeGroup(configuration: GroupConfiguration) -> some View {
        switch configuration.presentation {
        case .navigation:
            SidebarNavigationLink(configuration: configuration)
        case .inline:
            Section {
                configuration.content
            } footer: {
                if let footer = configuration.footer {
                    Text(footer)
                }
            }
        }
    }

    func makeItem(configuration: ItemConfiguration) -> some View {
        configuration.content
    }

    private struct SidebarNavigationLink: View {
        let configuration: SettingsGroupConfiguration

        var body: some View {
            destinationBasedLink
        }

        private var destinationBasedLink: some View {
            NavigationLink {
                NavigationStack {
                    configuration.content
                        .navigationTitle(configuration.title)
                }
            } label: {
                configuration.label
            }
        }

        private var selectionBasedLink: some View {
            NavigationLink(value: configuration) {
                configuration.label
            }
        }
    }

    private struct SidebarContainer: View {
        let configuration: SettingsContainerConfiguration

        @State
        private var selectedGroup: SettingsGroupConfiguration?

        var body: some View {
            NavigationSplitView {
                List(selection: selectionBinding) {
                    configuration.content
                }
                .navigationTitle(configuration.title)
                .navigationSplitViewColumnWidth(185)

            } detail: {
                Text("Select a setting")
                    .foregroundStyle(.secondary)
            }
            .hideSidebarToggle()
        }

        private var selectionBinding: Binding<SettingsGroupConfiguration?>? {
            nil
        }
    }
}

import SwiftUIIntrospect

extension View {
    fileprivate func hideSidebarToggle() -> some View {
        modifier(HideSidebarToggleViewModifier())
    }
}

private struct HideSidebarToggleViewModifier: ViewModifier {
    func body(content: Content) -> some View {
        content
            .introspect(.window, on: .macOS(.v13, .v14, .v15, .v26)) { window in
                if let toolbar = window.toolbar {
                    let sidebarItem = "com.apple.SwiftUI.navigationSplitView.toggleSidebar"
                    let sidebarToggle = toolbar.items.first(where: { $0.itemIdentifier.rawValue == sidebarItem })
                    sidebarToggle?.view?.isHidden = true
                }
            }
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/SettingsForm.swift`:

```swift
import SwiftUI
import SwiftUIIntrospect
import RuntimeViewerUI

struct SettingsForm<Content: View>: View {
    @Environment(\.colorScheme)
    private var colorScheme

    @Environment(\.controlActiveState)
    private var activeState

    @Environment(SettingsViewModel.self)
    private var viewModel

    @ViewBuilder
    var content: Content

    var body: some View {
        NavigationStack {
            Form {
                Section {
                    EmptyView()
                } footer: {
                    Rectangle()
                        .frame(height: 0)
                        .background(
                            GeometryReader {
                                Color.clear.preference(
                                    key: ViewOffsetKey.self,
                                    value: -$0.frame(in: .named("scroll")).origin.y
                                )
                            }
                        )
                        .onPreferenceChange(ViewOffsetKey.self) {
                            if $0 <= -20.0 && !viewModel.scrolledToTop {
                                withAnimation {
                                    viewModel.scrolledToTop = true
                                }
                            } else if $0 > -20.0 && viewModel.scrolledToTop {
                                withAnimation {
                                    viewModel.scrolledToTop = false
                                }
                            }
                        }
                }
                content
            }
            .introspect(.scrollView, on: .macOS(.v10_15, .v11, .v12, .v13, .v14, .v15, .v26)) {
                $0.scrollerInsets.top = 50
            }
            .formStyle(.grouped)
            .coordinateSpace(name: "scroll")
        }
        .safeAreaInset(edge: .top, spacing: -50) {
            VisualEffectView(.menu)
                .opacity(!viewModel.scrolledToTop ? 1 : 0)
                .transaction { transaction in
                    transaction.animation = nil
                }
                .overlay(alignment: .bottom) {
                    LinearGradient(
                        gradient: Gradient(
                            colors: [.black.opacity(colorScheme == .dark ? 1 : 0.17), .black.opacity(0)]
                        ),
                        startPoint: .top,
                        endPoint: .bottom
                    )
                    .frame(height: colorScheme == .dark || activeState == .inactive ? 1 : 2)
                    .padding(.bottom, colorScheme == .dark || activeState == .inactive ? -1 : -2)
                    .opacity(!viewModel.scrolledToTop ? 1 : 0)
                    .transition(.opacity)
                }
                .ignoresSafeArea()
                .frame(height: 0)
        }
    }

    private struct ViewOffsetKey: PreferenceKey {
        typealias Value = CGFloat

        static var defaultValue: CGFloat { .zero }

        static func reduce(value: inout Value, nextValue: () -> Value) {
            value += nextValue()
        }
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/SettingsIcon.swift`:

```swift
import SwiftUI
import SwiftUIIntrospect

struct SettingsIcon: View {
    private let content: IconContent
    private let color: Color?
    private let size: CGFloat

    init(
        symbol: String,
        color: Color? = nil,
        size: CGFloat? = nil
    ) {
        self.content = .symbol(symbol)
        self.color = color ?? .accentColor
        self.size = size ?? 20
    }

    init(
        text: String,
        textColor: Color? = nil,
        color: Color? = nil,
        size: CGFloat? = nil
    ) {
        self.content = .text(text, textColor: textColor)
        self.color = color ?? .accentColor
        self.size = size ?? 20
    }

    init(
        image: Image,
        size: CGFloat? = nil
    ) {
        self.content = .image(image)
        self.color = nil
        self.size = size ?? 20
    }

    private func getSafeImage(named: String) -> Image {
        if NSImage(systemSymbolName: named, accessibilityDescription: nil) != nil {
            return Image(systemName: named)
        } else {
            return Image(named)
        }
    }

    var body: some View {
        RoundedRectangle(cornerRadius: size / 4, style: .continuous)
            .fill(background)
            .overlay {
                switch content {
                case .symbol(let name):
                    getSafeImage(named: name)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .foregroundColor(.primary)
                        .padding(size / 8)
                case .text(let text, let textColor):
                    Text(text)
                        .font(.system(size: size * 0.65))
                        .foregroundColor(textColor ?? .primary)
                case .image(let image):
                    image
                        .resizable()
                        .aspectRatio(contentMode: .fill)
                }
            }
            .clipShape(RoundedRectangle(cornerRadius: size / 4, style: .continuous))
            .shadow(
                color: Color(NSColor.black).opacity(0.25),
                radius: size / 40,
                y: size / 40
            )
            .frame(width: size, height: size)
    }

    private var background: AnyShapeStyle {
        switch content {
        case .symbol,
             .text:
            return AnyShapeStyle((color ?? .accentColor).gradient)
        case .image:
            return AnyShapeStyle(.regularMaterial)
        }
    }

    private enum IconContent {
        case symbol(String)
        case text(String, textColor: Color?)
        case image(Image)
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/SettingsRootView.swift`:

```swift
import SwiftUI
import SettingsKit
import Dependencies
import Observation
import SwiftUIIntrospect

struct SettingsRootView: View {
    @Dependency(\.settings)
    private var settings

    @State
    private var viewModel = SettingsViewModel()

    var body: some View {
        SettingsView()
            .environment(settings)
            .environment(viewModel)
            .frame(minWidth: 715, maxWidth: 715)
            .frame(minHeight: 400)
            .settingsStyle(RuntimeViewerSettingsStyle())
    }
}

private struct SettingsView: SettingsContainer {
    var settingsBody: some SettingsContent {
        GeneralSettingsView()
        NotificationSettingsView()
        TransformerSettingsView()
        HelperServiceSettingsView()
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/SettingsViewModel.swift`:

```swift
import SwiftUI
import Observation

@Observable
final class SettingsViewModel {
    var backButtonVisible: Bool = false
    var scrolledToTop: Bool = false

    /// Holds a monitor closure for the `keyDown` event
    private var keyDownEventMonitor: Any?

    func setKeyDownMonitor(monitor: @escaping (NSEvent) -> NSEvent?) {
        keyDownEventMonitor = NSEvent.addLocalMonitorForEvents(matching: .keyDown, handler: monitor)
    }

    func removeKeyDownMonitor() {
        if let eventMonitor = keyDownEventMonitor {
            NSEvent.removeMonitor(eventMonitor)
            keyDownEventMonitor = nil
        }
    }

    deinit {
        removeKeyDownMonitor()
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerSettingsUI/SettingsWindowController.swift`:

```swift
import AppKit
import SwiftUI
import UIFoundation
import RuntimeViewerSettings

public final class SettingsWindow: NSWindow {}

public final class SettingsWindowController: XiblessWindowController<SettingsWindow> {
    public static let shared = SettingsWindowController()

    private lazy var settingsViewController = SettingsViewController()

    private init() {
        super.init(
            windowGenerator:
            SettingsWindow(
                contentRect: .init(
                    origin: .zero,
                    size: .zero
                ),
                styleMask: [.titled,
                            .miniaturizable,
                            .closable,
                            .resizable,
                            .fullSizeContentView],
                backing: .buffered,
                defer: false
            )
        )

        NSSplitViewItem.swizzle()
    }

    public override func windowDidLoad() {
        super.windowDidLoad()
        contentWindow.title = "Settings"
        contentWindow.titlebarAppearsTransparent = true
        contentWindow.collectionBehavior.insert(.fullScreenNone)
        contentWindow.center()
        contentWindow.setFrameAutosaveName(.init(describing: SettingsWindowController.self))
        settingsViewController.view.frame = .init(origin: .zero, size: contentWindow.frame.size)
        contentViewController = settingsViewController
    }
}

final class SettingsViewController: NSHostingController<SettingsRootView> {
    init() {
        super.init(rootView: .init())
    }

    @available(*, unavailable)
    @MainActor @preconcurrency dynamic required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

extension NSSplitViewItem {
    @objc fileprivate var canCollapseSwizzled: Bool {
        if let check = viewController.view.window?.isKind(of: SettingsWindow.self), check {
            return false
        }
        return self.canCollapseSwizzled
    }

    static func swizzle() {
        let origSelector = #selector(getter: NSSplitViewItem.canCollapse)
        let swizzledSelector = #selector(getter: canCollapseSwizzled)
        let originalMethodSet = class_getInstanceMethod(self as AnyClass, origSelector)
        let swizzledMethodSet = class_getInstanceMethod(self as AnyClass, swizzledSelector)

        method_exchangeImplementations(originalMethodSet!, swizzledMethodSet!)
    }
}

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/AreaSegmentedControl.swift`:

```swift
#if os(macOS)

import AppKit
import SnapKit

open class AreaSegmentedControl: Control {
    private struct SegmentItem {
        var image: NSImage?
        var alternateImage: NSImage?
        var label: String = ""
        var width: CGFloat = 0
        var tag: Int = 0
        var toolTip: String?
        var isSelected: Bool = false
        var isEnabled: Bool = true
        var menu: NSMenu?
    }

    private var segments: [SegmentItem] = []
    private var segmentButtons: [AreaSegmentButton] = []

    private let topDivider = Divider()
    private let bottomDivider = Divider()

    open var trackingMode: NSSegmentedControl.SwitchTracking = .selectOne

    open var segmentCount: Int {
        get { segments.count }
        set { resizeSegments(to: newValue) }
    }

    @objc open var indexOfSelectedItem: Int { selectedSegment }
    
    open var selectedSegment: Int {
        get { segments.firstIndex(where: { $0.isSelected }) ?? -1 }
        set {
            guard isValidIndex(newValue) else { return }
            if trackingMode == .selectOne {
                for i in 0 ..< segmentCount {
                    setSelected(i == newValue, forSegment: i)
                }
            } else {
                setSelected(true, forSegment: newValue)
            }
        }
    }
    
    open override var intrinsicContentSize: NSSize {
        return .init(width: NSView.noIntrinsicMetric, height: 27)
    }

    open override func setup() {
        super.setup()
        hierarchy {
            topDivider
            bottomDivider
        }
    }

    open override func layout() {
        super.layout()

        for btn in segmentButtons {
            if btn.superview == nil { addSubview(btn) }
        }

        
        let height = bounds.height
        let width = bounds.width
        let buttonSpacing: CGFloat = 20
        let defaultButtonWidth = height

        topDivider.frame = .init(x: 0, y: 0, width: width, height: 1)
        
        let totalButtonWidth: CGFloat = segmentButtons.enumerated().reduce(0) { partialResult, item in
            let (index, _) = item
            let segWidth = self.width(forSegment: index)
            let currentWidth = segWidth > 0 ? segWidth : defaultButtonWidth
            let spacing = index == segmentButtons.count - 1 ? 0 : buttonSpacing
            return partialResult + currentWidth + spacing
        }

        let startX = (width - totalButtonWidth) / 2
        var currentX = startX

        for (index, button) in segmentButtons.enumerated() {
            let segWidth = self.width(forSegment: index)
            let actualWidth = segWidth > 0 ? segWidth : defaultButtonWidth
            button.frame = CGRect(x: currentX, y: 0, width: actualWidth, height: height - 2)
            currentX += actualWidth + buttonSpacing
        }
        
        bottomDivider.frame = .init(x: 0, y: height - 1, width: width, height: 1)
    }

    open func setLabel(_ label: String, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].label = label
        segmentButtons[segment].title = label
    }

    open func label(forSegment segment: Int) -> String? {
        guard isValidIndex(segment) else { return nil }
        return segments[segment].label
    }

    open func setImage(_ image: NSImage?, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].image = image
        segmentButtons[segment].image = image
    }

    open func image(forSegment segment: Int) -> NSImage? {
        guard isValidIndex(segment) else { return nil }
        return segments[segment].image
    }

    open func setAlternateImage(_ image: NSImage?, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].alternateImage = image
        segmentButtons[segment].alternateImage = image
    }

    open func alternateImage(forSegment segment: Int) -> NSImage? {
        guard isValidIndex(segment) else { return nil }
        return segments[segment].alternateImage
    }

    open func setWidth(_ width: CGFloat, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].width = width
        needsLayout = true
    }

    open func width(forSegment segment: Int) -> CGFloat {
        guard isValidIndex(segment) else { return 0 }
        return segments[segment].width
    }

    open func setEnabled(_ enabled: Bool, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].isEnabled = enabled
        segmentButtons[segment].isEnabled = enabled
    }

    open func isEnabled(forSegment segment: Int) -> Bool {
        guard isValidIndex(segment) else { return false }
        return segments[segment].isEnabled
    }

    open func setSelected(_ selected: Bool, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].isSelected = selected
        segmentButtons[segment].state = selected ? .on : .off

        if trackingMode == .selectOne, selected {
            for i in 0 ..< segmentCount where i != segment {
                segments[i].isSelected = false
                segmentButtons[i].state = .off
            }
        }
    }

    open func isSelected(forSegment segment: Int) -> Bool {
        guard isValidIndex(segment) else { return false }
        return segments[segment].isSelected
    }

    open func setTag(_ tag: Int, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].tag = tag
    }

    open func tag(forSegment segment: Int) -> Int {
        guard isValidIndex(segment) else { return 0 }
        return segments[segment].tag
    }

    open func setToolTip(_ toolTip: String?, forSegment segment: Int) {
        guard isValidIndex(segment) else { return }
        segments[segment].toolTip = toolTip
        segmentButtons[segment].toolTip = toolTip
    }

    open func toolTip(forSegment segment: Int) -> String? {
        guard isValidIndex(segment) else { return nil }
        return segments[segment].toolTip
    }

    open func selectSegment(withTag tag: Int) -> Bool {
        if let index = segments.firstIndex(where: { $0.tag == tag }) {
            selectedSegment = index
            return true
        }
        return false
    }

    private func isValidIndex(_ index: Int) -> Bool {
        return index >= 0 && index < segments.count
    }

    private func resizeSegments(to newCount: Int) {
        let currentCount = segments.count
        if newCount > currentCount {
            for _ in currentCount ..< newCount {
                let newSegment = SegmentItem()
                segments.append(newSegment)
                let btn = AreaSegmentButton()
                btn.target = self
                btn.action = #selector(handleButtonClick(_:))
                segmentButtons.append(btn)
                addSubview(btn)
            }
        } else if newCount < currentCount {
            for _ in newCount ..< currentCount {
                segments.removeLast()
                let btn = segmentButtons.removeLast()
                btn.removeFromSuperview()
            }
        }
        needsLayout = true
    }

    @objc private func handleButtonClick(_ sender: AreaSegmentButton) {
        guard let index = segmentButtons.firstIndex(of: sender) else { return }
        let alreadySelected = isSelected(forSegment: index)

        switch trackingMode {
        case .selectOne:
            if !alreadySelected {
                selectedSegment = index
                sendAction(action, to: target)
            }
        case .selectAny:
            setSelected(!alreadySelected, forSegment: index)
            sendAction(action, to: target)
        case .momentary, .momentaryAccelerator:
            sendAction(action, to: target)
        @unknown default: break
        }
    }
}

final class AreaSegmentButton: Button {
    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        self.isBordered = false
        updateVisuals()
    }

    @available(*, unavailable)
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override var state: NSControl.StateValue {
        didSet { updateVisuals() }
    }

    override var alternateImage: NSImage? {
        didSet { updateVisuals() }
    }

    private func updateVisuals() {
        image = state == .on ? alternateImage : image
        contentTintColor = state == .on ? .controlAccentColor : .secondaryLabelColor
    }

    override func viewDidChangeEffectiveAppearance() {
        super.viewDidChangeEffectiveAppearance()
        updateVisuals()
    }
}


import AppKit
import FrameworkToolbox

public protocol SegmentedControl: NSControl, FrameworkToolboxCompatible, FrameworkToolboxDynamicMemberLookup, TargetActionProvider {
    var segmentCount: Int { get set }
    var selectedSegment: Int { get set }
    var trackingMode: NSSegmentedControl.SwitchTracking { get set }
    var indexOfSelectedItem: Int { get }
    
    
    func setLabel(_ label: String, forSegment segment: Int)
    func label(forSegment segment: Int) -> String?
    
    func setImage(_ image: NSImage?, forSegment segment: Int)
    func image(forSegment segment: Int) -> NSImage?
    
    func setAlternateImage(_ image: NSImage?, forSegment segment: Int)
    func alternateImage(forSegment segment: Int) -> NSImage?
    
    func setWidth(_ width: CGFloat, forSegment segment: Int)
    func width(forSegment segment: Int) -> CGFloat
    
    func setEnabled(_ enabled: Bool, forSegment segment: Int)
    func isEnabled(forSegment segment: Int) -> Bool
    
    func setSelected(_ selected: Bool, forSegment segment: Int)
    func isSelected(forSegment segment: Int) -> Bool
    
    func setToolTip(_ toolTip: String?, forSegment segment: Int)
    func toolTip(forSegment segment: Int) -> String?
    
    func setTag(_ tag: Int, forSegment segment: Int)
    func tag(forSegment segment: Int) -> Int
    
    func selectSegment(withTag tag: Int) -> Bool
}

extension NSSegmentedControl: SegmentedControl {
    public func setAlternateImage(_ image: NSImage?, forSegment segment: Int) {}
    
    public func alternateImage(forSegment segment: Int) -> NSImage? { return nil }
    
    public func selectSegment(withTag tag: Int) -> Bool {
        for i in 0..<segmentCount {
            if self.tag(forSegment: i) == tag {
                self.selectedSegment = i
                return true
            }
        }
        return false
    }
}

extension AreaSegmentedControl: SegmentedControl {}


#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/Extensions.swift`:

```swift
#if os(macOS)

import AppKit

extension NSPopUpButton {
    public var popUpButtonCell: NSPopUpButtonCell? {
        cell as? NSPopUpButtonCell
    }
}


#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/HUDView.swift`:

```swift
#if os(macOS)

import AppKit

open class HUDView: NSView {
    public struct Configuration: Hashable {
        public struct ShadowProperties: Hashable {
            public var opacity: Float
            public var radius: CGFloat
            public var offset: CGSize
            public var color: NSColor

            public init(opacity: Float, radius: CGFloat, offset: CGSize, color: NSColor) {
                self.opacity = opacity
                self.radius = radius
                self.offset = offset
                self.color = color
            }

            public func hash(into hasher: inout Hasher) {
                hasher.combine(opacity)
                hasher.combine(radius)
                hasher.combine(offset.width)
                hasher.combine(offset.height)
                hasher.combine(color.hashValue)
            }
        }

        public struct BackgroundProperties: Hashable {
            public var cornerRadius: CGFloat
            public var material: NSVisualEffectView.Material
            public var blendingMode: NSVisualEffectView.BlendingMode

            public init(
                cornerRadius: CGFloat = 20,
                material: NSVisualEffectView.Material = .hudWindow,
                blendingMode: NSVisualEffectView.BlendingMode = .withinWindow
            ) {
                self.material = material
                self.blendingMode = blendingMode
                self.cornerRadius = cornerRadius
            }
        }

        public struct TextProperties: Hashable {
            public var font: NSFont
            public var color: NSColor
            public var alignment: NSTextAlignment
            public var maximumNumberOfLines: Int

            public init(
                font: NSFont = .systemFont(ofSize: 14, weight: .medium),
                color: NSColor = .labelColor,
                alignment: NSTextAlignment = .center,
                maximumNumberOfLines: Int = 3
            ) {
                self.font = font
                self.color = color
                self.alignment = alignment
                self.maximumNumberOfLines = maximumNumberOfLines
            }
        }

        public struct ImageProperties: Hashable {
            public var tintColor: NSColor?
            public var preferredSymbolConfiguration: NSImage.SymbolConfiguration?

            public init(
                tintColor: NSColor? = nil,
                preferredSymbolConfiguration: NSImage.SymbolConfiguration? = nil
            ) {
                self.preferredSymbolConfiguration = preferredSymbolConfiguration
                self.tintColor = tintColor
            }
        }

        // MARK: - Properties

        public var title: String?
        public var image: NSImage?
        public var duration: TimeInterval

        public var windowSize: CGSize = .init(width: 160, height: 160)
        public var contentInsets: NSEdgeInsets = .init(top: 20, left: 12, bottom: 20, right: 12)
        public var spacing: CGFloat = 20

        public var textProperties: TextProperties
        public var imageProperties: ImageProperties
        public var shadowProperties: ShadowProperties?
        public var backgroundProperties: BackgroundProperties

        // MARK: - Initializer

        public init(
            title: String? = nil,
            image: NSImage? = nil,
            duration: TimeInterval = 1.0
        ) {
            self.title = title
            self.image = image
            self.duration = duration
            self.backgroundProperties = BackgroundProperties()
            self.textProperties = TextProperties()
            self.imageProperties = ImageProperties()
        }

        public static func standard() -> Configuration {
            return Configuration()
        }

        public static func success() -> Configuration {
            var config = Configuration()
            config.imageProperties.tintColor = .systemGreen
            config.imageProperties.preferredSymbolConfiguration = .init(pointSize: 40, weight: .semibold)
            return config
        }

        public static func error() -> Configuration {
            var config = Configuration()
            config.imageProperties.tintColor = .systemRed
            config.shadowProperties = ShadowProperties(
                opacity: 0.3,
                radius: 15,
                offset: CGSize(width: 0, height: -5),
                color: .black
            )
            return config
        }
    }

    public final var configuration: Configuration {
        didSet {
            if oldValue != configuration {
                setNeedsUpdateConfiguration()
            }
        }
    }

    public final var configurationUpdateHandler: ((HUDView) -> Void)?

    private lazy var backgroundEffectView: NSVisualEffectView = {
        let visualEffectView = NSVisualEffectView()
        visualEffectView.translatesAutoresizingMaskIntoConstraints = false
        visualEffectView.state = .active
        visualEffectView.wantsLayer = true
        visualEffectView.layer?.masksToBounds = true
        return visualEffectView
    }()

    private lazy var contentStackView: NSStackView = {
        let stackView = NSStackView()
        stackView.distribution = .fill
        stackView.orientation = .vertical
        stackView.alignment = .centerX
        stackView.translatesAutoresizingMaskIntoConstraints = false
        return stackView
    }()

    private lazy var imageView: NSImageView = {
        let imageView = NSImageView()
        imageView.translatesAutoresizingMaskIntoConstraints = false
        imageView.contentTintColor = .labelColor
        return imageView
    }()

    private lazy var label: NSTextField = {
        let label = NSTextField(wrappingLabelWithString: "")
        label.drawsBackground = false
        label.isBezeled = false
        label.isEditable = false
        label.isSelectable = false
        label.alignment = .center
        return label
    }()

    public init(configuration: Configuration) {
        self.configuration = configuration
        super.init(frame: .zero)
        commonInit()
    }

    public required init?(coder: NSCoder) {
        self.configuration = .standard()
        super.init(coder: coder)
        commonInit()
    }

    private func commonInit() {
        wantsLayer = true
        layerContentsRedrawPolicy = .onSetNeedsDisplay
        setupHierarchy()
        updateConfiguration()
    }

    open func setNeedsUpdateConfiguration() {
        updateConfiguration()
    }

    open func updateConfiguration() {
        configurationUpdateHandler?(self)

        let configuration = configuration

        backgroundEffectView.material = configuration.backgroundProperties.material
        backgroundEffectView.blendingMode = configuration.backgroundProperties.blendingMode
        backgroundEffectView.layer?.cornerRadius = configuration.backgroundProperties.cornerRadius

        if var image = configuration.image {
            if let preferredSymbolConfiguration = configuration.imageProperties.preferredSymbolConfiguration, let newImage = image.withSymbolConfiguration(preferredSymbolConfiguration) {
                image = newImage
            }
            imageView.image = image
            imageView.contentTintColor = configuration.imageProperties.tintColor
            if imageView.superview == nil {
                contentStackView.insertArrangedSubview(imageView, at: 0)
            }
        } else {
            imageView.removeFromSuperview()
        }

        if let title = configuration.title {
            label.stringValue = title
            label.font = configuration.textProperties.font
            label.textColor = configuration.textProperties.color
            label.alignment = configuration.textProperties.alignment
            label.maximumNumberOfLines = configuration.textProperties.maximumNumberOfLines
            if label.superview == nil {
                contentStackView.addArrangedSubview(label)
            }
        } else {
            label.removeFromSuperview()
        }

        contentStackView.spacing = configuration.spacing
        contentStackView.edgeInsets = configuration.contentInsets

        needsDisplay = true
    }

    public override final var wantsUpdateLayer: Bool { true }

    public override final func updateLayer() {
        guard let layer = layer else { return }
        let backgroundProperties = configuration.backgroundProperties
        let shadowProperties = configuration.shadowProperties
        if let shadow = shadowProperties {
            layer.shadowColor = shadow.color.cgColor
            layer.shadowOpacity = shadow.opacity
            layer.shadowRadius = shadow.radius
            layer.shadowOffset = shadow.offset
            let path = CGPath(
                roundedRect: CGRect(origin: .zero, size: configuration.windowSize),
                cornerWidth: backgroundProperties.cornerRadius,
                cornerHeight: backgroundProperties.cornerRadius,
                transform: nil
            )
            layer.shadowPath = path
        } else {
            layer.shadowOpacity = 0
            layer.shadowPath = nil
        }
    }

    private func setupHierarchy() {
        addSubview(backgroundEffectView)
        backgroundEffectView.addSubview(contentStackView)

        NSLayoutConstraint.activate([
            backgroundEffectView.leadingAnchor.constraint(equalTo: leadingAnchor),
            backgroundEffectView.trailingAnchor.constraint(equalTo: trailingAnchor),
            backgroundEffectView.topAnchor.constraint(equalTo: topAnchor),
            backgroundEffectView.bottomAnchor.constraint(equalTo: bottomAnchor),

            contentStackView.centerXAnchor.constraint(equalTo: backgroundEffectView.centerXAnchor),
            contentStackView.centerYAnchor.constraint(equalTo: backgroundEffectView.centerYAnchor),
            contentStackView.widthAnchor.constraint(lessThanOrEqualTo: backgroundEffectView.widthAnchor),
            contentStackView.heightAnchor.constraint(lessThanOrEqualTo: backgroundEffectView.heightAnchor),
        ])
    }

    fileprivate func animateIn() async {
        alphaValue = 0
        return await withCheckedContinuation { continuation in
            NSAnimationContext.runAnimationGroup { context in
                context.duration = 0.2
                context.timingFunction = CAMediaTimingFunction(name: .easeOut)
                self.animator().alphaValue = 1.0
            } completionHandler: {
                continuation.resume()
            }
        }
    }

    fileprivate func animateOut() async {
        return await withCheckedContinuation { continuation in
            NSAnimationContext.runAnimationGroup { context in
                context.duration = 0.25
                context.timingFunction = CAMediaTimingFunction(name: .easeIn)
                self.animator().alphaValue = 0.0
            } completionHandler: {
                continuation.resume()
            }
        }
    }
}

extension NSWindow {
    public func showHUD(with configuration: HUDView.Configuration) {
        Task { @MainActor in
            self.contentView?.subviews
                .compactMap { $0 as? HUDView }
                .forEach { $0.removeFromSuperview() }

            guard let contentView = self.contentView else { return }

            let hud = HUDView(configuration: configuration)
            contentView.addSubview(hud)

            hud.translatesAutoresizingMaskIntoConstraints = false
            NSLayoutConstraint.activate([
                hud.centerXAnchor.constraint(equalTo: contentView.centerXAnchor),
                hud.centerYAnchor.constraint(equalTo: contentView.centerYAnchor),
                hud.widthAnchor.constraint(equalToConstant: configuration.windowSize.width),
                hud.heightAnchor.constraint(equalToConstant: configuration.windowSize.height),
            ])

            await hud.animateIn()

            try? await Task.sleep(nanoseconds: UInt64(configuration.duration * 1_000_000_000))

            guard hud.superview != nil else { return }

            await hud.animateOut()

            hud.removeFromSuperview()
        }
    }

    public func showHUD(text: String, image: NSImage? = nil) {
        var config = HUDView.Configuration.standard()
        config.title = text
        config.image = image
        showHUD(with: config)
    }
}

// extension NSEdgeInsets: @retroactive Hashable {
//    public func hash(into hasher: inout Hasher) {
//        hasher.combine(top)
//        hasher.combine(left)
//        hasher.combine(right)
//        hasher.combine(bottom)
//    }
//
//    public static func == (lhs: Self, rhs: Self) -> Bool {
//        return lhs.top == rhs.top && lhs.left == rhs.left && lhs.right == rhs.right && lhs.bottom == rhs.bottom
//    }
// }

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/ItemPopUpButton.swift`:

```swift
#if os(macOS)

import AppKit
import SFSymbols
import UIFoundationToolbox

public final class ItemPopUpButton<Item: CaseIterable & CustomStringConvertible & RawRepresentable>: NSPopUpButton where Item.RawValue == Int {
    public var onItem: Item? {
        didSet {
            guard let onItem else { return }
            item(withTitle: onItem.description)?.do {
                $0.state = .on
            }
        }
    }
    
    public var icon: NSImage?
    
    public var stateChanged: ((Item?) -> Void)?

    public func setup() {
        pullsDown = true
        preferredEdge = .minY
        isBordered = false
        popUpButtonCell?.arrowPosition = .noArrow
        addItem(withTitle: "")
        item(at: 0)?.do {
            $0.image = icon
        }

        for item in Item.allCases {
            addItem(withTitle: item.description)
        }

        box.action { [weak self] button in
            guard let self else { return }
            button.itemArray.filter { $0 !== button.selectedItem }.forEach { $0.state = .off }
            button.selectedItem?.state = button.selectedItem?.state == .on ? .off : .on
            if button.selectedItem?.state == .on {
                stateChanged?(Item(rawValue: button.indexOfSelectedItem - 1))
            } else {
                stateChanged?(nil)
            }
        }
    }
}


#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/MinimapView.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit

// MARK: -

// MARK: Minimap view for macOS

/// Customised text view for the minimap.
///
class MinimapView: NSTextView {
    // Highlight the current line.
    //
    override func drawBackground(in rect: NSRect) {
        let rectWithinBounds = rect.intersection(bounds)
        super.drawBackground(in: rectWithinBounds)

        guard let textLayoutManager = textLayoutManager,
              let textContentStorage = textContentStorage
        else { return }

        let viewportRange = textLayoutManager.textViewportLayoutController.viewportRange

        // If the selection is an insertion point, highlight the corresponding line
        if let location = insertionPoint,
           let textLocation = textContentStorage.textLocation(for: location) {
            if viewportRange == nil
                || viewportRange!.contains(textLocation)
                || viewportRange!.endLocation.compare(textLocation) == .orderedSame {
                drawBackgroundHighlight(
                    within: rectWithinBounds,
                    forLineContaining: textLocation,
                    withColour: .textBackgroundColor
                )
            }
        }
    }
}

extension NSFont {
    /// The constant adavance for a (horizontal) monospace font.
    ///
    var maximumHorizontalAdvancement: CGFloat { maximumAdvancement.width }

    /// The line height (which is an exting property on `UIFont`).
    ///
    var lineHeight: CGFloat { ceil(ascender - descender - leading) }
}

// MARK: -

// MARK: Minimap layout functionality

class MinimapLineFragment: NSTextLineFragment {
    /// Text line fragment that we base our derived fragment on.
    ///
    /// `NSTextLineFragment` is a class cluster; hence, we need to embded a fragment generated by TextKit for us to get
    /// at its properties.
    ///
    private let textLineFragment: NSTextLineFragment

    /// All rendering attribute runs applying to this line.
    ///
    private let attributes: [MinimapLayoutFragment.AttributeRun]

    /// The advacement per glyph (for a monospaced font).
    ///
    private let advancement: CGFloat

    init(_ textLineFragment: NSTextLineFragment, attributes: [MinimapLayoutFragment.AttributeRun]) {
        self.textLineFragment = textLineFragment
        self.attributes = attributes

        let attributedString = textLineFragment.attributedString,
            range = textLineFragment.characterRange

        // Determine the advancement per glyph (assuming a monospaced font), scaling it down for the minimap.
        let font = if range.length > 0,
                      let font = attributedString.attribute(.font, at: range.location, effectiveRange: nil) as? NSFont { font }
        else { NSFont.monospacedSystemFont(ofSize: NSFont.systemFontSize, weight: .regular) }
        self.advancement = font.maximumHorizontalAdvancement / minimapRatio

        super.init(attributedString: attributedString, range: range)
    }

    @available(*, unavailable)
    required init?(coder aDecoder: NSCoder) { fatalError("init(coder:) has not been implemented") }

    override var glyphOrigin: CGPoint { CGPoint(
        x: textLineFragment.glyphOrigin.x / minimapRatio,
        y: textLineFragment.glyphOrigin.y / minimapRatio
    ) }

    override var typographicBounds: CGRect {
        CGRect(
            x: textLineFragment.typographicBounds.minX / minimapRatio,
            y: textLineFragment.typographicBounds.minY / minimapRatio,
            width: textLineFragment.typographicBounds.width / minimapRatio,
            height: textLineFragment.typographicBounds.height / minimapRatio
        )
    }

    override func characterIndex(for point: CGPoint) -> Int {
        textLineFragment.characterIndex(for: CGPoint(x: point.x * minimapRatio, y: point.y * minimapRatio))
    }

    override func fractionOfDistanceThroughGlyph(for point: CGPoint) -> CGFloat {
        textLineFragment.fractionOfDistanceThroughGlyph(for: point)
    }

    override func locationForCharacter(at index: Int) -> CGPoint {
        let point = textLineFragment.locationForCharacter(at: index)
        return CGPoint(x: point.x / minimapRatio, y: point.y / minimapRatio)
    }

    // Draw boxes using a character's foreground colour instead of actual glyphs.
    override func draw(at point: CGPoint, in context: CGContext) {
        // Leave some space between glyph boxes on adjacent lines
        let gap = typographicBounds.height * 0.3

        for attribute in attributes {
            let attributeRect = CGRect(
                x: floor(point.x + advancement * CGFloat(attribute.range.location)),
                y: floor(point.y + gap / 2),
                width: floor(advancement * CGFloat(attribute.range.length)),
                height: typographicBounds.height - gap
            )
            if let colour = attribute.attributes[.foregroundColor] as? NSColor {
                colour.withAlphaComponent(0.50).setFill()
            }
            NSBezierPath(rect: attributeRect).fill()
        }
    }
}

/// Minimap layout fragments replaces all line fragments by a our own variant of minimap line fragments, which draw
/// coloured boxes instead of actual glyphs.
///
class MinimapLayoutFragment: NSTextLayoutFragment {
    private var _textLineFragments: [NSTextLineFragment] = []

    private var observation: NSKeyValueObservation?

    override var layoutFragmentFrame: CGRect {
        CGRect(
            x: super.layoutFragmentFrame.minX,
            y: super.layoutFragmentFrame.minY,
            width: super.layoutFragmentFrame.width / minimapRatio,
            height: super.layoutFragmentFrame.height / minimapRatio
        )
    }

    // NB: We don't override `renderingSurfaceBounds` as that is calculated on the basis of `layoutFragmentFrame`.

    @objc override dynamic var textLineFragments: [NSTextLineFragment] {
        return _textLineFragments
    }

    override init(textElement: NSTextElement, range rangeInElement: NSTextRange?) {
        super.init(textElement: textElement, range: rangeInElement)
        self.observation = super.observe(\.textLineFragments, options: [.new]) { [weak self] _, _ in

            // NB: We cannot use `change.newValue` as this seems to pull the value from the subclass property (which we
            //     want to update here). Instead, we need to directly access `super`. This is, however as per Swift 5.9
            //     not possible in a closure weakly capturing `self` (which we need to do here to avoid a retain cycle).
            //     Hence, we defer to an auxilliary method.
            self?.updateTextLineFragments()
        }
    }

    typealias AttributeRun = (attributes: [NSAttributedString.Key: Any], range: NSRange)

    // We don't draw white space and control characters
    private let invisibleCharacterers = CharacterSet.whitespacesAndNewlines.union(CharacterSet.controlCharacters)
    private lazy var invertedInvisibleCharacters = invisibleCharacterers.inverted

    /// Update the text line fragments from the corresponding property of `super`.
    ///
    private func updateTextLineFragments() {
        if let textLayoutManager = textLayoutManager {
            var location = rangeInElement.location
            _textLineFragments = []
            for fragment in super.textLineFragments {
                guard let string = (fragment.attributedString.string[fragment.characterRange].flatMap { String($0) })
                else { break }

                let attributeRuns
                    = if let endLocation = textLayoutManager.location(location, offsetBy: fragment.characterRange.length),
                    let textRange = NSTextRange(location: location, end: endLocation) {
                    textLayoutManager.renderingAttributes(in: textRange).map { attributeRun in
                        (
                            attributes: attributeRun.attributes,
                            range: NSRange(
                                location: textLayoutManager.offset(from: location, to: attributeRun.textRange.location),
                                length: textLayoutManager.offset(from: attributeRun.textRange.location, to: attributeRun.textRange.endLocation)
                            )
                        )
                    }
                } else { [AttributeRun]() }

                var attributeRunsWithoutWhitespace: [AttributeRun] = []
                for (attributes, range) in attributeRuns {
                    if attributes[.hideInvisibles] == nil {
                        attributeRunsWithoutWhitespace.append((attributes: attributes, range: range))
                    } else {
                        var remainingRange = range
                        while remainingRange.length > 0,
                              let match = string.rangeOfCharacter(from: invisibleCharacterers, range: remainingRange.range(in: string)) {
                            let lower = match.lowerBound.utf16Offset(in: string),
                                upper = min(match.upperBound.utf16Offset(in: string), remainingRange.max)

                            // If we have got a prefix with visible characters, emit an attribute run covering those.
                            if lower > remainingRange.location {
                                attributeRunsWithoutWhitespace.append((
                                    attributes: attributes,
                                    range: NSRange(
                                        location: remainingRange.location,
                                        length: lower - remainingRange.location
                                    )
                                ))
                            }

                            // Advance the remaining range to after the character found in `match`.
                            remainingRange = NSRange(
                                location: upper,
                                length: remainingRange.length - (upper - remainingRange.location)
                            )

                            if let nextVisibleCharacter = string.rangeOfCharacter(
                                from: invertedInvisibleCharacters,
                                range: remainingRange.range(in: string)
                            ) {
                                // If there is another visible character, the new remaining range starts with that character.
                                let lower = nextVisibleCharacter.lowerBound.utf16Offset(in: string)
                                remainingRange = NSRange(
                                    location: lower,
                                    length: remainingRange.length - (lower - remainingRange.location)
                                )

                            } else { // If there are no more visible characters, we are done.
                                remainingRange.length = 0
                            }
                        }
                    }
                }
                _textLineFragments.append(MinimapLineFragment(fragment, attributes: attributeRunsWithoutWhitespace))
                location = textLayoutManager.location(location, offsetBy: fragment.characterRange.length) ?? location
            }
        }
    }

    @available(*, unavailable)
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

class MinimapTextLayoutManagerDelegate: NSObject, NSTextLayoutManagerDelegate {
    // We create instances of our own flavour of layout fragments
    func textLayoutManager(_ textLayoutManager: NSTextLayoutManager,
                           textLayoutFragmentFor location: NSTextLocation,
                           in textElement: NSTextElement)
        -> NSTextLayoutFragment {
        guard let paragraph = textElement as? NSTextParagraph
        else { return NSTextLayoutFragment(textElement: textElement, range: nil) }

        return MinimapLayoutFragment(textElement: paragraph, range: nil)
    }
}

let minimapRatio = CGFloat(8)

extension NSAttributedString.Key {
    /// Attribute to indicate that an attribute run has the default styling and not a token-specific styling.
    ///
    static let hideInvisibles: NSAttributedString.Key = .init("hideInvisibles")
}

extension NSTextView {
    typealias Color = NSColor
    typealias Font = NSFont

    var optTextLayoutManager: NSTextLayoutManager? { textLayoutManager }
    var optTextContainer: NSTextContainer? { textContainer }
    var optTextContentStorage: NSTextContentStorage? { textContentStorage }

    var textBackgroundColor: Color? { backgroundColor }
    var textFont: Font? { font }
    var textContainerOrigin: CGPoint { return CGPoint(x: textContainerInset.width, y: textContainerInset.height) }

    var text: String! {
        get { string }
        set { string = newValue }
    }

    var insertionPoint: Int? {
        if let selection = selectedRanges.first as? NSRange, selection.length == 0 { return selection.location }
        else { return nil }
    }

    var documentVisibleRect: CGRect { enclosingScrollView?.documentVisibleRect ?? bounds }

    var contentSize: CGSize { bounds.size }

    func drawBackgroundHighlight(within rect: CGRect,
                                 forLineContaining textLocation: NSTextLocation,
                                 withColour colour: NSColor) {
        guard let textLayoutManager = optTextLayoutManager else { return }

        colour.setFill()
        if let fragmentFrame = textLayoutManager.textLayoutFragment(for: textLocation)?.layoutFragmentFrameWithoutExtraLineFragment,
           let highlightRect = lineBackgroundRect(y: fragmentFrame.minY, height: fragmentFrame.height) {
            let clippedRect = highlightRect.intersection(rect)
            if !clippedRect.isNull { NSBezierPath(rect: clippedRect).fill() }

        } else
        if let previousLocation = optTextContentStorage?.location(textLocation, offsetBy: -1),
           let fragmentFrame = textLayoutManager.textLayoutFragment(for: previousLocation)?.layoutFragmentFrameExtraLineFragment,
           let highlightRect = lineBackgroundRect(y: fragmentFrame.minY, height: fragmentFrame.height) {
            let clippedRect = highlightRect.intersection(rect)
            if !clippedRect.isNull { NSBezierPath(rect: clippedRect).fill() }
        }
    }

    func lineBackgroundRect(y: CGFloat, height: CGFloat) -> CGRect? {
        // We start at x = 0 as it looks nicer in case we overscoll when horizontal scrolling is enabled (i.e., when lines
        // are not wrapped).
        return CGRect(x: 0, y: y, width: bounds.size.width, height: height)
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/NSTextContentStorage+.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit

extension NSTextContentStorage {
    /// Convert a text location to a character location within this text content storage.
    ///
    /// - Parameter textLocation: The text location to convert.
    /// - Returns: The corresponding character position in the underlying text storage.
    ///
    func location(for textLocation: NSTextLocation) -> Int {
        offset(from: documentRange.location, to: textLocation)
    }

    /// Convert a character location into a text location within this text content storage.
    ///
    /// - Parameter location: The character location to convert.
    /// - Returns: The corresponding text location.
    ///
    func textLocation(for location: Int) -> NSTextLocation? {
        self.location(documentRange.location, offsetBy: location)
    }

    /// Convert a text range to a character range within this text content storage.
    ///
    /// - Parameter textRange: The text range to convert.
    /// - Returns: The corresponding character range in the underlying text storage.
    ///
    func range(for textRange: NSTextRange) -> NSRange {
        NSRange(
            location: offset(from: documentRange.location, to: textRange.location),
            length: offset(from: textRange.location, to: textRange.endLocation)
        )
    }

    /// Convert a character range to a text range within this text content storage.
    ///
    /// - Parameter range: The character range to convert.
    /// - Returns: The corresponding text range in the underlying text storage if there exists a corresponding valid text
    ///     range.
    ///
    func textRange(for range: NSRange) -> NSTextRange? {
        // NB: `NSTextRange(location:end:)` crashes if `end` is before `start` (instead of returning `nil`).
        guard range.length >= 0 else { return nil }

        if let start = location(documentRange.location, offsetBy: range.location),
           let end = location(start, offsetBy: range.length) {
            return NSTextRange(location: start, end: end)
        } else { return nil }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/NSTextLayoutManager+.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit

// MARK: -

// MARK: 'NSTextLayoutFragment' extras

extension NSTextLayoutFragment {
    /// Yield the layout fragment's frame, but without the height of an extra line fragment if present.
    ///
    var layoutFragmentFrameWithoutExtraLineFragment: CGRect {
        var frame = layoutFragmentFrame

        // If this layout fragment's last line fragment is for an empty string, then it is an extra line fragment and we
        // deduct its height from the layout fragment's height.
        if let lastTextLineFragment = textLineFragments.last, lastTextLineFragment.characterRange.length == 0 {
            frame.size.height -= lastTextLineFragment.typographicBounds.height
        }
        return frame
    }

    /// This is a temporary kludge to fix the height of the extra line fragment in case the size of the font used in the
    /// rest of the layout fragment varies from the standard font size. In TextKit 2, it is far from clear how to
    /// indicate the metrics to be used in a nicer manner. (Just setting the default font of the text view doesn't seem
    /// to work.)
    ///
    /// The solution here only works if there is at least one other line fragment (but that's always the case if the
    /// displayed string is now empty) and we use them same font height everywhere (which is the case for a code view).
    /// We simply use height of another line fragement for that of the extra line fragment and adjust the overall frame
    /// accordingly.
    ///
    var layoutFragmentFrameAdjustedKludge: CGRect {
        var frame = layoutFragmentFrame

        // If this layout fragment's last line fragment is for an empty string, then it is an extra line fragment and we
        // deduct its height from the layout fragment's height.
        if let firstTextLineFragment = textLineFragments.first,
           let lastTextLineFragment = textLineFragments.last,
           lastTextLineFragment.characterRange.length == 0 {
            frame.size.height -= lastTextLineFragment.typographicBounds.height
            frame.size.height += firstTextLineFragment.typographicBounds.height
        }
        return frame
    }

    /// Yield the frame of the layout fragment's extra line fragment if present (which is the case if this the last
    /// line fragment and it is terminated by a newline character).
    ///
    var layoutFragmentFrameExtraLineFragment: CGRect? {
        // If this layout fragment's last line fragment is for an empty string, then it is an extra line fragment and
        // return its bounds.
        if let lastTextLineFragment = textLineFragments.last, lastTextLineFragment.characterRange.length == 0 {
            let height = lastTextLineFragment.typographicBounds.height
            return CGRect(
                x: layoutFragmentFrame.minX,
                y: layoutFragmentFrame.maxY - height,
                width: layoutFragmentFrame.width,
                height: height
            )
        } else {
            return nil
        }
    }
}

// MARK: -

// MARK: 'NSTextLayoutManager' extras

extension NSTextLayoutManager {
    /// Yield the height of the entire set of text fragments covering the given text range.
    ///
    /// - Parameter textRange: The text range for which we want to compute the height of the text fragments.
    /// - Returns: The height of the text fragments.
    ///
    /// If there are gaps, they are included. If the range reaches until the end of the text and there is extra line
    /// fragment, then it is included, too.
    ///
    func textLayoutFragmentExtent(for textRange: NSTextRange) -> (y: CGFloat, height: CGFloat)? {
        let location = textRange.location

        if location.compare(documentRange.endLocation) == .orderedSame { // Start of range == end of the document
            if let lastLocation = textContentManager?.location(textRange.endLocation, offsetBy: -1),
               let lastTextLayoutFragment = textLayoutFragment(for: lastLocation),
               let lastTextLineFragment = lastTextLayoutFragment.textLineFragments.last,
               lastTextLineFragment.characterRange.length == 0 { // trailing newline at the end of the document
                // Extra line fragement
                let typographicBounds = lastTextLineFragment.typographicBounds
                return (
                    y: lastTextLayoutFragment.layoutFragmentFrame.minY + typographicBounds.minY,
                    height: typographicBounds.height
                )

            } else { // no trailing newline at the end of the document
                if let endLocation = textContentManager?.location(textRange.endLocation, offsetBy: -1),
                   let endFrame = textLayoutFragment(for: endLocation)?.layoutFragmentFrame {
                    return (y: endFrame.minY, height: endFrame.height)

                } else { return nil }
            }

        } else {
            let endLocation = if textRange.isEmpty { nil as NSTextLocation? }
            else { textContentManager?.location(textRange.endLocation, offsetBy: -1) },
                startFragment = textLayoutFragment(for: location),
                startFrame = startFragment?.layoutFragmentFrame,
                endFragment = if let endLocation { textLayoutFragment(for: endLocation) }
            else { nil as NSTextLayoutFragment? },
                endFrame = endFragment?.layoutFragmentFrameAdjustedKludge

            switch (startFrame, endFrame) {
            case (nil, nil): return nil
            case (.some(let startFrame), nil): return (y: startFrame.minY, height: startFrame.height)
            case (nil, let .some(endFrame)): return (y: endFrame.minY, height: endFrame.height)
            case let (.some(startFrame), .some(endFrame)):
                if startFrame.minY < endFrame.minY {
                    return (y: startFrame.minY, height: endFrame.maxY - startFrame.minY)
                } else {
                    return (y: endFrame.minY, height: startFrame.maxY - endFrame.minY)
                }
            }
        }
    }

    /// Enumerate all the text layout fragments that lie (partly) in the given range.
    ///
    /// - Parameters:
    ///   - range: The range for which we want to enumerate the text layout fragments.
    ///   - options: Enumeration options.
    ///   - block: The block to invoke on each eumerated text layout fragment.
    /// - Returns: See `NSTextLayoutFragment.enumerateTextLayoutFragments(from:options:using:)`.
    ///
    @discardableResult
    func enumerateTextLayoutFragments(in textRange: NSTextRange,
                                      options: NSTextLayoutFragment.EnumerationOptions = [],
                                      using block: (NSTextLayoutFragment) -> Bool)
        -> NSTextLocation? {
        // FIXME: This doesn't work if the options include `.reverse`.
        enumerateTextLayoutFragments(from: textRange.location, options: options) { textLayoutFragment in
            textLayoutFragment.rangeInElement.location.compare(textRange.endLocation) == .orderedAscending
                && block(textLayoutFragment)
        }
    }

    /// Compute the smallest rect that encompasses all text layout fragments that (partly) lie in the given range.
    ///
    /// - Parameter textRange: The range for which we want to compute the bounding box.
    /// - Returns: The bounding box.
    ///
    func textLayoutFragmentBoundingRect(for textRange: NSTextRange) -> CGRect {
        var boundingBox: CGRect = .null
        enumerateTextLayoutFragments(in: textRange, options: [.ensuresExtraLineFragment]) { textLayoutFragment in
            boundingBox = boundingBox.union(textLayoutFragment.layoutFragmentFrame)
            return true
        }
        return boundingBox
    }

    /// Determine the bounding rect of the first text segment of a given text range.
    ///
    /// - Parameter textRange: The text range for which we want to determine the first segment.
    /// - Returns: The bounding rect of the first text segment if any.
    ///
    func boundingRectOfFirstTextSegment(for textRange: NSTextRange) -> CGRect? {
        var result: CGRect?
        enumerateTextSegments(in: textRange, type: .standard, options: .rangeNotRequired) { _, rect, _, _ in
            result = rect
            return false
        }
        return result
    }

    /// Enumerates the rendering attributes within a given range.
    ///
    /// - Parameters:
    ///   - textRange: The text range whose rendering attributes are to be enumerated.
    ///   - reverse: Whether to enumerate in reverse; i.e., right-to-left.
    ///   - block: A closure invoked for each attribute run within the range.
    ///
    func enumerateRenderingAttributes(in textRange: NSTextRange,
                                      reverse: Bool,
                                      using block: (NSTextLayoutManager, [NSAttributedString.Key: Any], NSTextRange) -> Void) {
        if !reverse {
            enumerateRenderingAttributes(from: textRange.location, reverse: false) { textLayoutManager, attributes, attributeRange in

                if let clippedRange = attributeRange.intersection(textRange) {
                    block(textLayoutManager, attributes, clippedRange)
                }
                return attributeRange.endLocation.compare(textRange.endLocation) == .orderedAscending
            }

        } else {
            enumerateRenderingAttributes(from: textRange.endLocation, reverse: true) { textLayoutManager, attributes, attributeRange in

                if let clippedRange = attributeRange.intersection(textRange) {
                    block(textLayoutManager, attributes, clippedRange)
                }
                return attributeRange.location.compare(textRange.location) == .orderedDescending
            }
        }
    }

    /// A set of string attributes together with a text range to which they apply.
    ///
    typealias AttributeRun = (attributes: [NSAttributedString.Key: Any], textRange: NSTextRange)

    /// Collect all rendering attributes and their character ranges within a given text range.
    ///
    /// - Parameter textRange: The text range in which we want to collect rendering attributes.
    /// - Returns: An array of pairs and associated range for all rendering attributes within the given text range.
    ///
    func renderingAttributes(in textRange: NSTextRange) -> [AttributeRun] {
        var attributes: [(attributes: [NSAttributedString.Key: Any], textRange: NSTextRange)] = []
        enumerateRenderingAttributes(in: textRange, reverse: false) { attributes.append((attributes: $1, textRange: $2)) }
        return attributes
    }
}

// MARK: -

// MARK: 'NSTextLayoutManager' workaround

// There appears to be a bug in the implementation of 'NSTextLayoutManager' on at least macOS 14. Specifically, during
// processing of an edit operation, a closure stored in `renderingAttributesValidator` gets called before the layout
// manager has updated its data structures to text locations *after* the edit. As a result, calls to
// `setRenderingAttributes(_:for:)` (and related methods) will set rendering attributes in the vicinity of the edit
// location for shifted character ranges (if the edit operation changes the length of the text).
//
// It turns out that we can work around this issue by delaying the calls to `setRenderingAttributes(_:for:)` until after
// `NSTextContentManager.hasEditingTransaction` is `false`. We achieve this by using KVO to observe
// `hasEditingTransaction`, in order to trigger attribute setting after the editing transaction has completed.
//
// Unfortunately, the fix involving `NSTextContentManager.hasEditingTransaction`, on its own, is not sufficient, as
// `hasEditingTransaction` is not being used in case of a a paste command or in case of an undo/redo. In these cases,
// we wait until the `CodeViewDelegate` receives a `textDidChange` notification to trigger setting the attributes.

extension NSTextLayoutManager {
    private final class PendingTextLayoutFragments {
        var fragments: [NSTextLayoutFragment] = []
    }

    /// Notifies the layout manager that the rendering attributes in the given range need to be validated and redisplayed.
    ///
    /// - Parameter for: The range whose attributes need to be validated and redeisplayed.
    ///
    /// NB: This may be a large range. In this case, the work should be cut up to avoid unresponsiveness.
    ///
    func redisplayRenderingAttributes(for textRange: NSTextRange) {
        enumerateTextLayoutFragments(in: textRange) { textLayoutFragment in

            // We spawn a task per layout fragment to cut up the work.
            Task { @MainActor in // The non-sendable warnings are bogus as this goes to the `MainActor`.
                renderingAttributesValidator?(self, textLayoutFragment)
            }
            return true
        }

        // FIXME: Ensure that all the tasks with `renderingAttributesValidator` have complete before running the following.
        // FIXME: Well actually, only those within the viewport, for better responsiveness!
        _ = if let viewportRange = textViewportLayoutController.viewportRange
        { textRange.intersection(viewportRange) ?? textRange } else { textRange }
        // NB: Setting rendering attributes does not trigger redrawing of the affected area. We need to do that explicitly.
        Task { @MainActor in // The non-sendable warnings are bogus as this goes to the `MainActor`.
//            if let textContentStorage = textContentManager as? NSTextContentStorage,
//               let textStorage = textContentStorage.textStorage {
            // This seems the most reliable way to force a redraw of the affected (visible) area.
//                let range = textContentStorage.range(for: visibleTextRange)

            // FIXME: This code has been disabled, because it interferes with the setting of the `selectedRanges` (specifically, the
            // FIXME: insertion point) from macOS 15.1 (maybe already 15.0) onwards â€” see Issue #114.
//        textContentStorage.processEditing(for: textStorage,
//                                          edited: .editedAttributes,
//                                          range: range,
//                                          changeInLength: 0,
//                                          invalidatedRange: range)
//            }
        }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/NSView+Skeleton.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit

extension NSView {
    public struct SkeletonConfiguration {
        public enum Direction {
            case leftToRight
            case rightToLeft
        }

        public enum Style {
            case full
            case code
        }

        public var style: Style
        public var baseColor: NSColor
        public var highlightColor: NSColor
        public var lineHeight: CGFloat
        public var lineSpacing: CGFloat
        public var cornerRadius: CGFloat
        public var direction: Direction
        public var animationDuration: TimeInterval
        public var angle: CGFloat
        public var contentInsets: NSSize

        public static let `default` = SkeletonConfiguration(
            style: .full,
            baseColor: NSColor.textColor.withAlphaComponent(0.08),
            highlightColor: NSColor.white.withAlphaComponent(0.3),
            lineHeight: 14.0,
            lineSpacing: 8.0,
            cornerRadius: 4.0,
            direction: .leftToRight,
            animationDuration: 1.8,
            angle: 20.0
        )

        public static let codeEditor = SkeletonConfiguration(
            style: .code,
            baseColor: NSColor.textColor.withAlphaComponent(0.08),
            highlightColor: NSColor.white.withAlphaComponent(0.25),
            lineHeight: 15.0,
            lineSpacing: 6.0,
            cornerRadius: 2.0,
            direction: .leftToRight,
            animationDuration: 1.8,
            angle: 20.0
        )

        public init(
            style: Style = .full,
            baseColor: NSColor? = nil,
            highlightColor: NSColor? = nil,
            lineHeight: CGFloat = 14.0,
            lineSpacing: CGFloat = 8.0,
            cornerRadius: CGFloat = 4.0,
            direction: Direction = .leftToRight,
            animationDuration: TimeInterval = 1.5,
            angle: CGFloat = 20.0,
            contentInsets: NSSize = .init(width: 5, height: 5)
        ) {
            self.style = style
            self.baseColor = baseColor ?? NSColor.textColor.withAlphaComponent(0.08)
            self.highlightColor = highlightColor ?? NSColor.textColor.withAlphaComponent(0.3)
            self.lineHeight = lineHeight
            self.lineSpacing = lineSpacing
            self.cornerRadius = cornerRadius
            self.direction = direction
            self.animationDuration = animationDuration
            self.angle = angle
            self.contentInsets = contentInsets
        }
    }

    private final class SkeletonOverlayView: NSView {
        private final class Layer: CALayer {}

        private final class ShapeLayer: CAShapeLayer {}

        private final class GradientLayer: CAGradientLayer {}

        var configuration: SkeletonConfiguration

        // 1. å®¹å™¨å±‚ï¼šç”¨æ¥æ‰¿è½½æ‰€æœ‰å†…å®¹ï¼Œå¹¶è¢« mask è£å‰ªå‡ºæ–‡å­—å½¢çŠ¶
        private let containerLayer = Layer()

        // 2. é®ç½©å±‚ï¼šç»˜åˆ¶åœ†è§’çŸ©å½¢ï¼ˆæ–‡å­—å½¢çŠ¶ï¼‰
        private let shapeMaskLayer = ShapeLayer()

        // 3. åº•è‰²å±‚ (NEW)ï¼šæ°¸è¿œé™æ­¢ï¼Œæä¾›ç°è‰²çš„åº•
        private let backgroundLayer = Layer()

        // 4. å…‰æ•ˆå±‚ï¼šè´Ÿè´£æ‰«å…‰åŠ¨ç”»ï¼ŒèƒŒæ™¯é€æ˜
        private let shineLayer = GradientLayer()

        init(frame: NSRect, configuration: SkeletonConfiguration) {
            self.configuration = configuration
            super.init(frame: frame)
            setupLayers()
        }

        @available(*, unavailable)
        required init?(coder: NSCoder) {
            fatalError("init(coder:) has not been implemented")
        }

        override var isFlipped: Bool { true }

        override var wantsUpdateLayer: Bool { true }

        private func setupLayers() {
            wantsLayer = true

            layerContentsRedrawPolicy = .onSetNeedsDisplay

            guard let rootLayer = layer else { return }

            // 1. æ ¹å®¹å™¨ & Mask
            containerLayer.backgroundColor = NSColor.clear.cgColor
            containerLayer.mask = shapeMaskLayer
            rootLayer.addSublayer(containerLayer)

            // 2. åº•è‰²å±‚
            backgroundLayer.backgroundColor = configuration.baseColor.cgColor
            containerLayer.addSublayer(backgroundLayer)

            // 3. å…‰æ•ˆå±‚ (æ”¹åŠ¨ç‚¹)
            shineLayer.startPoint = CGPoint(x: 0.0, y: 0.5)
            shineLayer.endPoint = CGPoint(x: 1.0, y: 0.5)

            // ã€å…³é”®ä¿®æ”¹ã€‘ï¼šä½¿ç”¨5ä¸ªç‚¹ï¼Œè€Œä¸æ˜¯3ä¸ªç‚¹
            // 0.0 ~ 0.3: å®Œå…¨é€æ˜
            // 0.3 ~ 0.5: æ…¢æ…¢å˜äº®
            // 0.5: æœ€äº®
            // 0.5 ~ 0.7: æ…¢æ…¢å˜æš—
            // 0.7 ~ 1.0: å®Œå…¨é€æ˜
            // è¿™æ ·å…‰æ™•ä¼šéå¸¸æŸ”å’Œï¼Œä¸ä¼šåƒä¸€æ ¹æ£å­
            shineLayer.locations = [0.0, 0.3, 0.5, 0.7, 1.0]

            containerLayer.addSublayer(shineLayer)
        }

        override func updateLayer() {
            super.updateLayer()

            backgroundLayer.backgroundColor = configuration.baseColor.cgColor

            // è·å–é«˜äº®è‰²çš„ CGColor
            let highlight = configuration.highlightColor.cgColor
            // ææ·¡çš„è¿‡æ¸¡è‰² (ä¿ç•™åŸæœ¬é¢œè‰²çš„ 20% é€æ˜åº¦)
            let faint = configuration.highlightColor.withAlphaComponent(configuration.highlightColor.alphaComponent * 0.2).cgColor
            let clear = NSColor.clear.cgColor

            // ã€å…³é”®ä¿®æ”¹ã€‘ï¼šå»ºç«‹ 5 çº§é¢œè‰²æ¸å˜
            // é€æ˜ -> ææ·¡ -> é«˜äº® -> ææ·¡ -> é€æ˜
            shineLayer.colors = [
                clear,
                faint,
                highlight,
                faint,
                clear,
            ]
        }

        override func layout() {
            super.layout()

            CATransaction.begin()
            CATransaction.setDisableActions(true)

            let bounds = self.bounds
            containerLayer.frame = bounds

            // 1. åº•è‰²å±‚é“ºæ»¡å…¨å±
            backgroundLayer.frame = bounds

            // 2. é‡ç»˜é®ç½©å½¢çŠ¶ (æ–‡å­—æ¡)
            setupMaskShape(bounds: bounds)

            // 3. è®¡ç®—å…‰æ•ˆå±‚çš„å¤§å°å’Œä½ç½®
            let angleRad = configuration.angle * .pi / 180.0
            let extraWidth = bounds.height * abs(tan(angleRad))

            // ã€å…³é”®ä¿®æ”¹ã€‘ï¼šè¿™é‡Œ + 100 æ”¹æˆ bounds.width * 1.5
            // è®©å…‰æ¡å±‚çš„å®é™…ç‰©ç†å®½åº¦éå¸¸å®½ï¼Œè¿™æ ·æ¸å˜æ‹‰ä¼¸å¾—æ›´å¼€ï¼Œå…‰æ„Ÿæ›´ç»†è…»
            let totalWidth = bounds.width + extraWidth + (bounds.width * 1.5)
            let totalHeight = bounds.height * 2.0

            // å°†å…‰æ•ˆå±‚å±…ä¸­æ”¾ç½®ï¼Œç¨åé€šè¿‡ transform ç§»åŠ¨
            let gradientFrame = CGRect(
                x: (bounds.width - totalWidth) / 2,
                y: (bounds.height - totalHeight) / 2,
                width: totalWidth,
                height: totalHeight
            )

            shineLayer.frame = gradientFrame

            // åº”ç”¨æ—‹è½¬
            var transform = CATransform3DIdentity
            transform = CATransform3DMakeRotation(-angleRad, 0, 0, 1)
            shineLayer.transform = transform

            CATransaction.commit()

            // é‡æ–°å¯åŠ¨åŠ¨ç”»
            startAnimating()
        }

        private func setupMaskShape(bounds: CGRect) {
            let path = CGMutablePath()

            if bounds.width <= 0 || bounds.height <= 0 { return }

            var currentY: CGFloat = configuration.contentInsets.height
            let startX: CGFloat = configuration.contentInsets.width
            let maxAvailableWidth = bounds.width - (configuration.contentInsets.width * 2)

            if maxAvailableWidth <= 0 { return }

            let effectiveRowHeight = configuration.lineHeight + configuration.lineSpacing
            var rowIndex = 0

            while currentY < bounds.height {
                var lineWidth = maxAvailableWidth
                let lineX = startX // å§‹ç»ˆå·¦å¯¹é½ï¼Œæ— ç¼©è¿›

                if configuration.style == .code {
                    // ä½¿ç”¨æ­£å¼¦å‡½æ•°ç”Ÿæˆç¨³å®šçš„ä¼ªéšæœºæ•° (-1.0 ~ 1.0)
                    // ä¹˜ä»¥ 13.0 æ˜¯ä¸ºäº†è®©æ³¢å½¢è·³è·ƒå¤§ä¸€ç‚¹ï¼Œé¿å…ç›¸é‚»è¡Œé•¿åº¦å¤ªæ¥è¿‘
                    let randomSeed = sin(Double(rowIndex) * 13.0)

                    // å°† -1~1 æ˜ å°„åˆ° 0.4~1.0 (å³ 40% ~ 100% å®½åº¦)
                    // è¿™æ ·æœ€çŸ­çš„è¡Œä¹Ÿä¸ä¼šçŸ­äº 40%ï¼Œçœ‹èµ·æ¥æ›´åƒçœŸå®å†…å®¹
                    let widthRatio = CGFloat((randomSeed + 1.0) / 2.0 * 0.6 + 0.4)

                    lineWidth = maxAvailableWidth * widthRatio
                }

                // ç»˜åˆ¶åœ†è§’çŸ©å½¢
                let rect = CGRect(x: lineX, y: currentY, width: lineWidth, height: configuration.lineHeight)
                let roundedRect = CGPath(roundedRect: rect, cornerWidth: configuration.cornerRadius, cornerHeight: configuration.cornerRadius, transform: nil)
                path.addPath(roundedRect)

                currentY += effectiveRowHeight
                rowIndex += 1
            }

            shapeMaskLayer.path = path
        }

        // MARK: - Animation

        func startAnimating() {
            shineLayer.removeAnimation(forKey: "slide")

            let boundsWidth = bounds.width

            // åŠ¨ç”»è¡Œç¨‹ï¼šä»å·¦ä¾§å¤–é¢ -> å³ä¾§å¤–é¢
            // å› ä¸º layer å·²ç»æ—‹è½¬å¹¶å±…ä¸­ï¼Œæˆ‘ä»¬ç›´æ¥æ“ä½œ translation.x
            // åªè¦æ•°å€¼å¤Ÿå¤§ï¼Œèƒ½è¦†ç›–å±å¹•å®½åº¦å³å¯
            let startX = -boundsWidth * 1.5
            let endX = boundsWidth * 1.5

            let animation = CABasicAnimation(keyPath: "transform.translation.x")

            if configuration.direction == .leftToRight {
                animation.fromValue = startX
                animation.toValue = endX
            } else {
                animation.fromValue = endX
                animation.toValue = startX
            }

            animation.duration = configuration.animationDuration
            animation.repeatCount = .infinity
            animation.isRemovedOnCompletion = false
            animation.timingFunction = CAMediaTimingFunction(name: .linear)

            shineLayer.add(animation, forKey: "slide")
        }

        func stopAnimating() {
            shineLayer.removeAllAnimations()
        }
    }

    private final class SkeletonState {
        weak var overlayView: SkeletonOverlayView?
        var originalEditable: Bool = true
        var originalSelectable: Bool = true
        var originalTextColor: NSColor?
    }

    @inline(never) private static var skeletonStateKey: UInt8 = 0

    private var skeletonState: SkeletonState {
        get {
            if let state = objc_getAssociatedObject(self, &Self.skeletonStateKey) as? SkeletonState {
                return state
            }
            let newState = SkeletonState()
            objc_setAssociatedObject(self, &Self.skeletonStateKey, newState, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
            return newState
        }
    }

    public func showSkeleton(using config: SkeletonConfiguration = .default) {
        if skeletonState.overlayView != nil { return }

        if let textView = self as? NSTextView {
            skeletonState.originalEditable = textView.isEditable
            skeletonState.originalSelectable = textView.isSelectable
            skeletonState.originalTextColor = textView.textColor

            textView.isSelectable = false
            textView.isEditable = false
            textView.textColor = .clear
        }

        let overlay = SkeletonOverlayView(frame: bounds, configuration: config)
        overlay.translatesAutoresizingMaskIntoConstraints = false
        overlay.alphaValue = 0
        addSubview(overlay)

        NSLayoutConstraint.activate([
            overlay.topAnchor.constraint(equalTo: topAnchor),
            overlay.bottomAnchor.constraint(equalTo: bottomAnchor),
            overlay.leadingAnchor.constraint(equalTo: leadingAnchor),
            overlay.trailingAnchor.constraint(equalTo: trailingAnchor),
        ])

        overlay.startAnimating()

        skeletonState.overlayView = overlay

        NSAnimationContext.runAnimationGroup { context in
            context.duration = 0.35
            context.timingFunction = CAMediaTimingFunction(name: .easeOut)
            overlay.animator().alphaValue = 1.0
        }
    }

    public func hideSkeleton() {
        guard let overlay = skeletonState.overlayView else { return }

        NSAnimationContext.runAnimationGroup { context in
            context.duration = 0.25
            context.timingFunction = CAMediaTimingFunction(name: .easeIn)
            overlay.animator().alphaValue = 0.0
        } completionHandler: { [self] in
            overlay.stopAnimating()
            overlay.removeFromSuperview()
            skeletonState.overlayView = nil

            if let textView = self as? NSTextView {
                textView.isEditable = skeletonState.originalEditable
                textView.isSelectable = skeletonState.originalSelectable
                textView.textColor = skeletonState.originalTextColor ?? .labelColor
            }
        }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/AppKit/StatefulOutlineView.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
import AppKit
import UIFoundation

open class StatefulOutlineView: OutlineView {
    private var savedExpandedItems = Set<AnyHashable>()

    private var needsRestoreState = false

    open func beginFiltering() {
        saveExpansionState()
    }

    open func endFiltering() {
        if !savedExpandedItems.isEmpty {
            needsRestoreState = true
        }
    }

    private func saveExpansionState() {
        savedExpandedItems.removeAll()

        let numberOfRows = numberOfRows

        guard numberOfRows > 0 else { return }

        for i in 0 ..< numberOfRows {
            guard let item = item(atRow: i) else { continue }

            if isItemExpanded(item), let hashableItem = item as? AnyHashable {
                savedExpandedItems.insert(hashableItem)
            }
        }
    }

    private func restoreExpansionState() {
        collapseItem(nil, collapseChildren: true)

        var rowIndex = 0

        while rowIndex < numberOfRows {
            guard let item = item(atRow: rowIndex) else {
                rowIndex += 1
                continue
            }

            if let hashableItem = item as? AnyHashable, savedExpandedItems.contains(hashableItem) {
                expandItem(item)
            }

            rowIndex += 1
        }

        savedExpandedItems.removeAll()
    }

    open override func reloadData() {
        super.reloadData()
        
        didReloadData()
    }

    private func didReloadData() {
        if needsRestoreState {
            needsRestoreState = false
            DispatchQueue.main.async {
                self.restoreExpansionState()
            }
        }
    }
}

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/RuntimeViewerUI.swift`:

```swift
@_exported import SnapKit
@_exported import NSAttributedStringBuilder
@_exported import SFSymbols
@_exported import IDEIcons
@_exported import UIFoundation
@_exported import UIFoundationToolbox
@_exported import UIFoundationAppleInternal
#if canImport(AppKit) && !targetEnvironment(macCatalyst)
#if USING_SYSTEM_UXKIT
@_exported import UXKit
#else
@_exported import OpenUXKit
#endif
@_exported import FilterUI
@_exported import RunningApplicationKit
@_exported import Rearrange
@_exported import DSFQuickActionBar
@_exported import SystemHUD

#endif

#if canImport(UIKit)

#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/SwiftUI/VisualEffectView.swift`:

```swift
import SwiftUI

#if canImport(AppKit) && !targetEnvironment(macCatalyst)
/// A SwiftUI Wrapper for `NSVisualEffectView`
///
/// ## Usage
/// ```swift
/// VisualEffectView(material: .headerView, blendingMode: .withinWindow)
/// ```
public struct VisualEffectView: NSViewRepresentable {
    private let material: NSVisualEffectView.Material
    private let blendingMode: NSVisualEffectView.BlendingMode
    private let emphasized: Bool

    /// Initializes the
    /// [`NSVisualEffectView`](https://developer.apple.com/documentation/appkit/nsvisualeffectview)
    /// with a
    /// [`Material`](https://developer.apple.com/documentation/appkit/nsvisualeffectview/material) and
    /// [`BlendingMode`](https://developer.apple.com/documentation/appkit/nsvisualeffectview/blendingmode)
    ///
    /// By setting the
    /// [`emphasized`](https://developer.apple.com/documentation/appkit/nsvisualeffectview/1644721-isemphasized)
    /// flag, the emphasized state of the material will be used if available.
    ///
    /// - Parameters:
    ///   - material: The material to use. Defaults to `.headerView`.
    ///   - blendingMode: The blending mode to use. Defaults to `.withinWindow`.
    ///   - emphasized:A Boolean value indicating whether to emphasize the look of the material. Defaults to `false`.
    public init(
        _ material: NSVisualEffectView.Material = .headerView,
        blendingMode: NSVisualEffectView.BlendingMode = .withinWindow,
        emphasized: Bool = false
    ) {
        self.material = material
        self.blendingMode = blendingMode
        self.emphasized = emphasized
    }

    public func makeNSView(context: Context) -> NSVisualEffectView {
        let view = NSVisualEffectView()
        view.material = material
        view.blendingMode = blendingMode
        view.isEmphasized = emphasized
        view.state = .followsWindowActiveState
        return view
    }

    public func updateNSView(_ nsView: NSVisualEffectView, context: Context) {
        nsView.material = material
        nsView.blendingMode = blendingMode
    }

    /// Returns the system selection style as an ``EffectView`` if the `condition` is met.
    /// Otherwise it returns `Color.clear`
    ///
    /// - Parameter condition: The condition of when to apply the background. Defaults to `true`.
    /// - Returns: A View
    @ViewBuilder
    public static func selectionBackground(_ condition: Bool = true) -> some SwiftUI.View {
        if condition {
            VisualEffectView(.selection, blendingMode: .withinWindow, emphasized: true)
        } else {
            Color.clear
        }
    }
}
#endif

```

`RuntimeViewerPackages/Sources/RuntimeViewerUI/Then.swift`:

```swift
import Foundation
#if !os(Linux)
import CoreGraphics
#endif

#if os(macOS)
import AppKit
#endif

#if os(iOS) || os(tvOS)
import UIKit.UIGeometry
#endif

protocol Then {}

extension Then where Self: Any {
    /// Makes it available to set properties with closures just after initializing and copying the value types.
    ///
    ///     let frame = CGRect().with {
    ///       $0.origin.x = 10
    ///       $0.size.width = 100
    ///     }
    @inlinable
    func with(_ block: (inout Self) throws -> Void) rethrows -> Self {
        var copy = self
        try block(&copy)
        return copy
    }

    /// Makes it available to execute something with closures.
    ///
    ///     UserDefaults.standard.do {
    ///       $0.set("devxoul", forKey: "username")
    ///       $0.set("devxoul@gmail.com", forKey: "email")
    ///       $0.synchronize()
    ///     }
    @inlinable
    func `do`(_ block: (Self) throws -> Void) rethrows {
        try block(self)
    }
}

extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///       $0.textAlignment = .center
    ///       $0.textColor = UIColor.black
    ///       $0.text = "Hello, World!"
    ///     }
    @inlinable
    @discardableResult
    func then(_ block: (Self) throws -> Void) rethrows -> Self {
        try block(self)
        return self
    }
}

extension Then {
    @inlinable
    func `as`<T>(_ transform: (Self) throws -> T) rethrows -> T {
        try transform(self)
    }
}

extension NSObject: Then {}

extension CGPoint: Then {}
extension CGRect: Then {}
extension CGSize: Then {}
extension CGVector: Then {}

extension Array: Then {}
extension Dictionary: Then {}
extension Set: Then {}
extension JSONDecoder: Then {}
extension JSONEncoder: Then {}

#if os(macOS)
extension NSEdgeInsets: Then {}
extension NSRectEdge: Then {}
extension NSDirectionalRectEdge: Then {}
extension NSDirectionalEdgeInsets: Then {}
@available(macOS 15.0, *)
extension NSHorizontalDirection: Then {}
@available(macOS 15.0, *)
extension NSHorizontalDirection.Set: Then {}
@available(macOS 15.0, *)
extension NSVerticalDirection: Then {}
@available(macOS 15.0, *)
extension NSVerticalDirection.Set: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItem: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse.Highlight: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse.Phase: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemSection: Then {}
@available(macOS 26.0, *)
extension NSItemBadge: Then {}
@available(macOS 26.0, *)
extension NSView.LayoutRegion: Then {}
#endif

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Package.swift`:

```swift
// swift-tools-version: 5.9

import PackageDescription

let tag = "601.0.1"

let package = Package(
    name: "swift-syntax",
    platforms: [
        .iOS(.v13),
        .macCatalyst(.v13),
        .macOS(.v10_15),
        .tvOS(.v13),
        .watchOS(.v6),
    ],
    products: [
        .library(name: "SwiftBasicFormat", targets: ["SwiftBasicFormat_Aggregation"]),
        .library(name: "SwiftCompilerPlugin", targets: ["SwiftCompilerPlugin_Aggregation"]),
        .library(name: "SwiftDiagnostics", targets: ["SwiftDiagnostics_Aggregation"]),
        .library(name: "SwiftIDEUtils", targets: ["SwiftIDEUtils_Aggregation"]),
        .library(name: "SwiftIfConfig", targets: ["SwiftIfConfig_Aggregation"]),
        .library(name: "SwiftLexicalLookup", targets: ["SwiftLexicalLookup_Aggregation"]),
        .library(name: "SwiftOperators", targets: ["SwiftOperators_Aggregation"]),
        .library(name: "SwiftParser", targets: ["SwiftParser_Aggregation"]),
        .library(name: "SwiftParserDiagnostics", targets: ["SwiftParserDiagnostics_Aggregation"]),
        .library(name: "SwiftRefactor", targets: ["SwiftRefactor_Aggregation"]),
        .library(name: "SwiftSyntax", targets: ["SwiftSyntax_Aggregation"]),
        .library(name: "SwiftSyntaxBuilder", targets: ["SwiftSyntaxBuilder_Aggregation"]),
        .library(name: "SwiftSyntaxMacros", targets: ["SwiftSyntaxMacros_Aggregation"]),
        .library(name: "SwiftSyntaxMacroExpansion", targets: ["SwiftSyntaxMacroExpansion_Aggregation"]),
        .library(name: "SwiftSyntaxMacrosTestSupport", targets: ["SwiftSyntaxMacrosTestSupport_Aggregation"]),
        .library(name: "SwiftSyntaxMacrosGenericTestSupport", targets: ["SwiftSyntaxMacrosGenericTestSupport_Aggregation"]),
        .library(name: "_SwiftCompilerPluginMessageHandling", targets: ["SwiftCompilerPluginMessageHandling_Aggregation"]),
        .library(name: "_SwiftLibraryPluginProvider", targets: ["SwiftLibraryPluginProvider_Aggregation"]),
    ],
    targets: [
        // MARK: - SwiftBasicFormat
        .target(
            name: "SwiftBasicFormat_Aggregation",
            dependencies: [
                .target(name: "SwiftBasicFormat"),
                "SwiftSyntax_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftBasicFormat",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftBasicFormat.xcframework.zip",
            checksum: "94365ab0f550e63d788c2379193bcaef059d4c155d587eacc0648deb4dcdf418"
        ),

        // MARK: - SwiftCompilerPlugin
        .target(
            name: "SwiftCompilerPlugin_Aggregation",
            dependencies: [
                .target(name: "SwiftCompilerPlugin"),
                "SwiftCompilerPluginMessageHandling_Aggregation",
                "SwiftSyntaxMacros_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftCompilerPlugin",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftCompilerPlugin.xcframework.zip",
            checksum: "e3cad3e5b8c29b70c85fe05dd85622ad3a82f9ad48789ed7998bee35b34475da"
        ),

        // MARK: - SwiftDiagnostics
        .target(
            name: "SwiftDiagnostics_Aggregation",
            dependencies: [
                .target(name: "SwiftDiagnostics"),
                "SwiftSyntax_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftDiagnostics",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftDiagnostics.xcframework.zip",
            checksum: "50bf401279fc1f35f177bd40e4a1a107950dbb442fcde7a3fdce47836eb2016b"
        ),

        // MARK: - SwiftIDEUtils
        .target(
            name: "SwiftIDEUtils_Aggregation",
            dependencies: [
                .target(name: "SwiftIDEUtils"),
                "SwiftSyntax_Aggregation",
                "SwiftDiagnostics_Aggregation",
                "SwiftParser_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftIDEUtils",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftIDEUtils.xcframework.zip",
            checksum: "82a31659ddf3a24a89a17863aabaeea15024dd92267898c27b3d03a5298e3827"
        ),

        // MARK: - SwiftIfConfig
        .target(
            name: "SwiftIfConfig_Aggregation",
            dependencies: [
                .target(name: "SwiftIfConfig"),
                "SwiftSyntax_Aggregation",
                "SwiftSyntaxBuilder_Aggregation",
                "SwiftDiagnostics_Aggregation",
                "SwiftOperators_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftIfConfig",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftIfConfig.xcframework.zip",
            checksum: "86d9fb1a73a5c1f7f71d384abdd7f631a0b6a10de7660fe3fd577f1f1650c0a7"
        ),

        // MARK: - SwiftLexicalLookup
        .target(
            name: "SwiftLexicalLookup_Aggregation",
            dependencies: [
                .target(name: "SwiftLexicalLookup"),
                "SwiftSyntax_Aggregation",
                "SwiftIfConfig_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftLexicalLookup",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftLexicalLookup.xcframework.zip",
            checksum: "7f2f318e7caf5e6bc8707b3ddd812f77913852cbd699be6fafdc7e9e4638b0f8"
        ),

        // MARK: - SwiftOperators
        .target(
            name: "SwiftOperators_Aggregation",
            dependencies: [
                .target(name: "SwiftOperators"),
                "SwiftDiagnostics_Aggregation",
                "SwiftParser_Aggregation",
                "SwiftSyntax_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftOperators",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftOperators.xcframework.zip",
            checksum: "d6da125f107d2e0109b8f5056ab5f62a57ecc7a6f8760d7068628f0d660084ef"
        ),

        // MARK: - SwiftParser
        .target(
            name: "SwiftParser_Aggregation",
            dependencies: [
                .target(name: "SwiftParser"),
                "SwiftSyntax_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftParser",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftParser.xcframework.zip",
            checksum: "873e3a52f51db1f46531877d81d747c0b9c8125e801b0f40472c5b94359d57c1"
        ),

        // MARK: - SwiftParserDiagnostics
        .target(
            name: "SwiftParserDiagnostics_Aggregation",
            dependencies: [
                .target(name: "SwiftParserDiagnostics"),
                "SwiftBasicFormat_Aggregation",
                "SwiftDiagnostics_Aggregation",
                "SwiftParser_Aggregation",
                "SwiftSyntax_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftParserDiagnostics",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftParserDiagnostics.xcframework.zip",
            checksum: "7b6776f6941e1b32250694927c59e72abe952582eaad269da6183118349746ca"
        ),

        // MARK: - SwiftRefactor
        .target(
            name: "SwiftRefactor_Aggregation",
            dependencies: [
                .target(name: "SwiftRefactor"),
                "SwiftBasicFormat_Aggregation",
                "SwiftParser_Aggregation",
                "SwiftSyntax_Aggregation",
                "SwiftSyntaxBuilder_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftRefactor",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftRefactor.xcframework.zip",
            checksum: "b402430b131e6a9133dbb6cbc8760096454b97d3e6d9d97e3f0cfb4ea7bd0b42"
        ),

        // MARK: - SwiftSyntax
        .target(
            name: "SwiftSyntax_Aggregation",
            dependencies: [
                .target(name: "SwiftSyntax"),
                "_SwiftSyntaxCShims_Aggregation",
                "SwiftSyntax509_Aggregation",
                "SwiftSyntax510_Aggregation",
                "SwiftSyntax600_Aggregation",
                "SwiftSyntax601_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftSyntax",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntax.xcframework.zip",
            checksum: "d06ed8d94024fa44041a4ee0bf84610353cbaf1576bb7bfa91e952ef779c870a"
        ),

        // MARK: - SwiftSyntaxBuilder
        .target(
            name: "SwiftSyntaxBuilder_Aggregation",
            dependencies: [
                .target(name: "SwiftSyntaxBuilder"),
                "SwiftBasicFormat_Aggregation",
                "SwiftParser_Aggregation",
                "SwiftDiagnostics_Aggregation",
                "SwiftParserDiagnostics_Aggregation",
                "SwiftSyntax_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftSyntaxBuilder",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntaxBuilder.xcframework.zip",
            checksum: "4d9554178485ee66242b68662e92710461a0a1f641e0703c74e24c313a55251d"
        ),

        // MARK: - SwiftSyntaxMacros
        .target(
            name: "SwiftSyntaxMacros_Aggregation",
            dependencies: [
                .target(name: "SwiftSyntaxMacros"),
                "SwiftDiagnostics_Aggregation",
                "SwiftParser_Aggregation",
                "SwiftSyntax_Aggregation",
                "SwiftSyntaxBuilder_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftSyntaxMacros",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntaxMacros.xcframework.zip",
            checksum: "428f898a1e7852dec98d4c09185fb1a87e7fc77e0203ba83a0db90b360c6e035"
        ),

        // MARK: - SwiftSyntaxMacroExpansion
        .target(
            name: "SwiftSyntaxMacroExpansion_Aggregation",
            dependencies: [
                .target(name: "SwiftSyntaxMacroExpansion"),
                "SwiftSyntax_Aggregation",
                "SwiftSyntaxBuilder_Aggregation",
                "SwiftSyntaxMacros_Aggregation",
                "SwiftDiagnostics_Aggregation",
                "SwiftOperators_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftSyntaxMacroExpansion",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntaxMacroExpansion.xcframework.zip",
            checksum: "2ddcd299bd7523b53f02a005ec066831cbac20677292ee198801a3eafb8cf696"
        ),

        // MARK: - SwiftSyntaxMacrosTestSupport
        .target(
            name: "SwiftSyntaxMacrosTestSupport_Aggregation",
            dependencies: [
                .target(name: "SwiftSyntaxMacrosTestSupport"),
                "SwiftSyntax_Aggregation",
                "SwiftSyntaxMacroExpansion_Aggregation",
                "SwiftSyntaxMacros_Aggregation",
                "SwiftSyntaxMacrosGenericTestSupport_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftSyntaxMacrosTestSupport",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntaxMacrosTestSupport.xcframework.zip",
            checksum: "8ae3781cd5ad9e63b653a99a3c7ba1efd1eeaa2d831122d05868ea80b9998529"
        ),

        // MARK: - SwiftSyntaxMacrosGenericTestSupport
        .target(
            name: "SwiftSyntaxMacrosGenericTestSupport_Aggregation",
            dependencies: [
                .target(name: "SwiftSyntaxMacrosGenericTestSupport"),
                "_SwiftSyntaxGenericTestSupport_Aggregation",
                "SwiftDiagnostics_Aggregation",
                "SwiftIDEUtils_Aggregation",
                "SwiftParser_Aggregation",
                "SwiftSyntaxMacros_Aggregation",
                "SwiftSyntaxMacroExpansion_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftSyntaxMacrosGenericTestSupport",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntaxMacrosGenericTestSupport.xcframework.zip",
            checksum: "5601a9d686cc84f5b32e1c6c04a01f3fe16c8f5216f1edec648b6d2ce0aa1d04"
        ),

        // MARK: - _SwiftCompilerPluginMessageHandling
        .target(
            name: "_SwiftCompilerPluginMessageHandling_Aggregation",
            dependencies: [.target(name: "_SwiftCompilerPluginMessageHandling")]
        ),
        .binaryTarget(
            name: "_SwiftCompilerPluginMessageHandling",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/_SwiftCompilerPluginMessageHandling.xcframework.zip",
            checksum: "df02239aac44cb97402c49d04ebdb8d63880d1cf6d2730bdafb0c71d594b31b9"
        ),

        // MARK: - _SwiftLibraryPluginProvider
        .target(
            name: "_SwiftLibraryPluginProvider_Aggregation",
            dependencies: [.target(name: "_SwiftLibraryPluginProvider")]
        ),
        .binaryTarget(
            name: "_SwiftLibraryPluginProvider",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/_SwiftLibraryPluginProvider.xcframework.zip",
            checksum: "d5aeedeefa4aa7f424054147f4d55809f65f30174a3235bfd7cde957b4e8631f"
        ),

        // MARK: - _SwiftLibraryPluginProviderCShims
        .target(
            name: "_SwiftLibraryPluginProviderCShims_Aggregation",
            dependencies: [.target(name: "_SwiftLibraryPluginProviderCShims")]
        ),
        .binaryTarget(
            name: "_SwiftLibraryPluginProviderCShims",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/_SwiftLibraryPluginProviderCShims.xcframework.zip",
            checksum: "889ee8bf53509090f75fe39e5a74784af8eacdd896f7a314f1dff4fa60a5a8ca"
        ),

        // MARK: - _SwiftSyntaxCShims
        .target(
            name: "_SwiftSyntaxCShims_Aggregation",
            dependencies: [.target(name: "_SwiftSyntaxCShims")]
        ),
        .binaryTarget(
            name: "_SwiftSyntaxCShims",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/_SwiftSyntaxCShims.xcframework.zip",
            checksum: "f4d14eabe1bec36dfe7ebc13f4a159dbb046e966579af5d8d807e151c2aa6c9b"
        ),

        // MARK: - _SwiftSyntaxGenericTestSupport
        .target(
            name: "_SwiftSyntaxGenericTestSupport_Aggregation",
            dependencies: [.target(name: "_SwiftSyntaxGenericTestSupport")]
        ),
        .binaryTarget(
            name: "_SwiftSyntaxGenericTestSupport",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/_SwiftSyntaxGenericTestSupport.xcframework.zip",
            checksum: "884d1c5983a63e1863d38049174933f5c734a2537c91c26a1d241c08c4aeeeac"
        ),

        // MARK: - SwiftCompilerPluginMessageHandling
        .target(
            name: "SwiftCompilerPluginMessageHandling_Aggregation",
            dependencies: [
                .target(name: "SwiftCompilerPluginMessageHandling"),
                "_SwiftSyntaxCShims_Aggregation",
                "SwiftDiagnostics_Aggregation",
                "SwiftOperators_Aggregation",
                "SwiftParser_Aggregation",
                "SwiftSyntax_Aggregation",
                "SwiftSyntaxMacros_Aggregation",
                "SwiftSyntaxMacroExpansion_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftCompilerPluginMessageHandling",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftCompilerPluginMessageHandling.xcframework.zip",
            checksum: "d405da850c46662e7995110bfa1b21d2c900d61d24864bd4f4a47f3d94097014"
        ),

        // MARK: - SwiftLibraryPluginProvider
        .target(
            name: "SwiftLibraryPluginProvider_Aggregation",
            dependencies: [
                .target(name: "SwiftLibraryPluginProvider"),
                "SwiftSyntaxMacros_Aggregation",
                "SwiftCompilerPluginMessageHandling_Aggregation",
                "_SwiftLibraryPluginProviderCShims_Aggregation",
            ]
        ),
        .binaryTarget(
            name: "SwiftLibraryPluginProvider",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftLibraryPluginProvider.xcframework.zip",
            checksum: "8cdccb3839eb1f94eb601f347ada3839848add1b6c92cf415fab57c11727f396"
        ),

        // MARK: - SwiftSyntax509
        .target(
            name: "SwiftSyntax509_Aggregation",
            dependencies: [.target(name: "SwiftSyntax509")]
        ),
        .binaryTarget(
            name: "SwiftSyntax509",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntax509.xcframework.zip",
            checksum: "9c362169c3e677e0670c3630d1215d26b31191250db76516ea399f350d9b45ad"
        ),

        // MARK: - SwiftSyntax510
        .target(
            name: "SwiftSyntax510_Aggregation",
            dependencies: [.target(name: "SwiftSyntax510")]
        ),
        .binaryTarget(
            name: "SwiftSyntax510",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntax510.xcframework.zip",
            checksum: "d3a578ad0c7d352b6940397480d8f040b5095065af3836de66b6961eea28501c"
        ),

        // MARK: - SwiftSyntax600
        .target(
            name: "SwiftSyntax600_Aggregation",
            dependencies: [.target(name: "SwiftSyntax600")]
        ),
        .binaryTarget(
            name: "SwiftSyntax600",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntax600.xcframework.zip",
            checksum: "83c09d90b60f67c001d6f598a657c6cf0b457acad466f823074112b40ff678cf"
        ),

        // MARK: - SwiftSyntax601
        .target(
            name: "SwiftSyntax601_Aggregation",
            dependencies: [.target(name: "SwiftSyntax601")]
        ),
        .binaryTarget(
            name: "SwiftSyntax601",
            url: "https://github.com/MxIris-DeveloperTool/swift-syntax-builder/releases/download/601.0.1/SwiftSyntax601.xcframework.zip",
            checksum: "eed0abae3c33170a43441bd4c35f95e7591e05b7482cb10833803551dab5ebbd"
        ),

    ]
)

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftBasicFormat_Aggregation/SwiftBasicFormat_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftCompilerPluginMessageHandling_Aggregation/SwiftCompilerPluginMessageHandling_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftCompilerPlugin_Aggregation/SwiftCompilerPlugin_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftDiagnostics_Aggregation/SwiftDiagnostics_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftIDEUtils_Aggregation/SwiftIDEUtils_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftIfConfig_Aggregation/SwiftIfConfig_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftLexicalLookup_Aggregation/SwiftLexicalLookup_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftLibraryPluginProvider_Aggregation/SwiftLibraryPluginProvider_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftOperators_Aggregation/SwiftOperators_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftParserDiagnostics_Aggregation/SwiftParserDiagnostics_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftParser_Aggregation/SwiftParser_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftRefactor_Aggregation/SwiftRefactor_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntax509_Aggregation/SwiftSyntax509_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntax510_Aggregation/SwiftSyntax510_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntax600_Aggregation/SwiftSyntax600_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntax601_Aggregation/SwiftSyntax601_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntaxBuilder_Aggregation/SwiftSyntaxBuilder_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntaxMacroExpansion_Aggregation/SwiftSyntaxMacroExpansion_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntaxMacrosGenericTestSupport_Aggregation/SwiftSyntaxMacrosGenericTestSupport_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntaxMacrosTestSupport_Aggregation/SwiftSyntaxMacrosTestSupport_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntaxMacros_Aggregation/SwiftSyntaxMacros_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/SwiftSyntax_Aggregation/SwiftSyntax_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/_SwiftCompilerPluginMessageHandling_Aggregation/_SwiftCompilerPluginMessageHandling_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/_SwiftLibraryPluginProviderCShims_Aggregation/_SwiftLibraryPluginProviderCShims_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/_SwiftLibraryPluginProvider_Aggregation/_SwiftLibraryPluginProvider_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/_SwiftSyntaxCShims_Aggregation/_SwiftSyntaxCShims_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerPrecompiledLibraries/swift-syntax/Sources/_SwiftSyntaxGenericTestSupport_Aggregation/_SwiftSyntaxGenericTestSupport_Aggregation.swift`:

```swift
// This file is intentionally empty.
// It exists only to satisfy SwiftPM's requirement for source files in targets.
// The actual implementation is provided by the binary target.

```

`RuntimeViewerServer/RuntimeViewerServer.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 77;
	objects = {

/* Begin PBXBuildFile section */
		E978F9272F1C98A8004C09B4 /* LaunchServicesPrivate in Frameworks */ = {isa = PBXBuildFile; productRef = E978F9262F1C98A8004C09B4 /* LaunchServicesPrivate */; };
		E978F92A2F1C98F1004C09B4 /* RuntimeViewerCore in Frameworks */ = {isa = PBXBuildFile; productRef = E978F9292F1C98F1004C09B4 /* RuntimeViewerCore */; };
		E994E3C82F325593009DD28A /* RuntimeViewerCore in Frameworks */ = {isa = PBXBuildFile; productRef = E994E3C72F325593009DD28A /* RuntimeViewerCore */; };
		E994E3CA2F3255D1009DD28A /* LaunchServicesPrivate in Frameworks */ = {isa = PBXBuildFile; productRef = E994E3C92F3255D1009DD28A /* LaunchServicesPrivate */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		E978F9192F1BBB38004C09B4 /* RuntimeViewerServer.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = RuntimeViewerServer.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		E994E2962F323A51009DD28A /* RuntimeViewerServer.framework */ = {isa = PBXFileReference; explicitFileType = wrapper.framework; includeInIndex = 0; path = RuntimeViewerServer.framework; sourceTree = BUILT_PRODUCTS_DIR; };
		E994E3CB2F3257B6009DD28A /* RuntimeViewerCore */ = {isa = PBXFileReference; lastKnownFileType = wrapper; name = RuntimeViewerCore; path = ../RuntimeViewerCore; sourceTree = SOURCE_ROOT; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		E978F91B2F1BBB38004C09B4 /* RuntimeViewerServer */ = {
			isa = PBXFileSystemSynchronizedRootGroup;
			path = RuntimeViewerServer;
			sourceTree = "<group>";
		};
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		E978F9162F1BBB38004C09B4 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E978F92A2F1C98F1004C09B4 /* RuntimeViewerCore in Frameworks */,
				E978F9272F1C98A8004C09B4 /* LaunchServicesPrivate in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E994E28F2F323A51009DD28A /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E994E3C82F325593009DD28A /* RuntimeViewerCore in Frameworks */,
				E994E3CA2F3255D1009DD28A /* LaunchServicesPrivate in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		E978F90F2F1BBB38004C09B4 = {
			isa = PBXGroup;
			children = (
				E994E3CB2F3257B6009DD28A /* RuntimeViewerCore */,
				E978F91B2F1BBB38004C09B4 /* RuntimeViewerServer */,
				E978F9282F1C98F1004C09B4 /* Frameworks */,
				E978F91A2F1BBB38004C09B4 /* Products */,
			);
			sourceTree = "<group>";
		};
		E978F91A2F1BBB38004C09B4 /* Products */ = {
			isa = PBXGroup;
			children = (
				E978F9192F1BBB38004C09B4 /* RuntimeViewerServer.framework */,
				E994E2962F323A51009DD28A /* RuntimeViewerServer.framework */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		E978F9282F1C98F1004C09B4 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXHeadersBuildPhase section */
		E978F9142F1BBB38004C09B4 /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E994E28D2F323A51009DD28A /* Headers */ = {
			isa = PBXHeadersBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXHeadersBuildPhase section */

/* Begin PBXNativeTarget section */
		E978F9182F1BBB38004C09B4 /* RuntimeViewerServer */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E978F9202F1BBB38004C09B4 /* Build configuration list for PBXNativeTarget "RuntimeViewerServer" */;
			buildPhases = (
				E978F9142F1BBB38004C09B4 /* Headers */,
				E978F9152F1BBB38004C09B4 /* Sources */,
				E978F9162F1BBB38004C09B4 /* Frameworks */,
				E978F9172F1BBB38004C09B4 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				E978F91B2F1BBB38004C09B4 /* RuntimeViewerServer */,
			);
			name = RuntimeViewerServer;
			packageProductDependencies = (
				E978F9262F1C98A8004C09B4 /* LaunchServicesPrivate */,
				E978F9292F1C98F1004C09B4 /* RuntimeViewerCore */,
			);
			productName = RuntimeViewerServer;
			productReference = E978F9192F1BBB38004C09B4 /* RuntimeViewerServer.framework */;
			productType = "com.apple.product-type.framework";
		};
		E994E2892F323A51009DD28A /* RuntimeViewerMobileServer */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E994E2932F323A51009DD28A /* Build configuration list for PBXNativeTarget "RuntimeViewerMobileServer" */;
			buildPhases = (
				E994E28D2F323A51009DD28A /* Headers */,
				E994E28E2F323A51009DD28A /* Sources */,
				E994E28F2F323A51009DD28A /* Frameworks */,
				E994E2922F323A51009DD28A /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				E978F91B2F1BBB38004C09B4 /* RuntimeViewerServer */,
			);
			name = RuntimeViewerMobileServer;
			packageProductDependencies = (
				E994E3C72F325593009DD28A /* RuntimeViewerCore */,
				E994E3C92F3255D1009DD28A /* LaunchServicesPrivate */,
			);
			productName = RuntimeViewerServer;
			productReference = E994E2962F323A51009DD28A /* RuntimeViewerServer.framework */;
			productType = "com.apple.product-type.framework";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		E978F9102F1BBB38004C09B4 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 2620;
				LastUpgradeCheck = 2620;
				TargetAttributes = {
					E978F9182F1BBB38004C09B4 = {
						CreatedOnToolsVersion = 26.2;
					};
				};
			};
			buildConfigurationList = E978F9132F1BBB38004C09B4 /* Build configuration list for PBXProject "RuntimeViewerServer" */;
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = E978F90F2F1BBB38004C09B4;
			minimizedProjectReferenceProxies = 1;
			packageReferences = (
				E978F9252F1C98A8004C09B4 /* XCRemoteSwiftPackageReference "LaunchServicesPrivate" */,
			);
			preferredProjectObjectVersion = 77;
			productRefGroup = E978F91A2F1BBB38004C09B4 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				E978F9182F1BBB38004C09B4 /* RuntimeViewerServer */,
				E994E2892F323A51009DD28A /* RuntimeViewerMobileServer */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		E978F9172F1BBB38004C09B4 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E994E2922F323A51009DD28A /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		E978F9152F1BBB38004C09B4 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E994E28E2F323A51009DD28A /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		E9321B2A2F34A40A00665281 /* Distribution */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SWIFT_COMPILATION_MODE = wholemodule;
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Distribution;
		};
		E9321B2B2F34A40A00665281 /* Distribution */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				BUILD_LIBRARY_FOR_DISTRIBUTION = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = D5Q73692VW;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_MODULE_VERIFIER = YES;
				ENABLE_POINTER_AUTHENTICATION = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = (
					"@executable_path/../Frameworks",
					"@loader_path/Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.MxIris.RuntimeViewerServer;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SDKROOT = auto;
				SKIP_INSTALL = NO;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = macosx;
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_INSTALL_MODULE = YES;
				SWIFT_INSTALL_OBJC_HEADER = NO;
				SWIFT_UPCOMING_FEATURE_INTERNAL_IMPORTS_BY_DEFAULT = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 6;
				TVOS_DEPLOYMENT_TARGET = 13.0;
				WATCHOS_DEPLOYMENT_TARGET = 6.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Distribution;
		};
		E9321B2C2F34A40A00665281 /* Distribution */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				BUILD_LIBRARY_FOR_DISTRIBUTION = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = D5Q73692VW;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_MODULE_VERIFIER = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = (
					"@executable_path/../Frameworks",
					"@loader_path/Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.MxIris.RuntimeViewerServer;
				PRODUCT_NAME = RuntimeViewerServer;
				SDKROOT = auto;
				SKIP_INSTALL = NO;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = "appletvos appletvsimulator iphoneos iphonesimulator watchos watchsimulator xros xrsimulator";
				SUPPORTS_MACCATALYST = YES;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = YES;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_INSTALL_MODULE = YES;
				SWIFT_INSTALL_OBJC_HEADER = NO;
				SWIFT_UPCOMING_FEATURE_INTERNAL_IMPORTS_BY_DEFAULT = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,3,4,6,7";
				TVOS_DEPLOYMENT_TARGET = 13.0;
				WATCHOS_DEPLOYMENT_TARGET = 6.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Distribution;
		};
		E978F91E2F1BBB38004C09B4 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Debug;
		};
		E978F91F2F1BBB38004C09B4 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				CURRENT_PROJECT_VERSION = 1;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SWIFT_COMPILATION_MODE = wholemodule;
				VERSIONING_SYSTEM = "apple-generic";
				VERSION_INFO_PREFIX = "";
			};
			name = Release;
		};
		E978F9212F1BBB38004C09B4 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				BUILD_LIBRARY_FOR_DISTRIBUTION = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = D5Q73692VW;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_MODULE_VERIFIER = YES;
				ENABLE_POINTER_AUTHENTICATION = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = (
					"@executable_path/../Frameworks",
					"@loader_path/Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.MxIris.RuntimeViewerServer;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SDKROOT = auto;
				SKIP_INSTALL = YES;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = macosx;
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_INSTALL_MODULE = YES;
				SWIFT_INSTALL_OBJC_HEADER = NO;
				SWIFT_UPCOMING_FEATURE_INTERNAL_IMPORTS_BY_DEFAULT = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 6;
				TVOS_DEPLOYMENT_TARGET = 13.0;
				WATCHOS_DEPLOYMENT_TARGET = 6.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Debug;
		};
		E978F9222F1BBB38004C09B4 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				BUILD_LIBRARY_FOR_DISTRIBUTION = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = D5Q73692VW;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_MODULE_VERIFIER = YES;
				ENABLE_POINTER_AUTHENTICATION = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = (
					"@executable_path/../Frameworks",
					"@loader_path/Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.MxIris.RuntimeViewerServer;
				PRODUCT_NAME = "$(TARGET_NAME:c99extidentifier)";
				SDKROOT = auto;
				SKIP_INSTALL = YES;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = macosx;
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_INSTALL_MODULE = YES;
				SWIFT_INSTALL_OBJC_HEADER = NO;
				SWIFT_UPCOMING_FEATURE_INTERNAL_IMPORTS_BY_DEFAULT = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = 6;
				TVOS_DEPLOYMENT_TARGET = 13.0;
				WATCHOS_DEPLOYMENT_TARGET = 6.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Release;
		};
		E994E2942F323A51009DD28A /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				BUILD_LIBRARY_FOR_DISTRIBUTION = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = D5Q73692VW;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_MODULE_VERIFIER = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = (
					"@executable_path/../Frameworks",
					"@loader_path/Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.MxIris.RuntimeViewerServer;
				PRODUCT_NAME = RuntimeViewerServer;
				SDKROOT = auto;
				SKIP_INSTALL = NO;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = "appletvos appletvsimulator iphoneos iphonesimulator watchos watchsimulator xros xrsimulator";
				SUPPORTS_MACCATALYST = YES;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = YES;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_INSTALL_MODULE = YES;
				SWIFT_INSTALL_OBJC_HEADER = NO;
				SWIFT_UPCOMING_FEATURE_INTERNAL_IMPORTS_BY_DEFAULT = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,3,4,6,7";
				TVOS_DEPLOYMENT_TARGET = 13.0;
				WATCHOS_DEPLOYMENT_TARGET = 6.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Debug;
		};
		E994E2952F323A51009DD28A /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = YES;
				BUILD_LIBRARY_FOR_DISTRIBUTION = YES;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_TEAM = D5Q73692VW;
				DYLIB_COMPATIBILITY_VERSION = 1;
				DYLIB_CURRENT_VERSION = 1;
				DYLIB_INSTALL_NAME_BASE = "@rpath";
				ENABLE_MODULE_VERIFIER = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Frameworks";
				IPHONEOS_DEPLOYMENT_TARGET = 13.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"@executable_path/Frameworks",
					"@loader_path/Frameworks",
				);
				"LD_RUNPATH_SEARCH_PATHS[sdk=macosx*]" = (
					"@executable_path/../Frameworks",
					"@loader_path/Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 10.15;
				MARKETING_VERSION = 1.0;
				MODULE_VERIFIER_SUPPORTED_LANGUAGES = "objective-c objective-c++";
				MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS = "gnu17 gnu++20";
				PRODUCT_BUNDLE_IDENTIFIER = com.MxIris.RuntimeViewerServer;
				PRODUCT_NAME = RuntimeViewerServer;
				SDKROOT = auto;
				SKIP_INSTALL = NO;
				STRING_CATALOG_GENERATE_SYMBOLS = YES;
				SUPPORTED_PLATFORMS = "appletvos appletvsimulator iphoneos iphonesimulator watchos watchsimulator xros xrsimulator";
				SUPPORTS_MACCATALYST = YES;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = YES;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_INSTALL_MODULE = YES;
				SWIFT_INSTALL_OBJC_HEADER = NO;
				SWIFT_UPCOMING_FEATURE_INTERNAL_IMPORTS_BY_DEFAULT = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,3,4,6,7";
				TVOS_DEPLOYMENT_TARGET = 13.0;
				WATCHOS_DEPLOYMENT_TARGET = 6.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		E978F9132F1BBB38004C09B4 /* Build configuration list for PBXProject "RuntimeViewerServer" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E978F91E2F1BBB38004C09B4 /* Debug */,
				E978F91F2F1BBB38004C09B4 /* Release */,
				E9321B2A2F34A40A00665281 /* Distribution */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E978F9202F1BBB38004C09B4 /* Build configuration list for PBXNativeTarget "RuntimeViewerServer" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E978F9212F1BBB38004C09B4 /* Debug */,
				E978F9222F1BBB38004C09B4 /* Release */,
				E9321B2B2F34A40A00665281 /* Distribution */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E994E2932F323A51009DD28A /* Build configuration list for PBXNativeTarget "RuntimeViewerMobileServer" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E994E2942F323A51009DD28A /* Debug */,
				E994E2952F323A51009DD28A /* Release */,
				E9321B2C2F34A40A00665281 /* Distribution */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCRemoteSwiftPackageReference section */
		E978F9252F1C98A8004C09B4 /* XCRemoteSwiftPackageReference "LaunchServicesPrivate" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/MxIris-Reverse-Engineering/LaunchServicesPrivate";
			requirement = {
				branch = main;
				kind = branch;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		E978F9262F1C98A8004C09B4 /* LaunchServicesPrivate */ = {
			isa = XCSwiftPackageProductDependency;
			package = E978F9252F1C98A8004C09B4 /* XCRemoteSwiftPackageReference "LaunchServicesPrivate" */;
			productName = LaunchServicesPrivate;
		};
		E978F9292F1C98F1004C09B4 /* RuntimeViewerCore */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerCore;
		};
		E994E3C72F325593009DD28A /* RuntimeViewerCore */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerCore;
		};
		E994E3C92F3255D1009DD28A /* LaunchServicesPrivate */ = {
			isa = XCSwiftPackageProductDependency;
			package = E978F9252F1C98A8004C09B4 /* XCRemoteSwiftPackageReference "LaunchServicesPrivate" */;
			productName = LaunchServicesPrivate;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = E978F9102F1BBB38004C09B4 /* Project object */;
}

```

`RuntimeViewerServer/RuntimeViewerServer.xcodeproj/xcshareddata/xcschemes/RuntimeViewerMobileServer.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "E994E2892F323A51009DD28A"
               BuildableName = "RuntimeViewerServer.framework"
               BlueprintName = "RuntimeViewerMobileServer"
               ReferencedContainer = "container:RuntimeViewerServer.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E994E2892F323A51009DD28A"
            BuildableName = "RuntimeViewerServer.framework"
            BlueprintName = "RuntimeViewerMobileServer"
            ReferencedContainer = "container:RuntimeViewerServer.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`RuntimeViewerServer/RuntimeViewerServer.xcodeproj/xcshareddata/xcschemes/RuntimeViewerServer.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "E978F9182F1BBB38004C09B4"
               BuildableName = "RuntimeViewerServer.framework"
               BlueprintName = "RuntimeViewerServer"
               ReferencedContainer = "container:RuntimeViewerServer.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E978F9182F1BBB38004C09B4"
            BuildableName = "RuntimeViewerServer.framework"
            BlueprintName = "RuntimeViewerServer"
            ReferencedContainer = "container:RuntimeViewerServer.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`RuntimeViewerServer/RuntimeViewerServer/RuntimeViewerServerLoader.swift`:

```swift
import Foundation
import FoundationToolbox
import RuntimeViewerCore
import RuntimeViewerCommunication

#if os(macOS) || targetEnvironment(macCatalyst)
import LaunchServicesPrivate
#elseif canImport(UIKit)
#if os(watchOS)
import WatchKit.WKInterfaceDevice
#else
import UIKit.UIDevice
#endif
#else
#error("Unsupported Platform")
#endif

@_cdecl("swift_initializeRuntimeViewerServer")
func initializeRuntimeViewerServer() {
    RuntimeViewerServerLoader.main()
}

@Loggable
private enum RuntimeViewerServerLoader {
    private static var runtimeEngine: RuntimeEngine?

    private static var processName: String {
        if let displayName = Bundle.main.infoDictionary?["CFBundleDisplayName"] as? String {
            return displayName
        }

        if let bundleName = Bundle.main.infoDictionary?[kCFBundleNameKey as String] as? String {
            return bundleName
        }

        return ProcessInfo.processInfo.processName
    }

    private static var identifier: String {
        if let bundleID = Bundle.main.bundleIdentifier, !bundleID.isEmpty {
            return bundleID
        }

        let processName = ProcessInfo.processInfo.processName
        let sanitizedName = processName.components(separatedBy: .whitespacesAndNewlines).joined()

        return "com.RuntimeViewer.UnknownBinary.\(sanitizedName)"
    }

    fileprivate static func main() {
        #log(.default, "Attach successfully")
        Task {
            do {
                #log(.default, "Will Launch")

                #if os(macOS) || targetEnvironment(macCatalyst)

                if LSBundleProxy.forCurrentProcess().isSandboxed {
                    runtimeEngine = try await RuntimeEngine(source: .localSocketServer(name: processName, identifier: .init(rawValue: identifier)))
                } else {
                    runtimeEngine = try await RuntimeEngine(source: .remote(name: processName, identifier: .init(rawValue: identifier), role: .server))
                }

                #else

                #if os(watchOS)
                let name = WKInterfaceDevice.current().name
                #else
                let name = await UIDevice.current.name
                #endif

                runtimeEngine = try await RuntimeEngine(source: .bonjourServer(name: name, identifier: .init(rawValue: name)))

                #endif

                #log(.default, "Did Launch")
            } catch {
                #log(.error, "Failed to create runtime engine: \(error, privacy: .public)")
            }
        }
    }
}

#if os(macOS) || targetEnvironment(macCatalyst)
extension LSBundleProxy {
    fileprivate var isSandboxed: Bool {
        guard let entitlements = entitlements else { return false }
        guard let isSandboxed = entitlements["com.apple.security.app-sandbox"] as? Bool else { return false }
        return isSandboxed
    }
}
#endif

```

`RuntimeViewerServer/RuntimeViewerServer/main.m`:

```m
extern void swift_initializeRuntimeViewerServer(void);

__attribute__((constructor, used))
static void initializeRuntimeViewerServer(void) {
    swift_initializeRuntimeViewerServer();
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/AppDelegate.swift`:

```swift
#if canImport(UIKit)

//
//  AppDelegate.swift
//  RuntimeViewerCatalystHelper
//
//  Created by JH on 2024/6/25.
//

import UIKit
import OSLog

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    private let logger = Logger(subsystem: "com.RuntimeViewer.RuntimeViewerCatalystHelper", category: "AppDelegate")

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        do {
            let plugin = try AppKitBridge.shared.loadPlugins()
            plugin.launch()
        } catch {
            logger.error("\(error, privacy: .public)")
        }
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {}
}

#endif

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/AppKitBridge.swift`:

```swift
import Foundation

@objcMembers
final class AppKitBridge: NSObject {
    static let shared = AppKitBridge()
    
    private(set) var plugin: AppKitPlugin?

    enum Error: Swift.Error {
        case failedCreateBundlePath
        case failedLoadBundleFile
        case failedLoadPrincipalClass
    }

    @discardableResult
    func loadPlugins() throws -> AppKitPlugin {
        guard let bundlePath = Bundle.main.builtInPlugInsURL?.appendingPathComponent("RuntimeViewerCatalystHelperPlugin.bundle").path else {
            throw Error.failedCreateBundlePath
        }

        guard let bundle = Bundle(path: bundlePath) else {
            throw Error.failedLoadBundleFile
        }
        
        guard let principalClass = bundle.principalClass as? AppKitPlugin.Type else {
            throw Error.failedLoadPrincipalClass
        }

        let plugin = principalClass.init()
        self.plugin = plugin
        return plugin
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/Assets.xcassets/AppIcon.appiconset/Contents.json`:

```json
{
  "images" : [
    {
      "idiom" : "universal",
      "platform" : "ios",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<true/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/RuntimeViewerCatalystHelper.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelper/SceneDelegate.swift`:

```swift
#if canImport(UIKit)

//
//  SceneDelegate.swift
//  RuntimeViewerCatalystHelper
//
//  Created by JH on 2024/6/25.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
    }


}



#endif

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelperPlugin/AppKitPlugin.swift`:

```swift
import Foundation

@objc(AppKitPlugin)
protocol AppKitPlugin: NSObjectProtocol {
    init()
    func launch()
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerCatalystHelperPlugin/AppKitPluginImpl.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerCommunication
import RuntimeViewerCatalystExtensions

extension NSObject {
    @objc func rvch_makeKeyAndOrderFront(_ sender: Any?) {}
}

@objc(AppKitPluginImpl)
final class AppKitPluginImpl: NSObject, AppKitPlugin {
    var observation: NSKeyValueObservation?

    var runtimeEngine: RuntimeEngine?

    override required init() {
        super.init()
        NSApplication.shared.setActivationPolicy(.prohibited)
        if let UINSWindow = objc_getClass("UINSWindow") as? AnyClass {
            let m1 = class_getInstanceMethod(UINSWindow, #selector(NSWindow.makeKeyAndOrderFront(_:)))
            let m2 = class_getInstanceMethod(UINSWindow, #selector(NSObject.rvch_makeKeyAndOrderFront(_:)))
            if let m1, let m2 {
                method_exchangeImplementations(m1, m2)
            }
        }
        NotificationCenter.default.addObserver(self, selector: #selector(setupWindow(_:)), name: Notification.Name("_NSWindowWillBecomeVisible"), object: nil)
    }

    @objc func setupWindow(_ notification: Notification) {
        if let window = notification.object as? NSWindow, let uinsWindowClass = NSClassFromString("UINSWindow"), window.isKind(of: uinsWindowClass) {
            window.setFrame(.zero, display: true)
        }
    }

    func launch() {
        Task {
            runtimeEngine = RuntimeEngine(source: .macCatalystServer)
            try await runtimeEngine?.connect()
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerMCPServer/MCPBridgeClient.swift`:

```swift
import Foundation
import RuntimeViewerMCPShared

/// High-level typed API for calling MCP bridge commands.
final class MCPBridgeClient: Sendable {
    private let connection: MCPBridgeConnection

    init(connection: MCPBridgeConnection) {
        self.connection = connection
    }

    static func connectFromPortFile() async throws -> MCPBridgeClient {
        let connection = try await MCPBridgeConnection.connectFromPortFile()
        return MCPBridgeClient(connection: connection)
    }

    func listWindows() async throws -> MCPListWindowsResponse {
        struct Empty: Codable {}
        return try await connection.sendRequest(command: .listWindows, payload: Empty())
    }

    func selectedType(windowIdentifier: String) async throws -> MCPSelectedTypeResponse {
        let request = MCPSelectedTypeRequest(windowIdentifier: windowIdentifier)
        return try await connection.sendRequest(command: .selectedType, payload: request)
    }

    func typeInterface(windowIdentifier: String, imagePath: String?, typeName: String) async throws -> MCPTypeInterfaceResponse {
        let request = MCPTypeInterfaceRequest(windowIdentifier: windowIdentifier, imagePath: imagePath, typeName: typeName)
        return try await connection.sendRequest(command: .typeInterface, payload: request)
    }

    func listTypes(windowIdentifier: String, imagePath: String?) async throws -> MCPListTypesResponse {
        let request = MCPListTypesRequest(windowIdentifier: windowIdentifier, imagePath: imagePath)
        return try await connection.sendRequest(command: .listTypes, payload: request)
    }

    func searchTypes(windowIdentifier: String, query: String, imagePath: String?) async throws -> MCPSearchTypesResponse {
        let request = MCPSearchTypesRequest(windowIdentifier: windowIdentifier, query: query, imagePath: imagePath)
        return try await connection.sendRequest(command: .searchTypes, payload: request)
    }

    func grepTypeInterface(windowIdentifier: String, imagePath: String?, pattern: String) async throws -> MCPGrepTypeInterfaceResponse {
        let request = MCPGrepTypeInterfaceRequest(windowIdentifier: windowIdentifier, imagePath: imagePath, pattern: pattern)
        return try await connection.sendRequest(command: .grepTypeInterface, payload: request)
    }

    func stop() {
        connection.stop()
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerMCPServer/MCPBridgeConnection.swift`:

```swift
import Foundation
import Network
import os
import RuntimeViewerMCPShared

/// Handles TCP connection lifecycle, port file discovery, and frame-level I/O.
final class MCPBridgeConnection: Sendable {
    private let connection: NWConnection

    init(host: String, port: UInt16) async throws {
        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.noDelay = true
        let parameters = NWParameters(tls: nil, tcp: tcpOptions)

        self.connection = NWConnection(
            host: NWEndpoint.Host(host),
            port: NWEndpoint.Port(rawValue: port)!,
            using: parameters
        )

        try await withCheckedThrowingContinuation { (continuation: CheckedContinuation<Void, Error>) in
            let didResume = OSAllocatedUnfairLock(initialState: false)

            connection.stateUpdateHandler = { state in
                switch state {
                case .ready:
                    let alreadyResumed = didResume.withLock { resumed -> Bool in
                        if resumed { return true }
                        resumed = true
                        return false
                    }
                    guard !alreadyResumed else { return }
                    continuation.resume()
                case .failed(let error):
                    let alreadyResumed = didResume.withLock { resumed -> Bool in
                        if resumed { return true }
                        resumed = true
                        return false
                    }
                    guard !alreadyResumed else { return }
                    continuation.resume(throwing: error)
                case .waiting(let error):
                    let alreadyResumed = didResume.withLock { resumed -> Bool in
                        if resumed { return true }
                        resumed = true
                        return false
                    }
                    guard !alreadyResumed else { return }
                    continuation.resume(throwing: error)
                case .cancelled:
                    let alreadyResumed = didResume.withLock { resumed -> Bool in
                        if resumed { return true }
                        resumed = true
                        return false
                    }
                    guard !alreadyResumed else { return }
                    continuation.resume(throwing: MCPBridgeTransportError.connectionClosed)
                default:
                    break
                }
            }

            connection.start(queue: .global(qos: .userInitiated))

            DispatchQueue.global().asyncAfter(deadline: .now() + 10) {
                let alreadyResumed = didResume.withLock { resumed -> Bool in
                    if resumed { return true }
                    resumed = true
                    return false
                }
                guard !alreadyResumed else { return }
                continuation.resume(throwing: MCPBridgeTransportError.timeout)
            }
        }
    }

    static func connectFromPortFile() async throws -> MCPBridgeConnection {
        let appSupportURL = FileManager.default.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!
        let portFile = appSupportURL
            .appendingPathComponent("RuntimeViewer")
            .appendingPathComponent("mcp-bridge-port")

        guard FileManager.default.fileExists(atPath: portFile.path) else {
            throw MCPBridgeTransportError.serverNotRunning
        }

        let portString = try String(contentsOf: portFile, encoding: .utf8).trimmingCharacters(in: .whitespacesAndNewlines)
        guard let port = UInt16(portString) else {
            throw MCPBridgeTransportError.serverNotRunning
        }

        return try await MCPBridgeConnection(host: "127.0.0.1", port: port)
    }

    func sendRequest<Response: Decodable>(
        command: MCPBridgeCommand,
        payload: some Encodable
    ) async throws -> Response {
        let envelope = try MCPBridgeEnvelope(identifier: command.rawValue, value: payload)
        let requestJSON = try JSONEncoder().encode(envelope)
        try await MCPBridgeFrame.send(requestJSON, on: connection)

        let responseData = try await MCPBridgeFrame.receive(from: connection)
        let responseEnvelope = try JSONDecoder().decode(MCPBridgeResponseEnvelope.self, from: responseData)
        return try JSONDecoder().decode(Response.self, from: responseEnvelope.payload)
    }

    func stop() {
        connection.cancel()
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerMCPServer/main.swift`:

```swift
import Foundation
import MCP
import RuntimeViewerMCPShared

// MARK: - Tool Definitions

let listWindowsTool = Tool(
    name: "list_windows",
    description: "Lists all open RuntimeViewer windows with their identifiers. Call this first to get the window_identifier needed by other tools.",
    inputSchema: .object([
        "type": .string("object"),
    ])
)

let selectedTypeTool = Tool(
    name: "get_selected_type",
    description: "Returns the currently selected type in a specific RuntimeViewer window, including its image path, type name, kind, and full interface text.",
    inputSchema: .object([
        "type": .string("object"),
        "properties": .object([
            "window_identifier": .object([
                "type": .string("string"),
                "description": .string("The window identifier obtained from list_windows"),
            ]),
        ]),
        "required": .array([.string("window_identifier")]),
    ])
)

let typeInterfaceTool = Tool(
    name: "get_type_interface",
    description: "Gets the interface declaration for a specific runtime type. Returns the type's full interface text including methods, properties, and protocol conformances. If image_path is omitted, searches across all loaded images.",
    inputSchema: .object([
        "type": .string("object"),
        "properties": .object([
            "window_identifier": .object([
                "type": .string("string"),
                "description": .string("The window identifier obtained from list_windows"),
            ]),
            "image_path": .object([
                "type": .string("string"),
                "description": .string("Optional: the full path of the image (framework/dylib) containing the type. If omitted, searches all loaded images."),
            ]),
            "type_name": .object([
                "type": .string("string"),
                "description": .string("The name of the type to inspect (e.g. 'NSView', 'UIViewController')"),
            ]),
        ]),
        "required": .array([.string("window_identifier"), .string("type_name")]),
    ])
)

let listTypesTool = Tool(
    name: "list_types",
    description: "Lists all runtime types (classes, protocols, structs, etc.) in an image (framework/dylib). If image_path is omitted, lists types from all loaded images.",
    inputSchema: .object([
        "type": .string("object"),
        "properties": .object([
            "window_identifier": .object([
                "type": .string("string"),
                "description": .string("The window identifier obtained from list_windows"),
            ]),
            "image_path": .object([
                "type": .string("string"),
                "description": .string("Optional: the full path of the image (framework/dylib) to list types from. If omitted, lists types from all loaded images."),
            ]),
        ]),
        "required": .array([.string("window_identifier")]),
    ])
)

let searchTypesTool = Tool(
    name: "search_types",
    description: "Searches for runtime types by name across all loaded images or within a specific image. Performs case-insensitive substring matching. Use this to find types when you don't know the exact image path.",
    inputSchema: .object([
        "type": .string("object"),
        "properties": .object([
            "window_identifier": .object([
                "type": .string("string"),
                "description": .string("The window identifier obtained from list_windows"),
            ]),
            "query": .object([
                "type": .string("string"),
                "description": .string("The search query string (case-insensitive substring match against type names)"),
            ]),
            "image_path": .object([
                "type": .string("string"),
                "description": .string("Optional: limit search to a specific image path. If omitted, searches all loaded images."),
            ]),
        ]),
        "required": .array([.string("window_identifier"), .string("query")]),
    ])
)

let grepTypeInterfaceTool = Tool(
    name: "grep_type_interface",
    description: "Searches through generated interface text of all types for a keyword pattern. Returns matching types with the lines that contain the pattern. Useful for finding types that declare specific methods, properties, or protocol conformances. If image_path is omitted, searches across all loaded images.",
    inputSchema: .object([
        "type": .string("object"),
        "properties": .object([
            "window_identifier": .object([
                "type": .string("string"),
                "description": .string("The window identifier obtained from list_windows"),
            ]),
            "image_path": .object([
                "type": .string("string"),
                "description": .string("Optional: the full path of the image (framework/dylib) to search in. If omitted, searches all loaded images."),
            ]),
            "pattern": .object([
                "type": .string("string"),
                "description": .string("The search pattern (case-insensitive substring match against interface text lines)"),
            ]),
        ]),
        "required": .array([.string("window_identifier"), .string("pattern")]),
    ])
)

// MARK: - Main

let server = Server(
    name: "RuntimeViewer",
    version: "1.0.0",
    capabilities: .init(tools: .init(listChanged: false))
)

// Register tool list handler
await server.withMethodHandler(ListTools.self) { _ in
    .init(tools: [listWindowsTool, selectedTypeTool, typeInterfaceTool, listTypesTool, searchTypesTool, grepTypeInterfaceTool])
}

// Lazily connect to bridge when first tool call happens
actor BridgeConnection {
    private var client: MCPBridgeClient?

    func connectedClient() async throws -> MCPBridgeClient {
        if let client {
            return client
        }
        let newClient = try await MCPBridgeClient.connectFromPortFile()
        self.client = newClient
        return newClient
    }

    func reset() {
        client?.stop()
        client = nil
    }
}

let bridge = BridgeConnection()

// Helper to get a connected client with error handling
enum BridgeResult {
    case connected(MCPBridgeClient)
    case error(CallTool.Result)
}

func connectedClient() async -> BridgeResult {
    do {
        let client = try await bridge.connectedClient()
        return .connected(client)
    } catch {
        return .error(.init(
            content: [.text("Error: RuntimeViewer app is not running or MCP bridge is not started. Please launch RuntimeViewer first. (\(error.localizedDescription))")],
            isError: true
        ))
    }
}

// Register tool call handler
await server.withMethodHandler(CallTool.self) { params in
    switch params.name {
    case "list_windows":
        switch await connectedClient() {
        case .connected(let client):
            do {
                let response = try await client.listWindows()

                if response.windows.isEmpty {
                    return .init(content: [.text("No RuntimeViewer windows are currently open.")], isError: false)
                }

                var text = "Open Windows:\n"
                for window in response.windows {
                    text += "\n  Identifier: \(window.identifier)"
                    if let displayName = window.displayName {
                        text += "\n  Title: \(displayName)"
                    }
                    text += "\n  Key Window: \(window.isKeyWindow)"
                    if let selectedType = window.selectedTypeName {
                        text += "\n  Selected Type: \(selectedType)"
                    }
                    if let imagePath = window.selectedTypeImagePath {
                        text += "\n  Selected Type Image: \(imagePath)"
                    }
                    text += "\n"
                }

                return .init(content: [.text(text)], isError: false)
            } catch {
                await bridge.reset()
                return .init(
                    content: [.text("Error communicating with RuntimeViewer: \(error.localizedDescription)")],
                    isError: true
                )
            }
        case .error(let errorResult):
            return errorResult
        }

    case "get_selected_type":
        guard let windowIdentifier = params.arguments?["window_identifier"]?.stringValue else {
            return .init(
                content: [.text("Error: 'window_identifier' parameter is required. Use list_windows to get available window identifiers.")],
                isError: true
            )
        }

        switch await connectedClient() {
        case .connected(let client):
            do {
                let response = try await client.selectedType(windowIdentifier: windowIdentifier)

                guard let typeName = response.typeName else {
                    return .init(content: [.text("No type is currently selected in the specified window.")], isError: false)
                }

                var text = "Selected Type:\n"
                text += "  Name: \(response.displayName ?? typeName)\n"
                if let kind = response.typeKind {
                    text += "  Kind: \(kind)\n"
                }
                if let imagePath = response.imagePath {
                    text += "  Image: \(imagePath)\n"
                }
                if let interfaceText = response.interfaceText {
                    text += "\nInterface:\n\(interfaceText)"
                }

                return .init(content: [.text(text)], isError: false)
            } catch {
                await bridge.reset()
                return .init(
                    content: [.text("Error communicating with RuntimeViewer: \(error.localizedDescription)")],
                    isError: true
                )
            }
        case .error(let errorResult):
            return errorResult
        }

    case "get_type_interface":
        guard let windowIdentifier = params.arguments?["window_identifier"]?.stringValue else {
            return .init(
                content: [.text("Error: 'window_identifier' parameter is required. Use list_windows to get available window identifiers.")],
                isError: true
            )
        }
        guard let typeName = params.arguments?["type_name"]?.stringValue else {
            return .init(
                content: [.text("Error: 'type_name' parameter is required.")],
                isError: true
            )
        }
        let imagePath = params.arguments?["image_path"]?.stringValue

        switch await connectedClient() {
        case .connected(let client):
            do {
                let response = try await client.typeInterface(windowIdentifier: windowIdentifier, imagePath: imagePath, typeName: typeName)

                if let error = response.error {
                    return .init(content: [.text("Error: \(error)")], isError: true)
                }

                var text = "Type: \(response.displayName ?? typeName)\n"
                if let kind = response.typeKind {
                    text += "Kind: \(kind)\n"
                }
                if let responseImagePath = response.imagePath {
                    text += "Image: \(responseImagePath)\n"
                }
                if let interfaceText = response.interfaceText {
                    text += "\nInterface:\n\(interfaceText)"
                } else {
                    text += "\nNo interface text available."
                }

                return .init(content: [.text(text)], isError: false)
            } catch {
                await bridge.reset()
                return .init(
                    content: [.text("Error communicating with RuntimeViewer: \(error.localizedDescription)")],
                    isError: true
                )
            }
        case .error(let errorResult):
            return errorResult
        }

    case "list_types":
        guard let windowIdentifier = params.arguments?["window_identifier"]?.stringValue else {
            return .init(
                content: [.text("Error: 'window_identifier' parameter is required. Use list_windows to get available window identifiers.")],
                isError: true
            )
        }
        let imagePath = params.arguments?["image_path"]?.stringValue

        switch await connectedClient() {
        case .connected(let client):
            do {
                let response = try await client.listTypes(windowIdentifier: windowIdentifier, imagePath: imagePath)

                if let error = response.error {
                    return .init(content: [.text("Error: \(error)")], isError: true)
                }

                if response.types.isEmpty {
                    let scope = imagePath.map { "image '\($0)'" } ?? "all loaded images"
                    return .init(content: [.text("No types found in \(scope).")], isError: false)
                }

                // Group types by kind
                var grouped: [String: [MCPRuntimeTypeInfo]] = [:]
                for type in response.types {
                    grouped[type.kind, default: []].append(type)
                }

                let scopeName: String
                if let imagePath {
                    scopeName = String(imagePath.split(separator: "/").last ?? Substring(imagePath))
                } else {
                    scopeName = "all loaded images"
                }
                var text = "Types in \(scopeName):\n"
                text += "Total: \(response.types.count) types\n"
                for (kind, types) in grouped.sorted(by: { $0.key < $1.key }) {
                    text += "\n[\(kind)] (\(types.count)):\n"
                    for type in types {
                        text += "  - \(type.displayName)\n"
                    }
                }

                return .init(content: [.text(text)], isError: false)
            } catch {
                await bridge.reset()
                return .init(
                    content: [.text("Error communicating with RuntimeViewer: \(error.localizedDescription)")],
                    isError: true
                )
            }
        case .error(let errorResult):
            return errorResult
        }

    case "search_types":
        guard let windowIdentifier = params.arguments?["window_identifier"]?.stringValue else {
            return .init(
                content: [.text("Error: 'window_identifier' parameter is required. Use list_windows to get available window identifiers.")],
                isError: true
            )
        }
        guard let query = params.arguments?["query"]?.stringValue else {
            return .init(
                content: [.text("Error: 'query' parameter is required.")],
                isError: true
            )
        }
        let imagePath = params.arguments?["image_path"]?.stringValue

        switch await connectedClient() {
        case .connected(let client):
            do {
                let response = try await client.searchTypes(windowIdentifier: windowIdentifier, query: query, imagePath: imagePath)

                if let error = response.error {
                    return .init(content: [.text("Error: \(error)")], isError: true)
                }

                if response.types.isEmpty {
                    var text = "No types matching '\(query)'"
                    if let imagePath {
                        text += " in image '\(imagePath)'"
                    }
                    text += "."
                    return .init(content: [.text(text)], isError: false)
                }

                var text = "Search results for '\(query)':\n"
                text += "Found \(response.types.count) matching types\n\n"
                for type in response.types {
                    let imageName = type.imagePath.split(separator: "/").last ?? Substring(type.imagePath)
                    text += "  \(type.displayName) [\(type.kind)] â€” \(imageName)\n"
                }

                return .init(content: [.text(text)], isError: false)
            } catch {
                await bridge.reset()
                return .init(
                    content: [.text("Error communicating with RuntimeViewer: \(error.localizedDescription)")],
                    isError: true
                )
            }
        case .error(let errorResult):
            return errorResult
        }

    case "grep_type_interface":
        guard let windowIdentifier = params.arguments?["window_identifier"]?.stringValue else {
            return .init(
                content: [.text("Error: 'window_identifier' parameter is required. Use list_windows to get available window identifiers.")],
                isError: true
            )
        }
        let imagePath = params.arguments?["image_path"]?.stringValue
        guard let pattern = params.arguments?["pattern"]?.stringValue else {
            return .init(
                content: [.text("Error: 'pattern' parameter is required.")],
                isError: true
            )
        }

        switch await connectedClient() {
        case .connected(let client):
            do {
                let response = try await client.grepTypeInterface(windowIdentifier: windowIdentifier, imagePath: imagePath, pattern: pattern)

                if let error = response.error {
                    return .init(content: [.text("Error: \(error)")], isError: true)
                }

                if response.matches.isEmpty {
                    let scope = imagePath.map { "image '\($0)'" } ?? "all loaded images"
                    return .init(content: [.text("No matches for '\(pattern)' in \(scope).")], isError: false)
                }

                let scopeName: String
                if let imagePath {
                    scopeName = String(imagePath.split(separator: "/").last ?? Substring(imagePath))
                } else {
                    scopeName = "all loaded images"
                }
                var text = "Grep results for '\(pattern)' in \(scopeName):\n"
                text += "Found matches in \(response.matches.count) types\n"
                for match in response.matches {
                    text += "\n--- \(match.typeName) [\(match.kind)] ---\n"
                    for line in match.matchingLines {
                        text += "  \(line)\n"
                    }
                }

                return .init(content: [.text(text)], isError: false)
            } catch {
                await bridge.reset()
                return .init(
                    content: [.text("Error communicating with RuntimeViewer: \(error.localizedDescription)")],
                    isError: true
                )
            }
        case .error(let errorResult):
            return errorResult
        }

    default:
        throw MCPError.invalidParams("Unknown tool: \(params.name)")
    }
}

// Start MCP server with stdio transport
let transport = StdioTransport()
try await server.start(transport: transport)
await server.waitUntilCompleted()

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 70;
	objects = {

/* Begin PBXBuildFile section */
		E91CD9972C2127AD00C989CC /* EventMonitor.swift in Sources */ = {isa = PBXBuildFile; fileRef = E91CD9962C2127AD00C989CC /* EventMonitor.swift */; };
		E92124642F447AE1007481E4 /* ExportingState.swift in Sources */ = {isa = PBXBuildFile; fileRef = E92124632F447AE1007481E4 /* ExportingState.swift */; };
		E921246B2F447BA1007481E4 /* ExportingConfigurationViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E921246A2F447BA1007481E4 /* ExportingConfigurationViewModel.swift */; };
		E921246D2F447BBF007481E4 /* ExportingConfigurationViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E921246C2F447BBF007481E4 /* ExportingConfigurationViewController.swift */; };
		E921246F2F447BE1007481E4 /* ExportingProgressViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E921246E2F447BE1007481E4 /* ExportingProgressViewModel.swift */; };
		E92124712F447C7F007481E4 /* ExportingProgressViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E92124702F447C7F007481E4 /* ExportingProgressViewController.swift */; };
		E92124732F447C94007481E4 /* ExportingViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E92124722F447C94007481E4 /* ExportingViewController.swift */; };
		E927C22E2E9444F300084A7B /* AppIcon.icon in Resources */ = {isa = PBXBuildFile; fileRef = E927C22D2E9444F300084A7B /* AppIcon.icon */; };
		E9381D032EC8BFDE007F6333 /* RuntimeViewerCatalystHelper.app in Embed Helpers */ = {isa = PBXBuildFile; fileRef = E9C9E9EF2C2D379200C4AA34 /* RuntimeViewerCatalystHelper.app */; settings = {ATTRIBUTES = (RemoveHeadersOnCopy, ); }; };
		E942AC882C274DF600A2F3D3 /* RuntimeViewerApplication in Frameworks */ = {isa = PBXBuildFile; productRef = E942AC872C274DF600A2F3D3 /* RuntimeViewerApplication */; };
		E942ACBF2C28865100A2F3D3 /* MainRoute.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942ACBE2C28865100A2F3D3 /* MainRoute.swift */; };
		E9432FE62C0D614900362862 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9432FE52C0D614900362862 /* AppDelegate.swift */; };
		E9432FE82C0D614A00362862 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = E9432FE72C0D614A00362862 /* Assets.xcassets */; };
		E9432FEB2C0D614A00362862 /* Base in Resources */ = {isa = PBXBuildFile; fileRef = E9432FEA2C0D614A00362862 /* Base */; };
		E94330182C0DA62500362862 /* SidebarRootDirectoryViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E94330172C0DA62500362862 /* SidebarRootDirectoryViewController.swift */; };
		E943301C2C0DB75B00362862 /* Then.swift in Sources */ = {isa = PBXBuildFile; fileRef = E943301B2C0DB75B00362862 /* Then.swift */; };
		E947C36A2C2A4D0400296B2E /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = E947C3692C2A4D0400296B2E /* AppDelegate.swift */; };
		E947C36C2C2A4D0400296B2E /* SceneDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = E947C36B2C2A4D0400296B2E /* SceneDelegate.swift */; };
		E947C3732C2A4D0500296B2E /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = E947C3722C2A4D0500296B2E /* Assets.xcassets */; };
		E94BA6962E7EEB64006B553D /* SidebarRootTableRowView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E94BA6952E7EEB64006B553D /* SidebarRootTableRowView.swift */; };
		E94E36C62CF84AF8006101C8 /* AttachToProcessViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E94E36C52CF84AF8006101C8 /* AttachToProcessViewController.swift */; };
		E94E36C92CF87BD6006101C8 /* RuntimeViewerSymbols.swift in Sources */ = {isa = PBXBuildFile; fileRef = E94E36C82CF87BD6006101C8 /* RuntimeViewerSymbols.swift */; };
		E9530A3C2D9D5898008FBC7F /* SIPChecker.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9530A3B2D9D5898008FBC7F /* SIPChecker.swift */; };
		E96CF5332EC7A4A600CBC159 /* RuntimeSource+.swift in Sources */ = {isa = PBXBuildFile; fileRef = E96CF5322EC7A4A600CBC159 /* RuntimeSource+.swift */; };
		E96DE1E32F0ACE8D00F9BAB2 /* CheckboxButton+.swift in Sources */ = {isa = PBXBuildFile; fileRef = E96DE1E22F0ACE8D00F9BAB2 /* CheckboxButton+.swift */; };
		E975449A2C42BA5B00CC9DDD /* LoadFrameworksViewController.xib in Resources */ = {isa = PBXBuildFile; fileRef = E97544992C42BA5B00CC9DDD /* LoadFrameworksViewController.xib */; };
		E975449B2C42BA5B00CC9DDD /* LoadFrameworksViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E97544982C42BA5B00CC9DDD /* LoadFrameworksViewController.swift */; };
		E97544A42C42D11C00CC9DDD /* GenerationOptionsViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E97544A32C42D11C00CC9DDD /* GenerationOptionsViewModel.swift */; };
		E978F2792F1BA1DE004C09B4 /* com.mxiris.runtimeviewer.service.plist in Embed LaunchDaemon */ = {isa = PBXBuildFile; fileRef = E978F2782F1BA1A1004C09B4 /* com.mxiris.runtimeviewer.service.plist */; };
		E97B1C972EC9AE5D00FF5375 /* UIDebugger.m in Sources */ = {isa = PBXBuildFile; fileRef = E97B1C962EC9AE5D00FF5375 /* UIDebugger.m */; };
		E985A9CE2D9AF505005A573C /* RuntimeViewerCore in Frameworks */ = {isa = PBXBuildFile; productRef = E985A9CD2D9AF505005A573C /* RuntimeViewerCore */; };
		E985A9DA2D9AF7E5005A573C /* RuntimeViewerService in Frameworks */ = {isa = PBXBuildFile; productRef = E985A9D92D9AF7E5005A573C /* RuntimeViewerService */; };
		E9862A212F36F60800139991 /* MCP in Frameworks */ = {isa = PBXBuildFile; productRef = E9862A202F36F60800139991 /* MCP */; };
		E9862A232F36F61200139991 /* RuntimeViewerMCPShared in Frameworks */ = {isa = PBXBuildFile; productRef = E9862A222F36F61200139991 /* RuntimeViewerMCPShared */; };
		E9862A252F36F65600139991 /* RuntimeViewerMCPServer in Embed MCP Server */ = {isa = PBXBuildFile; fileRef = E9862A0B2F36F58900139991 /* RuntimeViewerMCPServer */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };
		E9862AD32F377D2B00139991 /* RuntimeViewerMCPBridge in Frameworks */ = {isa = PBXBuildFile; productRef = E9862AD22F377D2B00139991 /* RuntimeViewerMCPBridge */; };
		E9862AD52F377E9C00139991 /* AppMCPBridgeWindowProvider.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9862AD42F377E9C00139991 /* AppMCPBridgeWindowProvider.swift */; };
		E98BEF542F1CBE180041DB20 /* RuntimeViewerService in Frameworks */ = {isa = PBXBuildFile; productRef = E98BEF532F1CBE180041DB20 /* RuntimeViewerService */; };
		E98BEF552F1CBE870041DB20 /* com.mxiris.runtimeviewer.service in Embed LaunchServices */ = {isa = PBXBuildFile; fileRef = E9EC5BC52F1CBDBA00859091 /* com.mxiris.runtimeviewer.service */; settings = {ATTRIBUTES = (CodeSignOnCopy, ); }; };
		E98BF6282F1D4A690041DB20 /* RuntimeViewerCatalystExtensions in Frameworks */ = {isa = PBXBuildFile; productRef = E98BF6272F1D4A690041DB20 /* RuntimeViewerCatalystExtensions */; };
		E98BF62A2F1D4A750041DB20 /* RuntimeViewerCatalystExtensions in Frameworks */ = {isa = PBXBuildFile; productRef = E98BF6292F1D4A750041DB20 /* RuntimeViewerCatalystExtensions */; };
		E9935B922F44886A006DB4EC /* ExportingCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9935B912F44886A006DB4EC /* ExportingCoordinator.swift */; };
		E9935B952F448900006DB4EC /* ExportingCompletionViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9935B942F448900006DB4EC /* ExportingCompletionViewModel.swift */; };
		E9935B972F448910006DB4EC /* ExportingCompletionViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9935B962F448910006DB4EC /* ExportingCompletionViewController.swift */; };
		E995B8942ED97D140083D9D7 /* RuntimeEngineManager.swift in Sources */ = {isa = PBXBuildFile; fileRef = E995B8932ED97C130083D9D7 /* RuntimeEngineManager.swift */; };
		E995B8972F1CA0000083D9D7 /* RuntimeConnectionNotificationService.swift in Sources */ = {isa = PBXBuildFile; fileRef = E995B8962F1CA0000083D9D7 /* RuntimeConnectionNotificationService.swift */; };
		E99AE0BC2CBD4A840028B11E /* Document.swift in Sources */ = {isa = PBXBuildFile; fileRef = E99AE0BB2CBD4A840028B11E /* Document.swift */; };
		E99E61612C129DC2002C1A3D /* ContentTextViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E99E61602C129DC2002C1A3D /* ContentTextViewController.swift */; };
		E9A8252D2C0DECE400D9A85D /* SidebarCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A8252C2C0DECE400D9A85D /* SidebarCoordinator.swift */; };
		E9A825382C0E085200D9A85D /* MainCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825372C0E085200D9A85D /* MainCoordinator.swift */; };
		E9A8253A2C0E095500D9A85D /* SidebarRuntimeObjectViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825392C0E095500D9A85D /* SidebarRuntimeObjectViewController.swift */; };
		E9A825422C0E0B2300D9A85D /* MainWindowController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825412C0E0B2300D9A85D /* MainWindowController.swift */; };
		E9A825442C0E0B2800D9A85D /* MainSplitViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825432C0E0B2800D9A85D /* MainSplitViewController.swift */; };
		E9A825462C0E0B4900D9A85D /* ViewControllers.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825452C0E0B4900D9A85D /* ViewControllers.swift */; };
		E9A8254A2C0E0E9F00D9A85D /* ContentCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825492C0E0E9F00D9A85D /* ContentCoordinator.swift */; };
		E9A8254C2C0E0EA600D9A85D /* InspectorCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A8254B2C0E0EA600D9A85D /* InspectorCoordinator.swift */; };
		E9A825502C0E0EB400D9A85D /* InspectorNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A8254F2C0E0EB400D9A85D /* InspectorNavigationController.swift */; };
		E9A825522C0E0F9F00D9A85D /* ContentNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825512C0E0F9F00D9A85D /* ContentNavigationController.swift */; };
		E9A825542C0E0FBD00D9A85D /* SidebarNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825532C0E0FBD00D9A85D /* SidebarNavigationController.swift */; };
		E9A825562C0E0FF300D9A85D /* ContentPlaceholderViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825552C0E0FF300D9A85D /* ContentPlaceholderViewController.swift */; };
		E9A825582C0E202600D9A85D /* MainViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A825572C0E202600D9A85D /* MainViewModel.swift */; };
		E9AA36222C3089AB00A9B2E4 /* InspectorPlaceholderViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9AA36212C3089AB00A9B2E4 /* InspectorPlaceholderViewController.swift */; };
		E9B4C6562F35E9C800823FE0 /* main.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9B4C6542F35E9C800823FE0 /* main.swift */; };
		E9C9E9D72C2D161000C4AA34 /* RuntimeViewerCatalystHelperPlugin.bundle in Embed PlugIns */ = {isa = PBXBuildFile; fileRef = E9E900DC2C2CF9A500FADDCC /* RuntimeViewerCatalystHelperPlugin.bundle */; platformFilter = maccatalyst; settings = {ATTRIBUTES = (CodeSignOnCopy, RemoveHeadersOnCopy, ); }; };
		E9C9E9DD2C2D169D00C4AA34 /* AppKitPlugin.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9C9E9DB2C2D169D00C4AA34 /* AppKitPlugin.swift */; };
		E9C9E9DE2C2D169D00C4AA34 /* AppKitPluginImpl.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9C9E9DC2C2D169D00C4AA34 /* AppKitPluginImpl.swift */; };
		E9C9E9DF2C2D16B000C4AA34 /* AppKitPlugin.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9C9E9DB2C2D169D00C4AA34 /* AppKitPlugin.swift */; };
		E9C9E9E02C2D172600C4AA34 /* AppKitBridge.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9A18BA72C2978DF00689B49 /* AppKitBridge.swift */; };
		E9CE07AF2C148FA00070A6E8 /* MainToolbarController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9CE07AE2C148FA00070A6E8 /* MainToolbarController.swift */; };
		E9CE07B92C1497B30070A6E8 /* SidebarRootTableCellView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9CE07B82C1497B30070A6E8 /* SidebarRootTableCellView.swift */; };
		E9D470632F12A52A008BF7A9 /* SidebarRootViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9D470622F12A52A008BF7A9 /* SidebarRootViewController.swift */; };
		E9D470652F134210008BF7A9 /* SidebarRootTabViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9D470642F134210008BF7A9 /* SidebarRootTabViewController.swift */; };
		E9D470672F136E2A008BF7A9 /* SidebarRuntimeObjectListViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9D470662F136E2A008BF7A9 /* SidebarRuntimeObjectListViewController.swift */; };
		E9D470692F136E52008BF7A9 /* SidebarRuntimeObjectBookmarkViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9D470682F136E52008BF7A9 /* SidebarRuntimeObjectBookmarkViewController.swift */; };
		E9D4706B2F136E7F008BF7A9 /* SidebarRuntimeObjectTabViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9D4706A2F136E7F008BF7A9 /* SidebarRuntimeObjectTabViewController.swift */; };
		E9E900EB2C2D0D5B00FADDCC /* main.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9E900EA2C2D0D5B00FADDCC /* main.swift */; };
		E9EB37AC2C397024003E2859 /* InspectorClassViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9EB37AB2C397024003E2859 /* InspectorClassViewController.swift */; };
		E9EEE84B2E071704008D85D1 /* CommonLoadingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9EEE84A2E071704008D85D1 /* CommonLoadingView.swift */; };
		E9EEF7612E084D7D008D85D1 /* SidebarRuntimeObjectCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9EEF7602E084D7D008D85D1 /* SidebarRuntimeObjectCoordinator.swift */; };
		E9EEF7652E08540B008D85D1 /* ContentTextView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9EEF7642E08540B008D85D1 /* ContentTextView.swift */; };
		E9EEF7672E085420008D85D1 /* InspectorDisclosureView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9EEF7662E085420008D85D1 /* InspectorDisclosureView.swift */; };
		E9EEF7692E085426008D85D1 /* InspectorClassHierarchyView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9EEF7682E085426008D85D1 /* InspectorClassHierarchyView.swift */; };
		E9EEF7712E086841008D85D1 /* AttachToProcessViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9EEF7702E086841008D85D1 /* AttachToProcessViewModel.swift */; };
		E9F0A57E2C305C01001C36FB /* GenerationOptionsViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9F0A57D2C305C01001C36FB /* GenerationOptionsViewController.swift */; };
		E9F11E0B2F123EEC0052B0A3 /* SidebarRootCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9F11E0A2F123EEC0052B0A3 /* SidebarRootCoordinator.swift */; };
		E9F11E162F12671D0052B0A3 /* TabViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9F11E152F12671D0052B0A3 /* TabViewController.swift */; };
		E9F11E182F12812B0052B0A3 /* SidebarRootBookmarkViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9F11E172F12812B0052B0A3 /* SidebarRootBookmarkViewController.swift */; };
		E9F759422CF603DD00BE7A5F /* SidebarRuntimeObjectCellView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9F759412CF603DD00BE7A5F /* SidebarRuntimeObjectCellView.swift */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		E94C1B8E2F35E7AC005DF968 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E98BF5E92F1CE6810041DB20 /* RuntimeViewerServer.xcodeproj */;
			proxyType = 2;
			remoteGlobalIDString = E994E2962F323A51009DD28A;
			remoteInfo = RuntimeViewerMobileServer;
		};
		E9862A262F36F65D00139991 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E9432FDA2C0D614900362862 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = E9862A0A2F36F58900139991;
			remoteInfo = RuntimeViewerServer;
		};
		E9862A282F36F66400139991 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E98BF5E92F1CE6810041DB20 /* RuntimeViewerServer.xcodeproj */;
			proxyType = 1;
			remoteGlobalIDString = E978F9182F1BBB38004C09B4;
			remoteInfo = RuntimeViewerServer;
		};
		E98BEF562F1CBEAF0041DB20 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E9432FDA2C0D614900362862 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = E9EC5BC42F1CBDBA00859091;
			remoteInfo = com.mxiris.runtimeviewer.service;
		};
		E98BF6362F1D4ABB0041DB20 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E98BF5E92F1CE6810041DB20 /* RuntimeViewerServer.xcodeproj */;
			proxyType = 2;
			remoteGlobalIDString = E978F9192F1BBB38004C09B4;
			remoteInfo = RuntimeViewerServer;
		};
		E9C9E9D82C2D161000C4AA34 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = E9432FDA2C0D614900362862 /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = E9E900DB2C2CF9A500FADDCC;
			remoteInfo = RuntimeViewerCatalystHelperPlugin;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		E9862A092F36F58900139991 /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = /usr/share/man/man1/;
			dstSubfolderSpec = 0;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 1;
		};
		E9862A242F36F64700139991 /* Embed MCP Server */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 6;
			files = (
				E9862A252F36F65600139991 /* RuntimeViewerMCPServer in Embed MCP Server */,
			);
			name = "Embed MCP Server";
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9C9E9CC2C2D0F1B00C4AA34 /* Embed LaunchServices */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = Contents/Library/LaunchServices;
			dstSubfolderSpec = 1;
			files = (
				E98BEF552F1CBE870041DB20 /* com.mxiris.runtimeviewer.service in Embed LaunchServices */,
			);
			name = "Embed LaunchServices";
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9C9E9DA2C2D161000C4AA34 /* Embed PlugIns */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 13;
			files = (
				E9C9E9D72C2D161000C4AA34 /* RuntimeViewerCatalystHelperPlugin.bundle in Embed PlugIns */,
			);
			name = "Embed PlugIns";
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9C9E9EB2C2D33F500C4AA34 /* Embed Helpers */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = ../Applications;
			dstSubfolderSpec = 6;
			files = (
				E9381D032EC8BFDE007F6333 /* RuntimeViewerCatalystHelper.app in Embed Helpers */,
			);
			name = "Embed Helpers";
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9EC5BC32F1CBDBA00859091 /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = /usr/share/man/man1/;
			dstSubfolderSpec = 0;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 1;
		};
		E9F6CD052D9A7B1700DBFB50 /* Embed LaunchDaemon */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = Contents/Library/LaunchDaemons;
			dstSubfolderSpec = 1;
			files = (
				E978F2792F1BA1DE004C09B4 /* com.mxiris.runtimeviewer.service.plist in Embed LaunchDaemon */,
			);
			name = "Embed LaunchDaemon";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		E91CD9962C2127AD00C989CC /* EventMonitor.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = EventMonitor.swift; sourceTree = "<group>"; };
		E92124632F447AE1007481E4 /* ExportingState.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingState.swift; sourceTree = "<group>"; };
		E921246A2F447BA1007481E4 /* ExportingConfigurationViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingConfigurationViewModel.swift; sourceTree = "<group>"; };
		E921246C2F447BBF007481E4 /* ExportingConfigurationViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingConfigurationViewController.swift; sourceTree = "<group>"; };
		E921246E2F447BE1007481E4 /* ExportingProgressViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingProgressViewModel.swift; sourceTree = "<group>"; };
		E92124702F447C7F007481E4 /* ExportingProgressViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingProgressViewController.swift; sourceTree = "<group>"; };
		E92124722F447C94007481E4 /* ExportingViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingViewController.swift; sourceTree = "<group>"; };
		E927C22D2E9444F300084A7B /* AppIcon.icon */ = {isa = PBXFileReference; lastKnownFileType = folder.iconcomposer.icon; name = AppIcon.icon; path = ../Resources/AppIcon.icon; sourceTree = SOURCE_ROOT; };
		E942ACBE2C28865100A2F3D3 /* MainRoute.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainRoute.swift; sourceTree = "<group>"; };
		E9432FE22C0D614900362862 /* RuntimeViewer.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = RuntimeViewer.app; sourceTree = BUILT_PRODUCTS_DIR; };
		E9432FE52C0D614900362862 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		E9432FE72C0D614A00362862 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		E9432FEA2C0D614A00362862 /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.xib; name = Base; path = Base.lproj/MainMenu.xib; sourceTree = "<group>"; };
		E9432FEC2C0D614A00362862 /* RuntimeViewerUsingAppKit.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = RuntimeViewerUsingAppKit.entitlements; sourceTree = "<group>"; };
		E94330172C0DA62500362862 /* SidebarRootDirectoryViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootDirectoryViewController.swift; sourceTree = "<group>"; };
		E943301B2C0DB75B00362862 /* Then.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Then.swift; sourceTree = "<group>"; };
		E947C3672C2A4D0400296B2E /* RuntimeViewerCatalystHelper.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = RuntimeViewerCatalystHelper.app; sourceTree = BUILT_PRODUCTS_DIR; };
		E947C3692C2A4D0400296B2E /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		E947C36B2C2A4D0400296B2E /* SceneDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SceneDelegate.swift; sourceTree = "<group>"; };
		E947C3722C2A4D0500296B2E /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		E947C3772C2A4D0500296B2E /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		E94BA68D2E7EA992006B553D /* UXKit.xcframework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.xcframework; name = UXKit.xcframework; path = RuntimeViewerUsingAppKit/UXKit.xcframework; sourceTree = "<group>"; };
		E94BA6952E7EEB64006B553D /* SidebarRootTableRowView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootTableRowView.swift; sourceTree = "<group>"; };
		E94E36C52CF84AF8006101C8 /* AttachToProcessViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttachToProcessViewController.swift; sourceTree = "<group>"; };
		E94E36C82CF87BD6006101C8 /* RuntimeViewerSymbols.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RuntimeViewerSymbols.swift; sourceTree = "<group>"; };
		E9530A3B2D9D5898008FBC7F /* SIPChecker.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SIPChecker.swift; sourceTree = "<group>"; };
		E95CDA652DAA6FA300D97B03 /* Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
		E95CDA662DAA6FA900D97B03 /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		E95CDA672DAA970300D97B03 /* Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Debug.xcconfig; sourceTree = "<group>"; };
		E95CDA682DAA970900D97B03 /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Release.xcconfig; sourceTree = "<group>"; };
		E9668FFB2CEF7140007B344A /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		E9668FFC2CEF7140007B344A /* launchd.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = launchd.plist; sourceTree = "<group>"; };
		E96CF5322EC7A4A600CBC159 /* RuntimeSource+.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "RuntimeSource+.swift"; sourceTree = "<group>"; };
		E96DE1E22F0ACE8D00F9BAB2 /* CheckboxButton+.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "CheckboxButton+.swift"; sourceTree = "<group>"; };
		E97544982C42BA5B00CC9DDD /* LoadFrameworksViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = LoadFrameworksViewController.swift; sourceTree = "<group>"; };
		E97544992C42BA5B00CC9DDD /* LoadFrameworksViewController.xib */ = {isa = PBXFileReference; lastKnownFileType = file.xib; path = LoadFrameworksViewController.xib; sourceTree = "<group>"; };
		E97544A32C42D11C00CC9DDD /* GenerationOptionsViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GenerationOptionsViewModel.swift; sourceTree = "<group>"; };
		E978F2782F1BA1A1004C09B4 /* com.mxiris.runtimeviewer.service.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = com.mxiris.runtimeviewer.service.plist; sourceTree = "<group>"; };
		E97B1C952EC9AE5D00FF5375 /* UIDebugger.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = UIDebugger.h; sourceTree = "<group>"; };
		E97B1C962EC9AE5D00FF5375 /* UIDebugger.m */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.objc; path = UIDebugger.m; sourceTree = "<group>"; };
		E9862A0B2F36F58900139991 /* RuntimeViewerMCPServer */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = RuntimeViewerMCPServer; sourceTree = BUILT_PRODUCTS_DIR; };
		E9862AD42F377E9C00139991 /* AppMCPBridgeWindowProvider.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppMCPBridgeWindowProvider.swift; sourceTree = "<group>"; };
		E98BF5E92F1CE6810041DB20 /* RuntimeViewerServer.xcodeproj */ = {isa = PBXFileReference; lastKnownFileType = "wrapper.pb-project"; name = RuntimeViewerServer.xcodeproj; path = ../RuntimeViewerServer/RuntimeViewerServer.xcodeproj; sourceTree = SOURCE_ROOT; };
		E9935B912F44886A006DB4EC /* ExportingCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingCoordinator.swift; sourceTree = "<group>"; };
		E9935B942F448900006DB4EC /* ExportingCompletionViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingCompletionViewModel.swift; sourceTree = "<group>"; };
		E9935B962F448910006DB4EC /* ExportingCompletionViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ExportingCompletionViewController.swift; sourceTree = "<group>"; };
		E995B8932ED97C130083D9D7 /* RuntimeEngineManager.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RuntimeEngineManager.swift; sourceTree = "<group>"; };
		E995B8962F1CA0000083D9D7 /* RuntimeConnectionNotificationService.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RuntimeConnectionNotificationService.swift; sourceTree = "<group>"; };
		E99AE0BB2CBD4A840028B11E /* Document.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Document.swift; sourceTree = "<group>"; };
		E99E61602C129DC2002C1A3D /* ContentTextViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentTextViewController.swift; sourceTree = "<group>"; };
		E9A18BA72C2978DF00689B49 /* AppKitBridge.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppKitBridge.swift; sourceTree = "<group>"; };
		E9A8252C2C0DECE400D9A85D /* SidebarCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarCoordinator.swift; sourceTree = "<group>"; };
		E9A825372C0E085200D9A85D /* MainCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainCoordinator.swift; sourceTree = "<group>"; };
		E9A825392C0E095500D9A85D /* SidebarRuntimeObjectViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRuntimeObjectViewController.swift; sourceTree = "<group>"; };
		E9A825412C0E0B2300D9A85D /* MainWindowController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainWindowController.swift; sourceTree = "<group>"; };
		E9A825432C0E0B2800D9A85D /* MainSplitViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainSplitViewController.swift; sourceTree = "<group>"; };
		E9A825452C0E0B4900D9A85D /* ViewControllers.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ViewControllers.swift; sourceTree = "<group>"; };
		E9A825492C0E0E9F00D9A85D /* ContentCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentCoordinator.swift; sourceTree = "<group>"; };
		E9A8254B2C0E0EA600D9A85D /* InspectorCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorCoordinator.swift; sourceTree = "<group>"; };
		E9A8254F2C0E0EB400D9A85D /* InspectorNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorNavigationController.swift; sourceTree = "<group>"; };
		E9A825512C0E0F9F00D9A85D /* ContentNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentNavigationController.swift; sourceTree = "<group>"; };
		E9A825532C0E0FBD00D9A85D /* SidebarNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarNavigationController.swift; sourceTree = "<group>"; };
		E9A825552C0E0FF300D9A85D /* ContentPlaceholderViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentPlaceholderViewController.swift; sourceTree = "<group>"; };
		E9A825572C0E202600D9A85D /* MainViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainViewModel.swift; sourceTree = "<group>"; };
		E9AA36212C3089AB00A9B2E4 /* InspectorPlaceholderViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorPlaceholderViewController.swift; sourceTree = "<group>"; };
		E9B4C6542F35E9C800823FE0 /* main.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = main.swift; sourceTree = "<group>"; };
		E9C9E9C92C2D0E3C00C4AA34 /* Config.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Config.xcconfig; sourceTree = "<group>"; };
		E9C9E9CE2C2D10C600C4AA34 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		E9C9E9DB2C2D169D00C4AA34 /* AppKitPlugin.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppKitPlugin.swift; sourceTree = "<group>"; };
		E9C9E9DC2C2D169D00C4AA34 /* AppKitPluginImpl.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppKitPluginImpl.swift; sourceTree = "<group>"; };
		E9C9E9EF2C2D379200C4AA34 /* RuntimeViewerCatalystHelper.app */ = {isa = PBXFileReference; lastKnownFileType = wrapper.application; path = RuntimeViewerCatalystHelper.app; sourceTree = "<group>"; };
		E9CE07AE2C148FA00070A6E8 /* MainToolbarController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainToolbarController.swift; sourceTree = "<group>"; };
		E9CE07B82C1497B30070A6E8 /* SidebarRootTableCellView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootTableCellView.swift; sourceTree = "<group>"; };
		E9D470622F12A52A008BF7A9 /* SidebarRootViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootViewController.swift; sourceTree = "<group>"; };
		E9D470642F134210008BF7A9 /* SidebarRootTabViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootTabViewController.swift; sourceTree = "<group>"; };
		E9D470662F136E2A008BF7A9 /* SidebarRuntimeObjectListViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRuntimeObjectListViewController.swift; sourceTree = "<group>"; };
		E9D470682F136E52008BF7A9 /* SidebarRuntimeObjectBookmarkViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRuntimeObjectBookmarkViewController.swift; sourceTree = "<group>"; };
		E9D4706A2F136E7F008BF7A9 /* SidebarRuntimeObjectTabViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRuntimeObjectTabViewController.swift; sourceTree = "<group>"; };
		E9E900D72C2CF96500FADDCC /* RuntimeViewerCatalystHelper.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = RuntimeViewerCatalystHelper.entitlements; sourceTree = "<group>"; };
		E9E900DC2C2CF9A500FADDCC /* RuntimeViewerCatalystHelperPlugin.bundle */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RuntimeViewerCatalystHelperPlugin.bundle; sourceTree = BUILT_PRODUCTS_DIR; };
		E9E900E82C2D0D5B00FADDCC /* com.JH.RuntimeViewerService */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = com.JH.RuntimeViewerService; sourceTree = BUILT_PRODUCTS_DIR; };
		E9E900EA2C2D0D5B00FADDCC /* main.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = main.swift; sourceTree = "<group>"; };
		E9EB37AB2C397024003E2859 /* InspectorClassViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorClassViewController.swift; sourceTree = "<group>"; };
		E9EC5BC52F1CBDBA00859091 /* com.mxiris.runtimeviewer.service */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = com.mxiris.runtimeviewer.service; sourceTree = BUILT_PRODUCTS_DIR; };
		E9EEE84A2E071704008D85D1 /* CommonLoadingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = CommonLoadingView.swift; sourceTree = "<group>"; };
		E9EEF7602E084D7D008D85D1 /* SidebarRuntimeObjectCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRuntimeObjectCoordinator.swift; sourceTree = "<group>"; };
		E9EEF7642E08540B008D85D1 /* ContentTextView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentTextView.swift; sourceTree = "<group>"; };
		E9EEF7662E085420008D85D1 /* InspectorDisclosureView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorDisclosureView.swift; sourceTree = "<group>"; };
		E9EEF7682E085426008D85D1 /* InspectorClassHierarchyView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorClassHierarchyView.swift; sourceTree = "<group>"; };
		E9EEF7702E086841008D85D1 /* AttachToProcessViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AttachToProcessViewModel.swift; sourceTree = "<group>"; };
		E9F0A57D2C305C01001C36FB /* GenerationOptionsViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = GenerationOptionsViewController.swift; sourceTree = "<group>"; };
		E9F11E0A2F123EEC0052B0A3 /* SidebarRootCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootCoordinator.swift; sourceTree = "<group>"; };
		E9F11E152F12671D0052B0A3 /* TabViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TabViewController.swift; sourceTree = "<group>"; };
		E9F11E172F12812B0052B0A3 /* SidebarRootBookmarkViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootBookmarkViewController.swift; sourceTree = "<group>"; };
		E9F2E9B32ED3BCFC001DCC3E /* Shared.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = Shared.xcconfig; sourceTree = "<group>"; };
		E9F2E9B52ED3BD2B001DCC3E /* Shared-Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Shared-Release.xcconfig"; sourceTree = "<group>"; };
		E9F2E9B72ED3BD36001DCC3E /* Shared-Debug.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; path = "Shared-Debug.xcconfig"; sourceTree = "<group>"; };
		E9F759412CF603DD00BE7A5F /* SidebarRuntimeObjectCellView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRuntimeObjectCellView.swift; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFileSystemSynchronizedRootGroup section */
		E9862A0C2F36F58900139991 /* RuntimeViewerMCPServer */ = {isa = PBXFileSystemSynchronizedRootGroup; explicitFileTypes = {}; explicitFolders = (); path = RuntimeViewerMCPServer; sourceTree = "<group>"; };
/* End PBXFileSystemSynchronizedRootGroup section */

/* Begin PBXFrameworksBuildPhase section */
		E9432FDF2C0D614900362862 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E98BF62A2F1D4A750041DB20 /* RuntimeViewerCatalystExtensions in Frameworks */,
				E9862AD32F377D2B00139991 /* RuntimeViewerMCPBridge in Frameworks */,
				E942AC882C274DF600A2F3D3 /* RuntimeViewerApplication in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E947C3642C2A4D0400296B2E /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9862A082F36F58900139991 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9862A212F36F60800139991 /* MCP in Frameworks */,
				E9862A232F36F61200139991 /* RuntimeViewerMCPShared in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9E900D92C2CF9A500FADDCC /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E98BF6282F1D4A690041DB20 /* RuntimeViewerCatalystExtensions in Frameworks */,
				E985A9CE2D9AF505005A573C /* RuntimeViewerCore in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9E900E52C2D0D5B00FADDCC /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E985A9DA2D9AF7E5005A573C /* RuntimeViewerService in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9EC5BC22F1CBDBA00859091 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E98BEF542F1CBE180041DB20 /* RuntimeViewerService in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		E92CB2E52F41E7560091450B /* Exporting */ = {
			isa = PBXGroup;
			children = (
				E9935B912F44886A006DB4EC /* ExportingCoordinator.swift */,
				E92124722F447C94007481E4 /* ExportingViewController.swift */,
				E92124632F447AE1007481E4 /* ExportingState.swift */,
				E921246A2F447BA1007481E4 /* ExportingConfigurationViewModel.swift */,
				E921246C2F447BBF007481E4 /* ExportingConfigurationViewController.swift */,
				E921246E2F447BE1007481E4 /* ExportingProgressViewModel.swift */,
				E92124702F447C7F007481E4 /* ExportingProgressViewController.swift */,
				E9935B942F448900006DB4EC /* ExportingCompletionViewModel.swift */,
				E9935B962F448910006DB4EC /* ExportingCompletionViewController.swift */,
			);
			path = Exporting;
			sourceTree = "<group>";
		};
		E9432FD92C0D614900362862 = {
			isa = PBXGroup;
			children = (
				E98BF5E92F1CE6810041DB20 /* RuntimeViewerServer.xcodeproj */,
				E9F2E9B32ED3BCFC001DCC3E /* Shared.xcconfig */,
				E9F2E9B72ED3BD36001DCC3E /* Shared-Debug.xcconfig */,
				E9F2E9B52ED3BD2B001DCC3E /* Shared-Release.xcconfig */,
				E927C22D2E9444F300084A7B /* AppIcon.icon */,
				E9C9E9EF2C2D379200C4AA34 /* RuntimeViewerCatalystHelper.app */,
				E9432FE42C0D614900362862 /* RuntimeViewerUsingAppKit */,
				E947C3682C2A4D0400296B2E /* RuntimeViewerCatalystHelper */,
				E9E900E02C2CF9B000FADDCC /* RuntimeViewerCatalystHelperPlugin */,
				E9E900E92C2D0D5B00FADDCC /* com.JH.RuntimeViewerService */,
				E9B4C6552F35E9C800823FE0 /* com.mxiris.runtimeviewer.service */,
				E9862A0C2F36F58900139991 /* RuntimeViewerMCPServer */,
				E9432FE32C0D614900362862 /* Products */,
				E9432FF32C0D637500362862 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		E9432FE32C0D614900362862 /* Products */ = {
			isa = PBXGroup;
			children = (
				E9432FE22C0D614900362862 /* RuntimeViewer.app */,
				E947C3672C2A4D0400296B2E /* RuntimeViewerCatalystHelper.app */,
				E9E900DC2C2CF9A500FADDCC /* RuntimeViewerCatalystHelperPlugin.bundle */,
				E9E900E82C2D0D5B00FADDCC /* com.JH.RuntimeViewerService */,
				E9EC5BC52F1CBDBA00859091 /* com.mxiris.runtimeviewer.service */,
				E9862A0B2F36F58900139991 /* RuntimeViewerMCPServer */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		E9432FE42C0D614900362862 /* RuntimeViewerUsingAppKit */ = {
			isa = PBXGroup;
			children = (
				E9CE07C02C1498280070A6E8 /* App */,
				E9CE07BA2C1497EA0070A6E8 /* Base */,
				E9CE07BB2C1497F10070A6E8 /* Main */,
				E9CE07BC2C1497F70070A6E8 /* Sidebar */,
				E9CE07BD2C1498000070A6E8 /* Content */,
				E9CE07BE2C14980B0070A6E8 /* Inspector */,
				E97544A12C42D0D800CC9DDD /* Generation Options */,
				E97544A22C42D0F600CC9DDD /* Load Frameworks */,
				E94E36C42CF84A9F006101C8 /* Attach Process */,
				E92CB2E52F41E7560091450B /* Exporting */,
				E9CE07BF2C14981D0070A6E8 /* Utils */,
				E94E36C72CF87BBC006101C8 /* Resources */,
				E9432FE72C0D614A00362862 /* Assets.xcassets */,
				E9432FE92C0D614A00362862 /* MainMenu.xib */,
				E9432FEC2C0D614A00362862 /* RuntimeViewerUsingAppKit.entitlements */,
				E95CDA672DAA970300D97B03 /* Debug.xcconfig */,
				E95CDA682DAA970900D97B03 /* Release.xcconfig */,
				E9C9E9CE2C2D10C600C4AA34 /* Info.plist */,
				E978F2782F1BA1A1004C09B4 /* com.mxiris.runtimeviewer.service.plist */,
			);
			path = RuntimeViewerUsingAppKit;
			sourceTree = "<group>";
		};
		E9432FF32C0D637500362862 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
				E94BA68D2E7EA992006B553D /* UXKit.xcframework */,
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		E947C3682C2A4D0400296B2E /* RuntimeViewerCatalystHelper */ = {
			isa = PBXGroup;
			children = (
				E947C3692C2A4D0400296B2E /* AppDelegate.swift */,
				E9A18BA72C2978DF00689B49 /* AppKitBridge.swift */,
				E947C36B2C2A4D0400296B2E /* SceneDelegate.swift */,
				E947C3722C2A4D0500296B2E /* Assets.xcassets */,
				E9E900D72C2CF96500FADDCC /* RuntimeViewerCatalystHelper.entitlements */,
				E947C3772C2A4D0500296B2E /* Info.plist */,
			);
			path = RuntimeViewerCatalystHelper;
			sourceTree = "<group>";
		};
		E94E36C42CF84A9F006101C8 /* Attach Process */ = {
			isa = PBXGroup;
			children = (
				E94E36C52CF84AF8006101C8 /* AttachToProcessViewController.swift */,
				E9EEF7702E086841008D85D1 /* AttachToProcessViewModel.swift */,
			);
			path = "Attach Process";
			sourceTree = "<group>";
		};
		E94E36C72CF87BBC006101C8 /* Resources */ = {
			isa = PBXGroup;
			children = (
				E94E36C82CF87BD6006101C8 /* RuntimeViewerSymbols.swift */,
			);
			path = Resources;
			sourceTree = "<group>";
		};
		E97544A12C42D0D800CC9DDD /* Generation Options */ = {
			isa = PBXGroup;
			children = (
				E9F0A57D2C305C01001C36FB /* GenerationOptionsViewController.swift */,
				E97544A32C42D11C00CC9DDD /* GenerationOptionsViewModel.swift */,
			);
			path = "Generation Options";
			sourceTree = "<group>";
		};
		E97544A22C42D0F600CC9DDD /* Load Frameworks */ = {
			isa = PBXGroup;
			children = (
				E97544982C42BA5B00CC9DDD /* LoadFrameworksViewController.swift */,
				E97544992C42BA5B00CC9DDD /* LoadFrameworksViewController.xib */,
			);
			path = "Load Frameworks";
			sourceTree = "<group>";
		};
		E98BF6322F1D4ABB0041DB20 /* Products */ = {
			isa = PBXGroup;
			children = (
				E98BF6372F1D4ABB0041DB20 /* RuntimeViewerServer.framework */,
				E94C1B8F2F35E7AC005DF968 /* RuntimeViewerServer.framework */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		E9B4C6552F35E9C800823FE0 /* com.mxiris.runtimeviewer.service */ = {
			isa = PBXGroup;
			children = (
				E9B4C6542F35E9C800823FE0 /* main.swift */,
			);
			path = com.mxiris.runtimeviewer.service;
			sourceTree = "<group>";
		};
		E9CE07BA2C1497EA0070A6E8 /* Base */ = {
			isa = PBXGroup;
			children = (
				E9A825452C0E0B4900D9A85D /* ViewControllers.swift */,
				E9EEE84A2E071704008D85D1 /* CommonLoadingView.swift */,
				E9F11E152F12671D0052B0A3 /* TabViewController.swift */,
			);
			path = Base;
			sourceTree = "<group>";
		};
		E9CE07BB2C1497F10070A6E8 /* Main */ = {
			isa = PBXGroup;
			children = (
				E942ACBE2C28865100A2F3D3 /* MainRoute.swift */,
				E9A825372C0E085200D9A85D /* MainCoordinator.swift */,
				E9A825412C0E0B2300D9A85D /* MainWindowController.swift */,
				E9A825432C0E0B2800D9A85D /* MainSplitViewController.swift */,
				E9CE07AE2C148FA00070A6E8 /* MainToolbarController.swift */,
				E9A825572C0E202600D9A85D /* MainViewModel.swift */,
			);
			path = Main;
			sourceTree = "<group>";
		};
		E9CE07BC2C1497F70070A6E8 /* Sidebar */ = {
			isa = PBXGroup;
			children = (
				E9A8252C2C0DECE400D9A85D /* SidebarCoordinator.swift */,
				E9A825532C0E0FBD00D9A85D /* SidebarNavigationController.swift */,
				E9F11E0A2F123EEC0052B0A3 /* SidebarRootCoordinator.swift */,
				E9D470642F134210008BF7A9 /* SidebarRootTabViewController.swift */,
				E9D470622F12A52A008BF7A9 /* SidebarRootViewController.swift */,
				E94BA6952E7EEB64006B553D /* SidebarRootTableRowView.swift */,
				E9CE07B82C1497B30070A6E8 /* SidebarRootTableCellView.swift */,
				E94330172C0DA62500362862 /* SidebarRootDirectoryViewController.swift */,
				E9F11E172F12812B0052B0A3 /* SidebarRootBookmarkViewController.swift */,
				E9EEF7602E084D7D008D85D1 /* SidebarRuntimeObjectCoordinator.swift */,
				E9D4706A2F136E7F008BF7A9 /* SidebarRuntimeObjectTabViewController.swift */,
				E9A825392C0E095500D9A85D /* SidebarRuntimeObjectViewController.swift */,
				E9F759412CF603DD00BE7A5F /* SidebarRuntimeObjectCellView.swift */,
				E9D470662F136E2A008BF7A9 /* SidebarRuntimeObjectListViewController.swift */,
				E9D470682F136E52008BF7A9 /* SidebarRuntimeObjectBookmarkViewController.swift */,
			);
			path = Sidebar;
			sourceTree = "<group>";
		};
		E9CE07BD2C1498000070A6E8 /* Content */ = {
			isa = PBXGroup;
			children = (
				E9A825492C0E0E9F00D9A85D /* ContentCoordinator.swift */,
				E9A825512C0E0F9F00D9A85D /* ContentNavigationController.swift */,
				E9A825552C0E0FF300D9A85D /* ContentPlaceholderViewController.swift */,
				E99E61602C129DC2002C1A3D /* ContentTextViewController.swift */,
				E9EEF7642E08540B008D85D1 /* ContentTextView.swift */,
			);
			path = Content;
			sourceTree = "<group>";
		};
		E9CE07BE2C14980B0070A6E8 /* Inspector */ = {
			isa = PBXGroup;
			children = (
				E9A8254B2C0E0EA600D9A85D /* InspectorCoordinator.swift */,
				E9A8254F2C0E0EB400D9A85D /* InspectorNavigationController.swift */,
				E9AA36212C3089AB00A9B2E4 /* InspectorPlaceholderViewController.swift */,
				E9EB37AB2C397024003E2859 /* InspectorClassViewController.swift */,
				E9EEF7682E085426008D85D1 /* InspectorClassHierarchyView.swift */,
				E9EEF7662E085420008D85D1 /* InspectorDisclosureView.swift */,
			);
			path = Inspector;
			sourceTree = "<group>";
		};
		E9CE07BF2C14981D0070A6E8 /* Utils */ = {
			isa = PBXGroup;
			children = (
				E97B1C952EC9AE5D00FF5375 /* UIDebugger.h */,
				E97B1C962EC9AE5D00FF5375 /* UIDebugger.m */,
				E91CD9962C2127AD00C989CC /* EventMonitor.swift */,
				E943301B2C0DB75B00362862 /* Then.swift */,
				E9530A3B2D9D5898008FBC7F /* SIPChecker.swift */,
				E96CF5322EC7A4A600CBC159 /* RuntimeSource+.swift */,
				E995B8932ED97C130083D9D7 /* RuntimeEngineManager.swift */,
				E96DE1E22F0ACE8D00F9BAB2 /* CheckboxButton+.swift */,
				E995B8962F1CA0000083D9D7 /* RuntimeConnectionNotificationService.swift */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
		E9CE07C02C1498280070A6E8 /* App */ = {
			isa = PBXGroup;
			children = (
				E9432FE52C0D614900362862 /* AppDelegate.swift */,
				E9862AD42F377E9C00139991 /* AppMCPBridgeWindowProvider.swift */,
				E99AE0BB2CBD4A840028B11E /* Document.swift */,
			);
			path = App;
			sourceTree = "<group>";
		};
		E9E900E02C2CF9B000FADDCC /* RuntimeViewerCatalystHelperPlugin */ = {
			isa = PBXGroup;
			children = (
				E9C9E9DB2C2D169D00C4AA34 /* AppKitPlugin.swift */,
				E9C9E9DC2C2D169D00C4AA34 /* AppKitPluginImpl.swift */,
			);
			path = RuntimeViewerCatalystHelperPlugin;
			sourceTree = "<group>";
		};
		E9E900E92C2D0D5B00FADDCC /* com.JH.RuntimeViewerService */ = {
			isa = PBXGroup;
			children = (
				E9E900EA2C2D0D5B00FADDCC /* main.swift */,
				E9C9E9C92C2D0E3C00C4AA34 /* Config.xcconfig */,
				E95CDA652DAA6FA300D97B03 /* Debug.xcconfig */,
				E95CDA662DAA6FA900D97B03 /* Release.xcconfig */,
				E9668FFB2CEF7140007B344A /* Info.plist */,
				E9668FFC2CEF7140007B344A /* launchd.plist */,
			);
			path = com.JH.RuntimeViewerService;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		E9432FE12C0D614900362862 /* RuntimeViewerUsingAppKit */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E9432FEF2C0D614A00362862 /* Build configuration list for PBXNativeTarget "RuntimeViewerUsingAppKit" */;
			buildPhases = (
				E92988472F0D6A61001926A2 /* Update Build version */,
				E9432FDE2C0D614900362862 /* Sources */,
				E9432FDF2C0D614900362862 /* Frameworks */,
				E9432FE02C0D614900362862 /* Resources */,
				E9F6CD052D9A7B1700DBFB50 /* Embed LaunchDaemon */,
				E9C9E9CC2C2D0F1B00C4AA34 /* Embed LaunchServices */,
				E9C9E9EB2C2D33F500C4AA34 /* Embed Helpers */,
				E9862A242F36F64700139991 /* Embed MCP Server */,
			);
			buildRules = (
			);
			dependencies = (
				E9862A292F36F66400139991 /* PBXTargetDependency */,
				E9862A272F36F65D00139991 /* PBXTargetDependency */,
				E98BEF572F1CBEAF0041DB20 /* PBXTargetDependency */,
			);
			name = RuntimeViewerUsingAppKit;
			packageProductDependencies = (
				E942AC872C274DF600A2F3D3 /* RuntimeViewerApplication */,
				E98BF6292F1D4A750041DB20 /* RuntimeViewerCatalystExtensions */,
				E9862AD22F377D2B00139991 /* RuntimeViewerMCPBridge */,
			);
			productName = RuntimeViewerUsingAppKit;
			productReference = E9432FE22C0D614900362862 /* RuntimeViewer.app */;
			productType = "com.apple.product-type.application";
		};
		E947C3662C2A4D0400296B2E /* RuntimeViewerCatalystHelper */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E947C37A2C2A4D0500296B2E /* Build configuration list for PBXNativeTarget "RuntimeViewerCatalystHelper" */;
			buildPhases = (
				E92988482F0D6A86001926A2 /* Update Build version */,
				E947C3632C2A4D0400296B2E /* Sources */,
				E947C3642C2A4D0400296B2E /* Frameworks */,
				E947C3652C2A4D0400296B2E /* Resources */,
				E9C9E9DA2C2D161000C4AA34 /* Embed PlugIns */,
			);
			buildRules = (
			);
			dependencies = (
				E9C9E9D92C2D161000C4AA34 /* PBXTargetDependency */,
			);
			name = RuntimeViewerCatalystHelper;
			productName = RuntimeViewerCatalystHelper;
			productReference = E947C3672C2A4D0400296B2E /* RuntimeViewerCatalystHelper.app */;
			productType = "com.apple.product-type.application";
		};
		E9862A0A2F36F58900139991 /* RuntimeViewerMCPServer */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E9862A0F2F36F58900139991 /* Build configuration list for PBXNativeTarget "RuntimeViewerMCPServer" */;
			buildPhases = (
				E9862A072F36F58900139991 /* Sources */,
				E9862A082F36F58900139991 /* Frameworks */,
				E9862A092F36F58900139991 /* CopyFiles */,
			);
			buildRules = (
			);
			dependencies = (
			);
			fileSystemSynchronizedGroups = (
				E9862A0C2F36F58900139991 /* RuntimeViewerMCPServer */,
			);
			name = RuntimeViewerMCPServer;
			packageProductDependencies = (
				E9862A202F36F60800139991 /* MCP */,
				E9862A222F36F61200139991 /* RuntimeViewerMCPShared */,
			);
			productName = RuntimeViewerServer;
			productReference = E9862A0B2F36F58900139991 /* RuntimeViewerMCPServer */;
			productType = "com.apple.product-type.tool";
		};
		E9E900DB2C2CF9A500FADDCC /* RuntimeViewerCatalystHelperPlugin */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E9E900DD2C2CF9A500FADDCC /* Build configuration list for PBXNativeTarget "RuntimeViewerCatalystHelperPlugin" */;
			buildPhases = (
				E9E900D82C2CF9A500FADDCC /* Sources */,
				E9E900D92C2CF9A500FADDCC /* Frameworks */,
				E9E900DA2C2CF9A500FADDCC /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = RuntimeViewerCatalystHelperPlugin;
			packageProductDependencies = (
				E985A9CD2D9AF505005A573C /* RuntimeViewerCore */,
				E98BF6272F1D4A690041DB20 /* RuntimeViewerCatalystExtensions */,
			);
			productName = RuntimeViewerCatalystHelperPlugin;
			productReference = E9E900DC2C2CF9A500FADDCC /* RuntimeViewerCatalystHelperPlugin.bundle */;
			productType = "com.apple.product-type.bundle";
		};
		E9E900E72C2D0D5B00FADDCC /* com.JH.RuntimeViewerService */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E9E900EC2C2D0D5B00FADDCC /* Build configuration list for PBXNativeTarget "com.JH.RuntimeViewerService" */;
			buildPhases = (
				E9E900E42C2D0D5B00FADDCC /* Sources */,
				E9E900E52C2D0D5B00FADDCC /* Frameworks */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = com.JH.RuntimeViewerService;
			packageProductDependencies = (
				E985A9D92D9AF7E5005A573C /* RuntimeViewerService */,
			);
			productName = com.JH.RuntimeViewerService;
			productReference = E9E900E82C2D0D5B00FADDCC /* com.JH.RuntimeViewerService */;
			productType = "com.apple.product-type.tool";
		};
		E9EC5BC42F1CBDBA00859091 /* com.mxiris.runtimeviewer.service */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E9EC5BC92F1CBDBA00859091 /* Build configuration list for PBXNativeTarget "com.mxiris.runtimeviewer.service" */;
			buildPhases = (
				E9EC5BC12F1CBDBA00859091 /* Sources */,
				E9EC5BC22F1CBDBA00859091 /* Frameworks */,
				E9EC5BC32F1CBDBA00859091 /* CopyFiles */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = com.mxiris.runtimeviewer.service;
			packageProductDependencies = (
				E98BEF532F1CBE180041DB20 /* RuntimeViewerService */,
			);
			productName = com.mxiris.runtimeviewer.service;
			productReference = E9EC5BC52F1CBDBA00859091 /* com.mxiris.runtimeviewer.service */;
			productType = "com.apple.product-type.tool";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		E9432FDA2C0D614900362862 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 2630;
				LastUpgradeCheck = 2620;
				TargetAttributes = {
					E9432FE12C0D614900362862 = {
						CreatedOnToolsVersion = 15.4;
						LastSwiftMigration = 2610;
					};
					E947C3662C2A4D0400296B2E = {
						CreatedOnToolsVersion = 15.4;
					};
					E9862A0A2F36F58900139991 = {
						CreatedOnToolsVersion = 26.3;
					};
					E9E900DB2C2CF9A500FADDCC = {
						CreatedOnToolsVersion = 15.4;
					};
					E9E900E72C2D0D5B00FADDCC = {
						CreatedOnToolsVersion = 15.4;
					};
					E9EC5BC42F1CBDBA00859091 = {
						CreatedOnToolsVersion = 26.2;
					};
				};
			};
			buildConfigurationList = E9432FDD2C0D614900362862 /* Build configuration list for PBXProject "RuntimeViewerUsingAppKit" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = E9432FD92C0D614900362862;
			packageReferences = (
				E995B8992ED9834B0083D9D7 /* XCRemoteSwiftPackageReference "LaunchServicesPrivate" */,
				E9862A1F2F36F60800139991 /* XCRemoteSwiftPackageReference "swift-sdk" */,
			);
			productRefGroup = E9432FE32C0D614900362862 /* Products */;
			projectDirPath = "";
			projectReferences = (
				{
					ProductGroup = E98BF6322F1D4ABB0041DB20 /* Products */;
					ProjectRef = E98BF5E92F1CE6810041DB20 /* RuntimeViewerServer.xcodeproj */;
				},
			);
			projectRoot = "";
			targets = (
				E9432FE12C0D614900362862 /* RuntimeViewerUsingAppKit */,
				E947C3662C2A4D0400296B2E /* RuntimeViewerCatalystHelper */,
				E9E900DB2C2CF9A500FADDCC /* RuntimeViewerCatalystHelperPlugin */,
				E9E900E72C2D0D5B00FADDCC /* com.JH.RuntimeViewerService */,
				E9EC5BC42F1CBDBA00859091 /* com.mxiris.runtimeviewer.service */,
				E9862A0A2F36F58900139991 /* RuntimeViewerMCPServer */,
			);
		};
/* End PBXProject section */

/* Begin PBXReferenceProxy section */
		E94C1B8F2F35E7AC005DF968 /* RuntimeViewerServer.framework */ = {
			isa = PBXReferenceProxy;
			fileType = wrapper.framework;
			path = RuntimeViewerServer.framework;
			remoteRef = E94C1B8E2F35E7AC005DF968 /* PBXContainerItemProxy */;
			sourceTree = BUILT_PRODUCTS_DIR;
		};
		E98BF6372F1D4ABB0041DB20 /* RuntimeViewerServer.framework */ = {
			isa = PBXReferenceProxy;
			fileType = wrapper.framework;
			path = RuntimeViewerServer.framework;
			remoteRef = E98BF6362F1D4ABB0041DB20 /* PBXContainerItemProxy */;
			sourceTree = BUILT_PRODUCTS_DIR;
		};
/* End PBXReferenceProxy section */

/* Begin PBXResourcesBuildPhase section */
		E9432FE02C0D614900362862 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9432FE82C0D614A00362862 /* Assets.xcassets in Resources */,
				E9432FEB2C0D614A00362862 /* Base in Resources */,
				E975449A2C42BA5B00CC9DDD /* LoadFrameworksViewController.xib in Resources */,
				E927C22E2E9444F300084A7B /* AppIcon.icon in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E947C3652C2A4D0400296B2E /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E947C3732C2A4D0500296B2E /* Assets.xcassets in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9E900DA2C2CF9A500FADDCC /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		E92988472F0D6A61001926A2 /* Update Build version */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			name = "Update Build version";
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "#!/bin/bash\n\n#if [ \"${CONFIGURATION}\" = \"Release\" ]; then\n#    buildNumber=$(date +\"%Y%m%d.%H.%M.%S\")\n#    plistPath=\"${SRCROOT}/${INFOPLIST_FILE}\"\n#    echo \"ğŸš€ Release build detected. Updating Build Number to: $buildNumber\"\n#    /usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$plistPath\"\n#else\n#    echo \"âš ï¸ Debug build detected. Skipping Build Number update to keep Git clean.\"\n#fi\n";
		};
		E92988482F0D6A86001926A2 /* Update Build version */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputFileListPaths = (
			);
			inputPaths = (
			);
			name = "Update Build version";
			outputFileListPaths = (
			);
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "#!/bin/bash\n\n#if [ \"${CONFIGURATION}\" = \"Release\" ]; then\n#    buildNumber=$(date +\"%Y%m%d.%H.%M.%S\")\n#    plistPath=\"${SRCROOT}/${INFOPLIST_FILE}\"\n#    echo \"ğŸš€ Release build detected. Updating Build Number to: $buildNumber\"\n#    /usr/libexec/PlistBuddy -c \"Set :CFBundleVersion $buildNumber\" \"$plistPath\"\n#else\n#    echo \"âš ï¸ Debug build detected. Skipping Build Number update to keep Git clean.\"\n#fi\n";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		E9432FDE2C0D614900362862 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9D470672F136E2A008BF7A9 /* SidebarRuntimeObjectListViewController.swift in Sources */,
				E9432FE62C0D614900362862 /* AppDelegate.swift in Sources */,
				E9A8252D2C0DECE400D9A85D /* SidebarCoordinator.swift in Sources */,
				E9A8253A2C0E095500D9A85D /* SidebarRuntimeObjectViewController.swift in Sources */,
				E9EB37AC2C397024003E2859 /* InspectorClassViewController.swift in Sources */,
				E99AE0BC2CBD4A840028B11E /* Document.swift in Sources */,
				E943301C2C0DB75B00362862 /* Then.swift in Sources */,
				E9AA36222C3089AB00A9B2E4 /* InspectorPlaceholderViewController.swift in Sources */,
				E921246F2F447BE1007481E4 /* ExportingProgressViewModel.swift in Sources */,
				E9D470632F12A52A008BF7A9 /* SidebarRootViewController.swift in Sources */,
				E9F11E162F12671D0052B0A3 /* TabViewController.swift in Sources */,
				E9F759422CF603DD00BE7A5F /* SidebarRuntimeObjectCellView.swift in Sources */,
				E96CF5332EC7A4A600CBC159 /* RuntimeSource+.swift in Sources */,
				E9A8254C2C0E0EA600D9A85D /* InspectorCoordinator.swift in Sources */,
				E995B8942ED97D140083D9D7 /* RuntimeEngineManager.swift in Sources */,
				E995B8972F1CA0000083D9D7 /* RuntimeConnectionNotificationService.swift in Sources */,
				E9A825422C0E0B2300D9A85D /* MainWindowController.swift in Sources */,
				E9530A3C2D9D5898008FBC7F /* SIPChecker.swift in Sources */,
				E9D470652F134210008BF7A9 /* SidebarRootTabViewController.swift in Sources */,
				E92124712F447C7F007481E4 /* ExportingProgressViewController.swift in Sources */,
				E94E36C92CF87BD6006101C8 /* RuntimeViewerSymbols.swift in Sources */,
				E9A825562C0E0FF300D9A85D /* ContentPlaceholderViewController.swift in Sources */,
				E94BA6962E7EEB64006B553D /* SidebarRootTableRowView.swift in Sources */,
				E9A825382C0E085200D9A85D /* MainCoordinator.swift in Sources */,
				E9EEF7672E085420008D85D1 /* InspectorDisclosureView.swift in Sources */,
				E9A825462C0E0B4900D9A85D /* ViewControllers.swift in Sources */,
				E9862AD52F377E9C00139991 /* AppMCPBridgeWindowProvider.swift in Sources */,
				E9A825522C0E0F9F00D9A85D /* ContentNavigationController.swift in Sources */,
				E921246D2F447BBF007481E4 /* ExportingConfigurationViewController.swift in Sources */,
				E942ACBF2C28865100A2F3D3 /* MainRoute.swift in Sources */,
				E9EEF7692E085426008D85D1 /* InspectorClassHierarchyView.swift in Sources */,
				E9EEF7712E086841008D85D1 /* AttachToProcessViewModel.swift in Sources */,
				E9A825502C0E0EB400D9A85D /* InspectorNavigationController.swift in Sources */,
				E92124732F447C94007481E4 /* ExportingViewController.swift in Sources */,
				E96DE1E32F0ACE8D00F9BAB2 /* CheckboxButton+.swift in Sources */,
				E9935B922F44886A006DB4EC /* ExportingCoordinator.swift in Sources */,
				E9935B952F448900006DB4EC /* ExportingCompletionViewModel.swift in Sources */,
				E9935B972F448910006DB4EC /* ExportingCompletionViewController.swift in Sources */,
				E94330182C0DA62500362862 /* SidebarRootDirectoryViewController.swift in Sources */,
				E9F11E0B2F123EEC0052B0A3 /* SidebarRootCoordinator.swift in Sources */,
				E921246B2F447BA1007481E4 /* ExportingConfigurationViewModel.swift in Sources */,
				E99E61612C129DC2002C1A3D /* ContentTextViewController.swift in Sources */,
				E9D4706B2F136E7F008BF7A9 /* SidebarRuntimeObjectTabViewController.swift in Sources */,
				E9EEF7612E084D7D008D85D1 /* SidebarRuntimeObjectCoordinator.swift in Sources */,
				E9F0A57E2C305C01001C36FB /* GenerationOptionsViewController.swift in Sources */,
				E92124642F447AE1007481E4 /* ExportingState.swift in Sources */,
				E9A825582C0E202600D9A85D /* MainViewModel.swift in Sources */,
				E91CD9972C2127AD00C989CC /* EventMonitor.swift in Sources */,
				E975449B2C42BA5B00CC9DDD /* LoadFrameworksViewController.swift in Sources */,
				E9CE07B92C1497B30070A6E8 /* SidebarRootTableCellView.swift in Sources */,
				E97B1C972EC9AE5D00FF5375 /* UIDebugger.m in Sources */,
				E9D470692F136E52008BF7A9 /* SidebarRuntimeObjectBookmarkViewController.swift in Sources */,
				E9A825542C0E0FBD00D9A85D /* SidebarNavigationController.swift in Sources */,
				E9EEE84B2E071704008D85D1 /* CommonLoadingView.swift in Sources */,
				E9A825442C0E0B2800D9A85D /* MainSplitViewController.swift in Sources */,
				E9EEF7652E08540B008D85D1 /* ContentTextView.swift in Sources */,
				E9A8254A2C0E0E9F00D9A85D /* ContentCoordinator.swift in Sources */,
				E97544A42C42D11C00CC9DDD /* GenerationOptionsViewModel.swift in Sources */,
				E9CE07AF2C148FA00070A6E8 /* MainToolbarController.swift in Sources */,
				E94E36C62CF84AF8006101C8 /* AttachToProcessViewController.swift in Sources */,
				E9F11E182F12812B0052B0A3 /* SidebarRootBookmarkViewController.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E947C3632C2A4D0400296B2E /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9C9E9E02C2D172600C4AA34 /* AppKitBridge.swift in Sources */,
				E9C9E9DF2C2D16B000C4AA34 /* AppKitPlugin.swift in Sources */,
				E947C36A2C2A4D0400296B2E /* AppDelegate.swift in Sources */,
				E947C36C2C2A4D0400296B2E /* SceneDelegate.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9862A072F36F58900139991 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9E900D82C2CF9A500FADDCC /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9C9E9DE2C2D169D00C4AA34 /* AppKitPluginImpl.swift in Sources */,
				E9C9E9DD2C2D169D00C4AA34 /* AppKitPlugin.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9E900E42C2D0D5B00FADDCC /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9E900EB2C2D0D5B00FADDCC /* main.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9EC5BC12F1CBDBA00859091 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9B4C6562F35E9C800823FE0 /* main.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		E9862A272F36F65D00139991 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = E9862A0A2F36F58900139991 /* RuntimeViewerMCPServer */;
			targetProxy = E9862A262F36F65D00139991 /* PBXContainerItemProxy */;
		};
		E9862A292F36F66400139991 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			name = RuntimeViewerServer;
			targetProxy = E9862A282F36F66400139991 /* PBXContainerItemProxy */;
		};
		E98BEF572F1CBEAF0041DB20 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = E9EC5BC42F1CBDBA00859091 /* com.mxiris.runtimeviewer.service */;
			targetProxy = E98BEF562F1CBEAF0041DB20 /* PBXContainerItemProxy */;
		};
		E9C9E9D92C2D161000C4AA34 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			platformFilter = maccatalyst;
			target = E9E900DB2C2CF9A500FADDCC /* RuntimeViewerCatalystHelperPlugin */;
			targetProxy = E9C9E9D82C2D161000C4AA34 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		E9432FE92C0D614A00362862 /* MainMenu.xib */ = {
			isa = PBXVariantGroup;
			children = (
				E9432FEA2C0D614A00362862 /* Base */,
			);
			name = MainMenu.xib;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		E9432FED2C0D614A00362862 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MACOSX_DEPLOYMENT_TARGET = 11.0;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
			};
			name = Debug;
		};
		E9432FEE2C0D614A00362862 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEAD_CODE_STRIPPING = YES;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MACOSX_DEPLOYMENT_TARGET = 11.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = macosx;
				SWIFT_COMPILATION_MODE = wholemodule;
			};
			name = Release;
		};
		E9432FF02C0D614A00362862 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = E95CDA672DAA970300D97B03 /* Debug.xcconfig */;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO;
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = NO;
				AUTOMATION_APPLE_EVENTS = NO;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 20260106.23.26;
				DEAD_CODE_STRIPPING = YES;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				ENABLE_RESOURCE_ACCESS_AUDIO_INPUT = NO;
				ENABLE_RESOURCE_ACCESS_CALENDARS = NO;
				ENABLE_RESOURCE_ACCESS_CAMERA = NO;
				ENABLE_RESOURCE_ACCESS_CONTACTS = NO;
				ENABLE_RESOURCE_ACCESS_LOCATION = NO;
				ENABLE_RESOURCE_ACCESS_PHOTO_LIBRARY = NO;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				FUSE_BUILD_SCRIPT_PHASES = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = RuntimeViewerUsingAppKit/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = RuntimeViewer;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.developer-tools";
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INFOPLIST_KEY_NSLocalNetworkUsageDescription = "RuntimeViewer requires local network permissions to use the Bonjour discovery service";
				INFOPLIST_KEY_NSMainNibFile = MainMenu;
				INFOPLIST_KEY_NSPrincipalClass = NSApplication;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				MARKETING_VERSION = 2.0.0;
				ONLY_ACTIVE_ARCH = YES;
				PRODUCT_BUNDLE_IDENTIFIER = dev.JH.RuntimeViewer;
				PRODUCT_NAME = RuntimeViewer;
				RUNTIME_EXCEPTION_ALLOW_DYLD_ENVIRONMENT_VARIABLES = NO;
				RUNTIME_EXCEPTION_ALLOW_JIT = NO;
				RUNTIME_EXCEPTION_ALLOW_UNSIGNED_EXECUTABLE_MEMORY = NO;
				RUNTIME_EXCEPTION_DEBUGGING_TOOL = YES;
				RUNTIME_EXCEPTION_DISABLE_EXECUTABLE_PAGE_PROTECTION = NO;
				RUNTIME_EXCEPTION_DISABLE_LIBRARY_VALIDATION = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		E9432FF12C0D614A00362862 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = E95CDA682DAA970900D97B03 /* Release.xcconfig */;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO;
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				ASSETCATALOG_COMPILER_INCLUDE_ALL_APPICON_ASSETS = NO;
				AUTOMATION_APPLE_EVENTS = NO;
				CLANG_ENABLE_MODULES = YES;
				CODE_SIGN_ENTITLEMENTS = RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit.entitlements;
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 20260106.23.26;
				DEAD_CODE_STRIPPING = YES;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				ENABLE_RESOURCE_ACCESS_AUDIO_INPUT = NO;
				ENABLE_RESOURCE_ACCESS_CALENDARS = NO;
				ENABLE_RESOURCE_ACCESS_CAMERA = NO;
				ENABLE_RESOURCE_ACCESS_CONTACTS = NO;
				ENABLE_RESOURCE_ACCESS_LOCATION = NO;
				ENABLE_RESOURCE_ACCESS_PHOTO_LIBRARY = NO;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				FUSE_BUILD_SCRIPT_PHASES = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = RuntimeViewerUsingAppKit/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = RuntimeViewer;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.developer-tools";
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INFOPLIST_KEY_NSLocalNetworkUsageDescription = "RuntimeViewer requires local network permissions to use the Bonjour discovery service";
				INFOPLIST_KEY_NSMainNibFile = MainMenu;
				INFOPLIST_KEY_NSPrincipalClass = NSApplication;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/../Frameworks",
				);
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				MARKETING_VERSION = 2.0.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewer;
				PRODUCT_NAME = RuntimeViewer;
				RUNTIME_EXCEPTION_ALLOW_DYLD_ENVIRONMENT_VARIABLES = NO;
				RUNTIME_EXCEPTION_ALLOW_JIT = NO;
				RUNTIME_EXCEPTION_ALLOW_UNSIGNED_EXECUTABLE_MEMORY = NO;
				RUNTIME_EXCEPTION_DEBUGGING_TOOL = YES;
				RUNTIME_EXCEPTION_DISABLE_EXECUTABLE_PAGE_PROTECTION = NO;
				RUNTIME_EXCEPTION_DISABLE_LIBRARY_VALIDATION = YES;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		E947C3782C2A4D0500296B2E /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO;
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				BUILD_LIBRARY_FOR_DISTRIBUTION = NO;
				CODE_SIGN_ENTITLEMENTS = RuntimeViewerCatalystHelper/RuntimeViewerCatalystHelper.entitlements;
				CODE_SIGN_IDENTITY = "Apple Development";
				"CODE_SIGN_IDENTITY[sdk=macosx*]" = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 20260106.23.26;
				DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER = NO;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = RuntimeViewerCatalystHelper/Info.plist;
				INFOPLIST_KEY_LSBackgroundOnly = YES;
				INFOPLIST_KEY_LSUIElement = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 18.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 2.0.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewerCatalystHelper;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SKIP_INSTALL = NO;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
				SUPPORTS_MACCATALYST = YES;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,6";
			};
			name = Debug;
		};
		E947C3792C2A4D0500296B2E /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALLOW_TARGET_PLATFORM_SPECIALIZATION = NO;
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				BUILD_LIBRARY_FOR_DISTRIBUTION = NO;
				CODE_SIGN_ENTITLEMENTS = RuntimeViewerCatalystHelper/RuntimeViewerCatalystHelper.entitlements;
				CODE_SIGN_IDENTITY = "Apple Development";
				"CODE_SIGN_IDENTITY[sdk=macosx*]" = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 20260106.23.26;
				DERIVE_MACCATALYST_PRODUCT_BUNDLE_IDENTIFIER = NO;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = RuntimeViewerCatalystHelper/Info.plist;
				INFOPLIST_KEY_LSBackgroundOnly = YES;
				INFOPLIST_KEY_LSUIElement = YES;
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 18.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 2.0.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewerCatalystHelper;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SDKROOT = iphoneos;
				SKIP_INSTALL = NO;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
				SUPPORTS_MACCATALYST = YES;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,6";
				VALIDATE_PRODUCT = NO;
			};
			name = Release;
		};
		E9862A102F36F58900139991 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_HARDENED_RUNTIME = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		E9862A112F36F58900139991 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_HARDENED_RUNTIME = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		E9E900DE2C2CF9A500FADDCC /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEAD_CODE_STRIPPING = YES;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INFOPLIST_KEY_NSPrincipalClass = AppKitPluginImpl;
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Bundles";
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				MARKETING_VERSION = 1.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewerCatalystHelperPlugin;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				WRAPPER_EXTENSION = bundle;
			};
			name = Debug;
		};
		E9E900DF2C2CF9A500FADDCC /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				COMBINE_HIDPI_IMAGES = YES;
				CURRENT_PROJECT_VERSION = 1;
				DEAD_CODE_STRIPPING = YES;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = NO;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_KEY_NSHumanReadableCopyright = "";
				INFOPLIST_KEY_NSPrincipalClass = AppKitPluginImpl;
				INSTALL_PATH = "$(LOCAL_LIBRARY_DIR)/Bundles";
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				MARKETING_VERSION = 1.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewerCatalystHelperPlugin;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				WRAPPER_EXTENSION = bundle;
			};
			name = Release;
		};
		E9E900ED2C2D0D5B00FADDCC /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = E95CDA652DAA6FA300D97B03 /* Debug.xcconfig */;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CREATE_INFOPLIST_SECTION_IN_BINARY = YES;
				DEAD_CODE_STRIPPING = YES;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = YES;
				INFOPLIST_FILE = "$(SRCROOT)/$(TARGETNAME)/Info.plist";
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				ONLY_ACTIVE_ARCH = NO;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewerService;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		E9E900EE2C2D0D5B00FADDCC /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = E95CDA662DAA6FA900D97B03 /* Release.xcconfig */;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				CREATE_INFOPLIST_SECTION_IN_BINARY = YES;
				DEAD_CODE_STRIPPING = YES;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = YES;
				INFOPLIST_FILE = "$(SRCROOT)/$(TARGETNAME)/Info.plist";
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewerService;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
		E9EC5BCA2F1CBDBA00859091 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Debug;
		};
		E9EC5BCB2F1CBDBA00859091 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				CODE_SIGN_STYLE = Automatic;
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_HARDENED_RUNTIME = YES;
				ENABLE_POINTER_AUTHENTICATION = YES;
				MACOSX_DEPLOYMENT_TARGET = 15.0;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SKIP_INSTALL = YES;
				SWIFT_APPROACHABLE_CONCURRENCY = YES;
				SWIFT_UPCOMING_FEATURE_MEMBER_IMPORT_VISIBILITY = YES;
				SWIFT_VERSION = 5.0;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		E9432FDD2C0D614900362862 /* Build configuration list for PBXProject "RuntimeViewerUsingAppKit" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9432FED2C0D614A00362862 /* Debug */,
				E9432FEE2C0D614A00362862 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E9432FEF2C0D614A00362862 /* Build configuration list for PBXNativeTarget "RuntimeViewerUsingAppKit" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9432FF02C0D614A00362862 /* Debug */,
				E9432FF12C0D614A00362862 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E947C37A2C2A4D0500296B2E /* Build configuration list for PBXNativeTarget "RuntimeViewerCatalystHelper" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E947C3782C2A4D0500296B2E /* Debug */,
				E947C3792C2A4D0500296B2E /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E9862A0F2F36F58900139991 /* Build configuration list for PBXNativeTarget "RuntimeViewerMCPServer" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9862A102F36F58900139991 /* Debug */,
				E9862A112F36F58900139991 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E9E900DD2C2CF9A500FADDCC /* Build configuration list for PBXNativeTarget "RuntimeViewerCatalystHelperPlugin" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9E900DE2C2CF9A500FADDCC /* Debug */,
				E9E900DF2C2CF9A500FADDCC /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E9E900EC2C2D0D5B00FADDCC /* Build configuration list for PBXNativeTarget "com.JH.RuntimeViewerService" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9E900ED2C2D0D5B00FADDCC /* Debug */,
				E9E900EE2C2D0D5B00FADDCC /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E9EC5BC92F1CBDBA00859091 /* Build configuration list for PBXNativeTarget "com.mxiris.runtimeviewer.service" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9EC5BCA2F1CBDBA00859091 /* Debug */,
				E9EC5BCB2F1CBDBA00859091 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCRemoteSwiftPackageReference section */
		E9862A1F2F36F60800139991 /* XCRemoteSwiftPackageReference "swift-sdk" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/modelcontextprotocol/swift-sdk.git";
			requirement = {
				kind = upToNextMajorVersion;
				minimumVersion = 0.10.2;
			};
		};
		E995B8992ED9834B0083D9D7 /* XCRemoteSwiftPackageReference "LaunchServicesPrivate" */ = {
			isa = XCRemoteSwiftPackageReference;
			repositoryURL = "https://github.com/MxIris-Reverse-Engineering/LaunchServicesPrivate";
			requirement = {
				branch = main;
				kind = branch;
			};
		};
/* End XCRemoteSwiftPackageReference section */

/* Begin XCSwiftPackageProductDependency section */
		E942AC872C274DF600A2F3D3 /* RuntimeViewerApplication */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerApplication;
		};
		E985A9CD2D9AF505005A573C /* RuntimeViewerCore */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerCore;
		};
		E985A9D92D9AF7E5005A573C /* RuntimeViewerService */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerService;
		};
		E9862A202F36F60800139991 /* MCP */ = {
			isa = XCSwiftPackageProductDependency;
			package = E9862A1F2F36F60800139991 /* XCRemoteSwiftPackageReference "swift-sdk" */;
			productName = MCP;
		};
		E9862A222F36F61200139991 /* RuntimeViewerMCPShared */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerMCPShared;
		};
		E9862AD22F377D2B00139991 /* RuntimeViewerMCPBridge */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerMCPBridge;
		};
		E98BEF532F1CBE180041DB20 /* RuntimeViewerService */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerService;
		};
		E98BF6272F1D4A690041DB20 /* RuntimeViewerCatalystExtensions */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerCatalystExtensions;
		};
		E98BF6292F1D4A750041DB20 /* RuntimeViewerCatalystExtensions */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerCatalystExtensions;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = E9432FDA2C0D614900362862 /* Project object */;
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit.xcodeproj/xcshareddata/xcschemes/RuntimeViewer macOS.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "E9432FE12C0D614900362862"
               BuildableName = "RuntimeViewer.app"
               BlueprintName = "RuntimeViewerUsingAppKit"
               ReferencedContainer = "container:RuntimeViewerUsingAppKit.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E9432FE12C0D614900362862"
            BuildableName = "RuntimeViewer.app"
            BlueprintName = "RuntimeViewerUsingAppKit"
            ReferencedContainer = "container:RuntimeViewerUsingAppKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Debug"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E9432FE12C0D614900362862"
            BuildableName = "RuntimeViewer.app"
            BlueprintName = "RuntimeViewerUsingAppKit"
            ReferencedContainer = "container:RuntimeViewerUsingAppKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit.xcodeproj/xcshareddata/xcschemes/RuntimeViewerCatalystHelper.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <PostActions>
         <ExecutionAction
            ActionType = "Xcode.IDEStandardExecutionActionsCore.ExecutionActionType.ShellScriptAction">
            <ActionContent
               title = "Run Script"
               scriptText = "#!/bin/bash&#10;&#10;if [ &quot;${CONFIGURATION}&quot; = &quot;Debug&quot; ]; then&#10;&#10;APP_NAME=&quot;${TARGET_NAME}.app&quot;&#10;SRC_PATH=&quot;${BUILT_PRODUCTS_DIR}/${APP_NAME}&quot;&#10;DEST_PATH=&quot;${SRCROOT}&quot;&#10;&#10;if [ -d &quot;${DEST_PATH}/${APP_NAME}&quot; ]; then&#10;    rm -rf &quot;${DEST_PATH}/${APP_NAME}&quot;&#10;fi&#10;&#10;cp -f -R &quot;${SRC_PATH}&quot; &quot;${DEST_PATH}&quot;&#10;&#10;if [ $? -eq 0 ]; then&#10;    exit 0&#10;else&#10;    exit 1&#10;fi&#10;&#10;fi&#10;">
               <EnvironmentBuildable>
                  <BuildableReference
                     BuildableIdentifier = "primary"
                     BlueprintIdentifier = "E947C3662C2A4D0400296B2E"
                     BuildableName = "RuntimeViewerCatalystHelper.app"
                     BlueprintName = "RuntimeViewerCatalystHelper"
                     ReferencedContainer = "container:RuntimeViewerUsingAppKit.xcodeproj">
                  </BuildableReference>
               </EnvironmentBuildable>
            </ActionContent>
         </ExecutionAction>
      </PostActions>
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "E947C3662C2A4D0400296B2E"
               BuildableName = "RuntimeViewerCatalystHelper.app"
               BlueprintName = "RuntimeViewerCatalystHelper"
               ReferencedContainer = "container:RuntimeViewerUsingAppKit.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E947C3662C2A4D0400296B2E"
            BuildableName = "RuntimeViewerCatalystHelper.app"
            BlueprintName = "RuntimeViewerCatalystHelper"
            ReferencedContainer = "container:RuntimeViewerUsingAppKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Debug"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E947C3662C2A4D0400296B2E"
            BuildableName = "RuntimeViewerCatalystHelper.app"
            BlueprintName = "RuntimeViewerCatalystHelper"
            ReferencedContainer = "container:RuntimeViewerUsingAppKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/App/AppDelegate.swift`:

```swift
import AppKit
import FoundationToolbox
import RuntimeViewerCore
import RuntimeViewerApplication
import RuntimeViewerSettings
import RuntimeViewerSettingsUI
import RuntimeViewerArchitectures
import RuntimeViewerMCPBridge

@Loggable
@main
final class AppDelegate: NSObject, NSApplicationDelegate {
    private var mcpBridgeServer: MCPBridgeServer?

    func applicationDidFinishLaunching(_ aNotification: Notification) {
        @Dependency(\.settings)
        var settings

        observe {
            switch settings.general.appearance {
            case .system:
                NSApp.appearance = nil
            case .dark:
                NSApp.appearance = .init(named: .darkAqua)
            case .light:
                NSApp.appearance = .init(named: .aqua)
            }
        }

        startMCPBridgeServer()
    }

    func applicationWillTerminate(_ aNotification: Notification) {
        mcpBridgeServer?.stop()
    }

    func applicationSupportsSecureRestorableState(_ app: NSApplication) -> Bool {
        return false
    }

    func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
        return true
    }

    @IBAction func showSettings(_ sender: Any?) {
        SettingsWindowController.shared.showWindow(nil)
    }

    private func startMCPBridgeServer() {
        Task { @MainActor in
            do {
                let windowProvider = AppMCPBridgeWindowProvider()
                let server = try MCPBridgeServer(windowProvider: windowProvider)
                mcpBridgeServer = server
                await server.start()
            } catch {
                #log(.error, "Failed to start MCP Bridge Server: \(error, privacy: .public)")
            }
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/App/AppMCPBridgeWindowProvider.swift`:

```swift
#if canImport(RuntimeViewerMCPBridge)
import AppKit
import RuntimeViewerApplication
import RuntimeViewerMCPBridge
import RuntimeViewerMCPShared

@MainActor
final class AppMCPBridgeWindowProvider: MCPBridgeWindowProvider {
    func allWindowContexts() -> [MCPBridgeWindowContext] {
        NSDocumentController.shared.documents.compactMap { document -> MCPBridgeWindowContext? in
            guard let document = document as? Document else { return nil }
            guard let window = document.windowControllers.first?.window else { return nil }
            return MCPBridgeWindowContext(
                identifier: "\(window.windowNumber)",
                displayName: window.title,
                isKeyWindow: window.isKeyWindow,
                selectedRuntimeObject: document.documentState.selectedRuntimeObject,
                runtimeEngine: document.documentState.runtimeEngine
            )
        }
    }

    func windowContext(forIdentifier identifier: String) -> MCPBridgeWindowContext? {
        for document in NSDocumentController.shared.documents {
            guard let document = document as? Document else { continue }
            guard let window = document.windowControllers.first?.window else { continue }
            if identifier == "\(window.windowNumber)" {
                return MCPBridgeWindowContext(
                    identifier: identifier,
                    displayName: window.title,
                    isKeyWindow: window.isKeyWindow,
                    selectedRuntimeObject: document.documentState.selectedRuntimeObject,
                    runtimeEngine: document.documentState.runtimeEngine
                )
            }
        }
        return nil
    }
}
#endif

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/App/Document.swift`:

```swift
import AppKit
import RuntimeViewerApplication

final class Document: NSDocument {
    let documentState = DocumentState()

    private lazy var mainCoordinator = MainCoordinator(documentState: documentState)

    override class var autosavesInPlace: Bool { false }

    override func makeWindowControllers() {
        addWindowController(mainCoordinator.windowController)
    }

    override func data(ofType typeName: String) throws -> Data {
        throw NSError(domain: NSOSStatusErrorDomain, code: unimpErr, userInfo: nil)
    }

    override func read(from data: Data, ofType typeName: String) throws {
        throw NSError(domain: NSOSStatusErrorDomain, code: unimpErr, userInfo: nil)
    }

    override func updateChangeCount(_ change: NSDocument.ChangeType) {}
    override func runPageLayout(_ sender: Any?) {}
    override func printDocument(_ sender: Any?) {}
    override func saveAs(_ sender: Any?) {}
    override func saveTo(_ sender: Any?) {}
    override func save(_ sender: Any?) {}
    override func revertToSaved(_ sender: Any?) {}

    override func validateUserInterfaceItem(_ item: any NSValidatedUserInterfaceItem) -> Bool {
        switch item.action {
        case #selector(revertToSaved(_:)),
             #selector(save(_:)),
             #selector(saveAs(_:)),
             #selector(saveTo(_:)),
             #selector(printDocument(_:)),
             #selector(runPageLayout(_:)):
            return false
        default:
            return super.validateUserInterfaceItem(item)
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/app.fill.symbolset/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "symbols" : [
    {
      "filename" : "app.fill.svg",
      "idiom" : "universal"
    }
  ]
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/app.fill.symbolset/app.fill.svg`:

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg width="3300px" height="2200px" viewBox="0 0 3300 2200" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>square.and.arrow.up</title>
    <g id="é¡µé¢-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="square.and.arrow.up">
            <g id="Notes">
                <rect id="artboard" fill="#FFFFFF" fill-rule="nonzero" x="0" y="0" width="3300" height="2200"></rect>
                <line x1="263" y1="292" x2="3036" y2="292" id="è·¯å¾„" stroke="#000000" stroke-width="0.5"></line>
                <text id="Weight/Scale-Variations" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="322">Weight/Scale Variations</tspan>
                </text>
                <text id="Ultralight" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="533.711" y="322">Ultralight</tspan>
                </text>
                <text id="Thin" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="843.422" y="322">Thin</tspan>
                </text>
                <text id="Light" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1138.63" y="322">Light</tspan>
                </text>
                <text id="Regular" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1426.84" y="322">Regular</tspan>
                </text>
                <text id="Medium" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1723.06" y="322">Medium</tspan>
                </text>
                <text id="Semibold" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2015.77" y="322">Semibold</tspan>
                </text>
                <text id="Bold" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2326.48" y="322">Bold</tspan>
                </text>
                <text id="Heavy" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2618.19" y="322">Heavy</tspan>
                </text>
                <text id="Black" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2917.4" y="322">Black</tspan>
                </text>
                <line x1="263" y1="1903" x2="3036" y2="1903" id="è·¯å¾„" stroke="#000000" stroke-width="0.5"></line>
                <g id="ç¼–ç»„" transform="translate(264.3672, 1918.0684)" fill="#000000" fill-rule="nonzero">
                    <path d="M7.88088,15.76172 C12.18752,15.76172 15.7715,12.1875 15.7715,7.88086 C15.7715,3.57422 12.17774,0 7.8711,0 C3.57422,0 0,3.57422 0,7.88086 C0,12.1875 3.58398,15.76172 7.88086,15.76172 L7.88088,15.76172 Z M7.88088,14.277344 C4.33596,14.277344 1.50392,11.435544 1.50392,7.880864 C1.50392,4.326184 4.32618,1.484384 7.8711,1.484384 C11.42578,1.484384 14.27734,4.326184 14.27734,7.880864 C14.27734,11.435544 11.43554,14.277344 7.88086,14.277344 L7.88088,14.277344 Z M4.28712,7.880864 C4.28712,8.310552 4.589854,8.60352 5.039074,8.60352 L7.138674,8.60352 L7.138674,10.72266 C7.138674,11.162114 7.431642,11.464848 7.86133,11.464848 C8.310548,11.464848 8.603518,11.162114 8.603518,10.72266 L8.603518,8.60352 L10.722658,8.60352 C11.162112,8.60352 11.464846,8.310552 11.464846,7.880864 C11.464846,7.44141 11.162112,7.138676 10.722658,7.138676 L8.603518,7.138676 L8.603518,5.029296 C8.603518,4.580078 8.31055,4.277342 7.86133,4.277342 C7.431642,4.277342 7.138674,4.580076 7.138674,5.029296 L7.138674,7.138676 L5.039074,7.138676 C4.589856,7.138676 4.28712,7.44141 4.28712,7.880864 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="ç¼–ç»„" transform="translate(283.254, 1915.9883)" fill="#000000" fill-rule="nonzero">
                    <path d="M9.96094,19.92188 C15.41016,19.92188 19.92188,15.4004 19.92188,9.96094 C19.92188,4.51172 15.4004,0 9.95118,0 C4.51172,0 0,4.51172 0,9.96094 C0,15.4004 4.52148,19.92188 9.96094,19.92188 Z M9.96094,18.261724 C5.35156,18.261724 1.66992,14.570324 1.66992,9.960944 C1.66992,5.351564 5.3418,1.660164 9.95116,1.660164 C14.56052,1.660164 18.2617,5.351564 18.2617,9.960944 C18.2617,14.570324 14.5703,18.261724 9.96092,18.261724 L9.96094,18.261724 Z M5.4297,9.960944 C5.4297,10.43946 5.761732,10.761726 6.259778,10.761726 L9.130878,10.761726 L9.130878,13.642586 C9.130878,14.130868 9.46291,14.472664 9.941424,14.472664 C10.4297,14.472664 10.771502,14.140632 10.771502,13.642586 L10.771502,10.761726 L13.652362,10.761726 C14.140644,10.761726 14.48244,10.43946 14.48244,9.960944 C14.48244,9.472662 14.140644,9.130866 13.652362,9.130866 L10.771502,9.130866 L10.771502,6.259766 C10.771502,5.76172 10.4297,5.419922 9.941424,5.419922 C9.462908,5.419922 9.130878,5.761718 9.130878,6.259766 L9.130878,9.130866 L6.259778,9.130866 C5.761732,9.130866 5.4297,9.472662 5.4297,9.960944 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="ç¼–ç»„" transform="translate(307.1798, 1913.2246)" fill="#000000" fill-rule="nonzero">
                    <path d="M12.71486,25.43944 C19.67776,25.43944 25.43946,19.67772 25.43946,12.7246 C25.43946,5.7617 19.66798,0 12.70508,0 C5.75196,0 -1.42108547e-15,5.76172 -1.42108547e-15,12.7246 C-1.42108547e-15,19.67772 5.76172,25.43944 12.71484,25.43944 L12.71486,25.43944 Z M12.71486,23.623034 C6.6797,23.623034 1.82618,18.759754 1.82618,12.724594 C1.82618,6.679674 6.66994,1.826154 12.70508,1.826154 C18.75,1.826154 23.61328,6.679674 23.61328,12.724594 C23.61328,18.759754 18.75976,23.623034 12.71484,23.623034 L12.71486,23.623034 Z M6.94338,12.724594 C6.94338,13.242172 7.314474,13.6035 7.861348,13.6035 L11.806668,13.6035 L11.806668,17.55858 C11.806668,18.09569 12.177762,18.476548 12.69534,18.476548 C13.23245,18.476548 13.603544,18.105454 13.603544,17.55858 L13.603544,13.6035 L17.558624,13.6035 C18.095734,13.6035 18.476592,13.242172 18.476592,12.724594 C18.476592,12.177718 18.105498,11.806626 17.558624,11.806626 L13.603544,11.806626 L13.603544,7.861306 C13.603544,7.31443 13.23245,6.933572 12.69534,6.933572 C12.177762,6.933572 11.806668,7.314432 11.806668,7.861306 L11.806668,11.806626 L7.861348,11.806626 C7.314472,11.806626 6.94338,12.17772 6.94338,12.724594 Z" id="å½¢çŠ¶"></path>
                </g>
                <text id="Design-Variations" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1953">Design Variations</tspan>
                </text>
                <text id="Symbols-are-supported-in-up-to-nine-weights-and-three-scales." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1971">Symbols are supported in up to nine weights and three scales.</tspan>
                </text>
                <text id="For-optimal-layout-with-text-and-other-symbols,-vertically-align" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1989">For optimal layout with text and other symbols, vertically align</tspan>
                </text>
                <text id="symbols-with-the-adjacent-text." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="2007">symbols with the adjacent text.</tspan>
                </text>
                <line x1="776" y1="1919" x2="776" y2="1933" id="è·¯å¾„" stroke="#00AEEF" stroke-width="0.5"></line>
                <g id="ç¼–ç»„" transform="translate(778.4902, 1918.7324)" fill="#000000" fill-rule="nonzero">
                    <path d="M0.8203116,14.423832 C1.3378896,14.423832 1.5917956,14.2285116 1.7773436,13.681636 L3.0371096,10.234376 L8.7988296,10.234376 L10.0585956,13.681636 C10.2441424,14.228512 10.4980496,14.423832 11.0058616,14.423832 C11.5234396,14.423832 11.8554716,14.111324 11.8554716,13.623042 C11.8554716,13.4570264 11.8261748,13.300776 11.7480498,13.095698 L7.1679698,0.898438 C6.9433598,0.302734 6.5429698,0 5.9179698,0 C5.3125018,0 4.9023458,0.292968 4.6875018,0.888672 L0.1074218,13.105472 C0.0292968,13.31055 -3.55271368e-16,13.4668 -3.55271368e-16,13.632816 C-3.55271368e-16,14.121098 0.3125,14.423832 0.820312,14.423832 L0.8203116,14.423832 Z M3.5156316,8.750004 L5.8886716,2.177744 L5.9374998,2.177744 L8.3105398,8.750004 L3.5156316,8.750004 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="792.836" y1="1919" x2="792.836" y2="1933" id="è·¯å¾„" stroke="#00AEEF" stroke-width="0.5"></line>
                <text id="Margins" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="1953">Margins</tspan>
                </text>
                <text id="Leading-and-trailing-margins-on-the-left-and-right-side-of-each-symbol" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="1971">Leading and trailing margins on the left and right side of each symbol</tspan>
                </text>
                <text id="can-be-adjusted-by-modifying-the-x-location-of-the-margin-guidelines." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="1989">can be adjusted by modifying the x-location of the margin guidelines.</tspan>
                </text>
                <text id="Modifications-are-automatically-applied-proportionally-to-all" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="2007">Modifications are automatically applied proportionally to all</tspan>
                </text>
                <text id="scales-and-weights." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="2025">scales and weights.</tspan>
                </text>
                <g id="ç¼–ç»„" transform="translate(1291.2481, 1914.5174)" fill="#000000" fill-rule="nonzero">
                    <path d="M0.593687825,20.3477978 L2.29290583,22.0567818 C3.15228183,22.9259218 4.13860983,22.8673278 5.06634583,21.8419378 L15.7597058,10.0548378 L14.7929098,9.07827578 L4.17766983,20.7579558 C3.82610783,21.1583458 3.49407583,21.2560018 3.02532583,20.7872526 L1.85344983,19.6251426 C1.38469983,19.1661586 1.49212183,18.8243606 1.89251223,18.4630326 L13.3671122,7.66225258 L12.3905502,6.69545658 L0.798750225,17.5841366 C-0.187577775,18.5021046 -0.265703775,19.4786686 0.593672225,20.3478166 L0.593687825,20.3477978 Z M7.00970783,2.15443778 C6.58978583,2.56459378 6.56048983,3.14076578 6.79486383,3.53139178 C7.02923983,3.89271978 7.48822383,4.12709578 8.13275383,3.96107978 C9.59759783,3.61928378 11.1210338,3.56068978 12.5468138,4.49818978 L11.9608758,5.95326778 C11.6190798,6.78334578 11.7948602,7.36928378 12.3319698,7.91615778 L14.6268898,10.2306178 C15.1151718,10.7188998 15.5253278,10.7384298 16.0917338,10.6407738 L17.1561878,10.4454614 L17.8202498,11.1192894 L17.7811874,11.6759294 C17.742125,12.1739754 17.869078,12.5548354 18.3573594,13.0333514 L19.1190774,13.7755394 C19.5975934,14.2540554 20.2128274,14.2833514 20.6815774,13.8146018 L23.5917374,10.8946818 C24.0604874,10.4259318 24.0409554,9.83022778 23.5624406,9.35171378 L22.7909566,8.58999578 C22.3124406,8.11147978 21.9413466,7.95522978 21.4628326,7.99429178 L20.8866606,8.04311998 L20.2421286,7.40835398 L20.4862686,6.28530798 C20.6132218,5.71890198 20.4569718,5.27944798 19.8710346,4.69351198 L17.6737746,2.50601198 C14.3339346,-0.814308021 9.90033463,-0.736168021 7.00971463,2.15444998 L7.00970783,2.15443778 Z M8.50384783,2.52553178 C10.9354878,0.748187779 14.2265078,1.05092178 16.4530678,3.27748578 L18.8847078,5.68958578 C19.1190838,5.92396178 19.1581458,6.10950778 19.0897858,6.45130378 L18.7675198,7.93567978 L20.2714258,9.42005578 L21.2577538,9.36146198 C21.5116598,9.35169636 21.5897858,9.3712276 21.7850978,9.56653998 L22.3612698,10.142712 L19.9198698,12.584112 L19.3436978,12.00794 C19.1483854,11.8126276 19.1190878,11.734502 19.1288538,11.47083 L19.1972132,10.494268 L17.7030732,9.00989198 L16.1796352,9.26379798 C15.8573692,9.33215738 15.7108852,9.30286038 15.4667452,9.06848558 L13.4647852,7.06652558 C13.2108792,6.83214958 13.1815812,6.66613558 13.337832,6.29504158 L14.216738,4.20520158 C12.654238,2.75012358 10.622978,2.12512158 8.59173803,2.72082558 C8.43548803,2.75988798 8.37689403,2.63293498 8.50384743,2.52551318 L8.50384783,2.52553178 Z" id="å½¢çŠ¶"></path>
                </g>
                <text id="Exporting" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1289" y="1953">Exporting</tspan>
                </text>
                <text id="Symbols-should-be-outlined-when-exporting-to-ensure-the" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1289" y="1971">Symbols should be outlined when exporting to ensure the</tspan>
                </text>
                <text id="design-is-preserved-when-submitting-to-Xcode." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1289" y="1989">design is preserved when submitting to Xcode.</tspan>
                </text>
                <text id="template-version" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2952" y="1933">Template v.5.0</tspan>
                </text>
                <text id="Requires-Xcode-15-or-greater" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2865" y="1951">Requires Xcode 15 or greater</tspan>
                </text>
                <text id="descriptive-name" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2822" y="1969">Generated from square.and.arrow.up</tspan>
                </text>
                <text id="Typeset-at-100.0-points" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2901" y="1987">Typeset at 100.0 points</tspan>
                </text>
                <text id="Small" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="726">Small</tspan>
                </text>
                <text id="Medium" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1156">Medium</tspan>
                </text>
                <text id="Large" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1586">Large</tspan>
                </text>
            </g>
            <g id="Guides" transform="translate(263, 600.785)">
                <g id="H-reference" transform="translate(76.9937, 24.756)" fill="#27AAE1" fill-rule="nonzero">
                    <path d="M0,70.459 L2.644096,70.459 L28.334446,3.3267 L29.036646,3.3267 L29.036646,0 L27.128946,0 L0,70.459 Z M10.694846,45.9791 L45.987846,45.9791 L45.237846,43.7305 L11.444846,43.7305 L10.694846,45.9791 Z M54.125946,70.459 L56.770046,70.459 L29.644546,0 L28.438946,0 L28.438946,3.3267 L54.125946,70.459 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="0" y1="95.215" x2="2773" y2="95.215" id="Baseline-S" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="0" y1="24.756" x2="2773" y2="24.756" id="Capline-S" stroke="#27AAE1" stroke-width="0.5"></line>
                <g id="H-reference" transform="translate(76.9937, 454.756)" fill="#27AAE1" fill-rule="nonzero">
                    <path d="M0,70.459 L2.644096,70.459 L28.334446,3.3267 L29.036646,3.3267 L29.036646,0 L27.128946,0 L0,70.459 Z M10.694846,45.9791 L45.987846,45.9791 L45.237846,43.7305 L11.444846,43.7305 L10.694846,45.9791 Z M54.125946,70.459 L56.770046,70.459 L29.644546,0 L28.438946,0 L28.438946,3.3267 L54.125946,70.459 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="0" y1="525.215" x2="2773" y2="525.215" id="Baseline-M" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="0" y1="454.755" x2="2773" y2="454.755" id="Capline-M" stroke="#27AAE1" stroke-width="0.5"></line>
                <g id="H-reference" transform="translate(76.9937, 884.756)" fill="#27AAE1" fill-rule="nonzero">
                    <path d="M0,70.459 L2.644096,70.459 L28.334446,3.3267 L29.036646,3.3267 L29.036646,0 L27.128946,0 L0,70.459 Z M10.694846,45.9791 L45.987846,45.9791 L45.237846,43.7305 L11.444846,43.7305 L10.694846,45.9791 Z M54.125946,70.459 L56.770046,70.459 L29.644546,0 L28.438946,0 L28.438946,3.3267 L54.125946,70.459 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="0" y1="955.215" x2="2773" y2="955.215" id="Baseline-L" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="0" y1="884.755" x2="2773" y2="884.755" id="Capline-L" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="254.797" y1="1.13686838e-13" x2="254.797" y2="119.336" id="left-margin-Ultralight-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="338.625" y1="1.13686838e-13" x2="338.625" y2="119.336" id="right-margin-Ultralight-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="1142.73" y1="1.13686838e-13" x2="1142.73" y2="119.336" id="left-margin-Regular-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="1230.96" y1="1.13686838e-13" x2="1230.96" y2="119.336" id="right-margin-Regular-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="2622.99" y1="1.13686838e-13" x2="2622.99" y2="119.336" id="left-margin-Black-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="2717.81" y1="1.13686838e-13" x2="2717.81" y2="119.336" id="right-margin-Black-S" stroke="#00AEEF" stroke-width="0.5"></line>
            </g>
            <g id="Symbols" transform="translate(524, 622)" fill="#000000" fill-rule="nonzero">
                <g id="Black-S" transform="translate(2373, 0)">
                    <path d="M42.3380475,46.9436927 C42.6479014,45.9577685 42.6760831,45.0070642 42.4225925,44.0915796 C42.1690442,43.1760951 41.6690435,42.4296137 40.9225904,41.8521356 C40.1760796,41.2746575 39.2817089,40.9859184 38.2394784,40.9859184 L32.4930183,40.9859184 L43.4789283,22.140892 C43.9014511,21.4084582 43.9929766,20.626757 43.7535047,19.7957885 C43.5140905,18.96482 43.0422714,18.3380745 42.3380475,17.915552 C41.6056709,17.5493352 40.8662271,17.4859337 40.1197163,17.7253477 C39.3732632,17.9648194 38.7465172,18.4366669 38.2394784,19.1408902 L37.3521459,20.4084576 L36.7183617,19.1408902 C36.2957812,18.3521509 35.6901498,17.8451124 34.9014675,17.6197748 C34.1127275,17.3943795 33.3521403,17.4929719 32.6197059,17.915552 C31.8591765,18.3943801 31.373281,19.0281637 31.1620196,19.8169031 C30.9507582,20.6056424 31.0704653,21.3803054 31.5211409,22.140892 L34.014135,26.4084611 L25.6056775,40.9859184 L19.0563434,40.9859184 C18.1830874,40.9859184 17.4577489,41.2676193 16.880328,41.831021 C16.3028494,42.3943651 16.0141101,43.1126648 16.0141101,43.9859201 C16.0141101,44.8310227 16.3028494,45.5352461 16.880328,46.0985901 C17.4577489,46.6619918 18.1830874,46.9436927 19.0563434,46.9436927 L42.3380475,46.9436927 Z M21.0000118,54.9718213 C21.7042357,55.3943437 22.4507176,55.4858979 23.2394576,55.2464839 C24.0281976,55.0070699 24.633829,54.5352513 25.0563518,53.8310279 L27.2957976,49.9859236 C27.0422493,49.4507323 26.6126594,49.0000283 26.007028,48.6338114 C25.4013967,48.2675945 24.6901346,48.0281516 23.8732418,47.9154828 C23.056349,47.802814 22.2253798,47.8591484 21.3803342,48.084486 L19.9014467,50.9154845 C19.5070767,51.6760711 19.401446,52.4507341 19.5845546,53.2394734 C19.7676055,54.0282128 20.2394246,54.6056621 21.0000118,54.9718213 Z M53.9577417,54.9718213 C54.6901761,54.5774516 55.1479476,53.9929641 55.3310562,53.2183588 C55.5141071,52.4436959 55.3943711,51.6760711 54.9718484,50.9154845 L52.7324025,46.9436927 L55.7324067,46.9436927 C56.6056628,46.9436927 57.3662211,46.6619918 58.0140817,46.0985901 C58.662,45.5352461 58.9859591,44.8310227 58.9859591,43.9859201 C58.9859591,43.1126648 58.6761052,42.3943651 58.0563974,41.831021 C57.436632,41.2676193 56.6619684,40.9859184 55.7324067,40.9859184 L49.3521625,40.9859184 L41.9578116,28.1408954 C41.1127084,28.6197234 40.4788953,29.4295774 40.0563725,30.5704572 C39.6338497,31.7112794 39.4577793,32.9436558 39.5281613,34.2675864 C39.598601,35.5915747 39.9295984,36.7465021 40.5211534,37.7323686 L49.8591725,53.8310279 C50.2816953,54.5915568 50.8802885,55.0844901 51.6549521,55.3098277 C52.4296157,55.535223 53.1972122,55.422535 53.9577417,54.9718213 Z M16.4788909,75 C11.1267432,75 7.04222159,73.5915505 4.22532603,70.7746514 C1.40844201,67.9577524 0,63.8732513 0,58.5211483 L0,16.4788949 C0,11.1268092 1.40844201,7.0422909 4.22532603,4.22533992 C7.04222159,1.40844664 11.1267432,0 16.4788909,0 L58.5211783,0 C63.8732683,0 67.9577611,1.40844664 70.7746567,4.22533992 C73.5915522,7.0422909 75,11.1268092 75,16.4788949 L75,58.5211483 C75,63.8732513 73.5915522,67.9577524 70.7746567,70.7746514 C67.9577611,73.5915505 63.8732683,75 58.5211783,75 L16.4788909,75 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="Regular-S" transform="translate(888, 2)">
                    <path d="M43.1986811,47.7243036 C43.4936734,46.7768914 43.5221584,45.8220391 43.284136,44.8597467 C43.0461135,43.897515 42.5567676,43.1054033 41.8160983,42.4834116 C41.0754896,41.8614199 40.1276818,41.5504241 38.9726749,41.5504241 L31.8107754,41.5504241 L44.3996952,19.7953519 C44.8445827,19.0243154 44.9776542,18.224794 44.7989096,17.3967877 C44.6201651,16.5687206 44.1296652,15.9322739 43.32741,15.4874475 C42.5314106,15.1003805 41.7268171,15.0266477 40.9136295,15.266249 C40.1003812,15.5057896 39.4721332,16.0079806 39.0288856,16.7728221 L37.9495854,18.7370975 L36.7508489,16.7728221 C36.2841573,16.0064623 35.6637139,15.5038764 34.8895185,15.2650647 C34.1153231,15.0262529 33.3427068,15.1003805 32.5716697,15.4874475 C31.772512,15.9322739 31.2843505,16.5687206 31.107185,17.3967877 C30.9300196,18.224794 31.0638806,19.0243154 31.5087681,19.7953519 L34.4821048,24.9508802 L24.789266,41.5504241 L17.2223216,41.5504241 C16.3669836,41.5504241 15.6283184,41.8469649 15.0063262,42.4400465 C14.384334,43.0331889 14.0733379,43.7878572 14.0733379,44.7040514 C14.0733379,45.5328472 14.3913489,46.2434216 15.0273711,46.8357744 C15.6634539,47.4281272 16.3951041,47.7243036 17.2223216,47.7243036 L43.1986811,47.7243036 Z M19.4535311,56.7639244 C20.2230499,57.2352922 21.0210536,57.3445552 21.8475422,57.0917136 C22.6739702,56.8388112 23.3088383,56.3276313 23.7521467,55.5581739 L26.1144539,51.3415549 C25.9068599,50.9263674 25.5076759,50.5263941 24.9169017,50.1416351 C24.3261275,49.756876 23.6014923,49.4903689 22.742996,49.3421137 C21.8845605,49.1938584 20.9808467,49.2383471 20.0318546,49.4755798 L18.5170809,52.5379217 C18.101893,53.3651992 17.9684268,54.1721607 18.1166821,54.9588062 C18.2649982,55.7454517 18.7106145,56.3471577 19.4535311,56.7639244 Z M56.4501948,56.7639244 C57.221232,56.319098 57.6961228,55.6959219 57.8748674,54.8943962 C58.053612,54.0929313 57.9205405,53.3074398 57.475653,52.5379217 L54.626399,47.7243036 L58.6345774,47.7243036 C59.5227125,47.7243036 60.278171,47.4281272 60.9009528,46.8357744 C61.5237346,46.2434216 61.8351255,45.5328472 61.8351255,44.7040514 C61.8351255,43.7597367 61.5307495,42.9980534 60.9219976,42.4190017 C60.3133065,41.83995 59.5508331,41.5504241 58.6345774,41.5504241 L51.2034678,41.5504241 L42.9293799,27.2803882 C42.1005833,27.8438917 41.4867904,28.7331801 41.0880011,29.9482534 C40.6892118,31.1633875 40.5495202,32.4741191 40.6689262,33.8804483 C40.7883322,35.2867169 41.1594261,36.509625 41.7822079,37.5491729 L52.2359409,55.5581739 C52.6791885,56.2995715 53.2859665,56.7966911 54.0562748,57.0495328 C54.8265224,57.3023745 55.6244957,57.2071716 56.4501948,56.7639244 Z M16.3513745,75 C11.0351357,75 6.98085909,73.6038257 4.1885446,70.8114772 C1.39618153,68.0191347 0,63.9648645 0,58.6486667 L0,16.3513788 C0,11.0351446 1.39618153,6.98087137 4.1885446,4.18855926 C6.98085909,1.39618642 11.0351357,0 16.3513745,0 L58.6486984,0 C63.963358,0 68.0172399,1.39734039 70.8103439,4.19202118 C73.603448,6.98670197 75,11.0398212 75,16.3513788 L75,58.6486667 C75,63.9601818 73.603448,68.0132828 70.8103439,70.8079697 C68.0172399,73.6026566 63.963358,75 58.6486984,75 L16.3513745,75 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="Ultralight-S" transform="translate(0, 1)">
                    <path d="M42.6214565,47.8134634 C42.8953452,46.8736361 42.9039934,45.9262766 42.6474009,44.9713849 C42.3908084,44.0164311 41.8913241,43.2283339 41.1489479,42.6070932 C40.4066337,41.9858525 39.4596468,41.6752322 38.3079874,41.6752322 L30.9976122,41.6752322 L43.8474466,19.4285726 C44.3014894,18.6414983 44.4304986,17.8458378 44.2344741,17.0415912 C44.0383876,16.2372826 43.5172674,15.6081067 42.6711135,15.1540635 C41.9403922,14.7316992 41.1804407,14.6632269 40.3912592,14.9486467 C39.6021397,15.2341286 38.9949721,15.7126593 38.5697563,16.3842391 L37.2636082,18.5119621 L36.0809518,16.3842391 C35.7409156,15.6837702 35.1485335,15.1980171 34.3038055,14.9269799 C33.4590155,14.6560046 32.6431146,14.7316992 31.8561029,15.1540635 C31.0676653,15.6081067 30.5898478,16.2372826 30.4226504,17.0415912 C30.255453,17.8458378 30.3988758,18.6414983 30.8529186,19.4285726 L33.765296,24.6089984 L23.9533767,41.6752322 L16.1479188,41.6752322 C15.3566295,41.6752322 14.6503647,41.9779173 14.0291245,42.5832875 C13.4078222,43.1887198 13.0971711,43.9317785 13.0971711,44.8124635 C13.0971711,45.6311548 13.4081632,46.3359942 14.0301474,46.9269819 C14.6521315,47.5179695 15.3580553,47.8134634 16.1479188,47.8134634 L42.6214565,47.8134634 Z M18.5480101,57.2039557 C19.3061947,57.6305356 20.0729965,57.7079659 20.8484154,57.4362467 C21.6238343,57.1645275 22.2241516,56.6495754 22.6493673,55.8913902 L25.1424494,51.7509738 C24.9305545,51.3272456 24.543527,50.9258352 23.9813669,50.5467426 C23.4192688,50.1676501 22.7137169,49.9024092 21.8647113,49.7510202 C21.0157678,49.5996931 20.1069691,49.6451036 19.1383154,49.8872517 L17.5512422,52.8903904 C17.1274524,53.6802544 16.9912209,54.4834781 17.1425479,55.3000615 C17.2938748,56.116645 17.7623623,56.7512763 18.5480101,57.2039557 Z M56.0657807,57.2039557 C56.8528544,56.7499125 57.3444035,56.1070049 57.540428,55.275233 C57.7364525,54.4435231 57.6074434,53.6485755 57.1534005,52.8903904 L54.2041988,47.8134634 L58.3772518,47.8134634 C59.2565104,47.8134634 60.0139821,47.5179695 60.6496669,46.9269819 C61.2853517,46.3359942 61.6031941,45.6311548 61.6031941,44.8124635 C61.6031941,43.9303526 61.2856926,43.186953 60.6506898,42.5822646 C60.0157489,41.9775763 59.2579363,41.6752322 58.3772518,41.6752322 L50.7511731,41.6752322 L42.3057529,27.2730925 C41.4870623,27.8482717 40.8877988,28.7491668 40.5079626,29.9757778 C40.1281884,31.2024507 40.0060605,32.5130634 40.141579,33.9076157 C40.2770976,35.3021681 40.6626992,36.5436266 41.298384,37.6319912 L51.968701,55.8913902 C52.3939168,56.6481495 52.9928082,57.1623888 53.7653754,57.4341079 C54.5380046,57.7058891 55.3048063,57.6291717 56.0657807,57.2039557 Z M14.0321002,75 C9.50537226,75 6.03501933,73.7930008 3.62104135,71.3790024 C1.20701378,68.9649979 0,65.4946393 0,60.9679266 L0,14.0320362 C0,9.50536693 1.20701378,6.03501142 3.62104135,3.62096965 C6.03501933,1.20698988 9.50537226,0 14.0321002,0 L60.9678812,0 C65.46572,0 68.9288507,1.22865675 71.3572732,3.68597024 C73.7857577,6.14322174 75,9.59191039 75,14.0320362 L75,60.9679266 C75,65.408071 73.7857577,68.8567876 71.3572732,71.3140763 C68.9288507,73.7713588 65.46572,75 60.9678812,75 L14.0321002,75 Z" id="å½¢çŠ¶"></path>
                </g>
            </g>
        </g>
    </g>
</svg>
```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/app.symbolset/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "symbols" : [
    {
      "filename" : "app.svg",
      "idiom" : "universal"
    }
  ]
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/app.symbolset/app.svg`:

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg width="3300px" height="2200px" viewBox="0 0 3300 2200" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>square.and.arrow.up</title>
    <g id="é¡µé¢-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="square.and.arrow.up">
            <g id="Notes">
                <rect id="artboard" fill="#FFFFFF" fill-rule="nonzero" x="0" y="0" width="3300" height="2200"></rect>
                <line x1="263" y1="292" x2="3036" y2="292" id="è·¯å¾„" stroke="#000000" stroke-width="0.5"></line>
                <text id="Weight/Scale-Variations" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="322">Weight/Scale Variations</tspan>
                </text>
                <text id="Ultralight" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="533.711" y="322">Ultralight</tspan>
                </text>
                <text id="Thin" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="843.422" y="322">Thin</tspan>
                </text>
                <text id="Light" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1138.63" y="322">Light</tspan>
                </text>
                <text id="Regular" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1426.84" y="322">Regular</tspan>
                </text>
                <text id="Medium" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1723.06" y="322">Medium</tspan>
                </text>
                <text id="Semibold" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2015.77" y="322">Semibold</tspan>
                </text>
                <text id="Bold" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2326.48" y="322">Bold</tspan>
                </text>
                <text id="Heavy" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2618.19" y="322">Heavy</tspan>
                </text>
                <text id="Black" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2917.4" y="322">Black</tspan>
                </text>
                <line x1="263" y1="1903" x2="3036" y2="1903" id="è·¯å¾„" stroke="#000000" stroke-width="0.5"></line>
                <g id="ç¼–ç»„" transform="translate(264.3672, 1918.0684)" fill="#000000" fill-rule="nonzero">
                    <path d="M7.88088,15.76172 C12.18752,15.76172 15.7715,12.1875 15.7715,7.88086 C15.7715,3.57422 12.17774,0 7.8711,0 C3.57422,0 0,3.57422 0,7.88086 C0,12.1875 3.58398,15.76172 7.88086,15.76172 L7.88088,15.76172 Z M7.88088,14.277344 C4.33596,14.277344 1.50392,11.435544 1.50392,7.880864 C1.50392,4.326184 4.32618,1.484384 7.8711,1.484384 C11.42578,1.484384 14.27734,4.326184 14.27734,7.880864 C14.27734,11.435544 11.43554,14.277344 7.88086,14.277344 L7.88088,14.277344 Z M4.28712,7.880864 C4.28712,8.310552 4.589854,8.60352 5.039074,8.60352 L7.138674,8.60352 L7.138674,10.72266 C7.138674,11.162114 7.431642,11.464848 7.86133,11.464848 C8.310548,11.464848 8.603518,11.162114 8.603518,10.72266 L8.603518,8.60352 L10.722658,8.60352 C11.162112,8.60352 11.464846,8.310552 11.464846,7.880864 C11.464846,7.44141 11.162112,7.138676 10.722658,7.138676 L8.603518,7.138676 L8.603518,5.029296 C8.603518,4.580078 8.31055,4.277342 7.86133,4.277342 C7.431642,4.277342 7.138674,4.580076 7.138674,5.029296 L7.138674,7.138676 L5.039074,7.138676 C4.589856,7.138676 4.28712,7.44141 4.28712,7.880864 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="ç¼–ç»„" transform="translate(283.254, 1915.9883)" fill="#000000" fill-rule="nonzero">
                    <path d="M9.96094,19.92188 C15.41016,19.92188 19.92188,15.4004 19.92188,9.96094 C19.92188,4.51172 15.4004,0 9.95118,0 C4.51172,0 0,4.51172 0,9.96094 C0,15.4004 4.52148,19.92188 9.96094,19.92188 Z M9.96094,18.261724 C5.35156,18.261724 1.66992,14.570324 1.66992,9.960944 C1.66992,5.351564 5.3418,1.660164 9.95116,1.660164 C14.56052,1.660164 18.2617,5.351564 18.2617,9.960944 C18.2617,14.570324 14.5703,18.261724 9.96092,18.261724 L9.96094,18.261724 Z M5.4297,9.960944 C5.4297,10.43946 5.761732,10.761726 6.259778,10.761726 L9.130878,10.761726 L9.130878,13.642586 C9.130878,14.130868 9.46291,14.472664 9.941424,14.472664 C10.4297,14.472664 10.771502,14.140632 10.771502,13.642586 L10.771502,10.761726 L13.652362,10.761726 C14.140644,10.761726 14.48244,10.43946 14.48244,9.960944 C14.48244,9.472662 14.140644,9.130866 13.652362,9.130866 L10.771502,9.130866 L10.771502,6.259766 C10.771502,5.76172 10.4297,5.419922 9.941424,5.419922 C9.462908,5.419922 9.130878,5.761718 9.130878,6.259766 L9.130878,9.130866 L6.259778,9.130866 C5.761732,9.130866 5.4297,9.472662 5.4297,9.960944 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="ç¼–ç»„" transform="translate(307.1798, 1913.2246)" fill="#000000" fill-rule="nonzero">
                    <path d="M12.71486,25.43944 C19.67776,25.43944 25.43946,19.67772 25.43946,12.7246 C25.43946,5.7617 19.66798,0 12.70508,0 C5.75196,0 -1.42108547e-15,5.76172 -1.42108547e-15,12.7246 C-1.42108547e-15,19.67772 5.76172,25.43944 12.71484,25.43944 L12.71486,25.43944 Z M12.71486,23.623034 C6.6797,23.623034 1.82618,18.759754 1.82618,12.724594 C1.82618,6.679674 6.66994,1.826154 12.70508,1.826154 C18.75,1.826154 23.61328,6.679674 23.61328,12.724594 C23.61328,18.759754 18.75976,23.623034 12.71484,23.623034 L12.71486,23.623034 Z M6.94338,12.724594 C6.94338,13.242172 7.314474,13.6035 7.861348,13.6035 L11.806668,13.6035 L11.806668,17.55858 C11.806668,18.09569 12.177762,18.476548 12.69534,18.476548 C13.23245,18.476548 13.603544,18.105454 13.603544,17.55858 L13.603544,13.6035 L17.558624,13.6035 C18.095734,13.6035 18.476592,13.242172 18.476592,12.724594 C18.476592,12.177718 18.105498,11.806626 17.558624,11.806626 L13.603544,11.806626 L13.603544,7.861306 C13.603544,7.31443 13.23245,6.933572 12.69534,6.933572 C12.177762,6.933572 11.806668,7.314432 11.806668,7.861306 L11.806668,11.806626 L7.861348,11.806626 C7.314472,11.806626 6.94338,12.17772 6.94338,12.724594 Z" id="å½¢çŠ¶"></path>
                </g>
                <text id="Design-Variations" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1953">Design Variations</tspan>
                </text>
                <text id="Symbols-are-supported-in-up-to-nine-weights-and-three-scales." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1971">Symbols are supported in up to nine weights and three scales.</tspan>
                </text>
                <text id="For-optimal-layout-with-text-and-other-symbols,-vertically-align" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1989">For optimal layout with text and other symbols, vertically align</tspan>
                </text>
                <text id="symbols-with-the-adjacent-text." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="2007">symbols with the adjacent text.</tspan>
                </text>
                <line x1="776" y1="1919" x2="776" y2="1933" id="è·¯å¾„" stroke="#00AEEF" stroke-width="0.5"></line>
                <g id="ç¼–ç»„" transform="translate(778.4902, 1918.7324)" fill="#000000" fill-rule="nonzero">
                    <path d="M0.8203116,14.423832 C1.3378896,14.423832 1.5917956,14.2285116 1.7773436,13.681636 L3.0371096,10.234376 L8.7988296,10.234376 L10.0585956,13.681636 C10.2441424,14.228512 10.4980496,14.423832 11.0058616,14.423832 C11.5234396,14.423832 11.8554716,14.111324 11.8554716,13.623042 C11.8554716,13.4570264 11.8261748,13.300776 11.7480498,13.095698 L7.1679698,0.898438 C6.9433598,0.302734 6.5429698,0 5.9179698,0 C5.3125018,0 4.9023458,0.292968 4.6875018,0.888672 L0.1074218,13.105472 C0.0292968,13.31055 -3.55271368e-16,13.4668 -3.55271368e-16,13.632816 C-3.55271368e-16,14.121098 0.3125,14.423832 0.820312,14.423832 L0.8203116,14.423832 Z M3.5156316,8.750004 L5.8886716,2.177744 L5.9374998,2.177744 L8.3105398,8.750004 L3.5156316,8.750004 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="792.836" y1="1919" x2="792.836" y2="1933" id="è·¯å¾„" stroke="#00AEEF" stroke-width="0.5"></line>
                <text id="Margins" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="1953">Margins</tspan>
                </text>
                <text id="Leading-and-trailing-margins-on-the-left-and-right-side-of-each-symbol" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="1971">Leading and trailing margins on the left and right side of each symbol</tspan>
                </text>
                <text id="can-be-adjusted-by-modifying-the-x-location-of-the-margin-guidelines." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="1989">can be adjusted by modifying the x-location of the margin guidelines.</tspan>
                </text>
                <text id="Modifications-are-automatically-applied-proportionally-to-all" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="2007">Modifications are automatically applied proportionally to all</tspan>
                </text>
                <text id="scales-and-weights." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="776" y="2025">scales and weights.</tspan>
                </text>
                <g id="ç¼–ç»„" transform="translate(1291.2481, 1914.5174)" fill="#000000" fill-rule="nonzero">
                    <path d="M0.593687825,20.3477978 L2.29290583,22.0567818 C3.15228183,22.9259218 4.13860983,22.8673278 5.06634583,21.8419378 L15.7597058,10.0548378 L14.7929098,9.07827578 L4.17766983,20.7579558 C3.82610783,21.1583458 3.49407583,21.2560018 3.02532583,20.7872526 L1.85344983,19.6251426 C1.38469983,19.1661586 1.49212183,18.8243606 1.89251223,18.4630326 L13.3671122,7.66225258 L12.3905502,6.69545658 L0.798750225,17.5841366 C-0.187577775,18.5021046 -0.265703775,19.4786686 0.593672225,20.3478166 L0.593687825,20.3477978 Z M7.00970783,2.15443778 C6.58978583,2.56459378 6.56048983,3.14076578 6.79486383,3.53139178 C7.02923983,3.89271978 7.48822383,4.12709578 8.13275383,3.96107978 C9.59759783,3.61928378 11.1210338,3.56068978 12.5468138,4.49818978 L11.9608758,5.95326778 C11.6190798,6.78334578 11.7948602,7.36928378 12.3319698,7.91615778 L14.6268898,10.2306178 C15.1151718,10.7188998 15.5253278,10.7384298 16.0917338,10.6407738 L17.1561878,10.4454614 L17.8202498,11.1192894 L17.7811874,11.6759294 C17.742125,12.1739754 17.869078,12.5548354 18.3573594,13.0333514 L19.1190774,13.7755394 C19.5975934,14.2540554 20.2128274,14.2833514 20.6815774,13.8146018 L23.5917374,10.8946818 C24.0604874,10.4259318 24.0409554,9.83022778 23.5624406,9.35171378 L22.7909566,8.58999578 C22.3124406,8.11147978 21.9413466,7.95522978 21.4628326,7.99429178 L20.8866606,8.04311998 L20.2421286,7.40835398 L20.4862686,6.28530798 C20.6132218,5.71890198 20.4569718,5.27944798 19.8710346,4.69351198 L17.6737746,2.50601198 C14.3339346,-0.814308021 9.90033463,-0.736168021 7.00971463,2.15444998 L7.00970783,2.15443778 Z M8.50384783,2.52553178 C10.9354878,0.748187779 14.2265078,1.05092178 16.4530678,3.27748578 L18.8847078,5.68958578 C19.1190838,5.92396178 19.1581458,6.10950778 19.0897858,6.45130378 L18.7675198,7.93567978 L20.2714258,9.42005578 L21.2577538,9.36146198 C21.5116598,9.35169636 21.5897858,9.3712276 21.7850978,9.56653998 L22.3612698,10.142712 L19.9198698,12.584112 L19.3436978,12.00794 C19.1483854,11.8126276 19.1190878,11.734502 19.1288538,11.47083 L19.1972132,10.494268 L17.7030732,9.00989198 L16.1796352,9.26379798 C15.8573692,9.33215738 15.7108852,9.30286038 15.4667452,9.06848558 L13.4647852,7.06652558 C13.2108792,6.83214958 13.1815812,6.66613558 13.337832,6.29504158 L14.216738,4.20520158 C12.654238,2.75012358 10.622978,2.12512158 8.59173803,2.72082558 C8.43548803,2.75988798 8.37689403,2.63293498 8.50384743,2.52551318 L8.50384783,2.52553178 Z" id="å½¢çŠ¶"></path>
                </g>
                <text id="Exporting" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1289" y="1953">Exporting</tspan>
                </text>
                <text id="Symbols-should-be-outlined-when-exporting-to-ensure-the" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1289" y="1971">Symbols should be outlined when exporting to ensure the</tspan>
                </text>
                <text id="design-is-preserved-when-submitting-to-Xcode." fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="1289" y="1989">design is preserved when submitting to Xcode.</tspan>
                </text>
                <text id="template-version" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2952" y="1933">Template v.5.0</tspan>
                </text>
                <text id="Requires-Xcode-15-or-greater" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2865" y="1951">Requires Xcode 15 or greater</tspan>
                </text>
                <text id="descriptive-name" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2822" y="1969">Generated from square.and.arrow.up</tspan>
                </text>
                <text id="Typeset-at-100.0-points" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="2901" y="1987">Typeset at 100.0 points</tspan>
                </text>
                <text id="Small" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="726">Small</tspan>
                </text>
                <text id="Medium" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1156">Medium</tspan>
                </text>
                <text id="Large" fill="#000000" fill-rule="nonzero" font-family="Helvetica" font-size="13" font-weight="normal">
                    <tspan x="263" y="1586">Large</tspan>
                </text>
            </g>
            <g id="Guides" transform="translate(263, 600.785)">
                <g id="H-reference" transform="translate(76.9937, 24.756)" fill="#27AAE1" fill-rule="nonzero">
                    <path d="M0,70.459 L2.644096,70.459 L28.334446,3.3267 L29.036646,3.3267 L29.036646,0 L27.128946,0 L0,70.459 Z M10.694846,45.9791 L45.987846,45.9791 L45.237846,43.7305 L11.444846,43.7305 L10.694846,45.9791 Z M54.125946,70.459 L56.770046,70.459 L29.644546,0 L28.438946,0 L28.438946,3.3267 L54.125946,70.459 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="0" y1="95.215" x2="2773" y2="95.215" id="Baseline-S" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="0" y1="24.756" x2="2773" y2="24.756" id="Capline-S" stroke="#27AAE1" stroke-width="0.5"></line>
                <g id="H-reference" transform="translate(76.9937, 454.756)" fill="#27AAE1" fill-rule="nonzero">
                    <path d="M0,70.459 L2.644096,70.459 L28.334446,3.3267 L29.036646,3.3267 L29.036646,0 L27.128946,0 L0,70.459 Z M10.694846,45.9791 L45.987846,45.9791 L45.237846,43.7305 L11.444846,43.7305 L10.694846,45.9791 Z M54.125946,70.459 L56.770046,70.459 L29.644546,0 L28.438946,0 L28.438946,3.3267 L54.125946,70.459 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="0" y1="525.215" x2="2773" y2="525.215" id="Baseline-M" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="0" y1="454.755" x2="2773" y2="454.755" id="Capline-M" stroke="#27AAE1" stroke-width="0.5"></line>
                <g id="H-reference" transform="translate(76.9937, 884.756)" fill="#27AAE1" fill-rule="nonzero">
                    <path d="M0,70.459 L2.644096,70.459 L28.334446,3.3267 L29.036646,3.3267 L29.036646,0 L27.128946,0 L0,70.459 Z M10.694846,45.9791 L45.987846,45.9791 L45.237846,43.7305 L11.444846,43.7305 L10.694846,45.9791 Z M54.125946,70.459 L56.770046,70.459 L29.644546,0 L28.438946,0 L28.438946,3.3267 L54.125946,70.459 Z" id="å½¢çŠ¶"></path>
                </g>
                <line x1="0" y1="955.215" x2="2773" y2="955.215" id="Baseline-L" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="0" y1="884.755" x2="2773" y2="884.755" id="Capline-L" stroke="#27AAE1" stroke-width="0.5"></line>
                <line x1="254.797" y1="1.13686838e-13" x2="254.797" y2="119.336" id="left-margin-Ultralight-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="338.625" y1="1.13686838e-13" x2="338.625" y2="119.336" id="right-margin-Ultralight-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="1142.73" y1="1.13686838e-13" x2="1142.73" y2="119.336" id="left-margin-Regular-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="1230.96" y1="1.13686838e-13" x2="1230.96" y2="119.336" id="right-margin-Regular-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="2622.99" y1="1.13686838e-13" x2="2622.99" y2="119.336" id="left-margin-Black-S" stroke="#00AEEF" stroke-width="0.5"></line>
                <line x1="2717.81" y1="1.13686838e-13" x2="2717.81" y2="119.336" id="right-margin-Black-S" stroke="#00AEEF" stroke-width="0.5"></line>
            </g>
            <g id="Symbols" transform="translate(521, 623)" fill="#000000" fill-rule="nonzero">
                <g id="Black-S" transform="translate(2375, 0)">
                    <path d="M42.3380475,46.9436927 C42.6479014,45.9577685 42.6760831,45.0070642 42.4225925,44.0915796 C42.1690442,43.1760951 41.6690435,42.4296137 40.9225904,41.8521356 C40.1760796,41.2746575 39.2817089,40.9859184 38.2394784,40.9859184 L32.4930183,40.9859184 L43.4789283,22.140892 C43.9014511,21.4084582 43.9929766,20.626757 43.7535047,19.7957885 C43.5140905,18.96482 43.0422714,18.3380745 42.3380475,17.915552 C41.6056709,17.5493352 40.8662271,17.4859337 40.1197163,17.7253477 C39.3732632,17.9648194 38.7465172,18.4366669 38.2394784,19.1408902 L37.3521459,20.4084576 L36.7183617,19.1408902 C36.2957812,18.3521509 35.6901498,17.8451124 34.9014675,17.6197748 C34.1127275,17.3943795 33.3521403,17.4929719 32.6197059,17.915552 C31.8591765,18.3943801 31.373281,19.0281637 31.1620196,19.8169031 C30.9507582,20.6056424 31.0704653,21.3803054 31.5211409,22.140892 L34.014135,26.4084611 L25.6056775,40.9859184 L19.0563434,40.9859184 C18.1830874,40.9859184 17.4577489,41.2676193 16.880328,41.831021 C16.3028494,42.3943651 16.0141101,43.1126648 16.0141101,43.9859201 C16.0141101,44.8310227 16.3028494,45.5352461 16.880328,46.0985901 C17.4577489,46.6619918 18.1830874,46.9436927 19.0563434,46.9436927 L42.3380475,46.9436927 Z M21.0000118,54.9718213 C21.7042357,55.3943437 22.4507176,55.4858979 23.2394576,55.2464839 C24.0281976,55.0070699 24.633829,54.5352513 25.0563518,53.8310279 L27.2957976,49.9859236 C27.0422493,49.4507323 26.6126594,49.0000283 26.007028,48.6338114 C25.4013967,48.2675945 24.6901346,48.0281516 23.8732418,47.9154828 C23.056349,47.802814 22.2253798,47.8591484 21.3803342,48.084486 L19.9014467,50.9154845 C19.5070767,51.6760711 19.401446,52.4507341 19.5845546,53.2394734 C19.7676055,54.0282128 20.2394246,54.6056621 21.0000118,54.9718213 Z M53.9577417,54.9718213 C54.6901761,54.5774516 55.1479476,53.9929641 55.3310562,53.2183588 C55.5141071,52.4436959 55.3943711,51.6760711 54.9718484,50.9154845 L52.7324025,46.9436927 L55.7324067,46.9436927 C56.6056628,46.9436927 57.3662211,46.6619918 58.0140817,46.0985901 C58.662,45.5352461 58.9859591,44.8310227 58.9859591,43.9859201 C58.9859591,43.1126648 58.6761052,42.3943651 58.0563974,41.831021 C57.436632,41.2676193 56.6619684,40.9859184 55.7324067,40.9859184 L49.3521625,40.9859184 L41.9578116,28.1408954 C41.1127084,28.6197234 40.4788953,29.4295774 40.0563725,30.5704572 C39.6338497,31.7112794 39.4577793,32.9436558 39.5281613,34.2675864 C39.598601,35.5915747 39.9295984,36.7465021 40.5211534,37.7323686 L49.8591725,53.8310279 C50.2816953,54.5915568 50.8802885,55.0844901 51.6549521,55.3098277 C52.4296157,55.535223 53.1972122,55.422535 53.9577417,54.9718213 Z M16.4788909,75 C11.1267432,75 7.04222159,73.5915505 4.22532603,70.7746514 C1.40844201,67.9577524 0,63.8732513 0,58.5211483 L0,16.4788949 C0,11.1268092 1.40844201,7.0422909 4.22532603,4.22533992 C7.04222159,1.40844664 11.1267432,0 16.4788909,0 L58.5211783,0 C63.8732683,0 67.9577611,1.40844664 70.7746567,4.22533992 C73.5915522,7.0422909 75,11.1268092 75,16.4788949 L75,58.5211483 C75,63.8732513 73.5915522,67.9577524 70.7746567,70.7746514 C67.9577611,73.5915505 63.8732683,75 58.5211783,75 L16.4788909,75 Z M58.5211783,62.7464883 C60.0986583,62.7464883 61.1338507,62.683107 61.6267555,62.5563445 C62.1197179,62.429582 62.4296007,62.1197226 62.5564037,61.6267663 C62.683149,61.1338099 62.7465216,60.098604 62.7465216,58.5211483 L62.7465216,16.4788949 C62.7465216,14.9014162 62.683149,13.8661958 62.5564037,13.3732337 C62.4296007,12.8802717 62.1197179,12.570418 61.6267555,12.4436728 C61.1338507,12.3169276 60.0986583,12.253555 58.5211783,12.253555 L16.4788909,12.253555 C14.901411,12.253555 13.8661897,12.3169276 13.3732272,12.4436728 C12.8802647,12.570418 12.5704109,12.8802717 12.4436656,13.3732337 C12.3169202,13.8661958 12.2535476,14.9014162 12.2535476,16.4788949 L12.2535476,58.5211483 C12.2535476,60.098604 12.3169202,61.1338099 12.4436656,61.6267663 C12.5704109,62.1197226 12.8802647,62.429582 13.3732272,62.5563445 C13.8661897,62.683107 14.901411,62.7464883 16.4788909,62.7464883 L58.5211783,62.7464883 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="Regular-S" transform="translate(891, 0)">
                    <path d="M43.2316455,47.7192089 C43.5278654,46.7713412 43.5574692,45.8160725 43.3204569,44.8534029 C43.0835053,43.8906727 42.5947697,43.0983159 41.8542504,42.4763327 C41.113731,41.8542889 40.1658637,41.5432669 39.0106486,41.5432669 L31.8572386,41.5432669 L44.431327,19.8163193 C44.8756265,19.0461958 45.0089042,18.2464381 44.8311601,17.4170463 C44.6534161,16.5876544 44.1646805,15.9508087 43.3649536,15.506509 C42.5651659,15.1214168 41.7579774,15.0473467 40.9433878,15.2842984 C40.128859,15.5213109 39.4994145,16.0248788 39.0550543,16.7950024 L37.9887719,18.7499454 L36.7890905,16.7950024 C36.3151872,16.0248788 35.6931436,15.5213109 34.9229598,15.2842984 C34.1528366,15.0473467 33.3827134,15.1214168 32.6125902,15.506509 C31.8128026,15.9508087 31.3240368,16.5876544 31.1462927,17.4170463 C30.9686093,18.2464381 31.1019174,19.0461958 31.5462169,19.8163193 L34.5231266,24.9703841 L24.8370457,41.5432669 L17.2838026,41.5432669 C16.4248073,41.5432669 15.684288,41.8394566 15.0622444,42.431836 C14.4402008,43.0242761 14.129179,43.7796281 14.129179,44.697892 C14.129179,45.5272838 14.4476018,46.2381694 15.0844472,46.8305488 C15.7212927,47.4229889 16.4544111,47.7192089 17.2838026,47.7192089 L43.2316455,47.7192089 Z M19.5053607,56.738754 C20.2754839,57.2126575 21.0752412,57.3237324 21.9046326,57.0719787 C22.734024,56.8202251 23.3708695,56.3092561 23.815169,55.5390719 L26.1700352,51.318164 C25.9626873,50.9034681 25.5627935,50.5035741 24.9703537,50.1184819 C24.3779746,49.7333898 23.6522875,49.4668039 22.7932923,49.3187243 C21.9342364,49.1705839 21.0307748,49.21502 20.0829076,49.4520324 L18.5722954,52.517755 C18.1575997,53.3471468 18.0242916,54.1543055 18.1723712,54.9392309 C18.3205115,55.724217 18.7648413,56.324058 19.5053607,56.738754 Z M56.4721831,56.738754 C57.2423063,56.2944542 57.7162399,55.6724104 57.893984,54.8726224 C58.0716674,54.0728343 57.9383593,53.2878786 57.4940598,52.517755 L54.6504581,47.7192089 L58.6493356,47.7192089 C59.5379346,47.7192089 60.2932559,47.4229889 60.9152994,46.8305488 C61.537343,46.2381694 61.8483648,45.5272838 61.8483648,44.697892 C61.8483648,43.7500243 61.5447439,42.9872713 60.9375023,42.4096332 C60.3302606,41.8320557 59.5675384,41.5432669 58.6493356,41.5432669 L51.2293095,41.5432669 L42.9650294,27.2807547 C42.135638,27.843591 41.5210257,28.7322207 41.1211926,29.946644 C40.7212988,31.1611279 40.5805898,32.4718545 40.6990656,33.8788239 C40.8175414,35.2857932 41.1878011,36.5076477 41.8098447,37.5443875 L52.2511862,55.5390719 C52.6954857,56.2795917 53.3027274,56.7757587 54.0729112,57.027573 C54.8430344,57.2793267 55.6427917,57.1830537 56.4721831,56.738754 Z M16.4840453,75 C11.1226655,75 7.03497663,73.5930094 4.2209787,70.7790283 C1.4069929,67.9650472 0,63.8773655 0,58.5159831 L0,16.4839805 C0,11.1225981 1.4069929,7.03490725 4.2209787,4.22090795 C7.03497663,1.40696932 11.1226655,0 16.4840453,0 L58.5160275,0 C63.8774073,0 67.9650658,1.40696932 70.7790031,4.22090795 C73.593001,7.03490725 75,11.1225981 75,16.4839805 L75,58.5159831 C75,63.8773655 73.593001,67.9650472 70.7790031,70.7790283 C67.9650658,73.5930094 63.8774073,75 58.5160275,75 L16.4840453,75 Z M58.5160275,68.3353041 C61.2411534,68.3353041 63.2923988,68.0687182 64.6697637,67.5355464 C66.0471285,67.0023685 67.0023967,66.0470938 67.5355682,64.6697222 C68.0687398,63.2923567 68.3353255,61.2411104 68.3353255,58.5159831 L68.3353255,16.4839805 C68.3353255,13.7588532 68.0687398,11.7076069 67.5355682,10.3302414 C67.0023967,8.95287584 66.0471285,7.99760719 64.6697637,7.4644354 C63.2923988,6.93126361 61.2411534,6.66467771 58.5160275,6.66467771 L16.4840453,6.66467771 C13.7589194,6.66467771 11.707674,6.93126361 10.3303091,7.4644354 C8.95294429,7.99760719 7.9976761,8.95287584 7.46450457,10.3302414 C6.93127238,11.7076069 6.66465628,13.7588532 6.66465628,16.4839805 L6.66465628,58.5159831 C6.66465628,61.2411104 6.93127238,63.2923567 7.46450457,64.6697222 C7.9976761,66.0470938 8.95294429,67.0023685 10.3303091,67.5355464 C11.707674,68.0687182 13.7589194,68.3353041 16.4840453,68.3353041 L58.5160275,68.3353041 Z" id="å½¢çŠ¶"></path>
                </g>
                <g id="Ultralight-S">
                    <path d="M42.3105762,48 C42.5811025,47.0625553 42.5886137,46.117555 42.3331098,45.1649992 C42.0776059,44.2124435 41.5815897,43.4262025 40.8450613,42.8062764 C40.1085328,42.1864122 39.1690788,41.8764801 38.0266993,41.8764801 L30.7667253,41.8764801 L43.5280369,19.6503641 C43.9790167,18.8641541 44.1067994,18.0703576 43.9113851,17.2689746 C43.7159708,16.4676535 43.1973903,15.8401719 42.3556434,15.3865296 C41.6341374,14.9631715 40.8825865,14.8951406 40.1009908,15.1824371 C39.3193952,15.4697335 38.7181606,15.9460114 38.2972872,16.6112708 L36.9895998,18.7431415 L35.8171139,16.6112708 C35.4864365,15.9157892 34.9002243,15.4319558 34.0584775,15.1597704 C33.2167307,14.8875851 32.4050594,14.9631715 31.6234638,15.3865296 C30.8418681,15.8401719 30.3683855,16.4676535 30.203016,17.2689746 C30.0377081,18.0703576 30.1805132,18.8641541 30.6314314,19.6503641 L33.5173941,24.8213282 L23.7772468,41.8764801 L16.0212567,41.8764801 C15.2395994,41.8764801 14.5406577,42.1788567 13.9244316,42.7836098 C13.3081439,43.3884248 13,44.1293015 13,45.0062399 C13,45.822734 13.3081439,46.5258021 13.9244316,47.1154441 C14.5406577,47.705148 15.2395994,48 16.0212567,48 L42.3105762,48 Z M18.4580026,57.6092064 C19.2099521,58.0372348 19.9694167,58.113655 20.7363966,57.838467 C21.5033764,57.5633417 22.0974147,57.0436153 22.5185113,56.2792878 L25,52.1060107 C24.7894517,51.6779823 24.405931,51.2729018 23.8494378,50.8907694 C23.2930063,50.5085743 22.5936939,50.2410565 21.7515007,50.0882161 C20.9093074,49.935313 20.0069619,49.9811777 19.0444641,50.2258101 L17.4654441,53.2525019 C17.0443475,54.047385 16.9089818,54.8575772 17.059347,55.6830785 C17.2097123,56.5085797 17.6759308,57.1506224 18.4580026,57.6092064 Z M56.3338897,56.6170247 C57.1388952,56.1676153 57.6420316,55.5309315 57.8432989,54.7069734 C58.0445661,53.8830152 57.9129878,53.0965181 57.448564,52.347482 L54.4297456,47.3139923 L58.7024893,47.3139923 C59.6004557,47.3139923 60.3745166,47.0218517 61.0246719,46.4375703 C61.6748906,45.8533504 62,45.1567474 62,44.3477614 C62,43.4788868 61.6748906,42.7448229 61.0246719,42.1455694 C60.3745166,41.5463773 59.6004557,41.2467813 58.7024893,41.2467813 L50.8999596,41.2467813 L42.2614479,27 C41.4254343,27.5693092 40.8139281,28.4606726 40.4269294,29.6740903 C40.0398673,30.8875693 39.9159934,32.1834257 40.0553079,33.5616596 C40.1946858,34.939832 40.5894841,36.1682525 41.2397028,37.246921 L52.15398,55.3137129 C52.5874592,56.062749 53.1989654,56.5720776 53.9884986,56.8416987 C54.7780318,57.1113812 55.5598288,57.0364898 56.3338897,56.6170247 Z M13.909071,75 C9.42425985,75 5.98485994,73.8030305 3.59087128,71.4090915 C1.19695709,69.0151525 0,65.5757588 0,61.0909104 L0,13.9090896 C0,9.4242164 1.19695709,5.9848165 3.59087128,3.5908899 C5.98485994,1.1969633 9.42425985,0 13.909071,0 L61.0909104,0 C65.545498,0 68.9773265,1.21967749 71.3863959,3.65903246 C73.7954653,6.0984495 75,9.51513522 75,13.9090896 L75,61.0909104 C75,65.4848462 73.7954653,68.9015133 71.3863959,71.3409117 C68.9773265,73.7803039 65.545498,75 61.0909104,75 L13.909071,75 Z M60.9706744,73 C63.4730523,73 65.6286734,72.5176221 67.4375379,71.5528663 C69.2464642,70.5881082 70.6257727,69.2088069 71.5754636,67.4149623 C72.5251545,65.6211217 73,63.473035 73,60.9707024 L73,14.0293161 C73,11.5269403 72.5251545,9.37885363 71.5754636,7.58505618 C70.6257727,5.79119697 69.2464642,4.41188948 67.4375379,3.44713369 C65.6286734,2.4823779 63.4730523,2 60.9706744,2 L14.0292329,2 C11.4967856,2 9.33363162,2.47484508 7.53977102,3.42453525 C5.74591041,4.37422541 4.37413465,5.74596922 3.42444375,7.53976668 C2.47481458,9.33362588 2,11.496809 2,14.0293161 L2,60.9707024 C2,63.5031848 2.47481458,65.6663463 3.42444375,67.460187 C4.37413465,69.2540302 5.74591041,70.6257925 7.53977102,71.575474 C9.33363162,72.525158 11.4967856,73 14.0292329,73 L60.9706744,73 Z" id="å½¢çŠ¶"></path>
                </g>
            </g>
        </g>
    </g>
</svg>
```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/inject.symbolset/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "symbols" : [
    {
      "filename" : "syringe.svg",
      "idiom" : "universal"
    }
  ]
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Assets.xcassets/inject.symbolset/syringe.svg`:

```svg
<?xml version="1.0" encoding="UTF-8"?>
<!--Generator: Apple Native CoreSVG 341-->
<!DOCTYPE svg
PUBLIC "-//W3C//DTD SVG 1.1//EN"
       "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 3300 2200">
 <!--glyph: "100837", point size: 100.0, font version: "20.0d10e1", template writer version: "138.0.0"-->
 <style>.defaults {-sfsymbols-wiggle-style:linear;-sfsymbols-wiggle-angle:135}

.monochrome-0 {-sfsymbols-motion-group:0;-sfsymbols-layer-tags:syringe}

.multicolor-0:tintColor {-sfsymbols-motion-group:0;-sfsymbols-layer-tags:syringe}

.hierarchical-0:primary {-sfsymbols-motion-group:0;-sfsymbols-layer-tags:syringe}

.SFSymbolsPreviewWireframe {fill:none;opacity:1.0;stroke:black;stroke-width:0.5}
</style>
 <g id="Notes">
  <rect height="2200" id="artboard" style="fill:white;opacity:1" width="3300" x="0" y="0"/>
  <line style="fill:none;stroke:black;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="292" y2="292"/>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;font-weight:bold;" transform="matrix(1 0 0 1 263 322)">Weight/Scale Variations</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 559.711 322)">Ultralight</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 856.422 322)">Thin</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 1153.13 322)">Light</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 1449.84 322)">Regular</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 1746.56 322)">Medium</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 2043.27 322)">Semibold</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 2339.98 322)">Bold</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 2636.69 322)">Heavy</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:middle;" transform="matrix(1 0 0 1 2933.4 322)">Black</text>
  <line style="fill:none;stroke:black;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="1903" y2="1903"/>
  <g transform="matrix(0.2 0 0 0.2 263 1933)">
   <path d="m46.2402 4.15039c21.7773 0 39.4531-17.627 39.4531-39.4043s-17.6758-39.4043-39.4531-39.4043c-21.7285 0-39.4043 17.627-39.4043 39.4043s17.6758 39.4043 39.4043 39.4043Zm0-7.42188c-17.6758 0-31.9336-14.3066-31.9336-31.9824s14.2578-31.9824 31.9336-31.9824 31.9824 14.3066 31.9824 31.9824-14.3066 31.9824-31.9824 31.9824Zm-17.9688-31.9824c0 2.14844 1.51367 3.61328 3.75977 3.61328h10.498v10.5957c0 2.19727 1.46484 3.71094 3.61328 3.71094 2.24609 0 3.71094-1.51367 3.71094-3.71094v-10.5957h10.5957c2.19727 0 3.71094-1.46484 3.71094-3.61328 0-2.19727-1.51367-3.71094-3.71094-3.71094h-10.5957v-10.5469c0-2.24609-1.46484-3.75977-3.71094-3.75977-2.14844 0-3.61328 1.51367-3.61328 3.75977v10.5469h-10.498c-2.24609 0-3.75977 1.51367-3.75977 3.71094Z"/>
  </g>
  <g transform="matrix(0.2 0 0 0.2 281.506 1933)">
   <path d="m58.5449 14.5508c27.4902 0 49.8047-22.3145 49.8047-49.8047s-22.3145-49.8047-49.8047-49.8047-49.8047 22.3145-49.8047 49.8047 22.3145 49.8047 49.8047 49.8047Zm0-8.30078c-22.9492 0-41.5039-18.5547-41.5039-41.5039s18.5547-41.5039 41.5039-41.5039 41.5039 18.5547 41.5039 41.5039-18.5547 41.5039-41.5039 41.5039Zm-22.6562-41.5039c0 2.39258 1.66016 4.00391 4.15039 4.00391h14.3555v14.4043c0 2.44141 1.66016 4.15039 4.05273 4.15039 2.44141 0 4.15039-1.66016 4.15039-4.15039v-14.4043h14.4043c2.44141 0 4.15039-1.61133 4.15039-4.00391 0-2.44141-1.70898-4.15039-4.15039-4.15039h-14.4043v-14.3555c0-2.49023-1.70898-4.19922-4.15039-4.19922-2.39258 0-4.05273 1.70898-4.05273 4.19922v14.3555h-14.3555c-2.49023 0-4.15039 1.70898-4.15039 4.15039Z"/>
  </g>
  <g transform="matrix(0.2 0 0 0.2 304.924 1933)">
   <path d="m74.8535 28.3203c35.1074 0 63.623-28.4668 63.623-63.5742s-28.5156-63.623-63.623-63.623-63.5742 28.5156-63.5742 63.623 28.4668 63.5742 63.5742 63.5742Zm0-9.08203c-30.127 0-54.4922-24.3652-54.4922-54.4922s24.3652-54.4922 54.4922-54.4922 54.4922 24.3652 54.4922 54.4922-24.3652 54.4922-54.4922 54.4922Zm-28.8574-54.4922c0 2.58789 1.85547 4.39453 4.58984 4.39453h19.7266v19.7754c0 2.68555 1.85547 4.58984 4.44336 4.58984 2.68555 0 4.54102-1.85547 4.54102-4.58984v-19.7754h19.7754c2.68555 0 4.58984-1.80664 4.58984-4.39453 0-2.73438-1.85547-4.58984-4.58984-4.58984h-19.7754v-19.7266c0-2.73438-1.85547-4.63867-4.54102-4.63867-2.58789 0-4.44336 1.9043-4.44336 4.63867v19.7266h-19.7266c-2.73438 0-4.58984 1.85547-4.58984 4.58984Z"/>
  </g>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;font-weight:bold;" transform="matrix(1 0 0 1 263 1953)">Design Variations</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 263 1971)">Symbols are supported in up to nine weights and three scales.</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 263 1989)">For optimal layout with text and other symbols, vertically align</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 263 2007)">symbols with the adjacent text.</text>
  <line style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="776" x2="776" y1="1919" y2="1933"/>
  <g transform="matrix(0.2 0 0 0.2 776 1933)">
   <path d="m16.5527 0.78125c2.58789 0 3.85742-0.976562 4.78516-3.71094l6.29883-17.2363h28.8086l6.29883 17.2363c0.927734 2.73438 2.19727 3.71094 4.73633 3.71094 2.58789 0 4.24805-1.5625 4.24805-4.00391 0-0.830078-0.146484-1.61133-0.537109-2.63672l-22.9004-60.9863c-1.12305-2.97852-3.125-4.49219-6.25-4.49219-3.02734 0-5.07812 1.46484-6.15234 4.44336l-22.9004 61.084c-0.390625 1.02539-0.537109 1.80664-0.537109 2.63672 0 2.44141 1.5625 3.95508 4.10156 3.95508Zm13.4766-28.3691 11.8652-32.8613h0.244141l11.8652 32.8613Z"/>
  </g>
  <line style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="792.836" x2="792.836" y1="1919" y2="1933"/>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;font-weight:bold;" transform="matrix(1 0 0 1 776 1953)">Margins</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 776 1971)">Leading and trailing margins on the left and right side of each symbol</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 776 1989)">can be adjusted by modifying the x-location of the margin guidelines.</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 776 2007)">Modifications are automatically applied proportionally to all</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 776 2025)">scales and weights.</text>
  <g transform="matrix(0.2 0 0 0.2 1289 1933)">
   <path d="m14.209 9.32617 8.49609 8.54492c4.29688 4.3457 9.22852 4.05273 13.8672-1.07422l53.4668-58.9355-4.83398-4.88281-53.0762 58.3984c-1.75781 2.00195-3.41797 2.49023-5.76172 0.146484l-5.85938-5.81055c-2.34375-2.29492-1.80664-4.00391 0.195312-5.81055l57.373-54.0039-4.88281-4.83398-57.959 54.4434c-4.93164 4.58984-5.32227 9.47266-1.02539 13.8184Zm32.0801-90.9668c-2.09961 2.05078-2.24609 4.93164-1.07422 6.88477 1.17188 1.80664 3.4668 2.97852 6.68945 2.14844 7.32422-1.70898 14.9414-2.00195 22.0703 2.68555l-2.92969 7.27539c-1.70898 4.15039-0.830078 7.08008 1.85547 9.81445l11.4746 11.5723c2.44141 2.44141 4.49219 2.53906 7.32422 2.05078l5.32227-0.976562 3.32031 3.36914-0.195312 2.7832c-0.195312 2.49023 0.439453 4.39453 2.88086 6.78711l3.80859 3.71094c2.39258 2.39258 5.46875 2.53906 7.8125 0.195312l14.5508-14.5996c2.34375-2.34375 2.24609-5.32227-0.146484-7.71484l-3.85742-3.80859c-2.39258-2.39258-4.24805-3.17383-6.64062-2.97852l-2.88086 0.244141-3.22266-3.17383 1.2207-5.61523c0.634766-2.83203-0.146484-5.0293-3.07617-7.95898l-10.9863-10.9375c-16.6992-16.6016-38.8672-16.2109-53.3203-1.75781Zm7.4707 1.85547c12.1582-8.88672 28.6133-7.37305 39.7461 3.75977l12.1582 12.0605c1.17188 1.17188 1.36719 2.09961 1.02539 3.80859l-1.61133 7.42188 7.51953 7.42188 4.93164-0.292969c1.26953-0.0488281 1.66016 0.0488281 2.63672 1.02539l2.88086 2.88086-12.207 12.207-2.88086-2.88086c-0.976562-0.976562-1.12305-1.36719-1.07422-2.68555l0.341797-4.88281-7.4707-7.42188-7.61719 1.26953c-1.61133 0.341797-2.34375 0.195312-3.56445-0.976562l-10.0098-10.0098c-1.26953-1.17188-1.41602-2.00195-0.634766-3.85742l4.39453-10.4492c-7.8125-7.27539-17.9688-10.4004-28.125-7.42188-0.78125 0.195312-1.07422-0.439453-0.439453-0.976562Z"/>
  </g>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;font-weight:bold;" transform="matrix(1 0 0 1 1289 1953)">Exporting</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 1289 1971)">Symbols should be outlined when exporting to ensure the</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 1289 1989)">design is preserved when submitting to Xcode.</text>
  <text id="template-version" style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:end;" transform="matrix(1 0 0 1 3036 1933)">Template v.6.0</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:end;" transform="matrix(1 0 0 1 3036 1951)">Requires Xcode 16 or greater</text>
  <text id="descriptive-name" style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:end;" transform="matrix(1 0 0 1 3036 1969)">Generated from syringe</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;text-anchor:end;" transform="matrix(1 0 0 1 3036 1987)">Typeset at 100.0 points</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 263 726)">Small</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 263 1156)">Medium</text>
  <text style="stroke:none;fill:black;font-family:sans-serif;font-size:13;" transform="matrix(1 0 0 1 263 1586)">Large</text>
 </g>
 <g id="Guides">
  <g id="H-reference" style="fill:#27AAE1;stroke:none;" transform="matrix(1 0 0 1 339 696)">
   <path d="M0.993654 0L3.63775 0L29.3281-67.1323L30.0303-67.1323L30.0303-70.459L28.1226-70.459ZM11.6885-24.4799L46.9815-24.4799L46.2315-26.7285L12.4385-26.7285ZM55.1196 0L57.7637 0L30.6382-70.459L29.4326-70.459L29.4326-67.1323Z"/>
  </g>
  <line id="Baseline-S" style="fill:none;stroke:#27AAE1;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="696" y2="696"/>
  <line id="Capline-S" style="fill:none;stroke:#27AAE1;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="625.541" y2="625.541"/>
  <g id="H-reference" style="fill:#27AAE1;stroke:none;" transform="matrix(1 0 0 1 339 1126)">
   <path d="M0.993654 0L3.63775 0L29.3281-67.1323L30.0303-67.1323L30.0303-70.459L28.1226-70.459ZM11.6885-24.4799L46.9815-24.4799L46.2315-26.7285L12.4385-26.7285ZM55.1196 0L57.7637 0L30.6382-70.459L29.4326-70.459L29.4326-67.1323Z"/>
  </g>
  <line id="Baseline-M" style="fill:none;stroke:#27AAE1;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="1126" y2="1126"/>
  <line id="Capline-M" style="fill:none;stroke:#27AAE1;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="1055.54" y2="1055.54"/>
  <g id="H-reference" style="fill:#27AAE1;stroke:none;" transform="matrix(1 0 0 1 339 1556)">
   <path d="M0.993654 0L3.63775 0L29.3281-67.1323L30.0303-67.1323L30.0303-70.459L28.1226-70.459ZM11.6885-24.4799L46.9815-24.4799L46.2315-26.7285L12.4385-26.7285ZM55.1196 0L57.7637 0L30.6382-70.459L29.4326-70.459L29.4326-67.1323Z"/>
  </g>
  <line id="Baseline-L" style="fill:none;stroke:#27AAE1;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="1556" y2="1556"/>
  <line id="Capline-L" style="fill:none;stroke:#27AAE1;opacity:1;stroke-width:0.5;" x1="263" x2="3036" y1="1485.54" y2="1485.54"/>
  <line id="right-margin-Black-S" style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="2994.26" x2="2994.26" y1="600.785" y2="720.121"/>
  <line id="left-margin-Black-S" style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="2872.54" x2="2872.54" y1="600.785" y2="720.121"/>
  <line id="right-margin-Regular-S" style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="1503.09" x2="1503.09" y1="600.785" y2="720.121"/>
  <line id="left-margin-Regular-S" style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="1396.6" x2="1396.6" y1="600.785" y2="720.121"/>
  <line id="right-margin-Ultralight-S" style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="609.303" x2="609.303" y1="600.785" y2="720.121"/>
  <line id="left-margin-Ultralight-S" style="fill:none;stroke:#00AEEF;stroke-width:0.5;opacity:1.0;" x1="510.12" x2="510.12" y1="600.785" y2="720.121"/>
 </g>
 <g id="Symbols">
  <g id="Black-S" transform="matrix(1 0 0 1 2872.54 696)">
   <path class="monochrome-0 multicolor-0:tintColor hierarchical-0:primary SFSymbolsPreviewWireframe" d="M10.5469 13.4277C12.793 15.625 16.2109 15.4785 18.457 13.2812L33.3008-1.51367L25.293-9.47266L10.498 5.32227C8.25195 7.56836 8.20312 11.1816 10.5469 13.4277ZM21.9238-7.56836L31.4453 1.95312C36.6211 7.12891 43.7012 6.93359 49.1699 1.46484L87.6953-37.0605L79.6387-45.166L41.8457-7.37305C40.7715-6.29883 39.3066-6.34766 38.1836-7.4707L31.2988-14.3066C30.1758-15.3809 30.1758-16.8945 31.2988-18.0176L68.9941-55.7617L60.9375-63.8184L22.3145-25.2441C16.8945-19.8242 16.6992-12.793 21.9238-7.56836ZM30.6641-25.6348L39.1113-17.1387C40.0391-16.1621 41.6016-16.2109 42.5781-17.1387C43.6035-18.1152 43.5547-19.6289 42.5781-20.6055L34.1309-29.0527ZM38.9648-33.8867L47.4121-25.4395C48.3887-24.4629 49.9023-24.4629 50.8789-25.4395C51.8555-26.416 51.8555-27.9785 50.8789-28.9062L42.3828-37.3535ZM47.2168-42.1875L55.7129-33.7402C56.6895-32.8125 58.1543-32.7637 59.1309-33.7402C60.1074-34.7168 60.0586-36.1816 59.1309-37.1582L50.6836-45.6543ZM55.5176-50.4883L63.9648-41.9922C64.8926-41.0156 66.4551-41.0645 67.4316-41.9922C68.457-42.9688 68.4082-44.4824 67.4316-45.459L58.9844-53.9062ZM54.6387-66.3574L90.1855-30.8105C93.1152-27.8809 97.7539-27.8809 100.684-30.8105C103.564-33.6914 103.613-38.3789 100.684-41.3086L65.1367-76.8555C62.1582-79.834 57.5684-79.7852 54.6387-76.8555C51.709-73.9258 51.709-69.2871 54.6387-66.3574ZM62.793-65.7715L89.5508-38.9648L98.584-48.0469C101.514-50.9766 101.514-55.6152 98.584-58.5449L96.0449-61.084L98.4375-63.5742L100.244-61.7188C103.125-58.7891 107.861-58.8379 110.742-61.7188C113.672-64.6484 113.672-69.2871 110.742-72.2168L97.3145-85.6445C94.3848-88.5742 89.7461-88.5742 86.8164-85.6445C83.9355-82.7637 83.8867-78.0273 86.8164-75.1465L88.6719-73.3398L86.2305-70.8984L82.3242-74.8047C79.3945-77.7344 74.7559-77.7344 71.8262-74.8047Z"/>
  </g>
  <g id="Regular-S" transform="matrix(1 0 0 1 1396.6 696)">
   <path class="monochrome-0 multicolor-0:tintColor hierarchical-0:primary SFSymbolsPreviewWireframe" d="M9.7168 7.61719C10.8887 8.74023 12.6953 8.69141 13.916 7.51953L30.3711-8.93555L26.1719-13.0859L9.7168 3.36914C8.54492 4.54102 8.44727 6.44531 9.7168 7.61719ZM22.9492-12.8906L30.3711-5.51758C34.4238-1.51367 40.0391-1.66016 44.2871-5.95703L84.5215-46.1426L79.541-51.123L39.4043-10.9863C38.0371-9.61914 36.2305-9.7168 34.7656-11.1328L28.5156-17.334C27.0996-18.75 27.0996-20.6055 28.5156-21.9727L68.6035-62.0605L63.5742-67.0898L23.3887-26.8555C18.9941-22.4121 18.8477-16.8945 22.9492-12.8906ZM29.1992-30.5664L38.7207-20.9961C39.5508-20.2148 40.7227-20.2148 41.5039-21.0449C42.2363-21.8262 42.1875-22.998 41.4551-23.7793L31.8848-33.3008ZM37.1582-38.4766L46.6797-28.9062C47.4609-28.1738 48.6816-28.1738 49.4629-28.9062C50.1953-29.6875 50.1465-30.9082 49.4141-31.6895L39.8438-41.2109ZM45.1172-46.4844L54.6387-36.8652C55.4199-36.1328 56.6406-36.1328 57.4219-36.8652C58.1543-37.6465 58.1543-38.8672 57.373-39.6973L47.8027-49.2188ZM53.0762-54.3945L62.5977-44.8242C63.3789-44.0918 64.5508-44.0918 65.332-44.8242C66.1133-45.5078 66.0645-46.8262 65.332-47.6074L55.7617-57.1289ZM56.8359-68.457L85.9375-39.3066C87.3047-37.9395 89.5508-37.9395 90.918-39.3066C92.2852-40.6738 92.2852-42.9199 90.918-44.2871L61.8164-73.4375C60.3516-74.8535 58.2031-74.8047 56.8359-73.4375C55.4688-72.0703 55.3711-69.9219 56.8359-68.457ZM64.5996-68.0176L85.4492-47.0703L88.0859-49.7559C89.4531-51.0742 89.502-53.3691 88.0859-54.6875L82.9102-59.8633L87.207-64.1113L91.6992-59.668C93.0664-58.3008 95.3125-58.3008 96.6797-59.668C97.998-61.0352 97.998-63.2812 96.6797-64.6484L83.3496-77.9297C81.9824-79.2969 79.7363-79.2969 78.3691-77.9297C77.002-76.5625 77.002-74.3164 78.3691-72.9492L82.8613-68.457L78.6133-64.209L72.168-70.6055C70.8008-71.9727 68.5547-71.9727 67.1875-70.6055Z"/>
  </g>
  <g id="Ultralight-S" transform="matrix(1 0 0 1 510.12 696)">
   <path class="monochrome-0 multicolor-0:tintColor hierarchical-0:primary SFSymbolsPreviewWireframe" d="M9.12647 5.16506C9.48097 5.51614 10.1978 5.60354 10.6011 5.15822L27.147-11.4331L25.6724-12.9497L9.12647 3.59619C8.68115 4.04151 8.67431 4.71974 9.12647 5.16506ZM22.5405-15.1157L29.4175-8.24217C32.562-5.10105 36.815-5.1113 40.0186-8.27293L79.9351-48.1406L78.315-49.7153L38.2236-9.57862C36.1299-7.48488 33.3242-7.49172 31.1328-9.63429L23.9292-16.8799C21.7413-19.0225 21.7413-21.8769 23.8838-23.9707L64.0171-64.0586L62.3936-65.6367L22.5713-25.7202C19.3574-22.5483 19.3472-18.3022 22.5405-15.1157ZM28.5181-30.8843L37.313-21.9951C37.689-21.6225 38.4068-21.668 38.8247-21.9985C39.2393-22.3711 39.2359-23.1343 38.8213-23.5068L29.9321-32.3472ZM36.4771-38.7944L45.272-29.9961C45.69-29.5815 46.3203-29.5815 46.7383-29.9961C47.1529-30.3686 47.104-30.999 46.7349-31.417L37.8911-40.3027ZM44.3906-46.7568L53.231-37.9551C53.6489-37.5859 54.2793-37.5405 54.6973-37.9551C55.1118-38.3276 55.1118-38.958 54.6939-39.3794L45.8501-48.2197ZM52.3496-54.7124L61.1445-45.8232C61.5625-45.4541 62.2349-45.4541 62.6074-45.8232C63.0254-46.2798 63.022-46.917 62.6074-47.335L53.7637-56.1753ZM57.9712-69.0474L83.3491-43.666C83.7627-43.2524 84.4649-43.2524 84.8785-43.666C85.3375-44.125 85.3375-44.8271 84.8785-45.2407L59.5459-70.6221C59.0801-71.0391 58.3848-71.0357 57.9712-70.6221C57.5122-70.1631 57.5054-69.5132 57.9712-69.0474ZM63.0103-66.2012L80.4541-48.7051L83.6358-51.8901C84.0494-52.3457 84.0528-53.0059 83.6812-53.3706L76.462-60.5898L83.4834-67.6987L88.4751-62.665C88.9341-62.2514 89.6363-62.2968 90.0499-62.665C90.46-63.124 90.46-63.8262 90.0499-64.2852L78.627-75.7046C78.168-76.1182 77.4658-76.1182 77.0068-75.7046C76.6387-75.291 76.5933-74.5889 77.0068-74.1753L81.9985-69.1836L74.9351-62.1655L67.7178-69.334C67.3042-69.7476 66.6021-69.793 66.1885-69.334Z"/>
  </g>
 </g>
</svg>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Attach Process/AttachToProcessViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class AttachToProcessViewController: AppKitViewController<AttachToProcessViewModel> {
    private let pickerViewController: RunningApplicationPickerViewController

    private let attachRelay = PublishRelay<NSRunningApplication>()

    private let cancelRelay = PublishRelay<Void>()

    override init(viewModel: AttachToProcessViewModel? = nil) {
        let configuration = RunningApplicationPickerViewController.Configuration(title: "Attach To Process", description: "Select a running application to attach to", cancelButtonTitle: "Cancel", confirmButtonTitle: "Attach")
        self.pickerViewController = RunningApplicationPickerViewController(configuration: configuration)
        super.init(viewModel: viewModel)
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            pickerViewController
        }

        pickerViewController.view.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }

        pickerViewController.delegate = self
    }

    override func setupBindings(for viewModel: AttachToProcessViewModel) {
        super.setupBindings(for: viewModel)

        let input = AttachToProcessViewModel.Input(attachToProcess: attachRelay.asSignal(), cancel: cancelRelay.asSignal())

        _ = viewModel.transform(input)
    }
}

extension AttachToProcessViewController: RunningApplicationPickerViewController.Delegate {
    func runningApplicationPickerViewController(_ viewController: RunningApplicationPickerViewController, didConfirmApplication application: NSRunningApplication) {
        attachRelay.accept(application)
    }

    func runningApplicationPickerViewControllerWasCancelled(_ viewController: RunningApplicationPickerViewController) {
        cancelRelay.accept(())
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Attach Process/AttachToProcessViewModel.swift`:

```swift
import AppKit
import FoundationToolbox
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures
import RuntimeViewerHelperClient

final class AttachToProcessViewModel: ViewModel<MainRoute> {
    struct Input {
        let attachToProcess: Signal<NSRunningApplication>
        let cancel: Signal<Void>
    }

    struct Output {}

    enum Error: LocalizedError {
        case sandboxAppNoSupported

        var errorDescription: String? {
            "Sandbox apps are not currently supported"
        }
    }

    @Dependency(\.runtimeInjectClient)
    private var runtimeInjectClient
    
    @Dependency(\.runtimeEngineManager)
    private var runtimeEngineManager

    func transform(_ input: Input) -> Output {
        input.cancel.emit(to: router.rx.trigger(.dismiss)).disposed(by: rx.disposeBag)
        input.attachToProcess.emitOnNext { [weak self] application in
            guard let self,
                  let name = application.localizedName,
                  let bundleIdentifier = application.bundleIdentifier
            else { return }

            Task { @MainActor [weak self] in
                guard let self else { return }
                do {
                    try await runtimeInjectClient.installServerFrameworkIfNeeded()
                    guard let dylibURL = Bundle(url: runtimeInjectClient.serverFrameworkDestinationURL)?.executableURL else { return }
                    try await runtimeEngineManager.launchAttachedRuntimeEngine(name: name, identifier: bundleIdentifier, isSandbox: application.isSandbox)
                    try await runtimeInjectClient.injectApplication(pid: application.processIdentifier, dylibURL: dylibURL)
                    router.trigger(.dismiss)
                } catch {
                    runtimeEngineManager.terminateAttachedRuntimeEngine(name: name, identifier: bundleIdentifier, isSandbox: application.isSandbox)
                    logger.error("\(error, privacy: .public)")
                    errorRelay.accept(error)
                }
            }
        }.disposed(by: rx.disposeBag)

        return Output()
    }
}

private import LaunchServicesPrivate

extension NSRunningApplication {
    fileprivate var applicationProxy: LSApplicationProxy? {
        guard let bundleIdentifier else { return nil }
        return LSApplicationProxy(forIdentifier: bundleIdentifier)
    }

    fileprivate var isSandbox: Bool {
        guard let entitlements = applicationProxy?.entitlements else { return false }
        guard let isSandboxed = entitlements["com.apple.security.app-sandbox"] as? Bool else { return false }
        return isSandboxed
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Base.lproj/MainMenu.xib`:

```xib
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="24506" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="24506"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="NSApplication">
            <connections>
                <outlet property="delegate" destination="Voe-Tx-rLC" id="GzC-gU-4Uq"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customObject id="Voe-Tx-rLC" customClass="AppDelegate" customModule="RuntimeViewer" customModuleProvider="target"/>
        <customObject id="YLy-65-1bz" customClass="NSFontManager"/>
        <menu title="Main Menu" systemMenu="main" id="AYu-sK-qS6">
            <items>
                <menuItem title="RuntimeViewer" id="1Xt-HY-uBw">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="RuntimeViewer" systemMenu="apple" id="uQy-DD-JDr">
                        <items>
                            <menuItem title="About RuntimeViewer" id="5kV-Vb-QxS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="orderFrontStandardAboutPanel:" target="-1" id="Exp-CZ-Vem"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="VOq-y0-SEH"/>
                            <menuItem title="Preferencesâ€¦" keyEquivalent="," id="BOF-NM-1cW">
                                <connections>
                                    <action selector="showSettings:" target="Voe-Tx-rLC" id="4qT-9w-3Oc"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="wFC-TO-SCJ"/>
                            <menuItem title="Services" id="NMo-om-nkz">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Services" systemMenu="services" id="hz9-B4-Xy5"/>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="4je-JR-u6R"/>
                            <menuItem title="Hide RuntimeViewer" keyEquivalent="h" id="Olw-nP-bQN">
                                <connections>
                                    <action selector="hide:" target="-1" id="PnN-Uc-m68"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Hide Others" keyEquivalent="h" id="Vdr-fp-XzO">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="hideOtherApplications:" target="-1" id="VT4-aY-XCT"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Show All" id="Kd2-mp-pUS">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="unhideAllApplications:" target="-1" id="Dhg-Le-xox"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="kCx-OE-vgT"/>
                            <menuItem title="Quit RuntimeViewer" keyEquivalent="q" id="4sb-4s-VLi">
                                <connections>
                                    <action selector="terminate:" target="-1" id="Te7-pn-YzF"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="File" id="dMs-cI-mzQ">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="File" id="bib-Uj-vzu">
                        <items>
                            <menuItem title="New" keyEquivalent="n" id="Was-JA-tGl">
                                <connections>
                                    <action selector="newDocument:" target="-1" id="4Si-XN-c54"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Openâ€¦" keyEquivalent="o" id="IAo-SY-fd9">
                                <connections>
                                    <action selector="openDocument:" target="-1" id="bVn-NM-KNZ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Open Recent" id="tXI-mr-wws">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Open Recent" systemMenu="recentDocuments" id="oas-Oc-fiZ">
                                    <items>
                                        <menuItem title="Clear Menu" id="vNY-rz-j42">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="clearRecentDocuments:" target="-1" id="Daa-9d-B3U"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Open Quickly..." secondaryImage="bolt" catalog="system" keyEquivalent="O" id="4D6-xA-jkK" userLabel="Open Quickly...">
                                <connections>
                                    <action selector="openQuickly:" target="-1" id="gL3-Nr-CKk"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="m54-Is-iLE"/>
                            <menuItem title="Close" keyEquivalent="w" id="DVo-aG-piG">
                                <connections>
                                    <action selector="performClose:" target="-1" id="HmO-Ls-i7Q"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Saveâ€¦" enabled="NO" keyEquivalent="s" id="pxx-59-PXV"/>
                            <menuItem title="Save Asâ€¦" enabled="NO" keyEquivalent="S" id="Bw7-FT-i3A"/>
                            <menuItem title="Revert to Saved" enabled="NO" keyEquivalent="r" id="KaW-ft-85H"/>
                            <menuItem title="Export" secondaryImage="square.and.arrow.up" catalog="system" id="7Dd-Q9-1Hk">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="exportInterface:" target="-1" id="2R7-oW-otZ"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="aJh-i4-bef"/>
                            <menuItem title="Page Setupâ€¦" keyEquivalent="P" id="qIS-W8-SiK">
                                <modifierMask key="keyEquivalentModifierMask" shift="YES" command="YES"/>
                                <connections>
                                    <action selector="runPageLayout:" target="-1" id="Din-rz-gC5"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Printâ€¦" keyEquivalent="p" id="aTl-1u-JFS">
                                <connections>
                                    <action selector="print:" target="-1" id="qaZ-4w-aoO"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Edit" id="5QF-Oa-p0T">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Edit" id="W48-6f-4Dl">
                        <items>
                            <menuItem title="Undo" keyEquivalent="z" id="dRJ-4n-Yzg">
                                <connections>
                                    <action selector="undo:" target="-1" id="M6e-cu-g7V"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Redo" keyEquivalent="Z" id="6dh-zS-Vam">
                                <connections>
                                    <action selector="redo:" target="-1" id="oIA-Rs-6OD"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="WRV-NI-Exz"/>
                            <menuItem title="Cut" keyEquivalent="x" id="uRl-iY-unG">
                                <connections>
                                    <action selector="cut:" target="-1" id="YJe-68-I9s"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Copy" keyEquivalent="c" id="x3v-GG-iWU">
                                <connections>
                                    <action selector="copy:" target="-1" id="G1f-GL-Joy"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste" keyEquivalent="v" id="gVA-U4-sdL">
                                <connections>
                                    <action selector="paste:" target="-1" id="UvS-8e-Qdg"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Paste and Match Style" keyEquivalent="V" id="WeT-3V-zwk">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="pasteAsPlainText:" target="-1" id="cEh-KX-wJQ"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Delete" id="pa3-QI-u2k">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="delete:" target="-1" id="0Mk-Ml-PaM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Select All" keyEquivalent="a" id="Ruw-6m-B2m">
                                <connections>
                                    <action selector="selectAll:" target="-1" id="VNm-Mi-diN"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="uyl-h8-XO2"/>
                            <menuItem title="Find" id="4EN-yA-p0u">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Find" id="1b7-l0-nxx">
                                    <items>
                                        <menuItem title="Findâ€¦" tag="1" keyEquivalent="f" id="Xz5-n4-O0W">
                                            <connections>
                                                <action selector="performTextFinderAction:" target="-1" id="XVf-jV-DFh"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find and Replaceâ€¦" tag="12" keyEquivalent="f" id="YEy-JH-Tfz">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="WD3-Gg-5AJ"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Next" tag="2" keyEquivalent="g" id="q09-fT-Sye">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="NDo-RZ-v9R"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Find Previous" tag="3" keyEquivalent="G" id="OwM-mh-QMV">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="HOh-sY-3ay"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Use Selection for Find" tag="7" keyEquivalent="e" id="buJ-ug-pKt">
                                            <connections>
                                                <action selector="performFindPanelAction:" target="-1" id="U76-nv-p5D"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Jump to Selection" keyEquivalent="j" id="S0p-oC-mLd">
                                            <connections>
                                                <action selector="centerSelectionInVisibleArea:" target="-1" id="IOG-6D-g5B"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Spelling and Grammar" id="Dv1-io-Yv7">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Spelling" id="3IN-sU-3Bg">
                                    <items>
                                        <menuItem title="Show Spelling and Grammar" keyEquivalent=":" id="HFo-cy-zxI">
                                            <connections>
                                                <action selector="showGuessPanel:" target="-1" id="vFj-Ks-hy3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Document Now" keyEquivalent=";" id="hz2-CU-CR7">
                                            <connections>
                                                <action selector="checkSpelling:" target="-1" id="fz7-VC-reM"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="bNw-od-mp5"/>
                                        <menuItem title="Check Spelling While Typing" id="rbD-Rh-wIN">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleContinuousSpellChecking:" target="-1" id="7w6-Qz-0kB"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Check Grammar With Spelling" id="mK6-2p-4JG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleGrammarChecking:" target="-1" id="muD-Qn-j4w"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Correct Spelling Automatically" id="78Y-hA-62v">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticSpellingCorrection:" target="-1" id="2lM-Qi-WAP"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Substitutions" id="9ic-FL-obx">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Substitutions" id="FeM-D8-WVr">
                                    <items>
                                        <menuItem title="Show Substitutions" id="z6F-FW-3nz">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="orderFrontSubstitutionsPanel:" target="-1" id="oku-mr-iSq"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="gPx-C9-uUO"/>
                                        <menuItem title="Smart Copy/Paste" id="9yt-4B-nSM">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleSmartInsertDelete:" target="-1" id="3IJ-Se-DZD"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Quotes" id="hQb-2v-fYv">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticQuoteSubstitution:" target="-1" id="ptq-xd-QOA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Dashes" id="rgM-f4-ycn">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDashSubstitution:" target="-1" id="oCt-pO-9gS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smart Links" id="cwL-P1-jid">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticLinkDetection:" target="-1" id="Gip-E3-Fov"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Data Detectors" id="tRr-pd-1PS">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticDataDetection:" target="-1" id="R1I-Nq-Kbl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Text Replacement" id="HFQ-gK-NFA">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleAutomaticTextReplacement:" target="-1" id="DvP-Fe-Py6"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Transformations" id="2oI-Rn-ZJC">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Transformations" id="c8a-y6-VQd">
                                    <items>
                                        <menuItem title="Make Upper Case" id="vmV-6d-7jI">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="uppercaseWord:" target="-1" id="sPh-Tk-edu"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Make Lower Case" id="d9M-CD-aMd">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="lowercaseWord:" target="-1" id="iUZ-b5-hil"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Capitalize" id="UEZ-Bs-lqG">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="capitalizeWord:" target="-1" id="26H-TL-nsh"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Speech" id="xrE-MZ-jX0">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Speech" id="3rS-ZA-NoH">
                                    <items>
                                        <menuItem title="Start Speaking" id="Ynk-f8-cLZ">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="startSpeaking:" target="-1" id="654-Ng-kyl"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Stop Speaking" id="Oyz-dy-DGm">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="stopSpeaking:" target="-1" id="dX8-6p-jy9"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Format" id="jxT-CU-nIS">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Format" id="GEO-Iw-cKr">
                        <items>
                            <menuItem title="Font" id="Gi5-1S-RQB">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Font" systemMenu="font" id="aXa-aM-Jaq">
                                    <items>
                                        <menuItem title="Show Fonts" keyEquivalent="t" id="Q5e-8K-NDq">
                                            <connections>
                                                <action selector="orderFrontFontPanel:" target="YLy-65-1bz" id="WHr-nq-2xA"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Bold" tag="2" keyEquivalent="b" id="GB9-OM-e27">
                                            <connections>
                                                <action selector="addFontTrait:" target="YLy-65-1bz" id="hqk-hr-sYV"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Italic" tag="1" keyEquivalent="i" id="Vjx-xi-njq">
                                            <connections>
                                                <action selector="addFontTrait:" target="YLy-65-1bz" id="IHV-OB-c03"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Underline" keyEquivalent="u" id="WRG-CD-K1S">
                                            <connections>
                                                <action selector="underline:" target="-1" id="FYS-2b-JAY"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="5gT-KC-WSO"/>
                                        <menuItem title="Bigger" tag="3" keyEquivalent="+" id="Ptp-SP-VEL">
                                            <connections>
                                                <action selector="modifyFont:" target="YLy-65-1bz" id="Uc7-di-UnL"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Smaller" tag="4" keyEquivalent="-" id="i1d-Er-qST">
                                            <connections>
                                                <action selector="modifyFont:" target="YLy-65-1bz" id="HcX-Lf-eNd"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="kx3-Dk-x3B"/>
                                        <menuItem title="Kern" id="jBQ-r6-VK2">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Kern" id="tlD-Oa-oAM">
                                                <items>
                                                    <menuItem title="Use Default" id="GUa-eO-cwY">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="useStandardKerning:" target="-1" id="6dk-9l-Ckg"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Use None" id="cDB-IK-hbR">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="turnOffKerning:" target="-1" id="U8a-gz-Maa"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Tighten" id="46P-cB-AYj">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="tightenKerning:" target="-1" id="hr7-Nz-8ro"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Loosen" id="ogc-rX-tC1">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="loosenKerning:" target="-1" id="8i4-f9-FKE"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem title="Ligatures" id="o6e-r0-MWq">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Ligatures" id="w0m-vy-SC9">
                                                <items>
                                                    <menuItem title="Use Default" id="agt-UL-0e3">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="useStandardLigatures:" target="-1" id="7uR-wd-Dx6"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Use None" id="J7y-lM-qPV">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="turnOffLigatures:" target="-1" id="iX2-gA-Ilz"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Use All" id="xQD-1f-W4t">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="useAllLigatures:" target="-1" id="KcB-kA-TuK"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem title="Baseline" id="OaQ-X3-Vso">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Baseline" id="ijk-EB-dga">
                                                <items>
                                                    <menuItem title="Use Default" id="3Om-Ey-2VK">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="unscript:" target="-1" id="0vZ-95-Ywn"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Superscript" id="Rqc-34-cIF">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="superscript:" target="-1" id="3qV-fo-wpU"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Subscript" id="I0S-gh-46l">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="subscript:" target="-1" id="Q6W-4W-IGz"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Raise" id="2h7-ER-AoG">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="raiseBaseline:" target="-1" id="4sk-31-7Q9"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem title="Lower" id="1tx-W0-xDw">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="lowerBaseline:" target="-1" id="OF1-bc-KW4"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="Ndw-q3-faq"/>
                                        <menuItem title="Show Colors" keyEquivalent="C" id="bgn-CT-cEk">
                                            <connections>
                                                <action selector="orderFrontColorPanel:" target="-1" id="mSX-Xz-DV3"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="iMs-zA-UFJ"/>
                                        <menuItem title="Copy Style" keyEquivalent="c" id="5Vv-lz-BsD">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="copyFont:" target="-1" id="GJO-xA-L4q"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Paste Style" keyEquivalent="v" id="vKC-jM-MkH">
                                            <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                            <connections>
                                                <action selector="pasteFont:" target="-1" id="JfD-CL-leO"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                            <menuItem title="Text" id="Fal-I4-PZk">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <menu key="submenu" title="Text" id="d9c-me-L2H">
                                    <items>
                                        <menuItem title="Align Left" keyEquivalent="{" id="ZM1-6Q-yy1">
                                            <connections>
                                                <action selector="alignLeft:" target="-1" id="zUv-R1-uAa"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Center" keyEquivalent="|" id="VIY-Ag-zcb">
                                            <connections>
                                                <action selector="alignCenter:" target="-1" id="spX-mk-kcS"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Justify" id="J5U-5w-g23">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="alignJustified:" target="-1" id="ljL-7U-jND"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Align Right" keyEquivalent="}" id="wb2-vD-lq4">
                                            <connections>
                                                <action selector="alignRight:" target="-1" id="r48-bG-YeY"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="4s2-GY-VfK"/>
                                        <menuItem title="Writing Direction" id="H1b-Si-o9J">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <menu key="submenu" title="Writing Direction" id="8mr-sm-Yjd">
                                                <items>
                                                    <menuItem title="Paragraph" enabled="NO" id="ZvO-Gk-QUH">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                    </menuItem>
                                                    <menuItem id="YGs-j5-SAR">
                                                        <string key="title">	Default</string>
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="makeBaseWritingDirectionNatural:" target="-1" id="qtV-5e-UBP"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem id="Lbh-J2-qVU">
                                                        <string key="title">	Left to Right</string>
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="makeBaseWritingDirectionLeftToRight:" target="-1" id="S0X-9S-QSf"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem id="jFq-tB-4Kx">
                                                        <string key="title">	Right to Left</string>
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="makeBaseWritingDirectionRightToLeft:" target="-1" id="5fk-qB-AqJ"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem isSeparatorItem="YES" id="swp-gr-a21"/>
                                                    <menuItem title="Selection" enabled="NO" id="cqv-fj-IhA">
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                    </menuItem>
                                                    <menuItem id="Nop-cj-93Q">
                                                        <string key="title">	Default</string>
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="makeTextWritingDirectionNatural:" target="-1" id="lPI-Se-ZHp"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem id="BgM-ve-c93">
                                                        <string key="title">	Left to Right</string>
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="makeTextWritingDirectionLeftToRight:" target="-1" id="caW-Bv-w94"/>
                                                        </connections>
                                                    </menuItem>
                                                    <menuItem id="RB4-Sm-HuC">
                                                        <string key="title">	Right to Left</string>
                                                        <modifierMask key="keyEquivalentModifierMask"/>
                                                        <connections>
                                                            <action selector="makeTextWritingDirectionRightToLeft:" target="-1" id="EXD-6r-ZUu"/>
                                                        </connections>
                                                    </menuItem>
                                                </items>
                                            </menu>
                                        </menuItem>
                                        <menuItem isSeparatorItem="YES" id="fKy-g9-1gm"/>
                                        <menuItem title="Show Ruler" id="vLm-3I-IUL">
                                            <modifierMask key="keyEquivalentModifierMask"/>
                                            <connections>
                                                <action selector="toggleRuler:" target="-1" id="FOx-HJ-KwY"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Copy Ruler" keyEquivalent="c" id="MkV-Pr-PK5">
                                            <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                            <connections>
                                                <action selector="copyRuler:" target="-1" id="71i-fW-3W2"/>
                                            </connections>
                                        </menuItem>
                                        <menuItem title="Paste Ruler" keyEquivalent="v" id="LVM-kO-fVI">
                                            <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                            <connections>
                                                <action selector="pasteRuler:" target="-1" id="cSh-wd-qM2"/>
                                            </connections>
                                        </menuItem>
                                    </items>
                                </menu>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="View" id="H8h-7b-M4v">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="View" id="HyV-fh-RgO">
                        <items>
                            <menuItem title="Show Toolbar" keyEquivalent="t" id="snW-S8-Cw5">
                                <modifierMask key="keyEquivalentModifierMask" option="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleToolbarShown:" target="-1" id="BXY-wc-z0C"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Customize Toolbarâ€¦" id="1UK-8n-QPP">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="runToolbarCustomizationPalette:" target="-1" id="pQI-g3-MTW"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="hB3-LF-h0Y"/>
                            <menuItem title="Show Sidebar" keyEquivalent="s" id="kIP-vf-haE">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleSidebar:" target="-1" id="iwa-gc-5KM"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Enter Full Screen" keyEquivalent="f" id="4J7-dP-txa">
                                <modifierMask key="keyEquivalentModifierMask" control="YES" command="YES"/>
                                <connections>
                                    <action selector="toggleFullScreen:" target="-1" id="dU3-MA-1Rq"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Window" id="aUF-d1-5bR">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Window" systemMenu="window" id="Td7-aD-5lo">
                        <items>
                            <menuItem title="Minimize" keyEquivalent="m" id="OY7-WF-poV">
                                <connections>
                                    <action selector="performMiniaturize:" target="-1" id="VwT-WD-YPe"/>
                                </connections>
                            </menuItem>
                            <menuItem title="Zoom" id="R4o-n2-Eq4">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="performZoom:" target="-1" id="DIl-cC-cCs"/>
                                </connections>
                            </menuItem>
                            <menuItem isSeparatorItem="YES" id="eu3-7i-yIM"/>
                            <menuItem title="Bring All to Front" id="LE2-aR-0XJ">
                                <modifierMask key="keyEquivalentModifierMask"/>
                                <connections>
                                    <action selector="arrangeInFront:" target="-1" id="DRN-fu-gQh"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
                <menuItem title="Help" id="wpr-3q-Mcd">
                    <modifierMask key="keyEquivalentModifierMask"/>
                    <menu key="submenu" title="Help" systemMenu="help" id="F2S-fz-NVQ">
                        <items>
                            <menuItem title="RuntimeViewer Help" keyEquivalent="?" id="FKE-Sm-Kum">
                                <connections>
                                    <action selector="showHelp:" target="-1" id="y7X-2Q-9no"/>
                                </connections>
                            </menuItem>
                        </items>
                    </menu>
                </menuItem>
            </items>
            <point key="canvasLocation" x="200" y="121"/>
        </menu>
    </objects>
    <resources>
        <image name="bolt" catalog="system" width="13" height="17"/>
        <image name="square.and.arrow.up" catalog="system" width="15" height="18"/>
    </resources>
</document>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Base/CommonLoadingView.swift`:

```swift
import AppKit
import RuntimeViewerApplication
import RuntimeViewerUI
import RuntimeViewerArchitectures

final class CommonLoadingView: XiblessView {
    public var isRunning: Bool = false {
        didSet {
            if isRunning {
                loadingIndicator.startAnimating()
                isHidden = false
            } else {
                loadingIndicator.stopAnimating()
                isHidden = true
            }
        }
    }

    private lazy var contentView: NSView = {
        if #available(macOS 26.0, *) {
            NSView()
        } else {
            NSVisualEffectView()
        }
    }()

    private let loadingIndicator: MaterialLoadingIndicator = .init(radius: 25, color: .controlAccentColor)

    public override init(frame frameRect: CGRect) {
        super.init(frame: frameRect)

        hierarchy {
            contentView.hierarchy {
                loadingIndicator
            }
        }

        contentView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }

        loadingIndicator.snp.makeConstraints { make in
            make.center.equalToSuperview()
            make.size.equalTo(50)
        }

        loadingIndicator.lineWidth = 5
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Base/TabViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerApplication

struct TabViewItem {
    let normalSymbol: SFSymbols
    let selectedSymbol: SFSymbols
    let viewController: NSViewController
}

class TabViewController: UXViewController {
    private let contentView: NSView = {
        if #available(macOS 26.0, *) {
            UXView()
        } else {
            NSVisualEffectView()
        }
    }()

    private let segmentedControl: any SegmentedControl = {
        if #available(macOS 26.0, *) {
            NSSegmentedControl()
        } else {
            AreaSegmentedControl()
        }
    }()

    private let tabView = NSTabView()

    
    var autosaveName: String? {
        didSet {
            guard let autosaveName else { return }
            let index = UserDefaults.standard.integer(forKey: autosaveName)
            guard index >= 0, index < tabView.numberOfTabViewItems, index < segmentedControl.segmentCount else { return }
            tabView.selectTabViewItem(at: index)
            segmentedControl.selectedSegment = index
        }
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            contentView.hierarchy {
                segmentedControl
                tabView
            }
        }

        contentView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }

        segmentedControl.snp.makeConstraints { make in
            make.top.equalTo(contentView.safeAreaLayoutGuide)
            if #available(macOS 26.0, *) {
                make.leading.trailing.equalTo(contentView.safeAreaLayoutGuide).inset(8)
            } else {
                make.leading.trailing.equalTo(contentView.safeAreaLayoutGuide)
            }
        }

        tabView.view.snp.makeConstraints { make in
            make.top.equalTo(segmentedControl.snp.bottom).offset(10)
            make.left.right.bottom.equalTo(contentView.safeAreaLayoutGuide)
        }

//        segmentedControl.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)
        segmentedControl.controlSize = .large
        segmentedControl.selectedSegment = 0
        segmentedControl.target = tabView
        segmentedControl.action = #selector(tabView.takeSelectedTabViewItemFromSender(_:))

        tabView.tabViewType = .noTabsNoBorder
        tabView.tabPosition = .none
        tabView.tabViewBorderType = .none
    }

    var selectedTabViewItemIndex: Int {
        set { tabView.selectTabViewItem(at: newValue) }
        get { tabView.selectedTabViewItem.map { tabView.indexOfTabViewItem($0) } ?? NSNotFound }
    }

    func setTabViewItems(_ tabViewItems: [TabViewItem]) {
        segmentedControl.segmentCount = tabViewItems.count
        for (index, tabViewItem) in tabViewItems.enumerated() {
            segmentedControl.setImage(tabViewItem.normalSymbol.nsuiImgae, forSegment: index)
            segmentedControl.setAlternateImage(tabViewItem.selectedSymbol.nsuiImgae, forSegment: index)
            tabView.addTabViewItem(.init(viewController: tabViewItem.viewController))
        }
    }

    func removeAllTabViewItems() {
        tabView.tabViewItems.forEach { tabView.removeTabViewItem($0) }
    }
}

extension TabViewController: NSTabViewDelegate {
    func tabView(_ tabView: NSTabView, didSelect tabViewItem: NSTabViewItem?) {
        guard let tabViewItem else { return }
        let index = tabView.indexOfTabViewItem(tabViewItem)
        guard index >= 0, index < tabView.numberOfTabViewItems else { return }
        guard let autosaveName else { return }
        UserDefaults.standard.set(index, forKey: autosaveName)
    }
}

import CocoaCoordinator

extension Transition where ViewController: TabViewController {
    static func select(index: Int) -> Self {
        Self(presentables: []) { windowController, viewController, options, completion in
            viewController?.selectedTabViewItemIndex = index
            completion?()
        }
    }

    static func set(_ tabViewItems: [TabViewItem]) -> Self {
        Self(presentables: tabViewItems.map(\.viewController)) { windowController, viewController, options, completion in
            guard let viewController = viewController ?? ((windowController as? NSWindowController)?.contentViewController as? ViewController) else {
                completion?()
                return
            }
            viewController.removeAllTabViewItems()
            viewController.setTabViewItems(tabViewItems)
            completion?()
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Base/ViewControllers.swift`:

```swift
import AppKit
import LateResponders
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

open class UXKitViewController<ViewModel: ViewModelProtocol>: UXViewController {
    public private(set) var viewModel: ViewModel?

    private let commonLoadingView = CommonLoadingView()

    public private(set) var contentView: NSView = UXView()

    open var shouldDisplayCommonLoading: Bool { false }

    open var contentViewUsingSafeArea: Bool { false }

    private var usesSkeletonReplaceCommonLoading: Bool { false }

    private var _shouldSetupCommonLoading: Bool {
        shouldDisplayCommonLoading && !usesSkeletonReplaceCommonLoading
    }

    public init(viewModel: ViewModel? = nil) {
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }

    open override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            contentView
            if _shouldSetupCommonLoading {
                commonLoadingView
            }
        }

        contentView.snp.makeConstraints { make in
            if contentViewUsingSafeArea {
                make.edges.equalTo(view.safeAreaLayoutGuide)
            } else {
                make.edges.equalToSuperview()
            }
        }

        if _shouldSetupCommonLoading {
            commonLoadingView.snp.makeConstraints { make in
                make.edges.equalTo(view.safeAreaLayoutGuide)
            }
        }
    }

    @available(*, unavailable)
    public required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    open func setupBindings(for viewModel: ViewModel) {
        rx.disposeBag = DisposeBag()

        self.viewModel = viewModel

        if shouldDisplayCommonLoading {
            if usesSkeletonReplaceCommonLoading {
                viewModel.delayedLoading.driveOnNextMainActor { [weak self] isLoading in
                    guard let self else { return }
                    if isLoading {
                        contentView.showSkeleton()
                    } else {
                        contentView.hideSkeleton()
                    }
                }
                .disposed(by: rx.disposeBag)
            } else {
                viewModel.delayedLoading.drive(commonLoadingView.rx.isRunning).disposed(by: rx.disposeBag)
            }
        }

        viewModel.errorRelay
            .asSignal()
            .emitOnNextMainActor { [weak self] error in
                guard let self else { return }
                if let window = view.window {
                    NSAlert(error: error).beginSheetModal(for: window)
                } else {
                    NSAlert(error: error).runModal()
                }
            }
            .disposed(by: rx.disposeBag)
    }

    open override func viewDidAppear() {
        super.viewDidAppear()

        registerLateResponders()
    }

    open override func viewDidDisappear() {
        super.viewDidDisappear()

        unregisterLateResponders()
    }

    open func lateResponderSelectors() -> [Selector] { [] }

    private var lateResponder: LateResponder?

    private func registerLateResponders() {
        let lateResponderSelectors = lateResponderSelectors()
        guard !lateResponderSelectors.isEmpty else { return }
        guard let registry = lateResponderRegistering()?.lateResponderRegistry else { return }
        lateResponder?.deregister()
        let proxy = LateResponderProxy(for: self)
        proxy.proxiedSelectorNames = lateResponderSelectors.map { NSStringFromSelector($0) }
        registry.register(proxy)
        lateResponder = proxy
    }

    private func unregisterLateResponders() {
        guard let lateResponder else { return }
        lateResponder.deregister()
        self.lateResponder = nil
    }
}

open class UXEffectViewController<ViewModel: ViewModelProtocol>: UXKitViewController<ViewModel> {
    private lazy var effectView: NSView = {
        if #available(macOS 26.0, *) {
            let view = UXView()
//            view.backgroundColor = .windowBackgroundColor
            return view
        } else {
            return NSVisualEffectView()
        }
    }()

    open override var contentView: NSView { effectView }
}

open class AppKitViewController<ViewModel: ViewModelProtocol>: NSViewController {
    public private(set) var viewModel: ViewModel?

    public init(viewModel: ViewModel? = nil) {
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }

    @available(*, unavailable)
    public required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    open func setupBindings(for viewModel: ViewModel) {
        rx.disposeBag = DisposeBag()
        self.viewModel = viewModel

        viewModel.errorRelay
            .asSignal()
            .emitOnNextMainActor { [weak self] error in
                guard let self else { return }
                if let window = view.window {
                    NSAlert(error: error).beginSheetModal(for: window)
                } else {
                    NSAlert(error: error).runModal()
                }
            }
            .disposed(by: rx.disposeBag)
    }
}


open class UXKitNavigationController: UXNavigationController {
    
    open var shouldUseNoAnimationTransition: Bool { false }
    
    open override func viewDidLoad() {
        super.viewDidLoad()

        isToolbarHidden = true
        isNavigationBarHidden = true
        delegate = self
    }
}

extension UXKitNavigationController: UXNavigationControllerDelegate {
    public func navigationController(_ navigationController: UXNavigationController, animationControllerFor operation: UXNavigationController.Operation, from fromViewController: UXViewController, to toViewController: UXViewController) -> (any UXViewControllerAnimatedTransitioning)? {
        guard shouldUseNoAnimationTransition else { return nil }
        return UXKitNoAnimationTransition.shared
    }
}

private final class UXKitNoAnimationTransition: NSObject, UXViewControllerAnimatedTransitioning {

    private override init() {}
    
    static let shared = UXKitNoAnimationTransition()
    
    func transitionDuration(using transitionContext: UXViewControllerContextTransitioning?) -> TimeInterval {
        return 0
    }

    func animateTransition(using transitionContext: UXViewControllerContextTransitioning) {
        let containerView = transitionContext.containerView
        
        guard let toVC = transitionContext.viewController(forKey: .to) else {
            transitionContext.completeTransition(false)
            return
        }
        
        let toView = toVC.view
        
        let finalFrame = transitionContext.finalFrame(for: toVC)
        if finalFrame != .zero {
            toView.frame = finalFrame
        }
        
        CATransaction.begin()
        CATransaction.setDisableActions(true)
        
        containerView.addSubview(toView)
        toView.layoutSubtreeIfNeeded()
        
        CATransaction.commit()
        
        transitionContext.completeTransition(!transitionContext.transitionWasCancelled)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Content/ContentCoordinator.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

typealias ContentTransition = Transition<Void, ContentNavigationController>

final class ContentCoordinator: ViewCoordinator<ContentRoute, ContentTransition> {
    let documentState: DocumentState

    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(rootViewController: .init(nibName: nil, bundle: nil), initialRoute: nil)
    }

    override func prepareTransition(for route: ContentRoute) -> ContentTransition {
        switch route {
        case .placeholder:
            let contentPlaceholderViewController = ContentPlaceholderViewController()
            let contentPlaceholderViewModel = ContentPlaceholderViewModel(documentState: documentState, router: self)
            contentPlaceholderViewController.setupBindings(for: contentPlaceholderViewModel)
            contentPlaceholderViewController.loadViewIfNeeded()
            return .set([contentPlaceholderViewController], animated: true)
        case .root(let runtimeObject):
            let contentTextViewController = ContentTextViewController()
            let contentTextViewModel = ContentTextViewModel(runtimeObject: runtimeObject, documentState: documentState, router: self)
            contentTextViewController.setupBindings(for: contentTextViewModel)
            contentTextViewController.loadViewIfNeeded()
            return .set([contentTextViewController], animated: true)
        case .next(let runtimeObject):
            let contentTextViewController = ContentTextViewController()
            let contentTextViewModel = ContentTextViewModel(runtimeObject: runtimeObject, documentState: documentState, router: self)
            contentTextViewController.setupBindings(for: contentTextViewModel)
            contentTextViewController.loadViewIfNeeded()
            return .push(contentTextViewController, animated: true)
        case .back:
            return .pop(animated: true)
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Content/ContentNavigationController.swift`:

```swift
import AppKit
import RuntimeViewerUI

final class ContentNavigationController: UXKitNavigationController {
    override var shouldUseNoAnimationTransition: Bool { true }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Content/ContentPlaceholderViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ContentPlaceholderViewController: UXKitViewController<ContentPlaceholderViewModel> {
    private let placeholderLabel = Label("Select a runtime object")

    override var contentViewUsingSafeArea: Bool { true }
    
    override func viewDidLoad() {
        super.viewDidLoad()

        contentView.hierarchy {
            placeholderLabel
        }

        placeholderLabel.snp.makeConstraints { make in
            make.center.equalTo(contentView)
        }

        placeholderLabel.do {
            $0.font = .systemFont(ofSize: 20, weight: .regular)
            $0.textColor = .secondaryLabelColor
        }
    }

    override func viewDidAppear() {
        super.viewDidAppear()

        viewModel?.documentState.currentSubtitle = ""
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Content/ContentTextView.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerCore
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class ContentTextView: NSTextView {
    override func clicked(onLink link: Any, at charIndex: Int) {}
    override var acceptableDragTypes: [NSPasteboard.PasteboardType] { [] }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Content/ContentTextViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerCore
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class ContentTextViewController: UXKitViewController<ContentTextViewModel>, NSTextViewDelegate {
    override var acceptsFirstResponder: Bool { true }

    override var shouldDisplayCommonLoading: Bool { true }

    private let (scrollView, textView): (NSScrollView, ContentTextView) = {
        let scrollView = NSScrollView()
        let textView = ContentTextView(usingTextLayoutManager: false)

        textView.textContainer?.widthTracksTextView = true
        textView.textContainer?.heightTracksTextView = false

        scrollView.hasVerticalScroller = true
        scrollView.hasHorizontalScroller = false
        scrollView.drawsBackground = true
        scrollView.contentView.drawsBackground = true
        scrollView.documentView = textView

        textView.isRichText = false
        textView.usesRuler = false
        textView.usesInspectorBar = false
        textView.allowsDocumentBackgroundColorChange = false
        textView.importsGraphics = false
        textView.usesFontPanel = false
        textView.isVerticallyResizable = true
        textView.autoresizingMask = [.width, .height]
        
        return (scrollView, textView)
    }()

    private let eventMonitor = EventMonitor()

    private let jumpToDefinitionRelay = PublishRelay<RuntimeObject>()

    private var isPressedCommand: Bool = false
    
    override func viewDidLoad() {
        super.viewDidLoad()

        contentView.hierarchy {
            scrollView
        }

        scrollView.snp.makeConstraints { make in
            make.top.equalToSuperview()
            make.leading.trailing.bottom.equalTo(view.safeAreaLayoutGuide)
        }

        scrollView.do {
            $0.drawsBackground = true
        }

        textView.do {
            $0.isSelectable = true
            $0.isEditable = false
            $0.usesFindBar = true
            $0.textContainerInset = .init(width: 5.0, height: 5.0)
            $0.linkTextAttributes = [:]
            $0.delegate = self
        }
    }


    override func setupBindings(for viewModel: ContentTextViewModel) {
        super.setupBindings(for: viewModel)

        let input = ContentTextViewModel.Input(
            runtimeObjectClicked: Signal.of(textView.rx.methodInvoked(#selector(ContentTextView.clicked(onLink:at:))).map { $0[0] as! RuntimeObject }.asSignalOnErrorJustComplete().filter { [unowned self] _ in isPressedCommand }, jumpToDefinitionRelay.asSignal()).merge()
        )
        let output = viewModel.transform(input)

//        viewModel.delayedLoading.driveOnNextMainActor { [weak self] isLoading in
//            guard let self else { return }
//
//            if isLoading {
//                textView.showSkeleton(using: .default)
//            } else {
//                textView.hideSkeleton()
//            }
//        }
//        .disposed(by: rx.disposeBag)

        output.attributedString.drive(with: self) { target, attributedString in
            target.textView.textStorage?.setAttributedString(attributedString)
        }
        .disposed(by: rx.disposeBag)

        output.theme.drive(with: self) {
            ($0.contentView as? UXView)?.backgroundColor = $1.backgroundColor
            $0.textView.backgroundColor = $1.backgroundColor
            $0.scrollView.backgroundColor = $1.backgroundColor
        }
        .disposed(by: rx.disposeBag)

        output.runtimeObjectNotFound.emitOnNextMainActor { [weak self] in
            guard let self else { return }
            var configuration = HUDView.Configuration.standard()
            configuration.image = SFSymbols(systemName: .questionmark, pointSize: 80, weight: .light).nsuiImgae
            view.window?.showHUD(with: configuration)
        }
        .disposed(by: rx.disposeBag)

        rx.viewDidAppear.asDriver()
            .flatMapLatest { output.runtimeObjectName }
            .drive(with: self) { $0.viewModel?.documentState.currentSubtitle = $1 }
            .disposed(by: rx.disposeBag)

        eventMonitor.addLocalMonitorForEvents(matching: [.flagsChanged]) { [weak self] event in
            guard let self else { return event }
            isPressedCommand = event.modifierFlags.contains(.command)
            if isPressedCommand {
                textView.linkTextAttributes = [
                    .cursor: NSCursor.pointingHand,
                ]
            } else {
                textView.linkTextAttributes = [:]
            }
            return event
        }
    }

    func textView(_ view: NSTextView, menu: NSMenu, for event: NSEvent, at charIndex: Int) -> NSMenu? {
        var newMenuItems: [NSMenuItem] = []
        if let runtimeObject = view.attributedString().attributes(at: charIndex, effectiveRange: nil)[.link] as? RuntimeObject {
            let menuItem = JumpToDefinitionMenuItem(runtimeObject: runtimeObject)
            menuItem.target = self
            menuItem.action = #selector(jumpToDefinitionAction(_:))
            newMenuItems.append(menuItem)
        }
        newMenuItems.append(contentsOf: menu.items.filter { $0.action?.isStandardAction ?? false })
        menu.items = newMenuItems
        return menu
    }

    @objc private func jumpToDefinitionAction(_ sender: JumpToDefinitionMenuItem) {
        jumpToDefinitionRelay.accept(sender.runtimeObject)
    }

    override func lateResponderSelectors() -> [Selector] {
        [
            #selector(performTextFinderAction(_:)),
        ]
    }

    override func performTextFinderAction(_ sender: Any?) {
        textView.performTextFinderAction(sender)
    }
}

extension ContentTextViewController: NSMenuItemValidation {
    func validateMenuItem(_ menuItem: NSMenuItem) -> Bool {
        switch menuItem.action {
        case #selector(performTextFinderAction(_:)):
            return true
        default:
            return true
        }
    }
}

private final class JumpToDefinitionMenuItem: NSMenuItem {
    let runtimeObject: RuntimeObject

    init(runtimeObject: RuntimeObject) {
        self.runtimeObject = runtimeObject
        super.init(title: "Jump to Definition", action: nil, keyEquivalent: "")
        if #available(macOS 26.0, *) {
            image = SFSymbols(systemName: .arrowTurnDownRight).nsuiImgae
        }
    }

    @available(*, unavailable)
    required init(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

extension Selector {
    fileprivate var isStandardAction: Bool {
        self == #selector(NSText.cut(_:)) || self == #selector(NSText.copy(_:)) || self == #selector(NSText.paste(_:))
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Debug.xcconfig`:

```xcconfig
//#include "Shared-Debug.xcconfig"

SMPrivilegedExecutable = identifier "com.JH.RuntimeViewerService" and anchor apple generic and certificate leaf[subject.CN] = "Apple Development: JieHui Lai (4ZZALU97YZ)" and certificate 1[field.1.2.840.113635.100.6.2.1] /* exists */



```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingCompletionViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingCompletionViewController: AppKitViewController<ExportingCompletionViewModel>, ExportingStepViewController {
    private let checkmarkImageView = NSImageView().then {
        $0.image = .symbol(systemName: .checkmarkCircleFill)
        $0.symbolConfiguration = .init(pointSize: 56, weight: .regular)
        $0.contentTintColor = .systemGreen
    }

    private let titleLabel = Label("Export Complete").then {
        $0.font = .systemFont(ofSize: 20, weight: .bold)
        $0.alignment = .center
    }

    private let summaryLabel = Label().then {
        $0.font = .systemFont(ofSize: 13)
        $0.textColor = .secondaryLabelColor
        $0.alignment = .center
        $0.maximumNumberOfLines = 0
        $0.preferredMaxLayoutWidth = 350
    }

    private let showInFinderButton = PushButton().then {
        $0.title = "Show in Finder"
    }

    private lazy var contentStackView = VStackView(distribution: .fill, spacing: 10) {
        checkmarkImageView
            .customSpacing(24)
        titleLabel
        summaryLabel
            .customSpacing(16)
        showInFinderButton
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            contentStackView
        }

        contentStackView.snp.makeConstraints { make in
            make.center.equalToSuperview()
            make.top.leading.greaterThanOrEqualToSuperview()
            make.bottom.trailing.lessThanOrEqualToSuperview()
        }
    }

    override func setupBindings(for viewModel: ExportingCompletionViewModel) {
        super.setupBindings(for: viewModel)

        let input = ExportingCompletionViewModel.Input(
            refresh: rx.viewDidAppear.asSignal(),
            showInFinderClick: showInFinderButton.rx.click.asSignal()
        )

        let output = viewModel.transform(input)

        output.summaryText.drive(summaryLabel.rx.stringValue).disposed(by: rx.disposeBag)
    }
}

final class MockRouter<Route: Routable>: NSObject, Router {
    var triggeredRoutes: [Route] = []

    func contextTrigger(_ route: Route, with options: TransitionOptions, completion: ContextPresentationHandler?) {
        triggeredRoutes.append(route)
        completion?(AppTransition.none())
    }
}

#Preview(traits: .fixedLayout(width: 750, height: 450)) {
    let mockRouter = MockRouter<ExportingRoute>()
    let viewModel = ExportingCompletionViewModel(exportingState: .completionStepTesting, documentState: .init(), router: mockRouter)
    let viewController = ExportingCompletionViewController()
    viewController.setupBindings(for: viewModel)
    return viewController
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingCompletionViewModel.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingCompletionViewModel: ViewModel<ExportingRoute> {
    struct Input {
        let refresh: Signal<Void>
        let showInFinderClick: Signal<Void>
    }

    struct Output {
        let summaryText: Driver<String>
    }

    @Observed private(set) var summaryText: String = ""

    private let exportingState: ExportingState

    private func updateSummaryText(with result: RuntimeInterfaceExportResult) {
        var lines: [String] = []
        lines.append("\(result.succeeded) interfaces exported successfully")
        if result.failed > 0 {
            lines.append("\(result.failed) failed")
        }
        lines.append(String(format: "Duration: %.1fs", result.totalDuration))
        lines.append("ObjC: \(result.objcCount) | Swift: \(result.swiftCount)")
        summaryText = lines.joined(separator: "\n")
    }

    init(exportingState: ExportingState, documentState: DocumentState, router: any Router<ExportingRoute>) {
        self.exportingState = exportingState
        super.init(documentState: documentState, router: router)
    }

    func refreshFromState() {
        guard let result = exportingState.exportResult else { return }
        updateSummaryText(with: result)
    }

    func transform(_ input: Input) -> Output {
        exportingState.$exportResult
            .asObservable()
            .compactMap { $0 }
            .subscribeOnNext { [weak self] result in
                guard let self else { return }
                updateSummaryText(with: result)
            }
            .disposed(by: rx.disposeBag)

        input.refresh.emitOnNext { [weak self] in
            guard let self else { return }
            refreshFromState()
        }
        .disposed(by: rx.disposeBag)

        input.showInFinderClick.emitOnNext { [weak self] in
            guard let self else { return }
            guard let url = exportingState.destinationURL else { return }
            NSWorkspace.shared.activateFileViewerSelecting([url])
        }
        .disposed(by: rx.disposeBag)

        return Output(
            summaryText: $summaryText.asDriver()
        )
    }
}

extension ExportingCompletionViewModel: ExportingStepViewModel {
    var title: Driver<String> {
        "Export Complete:"
    }

    var nextTitle: Driver<String> {
        "Done"
    }

    var isPreviousEnabled: RxCocoa.Driver<Bool> {
        false
    }

    var isNextEnabled: Driver<Bool> {
        true
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingConfigurationViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingConfigurationViewController: AppKitViewController<ExportingConfigurationViewModel>, ExportingStepViewController {

    private let summaryLabel = Label()

    private let objcSingleFileRadio = RadioButton()
    private let objcDirectoryRadio = RadioButton()

    private let swiftSingleFileRadio = RadioButton()
    private let swiftDirectoryRadio = RadioButton()

    private let objcTitleLabel = Label("Objective-C:").then {
        $0.font = .systemFont(ofSize: 13, weight: .medium)
    }

    private let objcSingleDesc = Label("Combine all ObjC interfaces into one .h file").then {
        $0.font = .systemFont(ofSize: 11)
        $0.textColor = .tertiaryLabelColor
    }

    private let objcDirDesc = Label("Individual .h files in ObjCHeaders/ subdirectory").then {
        $0.font = .systemFont(ofSize: 11)
        $0.textColor = .tertiaryLabelColor
    }

    private let swiftTitleLabel = Label("Swift:").then {
        $0.font = .systemFont(ofSize: 13, weight: .medium)
    }

    private let swiftSingleDesc = Label("Combine all Swift interfaces into one .swiftinterface file").then {
        $0.font = .systemFont(ofSize: 11)
        $0.textColor = .tertiaryLabelColor
    }

    private let swiftDirDesc = Label("Individual files in SwiftInterfaces/ subdirectory").then {
        $0.font = .systemFont(ofSize: 11)
        $0.textColor = .tertiaryLabelColor
    }

    private lazy var contentStack = VStackView(alignment: .leading, spacing: 16) {
        summaryLabel
        objcStack
        swiftStack
    }

    private lazy var objcStack = VStackView(alignment: .leading, spacing: 12) {
        objcTitleLabel
        VStackView(alignment: .leading, spacing: 4) {
            objcSingleFileRadio
            objcSingleDesc
        }
        VStackView(alignment: .leading, spacing: 4) {
            objcDirectoryRadio
            objcDirDesc
        }
    }

    private lazy var swiftStack = VStackView(alignment: .leading, spacing: 12) {
        swiftTitleLabel
        VStackView(alignment: .leading, spacing: 4) {
            swiftSingleFileRadio
            swiftSingleDesc
        }
        VStackView(alignment: .leading, spacing: 4) {
            swiftDirectoryRadio
            swiftDirDesc
        }
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        summaryLabel.do {
            $0.font = .systemFont(ofSize: 13)
            $0.textColor = .secondaryLabelColor
        }

        objcSingleFileRadio.do {
            $0.title = "Single File (.h)"
            $0.font = .systemFont(ofSize: 13)
        }

        objcDirectoryRadio.do {
            $0.title = "Directory Structure"
            $0.font = .systemFont(ofSize: 13)
        }

        swiftSingleFileRadio.do {
            $0.title = "Single File (.swiftinterface)"
            $0.font = .systemFont(ofSize: 13)
        }

        swiftDirectoryRadio.do {
            $0.title = "Directory Structure"
            $0.font = .systemFont(ofSize: 13)
        }

        hierarchy {
            contentStack
        }

        contentStack.snp.makeConstraints { make in
            make.top.leading.trailing.equalToSuperview().inset(20)
        }
    }

    // MARK: - Bindings

    override func setupBindings(for viewModel: ExportingConfigurationViewModel) {
        super.setupBindings(for: viewModel)

        let input = ExportingConfigurationViewModel.Input(
            objcFormatSelected: Signal.merge(
                objcSingleFileRadio.rx.click.asSignal().map { ExportFormat.singleFile.rawValue },
                objcDirectoryRadio.rx.click.asSignal().map { ExportFormat.directory.rawValue }
            ),
            swiftFormatSelected: Signal.merge(
                swiftSingleFileRadio.rx.click.asSignal().map { ExportFormat.singleFile.rawValue },
                swiftDirectoryRadio.rx.click.asSignal().map { ExportFormat.directory.rawValue }
            )
        )

        let output = viewModel.transform(input)

        output.objcFormat.map { $0 == .singleFile }.drive(objcSingleFileRadio.rx.isCheck).disposed(by: rx.disposeBag)
        output.objcFormat.map { $0 == .directory }.drive(objcDirectoryRadio.rx.isCheck).disposed(by: rx.disposeBag)
        output.swiftFormat.map { $0 == .singleFile }.drive(swiftSingleFileRadio.rx.isCheck).disposed(by: rx.disposeBag)
        output.swiftFormat.map { $0 == .directory }.drive(swiftDirectoryRadio.rx.isCheck).disposed(by: rx.disposeBag)

        output.hasObjC.driveOnNext { [weak self] hasObjC in
            guard let self else { return }
            objcStack.isHidden = !hasObjC
        }
        .disposed(by: rx.disposeBag)

        output.hasSwift.driveOnNext { [weak self] hasSwift in
            guard let self else { return }
            swiftStack.isHidden = !hasSwift
        }
        .disposed(by: rx.disposeBag)

        Driver.combineLatest(output.objcCount, output.swiftCount, output.imageName)
            .driveOnNext { [weak self] objcCount, swiftCount, imageName in
                guard let self else { return }
                var parts = ["Image: \(imageName)"]
                if objcCount > 0 { parts.append("\(objcCount) ObjC") }
                if swiftCount > 0 { parts.append("\(swiftCount) Swift") }
                summaryLabel.stringValue = parts.joined(separator: " Â· ")
            }
            .disposed(by: rx.disposeBag)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingConfigurationViewModel.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingConfigurationViewModel: ViewModel<ExportingRoute> {
    struct Input {
        let objcFormatSelected: Signal<Int>
        let swiftFormatSelected: Signal<Int>
    }

    struct Output {
        let objcCount: Driver<Int>
        let swiftCount: Driver<Int>
        let hasObjC: Driver<Bool>
        let hasSwift: Driver<Bool>
        let imageName: Driver<String>
        let objcFormat: Driver<ExportFormat>
        let swiftFormat: Driver<ExportFormat>
    }

    let exportingState: ExportingState

    @Observed private(set) var isLoading: Bool = true

    init(exportingState: ExportingState, documentState: DocumentState, router: any Router<ExportingRoute>) {
        self.exportingState = exportingState
        super.init(documentState: documentState, router: router)
        loadObjects()
    }

    private func loadObjects() {
        Task { @MainActor [weak self] in
            guard let self else { return }
            do {
                let objects = try await documentState.runtimeEngine.objects(in: exportingState.imagePath)
                exportingState.allObjects = objects
                isLoading = false
            } catch {
                errorRelay.accept(error)
            }
        }
    }

    func transform(_ input: Input) -> Output {
        input.objcFormatSelected.emitOnNext { [weak self] index in
            guard let self else { return }
            exportingState.objcFormat = ExportFormat(rawValue: index) ?? .singleFile
        }
        .disposed(by: rx.disposeBag)

        input.swiftFormatSelected.emitOnNext { [weak self] index in
            guard let self else { return }
            exportingState.swiftFormat = ExportFormat(rawValue: index) ?? .singleFile
        }
        .disposed(by: rx.disposeBag)

        return Output(
            objcCount: exportingState.$allObjects.asDriver().map { $0.count { $0.kind.isObjC } },
            swiftCount: exportingState.$allObjects.asDriver().map { $0.count { $0.kind.isSwift } },
            hasObjC: exportingState.$allObjects.asDriver().map { $0.contains { $0.kind.isObjC } },
            hasSwift: exportingState.$allObjects.asDriver().map { $0.contains { $0.kind.isSwift } },
            imageName: .just(exportingState.imageName),
            objcFormat: exportingState.$objcFormat.asDriver(),
            swiftFormat: exportingState.$swiftFormat.asDriver()
        )
    }
}

extension ExportingConfigurationViewModel: ExportingStepViewModel {
    var title: Driver<String> {
        "Export Configuration:"
    }

    var isPreviousEnabled: Driver<Bool> {
        false
    }

    var isNextEnabled: Driver<Bool> {
        true
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingCoordinator.swift`:

```swift
import AppKit
import RuntimeViewerApplication
import RuntimeViewerArchitectures

enum ExportingRoute: Routable {
    case initial
    case previous
    case next
    case cancel
    case directoryPicker
}

typealias ExportingTransition = Transition<ExportingWindowController, ExportingViewController>

final class ExportingCoordinator: SceneCoordinator<ExportingRoute, ExportingTransition> {
    let exportingState: ExportingState

    let documentState: DocumentState

    init?(documentState: DocumentState) {
        guard let imageName = documentState.currentImageName,
              let imagePath = documentState.currentImagePath
        else { return nil }
        self.exportingState = .init(imagePath: imagePath, imageName: imageName)
        self.documentState = documentState
        super.init(windowController: .init(), initialRoute: nil)
        windowController.contentViewController = ExportingViewController(router: self)
        contextTrigger(.initial)
    }

    override func prepareTransition(for route: ExportingRoute) -> ExportingTransition {
        switch route {
        case .initial:
            let configurationViewController = ExportingConfigurationViewController()
            let configurationViewModel = ExportingConfigurationViewModel(exportingState: exportingState, documentState: documentState, router: self)
            configurationViewController.setupBindings(for: configurationViewModel)

            let progressViewController = ExportingProgressViewController()
            let progressViewModel = ExportingProgressViewModel(exportingState: exportingState, documentState: documentState, router: self)
            progressViewController.setupBindings(for: progressViewModel)

            let completionViewController = ExportingCompletionViewController()
            let completionViewModel = ExportingCompletionViewModel(exportingState: exportingState, documentState: documentState, router: self)
            completionViewController.setupBindings(for: completionViewModel)

            return .multiple(
                .set([configurationViewController, progressViewController, completionViewController]),
                .select(index: 0)
            )
        case .previous:
            switch exportingState.currentStep {
            case .configuration:
                break
            case .progress:
                exportingState.destinationURL = nil
                exportingState.currentStep = .configuration
            case .completion:
                break
            }
            return .select(index: exportingState.currentStep.rawValue)
        case .next:
            switch exportingState.currentStep {
            case .configuration:
                if exportingState.destinationURL == nil {
                    contextTrigger(.directoryPicker)
                    return .none()
                } else {
                    exportingState.currentStep = .progress
                }
            case .progress:
                exportingState.currentStep = .completion
            case .completion:
                removeFromParent()
                return .endSheetOnTop()
            }
            return .select(index: exportingState.currentStep.rawValue)
        case .cancel:
            removeFromParent()
            return .endSheetOnTop()
        case .directoryPicker:
            let panel = NSOpenPanel()
            panel.allowedContentTypes = [.directory]
            panel.canCreateDirectories = true
            panel.canChooseDirectories = true
            panel.canChooseFiles = false
            panel.beginSheetModal(for: windowController.contentWindow) { [weak self, weak panel] result in
                guard result == .OK, let self, let panel, let url = panel.url else { return }
                exportingState.destinationURL = url
                contextTrigger(.next)
            }
            return .none()
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingProgressViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingProgressViewController: AppKitViewController<ExportingProgressViewModel>, ExportingStepViewController {
    private let progressPhaseLabel = Label("Preparing...").then {
        $0.font = .systemFont(ofSize: 20, weight: .bold)
        $0.textColor = .controlTextColor
        $0.alignment = .center
    }

    private let progressIndicator = NSProgressIndicator().then {
        $0.style = .bar
        $0.isIndeterminate = false
        $0.minValue = 0
        $0.maxValue = 1
    }

    private let progressObjectLabel = Label().then {
        $0.font = .systemFont(ofSize: 13)
        $0.textColor = .secondaryLabelColor
        $0.alignment = .center
        $0.lineBreakMode = .byTruncatingMiddle
        $0.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        
        hierarchy {
            progressPhaseLabel
            progressIndicator
            progressObjectLabel
        }
        
        progressIndicator.snp.makeConstraints { make in
            make.center.equalToSuperview()
            make.leading.trailing.equalToSuperview().inset(100)
        }
        
        progressPhaseLabel.snp.makeConstraints { make in
            make.bottom.equalTo(progressIndicator.snp.top).offset(-8)
            make.leading.trailing.equalTo(progressIndicator)
        }
        
        progressObjectLabel.snp.makeConstraints { make in
            make.top.equalTo(progressIndicator.snp.bottom).offset(8)
            make.leading.trailing.equalTo(progressIndicator)
        }
    }

    override func setupBindings(for viewModel: ExportingProgressViewModel) {
        super.setupBindings(for: viewModel)

        let input = ExportingProgressViewModel.Input(
            startExport: rx.viewDidAppear.asSignal()
        )

        let output = viewModel.transform(input)

        output.phaseText.drive(progressPhaseLabel.rx.stringValue).disposed(by: rx.disposeBag)

        output.progressValue.drive(progressIndicator.rx.doubleValue).disposed(by: rx.disposeBag)

        output.currentObjectText.drive(progressObjectLabel.rx.stringValue).disposed(by: rx.disposeBag)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingProgressViewModel.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingProgressViewModel: ViewModel<ExportingRoute> {
    struct Input {
        let startExport: Signal<Void>
    }

    struct Output {
        let phaseText: Driver<String>
        let progressValue: Driver<Double>
        let currentObjectText: Driver<String>
    }

    @Observed private(set) var phaseText: String = "Preparing..."
    @Observed private(set) var progressValue: Double = 0
    @Observed private(set) var currentObjectText: String = ""

    private let exportingState: ExportingState

    private var exportTask: Task<Void, Never>?
    private var eventsTask: Task<Void, Never>?

    init(exportingState: ExportingState, documentState: DocumentState, router: any Router<ExportingRoute>) {
        self.exportingState = exportingState
        super.init(documentState: documentState, router: router)
    }

    deinit {
        exportTask?.cancel()
        eventsTask?.cancel()
    }

    func transform(_ input: Input) -> Output {
        input.startExport
            .emitOnNext { [weak self] in
                guard let self else { return }
                startExport()
            }
            .disposed(by: rx.disposeBag)
        return Output(
            phaseText: $phaseText.asDriver(),
            progressValue: $progressValue.asDriver(),
            currentObjectText: $currentObjectText.asDriver()
        )
    }

    private var isExporting: Bool = false
    
    func startExport() {
        if isExporting { return }
        isExporting = true
        guard let directory = exportingState.destinationURL else {
            isExporting = false
            return
        }

        var generationOptions = appDefaults.options
        generationOptions.transformer = settings.transformer

        let configuration = RuntimeInterfaceExportConfiguration(
            imagePath: exportingState.imagePath,
            imageName: exportingState.imageName,
            directory: directory,
            objcFormat: exportingState.objcFormat,
            swiftFormat: exportingState.swiftFormat,
            generationOptions: generationOptions
        )

        let reporter = RuntimeInterfaceExportReporter()

        eventsTask = Task { @MainActor [weak self] in
            guard let self else { return }
            for await event in reporter.events {
                handleExportEvent(event)
            }
        }

        exportTask = Task { @MainActor [weak self] in
            guard let self else { return }
            do {
                try await documentState.runtimeEngine.exportInterfaces(
                    with: configuration,
                    reporter: reporter
                )
            } catch {
                errorRelay.accept(error)
            }
        }
    }

    private func handleExportEvent(_ event: RuntimeInterfaceExportEvent) {
        switch event {
        case .phaseStarted(let phase):
            switch phase {
            case .preparing:
                phaseText = "Preparing..."
                progressValue = 0
                currentObjectText = ""
            case .exporting:
                phaseText = "Exporting interfaces..."
                progressValue = 0
                currentObjectText = ""
            case .writing:
                phaseText = "Writing files..."
            }
        case .phaseCompleted:
            break
        case .phaseFailed(_, let error):
            currentObjectText = error.localizedDescription
        case .objectStarted(let object, let current, let total):
            progressValue = Double(current - 1) / Double(total)
            currentObjectText = "\(object.displayName) (\(current)/\(total))"
        case .objectCompleted:
            break
        case .objectFailed:
            break
        case .completed(let result):
            exportingState.exportResult = result
            progressValue = 1.0
            var parts = ["\(result.succeeded) succeeded"]
            if result.failed > 0 {
                parts.append("\(result.failed) failed")
            }
            parts.append(String(format: "%.1fs", result.totalDuration))
            currentObjectText = parts.joined(separator: " Â· ")
            router.trigger(.next)
        }
    }
}

extension ExportingProgressViewModel: ExportingStepViewModel {
    var title: Driver<String> {
        "Exporting..."
    }

    var isPreviousEnabled: Driver<Bool> {
        false
    }

    var isNextEnabled: Driver<Bool> {
        false
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingState.swift`:

```swift
import Foundation
import RuntimeViewerCore
import RuntimeViewerArchitectures
import OrderedCollections

typealias ExportFormat = RuntimeInterfaceExportConfiguration.Format

enum ExportingStep: Int {
    case configuration
    case progress
    case completion
}

@MainActor
final class ExportingState {
    let imagePath: String

    let imageName: String

    @Observed
    var allObjects: [RuntimeObject] = []

    @Observed
    var objcFormat: ExportFormat = .directory

    @Observed
    var swiftFormat: ExportFormat = .singleFile

    @Observed
    var destinationURL: URL?

    @Observed
    var exportResult: RuntimeInterfaceExportResult?

    @Observed
    var currentStep: ExportingStep = .configuration

    init(imagePath: String, imageName: String) {
        self.imagePath = imagePath
        self.imageName = imageName
    }
    
    static let completionStepTesting = ExportingState(imagePath: "/System/Library/Frameworks/AppKit.framework/AppKit", imageName: "AppKit").then {
        $0.exportResult = .init(succeeded: 300, failed: 0, totalDuration: 5.0, objcCount: 100, swiftCount: 200)
    }
}

extension ExportingState: Then {}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

protocol ExportingStepViewModel: ViewModelProtocol {
    var title: Driver<String> { get }
    var previousTitle: Driver<String> { get }
    var nextTitle: Driver<String> { get }
    var isNextEnabled: Driver<Bool> { get }
    var isPreviousEnabled: Driver<Bool> { get }
}

extension ExportingStepViewModel {
    var previousTitle: Driver<String> {
        "Previous"
    }

    var nextTitle: Driver<String> {
        "Next"
    }
}

protocol ExportingStepViewController<ViewModel>: NSViewController {
    associatedtype ViewModel: ExportingStepViewModel

    var viewModel: ViewModel? { get }
}

final class ExportingWindowController: XiblessWindowController<NSWindow> {}

final class ExportingViewController: XiblessViewController<NSView> {
    fileprivate let tabViewController = NSTabViewController()

    private let titleLabel = Label()

    private let cancelButton = PushButton(title: "Cancel", titleFont: .systemFont(ofSize: 13))

    private let nextButton = PushButton(title: "Next", titleFont: .systemFont(ofSize: 13))

    private let previousButton = PushButton(title: "Previous", titleFont: .systemFont(ofSize: 13))

    private let router: any Router<ExportingRoute>

    private let navigationComponentsDisposeBag = DisposeBag()
    
    init(router: any Router<ExportingRoute>) {
        self.router = router
        super.init()
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            titleLabel
            tabViewController
            cancelButton
            nextButton
            previousButton
        }

        titleLabel.snp.makeConstraints { make in
            make.top.leading.trailing.equalToSuperview().inset(20)
        }

        tabViewController.view.snp.makeConstraints { make in
            make.top.equalTo(titleLabel.snp.bottom).offset(8)
            make.leading.trailing.equalToSuperview().inset(20)
        }

        cancelButton.snp.makeConstraints { make in
            make.leading.bottom.equalToSuperview().inset(20)
            make.width.equalTo(75)
        }

        nextButton.snp.makeConstraints { make in
            make.top.equalTo(tabViewController.view.snp.bottom).offset(20)
            make.trailing.bottom.equalToSuperview().inset(20)
            make.width.equalTo(75)
        }

        previousButton.snp.makeConstraints { make in
            make.centerY.equalTo(nextButton)
            make.trailing.equalTo(nextButton.snp.leading).offset(-12)
            make.width.equalTo(75)
        }

        tabViewController.do {
            $0.tabStyle = .unspecified
            $0.view.wantsLayer = true
            $0.view.layer?.do {
                $0.borderWidth = 1
                $0.borderColor = NSColor(light: .black.withAlphaComponent(0.1), dark: .white.withAlphaComponent(0.1)).cgColor
            }
        }

        titleLabel.do {
            $0.textColor = .controlTextColor
            $0.font = .systemFont(ofSize: 13)
        }

        cancelButton.rx.click.asSignal().emit(to: router.rx.trigger(.cancel)).disposed(by: navigationComponentsDisposeBag)
        previousButton.rx.click.asSignal().emit(to: router.rx.trigger(.previous)).disposed(by: navigationComponentsDisposeBag)
        nextButton.rx.click.asSignal().emit(to: router.rx.trigger(.next)).disposed(by: navigationComponentsDisposeBag)

        
        nextButton.do {
            $0.keyEquivalent = "\r"
        }

        cancelButton.do {
            $0.keyEquivalent = "\u{1b}"
        }
        
        preferredContentSize = NSSize(width: 745, height: 450)
    }

    func setupBinding(for viewModel: any ExportingStepViewModel) {
        rx.disposeBag = DisposeBag()

        viewModel.title.drive(titleLabel.rx.stringValue).disposed(by: rx.disposeBag)
        viewModel.previousTitle.drive(previousButton.rx.title).disposed(by: rx.disposeBag)
        viewModel.nextTitle.drive(nextButton.rx.title).disposed(by: rx.disposeBag)
        viewModel.isPreviousEnabled.drive(previousButton.rx.isEnabled).disposed(by: rx.disposeBag)
        viewModel.isNextEnabled.drive(nextButton.rx.isEnabled).disposed(by: rx.disposeBag)
    }
}

extension Transition where ViewController: ExportingViewController {
    static func select(index: Int) -> Self {
        Self(presentables: []) { windowController, viewController, options, completion in
            viewController?.tabViewController.selectedTabViewItemIndex = index
            if let stepViewController = viewController?.tabViewController.tabViewItems[index].viewController as? (any ExportingStepViewController), let viewModel = stepViewController.viewModel {
                viewController?.setupBinding(for: viewModel)
            }
            completion?()
        }
    }

    static func set(_ presentables: [Presentable]) -> Self {
        Self(presentables: presentables) { windowController, viewController, options, completion in
            guard let viewController = viewController ?? ((windowController as? NSWindowController)?.contentViewController as? ViewController) else {
                completion?()
                return
            }
            viewController.tabViewController.tabViewItems.forEach { viewController.tabViewController.removeTabViewItem($0) }
            presentables.compactMap { $0.viewController }.forEach { viewController.tabViewController.addTabViewItem(NSTabViewItem(viewController: $0)) }
            completion?()
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Generation Options/GenerationOptionsViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class GenerationOptionsViewController: AppKitViewController<GenerationOptionsViewModel<MainRoute>> {
    private struct OptionItem {
        let title: String
        let keyPath: OptionKeyPath
    }

    private struct Section {
        let title: String?
        let items: [OptionItem]
    }

    private lazy var sections: [Section] = [
        Section(title: "ObjC", items: [
            OptionItem(title: "Strip Protocol Conformance", keyPath: \.objcHeaderOptions.stripProtocolConformance),
            OptionItem(title: "Strip Overrides", keyPath: \.objcHeaderOptions.stripOverrides),
            OptionItem(title: "Strip Synthesized Ivars", keyPath: \.objcHeaderOptions.stripSynthesizedIvars),
            OptionItem(title: "Strip Synthesized Methods", keyPath: \.objcHeaderOptions.stripSynthesizedMethods),
            OptionItem(title: "Strip Ctor Method", keyPath: \.objcHeaderOptions.stripCtorMethod),
            OptionItem(title: "Strip Dtor Method", keyPath: \.objcHeaderOptions.stripDtorMethod),
            OptionItem(title: "Add Ivar Offset Comments", keyPath: \.objcHeaderOptions.addIvarOffsetComments),
            OptionItem(title: "Add Property Attributes Comments", keyPath: \.objcHeaderOptions.addPropertyAttributesComments),
        ]),
        Section(title: "Swift", items: [
            OptionItem(title: "Print Stripped Symbol Description", keyPath: \.swiftInterfaceOptions.printStrippedSymbolicItem),
            OptionItem(title: "Print Offset Comments", keyPath: \.swiftInterfaceOptions.emitOffsetComments),
            OptionItem(title: "Print Type Layout", keyPath: \.swiftInterfaceOptions.printTypeLayout),
            OptionItem(title: "Print Enum Layout", keyPath: \.swiftInterfaceOptions.printEnumLayout),
            OptionItem(title: "Synthesize Opaque Type (WIP)", keyPath: \.swiftInterfaceOptions.synthesizeOpaqueType),
        ]),
    ]

    private let generationOptionsLabel = Label("Generation Options")

    private lazy var stackView = VStackView(alignment: .left, spacing: 10) {
        generationOptionsLabel
    }

    private var checkboxMap: [OptionKeyPath: CheckboxButton] = [:]

    private let updateRelay = PublishRelay<(OptionKeyPath, Bool)>()

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            stackView
        }

        stackView.snp.makeConstraints { make in
            make.edges.equalToSuperview().inset(15)
        }

        for section in sections {
            if let title = section.title {
                let label = Label(title).then {
                    $0.textColor = .secondaryLabelColor
                }
                stackView.addArrangedSubview(label)
            }

            for item in section.items {
                let checkbox = CheckboxButton(title: item.title)
                stackView.addArrangedSubview(checkbox)

                checkboxMap[item.keyPath] = checkbox
            }
        }

        preferredContentSize = stackView.fittingSize.inset(15)
    }

    override func setupBindings(for viewModel: GenerationOptionsViewModel<MainRoute>) {
        super.setupBindings(for: viewModel)

        for (keyPath, checkbox) in checkboxMap {
            checkbox.rx.state.asSignal()
                .map { $0 == .on }
                .map { (keyPath, $0) }
                .emit(to: updateRelay)
                .disposed(by: rx.disposeBag)
        }

        let input = GenerationOptionsViewModel<MainRoute>.Input(
            updateOption: updateRelay.asSignal()
        )

        let output = viewModel.transform(input)

        output.options
            .driveOnNext { [weak self] options in
                guard let self else { return }
                for (keyPath, checkbox) in checkboxMap {
                    let isChecked = options[keyPath: keyPath]
                    checkbox.state = isChecked ? .on : .off
                }
            }
            .disposed(by: rx.disposeBag)
    }
}

extension CGSize {
    fileprivate func inset(_ value: CGFloat) -> CGSize {
        return .init(width: width + value * 2, height: height + value * 2)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Generation Options/GenerationOptionsViewModel.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication
import Dependencies
import RuntimeViewerCore

typealias OptionKeyPath = WritableKeyPath<RuntimeObjectInterface.GenerationOptions, Bool>

final class GenerationOptionsViewModel<Route: Routable>: ViewModel<Route> {
    struct Input {
        let updateOption: Signal<(OptionKeyPath, Bool)>
    }

    struct Output {
        let options: Driver<RuntimeObjectInterface.GenerationOptions>
    }


    func transform(_ input: Input) -> Output {
        input.updateOption
            .emitOnNext { [weak self] (keyPath, value) in
                guard let self else { return }
                var currentOptions = appDefaults.options
                currentOptions[keyPath: keyPath] = value
                appDefaults.options = currentOptions
            }
            .disposed(by: rx.disposeBag)

        return Output(
            options: appDefaults.$options.asDriverOnErrorJustComplete()
        )
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeName</key>
			<string>RuntimeViewer Document</string>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
			<key>LSHandlerRank</key>
			<string>Default</string>
			<key>LSItemContentTypes</key>
			<array>
				<string>com.JH.RuntimeViewer.Document</string>
			</array>
			<key>NSDocumentClass</key>
			<string>$(PRODUCT_MODULE_NAME).Document</string>
		</dict>
	</array>
	<key>NSBonjourServices</key>
	<array>
		<string>_runtimeviewer._tcp</string>
	</array>
	<key>SMPrivilegedExecutables</key>
	<dict>
		<key>com.JH.RuntimeViewerService</key>
		<string>$(SMPrivilegedExecutable)</string>
	</dict>
	<key>UTImportedTypeDeclarations</key>
	<array>
		<dict>
			<key>UTTypeConformsTo</key>
			<array>
				<string>public.data</string>
			</array>
			<key>UTTypeDescription</key>
			<string>RuntimeViewer Document</string>
			<key>UTTypeIcons</key>
			<dict/>
			<key>UTTypeIdentifier</key>
			<string>com.JH.RuntimeViewer.Document</string>
			<key>UTTypeTagSpecification</key>
			<dict>
				<key>public.filename-extension</key>
				<array>
					<string>runtimedocument</string>
				</array>
			</dict>
		</dict>
	</array>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Inspector/InspectorClassHierarchyView.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class InspectorClassHierarchyView: InspectorDisclosureView<Label> {
    var hierarchyString: String = "" {
        didSet {
            contentView.stringValue = hierarchyString
        }
    }

    init() {
        super.init(contentView: .init())
        title = "Hierarchy"
        contentView.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)
        contentView.textColor = .controlTextColor
        contentView.font = .systemFont(ofSize: 12, weight: .regular)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Inspector/InspectorClassViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class InspectorClassViewController: UXEffectViewController<InspectorClassViewModel> {
    private let classHierarchyView = InspectorClassHierarchyView()

    private lazy var contentStackView = VStackView {
        classHierarchyView
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        contentView.hierarchy {
            contentStackView
        }

        contentStackView.snp.makeConstraints { make in
            make.edges.equalTo(contentView.safeAreaLayoutGuide)
        }
    }

    override func setupBindings(for viewModel: InspectorClassViewModel) {
        super.setupBindings(for: viewModel)

        let input = InspectorClassViewModel.Input()
        let output = viewModel.transform(input)
        output.classHierarchy.drive(classHierarchyView.contentView.rx.stringValue).disposed(by: rx.disposeBag)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Inspector/InspectorCoordinator.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

typealias InspectorTransition = Transition<Void, InspectorNavigationController>

final class InspectorCoordinator: ViewCoordinator<InspectorRoute, InspectorTransition> {
    let documentState: DocumentState

    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(rootViewController: .init(nibName: nil, bundle: nil), initialRoute: nil)
    }

    override func prepareTransition(for route: InspectorRoute) -> InspectorTransition {
        switch route {
        case .placeholder:
            let viewModel = InspectorPlaceholderViewModel(documentState: documentState, router: self)
            let viewController = InspectorPlaceholderViewController()
            viewController.setupBindings(for: viewModel)
            return .set([viewController], animated: true)
        case .root(let inspectableObject):
            return .set([makeTransition(for: inspectableObject)], animated: true)
        case .next(let inspectableObject):
            return .push(makeTransition(for: inspectableObject), animated: true)
        case .back:
            return .pop(animated: true)
        }
    }

    func makeTransition(for inspectableObject: InspectableObject) -> UXViewController {
        switch inspectableObject {
        case .node:
            let viewModel = InspectorPlaceholderViewModel(documentState: documentState, router: self)
            let viewController = InspectorPlaceholderViewController()
            viewController.setupBindings(for: viewModel)
            return viewController
        case .object(let runtimeObject):
            switch runtimeObject.kind {
            case .objc(.type(.class)), .swift(.type(.class)):
                let viewModel = InspectorClassViewModel(runtimeObject: runtimeObject, documentState: documentState, router: self)
                let viewController = InspectorClassViewController()
                viewController.setupBindings(for: viewModel)
                return viewController
            default:
                let viewModel = InspectorPlaceholderViewModel(documentState: documentState, router: self)
                let viewController = InspectorPlaceholderViewController()
                viewController.setupBindings(for: viewModel)
                return viewController
            }
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Inspector/InspectorDisclosureView.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

class InspectorDisclosureView<ContentView: NSView>: XiblessView {
    private final class HeaderView: XiblessView {
        let titleLabel = Label()

        let disclosureButton = Button()

        override init(frame frameRect: CGRect) {
            super.init(frame: frameRect)

            hierarchy {
                titleLabel
                disclosureButton
            }

            titleLabel.snp.makeConstraints { make in
                make.top.left.equalToSuperview().inset(15)
                make.bottom.equalToSuperview()
            }

            disclosureButton.snp.makeConstraints { make in
                make.top.right.equalToSuperview().inset(15)
                make.left.greaterThanOrEqualTo(titleLabel.snp.right).offset(15)
            }

            titleLabel.textColor = .secondaryLabelColor
            titleLabel.font = .systemFont(ofSize: 12, weight: .bold)

            disclosureButton.title = "Hide"
            disclosureButton.alternateTitle = "Show"
            disclosureButton.setButtonType(.toggle)
            disclosureButton.contentTintColor = .secondaryLabelColor
            disclosureButton.font = .systemFont(ofSize: 12, weight: .bold)
            disclosureButton.isBordered = false
            disclosureButton.alphaValue = 0.0
        }

        override func updateTrackingAreas() {
            super.updateTrackingAreas()
            trackingAreas.forEach(removeTrackingArea(_:))

            addTrackingArea(NSTrackingArea(rect: bounds, options: [.mouseEnteredAndExited, .activeInKeyWindow, .inVisibleRect], owner: self, userInfo: nil))
        }

        override func mouseEntered(with event: NSEvent) {
            super.mouseEntered(with: event)
            disclosureButton.alphaValue = 1.0
        }

        override func mouseExited(with event: NSEvent) {
            super.mouseExited(with: event)
            disclosureButton.alphaValue = 0.0
        }
    }

    private let headerView: HeaderView

    let contentView: ContentView

    var title: String = "" {
        didSet {
            headerView.titleLabel.stringValue = title
        }
    }

    init(contentView: ContentView) {
        self.headerView = HeaderView()
        self.contentView = contentView

        super.init(frame: .zero)

        hierarchy {
            headerView
            contentView
        }

        headerView.snp.makeConstraints { make in
            make.top.left.right.equalToSuperview()
        }

        setupContentViewConstraints(for: headerView.disclosureButton.state)

        headerView.disclosureButton.box.setAction { [weak self] button in
            guard let self, let button else { return }
            setupContentViewConstraints(for: button.state)
        }
    }

    private func setupContentViewConstraints(for disclosureState: NSControl.StateValue) {
        contentView.snp.remakeConstraints { make in
            make.top.equalTo(headerView.snp.bottom).offset(15)
            make.left.bottom.equalToSuperview().inset(15)
            make.right.lessThanOrEqualToSuperview().inset(15)
            switch disclosureState {
            case .on:
                make.height.equalTo(0)
            default:
                break
            }
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Inspector/InspectorNavigationController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class InspectorNavigationController: UXKitNavigationController {
    override var shouldUseNoAnimationTransition: Bool { true }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Inspector/InspectorPlaceholderViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class InspectorPlaceholderViewController: UXEffectViewController<InspectorPlaceholderViewModel> {
    private let placeholderLabel = Label("No Selection")

    override var contentViewUsingSafeArea: Bool { true }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        contentView.hierarchy {
            placeholderLabel
        }

        placeholderLabel.snp.makeConstraints { make in
            make.center.equalToSuperview()
        }

        placeholderLabel.do {
            $0.font = .systemFont(ofSize: 18, weight: .regular)
            $0.textColor = .secondaryLabelColor
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Load Frameworks/LoadFrameworksViewController.swift`:

```swift
#if canImport(AppKit) && !targetEnvironment(macCatalyst)

import AppKit
import RuntimeViewerUI
import RuntimeViewerApplication

final class LoadFrameworksViewModel: ViewModel<MainRoute> {}

final class LoadFrameworksViewController: AppKitViewController<LoadFrameworksViewModel> {
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do view setup here.
    }
}

#endif

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Load Frameworks/LoadFrameworksViewController.xib`:

```xib
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="3.0" toolsVersion="24412" targetRuntime="MacOSX.Cocoa" propertyAccessControl="none" useAutolayout="YES" customObjectInstantitationMethod="direct">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.CocoaPlugin" version="24412"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <objects>
        <customObject id="-2" userLabel="File's Owner" customClass="LoadFrameworksViewController" customModule="RuntimeViewer" customModuleProvider="target">
            <connections>
                <outlet property="view" destination="Hz6-mo-xeY" id="0bl-1N-x8E"/>
            </connections>
        </customObject>
        <customObject id="-1" userLabel="First Responder" customClass="FirstResponder"/>
        <customObject id="-3" userLabel="Application" customClass="NSObject"/>
        <customView misplaced="YES" id="Hz6-mo-xeY">
            <rect key="frame" x="0.0" y="0.0" width="1250" height="554"/>
            <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
            <subviews>
                <box boxType="custom" borderType="none" cornerRadius="4" title="Box" translatesAutoresizingMaskIntoConstraints="NO" id="Fl2-0y-EnG">
                    <rect key="frame" x="0.0" y="482" width="1250" height="121"/>
                    <view key="contentView" id="WLB-cx-6mB">
                        <rect key="frame" x="0.0" y="0.0" width="1250" height="121"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <button verticalHuggingPriority="750" fixedFrame="YES" translatesAutoresizingMaskIntoConstraints="NO" id="eOh-BQ-aHD">
                                <rect key="frame" x="39" y="30" width="62" height="40"/>
                                <autoresizingMask key="autoresizingMask" flexibleMaxX="YES" flexibleMinY="YES"/>
                                <buttonCell key="cell" type="push" title="Load" bezelStyle="rounded" alignment="center" controlSize="large" borderStyle="border" imageScaling="proportionallyDown" inset="2" id="vw4-8t-031">
                                    <behavior key="behavior" pushIn="YES" lightByBackground="YES" lightByGray="YES"/>
                                    <font key="font" metaFont="system"/>
                                </buttonCell>
                            </button>
                        </subviews>
                    </view>
                    <color key="fillColor" name="windowBackgroundColor" catalog="System" colorSpace="catalog"/>
                </box>
                <scrollView autohidesScrollers="YES" horizontalLineScroll="24" horizontalPageScroll="10" verticalLineScroll="24" verticalPageScroll="10" usesPredominantAxisScrolling="NO" translatesAutoresizingMaskIntoConstraints="NO" id="YfC-LH-2Cy">
                    <rect key="frame" x="0.0" y="0.0" width="1250" height="482"/>
                    <clipView key="contentView" id="8Lu-A7-jST">
                        <rect key="frame" x="1" y="1" width="1248" height="480"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <tableView verticalHuggingPriority="750" allowsExpansionToolTips="YES" columnAutoresizingStyle="lastColumnOnly" tableStyle="inset" multipleSelection="NO" autosaveColumns="NO" rowHeight="24" rowSizeStyle="automatic" viewBased="YES" id="TXQ-jM-53l">
                                <rect key="frame" x="0.0" y="0.0" width="1248" height="480"/>
                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                <size key="intercellSpacing" width="17" height="0.0"/>
                                <color key="backgroundColor" name="controlBackgroundColor" catalog="System" colorSpace="catalog"/>
                                <color key="gridColor" name="gridColor" catalog="System" colorSpace="catalog"/>
                                <tableColumns>
                                    <tableColumn identifier="AutomaticTableColumnIdentifier.0" width="1000" minWidth="40" maxWidth="1000" id="miR-bb-ZaC">
                                        <tableHeaderCell key="headerCell" lineBreakMode="truncatingTail" borderStyle="border">
                                            <color key="textColor" name="headerTextColor" catalog="System" colorSpace="catalog"/>
                                            <color key="backgroundColor" name="headerColor" catalog="System" colorSpace="catalog"/>
                                        </tableHeaderCell>
                                        <textFieldCell key="dataCell" lineBreakMode="truncatingTail" selectable="YES" editable="YES" title="Text Cell" id="2RS-bP-Pmh">
                                            <font key="font" metaFont="system"/>
                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                            <color key="backgroundColor" name="controlBackgroundColor" catalog="System" colorSpace="catalog"/>
                                        </textFieldCell>
                                        <tableColumnResizingMask key="resizingMask" resizeWithTable="YES" userResizable="YES"/>
                                        <prototypeCellViews>
                                            <tableCellView id="JYm-8e-dp7">
                                                <rect key="frame" x="18" y="0.0" width="995" height="24"/>
                                                <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                                <subviews>
                                                    <textField focusRingType="none" horizontalHuggingPriority="251" verticalHuggingPriority="750" horizontalCompressionResistancePriority="250" fixedFrame="YES" translatesAutoresizingMaskIntoConstraints="NO" id="GKb-Kh-sQf">
                                                        <rect key="frame" x="0.0" y="4" width="995" height="16"/>
                                                        <autoresizingMask key="autoresizingMask" widthSizable="YES" flexibleMinY="YES" flexibleMaxY="YES"/>
                                                        <textFieldCell key="cell" lineBreakMode="truncatingTail" sendsActionOnEndEditing="YES" title="Table View Cell" id="KeF-h9-SN4">
                                                            <font key="font" usesAppearanceFont="YES"/>
                                                            <color key="textColor" name="controlTextColor" catalog="System" colorSpace="catalog"/>
                                                            <color key="backgroundColor" name="textBackgroundColor" catalog="System" colorSpace="catalog"/>
                                                        </textFieldCell>
                                                    </textField>
                                                </subviews>
                                                <connections>
                                                    <outlet property="textField" destination="GKb-Kh-sQf" id="01c-fh-Kwq"/>
                                                </connections>
                                            </tableCellView>
                                        </prototypeCellViews>
                                    </tableColumn>
                                </tableColumns>
                            </tableView>
                        </subviews>
                    </clipView>
                    <scroller key="horizontalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" horizontal="YES" id="imX-uk-6ka">
                        <rect key="frame" x="1" y="119" width="223" height="15"/>
                        <autoresizingMask key="autoresizingMask"/>
                    </scroller>
                    <scroller key="verticalScroller" hidden="YES" wantsLayer="YES" verticalHuggingPriority="750" horizontal="NO" id="Mf6-fD-jRW">
                        <rect key="frame" x="224" y="17" width="15" height="102"/>
                        <autoresizingMask key="autoresizingMask"/>
                    </scroller>
                </scrollView>
            </subviews>
            <constraints>
                <constraint firstItem="Fl2-0y-EnG" firstAttribute="top" secondItem="Hz6-mo-xeY" secondAttribute="top" id="10o-a0-Qyd"/>
                <constraint firstItem="YfC-LH-2Cy" firstAttribute="leading" secondItem="Hz6-mo-xeY" secondAttribute="leading" id="6YK-pZ-2dJ"/>
                <constraint firstItem="YfC-LH-2Cy" firstAttribute="height" secondItem="Hz6-mo-xeY" secondAttribute="height" multiplier="0.8" id="Qw6-DA-uOB"/>
                <constraint firstAttribute="trailing" secondItem="YfC-LH-2Cy" secondAttribute="trailing" id="Wwp-kX-LTl"/>
                <constraint firstItem="Fl2-0y-EnG" firstAttribute="leading" secondItem="Hz6-mo-xeY" secondAttribute="leading" id="YOE-km-dUJ"/>
                <constraint firstAttribute="bottom" secondItem="YfC-LH-2Cy" secondAttribute="bottom" id="dUe-Rv-LRq"/>
                <constraint firstItem="YfC-LH-2Cy" firstAttribute="top" secondItem="Fl2-0y-EnG" secondAttribute="bottom" id="yRD-mj-aaB"/>
                <constraint firstAttribute="trailing" secondItem="Fl2-0y-EnG" secondAttribute="trailing" id="zfd-D4-91L"/>
            </constraints>
            <point key="canvasLocation" x="348" y="388"/>
        </customView>
    </objects>
</document>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainCoordinator.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication
import LateResponders

typealias MainTransition = SceneTransition<MainWindowController, MainSplitViewController>

final class MainCoordinator: SceneCoordinator<MainRoute, MainTransition>, LateResponderRegistering {
    let documentState: DocumentState

    private lazy var sidebarCoordinator = SidebarCoordinator(documentState: documentState)

    private lazy var contentCoordinator = ContentCoordinator(documentState: documentState)

    private lazy var inspectorCoordinator = InspectorCoordinator(documentState: documentState)

    private lazy var viewModel = MainViewModel(documentState: documentState, router: self)

    private(set) lazy var lateResponderRegistry = LateResponderRegistry()

    private var childEventDisposeBag = DisposeBag()
    
    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(windowController: .init(documentState: documentState), initialRoute: .main(.local))
    }

    override func prepareTransition(for route: MainRoute) -> MainTransition {
        switch route {
        case .main(let runtimeEngine):
            documentState.runtimeEngine = runtimeEngine
            documentState.currentImageName = nil
            sidebarCoordinator.removeFromParent()
            contentCoordinator.removeFromParent()
            inspectorCoordinator.removeFromParent()
            sidebarCoordinator = SidebarCoordinator(documentState: documentState)
            contentCoordinator = ContentCoordinator(documentState: documentState)
            inspectorCoordinator = InspectorCoordinator(documentState: documentState)
            bindChildEvents()
            viewModel.completeTransition = sidebarCoordinator.rx.didCompleteTransition()
            windowController.setupBindings(for: viewModel)
            return .multiple(
                .show(windowController.splitViewController),
                .set(sidebar: sidebarCoordinator, content: contentCoordinator, inspector: inspectorCoordinator),
                .route(on: sidebarCoordinator, to: .root),
                .route(on: contentCoordinator, to: .placeholder),
                .route(on: inspectorCoordinator, to: .placeholder)
            )
        case .select(let runtimeObject):
            return .route(on: contentCoordinator, to: .root(runtimeObject))
        case .sidebarBack:
            return .route(on: sidebarCoordinator, to: .back)
        case .contentBack:
            return .route(on: contentCoordinator, to: .back)
        case .generationOptions(let sender):
            let viewController = GenerationOptionsViewController()
            let viewModel = GenerationOptionsViewModel(documentState: documentState, router: self)
            viewController.loadViewIfNeeded()
            viewController.setupBindings(for: viewModel)
            return .presentOnRoot(viewController, mode: .asPopover(relativeToRect: sender.bounds, ofView: sender, preferredEdge: .maxY, behavior: .transient))
        case .loadFramework:
            return .none()
        case .attachToProcess:
            let viewController = AttachToProcessViewController()
            let viewModel = AttachToProcessViewModel(documentState: documentState, router: self)
            viewController.setupBindings(for: viewModel)
            viewController.preferredContentSize = .init(width: 800, height: 600)
            return .presentOnRoot(viewController, mode: .asSheet)
        case .dismiss:
            return .dismiss()
        case .exportInterfaces:
            guard let exportingCoordinator = ExportingCoordinator(documentState: documentState) else { return .none() }
            addChild(exportingCoordinator)
            return .beginSheet(exportingCoordinator)
        }
    }

    override func completeTransition(for route: MainRoute) {
        switch route {
        case .main:
            windowController.splitViewController.setupSplitViewItems()
        default:
            break
        }
    }

    override var nextResponder: NSResponder? {
        set {
            lateResponderRegistry.lastResponder.nextResponder = newValue
        }
        get {
            lateResponderRegistry.initialResponder
        }
    }

    private func bindChildEvents() {
        childEventDisposeBag = DisposeBag()
        
        sidebarCoordinator.rx.didCompleteTransition()
            .subscribeOnNext { [weak self] route in
                guard let self else { return }
                switch route {
                case .clickedNode(let imageNode):
                    documentState.currentImageName = imageNode.name
                    documentState.currentImagePath = imageNode.path
                case .selectedObject(let runtimeObject):
                    documentState.selectedRuntimeObject = runtimeObject
                    contentCoordinator.trigger(.root(runtimeObject))
                case .back:
                    documentState.currentImageName = nil
                    documentState.currentImagePath = nil
                    documentState.selectedRuntimeObject = nil
                    contentCoordinator.trigger(.placeholder)
                case .exportInterface:
                    trigger(.exportInterfaces)
                case .selectedNode:
                    break
                case .root:
                    break
                }
            }
            .disposed(by: childEventDisposeBag)
        
        contentCoordinator.rx.didCompleteTransition()
            .subscribeOnNext { [weak self] route in
                guard let self else { return }
                let hasBackStack = contentCoordinator.rootViewController.viewControllers.count >= 2
                viewModel.isContentStackDepthGreaterThanOne.accept(hasBackStack)
                switch route {
                case .placeholder:
                    documentState.selectedRuntimeObject = nil
                    inspectorCoordinator.trigger(.placeholder)
                case .root(let runtimeObject):
                    documentState.selectedRuntimeObject = runtimeObject
                    inspectorCoordinator.trigger(.root(.object(runtimeObject)))
                case .next(let runtimeObject):
                    documentState.selectedRuntimeObject = runtimeObject
                    inspectorCoordinator.trigger(.next(.object(runtimeObject)))
                case .back:
                    inspectorCoordinator.trigger(.back)
                }
            }
            .disposed(by: childEventDisposeBag)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainRoute.swift`:

```swift
import Foundation
import FoundationToolbox
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

@AssociatedValue(.public)
@CaseCheckable(.public)
public enum MainRoute: Routable {
    case main(RuntimeEngine)
    case select(RuntimeObject)
    case sidebarBack
    case contentBack
    case generationOptions(sender: NSView)
    case loadFramework
    case attachToProcess
    case dismiss
    case exportInterfaces
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainSplitViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerApplication
import Dependencies

final class MainSplitViewController: NSSplitViewController {
    private var viewModel: MainViewModel?

    @Dependency(\.appDefaults)
    private var appDefaults

    override var splitViewItems: [NSSplitViewItem] {
        didSet {}
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        splitView.identifier = .makeIdentifier(of: Self.self)
    }

    private static let sidebarMinimumWidth: CGFloat = 300

    private static let contentMinimumWidth: CGFloat = 300

    private static let inspectorMinimumWidth: CGFloat = 260

    func setupSplitViewItems() {
        splitViewItems[safe: 0]?.do {
            $0.minimumThickness = Self.sidebarMinimumWidth
            $0.maximumThickness = NSSplitViewItem.unspecifiedDimension
            $0.holdingPriority = .init(261)
        }

        splitViewItems[safe: 1]?.do {
            $0.minimumThickness = Self.contentMinimumWidth
            $0.maximumThickness = NSSplitViewItem.unspecifiedDimension
            $0.holdingPriority = .init(250)
        }

        splitViewItems[safe: 2]?.do {
            $0.minimumThickness = Self.inspectorMinimumWidth
            $0.maximumThickness = NSSplitViewItem.unspecifiedDimension
            $0.holdingPriority = .init(261)
        }

        let autosaveName = "com.JH.RuntimeViewer.\(Self.self).autosaveName"

        let fullAutosaveName = "NSSplitView Subview Frames \(autosaveName)"

        let isInitialSetupAutosaveName = UserDefaults.standard.array(forKey: fullAutosaveName) == nil

        splitView.autosaveName = nil
        splitView.autosaveName = autosaveName

        DispatchQueue.main.async { [self] in
            if isInitialSetupAutosaveName {
                splitView.setPosition(Self.sidebarMinimumWidth, ofDividerAt: 0)
                splitView.setPosition(view.bounds.width - Self.inspectorMinimumWidth, ofDividerAt: 1)
            }
        }
    }

    func setupBindings(for viewModel: MainViewModel) {
        self.viewModel = viewModel
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainToolbarController.swift`:

```swift
import AppKit
import RxAppKit
import RuntimeViewerUI

final class MainToolbarController: NSObject, NSToolbarDelegate {
    protocol Delegate: AnyObject {}

    class IconButtonToolbarItem: NSToolbarItem {
        let button = ToolbarButton()
        
        convenience init(itemIdentifier: NSToolbarItem.Identifier, icon: SFSymbols.SystemSymbolName) {
            self.init(itemIdentifier: itemIdentifier, icon: icon as SFSymbols.SymbolName)
        }

        convenience init(itemIdentifier: NSToolbarItem.Identifier, icon: RuntimeViewerSymbols) {
            self.init(itemIdentifier: itemIdentifier, icon: icon as SFSymbols.SymbolName)
        }

        init(itemIdentifier: NSToolbarItem.Identifier, icon: SFSymbols.SymbolName) {
            super.init(itemIdentifier: itemIdentifier)
            view = button
            button.title = ""
            button.image = SFSymbols(name: icon).nsImage
        }
    }

    class TitleToolbarItem: NSToolbarItem {
        private let imageView = NSImageView()
        private let titleLabel = NSTextField(labelWithString: "")
        private let subtitleLabel = NSTextField(labelWithString: "")
        private let textStackView = NSStackView()
        private let containerStackView = NSStackView()

        var displayTitle: String {
            get { titleLabel.stringValue }
            set { titleLabel.stringValue = newValue }
        }

        var displaySubtitle: String {
            get { subtitleLabel.stringValue }
            set {
                let hadSubtitle = !subtitleLabel.stringValue.isEmpty
                let hasSubtitle = !newValue.isEmpty
                subtitleLabel.stringValue = newValue
                subtitleLabel.isHidden = newValue.isEmpty
                if hadSubtitle != hasSubtitle {
                    updateTitleFont()
                }
            }
        }

        var displayImage: NSImage? {
            get { imageView.image }
            set {
                imageView.image = newValue
                imageView.isHidden = newValue == nil
            }
        }

        var insets: NSEdgeInsets = NSEdgeInsets(top: 0, left: 8, bottom: 0, right: 0) {
            didSet { containerStackView.edgeInsets = insets }
        }

        init() {
            super.init(itemIdentifier: .Main.title)
            isNavigational = true
            isBordered = false

            imageView.imageScaling = .scaleProportionallyDown
            imageView.isHidden = true
            imageView.setContentHuggingPriority(.required, for: .horizontal)

            titleLabel.textColor = .labelColor
            titleLabel.lineBreakMode = .byTruncatingTail
            titleLabel.alignment = .left
            titleLabel.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)

            subtitleLabel.font = .systemFont(ofSize: 11, weight: .regular)
            subtitleLabel.textColor = .secondaryLabelColor
            subtitleLabel.lineBreakMode = .byTruncatingTail
            subtitleLabel.alignment = .left
            subtitleLabel.isHidden = true
            subtitleLabel.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)

            textStackView.setViews([titleLabel, subtitleLabel], in: .center)
            textStackView.orientation = .vertical
            textStackView.alignment = .leading
            textStackView.spacing = 0

            containerStackView.setViews([imageView, textStackView], in: .center)
            containerStackView.orientation = .horizontal
            containerStackView.alignment = .centerY
            containerStackView.spacing = 10
            containerStackView.edgeInsets = insets

            updateTitleFont()

            view = containerStackView
        }

        private func updateTitleFont() {
            let hasSubtitle = !subtitleLabel.isHidden
            if hasSubtitle {
                titleLabel.font = .systemFont(ofSize: 13, weight: .bold)
            } else {
                titleLabel.font = .systemFont(ofSize: 15, weight: .semibold)
            }
        }
    }

    class SwitchSourceToolbarItem: NSToolbarItem {
        let popUpButton = NSPopUpButton()

        init() {
            super.init(itemIdentifier: .Main.switchSource)
            view = popUpButton
            popUpButton.controlSize = .large
            popUpButton.bezelStyle = .toolbar
        }
    }

    let toolbar: NSToolbar

    unowned let delegate: Delegate

    let sidebarBackItem = IconButtonToolbarItem(itemIdentifier: .Main.sidebarBack, icon: .chevronBackward).then {
        $0.label = "Back"
    }

    let contentBackItem = IconButtonToolbarItem(itemIdentifier: .Main.contentBack, icon: .chevronBackward).then {
        $0.isNavigational = true
        $0.label = "Back"
    }

    let titleItem = TitleToolbarItem()

    let attachItem = IconButtonToolbarItem(itemIdentifier: .Main.attach, icon: .inject).then {
        $0.label = "Attach Process"
    }

    let saveItem = IconButtonToolbarItem(itemIdentifier: .Main.save, icon: .squareAndArrowDown).then {
        $0.label = "Save"
    }

    let switchSourceItem = SwitchSourceToolbarItem().then {
        $0.label = "Runtime Source"
    }

    let generationOptionsItem = IconButtonToolbarItem(itemIdentifier: .Main.generationOptions, icon: .ellipsisCurlybraces).then {
        $0.label = "Generation Options"
    }

    let sharingServicePickerItem = NSSharingServicePickerToolbarItem(itemIdentifier: .Main.share)

    let fontSizeSmallerItem = IconButtonToolbarItem(itemIdentifier: .Main.fontSizeSmaller, icon: .textformatSizeSmaller).then {
        $0.label = "Font Size Smaller"
    }

    let fontSizeLargerItem = IconButtonToolbarItem(itemIdentifier: .Main.fontSizeLarger, icon: .textformatSizeLarger).then {
        $0.label = "Font Size Larger"
    }

    let loadFrameworksItem = IconButtonToolbarItem(itemIdentifier: .Main.loadFrameworks, icon: .latch2Case).then {
        $0.label = "Load Frameworks"
    }

    let installHelperItem = IconButtonToolbarItem(itemIdentifier: .Main.installHelper, icon: .wrenchAndScrewdriver).then {
        $0.label = "Install Helper"
    }

    init(delegate: Delegate) {
        self.delegate = delegate
        self.toolbar = NSToolbar()
        super.init()

        toolbar.delegate = self
        toolbar.displayMode = .iconOnly
        toolbar.allowsUserCustomization = false
    }

    func toolbarDefaultItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {
        [
            .toggleSidebar,
            .Main.sidebarBack,
            .flexibleSpace,
            .sidebarTrackingSeparator,
            .Main.contentBack,
            .Main.title,
            .flexibleSpace,
            .Main.switchSource,
            .Main.attach,
            .Main.loadFrameworks,
            .Main.fontSizeSmaller,
            .Main.fontSizeLarger,
            .Main.generationOptions,
            .Main.save,
            .Main.share,
            .inspectorTrackingSeparator,
            .flexibleSpace,
            .toggleInspector,
        ]
    }

    func toolbarAllowedItemIdentifiers(_ toolbar: NSToolbar) -> [NSToolbarItem.Identifier] {
        [
            .Main.sidebarBack,
            .Main.contentBack,
            .Main.title,
            .flexibleSpace,
            .toggleSidebar,
            .sidebarTrackingSeparator,
            .inspectorTrackingSeparator,
            .toggleInspector,
            .Main.share,
            .Main.save,
            .Main.switchSource,
            .Main.generationOptions,
            .Main.fontSizeSmaller,
            .Main.fontSizeLarger,
            .Main.loadFrameworks,
            .Main.attach,
        ]
    }

    func toolbar(_ toolbar: NSToolbar, itemForItemIdentifier itemIdentifier: NSToolbarItem.Identifier, willBeInsertedIntoToolbar flag: Bool) -> NSToolbarItem? {
        switch itemIdentifier {
        case .Main.sidebarBack:
            return sidebarBackItem
        case .Main.contentBack:
            return contentBackItem
        case .Main.title:
            return titleItem
        case .Main.share:
            return sharingServicePickerItem
        case .Main.save:
            return saveItem
        case .Main.switchSource:
            return switchSourceItem
        case .Main.generationOptions:
            return generationOptionsItem
        case .Main.fontSizeSmaller:
            return fontSizeSmallerItem
        case .Main.fontSizeLarger:
            return fontSizeLargerItem
        case .Main.loadFrameworks:
            return loadFrameworksItem
        case .Main.installHelper:
            return installHelperItem
        case .Main.attach:
            return attachItem
        default:
            return nil
        }
    }
}

extension NSToolbarItem.Identifier: @retroactive ExpressibleByStringLiteral {
    public init(stringLiteral value: StringLiteralType) {
        self.init(value)
    }
}

extension NSToolbarItem.Identifier {
    enum Main {
        static let sidebarBack: NSToolbarItem.Identifier = "sidebarBack"
        static let contentBack: NSToolbarItem.Identifier = "contentBack"
        static let title: NSToolbarItem.Identifier = "title"
        static let share: NSToolbarItem.Identifier = "share"
        static let save: NSToolbarItem.Identifier = "save"
        static let switchSource: NSToolbarItem.Identifier = "switchSource"
        static let generationOptions: NSToolbarItem.Identifier = "generationOptions"
        static let fontSizeSmaller: NSToolbarItem.Identifier = "fontSizeSmaller"
        static let fontSizeLarger: NSToolbarItem.Identifier = "fontSizeLarger"
        static let loadFrameworks: NSToolbarItem.Identifier = "loadFrameworks"
        static let installHelper: NSToolbarItem.Identifier = "installHelper"
        static let helperStatus: NSToolbarItem.Identifier = "helperStatus"
        static let attach: NSToolbarItem.Identifier = "attach"
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainViewModel.swift`:

```swift
import AppKit
import UniformTypeIdentifiers
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication
import RuntimeViewerCommunication

enum MessageError: LocalizedError {
    case message(String)

    var errorDescription: String? {
        switch self {
        case .message(let message):
            return message
        }
    }
}

struct SharingData {
    let provider: NSItemProvider
    let title: String
    let iconType: RuntimeObjectKind
}


final class MainViewModel: ViewModel<MainRoute> {
    struct Input {
        let sidebarBackClick: Signal<Void>
        let contentBackClick: Signal<Void>
        let saveClick: Signal<Void>
        let switchSource: Signal<Int>
        let generationOptionsClick: Signal<NSView>
        let fontSizeSmallerClick: Signal<Void>
        let fontSizeLargerClick: Signal<Void>
        let loadFrameworksClick: Signal<Void>
//        let installHelperClick: Signal<Void>
        let attachToProcessClick: Signal<Void>
        let frameworksSelected: Signal<[URL]>
        let saveLocationSelected: Signal<URL>
    }

    struct Output {
        let sharingServiceData: Observable<[SharingData]>
        let isSavable: Driver<Bool>
        let isSidebarBackHidden: Driver<Bool>
        let isContentBackHidden: Driver<Bool>
        let runtimeSources: Driver<[RuntimeSource]>
        let selectedRuntimeSourceIndex: Driver<Int>
        let requestFrameworkSelection: Signal<Void>
        let requestSaveLocation: Signal<(name: String, type: UTType)>
        let requestRestartConfirmation: Signal<Void>
    }

    @Dependency(\.runtimeEngineManager) private var runtimeEngineManager

    var completeTransition: Observable<SidebarRoute>? {
        didSet {
            completeTransitionDisposable?.dispose()
            completeTransitionDisposable = completeTransition?.map { if case .selectedObject(let runtimeObject) = $0 { runtimeObject } else { nil } }.bind(to: $selectedRuntimeObject)
        }
    }

    var completeTransitionDisposable: Disposable?

    let isContentStackDepthGreaterThanOne = BehaviorRelay<Bool>(value: false)

    let selectedRuntimeSourceIndex = BehaviorRelay(value: 0)

    @Observed
    var selectedRuntimeObject: RuntimeObject?

    private let requestRestartConfirmationRelay = PublishRelay<Void>()

    func transform(_ input: Input) -> Output {
        rx.disposeBag = DisposeBag()

        let requestFrameworkSelection = input.loadFrameworksClick.asSignal()

        input.frameworksSelected.emitOnNext { [weak self] urls in
            guard let self else { return }
            Task { @MainActor in
                for url in urls {
                    do {
                        try Bundle(url: url)?.loadAndReturnError()
                        await self.documentState.runtimeEngine.reloadData(isReloadImageNodes: false)
                    } catch {
                        self.errorRelay.accept(error)
                    }
                }
            }
        }.disposed(by: rx.disposeBag)

        

//        input.installHelperClick.emitOnNext { [weak self] in
//            guard let self else { return }
//            Task { @MainActor in
//                do {
//                    try RuntimeHelperClient.installLegacyHelper()
//                    self.requestRestartConfirmationRelay.accept(())
//                } catch {
//                    self.errorRelay.accept(error)
//                }
//            }
//        }
//        .disposed(by: rx.disposeBag)

        input.fontSizeSmallerClick.emitOnNext { [weak self] in
            guard let self else { return }
            appDefaults.themeProfile.fontSizeSmaller()
        }
        .disposed(by: rx.disposeBag)

        input.fontSizeLargerClick.emitOnNext { [weak self] in
            guard let self else { return }
            appDefaults.themeProfile.fontSizeLarger()
        }
        .disposed(by: rx.disposeBag)

        input.attachToProcessClick.emitOnNextMainActor { [weak self] in
            guard let self else { return }
            if SIPChecker.isDisabled() {
                router.trigger(.attachToProcess)
            } else {
                errorRelay.accept(MessageError.message("SIP is enabled. Please disable SIP to attach to process."))
            }
        }
        .disposed(by: rx.disposeBag)

        input.sidebarBackClick.emit(to: router.rx.trigger(.sidebarBack)).disposed(by: rx.disposeBag)

        input.contentBackClick.emit(to: router.rx.trigger(.contentBack)).disposed(by: rx.disposeBag)

        input.generationOptionsClick.emit(with: self) { $0.router.trigger(.generationOptions(sender: $1)) }.disposed(by: rx.disposeBag)
        
        let requestSaveLocation = input.saveClick
            .withLatestFrom($selectedRuntimeObject.asSignalOnErrorJustComplete())
            .filterNil()
            .map { (name: $0.displayName, type: $0.contentType) }

        input.saveLocationSelected
            .withLatestFrom($selectedRuntimeObject.asSignalOnErrorJustComplete()) { saveLocation, selectedRuntimeObject in
                selectedRuntimeObject.map { (saveLocation, $0) }
            }
            .filterNil()
            .emitOnNext { [weak self] url, runtimeObject in
                guard let self else { return }
                Task {
                    do {
                        let semanticString = try await self.documentState.runtimeEngine.interface(for: runtimeObject, options: self.appDefaults.options)?.interfaceString
                        try semanticString?.string.write(to: url, atomically: true, encoding: .utf8)
                    } catch {
                        self.errorRelay.accept(error)
                    }
                }
            }.disposed(by: rx.disposeBag)

        input.switchSource.emit(with: self) {
            $0.router.trigger(.main($0.runtimeEngineManager.runtimeEngines[$1]))
            $0.selectedRuntimeSourceIndex.accept($1)
        }.disposed(by: rx.disposeBag)

        let sharingServiceData = completeTransition?.map { [weak self] router -> [SharingData] in
            guard let self, case .selectedObject(let runtimeObjectType) = router else { return [] }
            
            let item = NSItemProvider()
            
            item.registerDataRepresentation(forTypeIdentifier: runtimeObjectType.contentType.identifier, visibility: .all) { [weak self] completion in
                guard let self else {
                    completion(nil, nil)
                    return nil
                }
                Task { [weak self] in
                    guard let self else { return }
                    do {
                        let semanticString = try await documentState.runtimeEngine.interface(for: runtimeObjectType, options: self.appDefaults.options)?.interfaceString
                        completion(semanticString?.string.data(using: .utf8), nil)
                    } catch {
                        completion(nil, error)
                    }
                }
                return nil
            }
            
            return [SharingData(provider: item, title: runtimeObjectType.displayName, iconType: runtimeObjectType.kind)]
        }

        return Output(
            sharingServiceData: sharingServiceData ?? .empty(),
            isSavable: $selectedRuntimeObject.asDriver().map { $0 != nil },
            isSidebarBackHidden: completeTransition?.map { if $0.isClickedNode || $0.isSelectedObject { false } else { true } }.asDriver(onErrorJustReturn: true) ?? .just(true),
            isContentBackHidden: isContentStackDepthGreaterThanOne.map {
                !$0
            }.asDriver(onErrorJustReturn: true),
            runtimeSources: runtimeEngineManager.rx.runtimeEngines.map { $0.map { $0.source } },
            selectedRuntimeSourceIndex: selectedRuntimeSourceIndex.asDriver(),
            requestFrameworkSelection: requestFrameworkSelection,
            requestSaveLocation: requestSaveLocation,
            requestRestartConfirmation: requestRestartConfirmationRelay.asSignal()
        )
    }
}

extension UTType {
    fileprivate static let swiftInterface: Self = .init(filenameExtension: "swiftinterface") ?? .swiftSource
}

extension RuntimeObject {
    fileprivate var contentType: UTType {
        switch kind {
        case .c,
             .objc:
            return .cHeader
        case .swift:
            return .swiftInterface
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainWindowController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication
import UniformTypeIdentifiers

final class MainWindow: NSWindow {
    static let identifier: NSUserInterfaceItemIdentifier = "com.JH.RuntimeViewer.MainWindow"
    static let frameAutosaveName = "com.JH.RuntimeViewer.MainWindow.FrameAutosaveName"

    init() {
        super.init(contentRect: .zero, styleMask: [.titled, .closable, .miniaturizable, .resizable, .fullSizeContentView], backing: .buffered, defer: false)
    }

    override var canBecomeKey: Bool {
        true
    }

    override var canBecomeMain: Bool {
        true
    }
}

final class MainWindowController: XiblessWindowController<MainWindow> {
    let documentState: DocumentState

    private(set) lazy var toolbarController = MainToolbarController(delegate: self)

    private(set) lazy var splitViewController = MainSplitViewController()

    private var viewModel: MainViewModel?

    private let frameworksSelectedRelay = PublishRelay<[URL]>()

    private let saveLocationSelectedRelay = PublishRelay<URL>()

    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(windowGenerator: .init())
    }

    override func synchronizeWindowTitleWithDocumentName() {
        // Prevent NSDocument from overriding the window title with "Untitled"
        contentWindow.title = documentState.runtimeEngine.source.description
    }

    override func windowDidLoad() {
        super.windowDidLoad()
        contentWindow.title = documentState.runtimeEngine.source.description
        contentWindow.titleVisibility = .hidden
        contentWindow.toolbar = toolbarController.toolbar
        contentWindow.setFrame(.init(origin: .zero, size: .init(width: 1280, height: 800)), display: true)
        contentWindow.box.positionCenter()
        contentWindow.identifier = .makeIdentifier(of: Self.self)
        contentWindow.setFrameAutosaveName("com.JH.RuntimeViewer.\(Self.self).autosaveName")
        contentWindow.animationBehavior = .documentWindow
    }

    func setupBindings(for viewModel: MainViewModel) {
        rx.disposeBag = DisposeBag()

        self.viewModel = viewModel

        splitViewController.setupBindings(for: viewModel)

        documentState.$currentImageName
            .asDriver()
            .driveOnNext { [weak self] imageName in
                guard let self else { return }
                var title = documentState.runtimeEngine.source.description

                if let imageName {
                    title += " - \(imageName)"
                }

                contentWindow.title = title
                if let imageName {
                    toolbarController.titleItem.displayTitle = imageName
                } else {
                    toolbarController.titleItem.displayTitle = "RuntimeViewer"
                }
            }
            .disposed(by: rx.disposeBag)

        documentState.$currentSubtitle
            .asDriver()
            .driveOnNext { [weak self] subtitle in
                guard let self else { return }
                toolbarController.titleItem.displaySubtitle = subtitle
            }
            .disposed(by: rx.disposeBag)

        let input = MainViewModel.Input(
            sidebarBackClick: toolbarController.sidebarBackItem.button.rx.click.asSignal(),
            contentBackClick: toolbarController.contentBackItem.button.rx.click.asSignal(),
            saveClick: toolbarController.saveItem.button.rx.click.asSignal(),
            switchSource: toolbarController.switchSourceItem.popUpButton.rx.selectedItemIndex().asSignal(),
            generationOptionsClick: toolbarController.generationOptionsItem.button.rx.clickWithSelf.asSignal().map { $0 },
            fontSizeSmallerClick: toolbarController.fontSizeSmallerItem.button.rx.click.asSignal(),
            fontSizeLargerClick: toolbarController.fontSizeLargerItem.button.rx.click.asSignal(),
            loadFrameworksClick: toolbarController.loadFrameworksItem.button.rx.click.asSignal(),
            attachToProcessClick: toolbarController.attachItem.button.rx.click.asSignal(),
            frameworksSelected: frameworksSelectedRelay.asSignal(),
            saveLocationSelected: saveLocationSelectedRelay.asSignal()
        )
        let output = viewModel.transform(input)

        output.sharingServiceData
            .map { items -> [Any] in
                items.map { data in
                    let icon: NSImage
                    let ext: String
                    switch data.iconType {
                    case .c,
                         .objc:
                        ext = "h"
                        icon = NSWorkspace.shared.icon(for: .cHeader)
                    case .swift:
                        ext = "swiftinterface"
                        icon = NSWorkspace.shared.icon(for: .swiftSource)
                    }
                    return NSPreviewRepresentingActivityItem(item: data.provider, title: data.title + "." + ext, image: nil, icon: icon)
                }
            }
            .bind(to: toolbarController.sharingServicePickerItem.rx.items)
            .disposed(by: rx.disposeBag)

        output.requestFrameworkSelection.emitOnNext { [weak self] in
            guard let self else { return }
            presentOpenPanel()
        }
        .disposed(by: rx.disposeBag)

        output.requestSaveLocation.emitOnNext { [weak self] name, type in
            guard let self else { return }
            presentSavePanel(name: name, type: type)
        }.disposed(by: rx.disposeBag)

        output.isSavable.drive(toolbarController.saveItem.button.rx.isEnabled).disposed(by: rx.disposeBag)

        output.isSidebarBackHidden.drive(toolbarController.sidebarBackItem.rx.isHidden).disposed(by: rx.disposeBag)

        output.isContentBackHidden.drive(toolbarController.contentBackItem.rx.isHidden).disposed(by: rx.disposeBag)

        output.selectedRuntimeSourceIndex.drive(toolbarController.switchSourceItem.popUpButton.rx.selectedIndex()).disposed(by: rx.disposeBag)

        output.runtimeSources.drive(toolbarController.switchSourceItem.popUpButton.rx.items()).disposed(by: rx.disposeBag)

        viewModel.errorRelay
            .asSignal()
            .emitOnNextMainActor { [weak self] error in
                guard let self else { return }
                NSAlert(error: error).beginSheetModal(for: contentWindow)
            }
            .disposed(by: rx.disposeBag)
    }

    private func presentOpenPanel() {
        let openPanel = NSOpenPanel()
        openPanel.allowedContentTypes = [.framework]
        openPanel.allowsMultipleSelection = true
        openPanel.canChooseDirectories = true
        openPanel.beginSheetModal(for: contentWindow) { [weak self] response in
            guard let self, response == .OK else { return }
            frameworksSelectedRelay.accept(openPanel.urls)
        }
    }

    private func presentSavePanel(name: String, type: UTType) {
        let savePanel = NSSavePanel()
        savePanel.allowedContentTypes = [type]
        savePanel.nameFieldStringValue = name
        savePanel.beginSheetModal(for: contentWindow) { [weak self] response in
            guard let self, response == .OK, let url = savePanel.url else { return }
            saveLocationSelectedRelay.accept(url)
        }
    }
    
//    @IBAction func exportInterface(_ sender: Any?) {
//        viewModel?.router.trigger(.exportInterfaces)
//    }
}

extension MainWindowController: MainToolbarController.Delegate {}

extension NSUserInterfaceItemIdentifier {
    static func makeIdentifier<T>(of type: T.Type) -> Self {
        "com.JH.RuntimeViewer.\(T.self).identifier"
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Release.xcconfig`:

```xcconfig
//#include "Shared-Release.xcconfig"

SMPrivilegedExecutable = anchor apple generic and identifier "com.JH.RuntimeViewerService" and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = D5Q73692VW)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Resources/AppIcon.icon/icon.json`:

```json
{
  "fill" : {
    "automatic-gradient" : "extended-srgb:0.00000,0.53333,1.00000,1.00000"
  },
  "groups" : [
    {
      "blend-mode" : "normal",
      "blur-material" : 0.5,
      "hidden" : false,
      "layers" : [
        {
          "glass" : false,
          "image-name" : "Background 2.png",
          "name" : "Background 2",
          "position" : {
            "scale" : 1.3,
            "translation-in-points" : [
              12.78125,
              3.046875
            ]
          }
        }
      ],
      "lighting" : "individual",
      "shadow" : {
        "kind" : "neutral",
        "opacity" : 0.5
      },
      "specular" : true,
      "translucency" : {
        "enabled" : true,
        "value" : 0.5
      }
    }
  ],
  "supported-platforms" : {
    "circles" : [
      "watchOS"
    ],
    "squares" : "shared"
  }
}
```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Resources/RuntimeViewerSymbols.swift`:

```swift
import Foundation
import SFSymbols

enum RuntimeViewerSymbols: String, SFSymbols.SymbolName {
    case inject
    case app
    case appFill = "app.fill"

    var bundle: Bundle? { .main }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict/>
</plist>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarCoordinator.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

typealias SidebarTransition = Transition<Void, SidebarNavigationController>

final class SidebarCoordinator: ViewCoordinator<SidebarRoute, SidebarTransition> {
    let documentState: DocumentState

    private var rootCoordinator: SidebarRootCoordinator?

    private var runtimeObjectCoordinator: SidebarRuntimeObjectCoordinator?

    private var childEventDisposeBag = DisposeBag()

    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(rootViewController: .init(nibName: nil, bundle: nil), initialRoute: nil)
    }

    override func prepareTransition(for route: SidebarRoute) -> SidebarTransition {
        switch route {
        case .root:
            rootCoordinator?.removeFromParent()
            childEventDisposeBag = DisposeBag()
            let rootCoordinator = SidebarRootCoordinator(documentState: documentState)
            rootCoordinator.rx.didCompleteTransition()
                .subscribeOnNext { [weak self] route in
                    guard let self else { return }
                    switch route {
                    case .image(let imageNode):
                        trigger(.clickedNode(imageNode))
                    default:
                        break
                    }
                }
                .disposed(by: childEventDisposeBag)
            self.rootCoordinator = rootCoordinator
            return .set([rootCoordinator], animated: false)
        case .clickedNode(let imageNode):
            runtimeObjectCoordinator?.removeFromParent()
            let runtimeObjectCoordinator = SidebarRuntimeObjectCoordinator(documentState: documentState, imageNode: imageNode)
            runtimeObjectCoordinator.rx.didCompleteTransition()
                .subscribeOnNext { [weak self] route in
                    guard let self else { return }
                    switch route {
                    case .selectedObject(let runtimeObjectName):
                        trigger(.selectedObject(runtimeObjectName))
                    case .exportInterface:
                        trigger(.exportInterface)
                    default:
                        break
                    }
                }
                .disposed(by: childEventDisposeBag)
            self.runtimeObjectCoordinator = runtimeObjectCoordinator
            return .push(runtimeObjectCoordinator, animated: true)
        case .back:
            return .pop(animated: true)
        default:
            return .none()
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarNavigationController.swift`:

```swift
import AppKit
import RuntimeViewerUI

final class SidebarNavigationController: UXKitNavigationController {}

extension SidebarNavigationController {
    func navigationController(_ navigationController: UXNavigationController, willShow viewController: UXViewController) {
        if #available(macOS 26.0, *) {
            guard let coordinator = navigationController.transitionCoordinator,
                  let fromViewController = coordinator.viewController(forKey: .from),
                  let toViewController = coordinator.viewController(forKey: .to)
            else { return }

            let fromOriginalBackgroundColor = fromViewController.uxView.backgroundColor
            let toOriginalBackgroundColor = toViewController.uxView.backgroundColor
            coordinator.animate(alongsideTransition: { context in
                fromViewController.uxView.backgroundColor = .windowBackgroundColor
                toViewController.uxView.backgroundColor = .windowBackgroundColor
            }, completion: { context in
                fromViewController.uxView.backgroundColor = fromOriginalBackgroundColor
                toViewController.uxView.backgroundColor = toOriginalBackgroundColor
            })
        }
    }

    func navigationController(_ navigationController: UXNavigationController, didShow viewController: UXViewController) {
        if #available(macOS 26.0, *) {
            navigationController.view.needsDisplay = true
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRootBookmarkViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class SidebarRootBookmarkViewController: SidebarRootViewController<SidebarRootBookmarkViewModel> {
    
    override var isReorderable: Bool { true }
    
    private let removeBookmarkRelay = PublishRelay<Int>()

    private let noBookmarkLabel = Label()

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            noBookmarkLabel
        }

        noBookmarkLabel.snp.makeConstraints { make in
            make.center.equalToSuperview()
            make.top.leading.greaterThanOrEqualTo(16).priority(.high)
            make.bottom.trailing.lessThanOrEqualTo(-16)
        }

        noBookmarkLabel.do {
            $0.stringValue = "No Bookmark"
            $0.font = .systemFont(ofSize: 18, weight: .regular)
            $0.textColor = .secondaryLabelColor
        }

        outlineView.do {
            $0.menu = NSMenu().then {
                $0.delegate = self
            }
        }
    }

    override func setupBindings(for viewModel: SidebarRootBookmarkViewModel) {
        super.setupBindings(for: viewModel)

        let input = SidebarRootBookmarkViewModel.Input(
            moveBookmark: outlineView.rx.nodeMoved().asSignal(),
            removeBookmark: removeBookmarkRelay.asSignal(),
        )

        let output = viewModel.transform(input)
        
        output.isMoveBookmarkEnabled.drive(outlineView.rx.isReorderingEnabled).disposed(by: rx.disposeBag)
        
        output.isBookmarkEmpty.not().drive(noBookmarkLabel.rx.isHidden).disposed(by: rx.disposeBag)
        
        output.isBookmarkEmpty.drive(scrollView.rx.isHidden).disposed(by: rx.disposeBag)
        
        Driver.just(true).drive(outlineView.rx.isRootLevelReorderingOnly).disposed(by: rx.disposeBag)
    }

    @objc private func removeBookmarkMenuItemAction(_ sender: NSMenuItem) {
        guard outlineView.hasValidClickedRow, let index = sender.representedObject as? Int else { return }
        removeBookmarkRelay.accept(index)
    }
}

extension SidebarRootBookmarkViewController: NSMenuDelegate {
    func menuNeedsUpdate(_ menu: NSMenu) {
        guard outlineView.hasValidClickedRow else { return }
        
        if outlineView.parent(forItem: outlineView.itemAtClickedRow) == nil, let index = outlineView.rootIndex(forRow: outlineView.clickedRow) {
            menu.removeAllItems()
            menu.addItem(withTitle: "Remove Bookmark", action: #selector(removeBookmarkMenuItemAction(_:)), keyEquivalent: "").then {
                $0.image = SFSymbols(systemName: .bookmark).nsuiImgae
                $0.representedObject = index
            }
        } else {
            menu.removeAllItems()
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRootCoordinator.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

typealias SidebarRootTransition = Transition<Void, SidebarRootTabViewController>

final class SidebarRootCoordinator: ViewCoordinator<SidebarRootRoute, SidebarRootTransition> {
    let documentState: DocumentState

    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(rootViewController: .init(), initialRoute: .initial)
    }

    override func prepareTransition(for route: SidebarRootRoute) -> SidebarRootTransition {
        switch route {
        case .initial:
            let directoryViewController = SidebarRootDirectoryViewController()
            let directoryViewModel = SidebarRootDirectoryViewModel(documentState: documentState, router: self)
            directoryViewController.setupBindings(for: directoryViewModel)

            let bookmarkViewController = SidebarRootBookmarkViewController()
            let bookmarkViewModel = SidebarRootBookmarkViewModel(documentState: documentState, router: self)
            bookmarkViewController.setupBindings(for: bookmarkViewModel)
            return .set([
                TabViewItem(normalSymbol: .init(systemName: .folder), selectedSymbol: .init(systemName: .folderFill), viewController: directoryViewController),
                TabViewItem(normalSymbol: .init(systemName: .bookmark), selectedSymbol: .init(systemName: .bookmarkFill), viewController: bookmarkViewController),
            ])
        case .directory:
            return .select(index: 0)
        case .bookmarks:
            return .select(index: 1)
        default:
            return .none()
        }
    }

}



```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRootDirectoryViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class SidebarRootDirectoryViewController: SidebarRootViewController<SidebarRootDirectoryViewModel> {
    private let addToBookmarkRelay = PublishRelay<SidebarRootCellViewModel>()

    private let addToBookmarkHUD = SystemHUD(
        configuration: .init(
            image: SFSymbols(systemName: .bookmarkFill, pointSize: 90, weight: .medium).nsuiImgae,
            title: "Added Bookmark"
        )
    )

    override func viewDidLoad() {
        super.viewDidLoad()

        outlineView.do {
            $0.menu = NSMenu().then {
                $0.addItem(withTitle: "Add Item to Bookmark", action: #selector(addToBookmarkMenuItemAction(_:)), keyEquivalent: "").then {
                    $0.image = SFSymbols(systemName: .bookmark).nsuiImgae
                }
            }
        }
    }

    @objc private func addToBookmarkMenuItemAction(_ sender: NSMenuItem) {
        guard outlineView.hasValidClickedRow, let cellViewModel = outlineView.itemAtClickedRow as? SidebarRootCellViewModel else { return }
        addToBookmarkRelay.accept(cellViewModel)
        addToBookmarkHUD.show(delay: 1)
    }

    override func setupBindings(for viewModel: SidebarRootDirectoryViewModel) {
        super.setupBindings(for: viewModel)

        let input = SidebarRootDirectoryViewModel.Input(
            addBookmark: addToBookmarkRelay.asSignal()
        )

        _ = viewModel.transform(input)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRootTabViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class SidebarRootTabViewController: TabViewController {}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRootTableCellView.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class SidebarRootTableCellView: ImageTextTableCellView {
    override var backgroundStyle: NSView.BackgroundStyle {
        didSet {
            switch backgroundStyle {
            case .normal:
                _imageView.symbolConfiguration = .init(hierarchicalColor: .controlAccentColor)
            case .emphasized:
                _imageView.symbolConfiguration = .preferringMonochrome()
            case .raised:
                _imageView.symbolConfiguration = .preferringMonochrome()
            case .lowered:
                _imageView.symbolConfiguration = .preferringMonochrome()
            @unknown default:
                break
            }
        }
    }

    override func setup() {
        super.setup()
    }

    func bind(to viewModel: SidebarRootCellViewModel) {
        rx.disposeBag = DisposeBag()

        viewModel.$icon.asDriver().drive(_imageView.rx.image).disposed(by: rx.disposeBag)
        viewModel.$name.asDriver().drive(_textField.rx.attributedStringValue).disposed(by: rx.disposeBag)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRootTableRowView.swift`:

```swift
import AppKit
import RuntimeViewerApplication
import RuntimeViewerArchitectures
import RuntimeViewerUI

final class SidebarRootTableRowView: TableRowView {
    override var backgroundColor: NSColor {
        set {}
        get { Self.backgroundColor }
    }
    
    private static let backgroundColor = NSColor.controlAccentColor.withSystemEffect(.deepPressed)
    
//    override var isEmphasized: Bool {
//        set {}
//        get { true }
//    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRootViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

class SidebarRootViewController<ViewModel: SidebarRootViewModel>: UXKitViewController<ViewModel> {
    var isReorderable: Bool {
        false
    }

    let (scrollView, outlineView): (ScrollView, StatefulOutlineView) = StatefulOutlineView.scrollableSingleColumnOutlineView()

    private let filterSearchField = FilterSearchField()

    private let bottomSeparatorView = NSBox()

    private var dataSource: OutlineViewDataSource?

    override var shouldDisplayCommonLoading: Bool {
        true
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        contentView.hierarchy {
            scrollView
            bottomSeparatorView
            filterSearchField
        }

        scrollView.snp.makeConstraints { make in
            make.top.left.right.equalToSuperview()
            make.bottom.equalTo(bottomSeparatorView.snp.top)
        }

        bottomSeparatorView.snp.makeConstraints { make in
            make.left.right.equalToSuperview()
            make.bottom.equalTo(filterSearchField.snp.top).offset(-8)
            make.height.equalTo(1)
        }

        filterSearchField.snp.makeConstraints { make in
            make.left.right.equalToSuperview().inset(10)
            if #available(macOS 26.0, *) {
                make.bottom.equalTo(view.layoutGuide(for: .safeArea())).inset(8)
            } else {
                make.bottom.equalToSuperview().inset(8)
            }
        }

        bottomSeparatorView.do {
            $0.boxType = .separator
        }

        filterSearchField.do {
            if #available(macOS 26.0, *) {
                $0.controlSize = .extraLarge
                $0.font = .systemFont(ofSize: NSFont.systemFontSize)
                $0.cell?.font = .systemFont(ofSize: NSFont.systemFontSize)
                $0.textFieldCell?.placeholderString = nil
            } else {
                $0.controlSize = .large
            }
        }

        scrollView.do {
            $0.isHiddenVisualEffectView = true
        }
    }

    override func setupBindings(for viewModel: ViewModel) {
        super.setupBindings(for: viewModel)

        dataSource = .init(viewModel: viewModel)

        let input = ViewModel.Input(
            clickedNode: outlineView.rx.modelDoubleClicked().asSignal(),
            selectedNode: outlineView.rx.modelSelected().asSignal(),
            searchString: filterSearchField.rx.stringValue.asSignal()
        )

        let output = viewModel.transform(input)

        output.nodes.drive(isReorderable ? outlineView.rx.reorderableNodes : outlineView.rx.nodes)({ (outlineView: NSOutlineView, tableColumn: NSTableColumn?, node: SidebarRootCellViewModel) -> NSView? in
            let cellView = outlineView.box.makeView(ofClass: SidebarRootTableCellView.self)
            cellView.bind(to: node)
            return cellView
        }, { outlineView, _ -> NSTableRowView? in
            if #available(macOS 26.0, *) {
                return outlineView.box.makeView(ofClass: SidebarRootTableRowView.self)
            } else {
                return nil
            }
        })
        .disposed(by: rx.disposeBag)

        output.didBeginFiltering.emitOnNext { [weak self] in
            guard let self else { return }
            outlineView.beginFiltering()
        }
        .disposed(by: rx.disposeBag)

        output.didChangeFiltering.emitOnNext { [weak self] in
            guard let self else { return }
            outlineView.expandItem(nil, expandChildren: true)
        }
        .disposed(by: rx.disposeBag)

        output.didEndFiltering.emitOnNext { [weak self] in
            guard let self else { return }
            outlineView.endFiltering()
        }
        .disposed(by: rx.disposeBag)

        output.nodesIndexed
            .delay(.milliseconds(100))
            .asObservable()
            .first()
            .asObservable()
            .subscribeOnNext { [weak self] _ in
                guard let self, let dataSource else { return }
                
                outlineView.rx.setDataSource(dataSource).disposed(by: rx.disposeBag)
                outlineView.autosaveExpandedItems = true
                outlineView.identifier = "com.JH.RuntimeViewer.\(Self.self).identifier.\(viewModel.documentState.runtimeEngine.source.description)"
                outlineView.autosaveName = "com.JH.RuntimeViewer.\(Self.self).autosaveName.\(viewModel.documentState.runtimeEngine.source.description)"
            }
            .disposed(by: rx.disposeBag)
    }
}

extension SidebarRootViewController {
    private final class OutlineViewDataSource: NSObject, NSOutlineViewDataSource {
        private unowned let viewModel: ViewModel

        init(viewModel: ViewModel) {
            self.viewModel = viewModel
            super.init()
        }

        func outlineView(_ outlineView: NSOutlineView, itemForPersistentObject object: Any) -> Any? {
            guard !viewModel.isFiltering else { return nil }
            guard let path = object as? String else {
                return nil
            }
            let item = viewModel.allNodes[path]
            return item
        }

        func outlineView(_ outlineView: NSOutlineView, persistentObjectForItem item: Any?) -> Any? {
            guard !viewModel.isFiltering else { return nil }
            guard let item = item as? SidebarRootCellViewModel else { return nil }
            let returnObject = item.node.parent != nil ? item.node.absolutePath : item.node.name
            return returnObject
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRuntimeObjectBookmarkViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerCore
import RuntimeViewerApplication

final class SidebarRuntimeObjectBookmarkViewController: SidebarRuntimeObjectViewController<SidebarRuntimeObjectBookmarkViewModel> {
    
    override var isReorderable: Bool { true }
    
    private let removeBookmarkRelay = PublishRelay<Int>()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        imageLoadedView.emptyLabel.do {
            $0.font = .systemFont(ofSize: 18, weight: .regular)
            $0.textColor = .secondaryLabelColor
        }
        
        outlineView.do {
            $0.menu = NSMenu().then {
                $0.delegate = self
            }
        }
    }
    
    override func setupBindings(for viewModel: SidebarRuntimeObjectBookmarkViewModel) {
        super.setupBindings(for: viewModel)
        
        let input = SidebarRuntimeObjectBookmarkViewModel.Input(
            moveBookmark: outlineView.rx.nodeMoved().asSignal(),
            removeBookmark: removeBookmarkRelay.asSignal(),
        )
        
        let output = viewModel.transform(input)
        
        output.isMoveBookmarkEnabled.drive(outlineView.rx.isReorderingEnabled).disposed(by: rx.disposeBag)
        
        Driver.just(true).drive(outlineView.rx.isRootLevelReorderingOnly).disposed(by: rx.disposeBag)
        
        imageLoadedView.emptyLabel.stringValue = "No Bookmarks"
    }
    
    @objc private func removeBookmarkMenuItemAction(_ sender: NSMenuItem) {
        guard outlineView.hasValidClickedRow, let index = sender.representedObject as? Int else { return }
        removeBookmarkRelay.accept(index)
    }
}

extension SidebarRuntimeObjectBookmarkViewController: NSMenuDelegate {
    func menuNeedsUpdate(_ menu: NSMenu) {
        guard outlineView.hasValidClickedRow else { return }
        
        if outlineView.parent(forItem: outlineView.itemAtClickedRow) == nil, let index = outlineView.rootIndex(forRow: outlineView.clickedRow) {
            menu.removeAllItems()
            menu.addItem(withTitle: "Remove Bookmark", action: #selector(removeBookmarkMenuItemAction(_:)), keyEquivalent: "").then {
                $0.image = SFSymbols(systemName: .bookmark).nsuiImgae
                $0.representedObject = index
            }
        } else {
            menu.removeAllItems()
        }
    }
}

extension NSOutlineView {
    func rootIndex(forRow row: Int) -> Int? {
        guard row >= 0, let initialItem = self.item(atRow: row) else {
            return nil
        }
        
        var currentItem = initialItem
        
        while let parent = self.parent(forItem: currentItem) {
            currentItem = parent
        }
        
        let index = self.childIndex(forItem: currentItem)
        
        return index != -1 ? index : nil
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRuntimeObjectCellView.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerCore
import RuntimeViewerApplication

final class SidebarRuntimeObjectCellView: TableCellView {
    private let primaryIconImageView = ImageView()

    private let secondaryIconImageView = ImageView()

    private let nameLabel = Label()

    private let forOpenQuickly: Bool

    private lazy var contentStackView = HStackView(distribution: .fill, spacing: 6) {
        primaryIconImageView
            .contentHugging(h: .required)
            .contentCompressionResistance(h: .required)
        secondaryIconImageView
            .contentHugging(h: .required)
            .contentCompressionResistance(h: .required)
        nameLabel
            .contentHugging(h: .defaultLow)
            .contentCompressionResistance(h: .defaultLow)
    }

    init(forOpenQuickly: Bool) {
        self.forOpenQuickly = forOpenQuickly
        super.init(frame: .zero)
    }

    @available(*, unavailable)
    @MainActor required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func setup() {
        super.setup()

        addSubview(contentStackView)

        contentStackView.snp.makeConstraints { make in
            if forOpenQuickly {
                make.top.bottom.equalToSuperview()
                make.leading.trailing.equalToSuperview().inset(8)
                make.height.greaterThanOrEqualTo(40)
            } else {
                make.edges.equalToSuperview()
            }
        }

        primaryIconImageView.do {
            $0.contentTintColor = .controlAccentColor
        }

        secondaryIconImageView.do {
            $0.contentTintColor = .controlAccentColor
            $0.isHidden = true
        }

        nameLabel.do {
            $0.alignment = .left
            $0.maximumNumberOfLines = 1
        }
    }

    func bind(to viewModel: SidebarRuntimeObjectCellViewModel) {
        rx.disposeBag = DisposeBag()

        viewModel.$primaryIcon.asDriver().drive(primaryIconImageView.rx.image).disposed(by: rx.disposeBag)
        viewModel.$secondaryIcon.asDriver().drive(secondaryIconImageView.rx.image).disposed(by: rx.disposeBag)
        viewModel.$secondaryIcon.asDriver().map { $0 == nil }.drive(secondaryIconImageView.rx.isHidden).disposed(by: rx.disposeBag)
        viewModel.$name.asDriver().drive(nameLabel.rx.attributedStringValue).disposed(by: rx.disposeBag)
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRuntimeObjectCoordinator.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

typealias SidebarRuntimeObjectTransition = Transition<Void, SidebarRuntimeObjectTabViewController>

final class SidebarRuntimeObjectCoordinator: ViewCoordinator<SidebarRuntimeObjectRoute, SidebarRuntimeObjectTransition> {
    let documentState: DocumentState

    let imageNode: RuntimeImageNode

    init(documentState: DocumentState, imageNode: RuntimeImageNode) {
        self.documentState = documentState
        self.imageNode = imageNode
        super.init(rootViewController: .init(), initialRoute: .initial)
    }

    override func prepareTransition(for route: SidebarRuntimeObjectRoute) -> SidebarRuntimeObjectTransition {
        switch route {
        case .initial:
            let listViewController = SidebarRuntimeObjectListViewController()
            let listViewModel = SidebarRuntimeObjectListViewModel(imageNode: imageNode, documentState: documentState, router: self)
            listViewController.setupBindings(for: listViewModel)

            let bookmarkViewController = SidebarRuntimeObjectBookmarkViewController()
            let bookmarkViewModel = SidebarRuntimeObjectBookmarkViewModel(imageNode: imageNode, documentState: documentState, router: self)
            bookmarkViewController.setupBindings(for: bookmarkViewModel)
            
            return .set([
                TabViewItem(normalSymbol: .init(systemName: .folder), selectedSymbol: .init(systemName: .folderFill), viewController: listViewController),
                TabViewItem(normalSymbol: .init(systemName: .bookmark), selectedSymbol: .init(systemName: .bookmarkFill), viewController: bookmarkViewController),
            ])
        case .objects:
            return .select(index: 0)
        case .bookmarks:
            return .select(index: 1)
        default:
            return .none()
        }
    }

}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRuntimeObjectListViewController.swift`:

```swift
import AppKit
import FoundationToolbox
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerCore
import RuntimeViewerApplication

final class SidebarRuntimeObjectListViewController: SidebarRuntimeObjectViewController<SidebarRuntimeObjectListViewModel> {
    private let openQuicklyActionBar = DSFQuickActionBar()

    private let openQuicklyActivateRelay = PublishRelay<SidebarRuntimeObjectCellViewModel>()

    private let searchStringDidChangeForOpenQuickly = PublishRelay<String>()

    private var currentSearchTask: DSFQuickActionBar.SearchTask?

    private let addToBookmarkRelay = PublishRelay<SidebarRuntimeObjectCellViewModel>()

    private let addToBookmarkHUD = SystemHUD(
        configuration: .init(
            image: SFSymbols(systemName: .bookmarkFill, pointSize: 90, weight: .medium).nsuiImgae,
            title: "Added Bookmark"
        )
    )

    @Dependency(\.appDefaults)
    private var appDefaults

    override func viewDidLoad() {
        super.viewDidLoad()

        openQuicklyActionBar.do {
            $0.contentSource = self
        }

        outlineView.do {
            $0.menu = NSMenu().then {
                $0.addItem(withTitle: "Add Item to Bookmark", action: #selector(addToBookmarkMenuItemAction(_:)), keyEquivalent: "").then {
                    $0.image = SFSymbols(systemName: .bookmark).nsuiImgae
                }
            }
        }
    }

    override func setupBindings(for viewModel: SidebarRuntimeObjectListViewModel) {
        super.setupBindings(for: viewModel)

        let input = SidebarRuntimeObjectListViewModel.Input(
            runtimeObjectClickedForOpenQuickly: openQuicklyActivateRelay.asSignal(),
            searchStringForOpenQuickly: searchStringDidChangeForOpenQuickly.asSignal(),
            addBookmark: addToBookmarkRelay.asSignal()
        )

        let output = viewModel.transform(input)

        output.runtimeObjectsForOpenQuickly.driveOnNextMainActor { [weak self] viewModels in
            guard let self else { return }
            currentSearchTask?.complete(with: viewModels)
            currentSearchTask = nil
        }
        .disposed(by: rx.disposeBag)

        output.selectRuntimeObject.emitOnNextMainActor { [weak self] item in
            guard let self else { return }
            let outlineView = outlineView
            let row = outlineView.row(forItem: item)
            guard row >= 0, row < outlineView.numberOfRows else { return }
            outlineView.selectRowIndexes(.init(integer: row), byExtendingSelection: false)
            guard !outlineView.visibleRowIndexes.contains(row) else { return }
            outlineView.box.scrollRowToVisible(row, animated: false, scrollPosition: .centeredVertically)
        }
        .disposed(by: rx.disposeBag)
    }

    @ArrayBuilder<Selector>
    override func lateResponderSelectors() -> [Selector] {
        #selector(openQuickly(_:))
        #selector(exportInterface(_:))
    }

    @IBAction func openQuickly(_ sender: Any?) {
        openQuicklyActionBar.cancel()
        openQuicklyActionBar.present(
            parentWindow: view.window,
            placeholderText: "Open Quickly",
            searchImage: nil,
            initialSearchText: nil,
            showKeyboardShortcuts: false,
            canBecomeMainWindow: false
        ) {}
    }

    @IBAction func exportInterface(_ sender: Any?) {
        viewModel?.router.trigger(.exportInterface)
    }

    @objc private func addToBookmarkMenuItemAction(_ sender: NSMenuItem) {
        guard outlineView.hasValidClickedRow, let cellViewModel = outlineView.itemAtClickedRow as? SidebarRuntimeObjectCellViewModel else { return }
        addToBookmarkRelay.accept(cellViewModel)
        addToBookmarkHUD.show(delay: 1)
    }
    
    override func responds(to aSelector: Selector!) -> Bool {
        guard let aSelector else { return super.responds(to: aSelector) }
        switch aSelector {
        case #selector(exportInterface(_:)), #selector(openQuickly(_:)):
            return viewModel?.loadState == .loaded
        default:
            return super.responds(to: aSelector)
        }
    }
}

extension SidebarRuntimeObjectListViewController: DSFQuickActionBarContentSource {
    func quickActionBar(_ quickActionBar: DSFQuickActionBar, viewForItem item: AnyHashable, searchTerm: String) -> NSView? {
        guard let viewModel = item as? SidebarRuntimeObjectCellViewModel else { return nil }
        let cellView = quickActionBar.dequeueView() ?? SidebarRuntimeObjectCellView(forOpenQuickly: true)
        cellView.bind(to: viewModel)
        return cellView
    }

    func quickActionBar(_ quickActionBar: DSFQuickActionBar, itemsForSearchTermTask task: DSFQuickActionBar.SearchTask) {
        currentSearchTask = task
        searchStringDidChangeForOpenQuickly.accept(task.searchTerm)
    }

    func quickActionBar(_ quickActionBar: DSFQuickActionBar, didActivateItem item: AnyHashable) {
        guard let viewModel = item as? SidebarRuntimeObjectCellViewModel else { return }
        openQuicklyActivateRelay.accept(viewModel)
    }
}

extension DSFQuickActionBar: Then {}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRuntimeObjectTabViewController.swift`:

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

final class SidebarRuntimeObjectTabViewController: TabViewController {}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Sidebar/SidebarRuntimeObjectViewController.swift`:

```swift
import AppKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerCore
import RuntimeViewerApplication

class SidebarRuntimeObjectViewController<ViewModel: SidebarRuntimeObjectViewModel>: UXKitViewController<ViewModel> {
    var isReorderable: Bool {
        false
    }

    @ViewLoading
    private var tabView: NSTabView

    let imageNotLoadedView = ImageLoadableView()

    let imageLoadingView = ImageLoadingView()

    let imageLoadedView = ImageLoadedView()

    let imageLoadErrorView = ImageLoadableView()

    let imageUnknownView = ImageUnknownView()

    private let filterModeButton = ItemPopUpButton<FilterMode>()

    private let filterSearchField = FilterSearchField()

    private let bottomSeparatorView = NSBox()

    private let filterModeDidChange = PublishRelay<Void>()

    private var searchCaseInsensitiveButton: NSButton?

    @Dependency(\.appDefaults)
    private var appDefaults

    var outlineView: StatefulOutlineView {
        imageLoadedView.outlineView
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        tabView = NSTabView()

        contentView.hierarchy {
            tabView
            bottomSeparatorView
            filterModeButton
            filterSearchField
        }

        tabView.snp.makeConstraints { make in
            make.top.left.right.equalToSuperview()
            make.bottom.equalTo(bottomSeparatorView.snp.top)
        }

        bottomSeparatorView.snp.makeConstraints { make in
            make.left.right.equalToSuperview()
            make.bottom.equalTo(filterSearchField.snp.top).offset(-8)
            make.height.equalTo(1)
        }

        filterModeButton.snp.makeConstraints { make in
            make.left.equalToSuperview().inset(12)
            make.centerY.equalTo(filterSearchField)
        }

        filterSearchField.snp.makeConstraints { make in
            make.left.equalTo(filterModeButton.snp.right).offset(8)
            make.right.equalToSuperview().inset(10)
            make.bottom.equalToSuperview().inset(8)
        }

        tabView.do {
            $0.addTabViewItem(NSTabViewItem(view: imageNotLoadedView, loadState: .notLoaded))
            $0.addTabViewItem(NSTabViewItem(view: imageLoadingView, loadState: .loading))
            $0.addTabViewItem(NSTabViewItem(view: imageLoadedView, loadState: .loaded))
            $0.addTabViewItem(NSTabViewItem(view: imageLoadErrorView, loadState: .loadError(NSTabViewItem.PlaceholderLoadStateError.main)))
            $0.addTabViewItem(NSTabViewItem(view: imageUnknownView, loadState: .unknown))
            $0.tabViewType = .noTabsNoBorder
            $0.tabPosition = .none
            $0.tabViewBorderType = .none
        }

        bottomSeparatorView.do {
            $0.boxType = .separator
        }

        filterModeButton.do {
            $0.icon = .symbol(systemName: .line3HorizontalDecrease)
            $0.setup()
            $0.onItem = appDefaults.filterMode
            $0.stateChanged = { [weak self] filterMode in
                guard let self else { return }
                appDefaults.filterMode = filterMode
                filterModeDidChange.accept()
            }
        }

        filterSearchField.do {
            if #available(macOS 26.0, *) {
                $0.controlSize = .extraLarge
            } else {
                $0.controlSize = .large
            }

            $0.addFilterButton(systemSymbolName: "textformat", toolTip: "Case Insensitive").do { searchCaseInsensitiveButton = $0 }
        }
    }

    override func setupBindings(for viewModel: ViewModel) {
        super.setupBindings(for: viewModel)

        let input = ViewModel.Input(
            runtimeObjectClicked: imageLoadedView.outlineView.rx.modelSelected().asSignal(),
            loadImageClicked: Signal.of(
                imageNotLoadedView.loadImageButton.rx.click.asSignal(),
                imageLoadErrorView.loadImageButton.rx.click.asSignal()
            ).merge(),
            searchString: .combineLatest(filterSearchField.rx.stringValue.asSignal(), filterModeDidChange.asSignal().startWith(()), resultSelector: { a, b in a }),
            isSearchCaseInsensitive: searchCaseInsensitiveButton?.rx.state.asDriver().map { $0 == .on }
        )

        let output = viewModel.transform(input)

        output.runtimeObjects.drive(isReorderable ? imageLoadedView.outlineView.rx.reorderableNodes : imageLoadedView.outlineView.rx.nodes) { (outlineView: NSOutlineView, tableColumn: NSTableColumn?, viewModel: SidebarRuntimeObjectCellViewModel) -> NSView? in
            let cellView = outlineView.box.makeView(ofClass: SidebarRuntimeObjectCellView.self) { .init(forOpenQuickly: false) }
            cellView.bind(to: viewModel)
            return cellView
        }
        .disposed(by: rx.disposeBag)

        output.errorText.drive(imageLoadErrorView.titleLabel.rx.stringValue).disposed(by: rx.disposeBag)

        output.notLoadedText.drive(imageNotLoadedView.titleLabel.rx.stringValue).disposed(by: rx.disposeBag)

        output.emptyText.drive(imageLoadedView.emptyLabel.rx.stringValue).disposed(by: rx.disposeBag)

        output.isEmpty.not().drive(imageLoadedView.emptyLabel.rx.isHidden).disposed(by: rx.disposeBag)

        output.isEmpty.drive(imageLoadedView.scrollView.rx.isHidden).disposed(by: rx.disposeBag)

        output.didBeginFiltering.emitOnNext { [weak self] in
            guard let self else { return }
            imageLoadedView.outlineView.beginFiltering()
        }
        .disposed(by: rx.disposeBag)

        output.didChangeFiltering.emitOnNext { [weak self] in
            guard let self else { return }
            imageLoadedView.outlineView.expandItem(nil, expandChildren: true)
        }
        .disposed(by: rx.disposeBag)

        output.didEndFiltering.emitOnNext { [weak self] in
            guard let self else { return }
            imageLoadedView.outlineView.endFiltering()
        }
        .disposed(by: rx.disposeBag)

        output.windowInitialTitles.driveOnNext { [weak self] in
            guard let self else { return }
            self.viewModel?.documentState.currentSubtitle = $0.subtitle
        }
        .disposed(by: rx.disposeBag)

        output.loadState.driveOnNextMainActor { [weak self] loadState in
            guard let self else { return }
            tabView.selectTabViewItem(withIdentifier: loadState.tabViewItemIdentifier)
        }
        .disposed(by: rx.disposeBag)

        outlineView.identifier = "com.JH.RuntimeViewer.\(Self.self).identifier.\(viewModel.documentState.runtimeEngine.source.description)"
        outlineView.autosaveName = "com.JH.RuntimeViewer.\(Self.self).autosaveName.\(viewModel.documentState.runtimeEngine.source.description)"
    }
}

extension SidebarRuntimeObjectViewController {
    final class ImageUnknownView: XiblessView {}

    final class ImageLoadedView: XiblessView {
        let (scrollView, outlineView): (ScrollView, StatefulOutlineView) = StatefulOutlineView.scrollableSingleColumnOutlineView()

        let emptyLabel = Label()

        override init(frame frameRect: NSRect) {
            super.init(frame: frameRect)

            hierarchy {
                scrollView
                emptyLabel
            }

            scrollView.snp.makeConstraints { make in
                make.edges.equalToSuperview()
            }

            emptyLabel.snp.makeConstraints { make in
                make.center.equalToSuperview()
                make.top.left.greaterThanOrEqualTo(16).priority(.high)
                make.bottom.right.lessThanOrEqualTo(-16).priority(.high)
            }

            emptyLabel.do {
                $0.alignment = .center
                $0.maximumNumberOfLines = 0
                $0.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)
            }

            scrollView.do {
                $0.isHiddenVisualEffectView = true
            }
        }
    }

    final class ImageLoadingView: XiblessView {
        let loadingIndicator: MaterialLoadingIndicator = .init(radius: 25, color: .controlAccentColor)

        override init(frame frameRect: CGRect) {
            super.init(frame: frameRect)

            hierarchy {
                loadingIndicator
            }

            loadingIndicator.snp.makeConstraints { make in
                make.center.equalToSuperview()
                make.size.equalTo(50)
            }

            loadingIndicator.startAnimating()
            loadingIndicator.lineWidth = 5
        }
    }

    final class ImageLoadableView: XiblessView {
        let titleLabel = Label()

        let loadImageButton = PushButton()

        lazy var contentView = VStackView(alignment: .vStackCenter, spacing: 10) {
            titleLabel
                .gravity(.center)
            loadImageButton
                .gravity(.center)
        }

        override init(frame frameRect: CGRect) {
            super.init(frame: frameRect)

            hierarchy {
                contentView
            }

            contentView.snp.makeConstraints { make in
                make.center.equalToSuperview()
                make.width.equalTo(200)
            }

            titleLabel.do {
                $0.isSelectable = true
                $0.alignment = .center
            }

            loadImageButton.do {
                $0.title = "Load now"
            }
        }
    }
}

extension RuntimeImageLoadState {
    fileprivate var tabViewItemIdentifier: String {
        switch self {
        case .notLoaded:
            return "notLoaded"
        case .loading:
            return "loading"
        case .loaded:
            return "loaded"
        case .loadError:
            return "loadError"
        case .unknown:
            return "unknown"
        }
    }
}

extension NSTabViewItem {
    fileprivate enum PlaceholderLoadStateError: Error {
        case main
    }

    fileprivate convenience init(view: NSView, loadState: RuntimeImageLoadState) {
        self.init(identifier: loadState.tabViewItemIdentifier)
        let vc = NSViewController()
        vc.view = view
        self.viewController = vc
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AvailableLibraries</key>
	<array>
		<dict>
			<key>LibraryIdentifier</key>
			<string>macos-arm64e-arm64-x86_64</string>
			<key>LibraryPath</key>
			<string>UXKit.framework</string>
			<key>SupportedArchitectures</key>
			<array>
				<string>arm64e</string>
				<string>arm64</string>
				<string>x86_64</string>
			</array>
			<key>SupportedPlatform</key>
			<string>macos</string>
		</dict>
	</array>
	<key>CFBundlePackageType</key>
	<string>XFWK</string>
	<key>XCFrameworkFormatVersion</key>
	<string>1.0</string>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/UXKit.tbd`:

```tbd
--- !tapi-tbd
tbd-version:  
```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXBar.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXBarCommon.h>
#import <UXKit/UXKitDefines.h>
#import <UXKit/UXView.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXBar : UXView <NSAccessibilityGroup, UXBarPositioning>
@end

NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXBarButtonItem.h`:

```h
#import <UXKit/UXBarItem.h>
#import <UXKit/UXKitAppearance.h>
#import <UXKit/UXKitDefines.h>

@class UXViewController, UXView;

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

typedef NS_ENUM(NSInteger, UXBarButtonItemStyle) {
    UXBarButtonItemStylePlain,
    UXBarButtonItemStyleBordered,
    UXBarButtonItemStyleDone,
};

typedef NS_ENUM(NSInteger, UXBarButtonSystemItem) {
    UXBarButtonSystemItemNone = -1,
    UXBarButtonSystemItemDone,
    UXBarButtonSystemItemCancel,
    UXBarButtonSystemItemEdit,
    UXBarButtonSystemItemSave,
    UXBarButtonSystemItemAdd,
    UXBarButtonSystemItemFlexibleSpace,
    UXBarButtonSystemItemFixedSpace,
    UXBarButtonSystemItemCompose,
    UXBarButtonSystemItemReply,
    UXBarButtonSystemItemAction,
    UXBarButtonSystemItemOrganize,
    UXBarButtonSystemItemBookmarks,
    UXBarButtonSystemItemSearch,
    UXBarButtonSystemItemRefresh,
    UXBarButtonSystemItemStop,
    UXBarButtonSystemItemCamera,
    UXBarButtonSystemItemTrash,
    UXBarButtonSystemItemPlay,
    UXBarButtonSystemItemPause,
    UXBarButtonSystemItemRewind,
    UXBarButtonSystemItemFastForward,
    UXBarButtonSystemItemUndo,
    UXBarButtonSystemItemRedo,
    UXBarButtonSystemItemPageCurl,
    UXBarButtonSystemItemClose
};

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXBarButtonItem : UXBarItem <UXKitAppearance>

@property (nonatomic, copy, nullable) NSString *label;
@property (nonatomic, copy, nullable) NSString *identifier;
@property (nonatomic, strong, nullable) __kindof NSView *customView;
@property (nonatomic) CGFloat width;
@property (nonatomic) UXBarButtonItemStyle style;
@property (nonatomic) BOOL ignoresMultiClick;
@property (nonatomic) NSControlStateValue buttonState;
@property (nonatomic) NSEventModifierFlags keyEquivalentModifierMask;
@property (nonatomic, strong, nullable) NSString *keyEquivalent;
@property (nonatomic, strong, nullable) NSString *toolTip;
@property (nonatomic, weak, nullable) id target;
@property (nonatomic, nullable) SEL action;
- (instancetype)init NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithStyle:(UXBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action NS_DESIGNATED_INITIALIZER;
- (instancetype)initWithContentViewController:(UXViewController *)contentViewController;
- (instancetype)initWithCustomView:(NSView *)customView;
- (instancetype)initWithBarButtonSystemItem:(UXBarButtonSystemItem)systemItem target:(nullable id)target action:(nullable SEL)action;
- (instancetype)initWithBarButtonSystemItem:(UXBarButtonSystemItem)systemItem width:(CGFloat)width target:(nullable id)target action:(nullable SEL)action;
- (instancetype)initWithTitle:(NSString *)title style:(UXBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action;
- (instancetype)initWithImage:(NSImage *)image style:(UXBarButtonItemStyle)style target:(nullable id)target action:(nullable SEL)action;

@end


NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXBarCommon.h`:

```h
#import <Foundation/Foundation.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

typedef NS_ENUM(NSInteger, UXBarMetrics) {
    UXBarMetricsDefault,
    UXBarMetricsCompact,
    UXBarMetricsDefaultPrompt = 101, // Applicable only in bars with the prompt property, such as UXNavigationBar and UXSearchBar
    UXBarMetricsCompactPrompt,
};

typedef NS_ENUM(NSInteger, UXBarPosition) {
    UXBarPositionAny         = 0,
    UXBarPositionBottom      = 1, // The bar is at the bottom of its local context, and directional decoration draws accordingly (e.g., shadow above the bar).
    UXBarPositionTop         = 2, // The bar is at the top of its local context, and directional decoration draws accordingly (e.g., shadow below the bar)
    UXBarPositionTopAttached = 3, // The bar is at the top of the screen (as well as its local context), and its background extends upwardâ€”currently only enough for the status bar.
};

#define UXToolbarPosition       UXBarPosition
#define UXToolbarPositionAny    UXBarPositionAny
#define UXToolbarPositionBottom UXBarPositionBottom
#define UXToolbarPositionTop    UXBarPositionTop

NS_SWIFT_UI_ACTOR
@protocol UXBarPositioning <NSObject> // UXNavigationBar, UXToolbar, and UXSearchBar conform to this
@property (nonatomic, readonly) UXBarPosition barPosition;
@end

NS_SWIFT_UI_ACTOR
@protocol UXBarPositioningDelegate <NSObject> // UXNavigationBarDelegate, UXToolbarDelegate, and UXSearchBarDelegate all extend from this
@optional
/* Implement this method on your manual bar delegate when not managed by a UXKit controller.
   UXNavigationBar and UXSearchBar default to UXBarPositionTop, UXToolbar defaults to UXBarPositionBottom.
   This message will be sent when the bar moves to a window.
 */
- (UXBarPosition)positionForBar:(id <UXBarPositioning>)bar;
@end

NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXBarItem.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXKitDefines.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

@class NSImage, NSString;

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXBarItem : NSObject

@property (nonatomic) NSInteger tag;
@property (nonatomic, getter = isEnabled) BOOL enabled;
@property (nonatomic, strong, nullable) NSImage *image;
@property (nonatomic, strong, nullable) NSString *title;
@property (nonatomic, copy, nullable) NSString *accessibilityLabel;
@property (nonatomic, copy, nullable) NSString *accessibilityIdentifier;

- (instancetype)init NS_DESIGNATED_INITIALIZER;

@end



NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXBase.h`:

```h
#ifndef UXBase_h
#define UXBase_h

typedef void (^UXCompletionHandler)(void);
typedef void (^UXParameterCompletionHandler)(BOOL);

#endif /* UXBase_h */

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXImageView.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXKitDefines.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)


UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXImageView : UXView <NSAccessibilityImage>

@property (nonatomic, getter = isHighlighted) BOOL highlighted;
@property (nonatomic, strong, nullable) NSImage *image;
@property (nonatomic, strong, nullable) NSImage *highlightedImage;

@property (nonatomic) BOOL allowsVibrancy;
@property (nonatomic, copy, nullable) NSString *accessibilityLabel;

- (instancetype)initWithImage:(nullable NSImage *)image highlightedImage:(nullable NSImage *)highlightedImage;
- (instancetype)initWithImage:(nullable NSImage *)image;
- (void)sizeToFit;

@end

NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXKit.h`:

```h
#import <Foundation/Foundation.h>

//! Project version number for OpenUXKit.
FOUNDATION_EXPORT CGFloat OpenUXKitVersionNumber;

//! Project version string for OpenUXKit.
FOUNDATION_EXPORT const unsigned char OpenUXKitVersionString[];

// Common
#import <UXKit/UXBase.h>
#import <UXKit/UXKitDefines.h>

// Components
#import <UXKit/UXView.h>
#import <UXKit/UXViewController.h>
#import <UXKit/UXBar.h>
#import <UXKit/UXToolbar.h>
#import <UXKit/UXBarItem.h>
#import <UXKit/UXBarButtonItem.h>
#import <UXKit/UXNavigationBar.h>
#import <UXKit/UXNavigationController.h>
#import <UXKit/UXNavigationItem.h>
#import <UXKit/UXLabel.h>
#import <UXKit/UXImageView.h>

// Protocols
#import <UXKit/UXKitAppearance.h>
#import <UXKit/UXViewControllerTransitionCoordinator.h>
#import <UXKit/UXViewControllerTransitioning.h>
#import <UXKit/UXBarCommon.h>
#import <UXKit/UXLayoutSupport.h>


// Categories
//#import <OpenUXKit/NSImage+UXKit.h>
//#import <OpenUXKit/NSResponder+UXKit.h>
//#import <OpenUXKit/NSView+UXKit.h>
//#import <OpenUXKit/NSViewController+UXViewController.h>
//#import <OpenUXKit/NSWindow+UXKit.h>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXKitAppearance.h`:

```h
#import <AppKit/AppKit.h>

@class NSColor;

typedef NS_ENUM(NSInteger, UXTintAdjustmentMode) {
    UXTintAdjustmentModeAutomatic,
    UXTintAdjustmentModeNormal,
    UXTintAdjustmentModeDimmed,
};

@protocol UXKitAppearance <NSObject>
@property (nonatomic) UXTintAdjustmentMode tintAdjustmentMode;
@property (nonatomic, strong, nullable) NSColor *tintColor;
- (void)tintColorDidChange;
@end

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXKitDefines.h`:

```h
#ifndef _UXKITDEFINES_H
#define _UXKITDEFINES_H

#import <AvailabilityMacros.h>
#import <Foundation/NSObjCRuntime.h>

#ifdef __cplusplus
#define UXKIT_EXTERN        extern "C" __attribute__((visibility ("default")))
#define UXKIT_PRIVATE_EXTERN    __attribute__((visibility("hidden"))) extern "C"
#define UXKIT_PRIVATE          __attribute__((visibility("hidden")))
#else
#define UXKIT_EXTERN        extern __attribute__((visibility ("default")))
#define UXKIT_PRIVATE_EXTERN    __attribute__((visibility("hidden"))) extern
#define UXKIT_PRIVATE          __attribute__((visibility("hidden")))
#endif

#ifndef NS_SWIFT_BRIDGED_TYPEDEF
#if __has_attribute(swift_bridged_typedef)
#define NS_SWIFT_BRIDGED_TYPEDEF __attribute__((swift_bridged_typedef))
#else
#define NS_SWIFT_BRIDGED_TYPEDEF
#endif
#endif

#endif /* _UXKITDEFINES_H */

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXLabel.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXView.h>
#import <UXKit/UXKitDefines.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXLabel : UXView <NSAccessibilityStaticText>

@property (nonatomic, copy) NSString *text;
@property (nonatomic, copy) NSAttributedString *attributedText;
@property (nonatomic, strong, nullable) NSFont *font;
@property (nonatomic, strong, nullable) NSColor *textColor;
@property (nonatomic, strong, nullable) NSColor *shadowColor;
@property (nonatomic, strong, nullable) NSColor *highlightedTextColor;
@property (nonatomic) NSInteger numberOfLines;
@property (nonatomic) CGSize shadowOffset;
@property (nonatomic) BOOL selectable;
@property (nonatomic) BOOL centerVertically;
@property (nonatomic, getter = isHighlighted) BOOL highlighted;
@property (nonatomic) CGFloat preferredMaxLayoutWidth;
@property (nonatomic) NSInteger textAlignment;
@property (nonatomic) NSUInteger lineBreakMode;

- (CGRect)textRectForBounds:(CGRect)bounds limitedToNumberOfLines:(NSInteger)numberOfLines;
- (__kindof NSCell *)textFieldCell;
- (CGSize)sizeThatFits:(CGSize)size;
- (void)sizeToFit;
- (CGFloat)lastBaselineOffsetFromBottom;
- (CGFloat)firstBaselineOffsetFromTop;
- (NSEdgeInsets)alignmentRectInsets;

@end

NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXLayoutSupport.h`:

```h
#import <AppKit/AppKit.h>

@protocol UXLayoutSupport <NSObject>

@property (readonly) NSLayoutDimension *heightAnchor;
@property (readonly) NSLayoutYAxisAnchor *bottomAnchor;
@property (readonly) NSLayoutYAxisAnchor *topAnchor;
@property (nonatomic) CGFloat length;

@end

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXNavigationBar.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXBar.h>
#import <UXKit/UXNavigationController.h>
#import <UXKit/UXKitDefines.h>

@class UXNavigationItem, _UXNavigationItemContainerView;
NS_SWIFT_UI_ACTOR
@protocol UXNavigationBarDelegate <NSObject>
@end

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXNavigationBar : UXBar

@property (nonatomic, getter = isTranslucent) BOOL translucent;
@property (nonatomic, copy, nullable) NSArray<UXNavigationItem *> *items;
@property (nonatomic, weak, nullable) id <UXNavigationBarDelegate> delegate;
@property (nonatomic, readonly, nullable) UXNavigationItem *backItem;
@property (nonatomic, readonly, nullable) UXNavigationItem *topItem;

- (void)pushNavigationItem:(UXNavigationItem *)navigationItem animated:(BOOL)animated NS_SWIFT_NAME(pushItem(_:animated:));
- (nullable UXNavigationItem *)popNavigationItemAnimated:(BOOL)animated NS_SWIFT_NAME(popItem(animated:));

@end

NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXNavigationController.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXKitDefines.h>
#import <UXKit/UXToolbar.h>
#import <UXKit/UXViewController.h>
#import <UXKit/UXKitDefines.h>

@class UXNavigationBar, UXToolbar, UXView, UXViewController, UXBarButtonItem;
@protocol UXViewControllerAnimatedTransitioning, UXViewControllerInteractiveTransitioning, UXNavigationControllerDelegate;

typedef NS_ENUM(NSInteger, UXNavigationControllerOperation) {
    UXNavigationControllerOperationNone,
    UXNavigationControllerOperationPush,
    UXNavigationControllerOperationPop,
} NS_SWIFT_NAME(UXNavigationController.Operation);

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXNavigationController : UXViewController <UXToolbarDelegate, NSMenuDelegate>

@property (nonatomic, weak, nullable) id <UXNavigationControllerDelegate> delegate;
@property (nonatomic, readonly, null_resettable) UXToolbar *toolbar;
@property (nonatomic, getter = isToolbarHidden) BOOL toolbarHidden;
@property (nonatomic, readonly, nullable) UXToolbar *subtoolbar;
@property (nonatomic, getter = isSubtoolbarHidden) BOOL subtoolbarHidden;
@property (nonatomic, readonly, null_resettable) UXToolbar *accessoryBar;
@property (nonatomic, readonly, getter = isAccessoryBarHidden) BOOL accessoryBarHidden;
@property (nonatomic, readonly) UXNavigationBar *navigationBar;
@property (nonatomic, getter = isNavigationBarHidden) BOOL navigationBarHidden;
@property (nonatomic, getter = isNavigationBarDetached) BOOL navigationBarDetached;
@property (nonatomic, copy) NSArray<UXViewController *> *viewControllers;
@property (nonatomic, readonly, nullable) UXViewController *visibleViewController;
@property (nonatomic, readonly, nullable) UXViewController *topViewController;
@property (nonatomic, readonly, nullable) NSGestureRecognizer *interactivePopGestureRecognizer;

- (instancetype)initWithNavigationBarClass:(nullable Class)navigationBarClass toolbarClass:(nullable Class)toolbarClass;
- (instancetype)initWithRootViewController:(UXViewController *)rootViewController;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_UNAVAILABLE;
- (nullable UXViewController *)popViewControllerAnimated:(BOOL)animated;
- (nullable NSArray<__kindof UXViewController *> *)popToRootViewControllerAnimated:(BOOL)animated;
- (nullable NSArray<__kindof UXViewController *> *)popToViewController:(UXViewController *)viewController animated:(BOOL)animated NS_SWIFT_NAME(popToViewController(_:animated:));
- (void)pushViewController:(UXViewController *)viewController animated:(BOOL)animated;
- (void)setViewControllers:(NSArray<UXViewController *> *)viewControllers animated:(BOOL)animated;
- (void)detachNavigationBar;
- (void)setToolbarHidden:(BOOL)hidden animated:(BOOL)animated;
- (void)setNavigationBarHidden:(BOOL)hidden animated:(BOOL)animated;

@end
NS_SWIFT_UI_ACTOR
@protocol UXNavigationControllerDelegate <NSObject>
@optional
- (nullable id<UXViewControllerAnimatedTransitioning>)navigationController:(UXNavigationController *)navigationController animationControllerForOperation:(UXNavigationControllerOperation)operation fromViewController:(UXViewController *)fromViewController toViewController:(UXViewController *)toViewController;
- (nullable id<UXViewControllerInteractiveTransitioning>)navigationController:(UXNavigationController *)navigationController interactionControllerForAnimationController:(id<UXViewControllerAnimatedTransitioning>)animationController;
- (void)navigationController:(UXNavigationController *)navigationController didShowViewController:(UXViewController *)viewController;
- (BOOL)navigationController:(UXNavigationController *)navigationController shouldBeginInteractivePopFromViewController:(UXViewController *)fromViewController toViewController:(UXViewController *)toViewController;
- (BOOL)navigationController:(UXNavigationController *)navigationController shouldPopFromViewController:(UXViewController *)fromViewController toViewController:(UXViewController *)toViewController;
- (void)navigationController:(UXNavigationController *)navigationController willShowViewController:(UXViewController *)viewController;

@end

NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXNavigationItem.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXKitDefines.h>

@class UXBarButtonItem;

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXNavigationItem : NSObject <NSUserInterfaceItemIdentification>

@property (nonatomic, strong, nullable) NSString *title;
@property (nonatomic, strong, nullable) NSView *titleView;
@property (nonatomic, copy, nullable) NSString *prompt;
@property (nonatomic, strong, nullable) UXBarButtonItem *backBarButtonItem;
@property (nonatomic) BOOL hidesBackButton;
@property (nonatomic, strong, nullable) UXBarButtonItem *leftBarButtonItem;
@property (nonatomic, strong, nullable) UXBarButtonItem *rightBarButtonItem;
@property (nonatomic, strong, nullable) NSArray<UXBarButtonItem *> *leftBarButtonItems;
@property (nonatomic, strong, nullable) NSArray<UXBarButtonItem *> *rightBarButtonItems;
@property (nonatomic, strong, nullable) NSArray<UXBarButtonItem *> *leadingBarButtonItems;
@property (nonatomic, strong, nullable) NSArray<UXBarButtonItem *> *trailingBarButtonItems;

- (instancetype)initWithTitle:(NSString *)title NS_DESIGNATED_INITIALIZER;
- (void)setLeadingBarButtonItems:(nullable NSArray<UXBarButtonItem *> *)items animated:(BOOL)animated NS_SWIFT_NAME(setLeadingBarButtonItems(_:animated:));
- (void)setTrailingBarButtonItems:(nullable NSArray<UXBarButtonItem *> *)items animated:(BOOL)animated NS_SWIFT_NAME(setTrailingBarButtonItems(_:animated:));
- (void)setLeftBarButtonItem:(nullable UXBarButtonItem *)item animated:(BOOL)animated NS_SWIFT_NAME(setLeftBarButtonItem(_:animated:));
- (void)setLeftBarButtonItems:(nullable NSArray<UXBarButtonItem *> *)items animated:(BOOL)animated NS_SWIFT_NAME(setLeftBarButtonItems(_:animated:));
- (void)setRightBarButtonItem:(nullable UXBarButtonItem *)item animated:(BOOL)animated NS_SWIFT_NAME(setRightBarButtonItem(_:animated:));
- (void)setRightBarButtonItems:(nullable NSArray<UXBarButtonItem *> *)items animated:(BOOL)animated NS_SWIFT_NAME(setRightBarButtonItems(_:animated:));

@end


NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXToolbar.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXBar.h>
#import <UXKit/UXBarButtonItem.h>
#import <UXKit/UXKitDefines.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

@class UXToolbar;
NS_SWIFT_UI_ACTOR
@protocol UXToolbarDelegate <UXBarPositioningDelegate>

@optional
- (nullable NSResponder *)nextResponderForToolbar:(UXToolbar *)toolbar;

@end

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXToolbar : UXBar

@property (nonatomic, copy, nullable) NSArray<UXBarButtonItem *> *items;
@property (nonatomic, weak, nullable) id <UXToolbarDelegate> delegate;

- (void)setItems:(nullable NSArray<UXBarButtonItem *> *)items animated:(BOOL)animated;

@end


NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXView.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXKitDefines.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

typedef NS_ENUM(NSInteger, UXUserInterfaceLayoutDirection) {
    UXUserInterfaceLayoutDirectionLeftToRight,
    UXUserInterfaceLayoutDirectionRightToLeft,
};

typedef NS_ENUM(NSInteger, UXViewAnimationCurve) {
    UXViewAnimationCurveEaseInOut,         // slow at beginning and end
    UXViewAnimationCurveEaseIn,            // slow at beginning
    UXViewAnimationCurveEaseOut,           // slow at end
    UXViewAnimationCurveLinear,
} NS_SWIFT_NAME(UXView.AnimationCurve);

typedef NS_OPTIONS(NSUInteger, UXViewAnimationOptions) {
    UXViewAnimationOptionLayoutSubviews                  = 1 <<  0,
    UXViewAnimationOptionAllowUserInteraction            = 1 <<  1,// turn on user interaction while animating
    UXViewAnimationOptionBeginFromCurrentState           = 1 <<  2,// start all views from current value, not initial value
    UXViewAnimationOptionRepeat                          = 1 <<  3,// repeat animation indefinitely
    UXViewAnimationOptionAutoreverse                     = 1 <<  4,// if repeat, run animation back and forth
    UXViewAnimationOptionOverrideInheritedDuration       = 1 <<  5,// ignore nested duration
    UXViewAnimationOptionOverrideInheritedCurve          = 1 <<  6,// ignore nested curve
    UXViewAnimationOptionAllowAnimatedContent            = 1 <<  7,// animate contents (applies to transitions only)
    UXViewAnimationOptionShowHideTransitionViews         = 1 <<  8,// flip to/from hidden state instead of adding/removing
    UXViewAnimationOptionOverrideInheritedOptions        = 1 <<  9,// do not inherit any options or animation type

    UXViewAnimationOptionCurveEaseInOut                  = 0 << 16, // default
    UXViewAnimationOptionCurveEaseIn                     = 1 << 16,
    UXViewAnimationOptionCurveEaseOut                    = 2 << 16,
    UXViewAnimationOptionCurveLinear                     = 3 << 16,

    UXViewAnimationOptionTransitionNone                  = 0 << 20, // default
    UXViewAnimationOptionTransitionFlipFromLeft          = 1 << 20,
    UXViewAnimationOptionTransitionFlipFromRight         = 2 << 20,
    UXViewAnimationOptionTransitionCurlUp                = 3 << 20,
    UXViewAnimationOptionTransitionCurlDown              = 4 << 20,
    UXViewAnimationOptionTransitionCrossDissolve         = 5 << 20,
    UXViewAnimationOptionTransitionFlipFromTop           = 6 << 20,
    UXViewAnimationOptionTransitionFlipFromBottom        = 7 << 20,

    UXViewAnimationOptionPreferredFramesPerSecondDefault = 0 << 24,
    UXViewAnimationOptionPreferredFramesPerSecond60      = 3 << 24,
    UXViewAnimationOptionPreferredFramesPerSecond30      = 7 << 24,
} NS_SWIFT_NAME(UXView.AnimationOptions);

typedef NS_ENUM(NSInteger, UXViewContentMode) {
    UXViewContentModeScaleToFill,
    UXViewContentModeScaleAspectFit,      // contents scaled to fit with fixed aspect. remainder is transparent
    UXViewContentModeScaleAspectFill,     // contents scaled to fill with fixed aspect. some portion of content may be clipped.
    UXViewContentModeRedraw,              // redraw on bounds change (calls -setNeedsDisplay)
    UXViewContentModeCenter,              // contents remain same size. positioned adjusted.
    UXViewContentModeTop,
    UXViewContentModeBottom,
    UXViewContentModeLeft,
    UXViewContentModeRight,
    UXViewContentModeTopLeft,
    UXViewContentModeTopRight,
    UXViewContentModeBottomLeft,
    UXViewContentModeBottomRight,
} NS_SWIFT_NAME(UXView.ContentMode);

@class UXViewController, UXImageView;

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXView : NSView
@property (nonatomic, class, readonly) Class layerClass;
@property (nonatomic) BOOL userInteractionEnabled;
@property (nonatomic, getter = isExclusiveTouch) BOOL exclusiveTouch;
@property (nonatomic, strong, nullable) NSColor *borderColor;
@property (nonatomic) CGAffineTransform transform;
@property (nonatomic, readonly) CGPoint center;
@property (nonatomic, readonly) NSUserInterfaceLayoutDirection effectiveUserInterfaceLayoutDirection;
@property (nonatomic) UXViewContentMode contentMode;
@property (nonatomic) BOOL blurEnabled;
@property (nonatomic) NSVisualEffectMaterial blurMaterial;
@property (nonatomic, strong, nullable) NSColor *backgroundColor;

+ (void)performWithoutAnimation:(void (NS_NOESCAPE ^)(void))actionsWithoutAnimation;
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UXViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^__nullable)(BOOL finished))completion NS_SWIFT_DISABLE_ASYNC;
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations NS_SWIFT_DISABLE_ASYNC;
+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (^)(void))animations completion:(void (^__nullable)(BOOL finished))completion NS_SWIFT_DISABLE_ASYNC;
+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay options:(UXViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^__nullable)(BOOL finished))completion NS_SWIFT_DISABLE_ASYNC;

- (void)updateConstraintsForSubtreeIfNeeded;
- (CGSize)sizeThatFits:(CGSize)size;
- (void)insertSubview:(NSView *)insertSubview aboveSubview:(NSView *)aboveSubview;
- (void)insertSubview:(NSView *)insertSubview belowSubview:(NSView *)belowSubview;
- (void)bringSubviewToFront:(NSView *)subview NS_SWIFT_NAME(bringSubviewToFront(_:));
- (void)sendSubviewToBack:(NSView *)subview NS_SWIFT_NAME(sendSubviewToBack(_:));
- (nullable UXImageView *)snapshotViewFromRect:(CGRect)rect;
- (nullable UXImageView *)snapshotView;
- (nullable NSImage *)snapshotForRect:(CGRect)rect;
@end

NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXViewController.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXBarCommon.h>
#import <UXKit/UXKitDefines.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

typedef NS_OPTIONS(NSUInteger, UXRectEdge) {
    UXRectEdgeNone   = 0,
    UXRectEdgeTop    = 1 << 0,
    UXRectEdgeLeft   = 1 << 1,
    UXRectEdgeBottom = 1 << 2,
    UXRectEdgeRight  = 1 << 3,
    UXRectEdgeAll    = UXRectEdgeTop | UXRectEdgeLeft | UXRectEdgeBottom | UXRectEdgeRight
};

typedef NS_ENUM(NSInteger, UXModalPresentationStyle) {
    UXModalPresentationFullScreen = 0,
    UXModalPresentationPageSheet,
    UXModalPresentationFormSheet,
    UXModalPresentationCurrentContext,
    UXModalPresentationCustom,
    UXModalPresentationOverFullScreen,
    UXModalPresentationOverCurrentContext,
    UXModalPresentationPopover,
    UXModalPresentationBlurOverFullScreen,
    UXModalPresentationNone      = -1,
    UXModalPresentationAutomatic = -2,
};

@class UXNavigationController, UXNavigationItem, UXSourceController, UXTabBarController, UXTabBarItem, UXView, UXWindowController, UXTabBarItemSegment, UXPopoverController, UXBarButtonItem;
@protocol UXLayoutSupport, UXNavigationDestination, UXViewControllerTransitionCoordinator;

UXKIT_EXTERN NS_SWIFT_UI_ACTOR
@interface UXViewController : NSViewController
@property (nonatomic, class, readonly) Class viewClass;
@property (nonatomic) BOOL automaticallyAdjustsScrollViewInsets;
@property (nonatomic) UXModalPresentationStyle modalPresentationStyle;
@property (nonatomic, getter = isEditing) BOOL editing;
@property (nonatomic, readonly, nullable) UXViewController *ux_presentingViewController;
@property (nonatomic, readonly, nullable) UXViewController *ux_parentViewController;
@property (nonatomic, readonly, nullable) UXViewController *presentedViewController;
@property (nonatomic, readonly, nullable) id<UXViewControllerTransitionCoordinator> transitionCoordinator;
@property (nonatomic, readonly) UXView *uxView;
@property (nonatomic, readonly) id<UXLayoutSupport> topLayoutGuide;
@property (nonatomic, readonly) id<UXLayoutSupport> bottomLayoutGuide;
@property (nonatomic, strong, readonly, nullable) NSView *viewIfLoaded;

- (void)invalidateIntrinsicLayoutInsets;
- (NSEdgeInsets)intrinsicLayoutInsets;

- (void)setEditing:(BOOL)editing animated:(BOOL)animated;
- (void)dismissViewControllerAnimated:(BOOL)animated completion:(void (^ __nullable)(void))completion NS_SWIFT_DISABLE_ASYNC;
- (void)presentViewController:(UXViewController *)viewController animated:(BOOL)animated completion:(void (^ __nullable)(void))completion NS_SWIFT_DISABLE_ASYNC;
- (void)didMoveToParentViewController:(nullable UXViewController *)parent NS_SWIFT_NAME(didMove(toParent:));
- (void)willMoveToParentViewController:(nullable UXViewController *)parent NS_SWIFT_NAME(willMove(toParent:));
- (void)removeChildViewControllerAtIndex:(NSInteger)index;

- (void)viewDidLiveResize;
- (void)viewWillLiveResize;
- (void)viewDidLayoutSubviews;
- (void)viewWillLayoutSubviews;
@end

@interface UXViewController (UXNavigationControllerItem)
@property (nonatomic) BOOL hidesBottomBarWhenPushed;
@property (nonatomic, strong, nullable) UXViewController *toolbarViewController;
@property (nonatomic, strong, nullable) NSArray<__kindof UXBarButtonItem *> *toolbarItems;
@property (nonatomic, strong, nullable) NSArray<__kindof UXBarButtonItem *> *subtoolbarItems;
@property (nonatomic, strong, readonly, nullable) UXNavigationItem *navigationItem;
@property (nonatomic, strong, readonly, nullable) UXNavigationController *navigationController;
@property (nonatomic, strong, nullable) UXViewController *accessoryViewController;
@property (nonatomic, strong, nullable) NSArray<__kindof UXBarButtonItem *> *accessoryBarItems;
@property (nonatomic, readonly) UXBarPosition preferredToolbarPosition;
- (void)setToolbarItems:(nullable NSArray<UXBarButtonItem *> *)toolbarItems animated:(BOOL)animated;
@end

@interface UXViewController (Compatibility)
- (void)viewDidDisappear:(BOOL)animated;
- (void)viewWillDisappear:(BOOL)animated;
- (void)viewDidAppear:(BOOL)animated;
- (void)viewWillAppear:(BOOL)animated;
@property (nonatomic, readonly) NSInteger interfaceOrientation;
@end

@interface UXViewController (UXPopoverController)
@property (nonatomic, readonly, nullable) UXPopoverController *popoverController;
@end



NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXViewControllerTransitionCoordinator.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXViewController.h>

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

@class UXView;

typedef NSString * UXTransitionContextViewControllerKey NS_TYPED_ENUM;
typedef NSString * UXTransitionContextViewKey NS_TYPED_ENUM;

@protocol UXViewControllerTransitionCoordinatorContext <NSObject>
// The view in which the animated transition is taking place.
@property (nonatomic, readonly) UXView *containerView;
- (nullable __kindof UXViewController *)viewControllerForKey:(UXTransitionContextViewControllerKey)key;
// These three methods are potentially meaningful for interactive transitions that are
// completing. It reports the percent complete of the transition when it moves
// to the non-interactive completion phase of the transition.
@property (nonatomic, readonly) CGFloat percentComplete;
@property (nonatomic, readonly) CGFloat completionVelocity;
@property (nonatomic, readonly) NSInteger completionCurve;
// The full expected duration of the transition if it is run non-interactively.
@property (nonatomic, readonly) NSTimeInterval transitionDuration;
/// initiallyInteractive indicates whether the transition was initiated as an interactive transition.
/// It never changes during the course of a transition.
/// It can only be YES if isAnimated is YES.
///If it is NO, then isInteractive can only be YES if isInterruptible is YES
@property (nonatomic, readonly) BOOL initiallyInteractive;
// A modal presentation style whose transition is being customized or UIModalPresentationNone if this is not a modal presentation
// or dismissal.
@property (nonatomic, readonly) NSInteger presentationStyle;
// Most of the time isAnimated will be YES. For custom transitions that use the
// new UIModalPresentationCustom presentation type we invoke the
// animateTransition: even though the transition is not animated. (This allows
// the custom transition to add or remove subviews to the container view.)
@property (nonatomic, readonly, getter = isAnimated) BOOL animated;
// Interactive transitions have non-interactive segments. For example, they all complete non-interactively. Some interactive transitions may have
// intermediate segments that are not interactive.
@property (nonatomic, readonly, getter = isInteractive) BOOL interactive;

// isCancelled is usually NO. It is only set to YES for an interactive transition that was cancelled.
@property (nonatomic, readonly, getter = isCancelled) BOOL cancelled;
@end


@protocol UXViewControllerTransitionCoordinator <UXViewControllerTransitionCoordinatorContext>
- (BOOL)animateAlongsideTransitionInView:(nullable UXView *)view
                               animation:(void (^__nullable)(id <UXViewControllerTransitionCoordinatorContext>context))animation
                              completion:(void (^__nullable)(id <UXViewControllerTransitionCoordinatorContext>context))completion;
- (BOOL)animateAlongsideTransition:(void (^__nullable)(id <UXViewControllerTransitionCoordinatorContext>context))animation
                        completion:(void (^__nullable)(id <UXViewControllerTransitionCoordinatorContext>context))completion;
- (void)notifyWhenInteractionEndsUsingBlock:(void (^)(id <UXViewControllerTransitionCoordinatorContext>context))handler;
@end





NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Headers/UXViewControllerTransitioning.h`:

```h
#import <AppKit/AppKit.h>
#import <UXKit/UXBase.h>
#import <UXKit/UXView.h>
#import <UXKit/UXKitDefines.h>
#import <UXKit/UXViewController.h>
#import <UXKit/UXViewControllerTransitionCoordinator.h>

@class UXView, UXViewController;

NS_HEADER_AUDIT_BEGIN(nullability, sendability)

UXKIT_EXTERN UXTransitionContextViewControllerKey const UXTransitionContextFromViewControllerKey NS_SWIFT_NAME(from);
UXKIT_EXTERN UXTransitionContextViewControllerKey const UXTransitionContextToViewControllerKey NS_SWIFT_NAME(to);

UXKIT_EXTERN UXTransitionContextViewKey const UXTransitionContextFromViewKey NS_SWIFT_NAME(from);
UXKIT_EXTERN UXTransitionContextViewKey const UXTransitionContextToViewKey NS_SWIFT_NAME(to);

@protocol UXViewControllerContextTransitioning <NSObject>
// The frame's are set to CGRectZero when they are not known or
// otherwise undefined.  For example the finalFrame of the
// fromViewController will be CGRectZero if and only if the fromView will be
// removed from the window at the end of the transition. On the other
// hand, if the finalFrame is not CGRectZero then it must be respected
// at the end of the transition.
- (CGRect)finalFrameForViewController:(UXViewController *)viewController;
- (CGRect)initialFrameForViewController:(UXViewController *)viewController;
// Currently only two keys are defined by the
// system - UITransitionContextToViewControllerKey, and
// UITransitionContextFromViewControllerKey.
// Animators should not directly manipulate a view controller's views and should
// use viewForKey: to get views instead.
- (nullable __kindof UXViewController *)viewControllerForKey:(NSString *)key;
// This must be called whenever a transition completes (or is cancelled.)
// Typically this is called by the object conforming to the
// UIViewControllerAnimatedTransitioning protocol that was vended by the transitioning
// delegate.  For purely interactive transitions it should be called by the
// interaction controller. This method effectively updates internal view
// controller state at the end of the transition.
- (void)completeTransition:(BOOL)didComplete;
// An interaction controller that conforms to the
// UIViewControllerInteractiveTransitioning protocol (which is vended by a
// container view controller's delegate or, in the case of a presentation, the
// transitioningDelegate) should call these methods as the interactive
// transition is scrubbed and then either cancelled or completed. Note that if
// the animator is interruptible, then calling finishInteractiveTransition: and
// cancelInteractiveTransition: are indications that if the transition is not
// interrupted again it will finish naturally or be cancelled.

- (void)updateInteractiveTransition:(CGFloat)percentComplete;
- (void)finishInteractiveTransition;
- (void)cancelInteractiveTransition;

@property (nonatomic, readonly) UXModalPresentationStyle presentationStyle;

// Most of the time this is YES. For custom transitions that use the new UIModalPresentationCustom
// presentation type we will invoke the animateTransition: even though the transition should not be
// animated. This allows the custom transition to add or remove subviews to the container view.
@property (nonatomic, readonly, getter = isAnimated) BOOL animated;

// The next two values can change if the animating transition is interruptible.
@property (nonatomic, readonly, getter = isInteractive) BOOL interactive; // This indicates whether the transition is currently interactive.
@property (nonatomic, readonly) BOOL transitionWasCancelled;

// The view in which the animated transition should take place.
@property (nonatomic, readonly) UXView *containerView;

@optional
@property (nonatomic, copy, nullable) UXCompletionHandler arbitraryTransitionCompletionHandler;
@end

@protocol UXViewControllerAnimatedTransitioning <NSObject>
// This method can only be a no-op if the transition is interactive and not a percentDriven interactive transition.
- (void)animateTransition:(nullable id <UXViewControllerContextTransitioning>)transitionContext;
// This is used for percent driven interactive transitions, as well as for
// container controllers that have companion animations that might need to
// synchronize with the main animation.
- (CGFloat)transitionDuration:(id <UXViewControllerContextTransitioning>)transitionContext;

@optional
- (void)animationEnded:(BOOL)transitionCompleted;
@end

@protocol UXViewControllerInteractiveTransitioning <NSObject>
- (void)startInteractiveTransition:(id <UXViewControllerContextTransitioning>)transitionContext;

@optional
@property (nonatomic, readonly) CGFloat completionSpeed;
@property (nonatomic, readonly) UXViewAnimationCurve completionCurve;
@end



NS_HEADER_AUDIT_END(nullability, sendability)

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Modules/module.modulemap`:

```modulemap
framework module UXKit {
  umbrella "."

  export *
  module * { export * }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/Resources/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleExecutable</key>
	<string>UXKit</string>
	<key>CFBundleIdentifier</key>
	<string>com.apple.swe.UXKit</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>11.0</string>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/UXKit.xcframework/macos-arm64e-arm64-x86_64/UXKit.framework/Versions/A/UXKit.tbd`:

```tbd
--- !tapi-tbd
tbd-version:     4
targets:         [ x86_64-macos, arm64-macos, arm64e-macos ]
install-name:    '/System/Library/PrivateFrameworks/UXKit.framework/Versions/A/UXKit'
current-version: 801.43.240
exports:
  - targets:         [ x86_64-macos, arm64-macos, arm64e-macos ]
    symbols:         [ _NSImageDynamicRangeFromUXImageDynamicRange, _NSStringFromUXCollectionViewLayoutDropPosition, 
                       _UXCollectionElementKindCell, _UXCollectionElementKindSectionFooter, 
                       _UXCollectionElementKindSectionHeader, _UXCollectionViewDraggingPasteboardItemType, 
                       _UXCollectionViewDraggingPasteboardOptionWasPressed, _UXCollectionViewElementKindCell, 
                       _UXCollectionViewElementKindDecorationView, _UXCollectionViewElementKindSectionFooter, 
                       _UXCollectionViewElementKindSectionHeader, _UXEdgeInsetsNull, 
                       _UXEdgeInsetsZero, _UXFlowLayoutCommonRowHorizontalAlignmentKey, 
                       _UXFlowLayoutLastRowHorizontalAlignmentKey, _UXFlowLayoutRowVerticalAlignmentKey, 
                       _UXLocalizedString, _UXNavigationControllerOperationToString, 
                       _UXNavigationDestinationIsEqualToDestination, _UXNavigationItemCenterToolbarItemGroupKey, 
                       _UXNavigationItemHidesGlobalTrailingViewKey, _UXNavigationItemLeftBarButtonItemsKey, 
                       _UXNavigationItemProgressButtonItemKey, _UXNavigationItemRightBarButtonItemsKey, 
                       _UXNavigationItemSubtitleKey, _UXNavigationItemTitleKey, _UXNavigationItemUseWindowForTitleOutputKey, 
                       _UXSourceControllerForceSelectionKey, _UXSourceControllerSenderIdentifierKey, 
                       _UXSourceControllerShouldForceSelectionForNavigationDestination, 
                       _UXSourceControllerSkipDestinationRemovalKey, _UXTransitionContextFromViewControllerKey, 
                       _UXTransitionContextToViewControllerKey, _UXWindowToolbarCenteredItemIdentifier, 
                       __UXCollectionElementIsClone, __UXCollectionElementIsOriginal, 
                       __UXDebugFramesOfView, __UXImageBackChevron, __UXImageCheckmark, 
                       __UXImageForwardChevron, __UXImageLeftChevron, __UXImageRightChevron, 
                       __UXSolariumEnabled, __animationForViewFromValueToValueKeyPath, 
                       __transitionControllerClassForTransition, __uxImageFromRect, 
                       _kDefaultHeaderHeight, _kDefaultRowHeight, _kDefaultTransitionDuration, 
                       _parametersOfSpringAnimation ]
    objc-classes:    [ UIMutableIndexPath, UXBackButton, UXBar, UXBarButtonItem, 
                       UXBarItem, UXCollectionClipView, UXCollectionDocumentView, 
                       UXCollectionReusableView, UXCollectionView, UXCollectionViewAnimation, 
                       UXCollectionViewAnimationContext, UXCollectionViewCell, UXCollectionViewController, 
                       UXCollectionViewData, UXCollectionViewFilePromiseProvider, 
                       UXCollectionViewFlowLayout, UXCollectionViewFlowLayoutInvalidationContext, 
                       UXCollectionViewIndexPathsSet, UXCollectionViewLayout, UXCollectionViewLayoutAccessibility, 
                       UXCollectionViewLayoutAttributes, UXCollectionViewLayoutInvalidationContext, 
                       UXCollectionViewLayoutSectionAccessibility, UXCollectionViewMutableIndexPathsSet, 
                       UXCollectionViewPanGestureRecognizer, UXCollectionViewUpdate, 
                       UXCollectionViewUpdateGap, UXCollectionViewUpdateItem, UXControl, 
                       UXDestinationAuxiliaryStore, UXIdentityTransitionController, 
                       UXImageView, UXLabel, UXNavigationBar, UXNavigationController, 
                       UXNavigationItem, UXParallaxTransitionController, UXPopover, 
                       UXPopoverController, UXProxyViewController, UXSlideTransitionController, 
                       UXSourceController, UXSubtoolbar, UXTabBarController, UXTabBarItem, 
                       UXTabBarItemSegment, UXTableLayout, UXTableView, UXTableViewCell, 
                       UXTableViewController, UXTableViewHeaderFooterView, UXToolbar, 
                       UXTransitionController, UXView, UXViewAnimationContext, UXViewController, 
                       UXWindowController, UXWindowToolbarController, UXZoomingCrossfadeTransitionController, 
                       _UXButton, _UXButtonCell, _UXCollectionDocumentView, _UXCollectionSnapshotView, 
                       _UXCollectionView, _UXCollectionViewItemKey, _UXCollectionViewLayoutProxy, 
                       _UXCollectionViewRearrangingCoordinator, _UXCollectionViewSectionItemIndexes, 
                       _UXContainerView, _UXContentUnavailableView, _UXDetailViewController, 
                       _UXFlowLayoutInfo, _UXFlowLayoutItem, _UXFlowLayoutRow, _UXFlowLayoutSection, 
                       _UXInspectorViewController, _UXLayoutSpacer, _UXNavigationItemContainerView, 
                       _UXNavigationRequest, _UXResizableImage, _UXSettings, _UXSettingsGroup, 
                       _UXSinglePixelLine, _UXTableHeaderView, _UXToolbarItemsContainer, 
                       _UXViewControllerOneToOneTransitionContext, _UXViewControllerTransitionContext, 
                       _UXViewControllerTransitionCoordinator, _UXWindow, _UXWindowState ]
    objc-ivars:      [ UXCollectionViewAnimation._animationBlock, UXCollectionViewAnimation._collectionViewAnimationFlags, 
                       UXCollectionViewAnimation._completionHandlers, UXCollectionViewAnimation._endFraction, 
                       UXCollectionViewAnimation._finalLayoutAttributes, UXCollectionViewAnimation._startFraction, 
                       UXCollectionViewAnimation._startupHandlers, UXCollectionViewAnimation._view, 
                       UXCollectionViewAnimation._viewType, UXCollectionViewAnimationContext._animationCount, 
                       UXCollectionViewAnimationContext._completionHandler, UXCollectionViewAnimationContext._viewAnimations, 
                       UXCollectionViewData._clonedLayoutAttributes, UXCollectionViewData._collectionView, 
                       UXCollectionViewData._collectionViewDataFlags, UXCollectionViewData._contentSize, 
                       UXCollectionViewData._decorationLayoutAttributes, UXCollectionViewData._globalItems, 
                       UXCollectionViewData._invalidatedSupplementaryViews, UXCollectionViewData._lastResultForNumberOfItemsBeforeSection, 
                       UXCollectionViewData._lastSectionTestedForNumberOfItemsBeforeSection, 
                       UXCollectionViewData._layout, UXCollectionViewData._numItems, 
                       UXCollectionViewData._numSections, UXCollectionViewData._screenPageMap, 
                       UXCollectionViewData._sectionItemCounts, UXCollectionViewData._supplementaryLayoutAttributes, 
                       UXCollectionViewData._validLayoutRect, UXCollectionViewIndexPathsSet._sectionIndexes, 
                       UXCollectionViewIndexPathsSet._sectionToItemIndexesMap, UXCollectionViewUpdateGap._beginningRect, 
                       UXCollectionViewUpdateGap._deleteItems, UXCollectionViewUpdateGap._endingRect, 
                       UXCollectionViewUpdateGap._firstUpdateItem, UXCollectionViewUpdateGap._insertItems, 
                       UXCollectionViewUpdateGap._lastUpdateItem, UXTableView._tableViewDataSourceFlags, 
                       UXTableView._tableViewDelegateFlags, _UXCollectionViewItemKey._hash, 
                       _UXCollectionViewItemKey._identifier, _UXCollectionViewItemKey._indexPath, 
                       _UXCollectionViewItemKey._isClone, _UXFlowLayoutInfo._dimension, 
                       _UXFlowLayoutInfo._horizontal, _UXFlowLayoutInfo._isValid, 
                       _UXFlowLayoutInfo._layoutSize, _UXFlowLayoutInfo._leftToRight, 
                       _UXFlowLayoutInfo._rowAlignmentOptions, _UXFlowLayoutInfo._sections, 
                       _UXFlowLayoutInfo._useFloatingHeaderFooter, _UXFlowLayoutInfo._visibleBounds, 
                       _UXFlowLayoutItem._itemFrame, _UXFlowLayoutRow._complete, 
                       _UXFlowLayoutRow._horizontalAlignement, _UXFlowLayoutRow._index, 
                       _UXFlowLayoutRow._isValid, _UXFlowLayoutRow._items, _UXFlowLayoutRow._rowFrame, 
                       _UXFlowLayoutRow._rowSize, _UXFlowLayoutRow._verticalAlignement, 
                       _UXFlowLayoutSection._actualGap, _UXFlowLayoutSection._beginMargin, 
                       _UXFlowLayoutSection._endMargin, _UXFlowLayoutSection._fixedItemSize, 
                       _UXFlowLayoutSection._footerDimension, _UXFlowLayoutSection._footerFrame, 
                       _UXFlowLayoutSection._frame, _UXFlowLayoutSection._headerDimension, 
                       _UXFlowLayoutSection._headerFrame, _UXFlowLayoutSection._horizontalInterstice, 
                       _UXFlowLayoutSection._indexOfImcompleteRow, _UXFlowLayoutSection._isValid, 
                       _UXFlowLayoutSection._itemSize, _UXFlowLayoutSection._items, 
                       _UXFlowLayoutSection._itemsByRowCount, _UXFlowLayoutSection._itemsCount, 
                       _UXFlowLayoutSection._lastRowActualGap, _UXFlowLayoutSection._lastRowBeginMargin, 
                       _UXFlowLayoutSection._lastRowEndMargin, _UXFlowLayoutSection._lastRowIncomplete, 
                       _UXFlowLayoutSection._otherMargin, _UXFlowLayoutSection._rowAlignmentOptions, 
                       _UXFlowLayoutSection._rows, _UXFlowLayoutSection._sectionMagins, 
                       _UXFlowLayoutSection._verticalInterstice ]
...

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/CheckboxButton+.swift`:

```swift
import AppKit
import UIFoundation
import NSAttributedStringBuilder

extension CheckboxButton {
    convenience init(title: String, titleFont: NSFont? = nil, titleColor: NSColor? = nil, titleSpacing: CGFloat = 5.0) {
        self.init()
        self.attributedTitle = NSAttributedString {
            AText(title)
                .font(titleFont ?? .systemFont(ofSize: 13))
                .foregroundColor(titleColor ?? .labelColor)
                .paragraphStyle(NSMutableParagraphStyle().then {
                    $0.firstLineHeadIndent = titleSpacing
                    $0.lineBreakMode = .byClipping
                })
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/EventMonitor.swift`:

```swift
import AppKit

final class EventMonitor {
    private var monitors: [Any?] = []

    func addGlobalMonitorForEvents(matching mask: NSEvent.EventTypeMask, handler block: @escaping (NSEvent) -> Void) {
        monitors.append(NSEvent.addGlobalMonitorForEvents(matching: mask, handler: block))
    }

    func addLocalMonitorForEvents(matching mask: NSEvent.EventTypeMask, handler block: @escaping (NSEvent) -> NSEvent?) {
        monitors.append(NSEvent.addLocalMonitorForEvents(matching: mask, handler: block))
    }

    deinit {
        monitors.forEach(NSEvent.removeMonitor(_:))
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/RuntimeConnectionNotificationService.swift`:

```swift
import Foundation
import FoundationToolbox
import UserNotifications
import RuntimeViewerSettings
import RuntimeViewerCore
import RuntimeViewerCommunication
import Dependencies

/// Service responsible for sending local notifications for runtime connection events.
public final class RuntimeConnectionNotificationService: NSObject, Loggable {
    public static let shared = RuntimeConnectionNotificationService()

    private let notificationCenter = UNUserNotificationCenter.current()

    private override init() {
        super.init()
        notificationCenter.delegate = self
        requestAuthorization()
    }

    // MARK: - Authorization

    private func requestAuthorization() {
        notificationCenter.requestAuthorization(options: [.alert]) { granted, error in
            if let error {
                Self.logger.error("Notification authorization failed: \(error.localizedDescription, privacy: .public)")
            } else if granted {
                Self.logger.info("Notification authorization granted")
            } else {
                Self.logger.info("Notification authorization denied")
            }
        }
    }

    // MARK: - Connection Events

    /// Sends a notification when a runtime engine is connected.
    /// - Parameter source: The runtime source that was connected.
    public func notifyConnected(source: RuntimeSource) {
        let settings = Settings.shared.notifications
        guard settings.isEnabled, settings.showOnConnect else { return }

        let content = UNMutableNotificationContent()
        content.title = "Connected"
        content.body = "Successfully connected to \(source.displayName)"

        sendNotification(identifier: "connection.connected.\(source.identifier)", content: content)
    }

    /// Sends a notification when a runtime engine is disconnected.
    /// - Parameters:
    ///   - source: The runtime source that was disconnected.
    ///   - error: Optional error if disconnection was unexpected.
    public func notifyDisconnected(source: RuntimeSource, error: Error?) {
        let settings = Settings.shared.notifications
        guard settings.isEnabled, settings.showOnDisconnect else { return }

        let content = UNMutableNotificationContent()
        content.title = "Disconnected"

        if let error {
            content.body = "Lost connection to \(source.displayName): \(error.localizedDescription)"
        } else {
            content.body = "Disconnected from \(source.displayName)"
        }

        sendNotification(identifier: "connection.disconnected.\(source.identifier)", content: content)
    }

    // MARK: - Private

    private func sendNotification(identifier: String, content: UNNotificationContent) {
        let request = UNNotificationRequest(
            identifier: identifier,
            content: content,
            trigger: nil // Deliver immediately
        )

        notificationCenter.add(request) { error in
            if let error {
                Self.logger.error("Failed to send notification: \(error.localizedDescription, privacy: .public)")
            }
        }
    }
}

// MARK: - UNUserNotificationCenterDelegate

extension RuntimeConnectionNotificationService: UNUserNotificationCenterDelegate {
    public func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        willPresent notification: UNNotification,
        withCompletionHandler completionHandler: @escaping (UNNotificationPresentationOptions) -> Void
    ) {
        // Show notification even when app is in foreground
        completionHandler([.banner])
    }

    public func userNotificationCenter(
        _ center: UNUserNotificationCenter,
        didReceive response: UNNotificationResponse,
        withCompletionHandler completionHandler: @escaping () -> Void
    ) {
        // Handle notification tap if needed
        completionHandler()
    }
}

// MARK: - RuntimeSource Extension

extension RuntimeSource {
    fileprivate var displayName: String {
        switch self {
        case .local:
            return "Local Runtime"
        case .remote(let name, _, _):
            return name
        case .bonjourClient(let endpoint):
            return "Bonjour: \(endpoint.name)"
        case .bonjourServer(let name, _):
            return name
        case .macCatalystClient:
            return "Mac Catalyst Runtime"
        case .localSocketClient(let name, _):
            return name
        case .localSocketServer(let name, _):
            return name
        case .directTCPClient(let name, _, _):
            return name
        case .directTCPServer(let name, _):
            return name
        }
    }

    fileprivate var identifier: String {
        switch self {
        case .local:
            return "local"
        case .remote(_, let id, _):
            return id.rawValue
        case .bonjourClient(let endpoint):
            return "bonjour.\(endpoint.name)"
        case .bonjourServer(let name, _):
            return "bonjourServer.\(name)"
        case .macCatalystClient:
            return "macCatalyst"
        case .localSocketClient(_, let id):
            return id.rawValue
        case .localSocketServer(_, let id):
            return "localSocketServer.\(id.rawValue)"
        case .directTCPClient(let name, let host, let port):
            return "tcp.\(name).\(host).\(port)"
        case .directTCPServer(let name, let port):
            return "tcpServer.\(name).\(port)"
        }
    }
}

// MARK: - Dependencies

private enum RuntimeConnectionNotificationServiceKey: DependencyKey {
    static let liveValue = RuntimeConnectionNotificationService.shared
}

extension DependencyValues {
    public var runtimeConnectionNotificationService: RuntimeConnectionNotificationService {
        get { self[RuntimeConnectionNotificationServiceKey.self] }
        set { self[RuntimeConnectionNotificationServiceKey.self] = newValue }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/RuntimeEngineManager.swift`:

```swift
import Foundation
import FoundationToolbox
import ServiceManagement
import RuntimeViewerCore
import RuntimeViewerCommunication
import RuntimeViewerArchitectures
import RuntimeViewerHelperClient
import RuntimeViewerCatalystExtensions

public final class RuntimeEngineManager: Loggable {
    public static let shared = RuntimeEngineManager()

    @Published
    public private(set) var systemRuntimeEngines: [RuntimeEngine] = []

    @Published
    public private(set) var attachedRuntimeEngines: [RuntimeEngine] = []

    @Published
    public private(set) var bonjourRuntimeEngines: [RuntimeEngine] = []

    private let browser = RuntimeNetworkBrowser()

    @Dependency(\.helperServiceManager)
    private var helperServiceManager

    @Dependency(\.runtimeConnectionNotificationService)
    private var runtimeConnectionNotificationService

    @Dependency(\.runtimeHelperClient)
    private var runtimeHelperClient
    
    private init() {
        browser.start { [weak self] endpoint in
            guard let self else { return }
            Task { @MainActor in
                do {
                    let runtimeEngine = RuntimeEngine(source: .bonjourClient(endpoint: endpoint))
                    try await runtimeEngine.connect()
                    self.appendBonjourRuntimeEngine(runtimeEngine)
                } catch {
                    Self.logger.error("Failed to connect to bonjour runtime engine at endpoint: \("\(endpoint)", privacy: .public) with error: \(error, privacy: .public)")
                }
            }
        }
        Task {
            do {
                try await self.launchSystemRuntimeEngines()
            } catch {
                Self.logger.error("Failed to launch system runtime engines with error: \(error, privacy: .public)")
            }
        }
    }

    private func appendBonjourRuntimeEngine(_ bonjourRuntimeEngine: RuntimeEngine) {
        bonjourRuntimeEngines.append(bonjourRuntimeEngine)
        observeRuntimeEngineState(bonjourRuntimeEngine)
    }

    public var runtimeEngines: [RuntimeEngine] {
        systemRuntimeEngines + attachedRuntimeEngines + bonjourRuntimeEngines
    }

    @concurrent
    public func launchSystemRuntimeEngines() async throws {
        systemRuntimeEngines.append(.local)
        #if os(macOS)
        let macCatalystClientEngine = RuntimeEngine(source: .macCatalystClient)
        try await macCatalystClientEngine.connect()
        try await runtimeHelperClient.launchMacCatalystHelper()
        systemRuntimeEngines.append(macCatalystClientEngine)
        observeRuntimeEngineState(macCatalystClientEngine)
        #endif
    }

    @concurrent
    public func launchAttachedRuntimeEngine(name: String, identifier: String, isSandbox: Bool) async throws {
        let runtimeSource = if isSandbox {
            RuntimeSource.localSocketClient(name: name, identifier: .init(rawValue: identifier))
        } else {
            RuntimeSource.remote(name: name, identifier: .init(rawValue: identifier), role: .client)
        }

        let runtimeEngine = RuntimeEngine(source: runtimeSource)
        try await runtimeEngine.connect()
        attachedRuntimeEngines.append(runtimeEngine)
        observeRuntimeEngineState(runtimeEngine)
    }

    private func observeRuntimeEngineState(_ runtimeEngine: RuntimeEngine) {
        runtimeEngine.statePublisher.asObservable()
            .subscribeOnNext { [weak self, weak runtimeEngine] state in
                guard let self, let runtimeEngine else { return }
                switch state {
                case .initializing:
                    logger.info("Initializing runtime engine: \(runtimeEngine.source.description, privacy: .public)")
                case .connecting:
                    logger.info("Connecting to runtime engine: \(runtimeEngine.source.description, privacy: .public)")
                case .connected:
                    logger.info("Connected to runtime engine: \(runtimeEngine.source.description, privacy: .public)")
                    runtimeConnectionNotificationService.notifyConnected(source: runtimeEngine.source)
                case .disconnected(error: let error):
                    if let error {
                        logger.error("Disconnected from runtime engine: \(runtimeEngine.source.description, privacy: .public) with error: \(error, privacy: .public)")
                    } else {
                        logger.info("Disconnected from runtime engine: \(runtimeEngine.source.description, privacy: .public)")
                    }
                    runtimeConnectionNotificationService.notifyDisconnected(source: runtimeEngine.source, error: error)
                    terminateRuntimeEngine(for: runtimeEngine.source)
                default:
                    break
                }
            }
            .disposed(by: rx.disposeBag)
    }

    public func terminateRuntimeEngine(for source: RuntimeSource) {
        systemRuntimeEngines.removeAll { $0.source == source }
        attachedRuntimeEngines.removeAll { $0.source == source }
        bonjourRuntimeEngines.removeAll { $0.source == source }
    }

    public func terminateAttachedRuntimeEngine(name: String, identifier: String, isSandbox: Bool) {
        if isSandbox {
            terminateRuntimeEngine(for: .localSocketClient(name: name, identifier: .init(rawValue: identifier)))
        } else {
            terminateRuntimeEngine(for: .remote(name: name, identifier: .init(rawValue: identifier), role: .client))
        }
    }
}

extension RuntimeEngineManager: ReactiveCompatible {}

extension Reactive where Base == RuntimeEngineManager {
    public var runtimeEngines: Driver<[RuntimeEngine]> {
        Driver.combineLatest(base.$systemRuntimeEngines.asObservable().asDriver(onErrorJustReturn: []), base.$attachedRuntimeEngines.asObservable().asDriver(onErrorJustReturn: []), base.$bonjourRuntimeEngines.asObservable().asDriver(onErrorJustReturn: []), resultSelector: { $0 + $1 + $2 })
    }
}

// MARK: - Dependencies

private enum RuntimeEngineManagerKey: DependencyKey {
    static let liveValue = RuntimeEngineManager.shared
}

extension DependencyValues {
    public var runtimeEngineManager: RuntimeEngineManager {
        get { self[RuntimeEngineManagerKey.self] }
        set { self[RuntimeEngineManagerKey.self] = newValue }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/RuntimeSource+.swift`:

```swift
import AppKit
import RxSwift
import RxAppKit
import RuntimeViewerUI
import RuntimeViewerCommunication

extension RuntimeSource: @retroactive RxMenuItemRepresentable {}

extension RuntimeSource: MainMenuItemRepresentable {
    public var title: String { description }

    var icon: NSImage {
        switch self {
        case .local:
            return .symbol(systemName: .display)
        case .remote(_, let identifier, _):
            if identifier == .macCatalyst {
                return .symbol(systemName: .display)
            } else {
                return .symbol(name: RuntimeViewerSymbols.appFill)
            }
        case .bonjourClient, .bonjourServer:
            return .symbol(systemName: .bonjour)
        case .localSocketClient, .localSocketServer:
            return .symbol(systemName: .network)
        case .directTCPClient, .directTCPServer:
            return .symbol(systemName: .network)
        }
    }
}

extension Reactive where Base: NSMenu {
    func selectedItemIndex() -> ControlEvent<Int> {
        let source = itemSelected(Any?.self).compactMap { [weak base] menuItem, _ -> Int? in
            guard let self = base else { return nil }
            return self.items.firstIndex(of: menuItem)
        }.share()
        return ControlEvent(events: source)
    }
}

protocol MainMenuItemRepresentable: RxMenuItemRepresentable {
    var icon: NSImage { get }
}

extension Reactive where Base: NSPopUpButton {
    func items<MenuItemRepresentable: MainMenuItemRepresentable>() -> Binder<[MenuItemRepresentable]> {
        Binder(base) { (target: NSPopUpButton, items: [MenuItemRepresentable]) in
            target.removeAllItems()
            items.forEach { item in
                target.addItem(withTitle: item.title)
                if let menuItem = target.item(withTitle: item.title) {
                    menuItem.image = item.icon
                }
            }
        }
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/SIPChecker.swift`:

```swift
import Foundation

enum SIPChecker {
    static func isDisabled() -> Bool {
        let task = Process()
        task.launchPath = "/usr/bin/csrutil"
        task.arguments = ["status"]

        let pipe = Pipe()
        task.standardOutput = pipe

        task.launch()

        let data = pipe.fileHandleForReading.readDataToEndOfFile()

        guard let output = String(data: data, encoding: .utf8) else { return false }

        return output.contains("disabled")
    }
}

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/Then.swift`:

```swift
import Foundation
#if !os(Linux)
import CoreGraphics
#endif

#if os(macOS) && !targetEnvironment(macCatalyst)
import AppKit
#endif

#if os(iOS) || os(tvOS)
import UIKit.UIGeometry
#endif

protocol Then {}

extension Then where Self: Any {
    /// Makes it available to set properties with closures just after initializing and copying the value types.
    ///
    ///     let frame = CGRect().with {
    ///       $0.origin.x = 10
    ///       $0.size.width = 100
    ///     }
    @inlinable
    func with(_ block: (inout Self) throws -> Void) rethrows -> Self {
        var copy = self
        try block(&copy)
        return copy
    }

    /// Makes it available to execute something with closures.
    ///
    ///     UserDefaults.standard.do {
    ///       $0.set("devxoul", forKey: "username")
    ///       $0.set("devxoul@gmail.com", forKey: "email")
    ///       $0.synchronize()
    ///     }
    @inlinable
    func `do`(_ block: (Self) throws -> Void) rethrows {
        try block(self)
    }
}

extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///       $0.textAlignment = .center
    ///       $0.textColor = UIColor.black
    ///       $0.text = "Hello, World!"
    ///     }
    @inlinable
    @discardableResult
    func then(_ block: (Self) throws -> Void) rethrows -> Self {
        try block(self)
        return self
    }
}

extension Then {
    @inlinable
    func `as`<T>(_ transform: (Self) throws -> T) rethrows -> T {
        try transform(self)
    }
}

extension NSObject: Then {}

extension CGPoint: Then {}
extension CGRect: Then {}
extension CGSize: Then {}
extension CGVector: Then {}

extension Array: Then {}
extension Dictionary: Then {}
extension Set: Then {}
extension JSONDecoder: Then {}
extension JSONEncoder: Then {}

#if os(macOS)
extension NSEdgeInsets: Then {}
extension NSRectEdge: Then {}
extension NSDirectionalRectEdge: Then {}
extension NSDirectionalEdgeInsets: Then {}
@available(macOS 15.0, *)
extension NSHorizontalDirection: Then {}
@available(macOS 15.0, *)
extension NSHorizontalDirection.Set: Then {}
@available(macOS 15.0, *)
extension NSVerticalDirection: Then {}
@available(macOS 15.0, *)
extension NSVerticalDirection.Set: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItem: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse.Highlight: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemResponse.Phase: Then {}
@available(macOS 15.0, *)
extension NSSuggestionItemSection: Then {}
@available(macOS 26.0, *)
extension NSItemBadge: Then {}
@available(macOS 26.0, *)
extension NSView.LayoutRegion: Then {}
#endif

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/UIDebugger.h`:

```h
//
//  UIDebugger.h
//  UIDebugger
//
//  Created by Guilherme Rambo on 25/03/16.
//  Copyright Â© 2016 Guilherme Rambo. All rights reserved.
//

@import Cocoa;

@interface UIDebugger : NSObject

@end

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Utils/UIDebugger.m`:

```m
//
//  UIDebugger.m
//  UIDebugger
//
//  Created by Guilherme Rambo on 25/03/16.
//  Copyright Â© 2016 Guilherme Rambo. All rights reserved.
//

#import "UIDebugger.h"

@interface UIDebuggerMenuItem: NSMenuItem
+ (void)insertInMainMenu;
@end

@implementation UIDebugger

#ifdef DEBUG

+ (void)load
{
    NSMutableDictionary *argValues = [[NSUserDefaults standardUserDefaults] volatileDomainForName:NSArgumentDomain].mutableCopy;
    argValues[@"_NS_4445425547"] = @(YES);

    [[NSUserDefaults standardUserDefaults] setVolatileDomain:argValues forName:NSArgumentDomain];

    [[NSNotificationCenter defaultCenter] addObserverForName:NSApplicationDidFinishLaunchingNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) {
        [UIDebuggerMenuItem insertInMainMenu];
    }];
}

#endif

@end

@implementation UIDebuggerMenuItem

#ifdef DEBUG

+ (void)insertInMainMenu
{
    [[[NSApplication sharedApplication] mainMenu] addItem:[[self alloc] init]];
}


- (id)init
{
    return [self initWithTitle:@"Debug UI" action:@selector(submenuAction:) keyEquivalent:@""];
}

- (id)initWithTitle:(NSString *)itemName action:(SEL)anAction keyEquivalent:(NSString *)charCode
{
    if (self = [super initWithTitle:itemName action:anAction keyEquivalent:charCode])
    {
        NSMenu *submenu = [[NSMenu alloc] initWithTitle:@"Debug UI"];
        
        NSMenuItem *item1 = [[NSMenuItem alloc] initWithTitle:@"Visualize Constraints" action:@selector(visualizeConstraints:) keyEquivalent:@""];
        [item1 setTarget:self];
        [submenu addItem:item1];
        
        [self setSubmenu:submenu];
        
        return self;
    }
    return nil;
}

- (IBAction)visualizeConstraints:(id)sender
{
    NSWindow *window = [NSApp mainWindow];
    NSView *firstResponderView = (NSView *)window.firstResponder;
    
    if ([firstResponderView respondsToSelector:@selector(constraints)]) {
        [window visualizeConstraints:firstResponderView.constraints];
    } else {
        [window visualizeConstraints:window.contentView.constraints];
    }
}

#endif

@end

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/com.mxiris.runtimeviewer.service.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>com.mxiris.runtimeviewer.service</string>
	<key>BundleProgram</key>
	<string>Contents/Library/LaunchServices/com.mxiris.runtimeviewer.service</string>
	<key>MachServices</key>
	<dict>
		<key>com.mxiris.runtimeviewer.service</key>
		<true/>
	</dict>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/launchd.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>com.JH.RuntimeViewerService</string>
	<key>MachServices</key>
	<dict>
		<key>com.JH.RuntimeViewerService</key>
		<true/>
	</dict>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/Shared-Debug.xcconfig`:

```xcconfig
#include "Shared.xcconfig"

//ENABLE_POINTER_AUTHENTICATION = YES
//ARCHS = x86_64 arm64 arm64e

```

`RuntimeViewerUsingAppKit/Shared-Release.xcconfig`:

```xcconfig
#include "Shared.xcconfig"

//ENABLE_POINTER_AUTHENTICATION = YES
//ARCHS = x86_64 arm64 arm64e

```

`RuntimeViewerUsingAppKit/com.JH.RuntimeViewerService/Config.xcconfig`:

```xcconfig
OTHER_LDFLAGS = $(inherited) -sectcreate __TEXT __launchd_plist "$(SRCROOT)/com.JH.RuntimeViewerService/launchd.plist"


```

`RuntimeViewerUsingAppKit/com.JH.RuntimeViewerService/Debug.xcconfig`:

```xcconfig
#include "Config.xcconfig"
#include "Shared-Debug.xcconfig"

SMAuthorizedClient = identifier "dev.JH.RuntimeViewer" and anchor apple generic and certificate leaf[subject.CN] = "Apple Development: JieHui Lai (4ZZALU97YZ)" and certificate 1[field.1.2.840.113635.100.6.2.1] /* exists */

```

`RuntimeViewerUsingAppKit/com.JH.RuntimeViewerService/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>com.JH.RuntimeViewerService</string>
	<key>CFBundleShortVersionString</key>
	<string>1.0.0</string>
	<key>CFBundleVersion</key>
	<string>1</string>
	<key>SMAuthorizedClients</key>
	<array>
		<string>$(SMAuthorizedClient)</string>
	</array>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/com.JH.RuntimeViewerService/Release.xcconfig`:

```xcconfig
#include "Config.xcconfig"
#include "Shared-Release.xcconfig"

SMAuthorizedClient = anchor apple generic and identifier "com.JH.RuntimeViewer" and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = D5Q73692VW)

```

`RuntimeViewerUsingAppKit/com.JH.RuntimeViewerService/launchd.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Label</key>
	<string>com.JH.RuntimeViewerService</string>
	<key>MachServices</key>
	<dict>
		<key>com.JH.RuntimeViewerService</key>
		<true/>
	</dict>
</dict>
</plist>

```

`RuntimeViewerUsingAppKit/com.JH.RuntimeViewerService/main.swift`:

```swift
import Foundation
import RuntimeViewerService

try RuntimeViewerService.main()

```

`RuntimeViewerUsingAppKit/com.mxiris.runtimeviewer.service/main.swift`:

```swift
import RuntimeViewerService

try RuntimeViewerService.main()

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		E9038FA32C31A8200051B6AC /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = E9038FA22C31A8200051B6AC /* Assets.xcassets */; };
		E9038FAB2C31A8500051B6AC /* SidebarRootViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC8F2C27CF4F00A2F3D3 /* SidebarRootViewController.swift */; };
		E9038FAC2C31A8500051B6AC /* MainSplitViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E95441BB2C26E99400DFFD40 /* MainSplitViewController.swift */; };
		E9038FAD2C31A8500051B6AC /* ContentCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC952C28654F00A2F3D3 /* ContentCoordinator.swift */; };
		E9038FAE2C31A8500051B6AC /* ContentNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC972C28658A00A2F3D3 /* ContentNavigationController.swift */; };
		E9038FAF2C31A8500051B6AC /* SceneDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9432FC72C0D612000362862 /* SceneDelegate.swift */; };
		E9038FB02C31A8500051B6AC /* SidebarCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC8B2C27CF0A00A2F3D3 /* SidebarCoordinator.swift */; };
		E9038FB12C31A8500051B6AC /* Then.swift in Sources */ = {isa = PBXBuildFile; fileRef = E947C39D2C2AB7E400296B2E /* Then.swift */; };
		E9038FB22C31A8500051B6AC /* MainViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942ACA32C28682C00A2F3D3 /* MainViewModel.swift */; };
		E9038FB32C31A8500051B6AC /* InspectorNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC9F2C2866E600A2F3D3 /* InspectorNavigationController.swift */; };
		E9038FB42C31A8500051B6AC /* SidebarRuntimeObjectViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC922C28210100A2F3D3 /* SidebarRuntimeObjectViewController.swift */; };
		E9038FB52C31A8500051B6AC /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9432FC52C0D612000362862 /* AppDelegate.swift */; };
		E9038FB62C31A8500051B6AC /* SidebarNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC8D2C27CF3400A2F3D3 /* SidebarNavigationController.swift */; };
		E9038FB72C31A8500051B6AC /* ContentPlaceholderViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC992C28659C00A2F3D3 /* ContentPlaceholderViewController.swift */; };
		E9038FB82C31A8500051B6AC /* ContentTextViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC9B2C2865A300A2F3D3 /* ContentTextViewController.swift */; };
		E9038FB92C31A8500051B6AC /* ViewControllers.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9432FC92C0D612000362862 /* ViewControllers.swift */; };
		E9038FBA2C31A8500051B6AC /* InspectorCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942ACA12C2866F400A2F3D3 /* InspectorCoordinator.swift */; };
		E9038FBB2C31A8500051B6AC /* MainCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC762C270C0000A2F3D3 /* MainCoordinator.swift */; };
		E9038FBD2C31A8810051B6AC /* RuntimeViewerApplication in Frameworks */ = {isa = PBXBuildFile; productRef = E9038FBC2C31A8810051B6AC /* RuntimeViewerApplication */; };
		E9038FBF2C31A8810051B6AC /* RuntimeViewerArchitectures in Frameworks */ = {isa = PBXBuildFile; productRef = E9038FBE2C31A8810051B6AC /* RuntimeViewerArchitectures */; };
		E9038FC32C31A8810051B6AC /* RuntimeViewerUI in Frameworks */ = {isa = PBXBuildFile; productRef = E9038FC22C31A8810051B6AC /* RuntimeViewerUI */; };
		E927C2302E94450700084A7B /* AppIcon.icon in Resources */ = {isa = PBXBuildFile; fileRef = E927C22F2E94450700084A7B /* AppIcon.icon */; };
		E927C2312E94450700084A7B /* AppIcon.icon in Resources */ = {isa = PBXBuildFile; fileRef = E927C22F2E94450700084A7B /* AppIcon.icon */; };
		E942AC772C270C0000A2F3D3 /* MainCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC762C270C0000A2F3D3 /* MainCoordinator.swift */; };
		E942AC8A2C27556800A2F3D3 /* RuntimeViewerApplication in Frameworks */ = {isa = PBXBuildFile; productRef = E942AC892C27556800A2F3D3 /* RuntimeViewerApplication */; };
		E942AC8C2C27CF0A00A2F3D3 /* SidebarCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC8B2C27CF0A00A2F3D3 /* SidebarCoordinator.swift */; };
		E942AC8E2C27CF3400A2F3D3 /* SidebarNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC8D2C27CF3400A2F3D3 /* SidebarNavigationController.swift */; };
		E942AC902C27CF4F00A2F3D3 /* SidebarRootViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC8F2C27CF4F00A2F3D3 /* SidebarRootViewController.swift */; };
		E942AC932C28210100A2F3D3 /* SidebarRuntimeObjectViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC922C28210100A2F3D3 /* SidebarRuntimeObjectViewController.swift */; };
		E942AC962C28654F00A2F3D3 /* ContentCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC952C28654F00A2F3D3 /* ContentCoordinator.swift */; };
		E942AC982C28658A00A2F3D3 /* ContentNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC972C28658A00A2F3D3 /* ContentNavigationController.swift */; };
		E942AC9A2C28659C00A2F3D3 /* ContentPlaceholderViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC992C28659C00A2F3D3 /* ContentPlaceholderViewController.swift */; };
		E942AC9C2C2865A300A2F3D3 /* ContentTextViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC9B2C2865A300A2F3D3 /* ContentTextViewController.swift */; };
		E942ACA02C2866E600A2F3D3 /* InspectorNavigationController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942AC9F2C2866E600A2F3D3 /* InspectorNavigationController.swift */; };
		E942ACA22C2866F400A2F3D3 /* InspectorCoordinator.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942ACA12C2866F400A2F3D3 /* InspectorCoordinator.swift */; };
		E942ACA42C28682C00A2F3D3 /* MainViewModel.swift in Sources */ = {isa = PBXBuildFile; fileRef = E942ACA32C28682C00A2F3D3 /* MainViewModel.swift */; };
		E9432FC62C0D612000362862 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9432FC52C0D612000362862 /* AppDelegate.swift */; };
		E9432FC82C0D612000362862 /* SceneDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9432FC72C0D612000362862 /* SceneDelegate.swift */; };
		E9432FCA2C0D612000362862 /* ViewControllers.swift in Sources */ = {isa = PBXBuildFile; fileRef = E9432FC92C0D612000362862 /* ViewControllers.swift */; };
		E9432FCF2C0D612100362862 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = E9432FCE2C0D612100362862 /* Assets.xcassets */; };
		E947C39E2C2AB7E400296B2E /* Then.swift in Sources */ = {isa = PBXBuildFile; fileRef = E947C39D2C2AB7E400296B2E /* Then.swift */; };
		E95441BC2C26E99400DFFD40 /* MainSplitViewController.swift in Sources */ = {isa = PBXBuildFile; fileRef = E95441BB2C26E99400DFFD40 /* MainSplitViewController.swift */; };
		E96CF52D2EC7848700CBC159 /* XiblessView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E96CF52C2EC7848700CBC159 /* XiblessView.swift */; };
		E96CF52E2EC7848700CBC159 /* XiblessView.swift in Sources */ = {isa = PBXBuildFile; fileRef = E96CF52C2EC7848700CBC159 /* XiblessView.swift */; };
		E96CF5302EC784C000CBC159 /* Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = E96CF52F2EC784C000CBC159 /* Extensions.swift */; };
		E96CF5312EC784C000CBC159 /* Extensions.swift in Sources */ = {isa = PBXBuildFile; fileRef = E96CF52F2EC784C000CBC159 /* Extensions.swift */; };
		E985A9D62D9AF52E005A573C /* RuntimeViewerCore in Frameworks */ = {isa = PBXBuildFile; productRef = E985A9D52D9AF52E005A573C /* RuntimeViewerCore */; };
		E9AA36242C318A7300A9B2E4 /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = E9AA36232C318A7300A9B2E4 /* LaunchScreen.storyboard */; platformFilter = ios; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		E9038F982C31A81F0051B6AC /* RuntimeViewer.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = RuntimeViewer.app; sourceTree = BUILT_PRODUCTS_DIR; };
		E9038FA22C31A8200051B6AC /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		E9038FA72C31A8200051B6AC /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		E927C22F2E94450700084A7B /* AppIcon.icon */ = {isa = PBXFileReference; lastKnownFileType = folder.iconcomposer.icon; name = AppIcon.icon; path = ../Resources/AppIcon.icon; sourceTree = SOURCE_ROOT; };
		E942AC762C270C0000A2F3D3 /* MainCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainCoordinator.swift; sourceTree = "<group>"; };
		E942AC8B2C27CF0A00A2F3D3 /* SidebarCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarCoordinator.swift; sourceTree = "<group>"; };
		E942AC8D2C27CF3400A2F3D3 /* SidebarNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarNavigationController.swift; sourceTree = "<group>"; };
		E942AC8F2C27CF4F00A2F3D3 /* SidebarRootViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRootViewController.swift; sourceTree = "<group>"; };
		E942AC922C28210100A2F3D3 /* SidebarRuntimeObjectViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SidebarRuntimeObjectViewController.swift; sourceTree = "<group>"; };
		E942AC952C28654F00A2F3D3 /* ContentCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentCoordinator.swift; sourceTree = "<group>"; };
		E942AC972C28658A00A2F3D3 /* ContentNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentNavigationController.swift; sourceTree = "<group>"; };
		E942AC992C28659C00A2F3D3 /* ContentPlaceholderViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentPlaceholderViewController.swift; sourceTree = "<group>"; };
		E942AC9B2C2865A300A2F3D3 /* ContentTextViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentTextViewController.swift; sourceTree = "<group>"; };
		E942AC9F2C2866E600A2F3D3 /* InspectorNavigationController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorNavigationController.swift; sourceTree = "<group>"; };
		E942ACA12C2866F400A2F3D3 /* InspectorCoordinator.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = InspectorCoordinator.swift; sourceTree = "<group>"; };
		E942ACA32C28682C00A2F3D3 /* MainViewModel.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainViewModel.swift; sourceTree = "<group>"; };
		E9432FC22C0D612000362862 /* RuntimeViewer.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = RuntimeViewer.app; sourceTree = BUILT_PRODUCTS_DIR; };
		E9432FC52C0D612000362862 /* AppDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		E9432FC72C0D612000362862 /* SceneDelegate.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SceneDelegate.swift; sourceTree = "<group>"; };
		E9432FC92C0D612000362862 /* ViewControllers.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ViewControllers.swift; sourceTree = "<group>"; };
		E9432FCE2C0D612100362862 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		E9432FD32C0D612100362862 /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
		E9432FF22C0D617200362862 /* RuntimeViewerUsingUIKit.entitlements */ = {isa = PBXFileReference; lastKnownFileType = text.plist.entitlements; path = RuntimeViewerUsingUIKit.entitlements; sourceTree = "<group>"; };
		E947C39D2C2AB7E400296B2E /* Then.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = Then.swift; sourceTree = "<group>"; };
		E95441BB2C26E99400DFFD40 /* MainSplitViewController.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = MainSplitViewController.swift; sourceTree = "<group>"; };
		E96CF52C2EC7848700CBC159 /* XiblessView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = XiblessView.swift; sourceTree = "<group>"; };
		E96CF52F2EC784C000CBC159 /* Extensions.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Extensions.swift; sourceTree = "<group>"; };
		E9AA36232C318A7300A9B2E4 /* LaunchScreen.storyboard */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = file.storyboard; path = LaunchScreen.storyboard; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		E9038F952C31A81F0051B6AC /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E985A9D62D9AF52E005A573C /* RuntimeViewerCore in Frameworks */,
				E9038FBF2C31A8810051B6AC /* RuntimeViewerArchitectures in Frameworks */,
				E9038FBD2C31A8810051B6AC /* RuntimeViewerApplication in Frameworks */,
				E9038FC32C31A8810051B6AC /* RuntimeViewerUI in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9432FBF2C0D612000362862 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E942AC8A2C27556800A2F3D3 /* RuntimeViewerApplication in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		E9038F992C31A81F0051B6AC /* RuntimeViewerUsingVision */ = {
			isa = PBXGroup;
			children = (
				E9038FA22C31A8200051B6AC /* Assets.xcassets */,
				E9038FA72C31A8200051B6AC /* Info.plist */,
			);
			path = RuntimeViewerUsingVision;
			sourceTree = "<group>";
		};
		E9432FB92C0D612000362862 = {
			isa = PBXGroup;
			children = (
				E927C22F2E94450700084A7B /* AppIcon.icon */,
				E9432FC42C0D612000362862 /* RuntimeViewerUsingUIKit */,
				E9038F992C31A81F0051B6AC /* RuntimeViewerUsingVision */,
				E9432FC32C0D612000362862 /* Products */,
				E9432FF62C0D638200362862 /* Frameworks */,
			);
			sourceTree = "<group>";
		};
		E9432FC32C0D612000362862 /* Products */ = {
			isa = PBXGroup;
			children = (
				E9432FC22C0D612000362862 /* RuntimeViewer.app */,
				E9038F982C31A81F0051B6AC /* RuntimeViewer.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		E9432FC42C0D612000362862 /* RuntimeViewerUsingUIKit */ = {
			isa = PBXGroup;
			children = (
				E96CF52A2EC7814B00CBC159 /* App */,
				E96CF5292EC7813F00CBC159 /* Base */,
				E96CF5282EC7813600CBC159 /* Main */,
				E96CF5252EC7811800CBC159 /* Sidebar */,
				E96CF5262EC7812000CBC159 /* Content */,
				E96CF5272EC7812800CBC159 /* Inspector */,
				E96CF52B2EC7816900CBC159 /* Utils */,
				E9432FCE2C0D612100362862 /* Assets.xcassets */,
				E9AA36232C318A7300A9B2E4 /* LaunchScreen.storyboard */,
				E9432FF22C0D617200362862 /* RuntimeViewerUsingUIKit.entitlements */,
				E9432FD32C0D612100362862 /* Info.plist */,
			);
			path = RuntimeViewerUsingUIKit;
			sourceTree = "<group>";
		};
		E9432FF62C0D638200362862 /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		E96CF5252EC7811800CBC159 /* Sidebar */ = {
			isa = PBXGroup;
			children = (
				E942AC8B2C27CF0A00A2F3D3 /* SidebarCoordinator.swift */,
				E942AC8D2C27CF3400A2F3D3 /* SidebarNavigationController.swift */,
				E942AC8F2C27CF4F00A2F3D3 /* SidebarRootViewController.swift */,
				E942AC922C28210100A2F3D3 /* SidebarRuntimeObjectViewController.swift */,
			);
			path = Sidebar;
			sourceTree = "<group>";
		};
		E96CF5262EC7812000CBC159 /* Content */ = {
			isa = PBXGroup;
			children = (
				E942AC952C28654F00A2F3D3 /* ContentCoordinator.swift */,
				E942AC972C28658A00A2F3D3 /* ContentNavigationController.swift */,
				E942AC992C28659C00A2F3D3 /* ContentPlaceholderViewController.swift */,
				E942AC9B2C2865A300A2F3D3 /* ContentTextViewController.swift */,
			);
			path = Content;
			sourceTree = "<group>";
		};
		E96CF5272EC7812800CBC159 /* Inspector */ = {
			isa = PBXGroup;
			children = (
				E942AC9F2C2866E600A2F3D3 /* InspectorNavigationController.swift */,
				E942ACA12C2866F400A2F3D3 /* InspectorCoordinator.swift */,
			);
			path = Inspector;
			sourceTree = "<group>";
		};
		E96CF5282EC7813600CBC159 /* Main */ = {
			isa = PBXGroup;
			children = (
				E95441BB2C26E99400DFFD40 /* MainSplitViewController.swift */,
				E942AC762C270C0000A2F3D3 /* MainCoordinator.swift */,
				E942ACA32C28682C00A2F3D3 /* MainViewModel.swift */,
			);
			path = Main;
			sourceTree = "<group>";
		};
		E96CF5292EC7813F00CBC159 /* Base */ = {
			isa = PBXGroup;
			children = (
				E9432FC92C0D612000362862 /* ViewControllers.swift */,
				E96CF52C2EC7848700CBC159 /* XiblessView.swift */,
			);
			path = Base;
			sourceTree = "<group>";
		};
		E96CF52A2EC7814B00CBC159 /* App */ = {
			isa = PBXGroup;
			children = (
				E9432FC52C0D612000362862 /* AppDelegate.swift */,
				E9432FC72C0D612000362862 /* SceneDelegate.swift */,
			);
			path = App;
			sourceTree = "<group>";
		};
		E96CF52B2EC7816900CBC159 /* Utils */ = {
			isa = PBXGroup;
			children = (
				E96CF52F2EC784C000CBC159 /* Extensions.swift */,
				E947C39D2C2AB7E400296B2E /* Then.swift */,
			);
			path = Utils;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		E9038F972C31A81F0051B6AC /* RuntimeViewerUsingVision */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E9038FA82C31A8200051B6AC /* Build configuration list for PBXNativeTarget "RuntimeViewerUsingVision" */;
			buildPhases = (
				E9038F942C31A81F0051B6AC /* Sources */,
				E9038F952C31A81F0051B6AC /* Frameworks */,
				E9038F962C31A81F0051B6AC /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = RuntimeViewerUsingVision;
			packageProductDependencies = (
				E9038FBC2C31A8810051B6AC /* RuntimeViewerApplication */,
				E9038FBE2C31A8810051B6AC /* RuntimeViewerArchitectures */,
				E9038FC22C31A8810051B6AC /* RuntimeViewerUI */,
				E985A9D52D9AF52E005A573C /* RuntimeViewerCore */,
			);
			productName = RuntimeViewerUsingVision;
			productReference = E9038F982C31A81F0051B6AC /* RuntimeViewer.app */;
			productType = "com.apple.product-type.application";
		};
		E9432FC12C0D612000362862 /* RuntimeViewerUsingUIKit */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = E9432FD62C0D612100362862 /* Build configuration list for PBXNativeTarget "RuntimeViewerUsingUIKit" */;
			buildPhases = (
				E9432FBE2C0D612000362862 /* Sources */,
				E9432FBF2C0D612000362862 /* Frameworks */,
				E9432FC02C0D612000362862 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = RuntimeViewerUsingUIKit;
			packageProductDependencies = (
				E942AC892C27556800A2F3D3 /* RuntimeViewerApplication */,
			);
			productName = RuntimeViewerUsingUIKit;
			productReference = E9432FC22C0D612000362862 /* RuntimeViewer.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		E9432FBA2C0D612000362862 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1620;
				LastUpgradeCheck = 1640;
				TargetAttributes = {
					E9038F972C31A81F0051B6AC = {
						CreatedOnToolsVersion = 15.4;
					};
					E9432FC12C0D612000362862 = {
						CreatedOnToolsVersion = 15.4;
					};
				};
			};
			buildConfigurationList = E9432FBD2C0D612000362862 /* Build configuration list for PBXProject "RuntimeViewerUsingUIKit" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = E9432FB92C0D612000362862;
			packageReferences = (
			);
			productRefGroup = E9432FC32C0D612000362862 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				E9432FC12C0D612000362862 /* RuntimeViewerUsingUIKit */,
				E9038F972C31A81F0051B6AC /* RuntimeViewerUsingVision */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		E9038F962C31A81F0051B6AC /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9038FA32C31A8200051B6AC /* Assets.xcassets in Resources */,
				E927C2312E94450700084A7B /* AppIcon.icon in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9432FC02C0D612000362862 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9432FCF2C0D612100362862 /* Assets.xcassets in Resources */,
				E9AA36242C318A7300A9B2E4 /* LaunchScreen.storyboard in Resources */,
				E927C2302E94450700084A7B /* AppIcon.icon in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		E9038F942C31A81F0051B6AC /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E9038FAB2C31A8500051B6AC /* SidebarRootViewController.swift in Sources */,
				E9038FAC2C31A8500051B6AC /* MainSplitViewController.swift in Sources */,
				E9038FAD2C31A8500051B6AC /* ContentCoordinator.swift in Sources */,
				E9038FAE2C31A8500051B6AC /* ContentNavigationController.swift in Sources */,
				E9038FAF2C31A8500051B6AC /* SceneDelegate.swift in Sources */,
				E9038FB02C31A8500051B6AC /* SidebarCoordinator.swift in Sources */,
				E9038FB12C31A8500051B6AC /* Then.swift in Sources */,
				E9038FB22C31A8500051B6AC /* MainViewModel.swift in Sources */,
				E9038FB32C31A8500051B6AC /* InspectorNavigationController.swift in Sources */,
				E96CF52E2EC7848700CBC159 /* XiblessView.swift in Sources */,
				E9038FB42C31A8500051B6AC /* SidebarRuntimeObjectViewController.swift in Sources */,
				E9038FB52C31A8500051B6AC /* AppDelegate.swift in Sources */,
				E9038FB62C31A8500051B6AC /* SidebarNavigationController.swift in Sources */,
				E9038FB72C31A8500051B6AC /* ContentPlaceholderViewController.swift in Sources */,
				E9038FB82C31A8500051B6AC /* ContentTextViewController.swift in Sources */,
				E9038FB92C31A8500051B6AC /* ViewControllers.swift in Sources */,
				E9038FBA2C31A8500051B6AC /* InspectorCoordinator.swift in Sources */,
				E96CF5302EC784C000CBC159 /* Extensions.swift in Sources */,
				E9038FBB2C31A8500051B6AC /* MainCoordinator.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		E9432FBE2C0D612000362862 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				E942AC982C28658A00A2F3D3 /* ContentNavigationController.swift in Sources */,
				E942AC8E2C27CF3400A2F3D3 /* SidebarNavigationController.swift in Sources */,
				E947C39E2C2AB7E400296B2E /* Then.swift in Sources */,
				E95441BC2C26E99400DFFD40 /* MainSplitViewController.swift in Sources */,
				E942AC9C2C2865A300A2F3D3 /* ContentTextViewController.swift in Sources */,
				E942ACA22C2866F400A2F3D3 /* InspectorCoordinator.swift in Sources */,
				E942AC962C28654F00A2F3D3 /* ContentCoordinator.swift in Sources */,
				E942AC8C2C27CF0A00A2F3D3 /* SidebarCoordinator.swift in Sources */,
				E9432FCA2C0D612000362862 /* ViewControllers.swift in Sources */,
				E96CF52D2EC7848700CBC159 /* XiblessView.swift in Sources */,
				E9432FC62C0D612000362862 /* AppDelegate.swift in Sources */,
				E942AC932C28210100A2F3D3 /* SidebarRuntimeObjectViewController.swift in Sources */,
				E942AC772C270C0000A2F3D3 /* MainCoordinator.swift in Sources */,
				E9432FC82C0D612000362862 /* SceneDelegate.swift in Sources */,
				E942AC9A2C28659C00A2F3D3 /* ContentPlaceholderViewController.swift in Sources */,
				E942ACA02C2866E600A2F3D3 /* InspectorNavigationController.swift in Sources */,
				E942AC902C27CF4F00A2F3D3 /* SidebarRootViewController.swift in Sources */,
				E96CF5312EC784C000CBC159 /* Extensions.swift in Sources */,
				E942ACA42C28682C00A2F3D3 /* MainViewModel.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		E9038FA92C31A8200051B6AC /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "";
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(TARGET_NAME)/Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = RuntimeViewer;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.developer-tools";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = dev.JH.RuntimeViewer;
				PRODUCT_NAME = RuntimeViewer;
				SDKROOT = xros;
				SUPPORTED_PLATFORMS = "xros xrsimulator";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,7";
				XROS_DEPLOYMENT_TARGET = 2.0;
			};
			name = Debug;
		};
		E9038FAA2C31A8200051B6AC /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEVELOPMENT_ASSET_PATHS = "";
				ENABLE_PREVIEWS = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "$(TARGET_NAME)/Info.plist";
				INFOPLIST_KEY_CFBundleDisplayName = RuntimeViewer;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.developer-tools";
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewer;
				PRODUCT_NAME = RuntimeViewer;
				SDKROOT = xros;
				SUPPORTED_PLATFORMS = "xros xrsimulator";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,7";
				XROS_DEPLOYMENT_TARGET = 2.0;
			};
			name = Release;
		};
		E9432FD42C0D612100362862 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 17.5;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = "DEBUG $(inherited)";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Debug;
		};
		E9432FD52C0D612100362862 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				DEVELOPMENT_TEAM = D5Q73692VW;
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu17;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 17.5;
				LOCALIZATION_PREFERS_STRING_CATALOGS = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "iphonesimulator iphoneos";
				SWIFT_COMPILATION_MODE = wholemodule;
				VALIDATE_PRODUCT = YES;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Release;
		};
		E9432FD72C0D612100362862 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = RuntimeViewerUsingUIKit/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = RuntimeViewer;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.developer-tools";
				INFOPLIST_KEY_NSLocalNetworkUsageDescription = "RuntimeViewer requires local network permissions to use the Bonjour discovery service";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 18.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = dev.JH.RuntimeViewer;
				PRODUCT_NAME = RuntimeViewer;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "appletvos appletvsimulator iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,3";
				TVOS_DEPLOYMENT_TARGET = 18.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Debug;
		};
		E9432FD82C0D612100362862 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CODE_SIGN_ENTITLEMENTS = RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit.entitlements;
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = RuntimeViewerUsingUIKit/Info.plist;
				INFOPLIST_KEY_CFBundleDisplayName = RuntimeViewer;
				INFOPLIST_KEY_LSApplicationCategoryType = "public.app-category.developer-tools";
				INFOPLIST_KEY_NSLocalNetworkUsageDescription = "RuntimeViewer requires local network permissions to use the Bonjour discovery service";
				INFOPLIST_KEY_UIApplicationSupportsIndirectInputEvents = YES;
				INFOPLIST_KEY_UILaunchStoryboardName = LaunchScreen;
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPad = "UIInterfaceOrientationPortrait UIInterfaceOrientationPortraitUpsideDown UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				INFOPLIST_KEY_UISupportedInterfaceOrientations_iPhone = "UIInterfaceOrientationPortrait UIInterfaceOrientationLandscapeLeft UIInterfaceOrientationLandscapeRight";
				IPHONEOS_DEPLOYMENT_TARGET = 18.0;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.JH.RuntimeViewer;
				PRODUCT_NAME = RuntimeViewer;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = "appletvos appletvsimulator iphoneos iphonesimulator";
				SUPPORTS_MACCATALYST = NO;
				SUPPORTS_MAC_DESIGNED_FOR_IPHONE_IPAD = NO;
				SUPPORTS_XR_DESIGNED_FOR_IPHONE_IPAD = NO;
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,3";
				TVOS_DEPLOYMENT_TARGET = 18.0;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		E9038FA82C31A8200051B6AC /* Build configuration list for PBXNativeTarget "RuntimeViewerUsingVision" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9038FA92C31A8200051B6AC /* Debug */,
				E9038FAA2C31A8200051B6AC /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E9432FBD2C0D612000362862 /* Build configuration list for PBXProject "RuntimeViewerUsingUIKit" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9432FD42C0D612100362862 /* Debug */,
				E9432FD52C0D612100362862 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		E9432FD62C0D612100362862 /* Build configuration list for PBXNativeTarget "RuntimeViewerUsingUIKit" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				E9432FD72C0D612100362862 /* Debug */,
				E9432FD82C0D612100362862 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCSwiftPackageProductDependency section */
		E9038FBC2C31A8810051B6AC /* RuntimeViewerApplication */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerApplication;
		};
		E9038FBE2C31A8810051B6AC /* RuntimeViewerArchitectures */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerArchitectures;
		};
		E9038FC22C31A8810051B6AC /* RuntimeViewerUI */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerUI;
		};
		E942AC892C27556800A2F3D3 /* RuntimeViewerApplication */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerApplication;
		};
		E985A9D52D9AF52E005A573C /* RuntimeViewerCore */ = {
			isa = XCSwiftPackageProductDependency;
			productName = RuntimeViewerCore;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = E9432FBA2C0D612000362862 /* Project object */;
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit.xcodeproj/xcshareddata/xcschemes/RuntimeViewer iOS.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "E9432FC12C0D612000362862"
               BuildableName = "RuntimeViewer.app"
               BlueprintName = "RuntimeViewerUsingUIKit"
               ReferencedContainer = "container:RuntimeViewerUsingUIKit.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E9432FC12C0D612000362862"
            BuildableName = "RuntimeViewer.app"
            BlueprintName = "RuntimeViewerUsingUIKit"
            ReferencedContainer = "container:RuntimeViewerUsingUIKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E9432FC12C0D612000362862"
            BuildableName = "RuntimeViewer.app"
            BlueprintName = "RuntimeViewerUsingUIKit"
            ReferencedContainer = "container:RuntimeViewerUsingUIKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit.xcodeproj/xcshareddata/xcschemes/RuntimeViewer visionOS.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "2620"
   version = "1.7">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES"
      buildArchitectures = "Automatic">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "E9038F972C31A81F0051B6AC"
               BuildableName = "RuntimeViewer.app"
               BlueprintName = "RuntimeViewerUsingVision"
               ReferencedContainer = "container:RuntimeViewerUsingUIKit.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      shouldAutocreateTestPlan = "YES">
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E9038F972C31A81F0051B6AC"
            BuildableName = "RuntimeViewer.app"
            BlueprintName = "RuntimeViewerUsingVision"
            ReferencedContainer = "container:RuntimeViewerUsingUIKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "E9038F972C31A81F0051B6AC"
            BuildableName = "RuntimeViewer.app"
            BlueprintName = "RuntimeViewerUsingVision"
            ReferencedContainer = "container:RuntimeViewerUsingUIKit.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/App/AppDelegate.swift`:

```swift
import UIKit
import RuntimeViewerCore
import RuntimeViewerCommunication

@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    var remoteRuntimeEngine: RuntimeEngine?

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        DispatchQueue.global().async {
            _ = RuntimeEngine.local
        }
        Task {
            remoteRuntimeEngine = try await RuntimeEngine(source: .bonjourServer(name: UIDevice.current.name, identifier: .init(rawValue: UIDevice.current.name)))
        }
        return true
    }

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {}
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/App/SceneDelegate.swift`:

```swift
//
//  SceneDelegate.swift
//  RuntimeViewerUsingUIKit
//
//  Created by JH on 2024/6/3.
//

import UIKit
import RuntimeViewerApplication

class SceneDelegate: UIResponder, UIWindowSceneDelegate, UISplitViewControllerDelegate {
    var window: UIWindow?

    let documentState = DocumentState()

    lazy var mainCoordinator = MainCoordinator(documentState: documentState)

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        guard let windowScene = (scene as? UIWindowScene) else { return }
        let window = UIWindow(windowScene: windowScene)
        window.rootViewController = mainCoordinator.rootViewController
        self.window = window
        mainCoordinator.trigger(.initial)
        window.makeKeyAndVisible()
    }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Assets.xcassets/AccentColor.colorset/Contents.json`:

```json
{
  "colors" : [
    {
      "idiom" : "universal"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Base/ViewControllers.swift`:

```swift
import UIKit
import RuntimeViewerUI
import RuntimeViewerApplication

class UIKitViewController<ViewModel: ViewModelProtocol>: UIViewController {
    var viewModel: ViewModel?

    func setupBindings(for viewModel: ViewModel) {
        self.viewModel = viewModel
    }
}



```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Base/XiblessView.swift`:

```swift
import UIKit

class XiblessView: UIView {
    override init(frame: CGRect) {
        super.init(frame: frame)
    }

    @available(*, unavailable)
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Content/ContentCoordinator.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerApplication
import RuntimeViewerArchitectures

typealias ContentTransition = NavigationTransition

class ContentCoordinator: NavigationCoordinator<ContentRoute> {
    let documentState: DocumentState

    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(rootViewController: .init(nibName: nil, bundle: nil), initialRoute: .placeholder)
    }

    override func prepareTransition(for route: ContentRoute) -> ContentTransition {
        switch route {
        case .placeholder:
            let contentPlaceholderViewController = ContentPlaceholderViewController()
            let contentPlaceholderViewModel = ContentPlaceholderViewModel(documentState: documentState, router: self)
            contentPlaceholderViewController.setupBindings(for: contentPlaceholderViewModel)
            return .set([contentPlaceholderViewController], animation: nil)
        case .root(let runtimeObjectType):
            let contentTextViewController = ContentTextViewController()
            let contentTextViewModel = ContentTextViewModel(runtimeObject: runtimeObjectType, documentState: documentState, router: self)
            contentTextViewController.setupBindings(for: contentTextViewModel)
            return .set([contentTextViewController], animation: .default)
        case .next(let runtimeObjectType):
            let contentTextViewController = ContentTextViewController()
            let contentTextViewModel = ContentTextViewModel(runtimeObject: runtimeObjectType, documentState: documentState, router: self)
            contentTextViewController.setupBindings(for: contentTextViewModel)
            return .push(contentTextViewController, animation: .default)
        case .back:
            return .pop(animation: .default)
        }
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Content/ContentNavigationController.swift`:

```swift
#if canImport(UIKit)

import UIKit

class ContentNavigationController: UINavigationController {}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Content/ContentPlaceholderViewController.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

class ContentPlaceholderViewController: UIKitViewController<ContentPlaceholderViewModel> {
    let placeholerLabel = UILabel()

    override func viewDidLoad() {
        super.viewDidLoad()

        if #available(iOS 17.0, tvOS 17.0, *) {
            var contentUnavailableConfiguration = UIContentUnavailableConfiguration.empty()
            contentUnavailableConfiguration.text = "Select a runtime object"
            contentUnavailableConfiguration.textProperties.font = .systemFont(ofSize: 25, weight: .regular)
            contentUnavailableConfiguration.textProperties.color = .secondaryLabel
            self.contentUnavailableConfiguration = contentUnavailableConfiguration
        } else {
            hierarchy {
                placeholerLabel
            }

            placeholerLabel.snp.makeConstraints { make in
                make.center.equalToSuperview()
            }

            placeholerLabel.do {
                $0.text = "Select a runtime object"
                $0.font = .systemFont(ofSize: 25, weight: .regular)
                $0.textColor = .secondaryLabel
            }
        }
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Content/ContentTextViewController.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

class ContentTextViewController: UIKitViewController<ContentTextViewModel> {
    let textView = UITextView()

    let runtimeObjectClicked = PublishRelay<RuntimeObject>()

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            textView
        }

        textView.snp.makeConstraints { make in
            make.edges.equalTo(view.safeAreaLayoutGuide)
        }

        textView.do {
            $0.isSelectable = true
            #if !os(tvOS)
            $0.isEditable = false
            #endif
            $0.linkTextAttributes = [:]
            $0.delegate = self
            $0.textContainerInset = .init(top: 0, left: 15, bottom: 0, right: 15)
        }
    }

    override func setupBindings(for viewModel: ContentTextViewModel) {
        super.setupBindings(for: viewModel)
        let input = ContentTextViewModel.Input(runtimeObjectClicked: runtimeObjectClicked.asSignal())
        let output = viewModel.transform(input)

        output.attributedString.drive(textView.rx.attributedText).disposed(by: rx.disposeBag)
        output.runtimeObjectName.drive(navigationItem.rx.title).disposed(by: rx.disposeBag)
    }
}

extension ContentTextViewController: UITextViewDelegate {
//    #if !os(tvOS)
//    @available(iOS 17.0, *)
//    func textView(_ textView: UITextView, primaryActionFor textItem: UITextItem, defaultAction: UIAction) -> UIAction? {
//        return UIAction { _ in
//            print(textItem.content)
//        }
//    }
//
//    @available(iOS 17.0, *)
//    func textView(_ textView: UITextView, menuConfigurationFor textItem: UITextItem, defaultMenu: UIMenu) -> UITextItem.MenuConfiguration? {
//        switch textItem.content {
//        case .link(let url):
//            let jumpToDefinitionAction = UIAction(title: "Jump to Definition") { [weak self] _ in
//                guard let self = self else { return }
////                #warning("RuntimeObjectType is not used in this context, consider using RuntimeObject")
//                if let scheme = url.scheme, let host = url.host {
////                    var runtimeObject: RuntimeObjCRuntimeObject?
////                    switch scheme {
////                    case "class":
////                        runtimeObject = .class(named: host)
////                    case "protocol":
////                        runtimeObject = .protocol(named: host)
////                    default:
////                        break
////                    }
////                    if let runtimeObject {
////                        runtimeObjectClicked.accept(runtimeObject)
////                    }
//                }
//            }
//            return .init(menu: UIMenu(children: [jumpToDefinitionAction]))
//        default:
//            return nil
//        }
//    }
//    #endif
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationSupportsMultipleScenes</key>
		<false/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Inspector/InspectorCoordinator.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

typealias InspectorTransition = Transition<InspectorViewController>

class InspectorCoordinator: BaseCoordinator<InspectorRoute, InspectorTransition> {
    let documentState: DocumentState
    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(rootViewController: .init(nibName: nil, bundle: nil), initialRoute: .placeholder)
    }

    override func prepareTransition(for route: InspectorRoute) -> InspectorTransition {
        switch route {
        case .placeholder:
            let viewModel = InspectorPlaceholderViewModel(documentState: documentState, router: self)
            let viewController = InspectorPlaceholderViewController()
            viewController.setupBindings(for: viewModel)
            return .set([viewController])
        default:
            return .none()
        }
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Inspector/InspectorNavigationController.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerArchitectures
import RuntimeViewerApplication

class InspectorViewController: UITabBarController {}

class InspectorPlaceholderViewController: UIKitViewController<InspectorPlaceholderViewModel> {}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/LaunchScreen.storyboard`:

```storyboard
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="13122.16" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="13104.12"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="375" height="667"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" xcode11CocoaTouchSystemColor="systemBackgroundColor" cocoaTouchSystemColor="whiteColor"/>
                        <viewLayoutGuide key="safeArea" id="6Tk-OE-BBY"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
</document>

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Main/MainCoordinator.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

public enum MainRoute: Routable {
    case initial
    case select(RuntimeObject)
    case inspect(InspectableObject)
}

typealias MainTransition = Transition<MainSplitViewController>

class MainCoordinator: BaseCoordinator<MainRoute, MainTransition> {
    let documentState: DocumentState

    let completeTransition: PublishRelay<SidebarRoute> = .init()

    lazy var sidebarCoordinator = SidebarCoordinator(documentState: documentState, delegate: self)

    lazy var contentCoordinator = ContentCoordinator(documentState: documentState)

    lazy var compactSidebarCoordinator = SidebarCoordinator(documentState: documentState, delegate: self)

    lazy var inspectorCoordinator = InspectorCoordinator(documentState: documentState)

    init(documentState: DocumentState) {
        self.documentState = documentState
        super.init(rootViewController: .init(style: .doubleColumn), initialRoute: nil)
        rootViewController.delegate = self
    }

    override func prepareTransition(for route: MainRoute) -> MainTransition {
        switch route {
        case .initial:
            let viewModel = MainViewModel(documentState: documentState, router: self)
            rootViewController.setupBindings(for: viewModel)
            return .multiple(.set(sidebarCoordinator, for: .primary), .set(contentCoordinator, for: .secondary))
        case .select(let runtimeObject):
            return .multiple(.route(.root(runtimeObject), on: contentCoordinator), .show(column: .secondary))
        case .inspect(let inspectableType):
            return .route(.root(inspectableType), on: inspectorCoordinator)
        }
    }

    override func completeTransition(for route: MainRoute) {}
}

extension MainCoordinator: UISplitViewControllerDelegate {
    func splitViewController(_ svc: UISplitViewController, topColumnForCollapsingToProposedTopColumn proposedTopColumn: UISplitViewController.Column) -> UISplitViewController.Column {
        return .primary
    }

    func splitViewControllerDidCollapse(_ svc: UISplitViewController) {}
}

extension MainCoordinator: SidebarCoordinatorDelegate {
    func sidebarCoordinator(_ sidebarCoordinator: SidebarCoordinator, completeTransition route: SidebarRoute) {
        switch route {
        case .selectedNode(let runtimeNamedNode):
            inspectorCoordinator.trigger(.root(.node(runtimeNamedNode)))
        case .clickedNode /* (let runtimeNamedNode) */:
            break
        case .selectedObject(let runtimeObjectType):
            trigger(.select(runtimeObjectType), with: .init(animated: false))
        case .back:
            contentCoordinator.trigger(.placeholder)
        default:
            break
        }
        completeTransition.accept(route)
    }
}

@MainActor
extension Transition where RootViewController: UISplitViewController {
    @available(iOS 14, tvOS 14, *)
    public static func show(column: UISplitViewController.Column) -> Transition {
        Transition {
            SplitShowColumn(column)
        }
    }
}

@MainActor
@available(iOS 14, tvOS 14, *)
public struct SplitShowColumn<RootViewController> {
    // MARK: Stored Properties

    private let column: UISplitViewController.Column

    // MARK: Initialization

    public init(_ column: UISplitViewController.Column) {
        self.column = column
    }
}

@available(iOS 14, tvOS 14, *)
extension SplitShowColumn: TransitionComponent where RootViewController: UISplitViewController {
    public func build() -> Transition<RootViewController> {
        return Transition(presentables: [], animationInUse: nil) { rootViewController, _, completion in
            rootViewController.show(column)
            completion?()
        }
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Main/MainSplitViewController.swift`:

```swift
#if canImport(UIKit)

import UIKit

class MainSplitViewController: UISplitViewController {
    var viewModel: MainViewModel?

    func setupBindings(for viewModel: MainViewModel) {
        self.viewModel = viewModel
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        view.backgroundColor = .systemBackground
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Main/MainViewModel.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerApplication
import RuntimeViewerArchitectures

class MainViewModel: ViewModel<MainRoute> {}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit.entitlements`:

```entitlements
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.security.app-sandbox</key>
	<true/>
	<key>com.apple.security.network.client</key>
	<true/>
</dict>
</plist>

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Sidebar/SidebarCoordinator.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

protocol SidebarCoordinatorDelegate: AnyObject {
    func sidebarCoordinator(_ sidebarCoordinator: SidebarCoordinator, completeTransition: SidebarRoute)
}

typealias SidebarTransition = NavigationTransition

class SidebarCoordinator: NavigationCoordinator<SidebarRoute> {
    let documentState: DocumentState

    weak var coordinatorDelegate: SidebarCoordinatorDelegate?

    init(documentState: DocumentState, delegate: SidebarCoordinatorDelegate? = nil) {
        self.documentState = documentState
        self.coordinatorDelegate = delegate
        super.init(rootViewController: .init(nibName: nil, bundle: nil), initialRoute: .root)
    }

    override func prepareTransition(for route: SidebarRoute) -> SidebarTransition {
        switch route {
        case .root:
            let viewController = SidebarRootViewController()
            let viewModel = SidebarRootDirectoryViewModel(documentState: documentState, router: self)
            viewController.setupBindings(for: viewModel)
            return .set([viewController], animation: nil)
        case let .clickedNode(clickedNode):
            let viewController = SidebarRuntimeObjectViewController()
            let viewModel = SidebarRuntimeObjectListViewModel(imageNode: clickedNode, documentState: documentState, router: self)
            viewController.setupBindings(for: viewModel)
            return .push(viewController, animation: .default)
        case .back:
            return .pop(animation: .default)
        default:
            return .none()
        }
    }

    override func completeTransition(for route: SidebarRoute) {
        coordinatorDelegate?.sidebarCoordinator(self, completeTransition: route)
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Sidebar/SidebarNavigationController.swift`:

```swift
#if canImport(UIKit)

import UIKit

class SidebarNavigationController: UINavigationController {}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Sidebar/SidebarRootViewController.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

class SidebarRootViewController<ViewModel: SidebarRootViewModel>: UIKitViewController<ViewModel> {
    let collectionView: UICollectionView = {
        #if os(tvOS)
        var configuration = UICollectionLayoutListConfiguration(appearance: .grouped)
        #else
        var configuration = UICollectionLayoutListConfiguration(appearance: .sidebar)
        #endif
        if #available(iOS 26.0, *) {
            configuration.backgroundColor = .clear
        } else {
            configuration.backgroundColor = UIDevice.current.userInterfaceIdiom == .phone ? .systemBackground : .secondarySystemBackground
        }
        let collectionView = UICollectionView(frame: .zero, collectionViewLayout: UICollectionViewCompositionalLayout.list(using: configuration))
        return collectionView
    }()

    #if os(tvOS)
    let searchBar = UISearchBar.make()
    #else
    let searchBar = UISearchBar()
    #endif

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
//            searchBar
            collectionView
        }

//        searchBar.snp.makeConstraints { make in
//            make.top.equalTo(view.safeAreaLayoutGuide)
//            make.left.right.equalTo(view.safeAreaLayoutGuide).inset(15)
//        }

        collectionView.snp.makeConstraints { make in
//            make.top.equalTo(searchBar.snp.bottom)
            make.top.equalTo(view.safeAreaLayoutGuide)
            make.bottom.equalTo(view.safeAreaLayoutGuide)
            make.leading.trailing.equalToSuperview()
        }

        searchBar.do {
            $0.backgroundImage = .image(withColor: .clear)
        }

        if #unavailable(iOS 26.0) {
            if traitCollection.userInterfaceIdiom == .phone {
                view.backgroundColor = .systemBackground
                collectionView.backgroundColor = .systemBackground
            } else {
                view.backgroundColor = .secondarySystemBackground
                collectionView.backgroundColor = .secondarySystemBackground
            }
        }
    }

    override func setupBindings(for viewModel: ViewModel) {
        super.setupBindings(for: viewModel)

        let input = ViewModel.Input(clickedNode: collectionView.rx.modelSelected(SidebarRootCellViewModel.self).asSignal(), selectedNode: .never(), searchString: searchBar.rx.text.asSignalOnErrorJustComplete().filterNil())

        let output = viewModel.transform(input)

        output.nodes.drive(collectionView.rx.nodes(source:)) { (collectionView: UICollectionView, indexPath: IndexPath, viewModel: SidebarRootCellViewModel, cell: UICollectionViewListCell) in
            var content = cell.defaultContentConfiguration()
            content.textProperties.allowsDefaultTighteningForTruncation = false
            content.attributedText = viewModel.name
            content.image = viewModel.icon
            cell.contentConfiguration = content
            cell.indentationWidth = 8
        }
        .disposed(by: rx.disposeBag)

        output.nodes.map { Optional.some($0) }.drive(collectionView.rx.filteredNodes).disposed(by: rx.disposeBag)
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Sidebar/SidebarRuntimeObjectViewController.swift`:

```swift
#if canImport(UIKit)

import UIKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerApplication
import RuntimeViewerArchitectures

class SidebarRuntimeObjectViewController<ViewModel: SidebarRuntimeObjectViewModel>: UIKitViewController<ViewModel> {
    @MagicViewLoading
    var imageTabBarController = UITabBarController()

    let imageNotLoadedView = ImageLoadableView()

    let imageLoadingView = ImageLoadingView()

    let imageLoadedView = ImageLoadedView()

    let imageLoadErrorView = ImageLoadableView()

    override func viewDidLoad() {
        super.viewDidLoad()

        hierarchy {
            imageTabBarController
        }

        imageTabBarController.view.snp.makeConstraints { make in
            make.edges.equalTo(view.safeAreaLayoutGuide)
        }

        if #available(iOS 18.0, *) {
            imageTabBarController.isTabBarHidden = true
        } else {
            imageTabBarController.tabBar.isHidden = true
        }

        imageTabBarController.view.backgroundColor = .clear

        imageTabBarController.viewControllers = [
            UIViewController(view: imageNotLoadedView),
            UIViewController(view: imageLoadingView),
            UIViewController(view: imageLoadedView),
            UIViewController(view: imageLoadErrorView),
        ]

        if #unavailable(iOS 26.0) {
            if traitCollection.userInterfaceIdiom == .phone {
                view.backgroundColor = .systemBackground
            } else {
                view.backgroundColor = .secondarySystemBackground
            }
        }
    }

    override func setupBindings(for viewModel: ViewModel) {
        super.setupBindings(for: viewModel)
        let input = ViewModel.Input(
            runtimeObjectClicked: imageLoadedView.listView.rx.modelSelected(SidebarRuntimeObjectCellViewModel.self).asSignal(),
            loadImageClicked: Signal.of(
                imageNotLoadedView.loadImageButton.rx.tap.asSignal(),
                imageLoadErrorView.loadImageButton.rx.tap.asSignal()
            ).merge(),
            searchString: imageLoadedView.searchBar.rx.text.asSignalOnErrorJustComplete().filterNil(),
            isSearchCaseInsensitive: nil
        )

        let output = viewModel.transform(input)
        let listCellRegistration = UICollectionView.CellRegistration<UICollectionViewListCell, SidebarRuntimeObjectCellViewModel> { cell, indexPath, viewModel in
            var content = cell.defaultContentConfiguration()
            content.textProperties.allowsDefaultTighteningForTruncation = false
            content.attributedText = viewModel.name
            content.image = viewModel.primaryIcon

            cell.contentConfiguration = content
        }

        output.runtimeObjects.drive(imageLoadedView.listView.rx.items) { collectionView, index, viewModel -> UICollectionViewCell in
            collectionView.dequeueConfiguredReusableCell(using: listCellRegistration, for: IndexPath(item: index, section: 0), item: viewModel)
        }
        .disposed(by: rx.disposeBag)

        output.errorText.drive(imageLoadErrorView.titleLabel.rx.text).disposed(by: rx.disposeBag)

        output.notLoadedText.drive(imageNotLoadedView.titleLabel.rx.text).disposed(by: rx.disposeBag)

        output.emptyText.drive(imageLoadedView.emptyLabel.rx.text).disposed(by: rx.disposeBag)

        output.isEmpty.drive(imageLoadedView.searchBar.rx.isHidden).disposed(by: rx.disposeBag)

        output.isEmpty.not().drive(imageLoadedView.emptyLabel.rx.isHidden).disposed(by: rx.disposeBag)

        output.loadState.map { $0.index }.drive(imageTabBarController.rx.selectedIndex).disposed(by: rx.disposeBag)
    }
}

extension RuntimeImageLoadState {
    var index: Int {
        switch self {
        case .notLoaded:
            0
        case .loading:
            1
        case .loaded:
            2
        case .loadError:
            3
        case .unknown:
            4
        }
    }
}

extension SidebarRuntimeObjectViewController {
    class ImageLoadingView: XiblessView {
        let loadingIndicator: MaterialLoadingIndicator = .init(radius: 25, color: .tintColor)

        override init(frame frameRect: CGRect) {
            super.init(frame: frameRect)

            hierarchy {
                loadingIndicator
            }

            loadingIndicator.snp.makeConstraints { make in
                make.center.equalToSuperview()
                make.size.equalTo(50)
            }

            loadingIndicator.startAnimating()
        }
    }

    class ImageLoadedView: XiblessView {
        #if os(tvOS)
        let searchBar = UISearchBar.make()
        #else
        let searchBar = UISearchBar()
        #endif

        let listView: UICollectionView = {
            #if os(tvOS)
            var configuration = UICollectionLayoutListConfiguration(appearance: .grouped)
            #else
            var configuration = UICollectionLayoutListConfiguration(appearance: .sidebar)
            #endif
            if #available(iOS 26.0, *) {
                configuration.backgroundColor = .clear
            } else {
                configuration.backgroundColor = UIDevice.current.userInterfaceIdiom == .phone ? .systemBackground : .secondarySystemBackground
            }
            let collectionView = UICollectionView(frame: .zero, collectionViewLayout: UICollectionViewCompositionalLayout.list(using: configuration))
            return collectionView
        }()

        let emptyLabel = UILabel()

        override init(frame: CGRect) {
            super.init(frame: frame)

            hierarchy {
                searchBar
                listView
                emptyLabel
            }

            searchBar.snp.makeConstraints { make in
                make.top.equalToSuperview()
                make.left.right.equalToSuperview().inset(15)
            }

            listView.snp.makeConstraints { make in
                make.top.equalTo(searchBar.snp.bottom)
                make.bottom.left.right.equalToSuperview().inset(15)
            }

            emptyLabel.snp.makeConstraints { make in
                make.center.equalToSuperview()
                make.left.right.equalToSuperview().inset(15)
            }

            emptyLabel.do {
                $0.textAlignment = .center
                $0.numberOfLines = 0
            }

            searchBar.do {
                $0.backgroundImage = .image(withColor: .clear)
            }
        }
    }

    class ImageLoadableView: XiblessView {
        let titleLabel = UILabel()

        let loadImageButton = UIButton(type: .system)

        lazy var contentView = VStackView(alignment: .vStackCenter, spacing: 10) {
            titleLabel
            loadImageButton
        }

        override init(frame frameRect: CGRect) {
            super.init(frame: frameRect)

            hierarchy {
                contentView
            }

            contentView.snp.makeConstraints { make in
                make.center.equalToSuperview()
                make.width.equalTo(200)
            }

            titleLabel.do {
                $0.textAlignment = .center
                $0.numberOfLines = 0
            }

            loadImageButton.do {
                $0.configuration = .tinted()
                $0.setTitle("Load now", for: .normal)
            }
        }
    }
}

#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Utils/Extensions.swift`:

```swift
import UIKit

extension UIViewController {
    convenience init(view: UIView) {
        self.init()
        self.view = view
    }
}

extension UIImage {
    static func image(withColor color: UIColor, size: CGSize = CGSize(width: 1, height: 1)) -> UIImage {
        let renderer = UIGraphicsImageRenderer(size: size)
        return renderer.image { context in
            color.setFill()
            context.fill(CGRect(origin: .zero, size: size))
        }
    }
}

#if os(tvOS)
extension UIColor {
    static var systemBackground: UIColor {
        .init { traitCollection in
            traitCollection.userInterfaceStyle == .light ? "#FFFFFFFF".uiColor : "#000000FF".uiColor
        }
    }

    static var secondarySystemBackground: UIColor {
        .init { traitCollection in
            traitCollection.userInterfaceStyle == .light ? "#F2F2F7FF".uiColor : "#1C1C1EFF".uiColor
        }
    }
}

extension UISearchBar {
    static func make() -> UISearchBar {
        let UISearchBarClass = NSClassFromString("UISearchBar") as! UIView.Type
        return UISearchBarClass.init(frame: .zero) as! UISearchBar
    }
}

#endif

#if os(tvOS)
import RxSwift
import RxCocoa

extension Reactive where Base: UIButton {
    /// Reactive wrapper for target action pattern on `self`.
    public var tap: ControlEvent<Void> {
        primaryAction
    }
}
#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingUIKit/Utils/Then.swift`:

```swift
// The MIT License (MIT)
//
// Copyright (c) 2015 Suyeol Jeon (xoul.kr)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

import Foundation
#if !os(Linux)
import CoreGraphics
#endif

#if os(macOS) && !targetEnvironment(macCatalyst)
import AppKit
#endif

#if os(iOS) || os(tvOS)
import UIKit.UIGeometry
#endif

protocol Then {}

extension Then where Self: Any {
    /// Makes it available to set properties with closures just after initializing and copying the value types.
    ///
    ///     let frame = CGRect().with {
    ///       $0.origin.x = 10
    ///       $0.size.width = 100
    ///     }
    @inlinable
    func with(_ block: (inout Self) throws -> Void) rethrows -> Self {
        var copy = self
        try block(&copy)
        return copy
    }

    /// Makes it available to execute something with closures.
    ///
    ///     UserDefaults.standard.do {
    ///       $0.set("devxoul", forKey: "username")
    ///       $0.set("devxoul@gmail.com", forKey: "email")
    ///       $0.synchronize()
    ///     }
    @inlinable
    func `do`(_ block: (Self) throws -> Void) rethrows {
        try block(self)
    }
}

extension Then where Self: AnyObject {
    /// Makes it available to set properties with closures just after initializing.
    ///
    ///     let label = UILabel().then {
    ///       $0.textAlignment = .center
    ///       $0.textColor = UIColor.black
    ///       $0.text = "Hello, World!"
    ///     }
    @inlinable
    @discardableResult
    func then(_ block: @Sendable (Self) throws -> Void) rethrows -> Self {
        try block(self)
        return self
    }
}

extension Then {
    @inlinable
    func `as`<T>(_ transform: (Self) throws -> T) rethrows -> T {
        try transform(self)
    }
}


extension NSObject: Then {}

#if !os(Linux)
extension CGPoint: Then {}
extension CGRect: Then {}
extension CGSize: Then {}
extension CGVector: Then {}
#endif

extension Array: Then {}
extension Dictionary: Then {}
extension Set: Then {}
extension JSONDecoder: Then {}
extension JSONEncoder: Then {}


#if os(macOS) && !targetEnvironment(macCatalyst)
extension NSEdgeInsets: Then {}
extension NSRectEdge: Then {}
#endif

#if os(iOS) || os(tvOS)
extension UIEdgeInsets: Then {}
extension UIOffset: Then {}
extension UIRectEdge: Then {}
#endif

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/AppIcon.solidimagestack/Back.solidimagestacklayer/Content.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Rectangle 108.png",
      "idiom" : "vision",
      "scale" : "2x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/AppIcon.solidimagestack/Back.solidimagestacklayer/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/AppIcon.solidimagestack/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  },
  "layers" : [
    {
      "filename" : "Front.solidimagestacklayer"
    },
    {
      "filename" : "Middle.solidimagestacklayer"
    },
    {
      "filename" : "Back.solidimagestacklayer"
    }
  ]
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/AppIcon.solidimagestack/Front.solidimagestacklayer/Content.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Frame 122.png",
      "idiom" : "vision",
      "scale" : "2x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/AppIcon.solidimagestack/Front.solidimagestacklayer/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/AppIcon.solidimagestack/Middle.solidimagestacklayer/Content.imageset/Contents.json`:

```json
{
  "images" : [
    {
      "filename" : "Frame 124.png",
      "idiom" : "vision",
      "scale" : "2x"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/AppIcon.solidimagestack/Middle.solidimagestacklayer/Contents.json`:

```json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Assets.xcassets/Contents.json`:

```json
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
```

`RuntimeViewerUsingUIKit/RuntimeViewerUsingVision/Info.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>UIApplicationSceneManifest</key>
	<dict>
		<key>UIApplicationPreferredDefaultSceneSessionRole</key>
		<string>UIWindowSceneSessionRoleApplication</string>
		<key>UIApplicationSupportsMultipleScenes</key>
		<true/>
		<key>UISceneConfigurations</key>
		<dict>
			<key>UIWindowSceneSessionRoleApplication</key>
			<array>
				<dict>
					<key>UISceneConfigurationName</key>
					<string>Default Configuration</string>
					<key>UISceneDelegateClassName</key>
					<string>$(PRODUCT_MODULE_NAME).SceneDelegate</string>
				</dict>
			</array>
		</dict>
	</dict>
</dict>
</plist>

```

`docs/plans/2026-02-16-interface-export-design.md`:

```md
# Interface Export Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add unified ObjC/Swift interface export API to RuntimeViewerCore with progress reporting via AsyncStream.

**Architecture:** All export types live in RuntimeViewerCore under a new `Export/` directory. A unified `RuntimeInterfaceExportEvent` enum reports progress through `AsyncStream`. RuntimeEngine gets new `exportInterface` (single) and `exportInterfaces` (batch) methods that delegate to existing `interface(for:options:)` and `objects(in:)`.

**Tech Stack:** Swift 5 mode, Swift Concurrency (actors, AsyncStream), SemanticString from Semantic framework. No new dependencies.

**Compatibility Note:** RuntimeViewerCore targets macOS 10.15+. Use `AsyncStream { continuation in }` init (not `.makeStream()`), and `TimeInterval` (not `Duration`/`ContinuousClock`).

---

### Task 1: Create RuntimeInterfaceExportEvent and RuntimeInterfaceExportResult

**Files:**
- Create: `RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportEvent.swift`

**Step 1: Create the Export directory and event file**

```swift
import Foundation
import Semantic

public enum RuntimeInterfaceExportEvent: Sendable {
    case phaseStarted(Phase)
    case phaseCompleted(Phase)
    case phaseFailed(Phase, any Error)

    case objectStarted(RuntimeObject, current: Int, total: Int)
    case objectCompleted(RuntimeObject, SemanticString)
    case objectFailed(RuntimeObject, any Error)

    case completed(RuntimeInterfaceExportResult)

    public enum Phase: Sendable {
        case preparing
        case exporting
        case writing
    }
}

public struct RuntimeInterfaceExportResult: Sendable {
    public let succeeded: Int
    public let failed: Int
    public let totalDuration: TimeInterval
    public let objcCount: Int
    public let swiftCount: Int

    public init(succeeded: Int, failed: Int, totalDuration: TimeInterval, objcCount: Int, swiftCount: Int) {
        self.succeeded = succeeded
        self.failed = failed
        self.totalDuration = totalDuration
        self.objcCount = objcCount
        self.swiftCount = swiftCount
    }
}
```

**Step 2: Build to verify**

Run: `cd /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewerCore && swift build 2>&1 | xcsift`

**Step 3: Commit**

```
feat: Add RuntimeInterfaceExportEvent and RuntimeInterfaceExportResult
```

---

### Task 2: Create RuntimeInterfaceExportReporter

**Files:**
- Create: `RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportReporter.swift`

**Step 1: Create the reporter**

```swift
import Foundation

public final class RuntimeInterfaceExportReporter: Sendable {
    public let events: AsyncStream<RuntimeInterfaceExportEvent>
    private let continuation: AsyncStream<RuntimeInterfaceExportEvent>.Continuation

    public init() {
        var cont: AsyncStream<RuntimeInterfaceExportEvent>.Continuation!
        self.events = AsyncStream { cont = $0 }
        self.continuation = cont
    }

    func send(_ event: RuntimeInterfaceExportEvent) {
        continuation.yield(event)
    }

    func finish() {
        continuation.finish()
    }
}
```

**Step 2: Build to verify**

Run: `cd /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewerCore && swift build 2>&1 | xcsift`

**Step 3: Commit**

```
feat: Add RuntimeInterfaceExportReporter with AsyncStream
```

---

### Task 3: Create RuntimeInterfaceExportConfiguration

**Files:**
- Create: `RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportConfiguration.swift`

**Step 1: Create the configuration**

```swift
import Foundation

public struct RuntimeInterfaceExportConfiguration: Sendable {
    public let scope: Scope
    public let format: Format
    public let generationOptions: RuntimeObjectInterface.GenerationOptions

    public init(scope: Scope, format: Format, generationOptions: RuntimeObjectInterface.GenerationOptions) {
        self.scope = scope
        self.format = format
        self.generationOptions = generationOptions
    }

    public enum Scope: Sendable {
        case singleObject(RuntimeObject)
        case image(String)
    }

    public enum Format: Sendable {
        case singleFile
        case directory
    }
}
```

**Step 2: Build to verify**

Run: `cd /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewerCore && swift build 2>&1 | xcsift`

**Step 3: Commit**

```
feat: Add RuntimeInterfaceExportConfiguration
```

---

### Task 4: Create RuntimeInterfaceExportItem and RuntimeObject+Export

**Files:**
- Create: `RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportItem.swift`
- Create: `RuntimeViewerCore/Sources/RuntimeViewerCore/Common/RuntimeObject+Export.swift`

**Step 1: Create the export item**

```swift
import Foundation

public struct RuntimeInterfaceExportItem: Sendable {
    public let object: RuntimeObject
    public let plainText: String
    public let suggestedFileName: String

    public init(object: RuntimeObject, plainText: String, suggestedFileName: String) {
        self.object = object
        self.plainText = plainText
        self.suggestedFileName = suggestedFileName
    }

    public var fileExtension: String {
        switch object.kind {
        case .swift: return "swiftinterface"
        case .objc, .c: return "h"
        }
    }

    public var isSwift: Bool {
        if case .swift = object.kind { return true }
        return false
    }
}
```

**Step 2: Create the RuntimeObject export extension**

```swift
import Foundation

extension RuntimeObject {
    public var exportFileName: String {
        let sanitized = displayName
            .replacingOccurrences(of: "/", with: "_")
            .replacingOccurrences(of: ":", with: "_")
        switch kind {
        case .swift:
            return "\(sanitized).swiftinterface"
        case .objc, .c:
            return "\(sanitized).h"
        }
    }
}
```

**Step 3: Build to verify**

Run: `cd /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewerCore && swift build 2>&1 | xcsift`

**Step 4: Commit**

```
feat: Add RuntimeInterfaceExportItem and RuntimeObject.exportFileName
```

---

### Task 5: Create RuntimeInterfaceExportWriter

**Files:**
- Create: `RuntimeViewerCore/Sources/RuntimeViewerCore/Export/RuntimeInterfaceExportWriter.swift`

**Step 1: Create the writer**

```swift
import Foundation

public enum RuntimeInterfaceExportWriter {
    public static func writeSingleFile(
        items: [RuntimeInterfaceExportItem],
        to directory: URL,
        imageName: String,
        reporter: RuntimeInterfaceExportReporter
    ) throws {
        reporter.send(.phaseStarted(.writing))

        let objcItems = items.filter { !$0.isSwift }
        let swiftItems = items.filter { $0.isSwift }

        if !objcItems.isEmpty {
            let combined = objcItems.map(\.plainText).joined(separator: "\n\n")
            let file = directory.appendingPathComponent("\(imageName).h")
            try combined.write(to: file, atomically: true, encoding: .utf8)
        }

        if !swiftItems.isEmpty {
            let combined = swiftItems.map(\.plainText).joined(separator: "\n\n")
            let file = directory.appendingPathComponent("\(imageName).swiftinterface")
            try combined.write(to: file, atomically: true, encoding: .utf8)
        }

        reporter.send(.phaseCompleted(.writing))
    }

    public static func writeDirectory(
        items: [RuntimeInterfaceExportItem],
        to directory: URL,
        reporter: RuntimeInterfaceExportReporter
    ) throws {
        reporter.send(.phaseStarted(.writing))

        let objcItems = items.filter { !$0.isSwift }
        let swiftItems = items.filter { $0.isSwift }

        if !objcItems.isEmpty {
            let objcDir = directory.appendingPathComponent("ObjCHeaders")
            try FileManager.default.createDirectory(at: objcDir, withIntermediateDirectories: true)
            for item in objcItems {
                let file = objcDir.appendingPathComponent(item.suggestedFileName)
                try item.plainText.write(to: file, atomically: true, encoding: .utf8)
            }
        }

        if !swiftItems.isEmpty {
            let swiftDir = directory.appendingPathComponent("SwiftInterfaces")
            try FileManager.default.createDirectory(at: swiftDir, withIntermediateDirectories: true)
            for item in swiftItems {
                let file = swiftDir.appendingPathComponent(item.suggestedFileName)
                try item.plainText.write(to: file, atomically: true, encoding: .utf8)
            }
        }

        reporter.send(.phaseCompleted(.writing))
    }
}
```

**Step 2: Build to verify**

Run: `cd /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewerCore && swift build 2>&1 | xcsift`

**Step 3: Commit**

```
feat: Add RuntimeInterfaceExportWriter for single-file and directory export
```

---

### Task 6: Add export methods to RuntimeEngine

**Files:**
- Modify: `RuntimeViewerCore/Sources/RuntimeViewerCore/RuntimeEngine.swift` (add extension at end of file, after line 444)

**Step 1: Add export extension to RuntimeEngine**

Append after the existing `RuntimeConnection` extension (end of file):

```swift
// MARK: - Export

extension RuntimeEngine {
    public enum RuntimeExportError: Error {
        case interfaceGenerationFailed(RuntimeObject)
    }

    public func exportInterface(
        for object: RuntimeObject,
        options: RuntimeObjectInterface.GenerationOptions
    ) async throws -> RuntimeInterfaceExportItem {
        guard let runtimeInterface = try await interface(for: object, options: options) else {
            throw RuntimeExportError.interfaceGenerationFailed(object)
        }
        return RuntimeInterfaceExportItem(
            object: object,
            plainText: runtimeInterface.interfaceString.string,
            suggestedFileName: object.exportFileName
        )
    }

    public func exportInterfaces(
        in imagePath: String,
        options: RuntimeObjectInterface.GenerationOptions,
        reporter: RuntimeInterfaceExportReporter
    ) async throws -> [RuntimeInterfaceExportItem] {
        let startTime = CFAbsoluteTimeGetCurrent()

        reporter.send(.phaseStarted(.preparing))
        let allObjects = try await objects(in: imagePath)
        reporter.send(.phaseCompleted(.preparing))

        reporter.send(.phaseStarted(.exporting))
        var results: [RuntimeInterfaceExportItem] = []
        var succeeded = 0
        var failed = 0
        var objcCount = 0
        var swiftCount = 0
        let total = allObjects.count

        for (index, object) in allObjects.enumerated() {
            reporter.send(.objectStarted(object, current: index + 1, total: total))
            do {
                let item = try await exportInterface(for: object, options: options)
                results.append(item)
                succeeded += 1
                if item.isSwift { swiftCount += 1 } else { objcCount += 1 }
                reporter.send(.objectCompleted(object, runtimeInterface.interfaceString))
            } catch {
                failed += 1
                reporter.send(.objectFailed(object, error))
            }
        }
        reporter.send(.phaseCompleted(.exporting))

        let duration = CFAbsoluteTimeGetCurrent() - startTime
        let result = RuntimeInterfaceExportResult(
            succeeded: succeeded,
            failed: failed,
            totalDuration: duration,
            objcCount: objcCount,
            swiftCount: swiftCount
        )
        reporter.send(.completed(result))
        reporter.finish()
        return results
    }
}
```

**Important:** The `exportInterfaces` method has a bug in the design â€” `runtimeInterface` is not in scope inside the loop. Fix: call `interface(for:options:)` directly instead of going through `exportInterface`, or restructure to capture the SemanticString.

Corrected implementation for the loop body:

```swift
for (index, object) in allObjects.enumerated() {
    reporter.send(.objectStarted(object, current: index + 1, total: total))
    do {
        guard let runtimeInterface = try await interface(for: object, options: options) else {
            throw RuntimeExportError.interfaceGenerationFailed(object)
        }
        let item = RuntimeInterfaceExportItem(
            object: object,
            plainText: runtimeInterface.interfaceString.string,
            suggestedFileName: object.exportFileName
        )
        results.append(item)
        succeeded += 1
        if item.isSwift { swiftCount += 1 } else { objcCount += 1 }
        reporter.send(.objectCompleted(object, runtimeInterface.interfaceString))
    } catch {
        failed += 1
        reporter.send(.objectFailed(object, error))
    }
}
```

**Step 2: Build to verify**

Run: `cd /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewerCore && swift build 2>&1 | xcsift`

**Step 3: Commit**

```
feat: Add exportInterface and exportInterfaces methods to RuntimeEngine
```

---

### Task 7: Full project build verification

**Step 1: Clean build RuntimeViewerCore**

Run: `cd /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewerCore && swift package clean && swift build 2>&1 | xcsift`

**Step 2: Build the main app**

Run: `xcodebuild build -workspace /Volumes/Repositories/Private/Org/MxIris-Reverse-Engineering/RuntimeViewer/RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift`

**Step 3: Commit if any fixes needed**

---

## Files Summary

| File | Action |
|------|--------|
| `RuntimeViewerCore/.../Export/RuntimeInterfaceExportEvent.swift` | Create |
| `RuntimeViewerCore/.../Export/RuntimeInterfaceExportReporter.swift` | Create |
| `RuntimeViewerCore/.../Export/RuntimeInterfaceExportConfiguration.swift` | Create |
| `RuntimeViewerCore/.../Export/RuntimeInterfaceExportItem.swift` | Create |
| `RuntimeViewerCore/.../Export/RuntimeInterfaceExportWriter.swift` | Create |
| `RuntimeViewerCore/.../Common/RuntimeObject+Export.swift` | Create |
| `RuntimeViewerCore/.../RuntimeEngine.swift` | Modify (append extension) |

```

`docs/plans/2026-02-17-export-wizard-enhancement-design.md`:

```md
# Export Wizard Enhancement Design

## Goal

Enhance the export feature to support selective object export with separate ObjC/Swift format configuration, using a multi-step wizard with NSTabViewController.

## Current State

The existing export UI is a single `ExportingViewController` with 3 inline page views (configuration, progress, completion) managed by manual view swapping. It exports all RuntimeObjects in the current image with a single format choice.

## Requirements

1. **Selective export**: Users can choose which RuntimeObjects to export (default: all selected)
2. **ObjC/Swift separate configuration**: Each language type has its own format choice (single file / directory)
3. **Multi-step wizard**: Each step is a separate ViewController, hosted by NSTabViewController

## Wizard Steps

| Step | Name | Purpose |
|------|------|---------|
| 1 | Selection | List all RuntimeObjects in current image, grouped by ObjC/Swift, default all selected, user can toggle |
| 2 | Configuration | Separate format selection for ObjC and Swift (single file / directory structure) |
| 3 | Export | Directory picker â†’ progress â†’ completion summary |

## Architecture

```
MainCoordinator
â””â”€â”€ prepareTransition(.exportInterfaces)
    â””â”€â”€ ExportingCoordinator (new, manages wizard flow)
        â””â”€â”€ ExportingTabViewController (NSTabViewController, .noTabsNoBorder)
            â”œâ”€â”€ Tab 0: ExportingSelectionViewController + ExportingSelectionViewModel
            â”œâ”€â”€ Tab 1: ExportingConfigurationViewController + ExportingConfigurationViewModel
            â””â”€â”€ Tab 2: ExportingProgressViewController + ExportingProgressViewModel
```

### Shared State

```swift
final class ExportingState {
    let imagePath: String
    let imageName: String
    var allObjects: [RuntimeObject] = []
    var selectedObjCObjects: [RuntimeObject] = []
    var selectedSwiftObjects: [RuntimeObject] = []
    var objcFormat: ExportFormat = .singleFile
    var swiftFormat: ExportFormat = .singleFile
    var destinationURL: URL?
}
```

Created by ExportingCoordinator and passed to each sub-ViewModel.

### ExportingCoordinator

- Inherits from appropriate coordinator base
- Creates ExportingTabViewController and all sub-VCs
- Manages tab transitions (next/back)
- Handles dismiss routing via MainRoute

### ExportingTabViewController

- NSTabViewController subclass
- `tabStyle = .unspecified` (no visible tabs â€” navigation via Next/Back buttons)
- Hosts the 3 step VCs as tab items
- Provides `showStep(_:)` method for coordinator to drive transitions

## Step Details

### Step 1: Selection

**UI Layout:**
- Header: icon + "Export Interfaces" title
- Image name display
- Two grouped sections (ObjC / Swift), each with:
  - Group header with "Select All" checkbox
  - NSTableView or NSOutlineView with checkbox column listing RuntimeObjects
- Footer: summary text ("12 ObjC classes, 8 Swift types selected")
- Buttons: Cancel | Next â†’

**Behavior:**
- On load, fetch all RuntimeObjects for the image from RuntimeEngine
- Default: all objects selected
- "Select All" checkbox per group toggles entire group
- Next button disabled if nothing selected

### Step 2: Configuration

**UI Layout:**
- Header: "Export Format" title
- Selection summary from Step 1
- Two format selection areas:
  - **ObjC Export Format**: radio buttons (Single File .h / Directory Structure)
  - **Swift Export Format**: radio buttons (Single File .swiftinterface / Directory Structure)
- Each with brief description text
- Buttons: â† Back | Cancel | Exportâ€¦

**Behavior:**
- Shows count of selected ObjC and Swift objects
- If no ObjC objects selected, ObjC section hidden/disabled (and vice versa for Swift)
- "Exportâ€¦" triggers directory selection panel

### Step 3: Progress / Completion

**UI Layout (Progress):**
- Phase label ("Exporting interfaces...")
- Progress bar
- Current object label
- Cancel button

**UI Layout (Completion):**
- Checkmark icon + "Export Complete"
- Summary: succeeded count, failed count, duration, ObjC/Swift breakdown
- Buttons: Show in Finder | Done

**Behavior:**
- Reuses existing export logic from ExportingViewModel
- Two internal states (progress / completion) managed within this single VC
- Cancel during export cancels the async task

## Navigation Flow

```
Step 1 â†’ validate(â‰¥1 selected) â†’ Step 2
Step 2 â†’ Back â†’ Step 1
Step 2 â†’ Exportâ€¦ â†’ directory picker â†’ Step 3 (auto-start export)
Step 3 â†’ Cancel â†’ dismiss
Step 3 â†’ Done â†’ dismiss
Step 3 â†’ Show in Finder â†’ open Finder + stay
Any step â†’ Cancel â†’ dismiss
```

## Route Changes

- `MainRoute.exportInterfaces` remains unchanged
- `MainCoordinator.prepareTransition(.exportInterfaces)` creates `ExportingCoordinator` instead of directly creating VC+VM
- No new routes needed in MainRoute; internal wizard navigation handled by ExportingCoordinator

## Export API Integration

The existing `RuntimeEngine.exportInterfaces(in:options:reporter:)` exports all objects in an image. For selective export, use the per-object API:

```swift
// Export selected objects individually
for object in selectedObjects {
    let item = try await engine.exportInterface(for: object, options: options)
}
```

The writer needs to be called twice (once for ObjC items, once for Swift items) if formats differ.

## Files to Create/Modify

### New Files
- `Exporting/ExportingState.swift` â€” shared wizard state
- `Exporting/ExportingCoordinator.swift` â€” wizard coordinator
- `Exporting/ExportingTabViewController.swift` â€” NSTabViewController host
- `Exporting/ExportingSelectionViewController.swift` â€” Step 1 VC
- `Exporting/ExportingSelectionViewModel.swift` â€” Step 1 VM
- `Exporting/ExportingConfigurationViewController.swift` â€” Step 2 VC
- `Exporting/ExportingConfigurationViewModel.swift` â€” Step 2 VM
- `Exporting/ExportingProgressViewController.swift` â€” Step 3 VC
- `Exporting/ExportingProgressViewModel.swift` â€” Step 3 VM

### Modified Files
- `Main/MainCoordinator.swift` â€” update `.exportInterfaces` case to use ExportingCoordinator
- Delete or repurpose old `ExportingViewController.swift` and `ExportingViewModel.swift`

```

`docs/plans/2026-02-17-export-wizard-enhancement-plan.md`:

```md
# Export Wizard Enhancement Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Refactor the export UI into a multi-step wizard with NSTabViewController, supporting selective object export and separate ObjC/Swift format configuration.

**Architecture:** Replace the single `ExportingViewController` with an `ExportingTabViewController` (NSTabViewController) hosting 3 step VCs: Selection â†’ Configuration â†’ Progress/Completion. Each step has its own ViewController + ViewModel pair. A shared `ExportingState` object passes data between steps. The Tab VC creates all sub-VCs/VMs and manages tab transitions by observing navigation signals from each VM.

**Tech Stack:** AppKit, RxSwift, SnapKit, RuntimeViewerCore export APIs

---

## Context

**Key base classes:**
- `AppKitViewController<VM: ViewModelProtocol>` â€” provides `viewModel`, `setupBindings(for:)`, auto error handling
- `ViewModel<Route: Routable>` â€” provides `documentState`, `router`, `appDefaults`, `errorRelay`, `rx.disposeBag`
- `@Observed` property wrapper â€” backed by `BehaviorRelay`, use `$prop.asDriver()` for output

**Key APIs:**
- `RuntimeEngine.objects(in: imagePath) async throws -> [RuntimeObject]` â€” get all objects in an image
- `RuntimeEngine.exportInterface(for: object, options:) async throws -> RuntimeInterfaceExportItem` â€” export single object
- `RuntimeInterfaceExportWriter.writeSingleFile(items:to:imageName:reporter:)` â€” write combined .h/.swiftinterface
- `RuntimeInterfaceExportWriter.writeDirectory(items:to:reporter:)` â€” write individual files in subdirs
- `RuntimeObject.kind.isSwift` / `RuntimeObject.kind.isObjc` â€” kind checking via `@CaseCheckable`

**File locations (all under `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/`):**
- Old files to delete: `ExportingViewController.swift`, `ExportingViewModel.swift`
- New files: all 8 new files created in this directory

---

### Task 1: Create ExportingState

Shared state object that passes data between wizard steps.

**Files:**
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingState.swift`

**Step 1: Write the file**

```swift
import Foundation
import RuntimeViewerCore

enum ExportFormat: Int {
    case singleFile = 0
    case directory = 1
}

final class ExportingState {
    let imagePath: String
    let imageName: String

    var allObjects: [RuntimeObject] = []
    var selectedObjects: Set<RuntimeObject> = []

    var objcFormat: ExportFormat = .singleFile
    var swiftFormat: ExportFormat = .singleFile

    var destinationURL: URL?

    var objcObjects: [RuntimeObject] {
        allObjects.filter { !$0.kind.isSwift }
    }

    var swiftObjects: [RuntimeObject] {
        allObjects.filter { $0.kind.isSwift }
    }

    var selectedObjcObjects: [RuntimeObject] {
        objcObjects.filter { selectedObjects.contains($0) }
    }

    var selectedSwiftObjects: [RuntimeObject] {
        swiftObjects.filter { selectedObjects.contains($0) }
    }

    init(imagePath: String, imageName: String) {
        self.imagePath = imagePath
        self.imageName = imageName
    }
}
```

**Step 2: Build**

```bash
xcodebuild build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

**Step 3: Commit**

```bash
git add RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingState.swift
git commit -m "feat(export): Add ExportingState shared state object"
```

---

### Task 2: Create ExportingSelectionViewModel

Step 1 ViewModel â€” loads objects, manages checkbox selection state.

**Files:**
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingSelectionViewModel.swift`

**Step 1: Write the file**

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingSelectionViewModel: ViewModel<MainRoute> {
    struct Input {
        let cancelClick: Signal<Void>
        let nextClick: Signal<Void>
        let toggleObject: Signal<RuntimeObject>
        let toggleAllObjC: Signal<Bool>
        let toggleAllSwift: Signal<Bool>
    }

    struct Output {
        let objcObjects: Driver<[RuntimeObject]>
        let swiftObjects: Driver<[RuntimeObject]>
        let selectedObjects: Driver<Set<RuntimeObject>>
        let summaryText: Driver<String>
        let isNextEnabled: Driver<Bool>
        let isLoading: Driver<Bool>
    }

    @Observed private(set) var objcObjects: [RuntimeObject] = []
    @Observed private(set) var swiftObjects: [RuntimeObject] = []
    @Observed private(set) var selectedObjects: Set<RuntimeObject> = []
    @Observed private(set) var isLoading: Bool = true

    let nextRelay = PublishRelay<Void>()

    private let exportingState: ExportingState

    init(exportingState: ExportingState, documentState: DocumentState, router: any Router<MainRoute>) {
        self.exportingState = exportingState
        super.init(documentState: documentState, router: router)
        loadObjects()
    }

    private func loadObjects() {
        Task { @MainActor [weak self] in
            guard let self else { return }
            do {
                let objects = try await documentState.runtimeEngine.objects(in: exportingState.imagePath)
                let objc = objects.filter { !$0.kind.isSwift }
                let swift = objects.filter { $0.kind.isSwift }
                self.objcObjects = objc
                self.swiftObjects = swift
                self.selectedObjects = Set(objects)
                self.exportingState.allObjects = objects
                self.isLoading = false
            } catch {
                errorRelay.accept(error)
            }
        }
    }

    func transform(_ input: Input) -> Output {
        input.cancelClick.emitOnNext { [weak self] in
            guard let self else { return }
            router.trigger(.dismiss)
        }
        .disposed(by: rx.disposeBag)

        input.nextClick.emitOnNext { [weak self] in
            guard let self else { return }
            exportingState.selectedObjects = selectedObjects
            nextRelay.accept(())
        }
        .disposed(by: rx.disposeBag)

        input.toggleObject.emitOnNext { [weak self] object in
            guard let self else { return }
            if selectedObjects.contains(object) {
                selectedObjects.remove(object)
            } else {
                selectedObjects.insert(object)
            }
        }
        .disposed(by: rx.disposeBag)

        input.toggleAllObjC.emitOnNext { [weak self] selected in
            guard let self else { return }
            if selected {
                selectedObjects.formUnion(objcObjects)
            } else {
                selectedObjects.subtract(objcObjects)
            }
        }
        .disposed(by: rx.disposeBag)

        input.toggleAllSwift.emitOnNext { [weak self] selected in
            guard let self else { return }
            if selected {
                selectedObjects.formUnion(swiftObjects)
            } else {
                selectedObjects.subtract(swiftObjects)
            }
        }
        .disposed(by: rx.disposeBag)

        let summaryText = $selectedObjects.asDriver().map { [weak self] selected -> String in
            guard let self else { return "" }
            let objcCount = objcObjects.filter { selected.contains($0) }.count
            let swiftCount = swiftObjects.filter { selected.contains($0) }.count
            return "\(objcCount + swiftCount) items selected (\(objcCount) ObjC, \(swiftCount) Swift)"
        }

        let isNextEnabled = $selectedObjects.asDriver().map { !$0.isEmpty }

        return Output(
            objcObjects: $objcObjects.asDriver(),
            swiftObjects: $swiftObjects.asDriver(),
            selectedObjects: $selectedObjects.asDriver(),
            summaryText: summaryText,
            isNextEnabled: isNextEnabled,
            isLoading: $isLoading.asDriver()
        )
    }
}
```

**Step 2: Build**

```bash
xcodebuild build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

**Step 3: Commit**

```bash
git add RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingSelectionViewModel.swift
git commit -m "feat(export): Add ExportingSelectionViewModel for Step 1"
```

---

### Task 3: Create ExportingSelectionViewController

Step 1 VC â€” NSTableView with checkbox groups for ObjC/Swift, select all toggles, summary label.

**Files:**
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingSelectionViewController.swift`

**Step 1: Write the file**

The table view uses a flat list with two kinds of rows: group headers (bold, with select-all checkbox) and object rows (indented, with individual checkbox). Checkbox clicks route through relays to the ViewModel.

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingSelectionViewController: AppKitViewController<ExportingSelectionViewModel> {
    // MARK: - Types

    private enum SelectionGroup: Int, CaseIterable {
        case objc = 0
        case swift = 1

        var title: String {
            switch self {
            case .objc: return "Objective-C"
            case .swift: return "Swift"
            }
        }
    }

    private enum SelectionItem {
        case group(SelectionGroup)
        case object(RuntimeObject)
    }

    // MARK: - Relays

    private let cancelRelay = PublishRelay<Void>()
    private let nextRelay = PublishRelay<Void>()
    private let toggleObjectRelay = PublishRelay<RuntimeObject>()
    private let toggleAllObjCRelay = PublishRelay<Bool>()
    private let toggleAllSwiftRelay = PublishRelay<Bool>()

    // MARK: - State

    private var items: [SelectionItem] = []
    private var objcObjects: [RuntimeObject] = []
    private var swiftObjects: [RuntimeObject] = []
    private var selectedObjects: Set<RuntimeObject> = []

    // MARK: - UI

    private let tableView = NSTableView()
    private let scrollView = ScrollView()
    private let summaryLabel = Label()
    private let nextButton = PushButton()

    // MARK: - Lifecycle

    override func loadView() {
        view = NSView()

        let iconImageView = ImageView().then {
            $0.image = NSImage(systemSymbolName: "doc.text", accessibilityDescription: nil)
            $0.symbolConfiguration = .init(pointSize: 32, weight: .light)
            $0.contentTintColor = .controlAccentColor
        }

        let titleLabel = Label("Export Interfaces").then {
            $0.font = .systemFont(ofSize: 18, weight: .semibold)
        }

        let headerStack = HStackView(spacing: 10) {
            iconImageView
            titleLabel
        }.then {
            $0.alignment = .centerY
        }

        let column = NSTableColumn(identifier: .init("main"))
        column.title = ""
        tableView.do {
            $0.addTableColumn(column)
            $0.headerView = nil
            $0.dataSource = self
            $0.delegate = self
            $0.selectionHighlightStyle = .none
            $0.rowHeight = 24
            $0.intercellSpacing = NSSize(width: 0, height: 2)
        }

        scrollView.do {
            $0.documentView = tableView
            $0.hasVerticalScroller = true
        }

        summaryLabel.do {
            $0.font = .systemFont(ofSize: 12)
            $0.textColor = .secondaryLabelColor
        }

        let cancelButton = PushButton().then {
            $0.title = "Cancel"
            $0.keyEquivalent = "\u{1b}"
            $0.target = self
            $0.action = #selector(cancelClicked)
        }

        nextButton.do {
            $0.title = "Next"
            $0.keyEquivalent = "\r"
            $0.target = self
            $0.action = #selector(nextClicked)
        }

        let buttonStack = HStackView(spacing: 8) {
            cancelButton
            nextButton
        }

        view.hierarchy {
            headerStack
            scrollView
            summaryLabel
            buttonStack
        }

        headerStack.snp.makeConstraints { make in
            make.top.leading.equalToSuperview().inset(20)
        }

        scrollView.snp.makeConstraints { make in
            make.top.equalTo(headerStack.snp.bottom).offset(16)
            make.leading.trailing.equalToSuperview().inset(20)
            make.bottom.equalTo(summaryLabel.snp.top).offset(-8)
        }

        summaryLabel.snp.makeConstraints { make in
            make.leading.equalToSuperview().inset(20)
            make.bottom.equalTo(buttonStack.snp.top).offset(-12)
        }

        buttonStack.snp.makeConstraints { make in
            make.trailing.bottom.equalToSuperview().inset(20)
        }
    }

    // MARK: - Actions

    @objc private func cancelClicked() {
        cancelRelay.accept(())
    }

    @objc private func nextClicked() {
        nextRelay.accept(())
    }

    @objc private func checkboxClicked(_ sender: NSButton) {
        let row = sender.tag
        guard row >= 0, row < items.count else { return }
        let item = items[row]
        switch item {
        case .group(let group):
            let nextState: Bool = sender.state != .off
            switch group {
            case .objc: toggleAllObjCRelay.accept(nextState)
            case .swift: toggleAllSwiftRelay.accept(nextState)
            }
        case .object(let object):
            toggleObjectRelay.accept(object)
        }
    }

    // MARK: - Data

    private func rebuildItems() {
        items = []
        if !objcObjects.isEmpty {
            items.append(.group(.objc))
            items += objcObjects.map { .object($0) }
        }
        if !swiftObjects.isEmpty {
            items.append(.group(.swift))
            items += swiftObjects.map { .object($0) }
        }
        tableView.reloadData()
    }

    // MARK: - Bindings

    override func setupBindings(for viewModel: ExportingSelectionViewModel) {
        super.setupBindings(for: viewModel)

        let input = ExportingSelectionViewModel.Input(
            cancelClick: cancelRelay.asSignal(),
            nextClick: nextRelay.asSignal(),
            toggleObject: toggleObjectRelay.asSignal(),
            toggleAllObjC: toggleAllObjCRelay.asSignal(),
            toggleAllSwift: toggleAllSwiftRelay.asSignal()
        )

        let output = viewModel.transform(input)

        output.objcObjects.driveOnNext { [weak self] objects in
            guard let self else { return }
            self.objcObjects = objects
            rebuildItems()
        }
        .disposed(by: rx.disposeBag)

        output.swiftObjects.driveOnNext { [weak self] objects in
            guard let self else { return }
            self.swiftObjects = objects
            rebuildItems()
        }
        .disposed(by: rx.disposeBag)

        output.selectedObjects.driveOnNext { [weak self] selected in
            guard let self else { return }
            self.selectedObjects = selected
            tableView.reloadData()
        }
        .disposed(by: rx.disposeBag)

        output.summaryText.drive(summaryLabel.rx.stringValue).disposed(by: rx.disposeBag)

        output.isNextEnabled.driveOnNext { [weak self] enabled in
            guard let self else { return }
            nextButton.isEnabled = enabled
        }
        .disposed(by: rx.disposeBag)
    }
}

// MARK: - NSTableViewDataSource

extension ExportingSelectionViewController: NSTableViewDataSource {
    func numberOfRows(in tableView: NSTableView) -> Int {
        items.count
    }
}

// MARK: - NSTableViewDelegate

extension ExportingSelectionViewController: NSTableViewDelegate {
    func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -> NSView? {
        let item = items[row]
        switch item {
        case .group(let group):
            let objects = group == .objc ? objcObjects : swiftObjects
            let selectedCount = objects.filter { selectedObjects.contains($0) }.count

            let checkbox = NSButton(checkboxWithTitle: "\(group.title) (\(objects.count))", target: self, action: #selector(checkboxClicked(_:)))
            checkbox.font = .systemFont(ofSize: 13, weight: .semibold)
            checkbox.tag = row
            checkbox.allowsMixedState = true
            checkbox.state = selectedCount == 0 ? .off : (selectedCount == objects.count ? .on : .mixed)

            let container = NSView()
            container.addSubview(checkbox)
            checkbox.snp.makeConstraints { make in
                make.leading.equalToSuperview().offset(4)
                make.centerY.equalToSuperview()
            }
            return container

        case .object(let object):
            let checkbox = NSButton(checkboxWithTitle: object.displayName, target: self, action: #selector(checkboxClicked(_:)))
            checkbox.font = .systemFont(ofSize: 13)
            checkbox.tag = row
            checkbox.state = selectedObjects.contains(object) ? .on : .off

            let container = NSView()
            container.addSubview(checkbox)
            checkbox.snp.makeConstraints { make in
                make.leading.equalToSuperview().offset(24)
                make.centerY.equalToSuperview()
            }
            return container
        }
    }

    func tableView(_ tableView: NSTableView, heightOfRow row: Int) -> CGFloat {
        switch items[row] {
        case .group: return 28
        case .object: return 22
        }
    }

    func tableView(_ tableView: NSTableView, shouldSelectRow row: Int) -> Bool {
        false
    }
}
```

**Step 2: Build**

```bash
xcodebuild build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

**Step 3: Commit**

```bash
git add RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingSelectionViewController.swift
git commit -m "feat(export): Add ExportingSelectionViewController for Step 1"
```

---

### Task 4: Create ExportingConfigurationViewModel + ViewController

Step 2 â€” separate ObjC/Swift format selection (single file or directory).

**Files:**
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingConfigurationViewModel.swift`
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingConfigurationViewController.swift`

**Step 1: Write ExportingConfigurationViewModel**

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingConfigurationViewModel: ViewModel<MainRoute> {
    struct Input {
        let cancelClick: Signal<Void>
        let backClick: Signal<Void>
        let exportClick: Signal<Void>
        let objcFormatSelected: Signal<Int>
        let swiftFormatSelected: Signal<Int>
    }

    struct Output {
        let objcCount: Driver<Int>
        let swiftCount: Driver<Int>
        let hasObjC: Driver<Bool>
        let hasSwift: Driver<Bool>
        let imageName: Driver<String>
    }

    @Observed private(set) var objcCount: Int = 0
    @Observed private(set) var swiftCount: Int = 0
    @Observed private(set) var hasObjC: Bool = false
    @Observed private(set) var hasSwift: Bool = false

    let backRelay = PublishRelay<Void>()
    let exportClickedRelay = PublishRelay<Void>()

    private let exportingState: ExportingState

    init(exportingState: ExportingState, documentState: DocumentState, router: any Router<MainRoute>) {
        self.exportingState = exportingState
        super.init(documentState: documentState, router: router)
    }

    func refreshFromState() {
        let objc = exportingState.selectedObjcObjects
        let swift = exportingState.selectedSwiftObjects
        objcCount = objc.count
        swiftCount = swift.count
        hasObjC = !objc.isEmpty
        hasSwift = !swift.isEmpty
    }

    func transform(_ input: Input) -> Output {
        input.cancelClick.emitOnNext { [weak self] in
            guard let self else { return }
            router.trigger(.dismiss)
        }
        .disposed(by: rx.disposeBag)

        input.backClick.emitOnNext { [weak self] in
            guard let self else { return }
            backRelay.accept(())
        }
        .disposed(by: rx.disposeBag)

        input.exportClick.emitOnNext { [weak self] in
            guard let self else { return }
            exportClickedRelay.accept(())
        }
        .disposed(by: rx.disposeBag)

        input.objcFormatSelected.emitOnNext { [weak self] index in
            guard let self else { return }
            exportingState.objcFormat = ExportFormat(rawValue: index) ?? .singleFile
        }
        .disposed(by: rx.disposeBag)

        input.swiftFormatSelected.emitOnNext { [weak self] index in
            guard let self else { return }
            exportingState.swiftFormat = ExportFormat(rawValue: index) ?? .singleFile
        }
        .disposed(by: rx.disposeBag)

        return Output(
            objcCount: $objcCount.asDriver(),
            swiftCount: $swiftCount.asDriver(),
            hasObjC: $hasObjC.asDriver(),
            hasSwift: $hasSwift.asDriver(),
            imageName: .just(exportingState.imageName)
        )
    }
}
```

**Step 2: Write ExportingConfigurationViewController**

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingConfigurationViewController: AppKitViewController<ExportingConfigurationViewModel> {
    // MARK: - Relays

    private let cancelRelay = PublishRelay<Void>()
    private let backRelay = PublishRelay<Void>()
    private let exportRelay = PublishRelay<Void>()
    private let objcFormatRelay = PublishRelay<Int>()
    private let swiftFormatRelay = PublishRelay<Int>()

    // MARK: - UI

    private let summaryLabel = Label()

    private let objcSectionView = NSView()
    private let objcSingleFileRadio = NSButton()
    private let objcDirectoryRadio = NSButton()

    private let swiftSectionView = NSView()
    private let swiftSingleFileRadio = NSButton()
    private let swiftDirectoryRadio = NSButton()

    // MARK: - Lifecycle

    override func loadView() {
        view = NSView()

        let headerLabel = Label("Export Format").then {
            $0.font = .systemFont(ofSize: 18, weight: .semibold)
        }

        summaryLabel.do {
            $0.font = .systemFont(ofSize: 13)
            $0.textColor = .secondaryLabelColor
        }

        // ObjC section
        let objcTitleLabel = Label("Objective-C:").then {
            $0.font = .systemFont(ofSize: 13, weight: .medium)
        }

        objcSingleFileRadio.do {
            $0.setButtonType(.radio)
            $0.title = "Single File (.h)"
            $0.font = .systemFont(ofSize: 13)
            $0.state = .on
            $0.target = self
            $0.action = #selector(objcFormatChanged(_:))
            $0.tag = 0
        }

        let objcSingleDesc = Label("Combine all ObjC interfaces into one .h file").then {
            $0.font = .systemFont(ofSize: 11)
            $0.textColor = .tertiaryLabelColor
        }

        objcDirectoryRadio.do {
            $0.setButtonType(.radio)
            $0.title = "Directory Structure"
            $0.font = .systemFont(ofSize: 13)
            $0.state = .off
            $0.target = self
            $0.action = #selector(objcFormatChanged(_:))
            $0.tag = 1
        }

        let objcDirDesc = Label("Individual .h files in ObjCHeaders/ subdirectory").then {
            $0.font = .systemFont(ofSize: 11)
            $0.textColor = .tertiaryLabelColor
        }

        let objcStack = VStackView(alignment: .leading, spacing: 6) {
            objcTitleLabel
            VStackView(alignment: .leading, spacing: 2) {
                objcSingleFileRadio
                objcSingleDesc
            }
            VStackView(alignment: .leading, spacing: 2) {
                objcDirectoryRadio
                objcDirDesc
            }
        }

        // Swift section
        let swiftTitleLabel = Label("Swift:").then {
            $0.font = .systemFont(ofSize: 13, weight: .medium)
        }

        swiftSingleFileRadio.do {
            $0.setButtonType(.radio)
            $0.title = "Single File (.swiftinterface)"
            $0.font = .systemFont(ofSize: 13)
            $0.state = .on
            $0.target = self
            $0.action = #selector(swiftFormatChanged(_:))
            $0.tag = 0
        }

        let swiftSingleDesc = Label("Combine all Swift interfaces into one .swiftinterface file").then {
            $0.font = .systemFont(ofSize: 11)
            $0.textColor = .tertiaryLabelColor
        }

        swiftDirectoryRadio.do {
            $0.setButtonType(.radio)
            $0.title = "Directory Structure"
            $0.font = .systemFont(ofSize: 13)
            $0.state = .off
            $0.target = self
            $0.action = #selector(swiftFormatChanged(_:))
            $0.tag = 1
        }

        let swiftDirDesc = Label("Individual files in SwiftInterfaces/ subdirectory").then {
            $0.font = .systemFont(ofSize: 11)
            $0.textColor = .tertiaryLabelColor
        }

        let swiftStack = VStackView(alignment: .leading, spacing: 6) {
            swiftTitleLabel
            VStackView(alignment: .leading, spacing: 2) {
                swiftSingleFileRadio
                swiftSingleDesc
            }
            VStackView(alignment: .leading, spacing: 2) {
                swiftDirectoryRadio
                swiftDirDesc
            }
        }

        objcSectionView.hierarchy { objcStack }
        objcStack.snp.makeConstraints { $0.edges.equalToSuperview() }

        swiftSectionView.hierarchy { swiftStack }
        swiftStack.snp.makeConstraints { $0.edges.equalToSuperview() }

        let contentStack = VStackView(alignment: .leading, spacing: 16) {
            headerLabel
            summaryLabel
            objcSectionView
            swiftSectionView
        }

        let backButton = PushButton().then {
            $0.title = "Back"
            $0.target = self
            $0.action = #selector(backClicked)
        }

        let cancelButton = PushButton().then {
            $0.title = "Cancel"
            $0.keyEquivalent = "\u{1b}"
            $0.target = self
            $0.action = #selector(cancelClicked)
        }

        let exportButton = PushButton().then {
            $0.title = "Export\u{2026}"
            $0.keyEquivalent = "\r"
            $0.target = self
            $0.action = #selector(exportClicked)
        }

        let buttonStack = HStackView(spacing: 8) {
            backButton
            cancelButton
            exportButton
        }

        view.hierarchy {
            contentStack
            buttonStack
        }

        contentStack.snp.makeConstraints { make in
            make.top.leading.trailing.equalToSuperview().inset(20)
        }

        buttonStack.snp.makeConstraints { make in
            make.trailing.bottom.equalToSuperview().inset(20)
        }
    }

    // MARK: - Actions

    @objc private func cancelClicked() {
        cancelRelay.accept(())
    }

    @objc private func backClicked() {
        backRelay.accept(())
    }

    @objc private func exportClicked() {
        exportRelay.accept(())
    }

    @objc private func objcFormatChanged(_ sender: NSButton) {
        objcSingleFileRadio.state = sender.tag == 0 ? .on : .off
        objcDirectoryRadio.state = sender.tag == 1 ? .on : .off
        objcFormatRelay.accept(sender.tag)
    }

    @objc private func swiftFormatChanged(_ sender: NSButton) {
        swiftSingleFileRadio.state = sender.tag == 0 ? .on : .off
        swiftDirectoryRadio.state = sender.tag == 1 ? .on : .off
        swiftFormatRelay.accept(sender.tag)
    }

    // MARK: - Bindings

    override func setupBindings(for viewModel: ExportingConfigurationViewModel) {
        super.setupBindings(for: viewModel)

        let input = ExportingConfigurationViewModel.Input(
            cancelClick: cancelRelay.asSignal(),
            backClick: backRelay.asSignal(),
            exportClick: exportRelay.asSignal(),
            objcFormatSelected: objcFormatRelay.asSignal(),
            swiftFormatSelected: swiftFormatRelay.asSignal()
        )

        let output = viewModel.transform(input)

        output.hasObjC.driveOnNext { [weak self] hasObjC in
            guard let self else { return }
            objcSectionView.isHidden = !hasObjC
        }
        .disposed(by: rx.disposeBag)

        output.hasSwift.driveOnNext { [weak self] hasSwift in
            guard let self else { return }
            swiftSectionView.isHidden = !hasSwift
        }
        .disposed(by: rx.disposeBag)

        Driver.combineLatest(output.objcCount, output.swiftCount, output.imageName)
            .driveOnNext { [weak self] objcCount, swiftCount, imageName in
                guard let self else { return }
                var parts: [String] = ["Image: \(imageName)"]
                if objcCount > 0 { parts.append("\(objcCount) ObjC") }
                if swiftCount > 0 { parts.append("\(swiftCount) Swift") }
                summaryLabel.stringValue = parts.joined(separator: " Â· ")
            }
            .disposed(by: rx.disposeBag)
    }
}
```

**Step 3: Build**

```bash
xcodebuild build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

**Step 4: Commit**

```bash
git add RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingConfigurationViewModel.swift \
        RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingConfigurationViewController.swift
git commit -m "feat(export): Add ExportingConfigurationViewController/ViewModel for Step 2"
```

---

### Task 5: Create ExportingProgressViewModel + ViewController

Step 3 â€” performs export, shows progress, displays completion summary.

**Files:**
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingProgressViewModel.swift`
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingProgressViewController.swift`

**Step 1: Write ExportingProgressViewModel**

This VM uses `RuntimeEngine.exportInterface(for:options:)` per selected object and tracks progress manually. It then calls `RuntimeInterfaceExportWriter` with separate formats for ObjC and Swift items.

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingProgressViewModel: ViewModel<MainRoute> {
    enum Page {
        case progress
        case completion
    }

    struct ExportResult {
        let succeeded: Int
        let failed: Int
        let totalDuration: TimeInterval
        let objcCount: Int
        let swiftCount: Int
    }

    struct Input {
        let cancelClick: Signal<Void>
        let doneClick: Signal<Void>
        let showInFinderClick: Signal<Void>
    }

    struct Output {
        let currentPage: Driver<Page>
        let phaseText: Driver<String>
        let progressValue: Driver<Double>
        let currentObjectText: Driver<String>
        let result: Driver<ExportResult?>
    }

    @Observed private(set) var currentPage: Page = .progress
    @Observed private(set) var phaseText: String = "Preparing..."
    @Observed private(set) var progressValue: Double = 0
    @Observed private(set) var currentObjectText: String = ""
    @Observed private(set) var exportResult: ExportResult?

    private let exportingState: ExportingState
    private var exportTask: Task<Void, Never>?

    init(exportingState: ExportingState, documentState: DocumentState, router: any Router<MainRoute>) {
        self.exportingState = exportingState
        super.init(documentState: documentState, router: router)
    }

    func transform(_ input: Input) -> Output {
        input.cancelClick.emitOnNext { [weak self] in
            guard let self else { return }
            exportTask?.cancel()
            router.trigger(.dismiss)
        }
        .disposed(by: rx.disposeBag)

        input.doneClick.emitOnNext { [weak self] in
            guard let self else { return }
            router.trigger(.dismiss)
        }
        .disposed(by: rx.disposeBag)

        input.showInFinderClick.emitOnNext { [weak self] in
            guard let self else { return }
            guard let url = exportingState.destinationURL else { return }
            NSWorkspace.shared.activateFileViewerSelecting([url])
        }
        .disposed(by: rx.disposeBag)

        return Output(
            currentPage: $currentPage.asDriver(),
            phaseText: $phaseText.asDriver(),
            progressValue: $progressValue.asDriver(),
            currentObjectText: $currentObjectText.asDriver(),
            result: $exportResult.asDriver()
        )
    }

    func startExport() {
        guard let directory = exportingState.destinationURL else { return }

        currentPage = .progress
        phaseText = "Exporting interfaces..."
        progressValue = 0
        currentObjectText = ""
        exportResult = nil

        let selectedObjcObjects = exportingState.selectedObjcObjects
        let selectedSwiftObjects = exportingState.selectedSwiftObjects
        let allSelected = selectedObjcObjects + selectedSwiftObjects

        exportTask = Task { [weak self] in
            guard let self else { return }

            let startTime = CFAbsoluteTimeGetCurrent()
            var items: [RuntimeInterfaceExportItem] = []
            var succeeded = 0
            var failed = 0

            do {
                for (index, object) in allSelected.enumerated() {
                    if Task.isCancelled { break }

                    await MainActor.run { [weak self] in
                        guard let self else { return }
                        progressValue = Double(index) / Double(allSelected.count)
                        currentObjectText = "\(object.displayName) (\(index + 1)/\(allSelected.count))"
                    }

                    do {
                        let item = try await documentState.runtimeEngine.exportInterface(
                            for: object,
                            options: appDefaults.options
                        )
                        items.append(item)
                        succeeded += 1
                    } catch {
                        failed += 1
                    }
                }

                guard !Task.isCancelled else { return }

                await MainActor.run { [weak self] in
                    guard let self else { return }
                    phaseText = "Writing files..."
                    progressValue = 1.0
                }

                try writeItems(items, to: directory)

                let duration = CFAbsoluteTimeGetCurrent() - startTime
                let objcCount = items.filter { !$0.isSwift }.count
                let swiftCount = items.filter { $0.isSwift }.count

                let result = ExportResult(
                    succeeded: succeeded,
                    failed: failed,
                    totalDuration: duration,
                    objcCount: objcCount,
                    swiftCount: swiftCount
                )

                await MainActor.run { [weak self] in
                    guard let self else { return }
                    exportResult = result
                    currentPage = .completion
                }
            } catch {
                await MainActor.run { [weak self] in
                    guard let self else { return }
                    errorRelay.accept(error)
                }
            }
        }
    }

    private func writeItems(_ items: [RuntimeInterfaceExportItem], to directory: URL) throws {
        let objcItems = items.filter { !$0.isSwift }
        let swiftItems = items.filter { $0.isSwift }

        if !objcItems.isEmpty {
            let reporter = RuntimeInterfaceExportReporter()
            switch exportingState.objcFormat {
            case .singleFile:
                try RuntimeInterfaceExportWriter.writeSingleFile(
                    items: objcItems,
                    to: directory,
                    imageName: exportingState.imageName,
                    reporter: reporter
                )
            case .directory:
                try RuntimeInterfaceExportWriter.writeDirectory(
                    items: objcItems,
                    to: directory,
                    reporter: reporter
                )
            }
        }

        if !swiftItems.isEmpty {
            let reporter = RuntimeInterfaceExportReporter()
            switch exportingState.swiftFormat {
            case .singleFile:
                try RuntimeInterfaceExportWriter.writeSingleFile(
                    items: swiftItems,
                    to: directory,
                    imageName: exportingState.imageName,
                    reporter: reporter
                )
            case .directory:
                try RuntimeInterfaceExportWriter.writeDirectory(
                    items: swiftItems,
                    to: directory,
                    reporter: reporter
                )
            }
        }
    }
}
```

**Step 2: Write ExportingProgressViewController**

Two internal pages (progress view and completion view) managed by the same showPage pattern.

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingProgressViewController: AppKitViewController<ExportingProgressViewModel> {
    // MARK: - Relays

    private let cancelRelay = PublishRelay<Void>()
    private let doneRelay = PublishRelay<Void>()
    private let showInFinderRelay = PublishRelay<Void>()

    // MARK: - Progress Page

    private let progressPhaseLabel = Label("Preparing...").then {
        $0.font = .systemFont(ofSize: 15, weight: .medium)
        $0.alignment = .center
    }

    private let progressIndicator = NSProgressIndicator().then {
        $0.style = .bar
        $0.isIndeterminate = false
        $0.minValue = 0
        $0.maxValue = 1
    }

    private let progressObjectLabel = Label().then {
        $0.font = .systemFont(ofSize: 12)
        $0.textColor = .secondaryLabelColor
        $0.alignment = .center
    }

    private lazy var progressPageView: NSView = {
        let container = NSView()

        let contentStack = VStackView(alignment: .centerX, spacing: 12) {
            progressPhaseLabel
            progressIndicator
            progressObjectLabel
        }

        let cancelButton = PushButton().then {
            $0.title = "Cancel"
            $0.keyEquivalent = "\u{1b}"
            $0.target = self
            $0.action = #selector(cancelClicked)
        }

        container.hierarchy {
            contentStack
            cancelButton
        }

        progressIndicator.snp.makeConstraints { make in
            make.width.equalTo(350)
        }

        contentStack.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().offset(-20)
            make.leading.greaterThanOrEqualToSuperview().offset(20)
            make.trailing.lessThanOrEqualToSuperview().offset(-20)
        }

        cancelButton.snp.makeConstraints { make in
            make.trailing.bottom.equalToSuperview().inset(20)
        }

        return container
    }()

    // MARK: - Completion Page

    private let completionSummaryLabel = Label().then {
        $0.font = .systemFont(ofSize: 13)
        $0.textColor = .secondaryLabelColor
        $0.alignment = .center
        $0.maximumNumberOfLines = 0
        $0.preferredMaxLayoutWidth = 350
    }

    private lazy var completionPageView: NSView = {
        let container = NSView()

        let checkmarkImageView = ImageView().then {
            $0.image = NSImage(systemSymbolName: "checkmark.circle.fill", accessibilityDescription: nil)
            $0.symbolConfiguration = .init(pointSize: 48, weight: .light)
            $0.contentTintColor = .systemGreen
        }

        let titleLabel = Label("Export Complete").then {
            $0.font = .systemFont(ofSize: 18, weight: .semibold)
            $0.alignment = .center
        }

        let contentStack = VStackView(alignment: .centerX, spacing: 8) {
            checkmarkImageView
            titleLabel
            completionSummaryLabel
        }

        let showInFinderButton = PushButton().then {
            $0.title = "Show in Finder"
            $0.target = self
            $0.action = #selector(showInFinderClicked)
        }

        let doneButton = PushButton().then {
            $0.title = "Done"
            $0.keyEquivalent = "\r"
            $0.target = self
            $0.action = #selector(doneClicked)
        }

        let buttonStack = HStackView(spacing: 8) {
            showInFinderButton
            doneButton
        }

        container.hierarchy {
            contentStack
            buttonStack
        }

        contentStack.snp.makeConstraints { make in
            make.centerX.equalToSuperview()
            make.centerY.equalToSuperview().offset(-20)
        }

        buttonStack.snp.makeConstraints { make in
            make.trailing.bottom.equalToSuperview().inset(20)
        }

        return container
    }()

    // MARK: - Container

    private let containerView = NSView()

    // MARK: - Lifecycle

    override func loadView() {
        view = NSView()
        view.addSubview(containerView)

        containerView.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        showPage(progressPageView)
    }

    // MARK: - Actions

    @objc private func cancelClicked() {
        cancelRelay.accept(())
    }

    @objc private func doneClicked() {
        doneRelay.accept(())
    }

    @objc private func showInFinderClicked() {
        showInFinderRelay.accept(())
    }

    // MARK: - Page Management

    private func showPage(_ page: NSView) {
        containerView.subviews.forEach { $0.removeFromSuperview() }
        containerView.addSubview(page)
        page.snp.makeConstraints { make in
            make.edges.equalToSuperview()
        }
    }

    // MARK: - Bindings

    override func setupBindings(for viewModel: ExportingProgressViewModel) {
        super.setupBindings(for: viewModel)

        let input = ExportingProgressViewModel.Input(
            cancelClick: cancelRelay.asSignal(),
            doneClick: doneRelay.asSignal(),
            showInFinderClick: showInFinderRelay.asSignal()
        )

        let output = viewModel.transform(input)

        output.currentPage.driveOnNext { [weak self] page in
            guard let self else { return }
            switch page {
            case .progress:
                showPage(progressPageView)
            case .completion:
                showPage(completionPageView)
            }
        }
        .disposed(by: rx.disposeBag)

        output.phaseText.drive(progressPhaseLabel.rx.stringValue).disposed(by: rx.disposeBag)

        output.progressValue.driveOnNext { [weak self] value in
            guard let self else { return }
            progressIndicator.doubleValue = value
        }
        .disposed(by: rx.disposeBag)

        output.currentObjectText.drive(progressObjectLabel.rx.stringValue).disposed(by: rx.disposeBag)

        output.result.compactMap { $0 }.driveOnNext { [weak self] result in
            guard let self else { return }
            var lines: [String] = []
            lines.append("\(result.succeeded) interfaces exported successfully")
            if result.failed > 0 {
                lines.append("\(result.failed) failed")
            }
            lines.append(String(format: "Duration: %.1fs", result.totalDuration))
            lines.append("ObjC: \(result.objcCount) | Swift: \(result.swiftCount)")
            completionSummaryLabel.stringValue = lines.joined(separator: "\n")
        }
        .disposed(by: rx.disposeBag)
    }
}
```

**Step 3: Build**

```bash
xcodebuild build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

**Step 4: Commit**

```bash
git add RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingProgressViewModel.swift \
        RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingProgressViewController.swift
git commit -m "feat(export): Add ExportingProgressViewController/ViewModel for Step 3"
```

---

### Task 6: Create ExportingTabViewController

NSTabViewController container that hosts all 3 step VCs and manages tab transitions.

**Files:**
- Create: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingTabViewController.swift`

**Step 1: Write the file**

```swift
import AppKit
import RuntimeViewerCore
import RuntimeViewerUI
import RuntimeViewerArchitectures
import RuntimeViewerApplication

final class ExportingTabViewController: NSTabViewController {
    private let exportingState: ExportingState
    private let documentState: DocumentState
    private let router: any Router<MainRoute>

    private var selectionVM: ExportingSelectionViewModel!
    private var configurationVM: ExportingConfigurationViewModel!
    private var progressVM: ExportingProgressViewModel!

    private var disposeBag = DisposeBag()

    init(exportingState: ExportingState, documentState: DocumentState, router: any Router<MainRoute>) {
        self.exportingState = exportingState
        self.documentState = documentState
        self.router = router
        super.init(nibName: nil, bundle: nil)
    }

    @available(*, unavailable)
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }

    override func viewDidLoad() {
        super.viewDidLoad()

        tabStyle = .unspecified
        preferredContentSize = NSSize(width: 550, height: 450)

        // Step 1: Selection
        let selectionVC = ExportingSelectionViewController()
        selectionVM = ExportingSelectionViewModel(
            exportingState: exportingState,
            documentState: documentState,
            router: router
        )
        selectionVC.setupBindings(for: selectionVM)

        // Step 2: Configuration
        let configurationVC = ExportingConfigurationViewController()
        configurationVM = ExportingConfigurationViewModel(
            exportingState: exportingState,
            documentState: documentState,
            router: router
        )
        configurationVC.setupBindings(for: configurationVM)

        // Step 3: Progress
        let progressVC = ExportingProgressViewController()
        progressVM = ExportingProgressViewModel(
            exportingState: exportingState,
            documentState: documentState,
            router: router
        )
        progressVC.setupBindings(for: progressVM)

        // Add tab items
        addTabViewItem(NSTabViewItem(viewController: selectionVC))
        addTabViewItem(NSTabViewItem(viewController: configurationVC))
        addTabViewItem(NSTabViewItem(viewController: progressVC))

        selectedTabViewItemIndex = 0

        setupNavigationBindings()
    }

    private func setupNavigationBindings() {
        // Selection â†’ Configuration
        selectionVM.nextRelay.asSignal().emitOnNext { [weak self] in
            guard let self else { return }
            configurationVM.refreshFromState()
            selectedTabViewItemIndex = 1
        }
        .disposed(by: disposeBag)

        // Configuration â†’ Selection (back)
        configurationVM.backRelay.asSignal().emitOnNext { [weak self] in
            guard let self else { return }
            selectedTabViewItemIndex = 0
        }
        .disposed(by: disposeBag)

        // Configuration â†’ Export (directory picker â†’ Progress)
        configurationVM.exportClickedRelay.asSignal().emitOnNext { [weak self] in
            guard let self else { return }
            presentDirectoryPicker()
        }
        .disposed(by: disposeBag)
    }

    private func presentDirectoryPicker() {
        let panel = NSOpenPanel()
        panel.canChooseDirectories = true
        panel.canChooseFiles = false
        panel.canCreateDirectories = true
        panel.prompt = "Export"
        panel.message = "Choose a destination folder for exported interfaces"

        guard let window = view.window else { return }
        panel.beginSheetModal(for: window) { [weak self] response in
            guard let self else { return }
            guard response == .OK, let url = panel.url else { return }
            exportingState.destinationURL = url
            selectedTabViewItemIndex = 2
            progressVM.startExport()
        }
    }
}
```

**Step 2: Build**

```bash
xcodebuild build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

**Step 3: Commit**

```bash
git add RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingTabViewController.swift
git commit -m "feat(export): Add ExportingTabViewController container"
```

---

### Task 7: Update MainCoordinator and delete old files

Wire the new ExportingTabViewController into the existing routing. Delete old single-VC export files.

**Files:**
- Modify: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainCoordinator.swift`
- Delete: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingViewController.swift`
- Delete: `RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingViewModel.swift`

**Step 1: Update MainCoordinator**

Replace the `.exportInterfaces` case in `prepareTransition(for:)`.

Find this block (around line 70-78):

```swift
case .exportInterfaces:
    guard let imagePath = documentState.currentImagePath,
          let imageName = documentState.currentImageName else {
        return .none()
    }
    let viewController = ExportingViewController()
    let viewModel = ExportingViewModel(imagePath: imagePath, imageName: imageName, documentState: documentState, router: self)
    viewController.setupBindings(for: viewModel)
    return .presentOnRoot(viewController, mode: .asSheet)
```

Replace with:

```swift
case .exportInterfaces:
    guard let imagePath = documentState.currentImagePath,
          let imageName = documentState.currentImageName else {
        return .none()
    }
    let state = ExportingState(imagePath: imagePath, imageName: imageName)
    let tabViewController = ExportingTabViewController(
        exportingState: state,
        documentState: documentState,
        router: self
    )
    return .presentOnRoot(tabViewController, mode: .asSheet)
```

**Step 2: Delete old files**

```bash
git rm RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingViewController.swift
git rm RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ExportingViewModel.swift
```

**NOTE:** Also remove these files from the Xcode project if they are referenced in the `.pbxproj`. Use Xcode MCP tools or manual editing.

**Step 3: Build**

```bash
xcodebuild build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

**Step 4: Commit**

```bash
git add -A RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Exporting/ \
        RuntimeViewerUsingAppKit/RuntimeViewerUsingAppKit/Main/MainCoordinator.swift
git commit -m "feat(export): Wire ExportingTabViewController and remove old export files"
```

---

### Task 8: Final build verification

**Step 1: Clean build**

```bash
xcodebuild clean build -workspace RuntimeViewer.xcworkspace -scheme "RuntimeViewerUsingAppKit" -configuration Debug -destination 'generic/platform=macOS' 2>&1 | xcsift
```

Expected: 0 errors

**Step 2: Verify all new files are tracked**

```bash
git status
```

All files should be committed with no untracked export files.

```