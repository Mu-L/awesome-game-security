Project Path: arc_kernelwernel_VMAware_e3kkbaxp

Source Tree:

```txt
arc_kernelwernel_VMAware_e3kkbaxp
â”œâ”€â”€ CMakeLists.txt
â”œâ”€â”€ CMakeSettings.json
â”œâ”€â”€ CONTRIBUTING.md
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ README_CN.md
â”œâ”€â”€ README_FR.md
â”œâ”€â”€ README_KR.md
â”œâ”€â”€ SECURITY.md
â”œâ”€â”€ assets
â”‚   â”œâ”€â”€ Screenshot from 2024-05-11 16-30-04.png
â”‚   â”œâ”€â”€ banner.jpg
â”‚   â”œâ”€â”€ banner_wojak.png
â”‚   â”œâ”€â”€ demo.png
â”‚   â”œâ”€â”€ gui.drawio
â”‚   â”œâ”€â”€ hyper-x
â”‚   â”‚   â”œâ”€â”€ v1
â”‚   â”‚   â”‚   â”œâ”€â”€ Hyper-X.drawio
â”‚   â”‚   â”‚   â””â”€â”€ Hyper-X.png
â”‚   â”‚   â”œâ”€â”€ v2
â”‚   â”‚   â”‚   â”œâ”€â”€ Hyper-X_version_2.drawio
â”‚   â”‚   â”‚   â””â”€â”€ Hyper-X_version_2.png
â”‚   â”‚   â”œâ”€â”€ v3
â”‚   â”‚   â”‚   â”œâ”€â”€ Hyper-X_version_3.drawio
â”‚   â”‚   â”‚   â””â”€â”€ Hyper-X_version_3.png
â”‚   â”‚   â”œâ”€â”€ v4
â”‚   â”‚   â”‚   â”œâ”€â”€ Hyper-X_version_4.drawio
â”‚   â”‚   â”‚   â””â”€â”€ Hyper-X_version_4.drawio.png
â”‚   â”‚   â””â”€â”€ v5
â”‚   â”‚       â”œâ”€â”€ Hyper-X_version_5.drawio
â”‚   â”‚       â””â”€â”€ Hyper-X_version_5.drawio.png
â”‚   â””â”€â”€ vmaware.png
â”œâ”€â”€ auxiliary
â”‚   â”œâ”€â”€ add_technique.py
â”‚   â”œâ”€â”€ benchmark.cpp
â”‚   â”œâ”€â”€ cpuid_fuzzer.c
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â”œâ”€â”€ test_standards.sh
â”‚   â”œâ”€â”€ updater.py
â”‚   â””â”€â”€ vmaware_download.cmake
â”œâ”€â”€ docs
â”‚   â”œâ”€â”€ documentation.md
â”‚   â””â”€â”€ score_system.md
â”œâ”€â”€ papers
â”‚   â”œâ”€â”€  Attacks on Virtual Machine Emulators.pdf
â”‚   â”œâ”€â”€ A Study of IO Performance of Virtual Machines.pdf
â”‚   â”œâ”€â”€ A new post-meltdown attack technique_ how to use speculative instructions for virtualization detection.pdf
â”‚   â”œâ”€â”€ Armv8-A virtualization.pdf
â”‚   â”œâ”€â”€ Detecting System Emulators.pdf
â”‚   â”œâ”€â”€ Detecting the Presence of Virtual  Machines Using the Local Data Table.pdf
â”‚   â”œâ”€â”€ Detection of Virtual Machines Based on Thread Scheduling.pdf
â”‚   â”œâ”€â”€ Invisible Sandbox Evasion - Check Point Research.pdf
â”‚   â”œâ”€â”€ Measuring virtual machine detection in malware using DSD tracer.pdf
â”‚   â”œâ”€â”€ Methods for Virtual Machine Detection.pdf
â”‚   â”œâ”€â”€ Rethinking anti-emulation techniques for large-scale software deployment.pdf
â”‚   â”œâ”€â”€ STEALTH SANDBOX ANALYSIS OF MALWARE.pdf
â”‚   â”œâ”€â”€ ThwartingVMDetection_Liston_Skoudis.pdf
â”‚   â”œâ”€â”€ lisa15-paper-xiao.pdf
â”‚   â””â”€â”€ vmde.pdf
â””â”€â”€ src
    â”œâ”€â”€ README.md
    â”œâ”€â”€ cli.cpp
    â””â”€â”€ vmaware.hpp

```

`CMakeLists.txt`:

```txt
# basic info
cmake_minimum_required(VERSION 3.22 FATAL_ERROR)
project(
    VMAware
    DESCRIPTION "VM detection library"
    LANGUAGES CXX
)

# set C++ standard
if(NOT DEFINED CMAKE_CXX_STANDARD)
    set(CMAKE_CXX_STANDARD 20)
endif()
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

if(MSVC)
    # Globally disable specific MSVC warnings from external headers
    add_compile_options(
        /wd5039  # 'TpSetCallbackCleanupGroup' potentially throwing
        /wd4820  # padding added after data member
        /wd4626  # deleted assignment operator
        /wd5045  # Spectre mitigation notice
        /wd4668  # undefined macro replaced with '0'
        /Zc:enumTypes  # use enum underlying type canonicalization
    )
endif()

# compiler flags
if (MSVC)
    set(CMAKE_CXX_FLAGS "/W4 /EHsc")
else()
    # Linux and Apple
    set(CMAKE_CXX_FLAGS "-Wextra -Wall -Wextra -Wconversion -Wdouble-promotion -Wno-unused-parameter -Wno-unused-function -Wno-sign-conversion")
endif()

if(CMAKE_C_COMPILER_ID STREQUAL "Clang" OR CMAKE_C_COMPILER_ID STREQUAL "GNU")
    set(CMAKE_CXX_FLAGS "${CMAKE_C_FLAGS} -lstdc++ -lm")
endif()

# find available compilers
if (LINUX)
    find_program(CLANGPP_EXECUTABLE NAMES clang++)
    find_program(GPP_EXECUTABLE NAMES g++)

    # select compiler with preference for clang++
    if(CLANGPP_EXECUTABLE)
        set(CMAKE_CXX_COMPILER "${CLANGPP_EXECUTABLE}")
        get_filename_component(COMPILER_NAME ${CLANGPP_EXECUTABLE} NAME)
    elseif(GPP_EXECUTABLE)
        set(CMAKE_CXX_COMPILER "${GPP_EXECUTABLE}")
        get_filename_component(COMPILER_NAME ${GPP_EXECUTABLE} NAME)
    endif()
endif()

message(STATUS "Compiler: ${COMPILER_NAME}")

# fetch and set build type
set(available_build_types Debug Release Dev_Release)
if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "Choose the type of build (Debug or Release)" FORCE)
endif()

# Define preprocessor macros based on the build type
if(CMAKE_BUILD_TYPE STREQUAL "Debug")
    add_compile_definitions(__VMAWARE_DEBUG__)
elseif(CMAKE_BUILD_TYPE STREQUAL "Release")
    add_compile_definitions(__VMAWARE_RELEASE__)
endif()

# general variables
set(PROJECT_DIR "${CMAKE_CURRENT_SOURCE_DIR}")
set(BUILD_DIR "${PROJECT_DIR}/build")
set(TARGET "vmaware")

# debug/release CXX flag options
if (MSVC)
    if(CMAKE_BUILD_TYPE MATCHES "Debug")
        message(STATUS "Build set to debug mode")
    elseif(CMAKE_BUILD_TYPE MATCHES "Release")
        message(STATUS "Build set to release mode")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /O2")
    endif()
elseif(APPLE)
    if(CMAKE_BUILD_TYPE MATCHES "Debug")
        message(STATUS "Build set to debug mode")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -O0 -fsanitize=address")
    elseif(CMAKE_BUILD_TYPE MATCHES "Release")
        message(STATUS "Build set to release mode")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g0 -O2 -march=native -mtune=native")
    endif()
elseif(LINUX)
    if(CMAKE_BUILD_TYPE MATCHES "Debug")
        message(STATUS "Build set to debug mode")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -fmax-errors=5 -DDEBUG -O0 -fsanitize=address,leak")
    elseif(CMAKE_BUILD_TYPE MATCHES "Release")
        message(STATUS "Build set to release mode")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g0 -O2")
        if(${CMAKE_SYSTEM_PROCESSOR} MATCHES "x86_64")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -march=native -mtune=native")
        elseif(${CMAKE_SYSTEM_PROCESSOR} MATCHES "arm")
            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -mcpu=native")
        endif()
    elseif(CMAKE_BUILD_TYPE MATCHES "Dev_Release")
        message(STATUS "Build set to development release mode")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g0 -O2 -mno-avx512f -mno-avx512bw -mno-avx512vl")
    endif()
else()
    message(STATUS "Build set to release mode")
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -O2")
endif()

# add executable
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY "${BUILD_DIR}")
add_executable(${TARGET} "src/cli.cpp")
if(NOT DEFINED CMAKE_CXX_STANDARD)
    set_property(TARGET ${TARGET} PROPERTY CXX_STANDARD 20)
endif()
set_property(TARGET ${TARGET} PROPERTY CXX_STANDARD_REQUIRED ON)

# CTest stuff
include(CTest)
enable_testing()
set(ARGUMENTS "--all")
if(MSVC)
    add_test(executable "${BUILD_DIR}/Release/${TARGET}")
else()
    add_test(NAME TARGET COMMAND "${BUILD_DIR}/${TARGET}" ${ARGUMENTS})
endif()

# install rules
if (NOT MSVC)
    if(CMAKE_BUILD_TYPE MATCHES "Release")
        install(TARGETS ${TARGET} DESTINATION /usr/bin)
        install(FILES "src/vmaware.hpp" DESTINATION /usr/include)
    else()
        install(TARGETS ${TARGET} DESTINATION ${CMAKE_SOURCE_DIR})
    endif()
elseif(MSVC)
    set(CMAKE_INSTALL_PREFIX "C:\\Program Files\\YourApplication")
    install(TARGETS ${TARGET} RUNTIME DESTINATION "bin")

    set(HEADER_INSTALL_PATH "C:\\Program Files (x86)\\YourLibrary\\include")
    install(FILES "src/vmaware.hpp" DESTINATION "${HEADER_INSTALL_PATH}")
endif()

```

`CMakeSettings.json`:

```json
{
  "configurations": [
    {
      "name": "x64-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "inheritEnvironments": [ "msvc_x64_x64" ],
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": ""
    },
    {
      "name": "x86-Debug",
      "generator": "Ninja",
      "configurationType": "Debug",
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "msvc_x86" ]
    },
    {
      "name": "x64-Release",
      "generator": "Ninja",
      "configurationType": "RelWithDebInfo",
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "msvc_x64_x64" ]
    },
    {
      "name": "x86-Release",
      "generator": "Ninja",
      "configurationType": "RelWithDebInfo",
      "buildRoot": "${projectDir}\\out\\build\\${name}",
      "installRoot": "${projectDir}\\out\\install\\${name}",
      "cmakeCommandArgs": "",
      "buildCommandArgs": "",
      "ctestCommandArgs": "",
      "inheritEnvironments": [ "msvc_x86" ]
    }
  ]
}
```

`CONTRIBUTING.md`:

```md
# Contribution Guidelines


Please consider adding your name and github in the vmaware.hpp file and the README's credit sections. Your work is valuable to us, and we want to credit you for the improvements you've made. 


## Translations
If you're making translations, please make sure that you have the intention to be as accurate as possible. If you're unsure which parts should be translated or not, you can use the other translated files as a reference to guide you.

Using translation software like google translate is allowed, but only if you cross-check between the english and translation version to verify if it's done correctly.

The README is quite big, so this is quite an effort. I'm sure you have better thing to do in your life but if you can do this, it would be greatly appreciated :)


## Code contributions
The general rules are:
- Keep it C++11 compatible, this is extremely important
- Use snake_case 
- Be as simple as possible
- Prefer readability over aggressive optimisations (especially intrinsics)
- Keep indentations at a minimum
- Don't create huge one-liners, try to break down statements line by line
- Write as few lines as possible for what you're trying to achieve
- Document your code and intentions very clearly, but don't overdo them for very obvious code
- Avoid `std::function`, `std::shared_ptr`, `std::bind`, `std::list`, or very obscure C++ features
- Indent size should be 4 spaces
- Use "We" instead of the first person when commenting

There are other formatting rules, which will be covered with a demonstration:

```cpp
int main() {
    const u32 number = 10; // 1. use const whenever it should be used.
                           // 2. use the rust integral type convention from 8 to 64 (i.e. i8, u16, u64, etc...)
                           // 3. keep the names as simple and clear as possible, don't call it "n", call it "number".
                           //    Try to name the variables into something that can universally be discerned by anybody,
                           //    Make sure it's also context-aware and should make sense. Calling it "tmp" is also fine.
                           //    Consistency is also key in this aspect, don't do "u32 number = find_num()", do find_number(). 

    if (number >= 54) { // 4. avoid magic numbers, put a comment or make a constexpr variable prior to using it,
        something();    //    preferably the latter.
    } else if (number) {  // 5. make the if, else if, and else statement lines the same without breaking lines, so don't do:
        something_else(); //    if () 
    }                     //    {
                          //       something();
                          //    }
                          //    else 
                          //    {
                          //       something_else(); 
                          //    }
                          //    
                          // try to follow as shown in this actual demonstration.

    if (
        ((number % 4) == 0) && // 6. use separate lines for each statement of a condition check. While this might look ok
        (number > 50) &&       //    on a single line, in practice your conditions will most likely not be as short and 
        (number < 100)         //    and simple as this. Try to avoid multiple condition checks in a single line for simplicity.
    ) {
        something()
    }


    for (u8 i = 0; i < number; i++) { // 6. Be as simple as possible without using fancy features like iterators if it's not necessary.
        something();
    }

    // Other rules will be added in the future, this is just a rough guideline for the moment.
}
```

## I want to add a new technique, how would I do that?
There's a few steps that should be taken:
1. Make sure to add the technique name in the enums of all the techniques in the appropriate place.
2. Add the technique function itself in the technique section of the library. Make sure to add it in the right place, as there's preprocessor directives for each platform (Linux, Windows, and Apple)
3. Add the technique in the technique table situated at the end of the header file. The score should be between 10 and 100. Although there are exceptions, it's advised to follow the aforementioned score range.
4. Add it to the CLI's technique runner list.


## I want to make a major change to the library
Depending on how big the change is, if the change is fairly small then just a simple PR is fine. But if it has hundreds of lines of code changes then it's best to create an issue prior to even starting to write the code, or you can discuss it with us, either works.


## Notes 
If you have any questions or inquiries, our contact details are in the README.

```

`LICENSE`:

```
MIT License

Copyright (c) 2026 kernelwernel

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
<p align="center">
   <img src="assets/banner.jpg" align="center" width="500" title="VMAware">
   <br>
   <img align="center" src="https://img.shields.io/github/actions/workflow/status/kernelwernel/VMAware/cmake-multi-platform.yml">
   <img align="center" src="https://img.shields.io/github/downloads/kernelwernel/VMAware/total">
   <img align="center" src="https://img.shields.io/badge/License-MIT-yellow.svg">
   <a href="https://deepwiki.com/kernelwernel/VMAware"><img align="center" src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
   <a href="https://discord.gg/hNVHChp7PX"><img align="center" src="https://dcbadge.limes.pink/api/server/https://discord.gg/hNVHChp7PX?style=flat"></a>
   <a href="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml">
     <img align="center" src="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml/badge.svg" alt="CodeQL Analysis">
   </a>

   <div align="center">
      <b>VMAware</b> (VM + Aware) is a cross-platform C++ framework for virtual machine detection.
      <br>
      <br>
      <a href="README_CN.md">ä¸­æ–‡ ğŸ‡¨ğŸ‡³</a> | <a href="README_FR.md">FranÃ§ais ğŸ‡«ğŸ‡·</a> | <a href="README_KR.md">í•œêµ­ì–´ ğŸ‡°ğŸ‡·</a>
   </div>
</p>

- - -

The library is:
- Very easy to use
- Cross-platform (Windows + MacOS + Linux)
- Features around 90 unique VM detection techniques [[list](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#flag-table)]
- Features the most cutting-edge techniques
- Able to detect around 70 VM brands including VMware, VirtualBox, QEMU, Hyper-V, and much more [[list](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#brand-table)]
- Able to beat VM hardeners
- Compatible with x86 and ARM, with backwards compatibility for 32-bit systems
- Very flexible, with total fine-grained control over which techniques get executed
- Able to detect various VM and semi-VM technologies like hypervisors, emulators, containers, sandboxes, and so on
- Available with C++11 and above
- Header-only
- Free of any external dependencies
- Memoized, meaning past results are cached and retrieved if ran again for performance benefits 
- Fully MIT-licensed, allowing unrestricted use and distribution

<br>

> [!NOTE]
> We are looking for translators willing to translate this README into your native language. If you'd like to contribute, feel free to give us a PR! 


## Example ğŸ§ª
```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    if (VM::detect()) {
        std::cout << "Virtual machine detected!" << "\n";
    } else {
        std::cout << "Running on baremetal" << "\n";
    }

    std::cout << "VM name: " << VM::brand() << "\n";
    std::cout << "VM type: " << VM::type() << "\n";
    std::cout << "VM certainty: " << (int)VM::percentage() << "%" << "\n";
    std::cout << "VM hardening: " << (VM::is_hardened() ? "likely" : "not found") << "\n";
}
```

possible output:
```
Virtual machine detected!
VM name: VirtualBox
VM type: Hypervisor (type 2)
VM certainty: 100%
VM hardening: not found
```

<br>

## Structure âš™ï¸

<p align="center">
<img src="assets/vmaware.png" align="center" title="VMAware">
<br>
</p>

<br>

## CLI tool ğŸ”§
This project also provides a handy CLI tool utilising the full potential of what the library can do. It also has cross-platform support.

Below is an example of a basic QEMU system with no hardening modifications on Linux.

<img src="assets/demo.png" title="cli">

<!-- Try it out on [Compiler Explorer](https://godbolt.org/z/4sKa1sqrW)!-->

<br>

## Installation ğŸ“¥
To install the library, download the `vmaware.hpp` file in the latest [release section](https://github.com/kernelwernel/VMAware/releases/latest) to your project. The binaries are also located there. No CMake or shared object linkages are necessary, it's literally that simple.

However, if you want the full project (globally accessible headers with <vmaware.hpp> and the CLI tool), follow these commands:
```bash
git clone https://github.com/kernelwernel/VMAware 
cd VMAware
```

### FOR LINUX:
```bash
sudo dnf/apt/yum update -y # change this to whatever your distro is
mkdir build
cd build
cmake ..
sudo make install
```

### FOR MACOS:
```bash
mkdir build
cd build
cmake ..
sudo make install
```

### FOR WINDOWS:
```bash
cmake -S . -B build/ -G "Visual Studio 16 2019"
```

Optionally, you can create a debug build by appending `-DCMAKE_BUILD_TYPE=Debug` to the cmake arguments.

<br>

### CMake installation
```cmake
# edit this
set(DIRECTORY "/path/to/your/directory/")

set(DESTINATION "${DIRECTORY}vmaware.hpp")

if (NOT EXISTS ${DESTINATION})
    message(STATUS "Downloading VMAware")
    set(URL "https://github.com/kernelwernel/VMAware/releases/latest/download/vmaware.hpp")
    file(DOWNLOAD ${URL} ${DESTINATION} SHOW_PROGRESS)
else()
    message(STATUS "VMAware already downloaded, skipping")
endif()
```

The module file and function version is located [here](auxiliary/vmaware_download.cmake)


<br>

## Documentation and code overview ğŸ“’
You can view the full docs [here](docs/documentation.md). All the details such as functions, techniques, settings, and examples are provided. Trust me, it's not too intimidating ;)

If you want to learn about the architecture and design of the library, head over to https://deepwiki.com/kernelwernel/VMAware

<br>

## Q&A â“

<details>
<summary>How does it work?</summary>
<br>

> It utilises a comprehensive list of low-level and high-level anti-VM techniques that gets accounted in a scoring system. The scores (0-100) for each technique are given based on an objective criteria focused on detecting the most stealthy VMs by minimizing false positives as much as possible, and every technique that has detected a VM will have their score added to a single accumulative point, where a threshold point number will decide whether it's actually running in a VM.

</details>

<details>
<summary>Who is this library for and what are the use cases?</summary>
<br>

> It's designed for security researchers, VM engineers, anticheat developers, and pretty much anybody who needs a practical and rock-solid VM detection mechanism in their project. The library is useful for malware analysts testing the concealment of their VMs and for proprietary software developers aiming to protect their applications from reverse engineering. It's an effective tool to benchmark how well a VM can hide itself from detection.
> 
> Additionally, software could adjust the behaviour of their program based on the detected environment. It could be useful for debugging and testing purposes, while system administrators could manage configurations differently. Finally, some applications might want to legally restrict usage in VMs as a license clause to prevent unauthorized distribution or testing.
>
> There are also projects that utilise our tool such as [Hypervisor-Phantom](https://github.com/Scrut1ny/Hypervisor-Phantom), which is an advanced malware analysis project that we helped strengthen their hypervisor environment and undetectability.

</details>

<details>
<summary>Why another VM detection project?</summary>
<br>

> There's already loads of projects that have the same goal such as 
<a href="https://github.com/CheckPointSW/InviZzzible">InviZzzible</a>, <a href="https://github.com/a0rtega/pafish">pafish</a> and <a href="https://github.com/LordNoteworthy/al-khaser">Al-Khaser</a>. But the difference between the aforementioned projects is that they don't provide a programmable interface to interact with the detection mechanisms, on top of having little to no support for non-Windows systems. Additionally, the VM detections in all those projects are often not sophisticated enough to be practically applied to real-world scenarios while not providing enough VM detection techniques. An additional hurdle is that they are all GPL projects, so using them for proprietary projects (which would be the main audience for such a functionality), is out of the question. 
>
> Pafish and InviZzzible have been abandoned for years. Although Al-Khaser does receive occasional updates and has a wide scope of detections that VMAware doesn't provide (anti-debugging, anti-injection, and so on), it still falls short due to the previously mentioned problems above.
> 
> While those projects have been useful to VMAware to some extent, we wanted to make them far better. Our goal was to make the detection techniques to be accessible programmatically in a cross-platform and flexible way for everybody to get something useful out of it rather than providing just a CLI tool. It also contains a larger quantity of techniques, so it's basically just a VM detection framework on steroids that focuses on practical and realistic usability for any scenario.

</details>

<!--
<details>
<summary>How does it compare to paid VM detection libraries?</summary>
<br>

> There are several paid software solutions available for protecting software licenses from reverse engineering or cracking, such as <a href="https://docs.sentinel.thalesgroup.com/home.htm">Thales' Sentinel RMS</a> and <a href="https://vmpsoft.com/">VMProtect</a>. These tools include VM detection as part of their feature set, though their primary focus is not necessarily VM detection unlike this project.
</details>
-->

<details>
<summary>Wouldn't it make it inferior for having the project open source?</summary>
<br>

> The only downside to VMAware is that it's fully open source, which makes the job of bypassers easier compared to having it closed source. However, We'd argue that's a worthy tradeoff by having as many VM detection techniques in an open and interactive manner rather than trying to obfuscate. Having it open source means we can have valuable community feedback to strengthen the library more effectively and accurately through discussions, collaborations, and competition against anti-anti-vm projects and malware analysis tools which try to hide it's a VM. 
> 
> All of this combined has further advanced the forefront innovations in the field of VM detections much more productively, compared to having it closed source. This is what made the project the best VM detection framework out there, and bypassing it has shown to be an immense challenge due to the sheer number of sophisticated and never-before-seen techniques we employ that other VM detectors don't use whether open or closed source (to our knowledge).
>
> In other words, it's about better quality AND quantity, better feedback, and better openness over security through obfuscation. It's the same reason why OpenSSH, OpenSSL, the Linux kernel, and other security-based software projects are relatively secure because of how there's more people helping to make it better compared to people trying to probe the source code with malicious intent. VMAware has this philosophy, and if you know anything about security, you should be familiar with the phrase: "Security through obfuscation is NOT security".

</details>


<details>
<summary>How effective are VM hardeners against the lib?</summary>
<br>

> Publicly known hardeners are not effective and most of them on Windows have been beaten, but this doesn't mean that the lib is immune to them. Custom hardeners that we may not be aware of might have a theoretical advantage, but they are substantially more difficult to produce.

</details>


<details>
<summary>How is it developed?</summary>
<br>

> Based on online research (ranging from scientific papers to private game-hacking forums and Discord servers), we identify the methods currently used to hide VMs and investigate generic detection techniques capable of finding them, while continuously tracking their activity so we stay one step ahead.
>
> Once we have production-ready code, we upload it directly to the main branch and begin testing in real environments. 
>
> Products that include our library run our detection algorithms on hundreds or even thousands of devices and quietly report back if a VM is detected; those reports are later manually checked for false positives.
>
> If experimental tests and public documentation/databases indicate that false positives have been resolved, we keep the changes in main and assign scores to new detections based on their effectiveness, reliability, and how they operate together with other techniques.
>
> Other situations (false flags, compilation errors, possible vulnerabilities, etc.) are also merged into main immediately.
>
> When the library has accumulated enough changes compared to previous versions, we publish a release and explain those changes in detail.

</details>

<details>
<summary>What about using this for malware?</summary>
<br>

> This project is not soliciting the development of malware for obvious reasons. Even if you intend to use it for concealment purposes, it'll most likely be flagged by antiviruses anyways and nothing is obfuscated to begin with. 
>
> We do not intentionally develop the library to try to stop or avoid EDR flags, such as using direct/indirect syscalling, inline hooking detection, and any other kind of malware evasion technique not related to hypervisor detection.

</details>

<details>
<summary>I have linker errors when compiling</summary>
<br>

> If you're compiling with gcc or clang, add the <code>-lm</code> and <code>-lstdc++</code> flags, or use g++/clang++ compilers instead. If you're receiving linker errors from a brand new VM environment on Linux, update your system with `sudo apt/dnf/yum update -y` to install the necessary C++ components.

</details>

<br>

## Issues, discussions, pull requests, and inquiries ğŸ“¬
If you have any suggestions, ideas, or any sort of contribution, feel free to ask! I'll be more than happy to discuss either in the [issue](https://github.com/kernelwernel/VMAware/issues) or [discussion](https://github.com/kernelwernel/VMAware/discussions) sections. If you want to personally ask something in private, our discords are `kr.nl` and `shenzken`

For email inquiries: `jeanruyv@gmail.com`

And if you found this project useful, a star would be appreciated :)

<br>

## Credits, contributors, and acknowledgements âœ’ï¸
- [kernelwernel](https://github.com/kernelwernel) (Maintainer and developer)
- [Requiem](https://github.com/NotRequiem) (Maintainer and co-developer)
- [Check Point Research](https://research.checkpoint.com/)
- [Unprotect Project](https://unprotect.it/)
- [Al-Khaser](https://github.com/LordNoteworthy/al-khaser)
- [pafish](https://github.com/a0rtega/pafish)
- [Matteo Malvica](https://www.matteomalvica.com)
- N. Rin, EP_X0FF
- [Peter Ferrie, Symantec](https://github.com/peterferrie)
- [Graham Sutherland, LRQA Nettitude](https://www.nettitude.com/uk/)
- [Alex](https://github.com/greenozon)
- [Marek KnÃ¡pek](https://github.com/MarekKnapek)
- [Vladyslav Miachkov](https://github.com/fameowner99)
- [(Offensive Security) Danny Quist](chamuco@gmail.com)
- [(Offensive Security) Val Smith](mvalsmith@metasploit.com)
- Tom Liston + Ed Skoudis
- [Tobias Klein](https://www.trapkit.de/index.html)
- [(S21sec) Alfredo Omella](https://www.s21sec.com/)
- [hfiref0x](https://github.com/hfiref0x)
- [Waleedassar](http://waleedassar.blogspot.com)
- [ä¸€åŠäººç”Ÿ](https://github.com/TimelifeCzy)
- [Thomas Roccia (fr0gger)](https://github.com/fr0gger)
- [systemd project](https://github.com/systemd/systemd)
- mrjaxser
- [iMonket](https://github.com/PrimeMonket)
- Eric Parker's discord community 
- [ShellCode33](https://github.com/ShellCode33)
- [Georgii Gennadev (D00Movenok)](https://github.com/D00Movenok)
- [utoshu](https://github.com/utoshu)
- [Jyd](https://github.com/jyd519)
- [git-eternal](https://github.com/git-eternal)
- [dmfrpro](https://github.com/dmfrpro)
- [Teselka](https://github.com/Teselka)
- [Kyun-J](https://github.com/Kyun-J)
- [luukjp](https://github.com/luukjp)
- [Randark](https://github.com/Randark-JMT)
- [Scrut1ny](https://github.com/Scrut1ny)
- [Lorenzo Rizzotti (Dreaming-Codes)](https://github.com/Dreaming-Codes)

<br>

## Legal ğŸ“œ
I am not responsible nor liable for any damage you cause through any malicious usage of this project. 

License: MIT

```

`README_CN.md`:

```md
<p align="center">
   <img src="assets/banner.jpg" align="center" width="500" title="VMAware">
   <br>
   <img align="center" src="https://img.shields.io/github/actions/workflow/status/kernelwernel/VMAware/cmake-multi-platform.yml">
   <img align="center" src="https://img.shields.io/github/downloads/kernelwernel/VMAware/total">
   <img align="center" src="https://img.shields.io/badge/License-MIT-yellow.svg">
   <a href="https://deepwiki.com/kernelwernel/VMAware"><img align="center" src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
   <a href="https://discord.gg/hNVHChp7PX"><img align="center" src="https://dcbadge.limes.pink/api/server/https://discord.gg/hNVHChp7PX?style=flat"></a>
   <a href="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml">
     <img align="center" src="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml/badge.svg" alt="CodeQL Analysis">
   </a>


   <div align="center">
      <b>VMAware</b> (VM + Aware) æ˜¯ä¸€ä¸ªè·¨å¹³å°çš„C++è™šæ‹Ÿæœºæ£€æµ‹åº“ã€‚
      <br>
      <br>
      <a href="README.md">English ğŸ‡¬ğŸ‡§</a> | <a href="README_FR.md">FranÃ§ais ğŸ‡«ğŸ‡·</a> | <a href="README_KR.md">í•œêµ­ì–´ ğŸ‡°ğŸ‡·</a>
   </div>
</p>

- - -

è¿™ä¸ªåº“:

- éå¸¸æ˜“äºä½¿ç”¨
- è·¨å¹³å° (Windows + MacOS + Linux)
- æ¶µç›–çº¦100ç§ç‹¬ç‰¹çš„è™šæ‹Ÿæœºæ£€æµ‹æ–¹æ¡ˆ ã€[åˆ—è¡¨](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#flag-table)ã€‘
- é‡‡ç”¨æœ€å°–ç«¯çš„æŠ€æœ¯
- èƒ½å¤Ÿæ£€æµ‹è¶…è¿‡70ç§è™šæ‹Ÿæœºå“ç‰Œï¼ŒåŒ…æ‹¬ VMwareã€VirtualBoxã€QEMUã€Hyper-V ç­‰ç­‰ ã€[åˆ—è¡¨](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#brand-table)ã€‘
- èƒ½å¤Ÿå‡»è´¥ VM ç¡¬åŒ–æŠ€æœ¯
- å…¼å®¹ x86 å’Œ ARM æ¶æ„ï¼Œå¹¶å‘ä¸‹å…¼å®¹ 32 ä½ç³»ç»Ÿ
- éå¸¸çµæ´»ï¼Œå¯å¯¹æ‰§è¡Œå“ªäº›æŠ€æœ¯è¿›è¡Œå®Œå…¨ç²¾ç»†åŒ–çš„æ§åˆ¶
- èƒ½å¤Ÿæ£€æµ‹å„ç§è™šæ‹Ÿæœºå’ŒåŠè™šæ‹ŸæœºæŠ€æœ¯ï¼Œå¦‚è™šæ‹Ÿæœºç›‘æ§ç¨‹åºã€æ¨¡æ‹Ÿå™¨ã€å®¹å™¨ã€æ²™ç®±ç­‰ã€‚
- é€‚ç”¨äº C++11 åŠæ›´é«˜ç‰ˆæœ¬
- çº¯å¤´æ–‡ä»¶å®ç°
- ä¸å­˜åœ¨ä»»ä½•å¤–éƒ¨ä¾èµ–
- å…·å¤‡è®°å¿†åŠŸèƒ½ï¼šè‹¥ç›¸åŒè®¡ç®—å†æ¬¡æ‰§è¡Œï¼Œä¼šä»ç¼“å­˜ä¸­ç›´æ¥è·å–è¿‡å¾€ç»“æœï¼Œè€Œéé‡æ–°è®¡ç®—ï¼Œä»è€Œè·å¾—æ€§èƒ½æå‡
- æœ¬é¡¹ç›®å®Œå…¨é‡‡ç”¨MITè®¸å¯è¯æˆæƒï¼Œå…è®¸ä¸å—é™åˆ¶åœ°ä½¿ç”¨ã€ä¿®æ”¹å’Œåˆ†å‘

<br>

## ä¾‹å­ ğŸ§ª

```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    if (VM::detect()) {
        std::cout << "Virtual machine detected!" << "\n";
    } else {
        std::cout << "Running on baremetal" << "\n";
    }

    std::cout << "VM name: " << VM::brand() << "\n";
    std::cout << "VM type: " << VM::type() << "\n";
    std::cout << "VM certainty: " << (int)VM::percentage() << "%" << "\n";
    std::cout << "VM hardening: " << (VM::is_hardened() ? "likely" : "not found") << "\n";
}
```

å¯èƒ½çš„è¾“å‡ºï¼š

```plaintext
Virtual machine detected!
VM name: VirtualBox
VM type: Hypervisor (type 2)
VM certainty: 100%
VM hardening: not found
```

<br>

## æ¶æ„ âš™ï¸

![VMAware library Structure](assets/vmaware.png)

<br>

## å‘½ä»¤è¡Œå·¥å…· ğŸ”§

è¯¥é¡¹ç›®è¿˜æä¾›äº†ä¸€ä¸ªä¾¿æ·çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œå……åˆ†å‘æŒ¥äº†åº“çš„å…¨éƒ¨æ½œåŠ›ã€‚å®ƒè¿˜å…·æœ‰è·¨å¹³å°æ”¯æŒã€‚

ä¸‹é¢ä¸ºä¸€ä¸ªåœ¨ Linux ç³»ç»Ÿä¸Šæœªä½œä»»ä½•å®‰å…¨åŠ å›ºçš„åŸºç¡€QEMUç³»ç»Ÿçš„ä¾‹å­

![cli](assets/demo.png)

<!-- Try it out on [Compiler Explorer](https://godbolt.org/z/4sKa1sqrW)!-->

<br>

## å®‰è£… ğŸ“¥

è¦å®‰è£…æ­¤åº“ï¼Œè¯·ä» [æœ€æ–°çš„å‘å¸ƒ](https://github.com/kernelwernel/VMAware/releases/latest) ä¸­è·å– `vmaware.hpp` æ–‡ä»¶å¹¶ç½®äºæ‚¨çš„é¡¹ç›®ä¸­ã€‚é¢„ç¼–è¯‘äºŒè¿›åˆ¶æ–‡ä»¶äº¦ä½äºè¯¥å¤„ã€‚æ— éœ€ CMake é…ç½®æˆ–å…±äº«åº“é“¾æ¥ï¼Œè¿‡ç¨‹æä¸ºç®€ä¾¿ã€‚

ç„¶è€Œï¼Œè‹¥éœ€è·å–å®Œæ•´é¡¹ç›®ï¼ˆå³å…¨å±€å¯è®¿é—®çš„ `vmaware.hpp` å¤´æ–‡ä»¶åŠå‘½ä»¤è¡Œå·¥å…·ï¼‰ï¼Œè¯·ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤ï¼š

```bash
git clone https://github.com/kernelwernel/VMAware 
cd VMAware
```

### å¯¹äº Linux

```bash
sudo dnf/apt/yum update -y # change this to whatever your distro is
mkdir build
cd build
cmake ..
sudo make install
```

### å¯¹äº MacOS

```bash
mkdir build
cd build
cmake ..
sudo make install
```

### å¯¹äº Windows

```bash
cmake -S . -B build/ -G "Visual Studio 16 2019"
```

å¦‚éœ€å¯ç”¨è°ƒè¯•åŠŸèƒ½ï¼Œå¯é€šè¿‡åœ¨CMakeå‚æ•°ä¸­è¿½åŠ  `-DCMAKE_BUILD_TYPE=Debug` æ¥åˆ›å»ºè°ƒè¯•ç‰ˆæœ¬ã€‚

### CMake å®‰è£…

```cmake
# edit this
set(DIRECTORY "/path/to/your/directory/")

set(DESTINATION "${DIRECTORY}vmaware.hpp")

if (NOT EXISTS ${DESTINATION})
    message(STATUS "Downloading VMAware")
    set(URL "https://github.com/kernelwernel/VMAware/releases/latest/download/vmaware.hpp")
    file(DOWNLOAD ${URL} ${DESTINATION} SHOW_PROGRESS)
else()
    message(STATUS "VMAware already downloaded, skipping")
endif()
```

æ¨¡å—æ–‡ä»¶åŠå‡½æ•°ç‰ˆæœ¬ä½äº [auxiliary/vmaware_download.cmake](auxiliary/vmaware_download.cmake)

<br>

## æ–‡æ¡£ä¸ä»£ç æ¦‚è¿° ğŸ“’

æ‚¨å¯åœ¨ [docs/documentation.md](docs/documentation.md) æŸ¥çœ‹å®Œæ•´æ–‡æ¡£ ã€‚å…¶ä¸­è¯¦å°½åˆ—å‡ºäº†æ‰€æœ‰ç»†èŠ‚ï¼ŒåŒ…æ‹¬åŠŸèƒ½ã€æŠ€æœ¯ã€è®¾ç½®åŠç¤ºä¾‹ã€‚ç›¸ä¿¡æˆ‘ï¼Œå†…å®¹å¹¶ä¸å¤æ‚

è‹¥æƒ³äº†è§£æœ¬åº“çš„æ¶æ„ä¸è®¾è®¡ï¼Œè¯·è®¿é—® [DeepWiki - VMAware](https://deepwiki.com/kernelwernel/VMAware)

<br>

## Q&A â“

<details>
<summary>å®ƒæ˜¯å¦‚ä½•è¿ä½œçš„ï¼Ÿ</summary>

> è¯¥åº“åˆ©ç”¨ä¸€ä¸ªåŒ…å«åº•å±‚ä¸é«˜å±‚æŠ€æœ¯çš„å…¨é¢åVMæ£€æµ‹æ¸…å•ï¼Œå¹¶é‡‡ç”¨ä¸€å¥—è¯„åˆ†æœºåˆ¶ã€‚æ¯ç§æŠ€æœ¯ï¼ˆ0-100åˆ†ï¼‰çš„æƒé‡å‡åŸºäºæ—¨åœ¨æœ€å¤§é™åº¦å‡å°‘è¯¯æŠ¥ã€ä¸“æ³¨æ£€æµ‹é«˜éšè”½æ€§è™šæ‹Ÿæœºçš„å®¢è§‚æ ‡å‡†ã€‚ä»»ä½•æˆåŠŸæ£€æµ‹åˆ°VMçš„æŠ€æœ¯éƒ½ä¼šå°†å…¶åˆ†æ•°ç´¯åŠ è‡³ä¸€ä¸ªæ±‡æ€»ç‚¹ï¼Œå½“è¯¥æ±‡æ€»ç‚¹è¶…è¿‡é¢„è®¾é˜ˆå€¼æ—¶ï¼Œå³è§¦å‘VMç¯å¢ƒåˆ¤å®šã€‚

</details>

<details>
<summary>è¿™ä¸ªåº“æ˜¯ä¸ºè°å‡†å¤‡çš„ï¼Ÿæœ‰å“ªäº›ä½¿ç”¨åœºæ™¯ï¼Ÿ</summary>

> è¯¥å·¥å…·ä¸“ä¸ºå®‰å…¨ç ”ç©¶äººå‘˜ã€è™šæ‹Ÿæœºå·¥ç¨‹å¸ˆã€åä½œå¼Šå¼€å‘è€…ä»¥åŠä»»ä½•éœ€è¦åœ¨é¡¹ç›®ä¸­éƒ¨ç½²å®ç”¨ä¸”åšä¸å¯æ‘§çš„è™šæ‹Ÿæœºæ£€æµ‹æœºåˆ¶çš„äººå£«è®¾è®¡ã€‚è¯¥åº“æ—¢èƒ½å¸®åŠ©æ¶æ„è½¯ä»¶åˆ†æå¸ˆæµ‹è¯•å…¶è™šæ‹Ÿæœºçš„éšè”½æ€§ï¼Œä¹Ÿèƒ½åŠ©åŠ›ä¸“æœ‰è½¯ä»¶å¼€å‘è€…ä¿æŠ¤åº”ç”¨ç¨‹åºå…é­é€†å‘å·¥ç¨‹æ”»å‡»ã€‚å®ƒå ªç§°è¯„ä¼°è™šæ‹Ÿæœºéšè”½æ£€æµ‹èƒ½åŠ›çš„æœ‰æ•ˆåŸºå‡†å·¥å…·ã€‚
>
> æ­¤å¤–ï¼Œè½¯ä»¶å¯æ ¹æ®æ£€æµ‹åˆ°çš„ç¯å¢ƒè°ƒæ•´ç¨‹åºè¡Œä¸ºã€‚è¿™åœ¨è°ƒè¯•å’Œæµ‹è¯•è¿‡ç¨‹ä¸­é¢‡å…·å®ç”¨ä»·å€¼ï¼ŒåŒæ—¶ç³»ç»Ÿç®¡ç†å‘˜ä¹Ÿèƒ½çµæ´»ç®¡ç†é…ç½®æ–¹æ¡ˆã€‚æœ€åï¼ŒæŸäº›åº”ç”¨ç¨‹åºå¯èƒ½éœ€è¦é€šè¿‡è®¸å¯è¯æ¡æ¬¾åœ¨æ³•å¾‹å±‚é¢é™åˆ¶è™šæ‹Ÿæœºä½¿ç”¨ï¼Œä»¥é˜²æ­¢æœªç»æˆæƒçš„åˆ†å‘æˆ–æµ‹è¯•è¡Œä¸ºã€‚
>
> è¿˜æœ‰ä¸€äº›é¡¹ç›®é‡‡ç”¨äº†æˆ‘ä»¬çš„å·¥å…·ï¼Œä¾‹å¦‚ [Hypervisor-Phantom](https://github.com/Scrut1ny/Hypervisor-Phantom)ï¼Œè¿™æ˜¯ä¸€ä¸ªé«˜çº§æ¶æ„è½¯ä»¶åˆ†æé¡¹ç›®ï¼Œæˆ‘ä»¬ååŠ©å…¶å¼ºåŒ–äº†è™šæ‹Ÿæœºç›‘æ§ç¨‹åºç¯å¢ƒå¹¶æå‡äº†éšè”½æ€§ã€‚

</details>

<details>
<summary>ä¸ºä»€ä¹ˆè¦åšåˆä¸€ä¸ªè™šæ‹Ÿæœºæ£€æµ‹é¡¹ç›®ï¼Ÿ</summary>

> å½“å‰å·²æœ‰å¤§é‡åŒç±»é¡¹ç›®ï¼Œä¾‹å¦‚ [InviZzzible](https://github.com/CheckPointSW/InviZzzible), [pafish](https://github.com/a0rtega/pafish) å’Œ [Al-Khaser](https://github.com/LordNoteworthy/al-khaser)ã€‚ ä½†å…³é”®å·®å¼‚åœ¨äºï¼šè¿™äº›é¡¹ç›®æ—¢æœªæä¾›å¯ç¼–ç¨‹æ¥å£æ¥è°ƒç”¨æ£€æµ‹æœºåˆ¶ï¼Œåˆå‡ ä¹å®Œå…¨ä¸æ”¯æŒé Windows ç³»ç»Ÿã€‚æ›´é‡è¦çš„æ˜¯ï¼Œå®ƒä»¬çš„è™šæ‹Ÿæœºæ£€æµ‹æŠ€æœ¯å¾€å¾€ä¸å¤Ÿç²¾å¯†ï¼Œéš¾ä»¥åº”ç”¨äºå®é™…åœºæ™¯ï¼Œä¸”æ”¯æŒçš„æ£€æµ‹æ–¹æ¡ˆæ•°é‡æœ‰é™ã€‚å¦ä¸€ä¸ªå…³é”®éšœç¢æ˜¯è¿™äº›é¡¹ç›®å‡é‡‡ç”¨ GPL åè®®ï¼Œå¯¼è‡´æ— æ³•è¢«ä¸“æœ‰è½¯ä»¶é¡¹ç›®ï¼ˆè¿™ç±»åŠŸèƒ½çš„ä¸»è¦éœ€æ±‚æ–¹ï¼‰ç›´æ¥é›†æˆä½¿ç”¨ã€‚
>
> Pafishä¸InviZzzibleé¡¹ç›®å·²åœæ›´å¤šå¹´ã€‚å°½ç®¡Al-Khaserä»ä¼šå¶å°”æ›´æ–°ï¼Œä¸”å…·å¤‡VMAwareæœªè¦†ç›–çš„å¹¿æ³›æ£€æµ‹èŒƒå›´ï¼ˆå¦‚åè°ƒè¯•ã€åæ³¨å…¥ç­‰ï¼‰ï¼Œä½†ç”±äºå‰æ–‡æ‰€è¿°çš„å„ç§å±€é™ï¼Œå…¶å®é™…æ•ˆæœä¾ç„¶ä¸å°½å¦‚äººæ„ã€‚
>
> è™½ç„¶è¿™äº›é¡¹ç›®å¯¹ VMAware çš„ç ”å‘æœ‰ä¸€å®šå€Ÿé‰´æ„ä¹‰ï¼Œä½†æˆ‘ä»¬çš„ç›®æ ‡æ˜¯å®ç°å…¨é¢è¶…è¶Šã€‚æ ¸å¿ƒåœ¨äºè®©æ£€æµ‹æŠ€æœ¯èƒ½é€šè¿‡ç¼–ç¨‹æ–¹å¼è·¨å¹³å°çµæ´»è°ƒç”¨ï¼Œä½¿æ‰€æœ‰å¼€å‘è€…éƒ½èƒ½ä»ä¸­è·ç›Šâ€”â€”è€Œéä»…æä¾›å‘½ä»¤è¡Œå·¥å…·ã€‚æ­¤å¤–ï¼Œæœ¬æ¡†æ¶è¿˜æ•´åˆäº†æ›´å¤§é‡çš„æ£€æµ‹æŠ€æœ¯ï¼Œå ªç§°å¼ºåŒ–ç‰ˆçš„è™šæ‹Ÿæœºæ£€æµ‹æ¡†æ¶ï¼Œä¸“æ³¨äºä¸ºä»»ä½•åœºæ™¯æä¾›åˆ‡å®å¯ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚

</details>

<!--
<details>
<summary>å®ƒä¸ä»˜è´¹çš„è™šæ‹Ÿæœºæ£€æµ‹åº“ç›¸æ¯”å¦‚ä½•ï¼Ÿ</summary>
<br>

> å½“å‰å¸‚é¢ä¸Šå­˜åœ¨å¤šæ¬¾ç”¨äºä¿æŠ¤è½¯ä»¶è®¸å¯ã€é˜²æ­¢é€†å‘å·¥ç¨‹æˆ–ç ´è§£çš„ä»˜è´¹è§£å†³æ–¹æ¡ˆï¼Œä¾‹å¦‚ [Thales' Sentinel RMS](https://docs.sentinel.thalesgroup.com/home.htm) å’Œ [VMProtect](https://vmpsoft.com/)ã€‚è¿™äº›å·¥å…·è™½å°†è™šæ‹Ÿæœºæ£€æµ‹çº³å…¥å…¶åŠŸèƒ½é›†ï¼Œä½†å…¶æ ¸å¿ƒç„¦ç‚¹å¹¶éè™šæ‹Ÿæœºæ£€æµ‹æŠ€æœ¯â€”â€”è¿™ä¸æœ¬é¡¹ç›®çš„ä¸“ç²¾æ–¹å‘æˆªç„¶ä¸åŒã€‚

</details>

-->

<details>
<summary>å¦‚æœé¡¹ç›®å¼€æºçš„è¯ï¼Œä¸ä¼šè®©è¿™ä¸ªé¡¹ç›®å˜å·®å—ï¼Ÿ</summary>

> VMAwareå”¯ä¸€çš„ç¼ºç‚¹åœ¨äºå…¶å®Œå…¨å¼€æºçš„æ€§è´¨â€”â€”ä¸é—­æºç›¸æ¯”ï¼Œè¿™ç¡®å®ä¼šè®©ç»•è¿‡æ£€æµ‹è€…æ›´å®¹æ˜“åˆ†æä»£ç ã€‚ä½†æˆ‘ä»¬è®¤ä¸ºè¿™æ˜¯å€¼å¾—çš„æƒè¡¡ï¼šé€šè¿‡ä»¥å¼€æ”¾äº’åŠ¨çš„æ–¹å¼æ•´åˆå¤§é‡è™šæ‹Ÿæœºæ£€æµ‹æŠ€æœ¯ï¼Œè¿œæ¯”ä¾èµ–ä»£ç æ··æ·†æ›´æœ‰ä»·å€¼ã€‚å¼€æºæ„å‘³ç€æˆ‘ä»¬èƒ½é€šè¿‡ç¤¾åŒºè®¨è®ºã€åä½œå¼€å‘ä»¥åŠä¸ååè™šæ‹Ÿæœºé¡¹ç›®ã€æ¶æ„è½¯ä»¶åˆ†æå·¥å…·çš„æŒç»­å¯¹æŠ—ï¼Œè·å¾—å®è´µçš„åé¦ˆï¼Œä»è€Œæ›´é«˜æ•ˆç²¾å‡†åœ°å¼ºåŒ–æ£€æµ‹åº“ã€‚
>
> ä¸é—­æºæ¨¡å¼ç›¸æ¯”ï¼Œè¿™äº›ä¼˜åŠ¿å…±åŒæ¨åŠ¨ç€è™šæ‹Ÿæœºæ£€æµ‹é¢†åŸŸçš„å‰æ²¿åˆ›æ–°ä»¥æ›´é«˜æ•ˆç‡å‘å±•ã€‚è¿™æ­£æ˜¯æœ¬é¡¹ç›®èƒ½æˆä¸ºå½“å‰æœ€ä½³è™šæ‹Ÿæœºæ£€æµ‹æ¡†æ¶çš„åŸå› â€”â€”ç”±äºæˆ‘ä»¬é‡‡ç”¨äº†å¤§é‡å…¶ä»–æ£€æµ‹å™¨ï¼ˆæ— è®ºå¼€æºæˆ–é—­æºï¼‰æœªæ›¾ä½¿ç”¨è¿‡çš„å°–ç«¯åˆ›æ–°æŠ€æœ¯ï¼Œè¦æˆåŠŸç»•è¿‡å®ƒå·²è¢«è¯æ˜æ˜¯æå…·æŒ‘æˆ˜æ€§çš„ã€‚
>
> æ¢è¨€ä¹‹ï¼Œè¿™ä»£è¡¨ç€åœ¨è´¨é‡ä¸æ•°é‡ã€åé¦ˆæœºåˆ¶ä»¥åŠå¼€æ”¾ç¨‹åº¦ä¸Šçš„å…¨é¢æå‡ï¼Œè€Œéä¾èµ–æ··æ·†æŠ€æœ¯æ¥å®ç°å®‰å…¨ã€‚è¿™æ­£æ˜¯ OpenSSHã€OpenSSLã€Linux å†…æ ¸ç­‰å®‰å…¨ç±»å¼€æºé¡¹ç›®èƒ½å¤Ÿä¿æŒç›¸å¯¹å®‰å…¨æ€§çš„æ ¹æœ¬åŸå› â€”â€”å‚ä¸æ”¹è¿›çš„è´¡çŒ®è€…æ•°é‡è¿œå¤šäºæ€€æœ‰æ¶æ„æ¢æŸ¥æºä»£ç çš„å°è¯•è€…ã€‚VMAwareç§‰æ‰¿è¿™ä¸€ç†å¿µï¼Œå¦‚æœæ‚¨äº†è§£å®‰å…¨é¢†åŸŸï¼Œå¿…ç„¶ç†Ÿæ‚‰è¿™å¥ç®´è¨€ï¼šâ€œé€šè¿‡æ··æ·†å®ç°çš„å®‰å…¨ï¼Œæ ¹æœ¬ç®—ä¸ä¸ŠçœŸæ­£çš„å®‰å…¨â€ã€‚

</details>

<details>
<summary>è™šæ‹ŸæœºåŠ å›ºæªæ–½å¯¹æ­¤åº“çš„é˜²æŠ¤æ•ˆæœå¦‚ä½•ï¼Ÿ</summary>

> å·²çŸ¥çš„å…¬å¼€å¼ºåŒ–å·¥å…·å¤§å¤šå·²å¤±æ•ˆï¼Œå°¤å…¶åœ¨Windowså¹³å°ä¸Šå¤šæ•°å·²è¢«æ”»ç ´ï¼Œä½†è¿™å¹¶ä¸æ„å‘³æœ¬æ£€æµ‹åº“èƒ½å®Œå…¨å…ç–«ã€‚é‚£äº›å°šæœªè¢«æŠ«éœ²çš„å®šåˆ¶åŒ–å¼ºåŒ–å·¥å…·æˆ–è®¸å…·å¤‡ç†è®ºä¸Šçš„ä¼˜åŠ¿ï¼Œä½†å…¶å¼€å‘éš¾åº¦ä¹Ÿå‘ˆæ•°é‡çº§å¢é•¿ã€‚

</details>

<details>
<summary>å®ƒæ˜¯å¦‚ä½•å¼€å‘çš„ï¼Ÿ</summary>

> åŸºäºçº¿ä¸Šç ”ç©¶ï¼ˆæ¶µç›–å­¦æœ¯è®ºæ–‡åˆ°ç§äººæ¸¸æˆç ´è§£è®ºå›åŠ Discord ç¤¾ç¾¤ç­‰æ¸ é“ï¼‰ï¼Œæˆ‘ä»¬è¯†åˆ«å½“å‰ç”¨äºéšè—è™šæ‹Ÿæœºçš„æ–¹æ³•ï¼Œå¹¶ç ”ç©¶èƒ½å¤Ÿæ£€æµ‹å®ƒä»¬çš„é€šç”¨æ£€æµ‹æ‰‹æ®µï¼ŒåŒæ—¶æŒç»­è¿½è¸ªå…¶æ´»åŠ¨ä»¥ä¿æŒé¢†å…ˆã€‚
> 
> å½“æˆ‘ä»¬å®Œæˆç”Ÿäº§çº§ä»£ç åï¼Œä¼šç›´æ¥å°†å…¶ä¸Šä¼ åˆ° main åˆ†æ”¯å¹¶åœ¨çœŸå®ç¯å¢ƒå¼€å§‹æµ‹è¯•ã€‚ä½¿ç”¨æˆ‘ä»¬åº“çš„äº§å“ä¼šåœ¨æ•°ç™¾ç”šè‡³æ•°åƒå°è®¾å¤‡ä¸Šè¿è¡Œæ£€æµ‹ç®—æ³•ï¼Œè‹¥æ£€æµ‹åˆ°è™šæ‹Ÿæœºä¼šé™é»˜ä¸ŠæŠ¥ï¼›è¿™äº›ä¸ŠæŠ¥éšåç”±äººå·¥æ ¸éªŒè¯¯æŠ¥ã€‚
> 
> å¦‚æœå®éªŒæµ‹è¯•å’Œå…¬å¼€æ–‡æ¡£/æ•°æ®åº“çš„çº¿ä¸Šè¯æ®è¡¨æ˜è¯¯æŠ¥å·²è¢«ä¿®æ­£ï¼Œæˆ‘ä»¬ä¼šå°†å˜æ›´ä¿ç•™åœ¨ mainï¼Œå¹¶æ ¹æ®æ–°æ£€æµ‹é¡¹çš„æœ‰æ•ˆæ€§ã€å¯é æ€§åŠä¸å…¶ä»–æŠ€æœ¯çš„ååŒè¡¨ç°å¯¹å…¶è¿›è¡Œè¯„åˆ†ã€‚
> 
> å…¶ä»–æƒ…å†µï¼ˆä¾‹å¦‚è¯¯æŠ¥æ ‡è®°ã€ç¼–è¯‘é”™è¯¯ã€æ½œåœ¨æ¼æ´ç­‰ï¼‰ä¹Ÿä¼šç«‹å³åˆå¹¶åˆ° mainã€‚
> 
> å½“åº“ç›¸æ¯”ä¹‹å‰çš„ç‰ˆæœ¬ç§¯ç´¯äº†è¶³å¤Ÿçš„æ”¹è¿›åï¼Œæˆ‘ä»¬ä¼šå‘å¸ƒæ–°ç‰ˆæœ¬ï¼Œå¹¶åœ¨å‘å¸ƒè¯´æ˜ä¸­è¯¦ç»†è¯´æ˜è¿™äº›æ›´æ”¹ã€‚

</details>

<details>
<summary>é‚£å°†è¿™ä¸ªé¡¹ç›®ç”¨åœ¨æ¶æ„è½¯ä»¶å‘¢ï¼Ÿ</summary>

> å‡ºäºæ˜¾è€Œæ˜“è§çš„åŸå› ï¼Œæœ¬é¡¹ç›®ä¸æ‹›å‹Ÿæ¶æ„è½¯ä»¶å¼€å‘è€…ã€‚å³ä¾¿æ‚¨æ‰“ç®—å°†å…¶ç”¨äºéšè”½ç›®çš„ï¼Œåç—…æ¯’è½¯ä»¶ä¹Ÿæå¯èƒ½å°†å…¶æ ‡è®°ä¸ºå¨èƒï¼Œå†µä¸”ç¨‹åºæœ¬èº«å¹¶æœªè¿›è¡Œä»»ä½•æ··æ·†å¤„ç†ã€‚
>
> æˆ‘ä»¬å¹¶æœªåˆ»æ„å¼€å‘æ­¤åº“ä»¥è§„é¿ç»ˆç«¯æ£€æµ‹ä¸å“åº”ï¼ˆEDRï¼‰ç³»ç»Ÿçš„æ£€æµ‹æ ‡è¯†ï¼Œä¾‹å¦‚é‡‡ç”¨ç›´æ¥/é—´æ¥ç³»ç»Ÿè°ƒç”¨ã€å†…è”é’©å­æ£€æµ‹ç­‰æ¶æ„è½¯ä»¶é€ƒé€¸æŠ€æœ¯ã€‚å½“å‰å®ç°çš„æ‰€æœ‰æŠ€æœ¯æ‰‹æ®µå‡ä¸“æ³¨äºè™šæ‹Ÿæœºæ£€æµ‹é¢†åŸŸï¼Œä¸æ¶‰åŠä»»ä½•ä¸æ¶æ„è§„é¿ç›¸å…³çš„åŠŸèƒ½å¼€å‘ã€‚

</details>

<details>
<summary>æˆ‘åœ¨ç¼–è¯‘æ—¶é‡åˆ°é“¾æ¥é”™è¯¯ï¼Ÿ</summary>

> è‹¥æ‚¨åœ¨ä½¿ç”¨ gcc æˆ– clang è¿›è¡Œç¼–è¯‘ï¼Œè¯·æ·»åŠ  `-lm` å’Œ `-lstdc++` ç¼–è¯‘é€‰é¡¹ï¼Œæˆ–ç›´æ¥æ”¹ç”¨ g++ / clang++ ç¼–è¯‘å™¨ã€‚è‹¥åœ¨å…¨æ–°çš„ Linux è™šæ‹Ÿæœºç¯å¢ƒä¸­é‡åˆ°é“¾æ¥å™¨æŠ¥é”™ï¼Œè¯·æ‰§è¡Œ `sudo apt/dnf/yum update -y` æ›´æ–°ç³»ç»Ÿä»¥å®‰è£…å¿…è¦çš„ C++ ç»„ä»¶ã€‚

</details>

<br>

## é—®é¢˜ã€è®¨è®ºã€æ‹‰å–è¯·æ±‚å’Œå’¨è¯¢ ğŸ“¬

æ¬¢è¿æå‡ºå»ºè®®ã€åˆ†äº«æƒ³æ³•æˆ–å‚ä¸ä»»ä½•å½¢å¼çš„è´¡çŒ®ï¼æˆ‘ä»¬éå¸¸ä¹æ„åœ¨ [Issues](https://github.com/kernelwernel/VMAware/issues) æˆ– [Discussions](https://github.com/kernelwernel/VMAware/discussions) æ¿å—ä¸æ‚¨äº¤æµã€‚æˆ‘ä»¬é€šå¸¸éƒ½ä¼šå°½å¿«å›å¤ã€‚è‹¥éœ€ç§ä¸‹è”ç³»ï¼Œå¯é€šè¿‡ Discord è´¦å· `kr.nl` æˆ– `shenzken` è”ç³»æˆ‘ä»¬ã€‚

é‚®ä»¶å’¨è¯¢è¯·è‡³ï¼š`jeanruyv@gmail.com`

å¦‚æœæœ¬é¡¹ç›®å¯¹æ‚¨æœ‰æ‰€å¸®åŠ©ï¼Œæ¬¢è¿ä¸ºæˆ‘ä»¬ç‚¹äº®ä¸€é¢— Star

<br>

## é¸£è°¢ã€è´¡çŒ®è€…åŠè‡´è°¢ âœ’ï¸

- [kernelwernel](https://github.com/kernelwernel) (Maintainer and developer)
- [Requiem](https://github.com/NotRequiem) (Maintainer and co-developer)
- [Check Point Research](https://research.checkpoint.com/)
- [Unprotect Project](https://unprotect.it/)
- [Al-Khaser](https://github.com/LordNoteworthy/al-khaser)
- [pafish](https://github.com/a0rtega/pafish)
- [Matteo Malvica](https://www.matteomalvica.com)
- N. Rin, EP_X0FF
- [Peter Ferrie, Symantec](https://github.com/peterferrie)
- [Graham Sutherland, LRQA Nettitude](https://www.nettitude.com/uk/)
- [Alex](https://github.com/greenozon)
- [Marek KnÃ¡pek](https://github.com/MarekKnapek)
- [Vladyslav Miachkov](https://github.com/fameowner99)
- [(Offensive Security) Danny Quist](chamuco@gmail.com)
- [(Offensive Security) Val Smith](mvalsmith@metasploit.com)
- Tom Liston + Ed Skoudis
- [Tobias Klein](https://www.trapkit.de/index.html)
- [(S21sec) Alfredo Omella](https://www.s21sec.com/)
- [hfiref0x](https://github.com/hfiref0x)
- [Waleedassar](http://waleedassar.blogspot.com)
- [ä¸€åŠäººç”Ÿ](https://github.com/TimelifeCzy)
- [Thomas Roccia (fr0gger)](https://github.com/fr0gger)
- [systemd project](https://github.com/systemd/systemd)
- mrjaxser
- [iMonket](https://github.com/PrimeMonket)
- Eric Parker's discord community
- [ShellCode33](https://github.com/ShellCode33)
- [Georgii Gennadev (D00Movenok)](https://github.com/D00Movenok)
- [utoshu](https://github.com/utoshu)
- [Jyd](https://github.com/jyd519)
- [git-eternal](https://github.com/git-eternal)
- [dmfrpro](https://github.com/dmfrpro)
- [Teselka](https://github.com/Teselka)
- [Kyun-J](https://github.com/Kyun-J)
- [luukjp](https://github.com/luukjp)
- [Randark](https://github.com/Randark-JMT)
- [Scrut1ny](https://github.com/Scrut1ny)
- [Lorenzo Rizzotti (Dreaming-Codes)](https://github.com/Dreaming-Codes)

<br>

## æ³•å¾‹å£°æ˜ ğŸ“œ

ä»»ä½•å› æ¶æ„ä½¿ç”¨æœ¬é¡¹ç›®æ‰€é€ æˆçš„æŸå®³ï¼Œæœ¬äººæ¦‚ä¸è´Ÿè´£ã€‚

è®¸å¯è¯ï¼šMIT

```

`README_FR.md`:

```md
<p align="center">
   <img src="assets/banner.jpg" align="center" width="500" title="VMAware">
   <br>
   <img align="center" src="https://img.shields.io/github/actions/workflow/status/kernelwernel/VMAware/cmake-multi-platform.yml">
   <img align="center" src="https://img.shields.io/github/downloads/kernelwernel/VMAware/total">
   <img align="center" src="https://img.shields.io/badge/License-MIT-yellow.svg">
   <a href="https://deepwiki.com/kernelwernel/VMAware"><img align="center" src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
   <a href="https://discord.gg/hNVHChp7PX"><img align="center" src="https://dcbadge.limes.pink/api/server/https://discord.gg/hNVHChp7PX?style=flat"></a>
   <a href="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml">
     <img align="center" src="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml/badge.svg" alt="CodeQL Analysis">
   </a>


   <div align="center">
      <b>VMAware</b> (VM + Aware) est une bibliothÃ¨que C++ multiplateforme pour la dÃ©tection des machines virtuelles.
      <br>
      <br>
      <a href="README_CN.md">ä¸­æ–‡ ğŸ‡¨ğŸ‡³</a> | <a href="README_FR.md">FranÃ§ais ğŸ‡«ğŸ‡·</a> | <a href="README_KR.md">í•œêµ­ì–´ ğŸ‡°ğŸ‡·</a>
   </div>
</p>

- - -

Cette bibliothÃ¨que est :
- TrÃ¨s facile Ã  utiliser
- Multiplateforme (Windows, MacOS et Linux)
- Offre une centaine de techniques uniques pour dÃ©tecter les machines virtuelles [[liste](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#flag-table)]
- Offre les techniques les plus avancÃ©es
- Capable de dÃ©tecter plus de 70 marques de machines virtuelles, notamment VMware, VirtualBox, QEMU, Hyper-V et bien d'autres [[liste](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#brand-table)]
- Capable de contourner les renforts des VM
- Compatible avec x86 et ARM, avec rÃ©trocompatibilitÃ© pour les systÃ¨mes 32 bits
- TrÃ¨s flexible, avec un contrÃ´le prÃ©cis sur les techniques exÃ©cutÃ©es
- Capable de dÃ©tecter diverses technologies VM et semi-VM telles que les hyperviseurs, les Ã©mulateurs, les conteneurs, les sandbox, etc.
- Disponible avec C++11 et versions ultÃ©rieures
- header-only
- Sans aucune dÃ©pendance externe
- MÃ©moÃ¯sÃ©, ce qui signifie que les rÃ©sultats passÃ©s sont mis en cache et rÃ©cupÃ©rÃ©s en cas de nouvelle exÃ©cution pour amÃ©liorer les performances
- EntiÃ¨rement sous licence MIT, permettant une utilisation et une distribution sans restriction

<br>

## Exemple ğŸ§ª
```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    if (VM::detect()) {
        std::cout << "Virtual machine detected!" << "\n";
    } else {
        std::cout << "Running on baremetal" << "\n";
    }

    std::cout << "VM name: " << VM::brand() << "\n";
    std::cout << "VM type: " << VM::type() << "\n";
    std::cout << "VM certainty: " << (int)VM::percentage() << "%" << "\n";
    std::cout << "VM hardening: " << (VM::is_hardened() ? "likely" : "not found") << "\n";
}
```

rÃ©sultat possible:
```
Virtual machine detected!
VM name: VirtualBox
VM type: Hypervisor (type 2)
VM certainty: 100%
VM hardening: not found
```

<br>

## Structure âš™ï¸

<p align="center">
<img src="assets/vmaware.png" align="center" title="VMAware">
<br>
</p>

<br>

## Outil CLI ğŸ”§
Ce projet fournit Ã©galement un outil CLI pratique qui exploite tout le potentiel de la bibliothÃ¨que. Il offre Ã©galement une prise en charge multiplateforme.

Vous trouverez ci-dessous un exemple de systÃ¨me QEMU de base sans modifications de renforcement sofiles Linux.

<img src="assets/demo.png" title="cli">

<!-- Try it out on [Compiler Explorer](https://godbolt.org/z/4sKa1sqrW)!-->

<br>

## Installation ğŸ“¥
To install the library, download the `vmaware.hpp` file in the latest [release section](https://github.com/kernelwernel/VMAware/releases/latest) to your project. The binaries are also located there. No CMake or shared object linkages are necessary, it's literally that simple.

However, if you want the full project (globally accessible headers with <vmaware.hpp> and the CLI tool), follow these commands:

Pour installer la bibliothÃ¨que, tÃ©lÃ©chargez le fichier `vmaware.hpp` dans la derniÃ¨re [section de publication](https://github.com/kernelwernel/VMAware/releases/latest) vers votre projet. Les binaires s'y trouvent Ã©galement. Aucun CMake ni les liens des shared objects sont nÃ©cessaire, c'est aussi simple que Ã§a.

Toutefois, si vous souhaitez obtenir le projet complet (ficher header accessibles globalement avec <vmaware.hpp> et l'outil CLI), suivez ces commandes:
```bash
git clone https://github.com/kernelwernel/VMAware 
cd VMAware
```

### FOR LINUX:
```bash
sudo dnf/apt/yum update -y # modifiez ceci en fonction de votre distribution.
mkdir build
cd build
cmake ..
sudo make install
```

### FOR MACOS:
```bash
mkdir build
cd build
cmake ..
sudo make install
```

### FOR WINDOWS:
```bash
cmake -S . -B build/ -G "Visual Studio 16 2019"
```

Vous pouvez Ã©galement crÃ©er une version de dÃ©bogage en ajoutant `-DCMAKE_BUILD_TYPE=Debug` aux arguments cmake.

<br>

### Installation avec CMake
```cmake
# changer ceci
set(DIRECTORY "/path/to/your/directory/")

set(DESTINATION "${DIRECTORY}vmaware.hpp")

if (NOT EXISTS ${DESTINATION})
    message(STATUS "Downloading VMAware")
    set(URL "https://github.com/kernelwernel/VMAware/releases/latest/download/vmaware.hpp")
    file(DOWNLOAD ${URL} ${DESTINATION} SHOW_PROGRESS)
else()
    message(STATUS "VMAware already downloaded, skipping")
endif()
```

Le fichier du module et la version fonctionelle se trouvent [ici](auxiliary/vmaware_download.cmake)

<br>

## Documentation et aperÃ§u du code ğŸ“’
Vous pouvez consulter la documentation complÃ¨te [ici](docs/documentation.md). Vous y trouverez tous les dÃ©tails comme les: fonctions, techniques, paramÃ¨tres et des exemples. Croyez-moi, ce nâ€™est pas si compliquÃ© ;)

Si vous voulez comprendre lâ€™architecture et la conception de la bibliothÃ¨que, rendez-vous sur https://deepwiki.com/kernelwernel/VMAware

<br>

## Questions et rÃ©ponses â“

<details>
<summary>Comment Ã§a marche?</summary>
<br>

> Ce systÃ¨me utilise une liste exhaustive de techniques anti-VM de bas et de haut niveau, prises en compte dans un systÃ¨me de notation. Les scores (de 0 Ã  100) attribuÃ©s Ã  chaque technique sont basÃ©s sur des critÃ¨res objectifs visant Ã  dÃ©tecter les VM les plus furtives en minimisant les faux positifs. Le score de chaque technique ayant dÃ©tectÃ© une VM est ajoutÃ© Ã  un total cumulatif. Un seuil de points dÃ©termine si la technique est effectivement exÃ©cutÃ©e dans une VM.

</details>

<details>
<summary>Ã€ qui s'adresse cette bibliothÃ¨que et quels sont ses cas d'utilisation?</summary>
<br>

> C'est conÃ§ue pour les chercheurs en sÃ©curitÃ©, les ingÃ©nieurs des VM, les dÃ©veloppeurs de solutions anti-triche et, plus gÃ©nÃ©ralement, toute personne ayant besoin d'un mÃ©canisme de dÃ©tection de machines virtuelles fiable et performant. Cette bibliothÃ¨que est utile aux analystes des malwares testant la dissimulation de leurs VM et aux dÃ©veloppeurs de logiciels propriÃ©taires souhaitant protÃ©ger leurs applications contre les reverse engineers. Elle constitue un outil efficace pour Ã©valuer la capacitÃ© d'une VM Ã  se dissimuler.
> 
> De plus, les logiciels pourraient adapter leur comportement en fonction de l'environnement dÃ©tectÃ©. Cela pourrait s'avÃ©rer utile pour le dÃ©bogage et les tests, tandis que les administrateurs systÃ¨me pourraient gÃ©rer les configurations diffÃ©remment. Enfin, certaines applications pourraient souhaiter restreindre lÃ©galement leur utilisation dans les VM, par exemple via une clause de licence, afin d'empÃªcher toute distribution ou tout test non autorisÃ©.
>
> Il existe Ã©galement des projets qui utilisent notre outil tels que [Hypervisor-Phantom](https://codeberg.org/Scrut1ny/Hypervisor-Phantom), qui est un projet d'analyse de logiciels malveillants avancÃ© que nous avons aidÃ© Ã  renforcer leur environnement hyperviseur et leur indÃ©tectabilitÃ©.

</details>

<details>
<summary>Pourquoi un autre projet de dÃ©tection des VM?</summary>
<br>

> De nombreux projets poursuivent dÃ©jÃ  le mÃªme objectif, tels que :
<a href="https://github.com/CheckPointSW/InviZzzible">InviZzzible</a>, <a href="https://github.com/a0rtega/pafish">pafish</a> et <a href="https://github.com/LordNoteworthy/al-khaser">Al-Khaser</a>. Cependant, ces projets se distinguent par lâ€™absence dâ€™interface programmable permettant dâ€™interagir avec leurs mÃ©canismes de dÃ©tection, ainsi que par une prise en charge trÃ¨s limitÃ©e, et du support inexistant des systÃ¨mes non-Windows. De plus, leurs systÃ¨mes de dÃ©tection des VM sont souvent trop simplistes pour une application concrÃ¨te, et ils ne proposent pas suffisamment de techniques de dÃ©tection. Un obstacle supplÃ©mentaire rÃ©side dans le fait qu'il s'agit de projets sous licence GPL. Donc, l'utilisation pour des projets propriÃ©taires (qui constitueraient le principal public cible de cette fonctionnalitÃ©) est exclue.
>
> Pafish et InviZzzible sont abandonnÃ©s depuis des annÃ©es. Bien qu'Al-Khaser bÃ©nÃ©ficie des mises Ã  jour occasionnelles et offre un large Ã©ventail de dÃ©tections que VMAware n'offre pas (anti-debugging, anti-injection, etc.), il reste inefficace en raison des problÃ¨mes mentionnÃ©s prÃ©cÃ©demment.
> 
> Bien que ces projets aient Ã©tÃ© utiles Ã  VMAware dans une certaine mesure, nous souhaitions les amÃ©liorer considÃ©rablement. Notre objectif Ã©tait de rendre les techniques de dÃ©tection accessibles par programmation, de maniÃ¨re multiplateforme et flexible, afin que chacun puisse en tirer profit, plutÃ´t que de fournir un simple outil en ligne de commande. Al-Khaser intÃ¨gre Ã©galement un plus grand nombre de techniques ; il s'agit donc essentiellement d'un framework de dÃ©tection des VM ultra-performant, axÃ© sur une utilisation pratique et rÃ©aliste dans tous les scÃ©narios.

</details>

<details>
<summary>Le fait que le projet soit open source ne le dÃ©savantage-t-il pas?</summary>
<br>

> Le seul inconvÃ©nient de VMAware est qu'il est entiÃ¨rement open source, ce qui facilite la tÃ¢che des pirates par rapport Ã  un logiciel propriÃ©taire. Nous estimons toutefois que ce compromis est justifiÃ© par la mise Ã  disposition d'un maximum de techniques de dÃ©tection des VM de maniÃ¨re ouverte et interactive, plutÃ´t que par la dissimulation. Le fait que le logiciel soit open source nous permet de bÃ©nÃ©ficier des prÃ©cieux retours de la communautÃ© afin d'amÃ©liorer la bibliothÃ¨que de maniÃ¨re plus efficace et prÃ©cise grÃ¢ce aux discussions, aux collaborations et Ã  la concurrence avec les projets anti-anti-VM et les outils d'analyse de malware qui tentent de masquer la nature virtuelle d'un logiciel.
> 
> Tout cela a permis de faire progresser les innovations de pointe dans le domaine de la dÃ©tection des VM de maniÃ¨re beaucoup plus productive qu'avec un logiciel propriÃ©taire. C'est ce qui a fait de notre projet le meilleur framework de dÃ©tection de VM qui existe, et le contourner s'avÃ¨re extrÃªmement difficile en raison du nombre considÃ©rable de techniques sophistiquÃ©es et inÃ©dites que nous utilisons et que les autres dÃ©tecteurs des VM, qu'ils soient open source ou propriÃ©taires (Ã  notre connaissance), n'emploient pas.
> 
> En d'autres termes, nous privilÃ©gions la qualitÃ© ET la quantitÃ©, les retours d'information et la transparence Ã  la sÃ©curitÃ© par l'obfuscation. C'est la mÃªme raison pour laquelle OpenSSH, OpenSSL, le kernel Linux et d'autres logiciels de sÃ©curitÃ© sont relativement sÃ©curisÃ©s: leur amÃ©lioration est favorisÃ©e par une communautÃ© plus nombreuse que les tentatives malveillantes d'analyser le code source. VMAware partage cette philosophie, et si vous vous intÃ©ressez Ã  la sÃ©curitÃ©, vous connaissez sans doute l'adage: Â«La sÃ©curitÃ© par l'obfuscation n'est PAS la sÃ©curitÃ©.Â»

</details>


<details>
<summary>Quelle est l'efficacitÃ© des outils de renforcement de la sÃ©curitÃ© des VM contre la bibliothÃ¨que?</summary>

> Les outils de renforcement connus du public sont inefficaces et la plupart de ceux utilisÃ©s sous Windows ont Ã©tÃ© contournÃ©s. Cependant, cela ne signifie pas que la bibliothÃ¨que y est immunisÃ©e. Des outils personnalisÃ©s, parfois inconnus, pourraient prÃ©senter un avantage thÃ©orique, mais leur dÃ©veloppement est bien plus complexe.

</details>


<details>
<summary>Comment est-il dÃ©veloppÃ©?</summary>
<br>

> Ã€ partir de recherches en ligne (articles scientifiques, forums privÃ©s de piratage de jeux, serveurs Discord, etc.), nous identifions les mÃ©thodes utilisÃ©es pour dissimuler les VM et Ã©tudions des techniques de dÃ©tection gÃ©nÃ©rales capables de les repÃ©rer, tout en surveillant en permanence leur activitÃ© pour garder une longueur d'avance.
> 
> Une fois le code prÃªt pour la production, nous le tÃ©lÃ©versons directement sur la branche main et commenÃ§ons les tests en conditions rÃ©elles. 
> 
> Les produits intÃ©grant notre bibliothÃ¨que exÃ©cutent nos algorithmes de dÃ©tection sur des centaines voire des milliers d'appareils et nous signalent discrÃ¨tement toute dÃ©tection de VM ; ces signalements sont ensuite vÃ©rifiÃ©s manuellement pour dÃ©tecter d'Ã©ventuels faux positifs.
> 
> Si les tests expÃ©rimentaux et les preuves issues de la documentation et des bases de donnÃ©es publiques confirment que les faux positifs ont Ã©tÃ© corrigÃ©s, nous conservons les modifications sur main et attribuons un score aux nouvelles dÃ©tections selon leur efficacitÃ©, leur fiabilitÃ© et leur interaction avec les autres techniques.
> 
> D'autres situations (faux positifs, erreurs de compilation, vulnÃ©rabilitÃ©s potentielles, etc.) sont Ã©galement intÃ©grÃ©es immÃ©diatement sur main.
> 
> Quand la bibliothÃ¨que a accumulÃ© suffisamment de modifications par rapport aux versions prÃ©cÃ©dentes, nous publions une release et dÃ©taillons les changements dans les notes de version.

</details>

<details>
<summary>Qu'en est-il de son utilisation pour des logiciels malveillants?</summary>
<br>

> Ce projet n'encourage pas le dÃ©veloppement de logiciels malveillants (ou malware), pour des raisons Ã©videntes. MÃªme si vous envisagez de l'utiliser Ã  des fins de dissimulation, il sera trÃ¨s probablement dÃ©tectÃ© par les antivirus de toute faÃ§on, et rien n'est obfusquÃ© au dÃ©part.
>
> Nous ne dÃ©veloppons pas intentionnellement cette bibliothÃ¨que dans le but de bloquer ou de contourner les indicateurs EDR, tels que l'utilisation des syscall directs/indirects, la dÃ©tection d'interception en ligne et toute autre technique d'Ã©vasion de logiciels malveillants non liÃ©e Ã  la dÃ©tection par hyperviseur.

</details>

<details>
<summary>J'ai des erreurs du linkeur lors de la compilation</summary>
<br>

> Si vous compilez avec gcc ou clang, ajoutez les options <code>-lm</code> et <code>-lstdc++</code>, ou utilisez plutÃ´t les compilateurs g++/clang++. Si vous rencontrez des erreurs de l'Ã©diteur de liens depuis un environnement de VM Linux flambant neuf, mettez Ã  jour votre systÃ¨me avec `sudo apt/dnf/yum update -y` pour installer les composants C++ nÃ©cessaires.

</details>

<br>

## ProblÃ¨mes, discussions, demandes de tirage (pull requests) et questions ğŸ“¬
N'hÃ©sitez pas Ã  nous faire part de vos suggestions, idÃ©es ou contributions! Nous serons ravis d'en discuter dans les sections [issues](https://github.com/kernelwernel/VMAware/issues) ou [discussions](https://github.com/kernelwernel/VMAware/discussions). Nous rÃ©pondons gÃ©nÃ©ralement assez rapidement. Si vous souhaitez nous poser une question en privÃ©, vous pouvez nous contacter sur Discord: `kr.nl` et `shenzken`.

Pour toute question par e-mail: `jeanruyv@gmail.com`

Et si ce projet vous a Ã©tÃ© utile, un star serait trÃ¨s apprÃ©ciÃ© :)

<br>

## CrÃ©dits, contributeurs et remerciements âœ’ï¸
- [kernelwernel](https://github.com/kernelwernel) (Maintainer and developer)
- [Requiem](https://github.com/NotRequiem) (Maintainer and co-developer)
- [Check Point Research](https://research.checkpoint.com/)
- [Unprotect Project](https://unprotect.it/)
- [Al-Khaser](https://github.com/LordNoteworthy/al-khaser)
- [pafish](https://github.com/a0rtega/pafish)
- [Matteo Malvica](https://www.matteomalvica.com)
- N. Rin, EP_X0FF
- [Peter Ferrie, Symantec](https://github.com/peterferrie)
- [Graham Sutherland, LRQA Nettitude](https://www.nettitude.com/uk/)
- [Alex](https://github.com/greenozon)
- [Marek KnÃ¡pek](https://github.com/MarekKnapek)
- [Vladyslav Miachkov](https://github.com/fameowner99)
- [(Offensive Security) Danny Quist](chamuco@gmail.com)
- [(Offensive Security) Val Smith](mvalsmith@metasploit.com)
- Tom Liston + Ed Skoudis
- [Tobias Klein](https://www.trapkit.de/index.html)
- [(S21sec) Alfredo Omella](https://www.s21sec.com/)
- [hfiref0x](https://github.com/hfiref0x)
- [Waleedassar](http://waleedassar.blogspot.com)
- [ä¸€åŠäººç”Ÿ](https://github.com/TimelifeCzy)
- [Thomas Roccia (fr0gger)](https://github.com/fr0gger)
- [systemd project](https://github.com/systemd/systemd)
- mrjaxser
- [iMonket](https://github.com/PrimeMonket)
- Eric Parker's discord community 
- [ShellCode33](https://github.com/ShellCode33)
- [Georgii Gennadev (D00Movenok)](https://github.com/D00Movenok)
- [utoshu](https://github.com/utoshu)
- [Jyd](https://github.com/jyd519)
- [git-eternal](https://github.com/git-eternal)
- [dmfrpro](https://github.com/dmfrpro)
- [Teselka](https://github.com/Teselka)
- [Kyun-J](https://github.com/Kyun-J)
- [luukjp](https://github.com/luukjp)
- [Randark](https://github.com/Randark-JMT)
- [Scrut1ny](https://github.com/Scrut1ny)
- [Lorenzo Rizzotti (Dreaming-Codes)](https://github.com/Dreaming-Codes)

<br>


## Mentions lÃ©gales ğŸ“œ
Je dÃ©cline toute responsabilitÃ© en cas de dommages causÃ©s par une utilisation malveillante de ce projet.

Licence : MIT
```

`README_KR.md`:

```md
<p align="center">
   <img src="assets/banner.jpg" align="center" width="500" title="VMAware">
   <br>
   <img align="center" src="https://img.shields.io/github/actions/workflow/status/kernelwernel/VMAware/cmake-multi-platform.yml">
   <img align="center" src="https://img.shields.io/github/downloads/kernelwernel/VMAware/total">
   <img align="center" src="https://img.shields.io/badge/License-MIT-yellow.svg">
   <a href="https://deepwiki.com/kernelwernel/VMAware"><img align="center" src="https://deepwiki.com/badge.svg" alt="Ask DeepWiki"></a>
   <a href="https://discord.gg/hNVHChp7PX"><img align="center" src="https://dcbadge.limes.pink/api/server/https://discord.gg/hNVHChp7PX?style=flat"></a>
   <a href="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml">
     <img align="center" src="https://github.com/kernelwernel/VMAware/actions/workflows/code_ql_analysis.yml/badge.svg" alt="CodeQL Analysis">
   </a>

   <div align="center">
      <b>VMAware</b> (VM + Aware)ëŠ” ê°€ìƒ ë¨¸ì‹  íƒì§€ë¥¼ ìœ„í•œ í¬ë¡œìŠ¤ í”Œë«í¼ C++ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì…ë‹ˆë‹¤.
      <br>
      <br>
      <a href="README.md">English ğŸ‡¬ğŸ‡§</a> | <a href="README_CN.md">ä¸­æ–‡ ğŸ‡¨ğŸ‡³</a> | <a href="README_FR.md">FranÃ§ais ğŸ‡«ğŸ‡·</a>
   </div>
</p>

- - -

ë¼ì´ë¸ŒëŸ¬ë¦¬ íŠ¹ì§•:
- ë§¤ìš° ê°„ë‹¨í•œ ì‚¬ìš©
- í¬ë¡œìŠ¤ í”Œë«í¼ ì§€ì› (Windows + MacOS + Linux)
- 100ì—¬ê°œì˜ ê°€ìƒ ë¨¸ì‹  ê°ì§€ ê¸°ìˆ  [[ëª©ë¡](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#flag-table)]
- ê·¸ë¦¬ê³  ê°€ì¥ ì„ êµ¬ì ì¸ ê°ì§€ ê¸°ìˆ 
- VMAware, VirtualBox, QEMU, Hyper-Vë“±ì„ í¬í•¨í•˜ëŠ” 70ê°€ì§€ ì´ìƒì˜ VM ë¸Œëœë“œ ê°ì§€ [[ëª©ë¡](https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#brand-table)]
- VM ë³´ì•ˆ ê°•í™” ë¬´ë ¥í™”
- x86, ARM ì•„í‚¤í…ì²˜ ë° 32ë¹„íŠ¸ ì‹œìŠ¤í…œì—ì„œë„ ì‚¬ìš© ê°€ëŠ¥
- ë§¤ìš° ìœ ì—°í•œ êµ¬ì¡°ë¡œ, í•„ìš”í•œ ê¸°ìˆ  êµ¬í˜„ì— ì„¸ë¶€ì ì¸ ì œì–´
- í•˜ì´í¼ë°”ì´ì €, ì—ë®¬ë ˆì´í„°, ì»¨í…Œì´ë„ˆ, ìƒŒë“œë°•ìŠ¤ ë“± ì¤€ ê°€ìƒ ë¨¸ì‹  ê°ì§€
- C++11 ì´ìƒë¶€í„° í˜¸í™˜
- ìˆœìˆ˜ í—¤ë” íŒŒì¼ êµ¬í˜„
- ì™¸ë¶€ ì¢…ì†ì„±ì´ ì—†ìŒ
- ë©”ëª¨ì´ì§• ê¸°ëŠ¥ìœ¼ë¡œ ì´ì „ ê²°ê³¼ë¥¼ ìºì‹±í•˜ì—¬ ê°ì§€ì‹œ ì„±ëŠ¥ì„ í–¥ìƒ
- ì´ í”„ë¡œì íŠ¸ëŠ” MIT ë¼ì´ì„ ìŠ¤ë¡œ ì œí•œ ì—†ëŠ” ì‚¬ìš©, ìˆ˜ì • ë° ë°°í¬ê°€ í—ˆìš©ë©ë‹ˆë‹¤.

<br>


## ì‚¬ìš© ì˜ˆì‹œ ğŸ§ª
```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    if (VM::detect()) {
        std::cout << "Virtual machine detected!" << "\n";
    } else {
        std::cout << "Running on baremetal" << "\n";
    }

    std::cout << "VM name: " << VM::brand() << "\n";
    std::cout << "VM type: " << VM::type() << "\n";
    std::cout << "VM certainty: " << (int)VM::percentage() << "%" << "\n";
    std::cout << "VM hardening: " << (VM::is_hardened() ? "likely" : "not found") << "\n";
}
```

ì¶œë ¥ ì˜ˆì‹œ:
```
Virtual machine detected!
VM name: VirtualBox
VM type: Hypervisor (type 2)
VM certainty: 100%
VM hardening: not found
```

<br>

## ë¼ì´ë¸ŒëŸ¬ë¦¬ êµ¬ì¡° âš™ï¸

<p align="center">
<img src="assets/vmaware.png" align="center" title="VMAware">
<br>
</p>

<br>

## CLI ë„êµ¬ ğŸ”§
ì´ í”„ë¡œì íŠ¸ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ê¸°ëŠ¥ì„ ìµœëŒ€í•œ í™œìš©í•˜ê¸° ìœ„í•´ í¬ë¡œìŠ¤ í”Œë«í¼ì„ ì§€ì›í•˜ëŠ” CLI ë„êµ¬ë„ ì œê³µí•©ë‹ˆë‹¤.

ì•„ë˜ëŠ” ë³´ì•ˆ ê°•í™” ì—†ì´ ì‚¬ìš©í•˜ëŠ” ë¦¬ëˆ…ìŠ¤ì—ì„œì˜ ê¸°ë³¸ QEMU ê°ì§€ ì˜ˆì‹œì…ë‹ˆë‹¤.

<img src="assets/demo.png" title="cli">

<!-- Try it out on [Compiler Explorer](https://godbolt.org/z/4sKa1sqrW)!-->

<br>

## ì„¤ì¹˜ ë°©ë²• ğŸ“¥
[ìµœì‹  ë¦´ë¦¬ì¦ˆ](https://github.com/kernelwernel/VMAware/releases/latest)ì—ì„œ vmaware.hpp íŒŒì¼ì„ ë‹¤ìš´ë¡œë“œí•˜ê³ , í”„ë¡œì íŠ¸ì— ì¶”ê°€í•˜ì„¸ìš”. ë¯¸ë¦¬ ì»´íŒŒì¼ëœ ë°”ì´ë„ˆë¦¬ íŒŒì¼ë“¤ë„ ì¤€ë¹„ë˜ì–´ ìˆìŠµë‹ˆë‹¤.  
CMakeë‚˜ ê³µìœ  ë¼ì´ë¸ŒëŸ¬ë¦¬ ë§í¬ ì„¤ì •ì´ í•„ìš”í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë§ ê·¸ëŒ€ë¡œ ë§¤ìš° ê°„ë‹¨í•©ë‹ˆë‹¤.

ì „ì²´ í”„ë¡œì íŠ¸ë¥¼ í¬í•¨ ì‹œí‚¤ê³ ì í•œë‹¤ë©´(ì¦‰ ì „ì—­ì ìœ¼ë¡œ vmaware.hppì™€ CLI ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ê³ ì í•œë‹¤ë©´), ë¨¼ì € ì´ í”„ë¡œì íŠ¸ë¥¼ ê°€ì ¸ì˜¨ë‹¤ìŒ
```bash
git clone https://github.com/kernelwernel/VMAware 
cd VMAware
```

ì´í›„ í”Œë«í¼ì— ë”°ë¼ ë‹¤ìŒ ì»¤ë§¨ë“œë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.

### ë¦¬ëˆ…ìŠ¤
```bash
sudo dnf/apt/yum update -y # change this to whatever your distro is
mkdir build
cd build
cmake ..
sudo make install
```

### MacOS
```bash
mkdir build
cd build
cmake ..
sudo make install
```

### ìœˆë„ìš°
```bash
cmake -S . -B build/ -G "Visual Studio 16 2019"
```

ì¶”ê°€ë¡œ, CMake ë§¤ê°œë³€ìˆ˜ì— `-DCMAKE_BUILD_TYPE=Debug`ë¥¼ ì¶”ê°€í•˜ì—¬ ë””ë²„ê·¸ ë¹Œë“œë¥¼ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<br>

### CMake ì„¤ì¹˜
```cmake
# edit this
set(DIRECTORY "/path/to/your/directory/")

set(DESTINATION "${DIRECTORY}vmaware.hpp")

if (NOT EXISTS ${DESTINATION})
    message(STATUS "Downloading VMAware")
    set(URL "https://github.com/kernelwernel/VMAware/releases/latest/download/vmaware.hpp")
    file(DOWNLOAD ${URL} ${DESTINATION} SHOW_PROGRESS)
else()
    message(STATUS "VMAware already downloaded, skipping")
endif()
```
ëª¨ë“ˆ íŒŒì¼ê³¼ í•¨ìˆ˜ ë²„ì „ì€ [ì´ê³³](auxiliary/vmaware_download.cmake)ì— ì‘ì„±ë˜ì–´ ìˆìŠµë‹ˆë‹¤.

<br>

## ë¬¸ì„œ ë° ì½”ë“œ ê°œìš” ğŸ“’
ì „ì²´ ë¬¸ì„œëŠ” [ì´ê³³](docs/documentation.md) ì—ì„œ í™•ì¸í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•¨ìˆ˜, ê¸°ìˆ , ì„¤ì •, ì˜ˆì‹œê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë³µì¡í•˜ì§€ ì•Šì•„ìš”! ;)

ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ì˜ ì•„í‚¤í…ì²˜ ë° ë””ìì¸ì— ëŒ€í•´ ìƒì„¸íˆ ì•Œê³ ì‹¶ìœ¼ì‹œë©´, https://deepwiki.com/kernelwernel/VMAware ì„ ë°©ë¬¸í•˜ì„¸ìš”

<br>

## Q&A â“

<details>
<summary>ì–´ë–»ê²Œ ë™ì‘í•˜ë‚˜ìš”?</summary>
<br>

> ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì €ìˆ˜ì¤€ ë° ê³ ìˆ˜ì¤€ ê¸°ìˆ ì„ ëª¨ë‘ í¬í•¨í•˜ëŠ” í¬ê´„ì ì¸ ì•ˆí‹° VM íƒì§€ ì²´í¬ë¦¬ìŠ¤íŠ¸ë¥¼ í™œìš©í•˜ê³ , ê°€ì¤‘ì¹˜ í• ë‹¹ ë©”ì»¤ë‹ˆì¦˜ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ê° ê¸°ìˆ ì˜ ê°€ì¤‘ì¹˜(0-100)ëŠ” ì˜¤íƒ(false positive)ì„ ìµœì†Œí™”í•˜ê³  ê³ ë„ë¡œ ì€ë°€í•œ ê°€ìƒ ë¨¸ì‹  íƒì§€ì— ì§‘ì¤‘í•˜ë„ë¡ ì„¤ê³„ëœ ê°ê´€ì ì¸ ê¸°ì¤€ì„ ê¸°ë°˜ìœ¼ë¡œ í•©ë‹ˆë‹¤. VMì„ ì„±ê³µì ìœ¼ë¡œ íƒì§€í•œ ê¸°ìˆ ì— ì„¤ì •ëœ ê°€ì¤‘ì¹˜ê°€ ëˆ„ì ë˜ë©°, ì´ ì ìˆ˜ê°€ ë¯¸ë¦¬ ì„¤ì •ëœ ì„ê³„ê°’ì„ ì´ˆê³¼í•˜ë©´ VM í™˜ê²½ìœ¼ë¡œ íŒë³„ë©ë‹ˆë‹¤.

</details>

<details>
<summary>ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì™œ í•„ìš”í•˜ë©° ëˆ„ê°€ ì‚¬ìš© í•  ìˆ˜ ìˆë‚˜ìš”?</summary>
<br>

> ì´ ë„êµ¬ëŠ” ë³´ì•ˆ ì—°êµ¬ì›, ê°€ìƒ ë¨¸ì‹  ì—”ì§€ë‹ˆì–´, í™”ì´íŠ¸ í•´ì»¤, ê·¸ë¦¬ê³  í”„ë¡œì íŠ¸ì— ì‹¤ìš©ì ì´ê³  ê°•ë ¥í•œ ê°€ìƒ ë¨¸ì‹  íƒì§€ ë©”ì»¤ë‹ˆì¦˜ì„ êµ¬ì¶•í•´ì•¼ í•˜ëŠ” ëª¨ë“  ì‚¬ìš©ìë¥¼ ìœ„í•´ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë©€ì›¨ì–´ ë¶„ì„ê°€ê°€ ê°€ìƒ ë¨¸ì‹ ì˜ ì€í ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•˜ëŠ” ë° ë„ì›€ì„ ì£¼ê³ , ë…ì  ì†Œí”„íŠ¸ì›¨ì–´ ê°œë°œìê°€ ë¦¬ë²„ìŠ¤ ì—”ì§€ë‹ˆì–´ë§ ê³µê²©ìœ¼ë¡œë¶€í„° ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë³´í˜¸í•˜ëŠ” ë° ë„ì›€ì„ ì¤ë‹ˆë‹¤. ë˜í•œ, ê°€ìƒ ë¨¸ì‹  ì€í íƒì§€ ê¸°ëŠ¥ì„ í‰ê°€í•˜ëŠ” íš¨ê³¼ì ì¸ ë²¤ì¹˜ë§ˆí¬ ë„êµ¬ ì—­í• ì„ í•©ë‹ˆë‹¤.
> 
> ë˜í•œ, ì´ ì†Œí”„íŠ¸ì›¨ì–´ëŠ” ê°ì§€ëœ í™˜ê²½ì— ë”°ë¼ ë™ì‘ì„ ì¡°ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ë””ë²„ê¹… ë° í…ŒìŠ¤íŠ¸ ì‹œ ë§¤ìš° ìœ ìš©í•  ë¿ë§Œ ì•„ë‹ˆë¼ ì‹œìŠ¤í…œ ê´€ë¦¬ìì—ê²Œ êµ¬ì„± ì²´ê³„ë¥¼ ìœ ì—°í•˜ê²Œ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ, ì¼ë¶€ ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ë¬´ë‹¨ ë°°í¬ ë˜ëŠ” í…ŒìŠ¤íŠ¸ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ë¼ì´ì„ ìŠ¤ ì¡°ê±´ì„ í†µí•´ ê°€ìƒ ë¨¸ì‹  ì‚¬ìš©ì— ëŒ€í•œ ë²•ì  ì œí•œì„ ìš”êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
>
> ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ë‹¤ë¥¸ í”„ë¡œì íŠ¸ë“¤ ì—ì„œë„ í™œìš©ë˜ê³  ìˆìŠµë‹ˆë‹¤. ëŒ€í‘œì ìœ¼ë¡œ ê³ ê¸‰ ë©€ì›¨ì–´ ë¶„ì„ í”„ë¡œì íŠ¸ì¸ [Hypervisor-Phantom](https://github.com/Scrut1ny/Hypervisor-Phantom)ì—ì„œ ê°€ìƒ ë¨¸ì‹  ëª¨ë‹ˆí„°ë§  í™˜ê²½ê³¼ ì€ë°€ì„±ì„ ê°œì„ í•˜ëŠ”ë° ë„ì›€ì„ ì£¼ì—ˆìŠµë‹ˆë‹¤.

</details>

<details>
<summary>ë‹¤ë¥¸ ê°€ìƒë¨¸ì‹  í”„ë¡œì íŠ¸ì™€ ë‹¤ë¥¸ ì ì€ ë¬´ì—‡ì¸ê°€ìš”?</summary>
<br>

> <a href="https://github.com/CheckPointSW/InviZzzible">InviZzzible</a>, <a href="https://github.com/a0rtega/pafish">pafish</a>, <a href="https://github.com/LordNoteworthy/al-khaser">Al-Khaser</a>ì™€ ê°™ì€ ìœ ì‚¬í•œ í”„ë¡œì íŠ¸ê°€ ì´ë¯¸ ë§ì´ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì£¼ìš” ì°¨ì´ì ì€ ì´ëŸ¬í•œ í”„ë¡œì íŠ¸ê°€ íƒì§€ ë©”ì»¤ë‹ˆì¦˜ì„ í˜¸ì¶œí•˜ëŠ” í”„ë¡œê·¸ë˜ë° ê°€ëŠ¥í•œ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ì§€ ì•Šê³  ìœˆë„ìš°ê°€ ì•„ë‹Œ ì‹œìŠ¤í…œì— ëŒ€í•œ ì§€ì›ì„ ê±°ì˜ ì œê³µí•˜ì§€ ì•ŠëŠ”ë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. ë” ì¤‘ìš”í•œ ê²ƒì€, ì´ëŸ¬í•œ ê°€ìƒ ë¨¸ì‹  íƒì§€ ê¸°ìˆ ì´ ì¢…ì¢… ì •í™•ë„ê°€ ë‚®ì•„ ì‹¤ì œ ìƒí™©ì— ì ìš©í•˜ê¸° ì–´ë µê³ , ì§€ì›í•˜ëŠ” íƒì§€ ê¸°ìˆ ë„ ì œí•œì ì´ë¼ëŠ” ê²ƒì…ë‹ˆë‹¤. ë˜ ë‹¤ë¥¸ ì£¼ìš” ì¥ì• ë¬¼ì€ ì´ëŸ¬í•œ í”„ë¡œì íŠ¸ê°€ ëª¨ë‘ GPL ë¼ì´ì„ ìŠ¤ë¥¼ ë”°ë¥´ê¸° ë•Œë¬¸ì— ë…ì  ì†Œí”„íŠ¸ì›¨ì–´ í”„ë¡œì íŠ¸(ì´ëŸ¬í•œ ìœ í˜•ì˜ ê¸°ëŠ¥ì„ ì£¼ë¡œ ì‚¬ìš©í•˜ëŠ” í”„ë¡œì íŠ¸)ì—ì„œ í™œìš©í•˜ê¸°ì— ì í•©í•˜ì§€ ì•Šë‹¤ëŠ” ê²ƒì…ë‹ˆë‹¤. 
>
> Pafishì™€ InviZzzible í”„ë¡œì íŠ¸ëŠ” ìˆ˜ë…„ ì „ë¶€í„° ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. Al-KhaserëŠ” ì—¬ì „íˆ ê°„í—ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ê³  VMwareì—ì„œ ì§€ì›í•˜ì§€ ì•ŠëŠ” ê´‘ë²”ìœ„í•œ íƒì§€ ê¸°ëŠ¥(ì˜ˆ: ì•ˆí‹° ë””ë²„ê¹… ë° ì•ˆí‹° ì¸ì ì…˜)ì„ ì œê³µí•˜ì§€ë§Œ, ìœ„ì—ì„œ ì–¸ê¸‰í•œ ë‹¤ì–‘í•œ ì œí•œ ì‚¬í•­ìœ¼ë¡œ ì¸í•´ ì‹¤ì œ ì„±ëŠ¥ì€ ì—¬ì „íˆ â€‹â€‹ë§Œì¡±ìŠ¤ëŸ½ì§€ ì•ŠìŠµë‹ˆë‹¤.
> 
> ì´ëŸ¬í•œ í”„ë¡œì íŠ¸ë“¤ì´ VMware ê°œë°œì— ëŒ€í•œ ì˜ê°ì„ ì œê³µí–ˆì§€ë§Œ, ì €í¬ì˜ ëª©í‘œëŠ” ì´ëŸ¬í•œ í”„ë¡œì íŠ¸ë“¤ì„ ì™„ì „íˆ ë›°ì–´ë„˜ëŠ” ê²ƒì…ë‹ˆë‹¤. í•µì‹¬ì€ ë‹¨ìˆœíˆ CLI ë„êµ¬ë¥¼ ì œê³µí•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, íƒì§€ ê¸°ìˆ ì„ ì—¬ëŸ¬ í”Œë«í¼ì—ì„œ í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ìœ ì—°í•˜ê²Œ ì ìš©í•˜ì—¬ ëª¨ë“  ê°œë°œìì—ê²Œ ì´ì ì„ ì œê³µí•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ë˜í•œ, ì´ í”„ë ˆì„ì›Œí¬ëŠ” ë”ìš± ê´‘ë²”ìœ„í•œ íƒì§€ ê¸°ìˆ ì„ í†µí•©í•˜ì—¬ ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ì— ëŒ€í•œ ì‹¤ì§ˆì ì¸ ì†”ë£¨ì…˜ì„ ì œê³µí•˜ëŠ” ë° ì¤‘ì ì„ ë‘” ëŒ€í­ í–¥ìƒëœ ê°€ìƒ ë¨¸ì‹  íƒì§€ í”„ë ˆì„ì›Œí¬ë¥¼ ëª©í‘œë¡œ í•˜ì—¬ ì œê³µë˜ê³  ìˆìŠµë‹ˆë‹¤.

</details>


<details>
<summary>ì˜¤í”ˆ ì†ŒìŠ¤ í”„ë¡œì íŠ¸ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë” ì·¨ì•½í•˜ê²Œ ë§Œë“¤ì§€ ì•Šì„ê¹Œìš”?</summary>
<br>

> VMwareì˜ ìœ ì¼í•œ ë‹¨ì ì€ ì™„ì „íˆ ì˜¤í”ˆì†ŒìŠ¤ë¼ëŠ” ì ì…ë‹ˆë‹¤. ì´ë¡œ ì¸í•´ ìš°íšŒ ê³µê²©ìê°€ ì‚¬ìœ  ì†Œí”„íŠ¸ì›¨ì–´ì— ë¹„í•´ ì½”ë“œë¥¼ ë¶„ì„í•˜ê¸°ê°€ ë” ì‰½ìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì €í¬ëŠ” ì´ê²ƒì´ ê°€ì¹˜ ìˆëŠ” ì ˆì¶©ì•ˆì´ë¼ê³  ìƒê°í•©ë‹ˆë‹¤. ìˆ˜ë§ì€ ê°€ìƒ ë¨¸ì‹  íƒì§€ ê¸°ìˆ ì„ ê°œë°©ì ì´ê³  ìƒí˜¸ ë³´ì™„ì ì¸ ë°©ì‹ìœ¼ë¡œ í†µí•©í•˜ëŠ” ê²ƒì´ ì½”ë“œ ë‚œë…í™”ì— ì˜ì¡´í•˜ëŠ” ê²ƒë³´ë‹¤ í›¨ì”¬ ë” ê°€ì¹˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì˜¤í”ˆì†ŒìŠ¤ëŠ” ì»¤ë®¤ë‹ˆí‹° í† ë¡ , í˜‘ì—… ê°œë°œ, ê·¸ë¦¬ê³  ê°€ìƒ ë¨¸ì‹  íƒì§€ í”„ë¡œì íŠ¸ ë° ì•…ì„±ì½”ë“œ ë¶„ì„ ë„êµ¬ì™€ì˜ ì§€ì†ì ì¸ í˜‘ë ¥ì„ í†µí•´ ê·€ì¤‘í•œ í”¼ë“œë°±ì„ ì–»ì„ ìˆ˜ ìˆìŒì„ ì˜ë¯¸í•˜ë©°, ì´ë¥¼ í†µí•´ íƒì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ë”ìš± íš¨ìœ¨ì ì´ê³  ì •í™•í•˜ê²Œ ê°•í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
> 
> í´ë¡œì¦ˆë“œ ì†ŒìŠ¤ ëª¨ë¸ê³¼ ë¹„êµí–ˆì„ ë•Œ, ì´ëŸ¬í•œ ì¥ì ë“¤ì€ ê°€ìƒ ë¨¸ì‹  íƒì§€ ë¶„ì•¼ì˜ ìµœì²¨ë‹¨ í˜ì‹ ì„ ì´ëŒì–´ë‚´ ë”ìš± íš¨ìœ¨ì ìœ¼ë¡œ ê°œë°œí•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ë°”ë¡œ ì´ëŸ¬í•œ ì´ìœ ë¡œ ì´ í”„ë¡œì íŠ¸ëŠ” í˜„ì¬ ì‚¬ìš© ê°€ëŠ¥í•œ ìµœê³ ì˜ ê°€ìƒ ë¨¸ì‹  íƒì§€ í”„ë ˆì„ì›Œí¬ê°€ ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ê°ì§€ í”„ë¡œì íŠ¸(ì˜¤í”ˆ ì†ŒìŠ¤ ë˜ëŠ” í´ë¡œì¦ˆë“œ ì†ŒìŠ¤)ì—ì„œëŠ” í•œ ë²ˆë„ ì‚¬ìš©í•˜ì§€ ì•Šì•˜ë˜ ìµœì²¨ë‹¨ í˜ì‹  ê¸°ìˆ ì„ ë‹¤ìˆ˜ ì‚¬ìš©í•˜ê³  ìˆê¸° ë•Œë¬¸ì—, ì´ëŸ¬í•œ ê¸°ìˆ ì„ ì„±ê³µì ìœ¼ë¡œ ìš°íšŒí•˜ëŠ” ê²ƒì´ ë§¤ìš° ì–´ë ¤ìš´ ê²ƒìœ¼ë¡œ ì…ì¦ë˜ì—ˆìŠµë‹ˆë‹¤.
>
> ë‹¤ì‹œ ë§í•´, ì´ëŠ” ë‚œë…í™” ê¸°ìˆ ì— ì˜ì¡´í•˜ì—¬ ë³´ì•ˆì„ í™•ë³´í•˜ëŠ” ê²ƒì´ì•„ë‹ˆë¼, ì§ˆê³¼ ì–‘, í”¼ë“œë°± ë©”ì»¤ë‹ˆì¦˜, ê·¸ë¦¬ê³  ê°œë°©ì„± ì¸¡ë©´ì—ì„œ í¬ê´„ì ì¸ ê°œì„ ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. ì´ê²ƒì´ ë°”ë¡œ OpenSSH, OpenSSL, Linux ì»¤ë„ê³¼ ê°™ì€ ë³´ì•ˆ ê´€ë ¨ ì˜¤í”ˆì†ŒìŠ¤ í”„ë¡œì íŠ¸ê°€ ìƒëŒ€ì ìœ¼ë¡œ ë³´ì•ˆì„ ìœ ì§€í•  ìˆ˜ ìˆëŠ” ê·¼ë³¸ì ì¸ ì´ìœ ì…ë‹ˆë‹¤. ê°œì„ ì— ê¸°ì—¬í•œ ì°¸ì—¬ìì˜ ìˆ˜ê°€ ì†ŒìŠ¤ ì½”ë“œë¥¼ ì•…ì˜ì ìœ¼ë¡œ íƒìƒ‰í•˜ë ¤ëŠ” ì°¸ì—¬ìì˜ ìˆ˜ë³´ë‹¤ í›¨ì”¬ ë§ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. VMwareëŠ” ì´ëŸ¬í•œ ì² í•™ì„ ê³ ìˆ˜í•˜ë©°, ë³´ì•ˆ ë¶„ì•¼ì— ì •í†µí•˜ë‹¤ë©´ "ë‚œë…í™”ë¥¼ í†µí•´ í™•ë³´í•œ ë³´ì•ˆì€ ì§„ì •í•œ ë³´ì•ˆì´ ì•„ë‹ˆë‹¤"ë¼ëŠ” ê²©ì–¸ì„ ì˜ ì•Œê³  ìˆì„ ê²ƒì…ë‹ˆë‹¤.
</details>


<details>
<summary>VM ë³´ì•ˆ ê°•í™”ëŠ” ì´ ë¼ì´ë¸ŒëŸ¬ë¦¬ì— ì–¼ë§Œí¼ íš¨ê³¼ì ì¼ê¹Œìš”?</summary>
<br>

> ì•Œë ¤ì§„ ëŒ€ë¶€ë¶„ì˜ ê³µê°œ ê°•í™” ë„êµ¬ëŠ” ë” ì´ìƒ íš¨ê³¼ì ì´ì§€ ì•Šìœ¼ë©°, ëŒ€ë¶€ë¶„ì˜ ê°•í™” ë„êµ¬ê°€ ë¬´ë ¥í™”ëœ ìœˆë„ìš° í”Œë«í¼ì—ì„œëŠ” ë”ìš± ê·¸ë ‡ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ê²ƒì´ ì´ íƒì§€ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì™„ë²½í•˜ê²Œ íš¨ê³¼ì  ì´ë¼ëŠ”ê²ƒì„ ì˜ë¯¸í•˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤. ì•„ì§ ê³µê°œë˜ì§€ ì•Šì€ ë§ì¶¤í˜• ê°•í™” ë„êµ¬ëŠ” ì´ë¡ ì ì¸ ì´ì ì´ ìˆì„ ìˆ˜ ìˆì§€ë§Œ, ê°œë°œ ë‚œì´ë„ëŠ” ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¦ê°€í•©ë‹ˆë‹¤.

</details>


<details>
<summary>ì–´ë–»ê²Œ ê°œë°œë˜ë‚˜ìš”?</summary>
<br>

> í•™ìˆ  ë…¼ë¬¸ì—ì„œ ê°œì¸ ê²Œì„ í•´í‚¹ í¬ëŸ¼, Discord ì»¤ë®¤ë‹ˆí‹°ì— ì´ë¥´ê¸°ê¹Œì§€ ì˜¨ë¼ì¸ ì¡°ì‚¬ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°€ìƒ ë¨¸ì‹ ì„ ìˆ¨ê¸°ëŠ” ìµœì‹  ê¸°ë²•ì„ ì‹ë³„í•˜ê³ , ì´ë¥¼ íƒì§€í•  ìˆ˜ ìˆëŠ” ì¼ë°˜ì  ë°©ë²•ì„ ì—°êµ¬í•˜ë©° ê·¸ í™œë™ì„ ì§€ì†ì ìœ¼ë¡œ ì¶”ì í•´ ê¸°ìˆ  ìš°ìœ„ë¥¼ ìœ ì§€í•©ë‹ˆë‹¤.
> 
> í”„ë¡œë•ì…˜ í’ˆì§ˆì˜ ì½”ë“œê°€ ì¤€ë¹„ë˜ë©´ ì´ë¥¼ main ë¶„ê¸°ì— ì§ì ‘ ì—…ë¡œë“œí•˜ê³  ì‹¤ì œ í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ìš°ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í¬í•¨í•œ ì œí’ˆë“¤ì€ ìˆ˜ë°±ì—ì„œ ìˆ˜ì²œ ëŒ€ì˜ ì¥ì¹˜ì—ì„œ íƒì§€ ì•Œê³ ë¦¬ì¦˜ì„ ì‹¤í–‰í•˜ë©°, ê°€ìƒ ë¨¸ì‹ ì´ ê°ì§€ë˜ë©´ ì¡°ìš©íˆ ë³´ê³ í•˜ê³  í•´ë‹¹ ë³´ê³ ì„œëŠ” ì´í›„ ìˆ˜ë™ìœ¼ë¡œ ì˜¤íƒ ì—¬ë¶€ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.
> 
> ì‹¤í—˜ í…ŒìŠ¤íŠ¸ ë° ê³µê°œ ë¬¸ì„œ/ë°ì´í„°ë² ì´ìŠ¤ì˜ ì¦ê±°ë¡œ ì˜¤íƒì´ ìˆ˜ì •ëœ ê²ƒì´ í™•ì¸ë˜ë©´ ë³€ê²½ì‚¬í•­ì€ mainì— ë‚¨ê²¨ì§€ë©°, ìƒˆ íƒì§€ í•­ëª©ì—ëŠ” ìœ íš¨ì„±, ì‹ ë¢°ì„±, ë‹¤ë¥¸ ê¸°ë²•ê³¼ì˜ ìƒí˜¸ì‘ìš©ì„ ê³ ë ¤í•œ ì ìˆ˜ê°€ ë¶€ì—¬ë©ë‹ˆë‹¤.
> 
> ì˜¤íƒ, ì»´íŒŒì¼ ì˜¤ë¥˜, ì ì¬ì  ì·¨ì•½ì  ë“± ë‹¤ë¥¸ ìƒí™©ë„ ì¦‰ì‹œ mainì— í†µí•©ë©ë‹ˆë‹¤.
> 
> ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì´ì „ ë²„ì „ ëŒ€ë¹„ ì¶©ë¶„í•œ ê°œì„ ì„ ëˆ„ì í•˜ë©´ ë¦´ë¦¬ìŠ¤ë¥¼ ê²Œì‹œí•˜ê³  ë³€ê²½ ì‚¬í•­ì„ ìƒì„¸íˆ ì„¤ëª…í•©ë‹ˆë‹¤.

</details>

<details>
<summary>ì´ í”„ë¡œì íŠ¸ê°€ ë©€ì›¨ì–´ë¡œ ì‚¬ìš©ë  ìˆ˜ ìˆì„ê¹Œìš”?</summary>
<br>

> ë‹¹ì—°í•˜ê²Œìš” ì´ í”„ë¡œì íŠ¸ëŠ” ë©€ì›¨ì–´ ê°œë°œìë¥¼ ëª¨ì§‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ë¶€ì •ì ì¸ ëª©ì ìœ¼ë¡œ ì‚¬ìš©í•˜ë ¤ê³  í•˜ë”ë¼ë„, í”„ë¡œê·¸ë¨ ìì²´ê°€ ë‚œë…í™”ë˜ì–´ ìˆì§€ ì•Šê¸° ë•Œë¬¸ì— ë°”ì´ëŸ¬ìŠ¤ ë°±ì‹  ì†Œí”„íŠ¸ì›¨ì–´ê°€ ì´ë¥¼ ìœ„í˜‘ìœ¼ë¡œ í‘œì‹œí•  ê°€ëŠ¥ì„±ì´ ë§¤ìš° ë†’ìŠµë‹ˆë‹¤.
>
> ë³¸ ë¼ì´ë¸ŒëŸ¬ë¦¬ëŠ” ì§/ê°„ì ‘ì ìœ¼ë¡œ ì‹œìŠ¤í…œ í˜¸ì¶œì´ë‚˜ ì¸ë¼ì¸ í›„í¬ íƒì§€ì™€ ê°™ì€ ì•…ì„±ì½”ë“œ ìš°íšŒ ê¸°ë²•ì„ ì‚¬ìš©í•˜ëŠ” ë“± ì—”ë“œí¬ì¸íŠ¸ íƒì§€ ë° ëŒ€ì‘(EDR) ì‹œìŠ¤í…œ íƒì§€ë¥¼ ìš°íšŒí•˜ê¸° ìœ„í•´ ì˜ë„ì ìœ¼ë¡œ ê°œë°œëœ ê²ƒì´ ì•„ë‹™ë‹ˆë‹¤. í˜„ì¬ êµ¬í˜„ëœ ëª¨ë“  ê¸°ë²•ì€ ê°€ìƒ ë¨¸ì‹  íƒì§€ì— ì¤‘ì ì„ ë‘ê³  ìˆìœ¼ë©°, ì•…ì„±ì½”ë“œ ìš°íšŒ ê´€ë ¨ ê¸°ëŠ¥ ê°œë°œì€ í¬í•¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

</details>

<details>
<summary>ì»´íŒŒì¼ì‹œ ë§í¬ ì˜¤ë¥˜ê°€ ë°œìƒí•©ë‹ˆë‹¤.</summary>
<br>

> gccë˜ëŠ” clangì„ ì‚¬ìš©í•˜ì—¬ ì»´íŒŒì¼í•˜ëŠ” ê²½ìš° <code>-lm</code> í˜¹ì€ <code>-lstdc++</code> í”Œë˜ê·¸ë¥¼ ì¶”ê°€í•˜ê±°ë‚˜, g++/clang++ ì»´íŒŒì¼ëŸ¬ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”. ë¦¬ëˆ…ìŠ¤ì˜ ì‹ ê·œ VMí™˜ê²½ì—ì„œ ë§í¬ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°, ì‹œìŠ¤í…œì„ ì—…ë°ì´íŠ¸ í›„ `sudo apt/dnf/yum update -y` ëª…ë ¹ì–´ë¥¼ í†µí•´ í•„ìš”í•œ C++êµ¬ì„± ìš”ì†Œë¥¼ ì„¤ì¹˜í•˜ì„¸ìš”.

</details>

<br>

## ì´ìŠˆ, í† ë¡ , PR ë° ë¬¸ì˜ ğŸ“¬
ì–´ë–¤ í˜•íƒœë¡œë“  ì œì•ˆ, ì•„ì´ë””ì–´ ê³µìœ , ê·¸ë¦¬ê³  ê¸°ì—¬ë¥¼ í™˜ì˜í•©ë‹ˆë‹¤! [ì´ìŠˆ](https://github.com/kernelwernel/VMAware/issues) ë˜ëŠ” [í† ë¡ ](https://github.com/kernelwernel/VMAware/discussions) ì—ì„œ ììœ ë¡­ê²Œ ì†Œí†µí•˜ì‹¤ ìˆ˜ ìˆìœ¼ë©°, ìµœëŒ€í•œ ë¹ ë¥´ê²Œ ë‹µë³€ ë“œë¦¬ê³ ì ë…¸ë ¥í•˜ê³  ìˆìŠµë‹ˆë‹¤. ê°œì¸ì ì¸ ì†Œí†µì€ Discordë¥¼ í†µí•´ `kr.nl` í˜¹ì€ `shenzken` ì—ê²Œ ì§ì ‘ ì—°ë½í•´ ì£¼ì„¸ìš”.


ì´ë©”ì¼ ì—°ë½ì²˜: `jeanruyv@gmail.com`

ê·¸ë¦¬ê³  ì´ í”„ë¡œì íŠ¸ê°€ ë‹¹ì‹ ì—ê²Œ ë„ì›€ì´ ë˜ì—ˆë‹¤ë©´, ìŠ¤íƒ€ë¥¼ ë¶€íƒë“œë¦½ë‹ˆë‹¤. :)

<br>

## í¬ë ˆë”§, ê¸°ì—¬ì ë° ê³ ë§ˆìš´ ë¶„ë“¤ âœ’ï¸
- [kernelwernel](https://github.com/kernelwernel) (Maintainer and developer)
- [Requiem](https://github.com/NotRequiem) (Maintainer and co-developer)
- [Check Point Research](https://research.checkpoint.com/)
- [Unprotect Project](https://unprotect.it/)
- [Al-Khaser](https://github.com/LordNoteworthy/al-khaser)
- [pafish](https://github.com/a0rtega/pafish)
- [Matteo Malvica](https://www.matteomalvica.com)
- N. Rin, EP_X0FF
- [Peter Ferrie, Symantec](https://github.com/peterferrie)
- [Graham Sutherland, LRQA Nettitude](https://www.nettitude.com/uk/)
- [Alex](https://github.com/greenozon)
- [Marek KnÃ¡pek](https://github.com/MarekKnapek)
- [Vladyslav Miachkov](https://github.com/fameowner99)
- [(Offensive Security) Danny Quist](chamuco@gmail.com)
- [(Offensive Security) Val Smith](mvalsmith@metasploit.com)
- Tom Liston + Ed Skoudis
- [Tobias Klein](https://www.trapkit.de/index.html)
- [(S21sec) Alfredo Omella](https://www.s21sec.com/)
- [hfiref0x](https://github.com/hfiref0x)
- [Waleedassar](http://waleedassar.blogspot.com)
- [ä¸€åŠäººç”Ÿ](https://github.com/TimelifeCzy)
- [Thomas Roccia (fr0gger)](https://github.com/fr0gger)
- [systemd project](https://github.com/systemd/systemd)
- mrjaxser
- [iMonket](https://github.com/PrimeMonket)
- Eric Parker's discord community 
- [ShellCode33](https://github.com/ShellCode33)
- [Georgii Gennadev (D00Movenok)](https://github.com/D00Movenok)
- [utoshu](https://github.com/utoshu)
- [Jyd](https://github.com/jyd519)
- [git-eternal](https://github.com/git-eternal)
- [dmfrpro](https://github.com/dmfrpro)
- [Teselka](https://github.com/Teselka)
- [Kyun-J](https://github.com/Kyun-J)
- [luukjp](https://github.com/luukjp)
- [Randark](https://github.com/Randark-JMT)
- [Scrut1ny](https://github.com/Scrut1ny)
- [Lorenzo Rizzotti (Dreaming-Codes)](https://github.com/Dreaming-Codes)

<br>

## ë²•ë¥  ê³ ì§€ ğŸ“œ
ì´ í”„ë¡œì íŠ¸ë¥¼ ì•…ì˜ì ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ë°œìƒí•œ ëª¨ë“  í”¼í•´ì— ëŒ€í•´ ì±…ì„ì´ ì—†ìœ¼ë©° ë°°ìƒ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

License: MIT

```

`SECURITY.md`:

```md
## Security Policy and Reporting Guidelines

Thank you for your interest in contributing to the security of **VMAware**, a C++ library for VM detection. 
We take security vulnerabilities seriously and aim to fix them promptly and responsibly. Please read and follow these guidelines when reporting a security issue.

---

### 1. Supported Versions

We only provide security fixes for the latest **v2** major release versions. 
If you discover a vulnerability in an unsupported version, please upgrade to the latest **v2.x** version and verify whether the issue still exists.

---

### 2. Reporting a Vulnerability

**Do not** open a public issue for security vulnerabilities.

**Contact**: Submit your report via email to the maintainers at:

```
jeanruyv@gmail.com
```

**Information to Include**:

* A clear description of the vulnerability.
* Steps to reproduce (proof-of-concept if available).
* Impact assessment (what threats this poses).
* Affected versions (as per Section 1).
* Suggested remediation or patches if possible.

---

### 3. Triage Policy

We prioritize meaningful and actionable security vulnerabilities. Reports will be dismissed without disclosure or fix if they:

> Have minimal or no real-world impact.

> Require unrealistic or contrived conditions for exploitation.

> Are speculative, incomplete, or lack a working proof-of-concept.

> Relate to outdated or unsupported versions.

> Involve minor issues such as denial-of-service through non-production use, debug-only settings, or expected behavior in constrained environments.

We reserve the right to classify any report as non-actionable and to not disclose or acknowledge such submissions publicly.

### 4. Handling and Response Timeline

**__1.__** Acknowledgment: You will receive a response within 48 hours.

**__2.__** Evaluation: Investigation will begin within 5 business days.

**__3.__** Patch Development: If the issue is valid and severe, a fix will be developed within 30 calendar days.

**__4.__** Disclosure: For actionable vulnerabilities, we will issue a security advisory and optionally credit the reporter.

### 5. Post-Fix Actions

* The patched version will be tagged with a security banner (e.g., v2.4.0-secfix).
* We will coordinate with package repositories and downstream projects.

### 6. Summary Workflow

```text
Reporter -> jeanruyv@gmail.com (PGP optional)
    -> Maintainers ack in 48h
    -> Investigation in 5 days
    -> Patch in 30 days (if warranted)
    -> Public disclosure & credit (if warranted)
```

---

### 7. Thank You

We value community involvement and appreciate your help in improving the security of VMAware.
That said, we aim to focus our efforts on high-impact, real-world vulnerabilities that affect production use.
Your efforts help keep **VMAware** safe and reliable. We appreciate your time and expertise!

```

`assets/gui.drawio`:

```drawio
<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0" version="24.7.17">
  <diagram name="Page-1" id="9TkIxMRUFxoYNPmumrxf">
    <mxGraphModel dx="988" dy="728" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-1" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="220" y="185" width="660" height="400" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-2" value="VMAware" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="257.36" y="195" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-3" value="" style="shape=image;verticalLabelPosition=bottom;labelBackgroundColor=default;verticalAlign=top;aspect=fixed;imageAspect=0;image=data:image/png,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;" vertex="1" parent="1">
          <mxGeometry x="227.36" y="200" width="22.11" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-4" value="" style="endArrow=none;html=1;rounded=0;exitX=0.004;exitY=0.135;exitDx=0;exitDy=0;exitPerimeter=0;entryX=1;entryY=0.135;entryDx=0;entryDy=0;entryPerimeter=0;" edge="1" parent="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="220" y="230" as="sourcePoint" />
            <mxPoint x="877.3599999999998" y="230" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-7" value="__" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="767.36" y="190" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-8" value="" style="swimlane;startSize=0;" vertex="1" parent="1">
          <mxGeometry x="827.36" y="205" width="10" height="10" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-9" value="X" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="827.36" y="195" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-11" value="Technique 1" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="270" y="250" width="110" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-16" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="260" y="255" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-15" value="âœ…" style="text;whiteSpace=wrap;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="261" y="252" width="50" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-17" value="&lt;font color=&quot;#80807e&quot;&gt;?&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#9a9996;fontColor=#333333;strokeColor=#666666;opacity=40;" vertex="1" parent="1">
          <mxGeometry x="370" y="255" width="15" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-19" value="Technique 2" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="270" y="280" width="110" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-20" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="260" y="285" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-21" value="âœ…" style="text;whiteSpace=wrap;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="261" y="282" width="50" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-22" value="&lt;font color=&quot;#80807e&quot;&gt;?&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#9a9996;fontColor=#333333;strokeColor=#666666;opacity=40;" vertex="1" parent="1">
          <mxGeometry x="370" y="285" width="15" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-23" value="Technique 3" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="270" y="310" width="110" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-24" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="260" y="315" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-25" value="âœ…" style="text;whiteSpace=wrap;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="261" y="312" width="50" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-26" value="&lt;font color=&quot;#80807e&quot;&gt;?&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#9a9996;fontColor=#333333;strokeColor=#666666;opacity=40;" vertex="1" parent="1">
          <mxGeometry x="370" y="315" width="15" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-27" value="Technique 4" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="270" y="340" width="110" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-28" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="260" y="345" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-29" value="âœ…" style="text;whiteSpace=wrap;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="261" y="342" width="50" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-30" value="&lt;font color=&quot;#80807e&quot;&gt;?&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#9a9996;fontColor=#333333;strokeColor=#666666;opacity=40;" vertex="1" parent="1">
          <mxGeometry x="370" y="345" width="15" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-36" value="Technique 5" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="270" y="370" width="110" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-37" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="260" y="375" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-38" value="âœ…" style="text;whiteSpace=wrap;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="261" y="372" width="50" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-39" value="&lt;font color=&quot;#80807e&quot;&gt;?&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#9a9996;fontColor=#333333;strokeColor=#666666;opacity=40;" vertex="1" parent="1">
          <mxGeometry x="370" y="375" width="15" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-40" value="..." style="text;strokeColor=none;fillColor=none;html=1;fontSize=24;fontStyle=1;verticalAlign=middle;align=center;" vertex="1" parent="1">
          <mxGeometry x="275" y="412" width="100" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-41" value="" style="endArrow=none;html=1;rounded=0;exitX=0;exitY=0.75;exitDx=0;exitDy=0;entryX=1;entryY=0.75;entryDx=0;entryDy=0;" edge="1" parent="1" source="YSZBXU-kMrKHwB1vCr1m-1" target="YSZBXU-kMrKHwB1vCr1m-1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="470" y="350" as="sourcePoint" />
            <mxPoint x="520" y="300" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-42" value="" style="endArrow=none;html=1;rounded=0;" edge="1" parent="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="640" y="490" as="sourcePoint" />
            <mxPoint x="640" y="230" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-43" value="&lt;font style=&quot;font-size: 21px;&quot;&gt;&lt;b&gt;Settings&lt;/b&gt;&lt;/font&gt;" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="730" y="240" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-45" value="" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="1">
          <mxGeometry x="420" y="255" width="40" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-46" value="" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#f8cecc;strokeColor=#b85450;" vertex="1" parent="1">
          <mxGeometry x="420" y="285" width="40" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-47" value="" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#f8cecc;strokeColor=#b85450;" vertex="1" parent="1">
          <mxGeometry x="420" y="315" width="40" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-48" value="" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="1">
          <mxGeometry x="420" y="345" width="40" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-49" value="" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#f8cecc;strokeColor=#b85450;" vertex="1" parent="1">
          <mxGeometry x="420" y="375" width="40" height="15" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-51" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="660" y="275" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-53" value="All" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="670" y="270" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-54" value="Spoofable" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="690" y="310" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-55" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="660" y="312.5" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-56" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="660" y="350" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-57" value="Recommended" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="700" y="347" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-58" value="" style="rounded=0;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="660" y="390" width="20" height="20" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-59" value="High threshold" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="680" y="385" width="100" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-60" value="" style="shape=image;verticalLabelPosition=bottom;labelBackgroundColor=default;verticalAlign=top;aspect=fixed;imageAspect=0;image=data:image/png,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;" vertex="1" parent="1">
          <mxGeometry x="240" y="489.17999999999995" width="306.36" height="90.82" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-61" value="âœ…" style="text;whiteSpace=wrap;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="661" y="272" width="50" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-62" value="âœ…" style="text;whiteSpace=wrap;fontSize=14;" vertex="1" parent="1">
          <mxGeometry x="661" y="310" width="50" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-64" value="START" style="rounded=1;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" vertex="1" parent="1">
          <mxGeometry x="748.36" y="510" width="89" height="40" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-65" value="" style="rounded=1;whiteSpace=wrap;html=1;arcSize=50;fillColor=#dae8fc;strokeColor=#6c8ebf;" vertex="1" parent="1">
          <mxGeometry x="600" y="529.59" width="120" height="10" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-66" value="loading bar" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="685" y="620" width="150" height="30" as="geometry" />
        </mxCell>
        <mxCell id="YSZBXU-kMrKHwB1vCr1m-67" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.75;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;" edge="1" parent="1" source="YSZBXU-kMrKHwB1vCr1m-66" target="YSZBXU-kMrKHwB1vCr1m-65">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="650" y="420" as="sourcePoint" />
            <mxPoint x="700" y="370" as="targetPoint" />
          </mxGeometry>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>

```

`assets/hyper-x/v1/Hyper-X.drawio`:

```drawio
<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0" version="24.7.6">
  <diagram name="Page-1" id="zGf0Ftu6_07F7baFzf_Y">
    <mxGraphModel dx="1206" dy="795" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="x2cThCooTCoZfJnJUzE6-1" value="" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="120" y="150" width="880" height="520" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-2" value="START" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="200" y="200" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-3" value="&lt;div&gt;Run the VM::HYPERVISOR_STR&lt;/div&gt;&lt;div&gt;technique, fetch eax&lt;br&gt;&lt;/div&gt;" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="180" y="290" width="160" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-4" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-2" target="x2cThCooTCoZfJnJUzE6-3" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="440" as="sourcePoint" />
            <mxPoint x="450" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-5" value="is eax 12?" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="205" y="380" width="110" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-6" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-3" target="x2cThCooTCoZfJnJUzE6-5" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="270" y="270" as="sourcePoint" />
            <mxPoint x="270" y="310" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-7" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-5" target="x2cThCooTCoZfJnJUzE6-9" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="440" as="sourcePoint" />
            <mxPoint x="450" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-8" value="Hyper-X mechanism" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=34;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="360" y="170" width="400" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-9" value="is eax 11?" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="205" y="470" width="110" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-10" value="Not Hyper-V, continue as normal" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="220" y="560" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-11" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-9" target="x2cThCooTCoZfJnJUzE6-10" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="440" as="sourcePoint" />
            <mxPoint x="450" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-12" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="250" y="530" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-13" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="250" y="440" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-14" value="Hyper-V VM, continue as normal" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="360" y="460" width="80" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-15" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-9" target="x2cThCooTCoZfJnJUzE6-14" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="440" as="sourcePoint" />
            <mxPoint x="450" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-16" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="300" y="470" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-17" value="At this point, it&#39;s fair to assume it&#39;s Hyper-V, but not sure whether host artifacts or VM" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="360" y="380" width="170" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-18" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-5" target="x2cThCooTCoZfJnJUzE6-17" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="440" as="sourcePoint" />
            <mxPoint x="450" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-19" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="300" y="381" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-20" value="Run all the Hyper-V techniques that may only appear in the VM, and not the host (most of these are firmware and OS-based)" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="360" y="250" width="170" height="90" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-21" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-17" target="x2cThCooTCoZfJnJUzE6-20" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="440" as="sourcePoint" />
            <mxPoint x="450" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-22" value="AcpiData" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="230" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-23" value="SMBIOS&lt;br&gt;(VM::MSSMBIOS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="310" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-24" value="Motherboard string&lt;br&gt;(VM::VPC_BOARD)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="390" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-25" value="Hyper-V event logs&lt;br&gt;(VM::EVENT_LOGS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="470" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-26" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-20" target="x2cThCooTCoZfJnJUzE6-22" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="295" />
              <mxPoint x="560" y="260" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-27" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" target="x2cThCooTCoZfJnJUzE6-23" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="560" y="290" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="340" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-28" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" target="x2cThCooTCoZfJnJUzE6-24" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="560" y="340" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="420" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-29" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" target="x2cThCooTCoZfJnJUzE6-25" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="560" y="410" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-30" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-22" target="x2cThCooTCoZfJnJUzE6-31" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="720" y="260" />
              <mxPoint x="720" y="371" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-31" value="Do any of these have any&lt;br&gt;signs of Hyper-V?" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="750" y="330" width="200" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-32" value="Hyper-V VM, continue as normal" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="800" y="440" width="100" height="100" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-33" value="Hyper-V host artifacts detected, this is NOT a VM" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="800" y="200" width="100" height="100" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-34" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;endFill=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-23" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="720" y="340" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-35" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;endFill=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-24" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="710" y="350" as="sourcePoint" />
            <mxPoint x="720" y="420" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-36" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;endFill=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-25" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="720" y="370" as="targetPoint" />
            <Array as="points">
              <mxPoint x="720" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-38" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-31" target="x2cThCooTCoZfJnJUzE6-32" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-39" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="840" y="410" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-40" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-31" target="x2cThCooTCoZfJnJUzE6-33" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-41" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="840" y="305" width="60" height="30" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>

```

`assets/hyper-x/v2/Hyper-X_version_2.drawio`:

```drawio
<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0" version="24.7.17">
  <diagram name="Page-1" id="zGf0Ftu6_07F7baFzf_Y">
    <mxGraphModel dx="1920" dy="788" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="x2cThCooTCoZfJnJUzE6-1" value="" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-10" y="150" width="1010" height="590" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-2" value="START" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="110" y="180" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-3" value="&lt;div&gt;Run the VM::HYPERVISOR_STR&lt;/div&gt;&lt;div&gt;technique, fetch eax. Does eax have the value of 11 or 12?&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="10" y="345" width="140" height="85" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-8" value="Hyper-X mechanism" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=34;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="360" y="170" width="400" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-10" value="Not Hyper-V, continue as normal" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="400" y="630" width="90" height="90" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-17" value="At this point, it&#39;s fair to assume it&#39;s Hyper-V, but not sure whether host artifacts or VM" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="360" y="390" width="170" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-20" value="Run all the Hyper-V techniques that may only appear in the VM, and not the host (most of these are firmware and OS-based)" style="rounded=0;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="360" y="250" width="170" height="90" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-21" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-17" target="x2cThCooTCoZfJnJUzE6-20" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="440" as="sourcePoint" />
            <mxPoint x="450" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-22" value="AcpiData" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="230" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-23" value="SMBIOS&lt;br&gt;(VM::MSSMBIOS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="310" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-24" value="Motherboard string&lt;br&gt;(VM::VPC_BOARD)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="390" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-25" value="Hyper-V event logs&lt;br&gt;(VM::EVENT_LOGS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="470" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-26" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-20" target="x2cThCooTCoZfJnJUzE6-22" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="295" />
              <mxPoint x="560" y="260" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-27" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" target="x2cThCooTCoZfJnJUzE6-23" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="560" y="290" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="340" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-28" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" target="x2cThCooTCoZfJnJUzE6-24" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="560" y="340" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="420" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-29" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" target="x2cThCooTCoZfJnJUzE6-25" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="560" y="410" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="560" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-30" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-22" target="x2cThCooTCoZfJnJUzE6-31" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
            <Array as="points">
              <mxPoint x="720" y="260" />
              <mxPoint x="720" y="375" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-31" value="Do any of these have any&lt;br&gt;signs of Hyper-V?" style="rhombus;whiteSpace=wrap;html=1;spacingTop=6;" parent="1" vertex="1">
          <mxGeometry x="745" y="330" width="210" height="90" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-32" value="&lt;font style=&quot;font-size: 11px;&quot;&gt;Hyper-V detected, this is in fact a VM&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="800" y="455" width="100" height="100" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-33" value="Hyper-V host artifacts detected, this is NOT a VM" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="800" y="200" width="100" height="100" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-34" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;endFill=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-23" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="720" y="340" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-35" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;endFill=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-24" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="710" y="350" as="sourcePoint" />
            <mxPoint x="720" y="420" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-36" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;endFill=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-25" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="720" y="370" as="targetPoint" />
            <Array as="points">
              <mxPoint x="720" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-38" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-31" target="x2cThCooTCoZfJnJUzE6-32" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-39" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="840" y="420" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-40" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-31" target="x2cThCooTCoZfJnJUzE6-33" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="690" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-41" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="840" y="305" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-1" value="&lt;font style=&quot;font-size: 11px;&quot;&gt;Are at least 2 of these true?&lt;/font&gt;" style="rhombus;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="362.5" y="505" width="165" height="90" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-2" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-1" target="x2cThCooTCoZfJnJUzE6-10">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="500" as="sourcePoint" />
            <mxPoint x="450" y="450" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-3" value="&lt;div&gt;No&lt;/div&gt;" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="440" y="600" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-5" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-1" target="x2cThCooTCoZfJnJUzE6-17">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="400" y="500" as="sourcePoint" />
            <mxPoint x="450" y="450" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-6" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="440" y="465" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-9" value="Does the CPU manufacturer have the &quot;Microsoft Hv&quot; string with the hypervisor cpuid leaf?" style="rounded=1;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="190" y="345" width="140" height="85" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-10" value="Does the CPU match with the VMProtect technique for Hyper-V root partition detection?" style="rounded=1;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="95" y="440" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-14" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=0.75;entryDx=0;entryDy=0;" edge="1" parent="1" source="x2cThCooTCoZfJnJUzE6-3" target="4PM8ViUepl_GfYZcxHRn-18">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="200" y="500" as="sourcePoint" />
            <mxPoint x="250" y="450" as="targetPoint" />
            <Array as="points">
              <mxPoint x="80" y="570" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-15" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-10" target="4PM8ViUepl_GfYZcxHRn-18">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="200" y="500" as="sourcePoint" />
            <mxPoint x="170" y="550" as="targetPoint" />
            <Array as="points">
              <mxPoint x="170" y="550" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-16" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0;entryY=0.25;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-9" target="4PM8ViUepl_GfYZcxHRn-18">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="200" y="500" as="sourcePoint" />
            <mxPoint x="265" y="550" as="targetPoint" />
            <Array as="points">
              <mxPoint x="260" y="530" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-18" value="" style="triangle;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="300" y="510" width="30" height="80" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-19" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-18" target="4PM8ViUepl_GfYZcxHRn-1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="230" y="500" as="sourcePoint" />
            <mxPoint x="280" y="450" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-20" value="" style="triangle;whiteSpace=wrap;html=1;direction=north;" vertex="1" parent="1">
          <mxGeometry x="130" y="265" width="80" height="35" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-22" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="1" source="x2cThCooTCoZfJnJUzE6-2" target="4PM8ViUepl_GfYZcxHRn-20">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="380" y="500" as="sourcePoint" />
            <mxPoint x="170" y="260" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-23" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.75;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-20" target="4PM8ViUepl_GfYZcxHRn-9">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="200" y="500" as="sourcePoint" />
            <mxPoint x="250" y="450" as="targetPoint" />
            <Array as="points">
              <mxPoint x="190" y="320" />
              <mxPoint x="260" y="320" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-24" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-20" target="4PM8ViUepl_GfYZcxHRn-10">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="200" y="500" as="sourcePoint" />
            <mxPoint x="250" y="450" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-25" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.25;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-20" target="x2cThCooTCoZfJnJUzE6-3">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="200" y="500" as="sourcePoint" />
            <mxPoint x="250" y="450" as="targetPoint" />
            <Array as="points">
              <mxPoint x="150" y="320" />
              <mxPoint x="80" y="320" />
            </Array>
          </mxGeometry>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>

```

`assets/hyper-x/v3/Hyper-X_version_3.drawio`:

```drawio
<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0" version="24.7.17">
  <diagram name="Page-1" id="zGf0Ftu6_07F7baFzf_Y">
    <mxGraphModel dx="1167" dy="860" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="x2cThCooTCoZfJnJUzE6-1" value="" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="50" y="80" width="710" height="600" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-2" value="START" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="110" y="180" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-3" value="&lt;div&gt;Run the VM::HYPERVISOR_STR&lt;/div&gt;&lt;div&gt;technique, fetch eax.&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="100" y="277.5" width="140" height="85" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-8" value="Hyper-X mechanism (v3)" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=34;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="205" y="120" width="400" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-10" value="Not Hyper-V, continue as normal" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="125" y="540" width="90" height="90" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-23" value="Does the SMBIOS show any strings related to Hyper-V?&lt;br&gt;(VM::MSSMBIOS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="330" y="460" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-24" value="Does the motherboard match with Hyper-V&lt;br&gt;or VirtualPC?&lt;br&gt;(VM::VPC_BOARD)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="330" y="362.5" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-32" value="&lt;font style=&quot;font-size: 11px;&quot;&gt;Hyper-V detected, this is in fact a VM&lt;/font&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="585" y="535" width="100" height="100" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-33" value="Hyper-V host artifacts detected, this is NOT a VM" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="585" y="260" width="100" height="100" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-38" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" parent="1" source="mEdIK6QNIQfA6IXG1Q04-20" target="x2cThCooTCoZfJnJUzE6-32" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="1245" y="440" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-40" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;" parent="1" source="mEdIK6QNIQfA6IXG1Q04-20" target="x2cThCooTCoZfJnJUzE6-33" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="1245" y="350" as="sourcePoint" />
            <mxPoint x="740" y="390" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-10" value="Does the CPU match with the VMProtect technique for Hyper-V root partition detection?" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="330" y="260" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-22" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-2" target="x2cThCooTCoZfJnJUzE6-3" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="380" y="500" as="sourcePoint" />
            <mxPoint x="170" y="265" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-6" value="Does eax have the &lt;br&gt;value of 11 or 12?" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="85" y="400" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-7" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-3" target="mEdIK6QNIQfA6IXG1Q04-6" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="380" y="500" as="sourcePoint" />
            <mxPoint x="430" y="450" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-16" value="Do the Windows event logs show any indication of Hyper-V?&lt;br&gt;(VM::EVENT_LOGS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="330" y="560" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-20" value="Are at least one &lt;br&gt;of these true?" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="550" y="400" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-29" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="165" y="502" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-30" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="625" y="370.5" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-32" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="625" y="502" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-33" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="240" y="420" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-37" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="mEdIK6QNIQfA6IXG1Q04-6" target="x2cThCooTCoZfJnJUzE6-10" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="410" y="490" as="sourcePoint" />
            <mxPoint x="460" y="440" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-2" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" source="mEdIK6QNIQfA6IXG1Q04-6" target="4PM8ViUepl_GfYZcxHRn-10">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="500" y="410" as="sourcePoint" />
            <mxPoint x="550" y="360" as="targetPoint" />
            <Array as="points">
              <mxPoint x="290" y="450" />
              <mxPoint x="290" y="300" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-3" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-24">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="290" y="403" as="sourcePoint" />
            <mxPoint x="550" y="360" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-5" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" target="mEdIK6QNIQfA6IXG1Q04-16">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="290" y="450" as="sourcePoint" />
            <mxPoint x="550" y="360" as="targetPoint" />
            <Array as="points">
              <mxPoint x="290" y="600" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-6" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-23">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="290" y="500" as="sourcePoint" />
            <mxPoint x="550" y="360" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-7" value="" style="endArrow=classic;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-10" target="mEdIK6QNIQfA6IXG1Q04-20">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="500" y="410" as="sourcePoint" />
            <mxPoint x="550" y="360" as="targetPoint" />
            <Array as="points">
              <mxPoint x="510" y="300" />
              <mxPoint x="510" y="450" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-8" value="" style="endArrow=none;html=1;rounded=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-24">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="510" y="403" as="sourcePoint" />
            <mxPoint x="550" y="360" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-10" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="1" source="mEdIK6QNIQfA6IXG1Q04-16">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="370" y="410" as="sourcePoint" />
            <mxPoint x="510" y="450" as="targetPoint" />
            <Array as="points">
              <mxPoint x="510" y="600" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="3IsLGjAELvZnN1pZ9IzM-12" value="" style="endArrow=none;html=1;rounded=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="1" source="x2cThCooTCoZfJnJUzE6-23">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="700" y="410" as="sourcePoint" />
            <mxPoint x="510" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>

```

`assets/hyper-x/v4/Hyper-X_version_4.drawio`:

```drawio
<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0" version="24.7.17">
  <diagram name="Page-1" id="zGf0Ftu6_07F7baFzf_Y">
    <mxGraphModel dx="1875" dy="788" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="x2cThCooTCoZfJnJUzE6-1" value="" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-30" y="130" width="990" height="540" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-2" value="START" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="790" y="360" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-3" value="&lt;div&gt;Run the VM::HYPERVISOR_STR&lt;/div&gt;&lt;div&gt;technique, fetch eax.&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="780" y="220" width="140" height="85" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-8" value="Hyper-X mechanism (v4)" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=34;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="265" y="160" width="400" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-10" value="Not Hyper-V, continue as normal" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry y="207" width="110" height="110" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-23" value="Does the SMBIOS show any strings related to Hyper-V?&lt;br&gt;(VM::MSSMBIOS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="240" y="390" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-24" value="Does the motherboard match with Hyper-V&lt;br&gt;or VirtualPC?&lt;br&gt;(VM::VPC_BOARD)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="70" y="390" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-32" value="&lt;div&gt;&lt;font style=&quot;font-size: 11px;&quot;&gt;Hyper-V detected,&amp;nbsp;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 11px;&quot;&gt;this is in fact a VM&lt;/font&gt;&lt;/div&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="610" y="520" width="110" height="110" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-33" value="Hyper-V host artifacts detected, this is NOT a VM" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="130" y="520" width="110" height="110" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-10" value="Does the CPU match with the VMProtect technique for Hyper-V root partition detection?" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="180" y="222" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-6" value="Does eax have the &lt;br&gt;&lt;div&gt;value of 11?&lt;/div&gt;" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="212.5" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-16" value="Do the Windows event logs show any indication of Hyper-V?&lt;br&gt;(VM::EVENT_LOGS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="410" y="390" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-20" value="Are at least one &lt;br&gt;of these true?" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="340" y="525" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-1" value="Does eax have the &lt;br&gt;&lt;div&gt;value of 12?&lt;/div&gt;" style="rhombus;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="370" y="212" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-2" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" source="mEdIK6QNIQfA6IXG1Q04-6" target="x2cThCooTCoZfJnJUzE6-32">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="310" y="550" as="sourcePoint" />
            <mxPoint x="360" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-3" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" source="x2cThCooTCoZfJnJUzE6-2" target="x2cThCooTCoZfJnJUzE6-3">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-4" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" source="x2cThCooTCoZfJnJUzE6-3" target="mEdIK6QNIQfA6IXG1Q04-6">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-5" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;" edge="1" parent="1" source="mEdIK6QNIQfA6IXG1Q04-6" target="6Mm_VMVsP4fTWzJjbTtz-1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-6" value="" style="endArrow=classic;html=1;rounded=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="1" source="6Mm_VMVsP4fTWzJjbTtz-1" target="4PM8ViUepl_GfYZcxHRn-10">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-7" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-10" target="x2cThCooTCoZfJnJUzE6-10">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="300" y="310" as="sourcePoint" />
            <mxPoint x="350" y="260" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-8" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-24">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="260" y="360" as="sourcePoint" />
            <mxPoint x="420" y="260" as="targetPoint" />
            <Array as="points">
              <mxPoint x="145" y="360" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-11" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" target="mEdIK6QNIQfA6IXG1Q04-16">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="260" y="360" as="sourcePoint" />
            <mxPoint x="420" y="260" as="targetPoint" />
            <Array as="points">
              <mxPoint x="485" y="360" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-12" value="" style="endArrow=none;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;endFill=0;" edge="1" parent="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="250" y="302" as="sourcePoint" />
            <mxPoint x="315" y="360" as="targetPoint" />
            <Array as="points">
              <mxPoint x="250" y="330" />
              <mxPoint x="315" y="330" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-13" value="" style="endArrow=none;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;endFill=0;" edge="1" parent="1" source="6Mm_VMVsP4fTWzJjbTtz-1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="450" y="320" as="sourcePoint" />
            <mxPoint x="310" y="330" as="targetPoint" />
            <Array as="points">
              <mxPoint x="455" y="330" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-15" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-23">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="315" y="360" as="sourcePoint" />
            <mxPoint x="380" y="420" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-16" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="1" source="x2cThCooTCoZfJnJUzE6-24" target="mEdIK6QNIQfA6IXG1Q04-20">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="330" y="420" as="sourcePoint" />
            <mxPoint x="380" y="370" as="targetPoint" />
            <Array as="points">
              <mxPoint x="145" y="500" />
              <mxPoint x="425" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-17" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-23">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="315" y="500" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-18" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" target="mEdIK6QNIQfA6IXG1Q04-16">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="420" y="500" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
            <Array as="points">
              <mxPoint x="485" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-19" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="1" source="mEdIK6QNIQfA6IXG1Q04-20" target="x2cThCooTCoZfJnJUzE6-32">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="380" y="420" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-20" value="" style="endArrow=classic;html=1;rounded=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;" edge="1" parent="1" source="mEdIK6QNIQfA6IXG1Q04-20" target="x2cThCooTCoZfJnJUzE6-33">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="380" y="420" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-21" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="280" y="545" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-22" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="510" y="545" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-23" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="120" y="230" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-24" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="323" y="231" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-25" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="395" y="302" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-26" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="250" y="302" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-27" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="530" y="231" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-30" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" vertex="1" parent="1">
          <mxGeometry x="605" y="312" width="60" height="30" as="geometry" />
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>

```

`assets/hyper-x/v5/Hyper-X_version_5.drawio`:

```drawio
<mxfile host="app.diagrams.net" agent="Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0" version="24.8.3">
  <diagram name="Page-1" id="zGf0Ftu6_07F7baFzf_Y">
    <mxGraphModel dx="1920" dy="788" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
      <root>
        <mxCell id="0" />
        <mxCell id="1" parent="0" />
        <mxCell id="x2cThCooTCoZfJnJUzE6-1" value="" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="-30" y="130" width="990" height="540" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-2" value="START" style="rounded=0;whiteSpace=wrap;html=1;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="790" y="360" width="120" height="60" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-3" value="&lt;div&gt;Run the VM::HYPERVISOR_STR&lt;/div&gt;&lt;div&gt;technique, fetch eax.&lt;br&gt;&lt;/div&gt;" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="780" y="220" width="140" height="85" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-8" value="Hyper-X mechanism (v5)" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=34;fontStyle=1" parent="1" vertex="1">
          <mxGeometry x="265" y="160" width="400" height="30" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-10" value="Not Hyper-V, continue as normal" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry y="207" width="110" height="110" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-23" value="Does the SMBIOS show any strings related to Hyper-V?&lt;br&gt;(VM::MSSMBIOS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="160" y="390" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-24" value="Does the motherboard match with Hyper-V&lt;br&gt;or VirtualPC?&lt;br&gt;(VM::VPC_BOARD)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry y="390" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-32" value="&lt;div&gt;&lt;font style=&quot;font-size: 11px;&quot;&gt;Hyper-V detected,&amp;nbsp;&lt;/font&gt;&lt;/div&gt;&lt;div&gt;&lt;font style=&quot;font-size: 11px;&quot;&gt;this is in fact a VM&lt;/font&gt;&lt;/div&gt;" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#d5e8d4;strokeColor=#82b366;" parent="1" vertex="1">
          <mxGeometry x="610" y="520" width="110" height="110" as="geometry" />
        </mxCell>
        <mxCell id="x2cThCooTCoZfJnJUzE6-33" value="Hyper-V host artifacts detected, this is NOT a VM" style="ellipse;whiteSpace=wrap;html=1;aspect=fixed;fillColor=#f8cecc;strokeColor=#b85450;" parent="1" vertex="1">
          <mxGeometry x="130" y="520" width="110" height="110" as="geometry" />
        </mxCell>
        <mxCell id="4PM8ViUepl_GfYZcxHRn-10" value="Does the CPU match with the VMProtect technique for Hyper-V root partition detection?" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="180" y="222" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-6" value="Does eax have the &lt;br&gt;&lt;div&gt;value of 11?&lt;/div&gt;" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="580" y="212.5" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-16" value="Do the Windows event logs show any indication of Hyper-V?&lt;br&gt;(VM::EVENT_LOGS)" style="rounded=1;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="320" y="390" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="mEdIK6QNIQfA6IXG1Q04-20" value="Are at least one &lt;br&gt;of these true?" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="340" y="525" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-1" value="Does eax have the &lt;br&gt;&lt;div&gt;value of 12?&lt;/div&gt;" style="rhombus;whiteSpace=wrap;html=1;" parent="1" vertex="1">
          <mxGeometry x="370" y="212" width="170" height="100" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-2" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" parent="1" source="mEdIK6QNIQfA6IXG1Q04-6" target="x2cThCooTCoZfJnJUzE6-32" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="310" y="550" as="sourcePoint" />
            <mxPoint x="360" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-3" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=0;exitDx=0;exitDy=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-2" target="x2cThCooTCoZfJnJUzE6-3" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-4" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-3" target="mEdIK6QNIQfA6IXG1Q04-6" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-5" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;" parent="1" source="mEdIK6QNIQfA6IXG1Q04-6" target="6Mm_VMVsP4fTWzJjbTtz-1" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-6" value="" style="endArrow=classic;html=1;rounded=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;" parent="1" source="6Mm_VMVsP4fTWzJjbTtz-1" target="4PM8ViUepl_GfYZcxHRn-10" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="340" y="550" as="sourcePoint" />
            <mxPoint x="390" y="500" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-7" value="" style="endArrow=classic;html=1;rounded=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;" parent="1" source="4PM8ViUepl_GfYZcxHRn-10" target="x2cThCooTCoZfJnJUzE6-10" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="300" y="310" as="sourcePoint" />
            <mxPoint x="350" y="260" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-13" value="" style="endArrow=none;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;endFill=0;" parent="1" source="6Mm_VMVsP4fTWzJjbTtz-1" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="450" y="320" as="sourcePoint" />
            <mxPoint x="310" y="330" as="targetPoint" />
            <Array as="points">
              <mxPoint x="455" y="330" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-16" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" parent="1" source="x2cThCooTCoZfJnJUzE6-24" target="mEdIK6QNIQfA6IXG1Q04-20" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="330" y="420" as="sourcePoint" />
            <mxPoint x="380" y="370" as="targetPoint" />
            <Array as="points">
              <mxPoint x="75" y="500" />
              <mxPoint x="425" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-17" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" parent="1" target="x2cThCooTCoZfJnJUzE6-23" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="235" y="500" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-18" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" parent="1" target="RZr1pIB1Tco0hS_tl9RE-1" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="420" y="500" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
            <Array as="points">
              <mxPoint x="555" y="500" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-19" value="" style="endArrow=classic;html=1;rounded=0;entryX=0;entryY=0.5;entryDx=0;entryDy=0;exitX=1;exitY=0.5;exitDx=0;exitDy=0;" parent="1" source="mEdIK6QNIQfA6IXG1Q04-20" target="x2cThCooTCoZfJnJUzE6-32" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="380" y="420" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-20" value="" style="endArrow=classic;html=1;rounded=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;exitX=0;exitY=0.5;exitDx=0;exitDy=0;" parent="1" source="mEdIK6QNIQfA6IXG1Q04-20" target="x2cThCooTCoZfJnJUzE6-33" edge="1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="380" y="420" as="sourcePoint" />
            <mxPoint x="430" y="370" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-21" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="280" y="545" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-22" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="510" y="545" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-23" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="120" y="230" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-24" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="323" y="231" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-25" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="395" y="302" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-26" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="200" y="302" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-27" value="No" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="530" y="231" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="6Mm_VMVsP4fTWzJjbTtz-30" value="Yes" style="text;html=1;align=center;verticalAlign=middle;whiteSpace=wrap;rounded=0;" parent="1" vertex="1">
          <mxGeometry x="605" y="312" width="60" height="30" as="geometry" />
        </mxCell>
        <mxCell id="RZr1pIB1Tco0hS_tl9RE-1" value="Does the ACPI data match with Hyper-V?&lt;br&gt;(VM::ACPI_HYPERV)" style="rounded=1;whiteSpace=wrap;html=1;" vertex="1" parent="1">
          <mxGeometry x="480" y="390" width="150" height="80" as="geometry" />
        </mxCell>
        <mxCell id="RZr1pIB1Tco0hS_tl9RE-2" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-24">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="320" y="360" as="sourcePoint" />
            <mxPoint x="320" y="480" as="targetPoint" />
            <Array as="points">
              <mxPoint x="75" y="360" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="RZr1pIB1Tco0hS_tl9RE-3" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" target="x2cThCooTCoZfJnJUzE6-23">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="235" y="360" as="sourcePoint" />
            <mxPoint x="320" y="480" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="RZr1pIB1Tco0hS_tl9RE-4" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" target="RZr1pIB1Tco0hS_tl9RE-1">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="320" y="360" as="sourcePoint" />
            <mxPoint x="320" y="480" as="targetPoint" />
            <Array as="points">
              <mxPoint x="555" y="360" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="RZr1pIB1Tco0hS_tl9RE-5" value="" style="endArrow=classic;html=1;rounded=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;" edge="1" parent="1" target="mEdIK6QNIQfA6IXG1Q04-16">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="395" y="360" as="sourcePoint" />
            <mxPoint x="320" y="480" as="targetPoint" />
          </mxGeometry>
        </mxCell>
        <mxCell id="RZr1pIB1Tco0hS_tl9RE-6" value="" style="endArrow=classic;html=1;rounded=0;exitX=0.5;exitY=1;exitDx=0;exitDy=0;" edge="1" parent="1" source="4PM8ViUepl_GfYZcxHRn-10">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="270" y="530" as="sourcePoint" />
            <mxPoint x="320" y="360" as="targetPoint" />
            <Array as="points">
              <mxPoint x="255" y="330" />
              <mxPoint x="320" y="330" />
            </Array>
          </mxGeometry>
        </mxCell>
        <mxCell id="RZr1pIB1Tco0hS_tl9RE-7" value="" style="endArrow=none;html=1;rounded=0;entryX=0.5;entryY=1;entryDx=0;entryDy=0;" edge="1" parent="1" target="mEdIK6QNIQfA6IXG1Q04-16">
          <mxGeometry width="50" height="50" relative="1" as="geometry">
            <mxPoint x="395" y="500" as="sourcePoint" />
            <mxPoint x="320" y="480" as="targetPoint" />
          </mxGeometry>
        </mxCell>
      </root>
    </mxGraphModel>
  </diagram>
</mxfile>

```

`auxiliary/add_technique.py`:

```py
# 
# â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
# â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  
#  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
#   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
# 
#  C++ VM detection library
# 
# ===============================================================
# 
#  This is an internal script to automatically add a technique to
#  the lib with many aspects of the lib updated based on user input.
#  
#  the updated components are:
#   - documentation
#   - technique table 
#   - CLI checklist
#   - technique enums
#   - flag_to_string()
#   - <os>_technique lambda functionality in CLI
#   - adding the technique itself in vmaware.hpp
# 
# ===============================================================
# 
#  - Made by: @kernelwernel (https://github.com/kernelwernel)
#  - Repository: https://github.com/kernelwernel/VMAware
#  - License: MIT

import questionary
import sys


is_dev_mode = False

if len(sys.argv) != 1:
    if sys.argv[1] == "--dev":
        is_dev_mode = True


class options:
    def __init__(self, enum_name, file_path, function_name, cross_platform, is_linux, is_win, is_mac, score, short_description, description, author, link, is_admin, is_gpl, only_32_bit, is_x86_only, notes):
        self.enum_name = enum_name
        self.file_path = file_path
        self.function_name = function_name
        self.cross_platform = cross_platform
        self.is_linux = is_linux
        self.is_win = is_win
        self.is_mac = is_mac
        self.score = score
        self.short_description = short_description
        self.description = description
        self.author = author
        self.link = link
        self.is_admin = is_admin
        self.is_gpl = is_gpl
        self.only_32_bit = only_32_bit
        self.is_x86_only = is_x86_only
        self.notes = notes


# there's like some really weird shit going on with \t, so i'm doing it manually
tab = "    "


def prompt():
    # 1: enum name
    enum_answer = ""
    if is_dev_mode:
        enum_answer = "TEST"
    else:
        enum_answer = questionary.text("What's the name of the enum? (i.e. VBOX_REG or HYPERVISOR_STR)").ask()
        enum_answer = enum_answer.upper()


    # 2: technique file
    file_path = ""
    if is_dev_mode:
        file_path = "../archive/techniques/test.cpp"
    else:
        while True:
            file_path = questionary.path("What's the path to the technique file?").ask()
            if not file_path.endswith(".cpp") and not file_path.endswith(".cc"):
                print("file input MUST be a .cpp file")
                continue

            with open(file_path, 'r') as file:
                is_static = False
                for line in file:
                    if "#include" in line.lower():
                        print("The cpp file will be directly copied to the lib verbatim, so do not add #include as this will mess up include orders.")
                        continue

                    if "static" in line:
                        is_static = True
                
                if not is_static:
                    print("The function must be set as static")
                    continue

                break


    # 3: function name
    function_name = ""
    if is_dev_mode:
        function_name = "test"
    else:
        function_name = questionary.text("What's the name of the function in your .cpp file? example: new_technique()").ask()
        function_name = function_name.lower()
        if "(" in function_name or ")" in function_name:
            function_name = function_name.replace("(", "").replace(")", "")


    # 4: is it cross-platform?
    cross_platform = False

    if is_dev_mode:
        cross_platform = False
        is_linux = True
        is_win = False
        is_mac = False
    else:
        cross_platform = questionary.confirm("Is it cross-platform?").ask()
        is_linux = False
        is_win = False
        is_mac = False
        if cross_platform == True:
            is_linux = True
            is_win = True
            is_mac = True
        else:
            choices = questionary.checkbox(
                "Which OS does this technique support?",
                choices=[
                    "Linux",
                    "Windows",
                    "MacOS"
                ]
            ).ask()
            if "Linux" in choices:
                is_linux = True
            if "Windows" in choices:
                is_win = True
            if "MacOS" in choices:
                is_mac = True
    

    # 5: certainty score
    if is_dev_mode:
        score = 50
    else:
        certainty = ""
        while True:
            certainty = questionary.text("What's the score of your technique? (0-100)").ask()
            if certainty == "":
                print("A score is mandatory, try again")
                continue
            
            if 0 <= int(certainty) <= 100:
                break
            else:
                print("Score must be between 0 and 100, try again")
                continue

        score = int(certainty)
        


    # 6: description
    description = ""
    if is_dev_mode:
        description = "testing, this is a boilerplate technique"
    else:
        while True:
            text = questionary.text("What's the description of your technique? (30-100 characters)").ask()
            if len(text) < 30:
                print("Too short, try again\n")
                continue
            if len(text) > 100:
                print("Too long, try again\n")
                continue
            description = text
            break

    # 7: short description
    short_description = ""
    if is_dev_mode:
        short_description = "testing, ignore"
    else:
        while True:
            text = questionary.text("What is your technique checking for? This will appear in the CLI, so be as minimal as you can (max 25 characters)").ask()
            if len(text) > 25:
                print("Too long, try again\n")
                continue
            if len(text) > len(description):
                print("The answer cannot be longer than the actual description from the previous question\n")
                continue
            short_description = text
            break


    # 8: author
    author = ""
    if is_dev_mode:
        author = ""
    else:
        author = questionary.text("Who is the author? (optional, can be left empty)").ask()


    # 9: link
    link = ""
    if is_dev_mode:
        link = ""
    else:
        link = questionary.text("If there's a source for the technique's origin, paste the link here (optional, can be left empty)").ask()


    # 10: permissions
    is_admin = False
    if is_dev_mode:
        is_admin = False
    else:
        is_admin = questionary.confirm("Does it require admin permissions?").ask()


    # 11: GPL
    is_gpl = False
    if is_dev_mode:
        is_gpl = True
    else:
        is_gpl = questionary.confirm("Is it GPL?").ask()


    # 12: 32-bit
    only_32_bit = False
    if is_dev_mode:
        only_32_bit = False
    else:
        only_32_bit = questionary.confirm("Is it 32-bit only? (no support for 64-bit systems)").ask()


    # 13: x86
    is_x86 = False
    if is_dev_mode:
        is_x86 = True
    else:
        is_x86 = questionary.confirm("Is it x86 only? (no support for ARM for example)").ask()


    # 14: notes
    notes = ""
    if is_dev_mode:
        notes = ""
    else:
        notes = questionary.text("Are there any extra notes you want to add? (leave this empty if it's unnecessary)").ask()


    return options(
        enum_answer,
        file_path,
        function_name,
        cross_platform,
        is_linux,
        is_win,
        is_mac,
        score,
        short_description,
        description,
        author,
        link,
        is_admin,
        is_gpl,
        only_32_bit,
        is_x86,
        notes
    )


def write_header(options, header_file):
    with open(header_file, 'r') as file:
        lines = file.readlines()

    new_code = []
    update_count = 0

    if options.is_gpl and header_file == "../src/vmaware_MIT.hpp":
        return

    for line in lines:
        # if the line is empty, skip
        if not line:
            new_code.append(line)
            continue


        # modify the enum
        if "// ADD NEW TECHNIQUE ENUM NAME HERE" in line:
            if options.is_gpl:
                new_code.append("/* GPL */ " + options.enum_name + ",\n")
            else:
                new_code.append(tab + tab + options.enum_name + ",\n")
            update_count += 1


        # append the technique function to the function list section
        if "// ADD NEW TECHNIQUE FUNCTION HERE" in line:
            full_technique = []
            new_code.append("\n")

            # manage the category string of the technique
            category_list = []
            if options.cross_platform:
                if options.is_x86_only:
                    category_list.append("x86")
            else:
                if options.is_linux:
                    category_list.append("Linux")
                if options.is_win:
                    category_list.append("Windows")
                if options.is_mac:
                    category_list.append("MacOS")
            category_str = ", ".join(category_list)

            # manage the basic details of the technique
            technique_details = []
            technique_details.append("@brief " + options.description)
            if options.author:
                technique_details.append("@author " + options.author)
            if options.link:
                technique_details.append("@link " + options.link)
            
            technique_details.append("@category " + category_str)

            if options.notes != "":
                technique_details.append("@note " + options.notes)

            if options.is_gpl:
                technique_details.append("@copyright GPL-3.0")

            technique_details.append("@implements VM::" + options.enum_name)
            
            # modify the technique details prefix comments 
            # depending on whether it's GPL or not
            if options.is_gpl:
                for comment in technique_details:
                    full_technique.append("// " + comment + "\n")
            else:
                full_technique.append("/**\n")
                for comment in technique_details:
                    full_technique.append(" * " + comment + "\n")
                full_technique.append(" */\n")

            # read the whole technique code
            with open(options.file_path, 'r') as technique_file:
                technique_code = technique_file.readlines()
                full_technique = full_technique + technique_code

            

            # add the GPL specifier for every line 
            if options.is_gpl:
                for i in range(len(full_technique)):
                    full_technique[i] = "/* GPL */     " + full_technique[i]

            # commit the full technique in the buffer 
            preprocessors = ["#endif", "#elif", "#else", "#if"]
            if options.is_gpl:
                for technique_line in full_technique:
                    if all(sub in technique_line for sub in preprocessors):
                        new_code.append(technique_line.lstrip())
                    else:
                        new_code.append(technique_line)
            else:
                for technique_line in full_technique:
                    if all(sub in technique_line for sub in preprocessors):
                        new_code.append(technique_line.lstrip())
                    else:
                        new_code.append(tab + technique_line)


            # extra lines
            new_code.append("\n\n")
            update_count += 1


        # modify the technique table with the new technique appended
        if "// END OF TECHNIQUE TABLE" in line:
            code_str = (
                "std::make_pair(VM::" + 
                options.enum_name + 
                ", VM::core::technique(" + 
                str(options.score) + 
                ", VM::" + 
                options.function_name +
                ")),\n"
            )

            if options.is_gpl:
                new_code.append("/* GPL */ " + code_str)
            else:
                new_code.append(tab + code_str)

            update_count += 1


        # modify the VM::flag_to_string function with the new technique
        if "// ADD NEW CASE HERE FOR NEW TECHNIQUE" in line:
            new_code.append(
                tab + tab + tab +
                "case " + 
                options.enum_name + 
                ": return \"" + 
                options.enum_name + 
                "\";\n"
            )
            update_count += 1

        # add the line in the buffer array
        new_code.append(line)

    if update_count != 4:
        raise ValueError("Not all sections have been update, try to check if the search key values have been modified")


    # commit the new changes from the buffer array
    with open(header_file, "w") as file:
        for line in new_code:
            file.write(line)




def write_cli(options):
    with open('../src/cli.cpp', 'r') as file:
        lines = file.readlines()

    new_code = []

    for line in lines:
        # if the line is empty, skip
        if not line:
            new_code.append(line)
            continue

        # modify the checklist with the newly appended technique here
        if "// ADD NEW TECHNIQUE CHECKER HERE" in line:
            new_code.append(
                tab +
                "checker(VM::" + 
                options.enum_name + 
                ", \"" + 
                options.short_description +
                "\");\n"
            )

        if "// ADD LINUX FLAG" in line:
            if options.is_linux:
                new_code.append(tab + tab + tab + "case VM::" + options.enum_name + ":\n")

        if "// ADD WINDOWS FLAG" in line:
            if options.is_win:
                new_code.append(tab + tab + tab + "case VM::" + options.enum_name + ":\n")

        if "// ADD MACOS FLAG" in line:
            if options.is_mac:
                new_code.append(tab + tab + tab + "case VM::" + options.enum_name + ":\n")

        # add the line in the buffer array
        new_code.append(line)


    # commit the new changes from the buffer array
    with open("../src/cli.cpp", "w") as file:
        for line in new_code:
            file.write(line)




def write_docs(options):
    with open('../docs/documentation.md', 'r') as file:
        lines = file.readlines()

    new_docs = []
    updated = False

    for line in lines:
        # if the line is empty, skip
        if not line:
            new_code.append(line)
            continue

        if "<!-- ADD TECHNIQUE DETAILS HERE -->" in line:
            query_list = []

            query_list.append("`VM::" + options.enum_name + "`")
            query_list.append(options.description)
            
            if options.cross_platform:
                query_list.append("ğŸ§ğŸªŸğŸ")
            else:
                category_list = []
                if options.is_linux:
                    category_list.append("ğŸ§")
                if options.is_win:
                    category_list.append("ğŸªŸ")
                if options.is_mac:
                    category_list.append("ğŸ")
                category_str = "".join(category_list)
                query_list.append(category_str)
            
            query_list.append(str(options.score) + "%")

            if options.is_admin:
                query_list.append("Admin")
            else:
                query_list.append("")

            if options.is_gpl:
                query_list.append("GPL")
            else:
                query_list.append("")

            if options.only_32_bit:
                query_list.append("32-bit")
            else:
                query_list.append("")

            if options.notes:
                query_list.append(options.notes)
            else:
                query_list.append("")

            query = "| " + " | ".join(query_list) + " |  |" # last part is meant to be the link, todo

            new_docs.append(query + "\n")
            updated = True
        
        # add the line in the buffer array
        new_docs.append(line)

    if updated == False:
        raise ValueError("Docs has not found the keyword breakpoint")

    # commit the new changes from the buffer array
    with open("../docs/documentation.md", "w") as file:
        for line in new_docs:
            file.write(line)




if __name__ == "__main__":
    options_object = prompt()

    write_header(options_object, "../src/vmaware.hpp")
    write_header(options_object, "../src/vmaware_MIT.hpp")
    write_cli(options_object)
    write_docs(options_object)
```

`auxiliary/benchmark.cpp`:

```cpp
/**
 * â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•
 *  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
 *
 *  C++ VM detection library
 *
 * ===============================================================
 *
 *  VMAwareBenchmark Utility: Measures performance of VM detection primitives
 *  with cross-platform nanosecond precision timing and adaptive unit
 *  formatting. Supports Windows, Linux, and macOS.
 *
 * ===============================================================
 *
 *  - Repository: https://github.com/kernelwernel/VMAware
 *  - License: MIT
 */

#include "vmaware.hpp"
#include <iostream>
#include <string>
#include <cmath>

#if defined(_WIN32)
#include <windows.h>
#elif defined(__linux__)
#include <time.h>
#elif defined(__APPLE__)
#include <mach/mach_time.h>
#endif

const std::string bold = "\033[1m";
const std::string ansi_exit = "\x1B[0m";
const std::string red = "\x1B[38;2;239;75;75m";
const std::string green = "\x1B[38;2;94;214;114m";
const std::string orange = "\x1B[38;2;255;180;5m";

class VMAwareBenchmark {
public:
    static inline uint64_t get_timestamp() {
#if defined(_WIN32)
        LARGE_INTEGER counter;
        QueryPerformanceCounter(&counter);
        return counter.QuadPart;
#elif defined(__linux__)
        struct timespec ts;
        clock_gettime(CLOCK_MONOTONIC, &ts);
        return static_cast<uint64_t>(ts.tv_sec) * 1e9 + ts.tv_nsec;
#elif defined(__APPLE__)
        return mach_absolute_time();
#else
        return 0;
#endif
    }

    static inline double get_elapsed(uint64_t start, uint64_t end) {
#if defined(_WIN32)
        static LARGE_INTEGER freq;
        QueryPerformanceFrequency(&freq);
        return (end - start) * 1e9 / freq.QuadPart; // Convert to nanoseconds
#elif defined(__linux__)
        return end - start; // Already in nanoseconds
#elif defined(__APPLE__)
        static mach_timebase_info_data_t timebase;
        if (timebase.denom == 0) mach_timebase_info(&timebase);
        return (end - start) * timebase.numer / timebase.denom;
#else
        return 0;
#endif
    }

    static std::string format_duration(double ns) {
        const double abs_ns = std::abs(ns);
        if (abs_ns >= 1e6) return bold + red + std::to_string(ns / 1e6) + " ms" + ansi_exit;
        if (abs_ns >= 1e3) return orange + std::to_string(ns / 1e3) + " Âµs" + ansi_exit;
        return green + std::to_string(ns) + " ns" + ansi_exit;
    }
};

static void enable_ansi_on_windows() {
#if defined(_WIN32)
    HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hOut == INVALID_HANDLE_VALUE) return;

    DWORD dwMode = 0;
    if (!GetConsoleMode(hOut, &dwMode)) return;

    dwMode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING | DISABLE_NEWLINE_AUTO_RETURN;
    SetConsoleMode(hOut, dwMode);
#endif
}

int main(void) {
    enable_ansi_on_windows();

    // Measurement variables
    uint64_t start, end;
    bool is_detected;
    std::string vm_brand, vm_type;
    uint8_t vm_percent;

    // VMAwareBenchmark VM::detect()
    start = VMAwareBenchmark::get_timestamp();
    is_detected = VM::detect();
    end = VMAwareBenchmark::get_timestamp();
    const double detect_time = VMAwareBenchmark::get_elapsed(start, end);

    // VMAwareBenchmark VM::brand()
    start = VMAwareBenchmark::get_timestamp();
    vm_brand = VM::brand();
    end = VMAwareBenchmark::get_timestamp();
    const double brand_time = VMAwareBenchmark::get_elapsed(start, end);

    // VMAwareBenchmark VM::type()
    start = VMAwareBenchmark::get_timestamp();
    vm_type = VM::type();
    end = VMAwareBenchmark::get_timestamp();
    const double type_time = VMAwareBenchmark::get_elapsed(start, end);

    // VMAwareBenchmark VM::percentage()
    start = VMAwareBenchmark::get_timestamp();
    vm_percent = VM::percentage();
    end = VMAwareBenchmark::get_timestamp();
    const double percent_time = VMAwareBenchmark::get_elapsed(start, end);

    // Program output
    std::cout << (is_detected ? "Virtual machine detected!\n" : "Running on baremetal\n")
        << "VM name: " << vm_brand << "\n"
        << "VM type: " << vm_type << "\n"
        << "VM certainty: " << static_cast<int>(vm_percent) << "%\n\n"
        << "Benchmark Results (Default):\n"
        << "VM::detect():    " << VMAwareBenchmark::format_duration(detect_time) << "\n"
        << "VM::brand():     " << VMAwareBenchmark::format_duration(brand_time) << "\n"
        << "VM::type():      " << VMAwareBenchmark::format_duration(type_time) << "\n"
        << "VM::percentage(): " << VMAwareBenchmark::format_duration(percent_time) << "\n\n"
        << "Benchmark Results (not cached):\n";

    for (const VM::enum_flags technique_enum : VM::technique_vector) {
        start = VMAwareBenchmark::get_timestamp();

        VM::check(technique_enum);

        end = VMAwareBenchmark::get_timestamp();
        const double technique_time = VMAwareBenchmark::get_elapsed(start, end);

        std::cout <<
            "VM::" <<
            VM::flag_to_string(technique_enum) <<
            ": " <<
            VMAwareBenchmark::format_duration(technique_time) <<
            "\n";
    }

    std::cout << "\n";

    return 0;
}

```

`auxiliary/cpuid_fuzzer.c`:

```c
/**
 * â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
 * â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  
 *  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
 * 
 *  C++ VM detection library
 * 
 * ===============================================================
 *
 *  This program serves as an internal tool for fuzzing cpuid values 
 *  and comparing them between baremetal outputs and VM outputs.
 * 
 * ===============================================================
 * 
 *  - Made by: @kernelwernel (https://github.com/kernelwernel)
 *  - Repository: https://github.com/kernelwernel/VMAware
 *  - License: MIT
 */


#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdatomic.h>
#include <string.h>
#include <stdlib.h>

#if (defined(_MSC_VER) || defined(_WIN32) || defined(_WIN64) || defined(__MINGW32__))
    #define MSVC 1
    #define LINUX 0
#elif (defined(__GNUC__) || defined(__linux__))
    #define MSVC 0
    #define LINUX 1
#else
    #error "Unknown OS, aborting"
#endif

#if (LINUX)
    #include <cpuid.h>
    #include <sched.h>
    #include <pthread.h>
    #include <unistd.h>
    #include <sys/sysinfo.h>
#else 
    #include <intrin.h>
#endif

// branching macros
#define unlikely(x) __builtin_expect(!!(x), 0)
#define likely(x)   __builtin_expect(!!(x), 1)

// cpu brand shit for ecx idfk
#define intel_ecx 0x6c65746e
#define amd_ecx 0x69746e65

// cpuid leaf values
#define manufacturer 0x00000000
#define proc_info 0x00000001
#define cache_tlb 0x00000002
#define serial 0x00000003
#define topology 0x00000004
#define topology2 0x0000000B
#define management 0x00000006
#define extended 0x00000007 // ecx = 0
#define extended2 0x00000007 // ecx = 1
#define extended3 0x00000007 // ecx = 2
#define xsave 0x0000000D
#define xsave2 0x0000000D // ecx = >2
#define xsave3 0x0000000D // ecx = 0
#define xsave4 0x0000000D // ecx = 1
#define sgx 0x00000012 // ecx = 0
#define sgx2 0x00000012 // ecx = 1
#define sgx3 0x00000012 // ecx = >2
#define proc_trace 0x00000014 // ecx = 0
#define aes 0x00000019
#define avx10 0x00000024 // ecx = 0
#define vm0 0x40000000
#define vm1 0x40000001
#define vm2 0x40000002
#define vm3 0x40000003
#define extended_proc_info 0x80000001
#define hypervisor 0x40000000
#define max_leaf 0x80000000
#define brand1 0x80000002
#define brand2 0x80000003
#define brand3 0x80000004
#define L1_cache 0x80000005
#define L2_cache 0x80000006
#define capabilities 0x80000007
#define virtual 0x80000008
#define svm 0x8000000A
#define enc_mem_cap 0x8000001F
#define ext_info2 0x80000021
#define amd_easter_egg 0x8fffffff
#define centaur_ext 0xC0000000
#define centaur_feature 0xC0000001

// index macros
#define eax 0
#define ebx 1
#define ecx 2
#define edx 3 

// cli flags
#define leaf_mode 1
#define scan_mode 2

// miscellaneous
#define null_leaf 0xFF
#define breakpoint 10000000


// basic cpuid wrapper
static void cpuid
(
    uint32_t *x,
    const uint64_t leaf,
    const uint64_t subleaf
) {
    #if (MSVC)
        __cpuidex((int32_t*)x, (int32_t)(leaf), (int32_t)(subleaf));
    #elif (LINUX)
        __cpuid_count(leaf, subleaf, x[0], x[1], x[2], x[3]);
    #endif
};

// get highest eax leaf 
static uint32_t get_highest_leaf() {
    uint32_t reg[4];
    cpuid(reg, max_leaf, null_leaf);
    return (reg[eax]);
}

// scan for predetermined leafs
void leaf_mode_fuzzer(const uint64_t p_max_leaf) {
    uint32_t reg[4];
    const uint32_t leafs[40] = { 
        manufacturer, proc_info, cache_tlb, 
        serial, topology, topology2, 
        management, extended, extended2, 
        extended3, xsave, xsave2 , 
        xsave3, xsave4, sgx, 
        sgx2, sgx3 , proc_trace, 
        aes, avx10, extended_proc_info, 
        hypervisor, max_leaf, brand1, 
        brand2, brand3, L1_cache, 
        L2_cache, capabilities, virtual, 
        svm, enc_mem_cap, ext_info2, 
        amd_easter_egg, centaur_ext, centaur_feature,
        vm0, vm1, vm2, vm3
    };

    const size_t leaf_arr_size = (sizeof(leafs) / sizeof(leafs[0]));    

    for (int i = 0; i < leaf_arr_size; i++) {
        if (leafs[i] >= p_max_leaf) {
            continue;
        }

        cpuid(reg, leafs[i], null_leaf);

        if (likely(
            reg[eax] || \
            reg[ebx] || \
            reg[ecx] || \
            reg[edx]
        )) {
            printf("leaf = %d\n", i);
            printf("eax = 0x%0X\n", reg[eax]);
            printf("ebx = 0x%0X\n", reg[ebx]);
            printf("ecx = 0x%0X\n", reg[ecx]);
            printf("edx = 0x%0X\n\n", reg[edx]);
        }
    }
}


// scan for a range of leafs
void scan_mode_fuzzer(const uint64_t p_max_leaf) {
    printf("%s", "Scan mode fuzzer \n");
    uint32_t reg[4];

    for (int i = 0; i < 0x10000; i++) {
        cpuid(reg, 0x40000000 + i, null_leaf);

        if (unlikely(
            reg[eax] || \
            reg[ebx] || \
            reg[ecx] || \
            reg[edx]
        )) {
            printf("leaf = %d\n", i);
            printf("eax = 0x%0X\n", reg[eax]);
            printf("ebx = 0x%0X\n", reg[ebx]);
            printf("ecx = 0x%0X\n", reg[ecx]);
            printf("edx = 0x%0X\n\n", reg[edx]);
        }
    }
}


int main(int argc, char *argv[]) {
    uint8_t flags = 0;

    if (argc == 1) {
        flags |= leaf_mode;
        flags |= scan_mode;
    } else if (argc == 2) {
        if (strcmp(argv[2], "--leaf") == 0) {
            flags |= leaf_mode;
        } else if (strcmp(argv[2], "--scan") == 0) {
            flags |= scan_mode;
        } else {
            printf("%s", "Unknown flag provided, aborting\n");
            return 1;
        }
    } else {
        printf("%s", "Too many flags provided, only use either --leaf or --scan\n");
        return 1;
    }

    const uint64_t high_leaf = get_highest_leaf();
    printf("highest leaf = 0x%0lX\n", high_leaf);

    if (flags & leaf_mode) {
        leaf_mode_fuzzer(high_leaf);
    }
    
    if (flags & scan_mode) {
        scan_mode_fuzzer(high_leaf);
    }

    return 0;
}
```

`auxiliary/requirements.txt`:

```txt
questionary
datetime
```

`auxiliary/test_standards.sh`:

```sh
#
# â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
# â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  
#  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
#   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
# 
#  C++ VM detection library
# 
# ===============================================================
#
#  This script is designed to test different C++ standards to see
#  if there are any edgecases before releasing it
# 
# ===============================================================
# 
#  - Made by: @kernelwernel (https://github.com/kernelwernel)
#  - Repository: https://github.com/kernelwernel/VMAware
#  - License: MIT

clear

current_dir=$(pwd) 
rm -rf build/
mkdir build/ 2>/dev/null
cd build/

standards=("11" "14" "17" "20" "23")

for version in "${standards[@]}"; do
    echo "[LOG] Running cmake with $version standard"
    cmake -DCMAKE_BUILD_TYPE=Debug -DCMAKE_CXX_STANDARD=$version ../..

    echo "[LOG] make"
    make
    make_status=$?

    if [ $make_status -ne 0 ]; then
        exit
    fi

    cp ../../build/vmaware .

    echo "[LOG] ./vmaware"
    ./vmaware 2>&1
    vmaware_status=$?

    if [ $vmaware_status -ne 0 ]; then
        exit
    fi
done

cd $current_dir

rm -rf build
```

`auxiliary/updater.py`:

```py
# 
# â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
# â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  
#  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
#   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
# 
#  C++ VM detection library
# 
# ===============================================================
# 
#  This is an internal script to update various stuff of the project automatically:
# 
#    1.  Update the line numbers for the sections header based on what
#        line they are located, so it's a (tiny) bit easier to understand
#        the structure of the headers for anybody reading it for the first
#        time, it's more of a guide to point which parts are this and that.
# 
#    2. Update the dates in the banner, example: "1.9 (September 2024)"
# 
# ===============================================================
# 
#  - Made by: @kernelwernel (https://github.com/kernelwernel)
#  - Repository: https://github.com/kernelwernel/VMAware
#  - License: MIT

import sys
import re
import os
from datetime import datetime

red = "\033[31m"
bold = "\033[1m"
ansi_exit = "\033[0m"

def find_file(filename_candidates, start_dir=None, max_levels=8, walk_depth=2):
    if start_dir is None:
        start_dir = os.path.dirname(os.path.abspath(__file__))

    cur = start_dir
    for _level in range(max_levels + 1):
        # direct candidate paths at this level
        for cand in filename_candidates:
            candidate_path = os.path.join(cur, cand)
            if os.path.isfile(candidate_path):
                return os.path.normpath(os.path.abspath(candidate_path))

        # shallow walk from this level to catch files in subdirs (limited depth)
        top = cur
        top_depth = top.rstrip(os.sep).count(os.sep)
        for root, dirs, files in os.walk(top):
            depth = root.rstrip(os.sep).count(os.sep) - top_depth
            if depth > walk_depth:
                dirs[:] = []
                continue
            for cand in filename_candidates:
                base = os.path.basename(cand)
                if base in files:
                    return os.path.normpath(os.path.abspath(os.path.join(root, base)))

        parent = os.path.dirname(cur)
        if parent == cur:
            break
        cur = parent

    return None


# just some candidates in case the header is moved but still in source code tree
vmaware_candidates = [
    os.path.join('src', 'vmaware.hpp'),
    os.path.join('include', 'vmaware.hpp'),
    'vmaware.hpp'
]
docs_candidates = [
    os.path.join('docs', 'documentation.md'),
    os.path.join('doc', 'documentation.md'),
    'documentation.md'
]

vmaware_file = find_file(vmaware_candidates)
if not vmaware_file:
    print("Error: could not locate vmaware.hpp (tried src/, include/, and parent dirs).")
    sys.exit(2)

vmaware_docs = find_file(docs_candidates)
if not vmaware_docs:
    print("Warning: could not locate docs/documentation.md; documentation update will be skipped.")
    vmaware_docs = None


def update_sections(filename):
    with open(filename, 'r', encoding='utf-8', errors='ignore') as vmaware_read:
        header_content = vmaware_read.readlines()

    enum = "enum enum_flags"
    cpu  = "struct cpu {"
    memo = "struct memo {"
    util = "struct util {"
    techniques = "private: // START OF PRIVATE VM DETECTION TECHNIQUE DEFINITIONS"
    core = "struct core {"
    public = "public: // START OF PUBLIC FUNCTIONS"
    external = "// ============= EXTERNAL DEFINITIONS ============="

    keywords = [enum, cpu, memo, util, techniques, core, public, external]
    scanner_keywords = [
        "__ENUM__",
        "__CPU__",
        "__MEMO__",
        "__UTIL__",
        "__TECHNIQUES__",
        "__CORE__",
        "__PUBLIC__",
        "__EXTERNAL__"
    ]

    pointer_array = []
    file_pointer = 0
    array_index = 0

    for line in header_content:
        if keywords[array_index] in line:
            if array_index != len(keywords) - 1:
                array_index += 1
            pointer_array.append(file_pointer)
        file_pointer += 1

    pair_array = []
    for i, scanner in enumerate(scanner_keywords):
        if i < len(pointer_array):
            pair_array.append((scanner, pointer_array[i]))

    banner = [
        " * - enums for publicly accessible techniques  => line __ENUM__",
        " * - struct for internal cpu operations        => line __CPU__",
        " * - struct for internal memoization           => line __MEMO__",
        " * - struct for internal utility functions     => line __UTIL__",
        " * - start of VM detection technique list      => line __TECHNIQUES__",
        " * - struct for internal core components       => line __CORE__",
        " * - start of public VM detection functions    => line __PUBLIC__",
        " * - start of externally defined variables     => line __EXTERNAL__"
    ]

    index = 0
    for macro, line_no in pair_array:
        for j, text in enumerate(banner):
            if macro in text:
                banner[j] = text.replace(macro, str(line_no))
                break

    # swap two entries to keep original ordering behaviour
    banner[4], banner[5] = banner[5], banner[4]

    section_line = 0
    section_marker = " * ============================== SECTIONS =================================="
    for line in header_content:
        if section_marker in line:
            break
        section_line += 1
    section_line += 1

    for i, new_line in enumerate(banner):
        # ensure we don't index past end
        if section_line + i < len(header_content):
            header_content[section_line + i] = new_line + '\n'

    with open(filename, 'w', encoding='utf-8', errors='ignore') as file:
        file.writelines(header_content)


def update_date(filename):
    args = sys.argv
    date_arg = ""
    pattern = r'\d+\.\d+\.\d+'

    for arg in args[1:]:
        if re.fullmatch(pattern, arg):
            date_arg = arg
            break

    with open(filename, 'r', encoding='utf-8', errors='ignore') as file:
        header_content = file.readlines()

    banner_line = " *   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• "
    index = 0
    for line in header_content:
        if banner_line in line:
            break
        index += 1

    def find_pattern(base_str):
        match = re.search(pattern, base_str)
        if match:
            return match.group()
        print(f"Version number not found for {red}{bold}{base_str}{ansi_exit}, aborting")
        sys.exit(1)

    header_version = find_pattern(header_content[index])
    arg_version = find_pattern(date_arg) if date_arg else header_version
    new_date = datetime.now().strftime("%B %Y")

    experimental = ""
    if not "--release" in args:
        experimental = "Experimental post-"

    new_content = banner_line + experimental + arg_version + " (" + new_date + ")"
    header_content[index] = new_content + '\n'

    with open(filename, 'w', encoding='utf-8', errors='ignore') as file:
        file.writelines(header_content)


with open(vmaware_file, 'r', encoding='utf-8', errors='ignore') as file:
    file_content = file.readlines()


def fetch_enums():
    file_start = "// START OF TECHNIQUE LIST"
    file_end = "// END OF TECHNIQUE LIST"

    file_start_ptr = 0
    file_end_ptr = 0

    file_index = 0

    for line in file_content:
        if file_start in line:
            file_start_ptr = file_index
        elif file_end in line:
            file_end_ptr = file_index
            break

        file_index += 1

    if file_end_ptr <= file_start_ptr:
        return []

    filtered_file = [line.strip() for line in file_content[file_start_ptr + 1: file_end_ptr]]

    enum_list = []
    for enum_line in filtered_file:
        # we can tolerate empty lines and comments
        if not enum_line or enum_line.startswith('//'):
            continue
        enum_list.append(enum_line.replace("case", "").split(":")[0].strip())

    return enum_list


class options:
    def __init__(self, enum_name="", line=0, platform_emojis="", score=0, description="", is_admin=False, only_32_bit=False, notes="", code_link=""):
        self.enum_name = enum_name
        self.line = line
        self.platform_emojis = platform_emojis
        self.score = score
        self.description = description
        self.is_admin = is_admin
        self.only_32_bit = only_32_bit
        self.notes = notes
        self.code_link = code_link


class array_dict(dict):
    def __getitem__(self, key):
        return self.get(key)
    
    def init_as_list(self, key):
        self[key] = options(enum_name = key)
        return self[key]


technique = array_dict()


def fetch_lib_info(enum_list):
    if not enum_list:
        return

    for enum in enum_list:
        technique.init_as_list(enum)

    # fetch line number
    enum_marker_prefix = "* @implements VM::"
    for i, line in enumerate(file_content):
        if enum_marker_prefix in line:
            for enum in enum_list:
                # avoid repeated scans (by matching suffix)
                if enum in line:
                    # set line if not already set
                    if technique[enum].line == 0:
                        technique[enum].line = i + 1

    # generate the code implementation link 
    link_prefix = "[link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L"
    for enum in enum_list:
        line_no_str = str(technique[enum].line if technique[enum].line else 1)
        technique[enum].code_link = link_prefix + line_no_str + ")"

    # fetch scores (by scanning the technique table once)
    start = "// START OF TECHNIQUE TABLE"
    end = "// END OF TECHNIQUE TABLE"
    start_ptr = end_ptr = -1
    for index, line in enumerate(file_content):
        if start in line:
            start_ptr = index
        elif end in line and start_ptr != -1: # Only set end if start was found
            end_ptr = index
            break


    if start_ptr == -1:
        print(f"start position for technique table not found, aborting")
        sys.exit(1)

    if end_ptr == -1:
        print(f"end position for technique table not found, aborting")
        sys.exit(1)

    raw_technique_list = []

    if end_ptr > start_ptr:
        raw_technique_list = [line.strip() for line in file_content[start_ptr+1:end_ptr]]
    
    technique_list = []

    for line in raw_technique_list:
        if line.startswith("#"):
            continue
        
        if line == "":
            continue
        
        technique_list.append(line)

    for enum in enum_list:
        for enum_line in technique_list:
            if enum in enum_line:
                matches = re.findall(r'\d+', enum_line)

                if len(matches) == 0:
                    print(f"could not find score number in technique table line, aborting")
                    sys.exit(1)
                
                if len(matches) > 2:
                    print(f"found multiple score numbers in technique table line, aborting")
                    sys.exit(1)
                
                technique[enum].score = int(matches[0])
                break

    # fetch more stuff, comment block surrounding the implementation line
    for enum in enum_list:
        start_line = end_line = technique[enum].line - 1  # convert to 0-based index
        if start_line < 0 or start_line >= len(file_content):
            continue

        while start_line >= 0 and not file_content[start_line].strip().startswith('/**'):
            start_line -= 1
        
        while end_line < len(file_content) and not file_content[end_line].strip().endswith('*/'):
            end_line += 1
        
        if (start_line < 0 or end_line >= len(file_content) or
            not file_content[start_line].strip().startswith('/**') or
            not file_content[end_line].strip().endswith('*/')):
            # some entries may not follow exact comment format for some reason
            continue
        
        details = file_content[start_line : end_line + 1]

        # check inside the comment
        for line in details:
            if "@brief" in line:
                technique[enum].description = line.split("@brief", 1)[-1].strip()
            if "@warning" in line:
                technique[enum].is_admin = True
            elif "@category" in line:
                linux = "Linux" in line
                windows = "Windows" in line
                macos = "MacOS" in line

                emojis = []
                if linux:
                    emojis.append("ğŸ§")
                if windows:
                    emojis.append("ğŸªŸ")
                if macos:
                    emojis.append("ğŸ")
                if not emojis:
                    emojis = ["ğŸ§", "ğŸªŸ", "ğŸ"]

                technique[enum].platform_emojis = ''.join(emojis)

                if "x86_32" in line:
                    technique[enum].only_32_bit = True

            if "@note" in line:
                technique[enum].notes = line.split("@note", 1)[-1].strip()


def update_docs(enum_list):
    if not vmaware_docs:
        print("Skipping documentation update because documentation.md was not found.")
        return

    technique_array = []

    for enum in enum_list:
        order = [
            f"`VM::{technique[enum].enum_name}`",
            technique[enum].description,
            technique[enum].platform_emojis,
            f"{technique[enum].score}%",
            "Admin" if technique[enum].is_admin else "",
            "32-bit" if technique[enum].only_32_bit else "",
            technique[enum].notes,
            technique[enum].code_link
        ]
        technique_array.append("| " + " | ".join(str(item).strip() for item in order) + " |")

    with open(vmaware_docs, 'r', encoding='utf-8', errors='ignore') as file:
        docs_content = file.readlines()

    docs_start = "<!-- START OF TECHNIQUE DOCUMENTATION -->"
    docs_end = "<!-- END OF TECHNIQUE DOCUMENTATION -->"

    start_ptr = -1
    end_ptr = -1

    for index, line in enumerate(docs_content):
        line_stripped = line.strip()
        if docs_start in line_stripped:
            start_ptr = index
        elif docs_end in line_stripped and start_ptr != -1:
            end_ptr = index
            break

    if start_ptr == -1 or end_ptr == -1:
        print("Error: Start or end marker not found in documentation.md")
        return

    header_rows = [
        docs_start,
        "",
        "| Flag alias | Description | Supported platforms | Certainty | Admin? | 32-bit only? | Notes | Code implementation |",
        "| ---------- | ----------- | ------------------- | --------- | ------ | ------------ | ----- | ------------------- |"
    ]
    technique_array = header_rows + technique_array

    # replace the region between start_ptr and end_ptr (inclusive start, exclusive end)
    docs_content[start_ptr:end_ptr] = [line + '\n' for line in technique_array]

    with open(vmaware_docs, 'w', encoding='utf-8', errors='ignore', newline='\n') as f:
        f.writelines(docs_content)


# Run updates
update_sections(vmaware_file)
update_date(vmaware_file)
enums = fetch_enums()
fetch_lib_info(enums)
update_docs(enums)
```

`auxiliary/vmaware_download.cmake`:

```cmake
# 
# â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
# â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
# â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  
#  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
#   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
# 
#  C++ VM detection library
# 
# ===============================================================
# 
#  This is the installation module for CMake.
#
#  INCLUDE CODE: 
#    include(/path/to/vmaware_download.cmake)
#   
#  EXAMPLE USAGE:
#    download_vmaware("/path/to/your/destination/directory/")
#   
# 
# ===============================================================
# 
#  - Made by: @kernelwernel (https://github.com/kernelwernel)
#  - Repository: https://github.com/kernelwernel/VMAware

function(download_vmaware directory)
    set(DIRECTORY "${directory}" CACHE STRING "Directory to save VMAware header")

    set(DESTINATION "${DIRECTORY}/vmaware.hpp")

    if (NOT EXISTS ${DESTINATION})
        message(STATUS "Downloading VMAware")
        set(URL "https://github.com/kernelwernel/VMAware/releases/latest/download/vmaware.hpp")
        file(DOWNLOAD ${URL} ${DESTINATION} SHOW_PROGRESS)
    else()
        message(STATUS "VMAware already downloaded, skipping")
    endif()
endfunction()
```

`docs/documentation.md`:

```md
# Documentation

## Contents
- [`VM::detect()`](#vmdetect)
- [`VM::percentage()`](#vmpercentage)
- [`VM::brand()`](#vmbrand)
- [`VM::check()`](#vmcheck)
- [`VM::add_custom()`](#vmadd_custom)
- [`VM::type()`](#vmtype)
- [`VM::conclusion()`](#vmconclusion)
- [`VM::detected_count()`](#vmdetected_count)
- [`VM::is_hardened()`](#vmis_hardened)
- [`(Advanced) VM::flag_to_string()`](#advanced-vmflag_to_string)
- [`(Advanced) VM::detected_enums()`](#advanced-vmdetected_enums)
- [vmaware struct](#vmaware-struct)
- [Notes and overall things to avoid](#notes-and-overall-things-to-avoid)
- [Flag table](#flag-table)
- [Brand table](#brand-table)
- [Setting flags](#setting-flags)
- [Variables](#variables)
- [CLI documentation](#cli-documentation)


<br>

## `VM::detect()`

This is basically the main function you're looking for, which returns a bool. If no parameter is provided, all the recommended checks will be performed. But you can optionally set which techniques are used.

```cpp
#include "vmaware.hpp"

int main() {
    /**
     * The basic way to detect a VM where the default checks will 
     * be performed. This is the recommended usage of the lib.
     */ 
    bool is_vm = VM::detect();


    /**
     * This does the exact same as above, but as an explicit alternative.
     */ 
    bool is_vm2 = VM::detect(VM::DEFAULT);


    /**
     * All checks are performed including techniques that are
     * disabled by default for a viariety of reasons. If you 
     * want all techniques for the sake of completeness, then 
     * you can use this flag but remember that there may be potential 
     * performance bottlenecks and an increase in false positives.
     */ 
    bool is_vm3 = VM::detect(VM::ALL);


    /**
     * This will raise the detection threshold above the default level.
     * Use this if you want to be extremely sure if it's a VM, but this 
     * increases the chance of a false negative. Use VM::percentage() 
     * for a more precise result if you want.
     */ 
    bool is_vm4 = VM::detect(VM::HIGH_THRESHOLD);


    /**
     * Essentially means only the CPU brand, MAC, and hypervisor bit techniques 
     * should be performed. Note that the less technique flags you provide, the more 
     * likely the result will not be accurate. If you just want to check for 
     * a single technique, use VM::check() instead. Also, read the flag table
     * at the end of this doc file for a full list of technique flags.
     */
    bool is_vm5 = VM::detect(VM::CPU_BRAND, VM::MAC, VM::HYPERVISOR_BIT);


    /**
     * If you want to disable any technique for whatever reason, use VM::DISABLE(...).
     * This code snippet essentially means "perform all the default flags, but only 
     * disable the VM::RDTSC technique". 
     */ 
    bool is_vm6 = VM::detect(VM::DISABLE(VM::RDTSC));


    /**
     * Same as above, but you can disable multiple techniques at the same time.
     */ 
    bool is_vm7 = VM::detect(VM::DISABLE(VM::VMID, VM::RDTSC, VM::HYPERVISOR_BIT));


    /**
     * This is just an example to show that you can use a combination of 
     * different flags and non-technique flags with the above examples. 
     */ 
    bool is_vm8 = VM::detect(VM::DEFAULT, VM::HIGH_THRESHOLD, VM::DISABLE(VM::RDTSC, VM::VMID));
}
```

<br>

## `VM::percentage()`
This will return a `std::uint8_t` between 0 and 100. It'll return the certainty of whether it has detected a VM based on all the techniques available as a percentage.

```cpp
#include "vmaware.hpp"
#include <iostream>
#include <cstdint>

int main() {
    // uint8_t and unsigned char works too
    const std::uint8_t percent = VM::percentage();

    if (percent == 100) {
        std::cout << "Definitely a VM!\n";
    } else if (percent == 0) {
        std::cout << "Definitely NOT a VM\n";
    } else {
        std::cout << "Unsure if it's a VM\n";
    }

    // converted to int for console character encoding reasons
    std::cout << "percentage: " << static_cast<int>(percent) << "%\n"; 

    return 0;
}
```

> [!NOTE]
> you can use the same flag system as shown with `VM::detect()` for this function.

<br>

## `VM::brand()`
This will essentially return the VM brand as a `std::string`. All the brands and brand alias variables are listed [here](#brand-table)

If none were detected, it will return `Unknown`. It should be noted that this could be a common scenario even if you're running inside a VM due to technical difficulties with accomplishing this. This is especially true for VMware sub-versions (ESX, GSX, Fusion, etc...). It's not recommended to rely on this function for critical operations as if your whole program depends on it.

```cpp
#include "vmaware.hpp"
#include <string>

int main() {
    const std::string result = VM::brand();

    if (result == "KVM") {
        // do KVM specific stuff
    } else if (result == "VirtualBox") {
        // you get the idea
    } else if (result == brands::VMWARE) {
        // having manual string comparisons like the two
        // previous ones can lead to typos which will 
        // make the whole check completely redundant.
        // So the lib provides hardcoded string variables 
        // as aliases to avoid these kinds of situations. 
        // They are located in the aforementioned brand table
    }

    return 0;
}
```


On rare occasions, there might be cases where there's multiple brands that have been detected, which might cause a conflicting output with an inaccurate result. To prevent this, you can use the `VM::MULTIPLE` flag that returns a **message** rather than a **VM brand string**. For example, if it found 2 conflicting brands, it will return `VMware or VirtualBox`. For 3 conflicts, it's `VMware or VirtualBox or QEMU` and so on.


```cpp
#include "vmaware.hpp"
#include <string>

int main() {
    // format: "vmbrand1 or vmbrand2 [or vmbrandx...]"
    const std::string result = VM::brand(VM::MULTIPLE);

    // example output: "VMware or Bochs"
    std::cout << result << "\n";

    // Keep in mind that there's no limit to how many conflicts there can be.
    // And if there's no conflict, it'll revert back to giving the brand string
    // normally as if the VM::MULTIPLE wasn't there

    return 0;
}
```

> [!NOTE]
> you can use the same flag system as shown with `VM::detect()` for `VM::brand()`

> [!IMPORTANT]
> `VM::MULTIPLE` has no effect for any other function other than `VM::brand()`


<br>

## `VM::check()`
This takes a single technique argument and returns a `bool`. It essentially returns a technique's effective output. Nothing more, nothing less.


```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    if (VM::check(VM::VMID)) {
        std::cout << "VMID technique detected a VM!\n";
    }

    if (VM::check(VM::HYPERVISOR_BIT)) {
        std::cout << "Hypervisor bit is set, most definitely a VM!\n";
    }

    return 0;
}
```

<br>

## `VM::add_custom()`
This function allows you to add your own custom VM detection techniques to the scoring system. The first parameter is the percentage score (0 to 100) of how likely it's a VM if your custom code returns `true`, and the second parameter should either be a lambda, a function pointer, or a `std::function<bool()>`

```cpp
// Example 1 with function pointers

bool new_technique() {
    // add your VM detection code here
    return true; 
}

VM::add_custom(50, new_technique);
```

```cpp
// Example 2 with lambdas

VM::add_custom(50, []() -> bool { 
    // add your VM detection code here
    return true; 
});

auto new_technique = []() -> bool { 
    // add your VM detection code here
    return true;
}

VM::add_custom(50, new_technique);
```

```cpp
// Example 3 with std::function

std::function<bool()> new_technique = []() -> bool {
    // add your VM detection code here
    return true;
};

VM::add_custom(50, new_technique);
```

<br>

## `VM::type()`
This will return the VM type (or architecture) as a `std::string` based on the brand found. The possible return values are listed [here](#brand-table) in the `type` column.

```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    // example output: VirtualBox is a Hypervisor (type 2) VM
    std::cout << VM::brand() << " is a " << VM::type() << " VM\n";
    return 0;
}
```


<br>

## `VM::conclusion()`
This will return the "conclusion" message of what the overall result is as a `std::string`. By default, there are 2 possible outputs:
- `Running on baremetal`
- `Running inside a [brand] VM`

The `[brand]` part might contain a brand or may as well be empty, depending on whether a brand has been found. Additionally, you can extend this by adding the `VM::DYNAMIC` flag which will now allow much more variadic  potential outputs:
- `Running on baremetal`
- `Very unlikely a [brand] VM`
- `Unlikely a [brand] VM`
- `Potentially a [brand] VM`
- `Might be a [brand] VM`
- `Likely a [brand] VM`
- `Very likely a [brand] VM`
- `Running inside a [brand] VM`


<br>

## `VM::detected_count()`
This will fetch the number of techniques that have been detected as a `std::uint8_t`.

```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    const std::uint8_t count = VM::detected_count();

    // output: 7 techniques were detected
    std::cout << count << " techniques were detected" << "\n"; 

    // note that if it's baremetal, it should be 0.
    // if it's a VM, it should have at least 4 to  
    // maybe around 15 max. The most I've seen was 
    // around 18 but that only occurs very rarely.

    return 0;
}
```

<br>

## `VM::is_hardened()`

This will detect whether the environment has any hardening indications as a `bool`. 

Internally, this function works by analysing which combination of techniques are expected to be detected together. If a certain combination rule is mismatched, it indicates some kind of tampering of the system which assumes some sort of VM hardening.

Similiary to `VM::brand()`, do not rely on this function for critical operations. This is meant to be a heuristic assumption rather than a concrete guarantee.


```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    if (VM::is_hardened()) {
        std::cout << "Potential hardening detected" << "\n";
    } else {
        std::cout << "Unsure if hardened" << "\n";
    }

    return 0;
}
```

<br>

## (Advanced) `VM::flag_to_string()`

<details>
<summary>Show</summary>

This will take a technique flag enum as an argument and return the string version of it. For example:

```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    const std::string name = VM::flag_to_string(VM::VMID);

    // output: VM::VMID 
    std::cout << "VM::" << name << "\n"; 

    return 0;
}
```

The reason why this exists is because it can be useful for debugging and infodumping purposes. It should be noted that the "VM::" part is not included in the string output, so that's based on the programmer's choice if it should remain in the string or not. The example given above is obviously useless since the whole code can be manually handwritten, but the function is especially convenient if it's being used with [`VM::technique_vector`](#variables). For example:

```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    // this will loop through all the enums in the technique_vector variable,
    // and then checks each of them and outputs the enum that was detected
    for (const auto technique_enum : VM::technique_vector) {
        if (VM::check(technique_enum)) {
            const std::string name = VM::flag_to_string(technique_enum);
            std::cout << "VM::" << name << " was detected\n";
        }
    }

    return 0;
}
```

</details>

<br>

## (Advanced) `VM::detected_enums()`

<details>
<summary>Show</summary>

This is a function that will return a vector of all the technique flags that were detected as running in a VM. The return type is `std::vector<VM::enum_flags>`, and it's designed to give a more programmatic overview of the result. 

```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    std::vector<VM::enum_flags> flag_list = VM::detected_enums();

    for (const auto flag : flag_list) {
        std::cout << "VM::" << VM::flag_to_string(flag) << " was detected" << "\n"; 
    }

    return 0;
}
```

</details>

<br>

# vmaware struct
If you prefer having an object to store all the relevant information about the program's environment instead of calling static member functions, you can use the `VM::vmaware` struct:

```cpp
struct vmaware {
    std::string brand;
    std::string type;
    std::string conclusion;
    bool is_vm;
    std::uint8_t percentage;
    std::uint8_t detected_count;
    std::uint8_t technique_count;
    std::vector<enum_flags> detected_techniques;
    std::vector<std::string> detected_technique_strings;
    std::vector<enum_flags> disabled_techniques;
}; 
```

example:
```cpp
#include "vmaware.hpp"
#include <iostream>

int main() {
    VM::vmaware vm;

    std::cout << "Is this a VM? = " << vm.is_vm << "\n";
    std::cout << "How many techniques detected a VM? = " << vm.detected_count << "%\n";
    std::cout << "What's the VM's type? = " << vm.type << "%\n";
    std::cout << "What's the overview in a human-readable message?" << vm.conclusion << "\n";
}
```

> [!NOTE]
> the flag system is compatible for the struct constructor.


<br>

# Notes and overall things to avoid
âŒ 1. Do NOT rely on the percentage to determine whether you're in a VM. The lib is not designed for this way, and you're potentially increasing false positives. Use VM::detect() instead for that job.

âŒ 2. Do NOT depend your whole program on whether a specific brand was found. VM::brand() will not guarantee it'll give you the result you're looking for even if the environment is in fact that specific VM brand.

> [!TIP]
> It should also be mentioned that it's recommended for the end-user to create a wrapper around the header file. C++ compilation is notoriously slow compared to C or other systems programming languages, and recompiling the header over and over again is a time waste, especially considering there's around 10k lines of code in it. This is incredibly unreliable and cumbersome for large-scale projects utilising the lib. If you have a build configuration that supports header dependency handling or [incremental compilation](https://en.wikipedia.org/wiki/Incremental_compiler) (which is present in most build systems such as CMake), you can fix the issue by doing something like this:
> ```cpp
> // wrapper.hpp
> #include <string>
> 
> namespace wrapper {
>     bool is_this_a_vm();
>     std::string vm_brand_name();
> }
> ```
> 
> ```cpp
> // wrapper.cpp
> #include "vmaware.hpp"
> #include "wrapper.hpp"
> 
> bool wrapper::is_this_a_vm() {
>     return VM::detect();
> }
> 
> std::string wrapper::vm_brand_name() {
>     return VM::brand();
> }
> ```
> 
> ```cpp
> // something.cpp
> #include "wrapper.hpp"
> 
> void something() {
>     if (wrapper::is_this_a_vm()) {
>         std::cout << wrapper::vm_brand_name() << "\n";
>     }
> }
> ```
> 
> This wrapper structure would prevent any avoidable recompilations as opposed to potentially recompiling the vmaware.hpp file for every build that modifies the source that #includes the lib, especially if there's a deep hierarchy of file dependencies within your project.

<br>

# Flag table
VMAware provides a convenient way to not only check for VMs, but also have the flexibility and freedom for the end-user to choose what techniques are used with complete control over what gets executed or not. This is handled with a flag system.

| Icon | Platform |
| --- | --- |
| ğŸ§ | Linux |
| ğŸªŸ | Windows |
| ğŸ | macOS |

<!-- START OF TECHNIQUE DOCUMENTATION -->

| Flag alias | Description | Supported platforms | Certainty | Admin? | 32-bit only? | Notes | Code implementation |
| ---------- | ----------- | ------------------- | --------- | ------ | ------------ | ----- | ------------------- |
| `VM::VMID` | Check CPUID output of manufacturer ID for known VMs/hypervisors at leaf 0 and 0x40000000-0x40000100 | ğŸ§ğŸªŸğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4291) |
| `VM::CPU_BRAND` | Check if CPU brand model contains any VM-specific string snippets | ğŸ§ğŸªŸğŸ | 95% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4309) |
| `VM::HYPERVISOR_BIT` | Check if hypervisor feature bit in CPUID ECX bit 31 is enabled (always false for physical CPUs) | ğŸ§ğŸªŸğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4388) |
| `VM::HYPERVISOR_STR` | Check for hypervisor brand string length (would be around 2 characters in a host machine) | ğŸ§ğŸªŸğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4414) |
| `VM::TIMER` | Check for timing anomalies in the system | ğŸ§ğŸªŸğŸ | 150% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4600) |
| `VM::THREAD_COUNT` | Check if there are only 1 or 2 threads, which is a common pattern in VMs with default settings, nowadays physical CPUs should have at least 4 threads for modern CPUs | ğŸ§ğŸªŸğŸ | 35% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7177) |
| `VM::MAC` | Check if mac address starts with certain VM designated values | ğŸ§ | 20% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5244) |
| `VM::TEMPERATURE` | Check for device's temperature | ğŸ§ | 80% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L6096) |
| `VM::SYSTEMD` | Check result from systemd-detect-virt tool | ğŸ§ | 35% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5125) |
| `VM::CVENDOR` | Check if the chassis vendor is a VM vendor | ğŸ§ | 65% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5149) |
| `VM::CTYPE` | Check if the chassis type is valid (it's very often invalid in VMs) | ğŸ§ | 20% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5174) |
| `VM::DOCKERENV` | Check if /.dockerenv or /.dockerinit file is present | ğŸ§ | 30% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5192) |
| `VM::DMIDECODE` | Check if dmidecode output matches a VM brand | ğŸ§ | 55% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5207) |
| `VM::DMESG` | Check if dmesg output matches a VM brand | ğŸ§ | 55% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5350) |
| `VM::HWMON` | Check if /sys/class/hwmon/ directory is present. If not, likely a VM | ğŸ§ | 35% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5391) |
| `VM::DLL` | Check for VM-specific DLLs | ğŸªŸ | 50% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7477) |
| `VM::HWMODEL` | Check if the sysctl for the hwmodel does not contain the "Mac" string | ğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7201) |
| `VM::WINE` | Check if the function "wine_get_unix_file_name" is present and if the OS booted from a VHD container | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7508) |
| `VM::POWER_CAPABILITIES` | Check what power states are enabled | ğŸªŸ | 45% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7622) |
| `VM::PROCESSES` | Check for any VM processes that are active | ğŸ§ | 40% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L6107) |
| `VM::LINUX_USER_HOST` | Check for default VM username and hostname for linux | ğŸ§ | 10% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5401) |
| `VM::GAMARUE` | Check for Gamarue ransomware technique which compares VM-specific Window product IDs | ğŸªŸ | 10% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7682) |
| `VM::BOCHS_CPU` | Check for various Bochs-related emulation oversights through CPU checks | ğŸ§ğŸªŸğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4442) |
| `VM::MAC_MEMSIZE` | Check if memory is too low for MacOS system | ğŸ | 15% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7237) |
| `VM::MAC_IOKIT` | Check MacOS' IO kit registry for VM-specific strings | ğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7270) |
| `VM::IOREG_GREP` | Check for VM-strings in ioreg commands for MacOS | ğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7367) |
| `VM::MAC_SIP` | Check for the status of System Integrity Protection and hv_mm_present | ğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7408) |
| `VM::VPC_INVALID` | Check for official VPC method | ğŸªŸ | 75% |  | 32-bit |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7791) |
| `VM::SYSTEM_REGISTERS` |  |  | 50% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L1) |
| `VM::VMWARE_IOMEM` | Check for VMware string in /proc/iomem | ğŸ§ | 65% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5430) |
| `VM::VMWARE_IOPORTS` | Check for VMware string in /proc/ioports | ğŸ§ | 70% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5942) |
| `VM::VMWARE_SCSI` | Check for VMware string in /proc/scsi/scsi | ğŸ§ | 40% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5739) |
| `VM::VMWARE_DMESG` | Check for VMware-specific device name in dmesg output | ğŸ§ | 65% | Admin |  | Disabled by default | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5758) |
| `VM::VMWARE_STR` | Check str assembly instruction method for VMware | ğŸªŸ | 35% |  | 32-bit |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7842) |
| `VM::VMWARE_BACKDOOR` | Check for official VMware io port backdoor technique | ğŸªŸ | 100% |  | 32-bit |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7867) |
| `VM::MUTEX` | Check for mutex strings of VM brands | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7928) |
| `VM::THREAD_MISMATCH` | Check if the system's thread count matches the expected thread count for the detected CPU model | ğŸ§ğŸªŸğŸ | 50% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4522) |
| `VM::CUCKOO_DIR` | Check for cuckoo directory using crt and WIN API directory functions | ğŸªŸ | 30% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8014) |
| `VM::CUCKOO_PIPE` | Check for Cuckoo specific piping mechanism | ğŸªŸ | 30% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8070) |
| `VM::AZURE` | Check for default Azure hostname format (Azure uses Hyper-V as their base VM brand) | ğŸ§ğŸªŸ | 30% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L6344) |
| `VM::DISPLAY` | Check for display configurations commonly found in VMs | ğŸªŸ | 25% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8124) |
| `VM::DEVICE_STRING` | Check if bogus device string would be accepted | ğŸªŸ | 25% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8146) |
| `VM::BLUESTACKS_FOLDERS` | Check for the presence of BlueStacks-specific folders | ğŸ§ | 5% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5446) |
| `VM::CPUID_SIGNATURE` | Check for signatures in leaf 0x40000001 in CPUID | ğŸ§ğŸªŸğŸ | 95% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4550) |
| `VM::KGT_SIGNATURE` | Check for Intel KGT (Trusty branch) hypervisor signature in CPUID | ğŸ§ğŸªŸğŸ | 80% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L4576) |
| `VM::QEMU_VIRTUAL_DMI` | Check for presence of QEMU in the /sys/devices/virtual/dmi/id directory | ğŸ§ | 40% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5527) |
| `VM::QEMU_USB` | Check for presence of QEMU in the /sys/kernel/debug/usb/devices directory | ğŸ§ | 20% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5556) |
| `VM::HYPERVISOR_DIR` | Check for presence of any files in /sys/hypervisor directory | ğŸ§ | 20% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5584) |
| `VM::UML_CPU` | Check for the "UML" string in the CPU brand | ğŸ§ | 80% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5632) |
| `VM::KMSG` | Check for any indications of hypervisors in the kernel message logs | ğŸ§ | 5% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5662) |
| `VM::VBOX_MODULE` | Check for a VBox kernel module | ğŸ§ | 15% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5716) |
| `VM::SYSINFO_PROC` | Check for potential VM info in /proc/sysinfo | ğŸ§ | 15% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5792) |
| `VM::DMI_SCAN` | Check for string matches of VM brands in the linux DMI | ğŸ§ | 50% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5814) |
| `VM::SMBIOS_VM_BIT` | Check for the VM bit in the SMBIOS data | ğŸ§ | 50% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5897) |
| `VM::PODMAN_FILE` | Check for podman file in /run/ | ğŸ§ | 5% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5927) |
| `VM::WSL_PROC` | Check for WSL or microsoft indications in /proc/ subdirectories | ğŸ§ | 30% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5959) |
| `VM::DRIVERS` | Check for VM-specific names for drivers | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8163) |
| `VM::DISK_SERIAL` | Check for serial numbers of virtual disks | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8261) |
| `VM::IVSHMEM` | Check for IVSHMEM device presence | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8500) |
| `VM::GPU_CAPABILITIES` | Check for GPU capabilities related to VMs | ğŸªŸ | 45% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8606) |
| `VM::DEVICE_HANDLES` | Check for vm-specific devices | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8644) |
| `VM::QEMU_FW_CFG` | Detect QEMU fw_cfg interface. This first checks the Device Tree for a fw-cfg node or hypervisor tag, then verifies the presence of the qemu_fw_cfg module and firmware directories in sysfs. | ğŸ§ | 70% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5987) |
| `VM::VIRTUAL_PROCESSORS` | Check if the number of virtual and logical processors are reported correctly by the system | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8746) |
| `VM::HYPERVISOR_QUERY` | Check if a call to NtQuerySystemInformation with the 0x9f leaf fills a _SYSTEM_HYPERVISOR_DETAIL_INFORMATION structure | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8776) |
| `VM::AMD_SEV` | Check for AMD-SEV MSR running on the system | ğŸ§ğŸ | 50% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L5469) |
| `VM::VIRTUAL_REGISTRY` | Check for particular object directory which is present in Sandboxie virtual environment but not in usual host systems | ğŸªŸ | 90% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8844) |
| `VM::FIRMWARE` | Check for VM signatures on all firmware tables | ğŸ§ğŸªŸ | 100% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L6404) |
| `VM::FILE_ACCESS_HISTORY` | Check if the number of accessed files are too low for a human-managed environment | ğŸ§ | 15% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L6017) |
| `VM::AUDIO` | Check if no waveform-audio output devices are present in the system | ğŸªŸ | 25% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8938) |
| `VM::NSJAIL_PID` | Check if process status matches with nsjail patterns with PID anomalies | ğŸ§ | 75% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L6044) |
| `VM::PCI_DEVICES` | Check for PCI vendor and device IDs that are VM-specific | ğŸ§ğŸªŸ | 95% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L6821) |
| `VM::ACPI_SIGNATURE` | Check for VM-specific ACPI device signatures | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L9046) |
| `VM::TRAP` | Check if after raising two traps at the same RIP, a hypervisor interferes with the instruction pointer delivery | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L9191) |
| `VM::UD` | Check if no waveform-audio output devices are present in the system | ğŸªŸ | 25% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L8938) |
| `VM::BLOCKSTEP` | Check if a hypervisor does not properly restore the interruptibility state after a VM-exit in compatibility mode | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L9466) |
| `VM::DBVM` | Check if Dark Byte's VM is present | ğŸªŸ | 150% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L9513) |
| `VM::BOOT_LOGO` | Check boot logo for known VM images | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L9632) |
| `VM::MAC_SYS` | Check for VM-strings in system profiler commands for MacOS | ğŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L7452) |
| `VM::KERNEL_OBJECTS` | Check for any signs of VMs in Windows kernel object entities | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L9734) |
| `VM::NVRAM` | Check for known NVRAM signatures that are present on virtual firmware | ğŸªŸ | 100% | Admin |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L9924) |
| `VM::SMBIOS_INTEGRITY` | Check if SMBIOS is malformed/corrupted in a way that is typical for VMs | ğŸªŸ | 50% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L10461) |
| `VM::EDID` | Check for non-standard EDID configurations | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L10472) |
| `VM::CPU_HEURISTIC` | Check whether the CPU is genuine and its reported instruction capabilities are not masked | ğŸªŸ | 90% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L10728) |
| `VM::CLOCK` | Check the presence of system timers | ğŸªŸ | 45% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L11196) |
| `VM::MSR` | Check whether the hypervisor correctly handles MSR behavior | ğŸªŸ | 100% |  |  |  | [link](https://github.com/kernelwernel/VMAware/tree/main/src/vmaware.hpp#L11345) |
<!-- END OF TECHNIQUE DOCUMENTATION -->

<br>

# Brand table

This is the table of all the brands the lib supports.

| String | Variable alias | VM type | Notes |
| ------ | -------------- | ------- | ----- |
| Unknown | `brands::NULL_BRAND` | Unknown | This is the default brand it returns if none were found |
| VirtualBox | `brands::VBOX` | Hypervisor (type 2) |  |
| VMware | `brands::VMWARE` | Hypervisor (type 2) |  |
| VMware Express | `brands::VMWARE_EXPRESS` | Hypervisor (type 2) |  |
| VMware ESX | `brands::VMWARE_ESX` | Hypervisor (type 1) |  |
| VMware GSX | `brands::VMWARE_GSX` | Hypervisor (type 2) |  |
| VMware Workstation | `brands::VMWARE_WORKSTATION` | Hypervisor (type 2) |  |
| VMware Fusion | `brands::VMWARE_FUSION` | Hypervisor (type 2) |  |
| VMware (with VmwareHardenedLoader) | `brands::VMWARE_HARD` | Hypervisor (type 2) | See the [repository](https://github.com/hzqst/VmwareHardenedLoader) |
| bhyve | `brands::BHYVE` | Hypervisor (type 2) |  |
| KVM | `brands::KVM` | Hypervisor (type 1) |  |
| QEMU | `brands::QEMU` | Emulator/Hypervisor (type 2) |  |
| QEMU+KVM | `brands::QEMU_KVM` | Hypervisor (type 1) |  |
| KVM Hyper-V Enlightenment | `brands::KVM_HYPERV` | Hypervisor (type 1) |  |
| QEMU+KVM Hyper-V Enlightenment | `brands::QEMU_KVM_HYPERV` | Hypervisor (type 1) |  |
| Microsoft Hyper-V | `brands::HYPERV` | Hypervisor (type 1) |  |
| Microsoft Virtual PC/Hyper-V | `brands::HYPERV_VPC` | Hypervisor (either type 1 or 2) |  |
| Parallels | `brands::PARALLELS` | Hypervisor (type 2) |  |
| Xen HVM | `brands::XEN` | Hypervisor (type 1) |  |
| ACRN | `brands::ACRN` | Hypervisor (type 1) |  |
| QNX hypervisor | `brands::QNX` | Hypervisor (type 1) |  |
| Hybrid Analysis | `brands::HYBRID` | Sandbox |  |
| Sandboxie | `brands::SANDBOXIE` | Sandbox |  |
| Docker | `brands::DOCKER` | Container |  |
| Wine | `brands::WINE` | Compatibility layer |  |
| Virtual PC  | `brands::VPC` | Hypervisor (type 2) |  |
| Anubis | `brands::ANUBIS` | Sandbox |  |
| JoeBox | `brands::JOEBOX` | Sandbox |  |
| ThreatExpert | `brands::THREATEXPERT` | Sandbox |  |
| CWSandbox | `brands::CWSANDBOX` | Sandbox |  |
| Comodo | `brands::COMODO` | Sandbox |  |
| Bochs | `brands::BOCHS` | Emulator |  |
| NetBSD NVMM | `brands::NVMM` | Hypervisor (type 2) |  |
| OpenBSD VMM | `brands::BSD_VMM` | Hypervisor (type 2) |  |
| Intel HAXM | `brands::INTEL_HAXM` | Hypervisor (type 1) |  |
| Unisys s-Par | `brands::UNISYS` | Partitioning Hypervisor |  |
| Lockheed Martin LMHS  | `brands::LMHS` | Hypervisor (unknown type) | Yes, you read that right. The lib can detect VMs running on US military fighter jets, apparently. |
| Cuckoo | `brands::CUCKOO` | Sandbox |  |
| BlueStacks | `brands::BLUESTACKS` | Emulator |  |
| Jailhouse | `brands::JAILHOUSE` | Partitioning Hypervisor |  |
| Apple VZ | `brands::APPLE_VZ` | Unknown |  |
| Intel KGT (Trusty) | `brands::INTEL_KGT` | Hypervisor (type 1) |  |
| Microsoft Azure Hyper-V | `brands::AZURE_HYPERV` | Hypervisor (type 1) |  |
| SimpleVisor | `brands::SIMPLEVISOR` | Hypervisor (type 1) |  |
| Hyper-V artifact (not an actual VM) | `brands::HYPERV_ARTIFACT` | Unknown | Windows Hyper-V has a tendency to modify host hardware values with VM values. In other words, this brand signifies that you're running on a host system, but the Hyper-V that's installed (either by default or manually by the user) is misleadingly making the whole system look like it's in a VM when in reality it's not. <br><br> For more information, refer to [this graph](https://github.com/kernelwernel/VMAware/blob/main/assets/hyper-x/v5/Hyper-X_version_5.drawio.png). |
| User-mode Linux | `brands::UML` | Paravirtualised/Hypervisor (type 2) |  |
| IBM PowerVM | `brands::POWERVM` | Hypervisor (type 1) |  |
| OpenStack (KVM) | `brands::OPENSTACK` | Hypervisor (type 1) |  |
| KubeVirt (KVM) | `brands::KUBEVIRT` | Hypervisor (type 1) |  |
| AWS Nitro System EC2 (KVM-based) | `brands::AWS_NITRO` | Hypervisor (type 1) |  |
| Podman | `brands::PODMAN` | Container |  |
| WSL | `brands::WSL` | Hybrid Hyper-V (type 1 and 2) | This is a type 1 at the fundamental level, but WSL has components that are reminiscent of type 2 VM designs to an extent. |
| OpenVZ | `brands::OPENVZ` | Container |  |
| ANY.RUN | N/A | Sandbox | Removed from the lib, available only in the CLI due to ethical reasons. |
| Barevisor | `brands::BAREVISOR` | Hypervisor (type 1) |  |
| HyperPlatform | `brands::HYPERPLATFORM` | Hypervisor (type 1) |  |
| MiniVisor | `brands::MINIVISOR` | Hypervisor (type 1) |  |
| Intel TDX | `brands::INTEL_TDX` | Trusted Domain |  |
| LKVM | `brands::LKVM` | Hypervisor (type 1) |  |
| AMD SEV | `brands::AMD_SEV` | VM encryptor |  |
| AMD SEV-ES | `brands::AMD_SEV_ES` | VM encryptor |  |
| AMD SEV-SNP | `brands::AMD_SEV_SNP` | VM encryptor |  |
| Neko Project II | `brands::NEKO_PROJECT` | Emulator |  | 
| Google Compute Engine (KVM) | `brands::GCE` | Cloud VM service |  |
| NoirVisor | `brands::NOIRVISOR` | Hypervisor (type 1) |  |
| Qihoo 360 Sandbox | `brands::QIHOO` | Sandbox |  |
| nsjail | `brands::NSJAIL` | Process isolator |  |
| DBVM | `brands::DBVM` | Hypervisor (type 1) | See the [Cheat Engine's Website](https://www.cheatengine.org/aboutdbvm.php) |

<br>

# Setting flags
| Flag | Description | Specific to |
|------|-------------|-------------|
| `VM::ALL` | This will enable all the technique flags, including checks that are disabled by default. |  |
| `VM::DEFAULT` | This represents a range of flags which are enabled if no default argument is provided. |
| `VM::MULTIPLE` | This will basically return a `std::string` message of what brands could be involved. For example, it could return "`VMware or VirtualBox`" instead of having a single brand string output. | VM::brand() |   
| `VM::HIGH_THRESHOLD` | This will set the threshold bar to confidently detect a VM by 3x higher. | VM::detect() and VM::percentage() |
| `VM::DYNAMIC` | This will add 8 options to the conclusion message rather than 2, each with their own varying likelihoods. | VM::conclusion() |
| `VM::NULL_ARG` | Does nothing, meant as a placeholder flag mainly for CLI purposes. It's best to ignore this.|  |

<br>

# Variables
| Variable | Type | Description |
|----------|------|-------------|
| `VM::technique_count` | `std::uint16_t` | This will store the number of VM detection techniques |
| `VM::technique_vector` | `std::vector<std::uint8_t>` | This will store all the technique macros as a vector. Useful if you're trying to loop through all the techniques for whatever operation you're performing. |

<br>

# CLI documentation
| Shorthand | Full command | Description |
|-----------|--------------|-------------|
| -h | --help | Prints the help menu |
| -v | --version | Prints the version and miscellaneous details |
| -d | --detect | Prints the VM detection result (1 = VM, 0 = baremetal) |
| -s | --stdout | Returns either 0 or 1 to STDOUT without any text output (0 = VM, 1 = baremetal) |
| -b | --brand | Prints the most likely brand |
| -l | --brand-list | Prints all the possible VM brand strings the CLI supports |
| -c | --conclusion | Prints the conclusion message string |
| -p | --percent | Prints the VM likeliness percentage between 0 and 100 |
| -n | --number | Prints the number of VM detection techniques it can perform |
| -t | --type | Returns the VM type (if a VM was found) |
| -o | --output | Set the output path for files, specifically with the --json command |
|    | --disable-notes | No notes will be provided |
|    | --high-threshold | A higher threshold bar for a VM detection will be applied |
|    | --no-ansi | Removes all the ANSI encodings (color and text style). This is added due to some terminals not supporting ANSI escape codes while cluttering the output |
|    | --dynamic | allow the conclusion message to be dynamic (8 possibilities instead of only 2) |
|    | --verbose | add more information to the output  |
|    | --enums | display the technique enum name used by the lib |
|    | --detected-only | Only display the techniques that were detected |
|    | --json | Output a json-formatted file of the results |

> [!NOTE]
> If you want a general result with the default settings, do not put any arguments. This is the intended way to use the CLI tool.
>

```

`docs/score_system.md`:

```md
# Scoring Criteria for VM Detection Techniques

## 1. Reliability (Maximum Weight: 50%) 
*Assess the techniqueâ€™s consistency in accurately detecting VMs.*
*Ranges from 5 to 40%, with higher scores indicating greater reliability.*
**__1.__ Consistency Across Tests:** Does the technique consistently identify VMs when tested multiple times?
**__2.__ Detection Rate**: What is the probability of accurately detecting a VM versus non-VM?

## 2. Specificity to VMs (Maximum Weight: 50%)
*Measure the likelihood that the technique is specific to VM environments and unlikely to trigger in non-VM contexts.*
*Ranges from 0 to 40%, where a high score indicates high specificity to VM environments.*
**__1.__ Environment Triggering**: How specific is this technique to VMs, or could it potentially trigger in certain non-VM setups?
**__2.__ Context Sensitivity**: Are there specific contexts where this technique might yield inconsistent results, or does it work across various VM platforms and configurations?

## 3. False Positive Likelihood (Penalty Only)
Evaluate the likelihood of the technique yielding false positives in non-VM environments.
This criterion only decreases the final score. If false positives are likely, the final score will be reduced, potentially to a minimum of 5.

**__1.__ Non-VM Triggers:** How often does this technique trigger in a host environment by mistake?
**__2.__ Real-World False Positives:**: Does the technique have a history of false positives in real-world scenarios?

```Each category is assigned a score arbitrarily using the considerations as guidelines. Then, the scores are summed to get a final technique score. If the technique shows a high likelihood of false positives, the final score is reduced, potentially lowering the score to 5 in cases of high false flag likelihood.```


### 3.1 False Positive Likelihood Penalty Criteria
The False Positive Likelihood penalty operates on a four-tier scale. Each level has a specific reduction percentage that will be subtracted from the initial score.
Reduction amounts vary from a small percentage for minor false positive risks to a significant penalty for techniques highly prone to false positives.
The resulting score will never fall below the minimum of 5.

### 3.2 Penalty Levels and Reduction Amounts
**1. Minimal False Positive Risk (0% Reduction)**
Characteristics: The technique is exceptionally reliable, with negligible chances of false positives in non-VM contexts.
Penalty: No reduction applied to the initial score.

**2. Low False Positive Risk (Reduce Final Score by 25%)**
Characteristics: The technique occasionally triggers false positives, usually in rare edge cases or under specific conditions. However, false positives are limited and unlikely in typical non-VM environments.
Penalty: Subtract 25% of the initial score.

**3. Moderate False Positive Risk (Reduce Final Score by 50%)**
Characteristics: The technique has a moderate risk of false positives, potentially triggering in various non-VM contexts or under commonly occurring conditions.
Penalty: Subtract 50% of the initial score.

**4. High False Positive Risk (Reduce Final Score by 80%, Minimum Score of 5)**
Characteristics: The technique frequently triggers false positives in non-VM environments, making it unreliable in many real-world scenarios.
Penalty: Subtract 80% of the initial score. `If the result is lower than 5, the final score is set to 5.`
```

`src/README.md`:

```md
| File | Purpose |
|------|---------|
| `cli.cpp`  | Entire CLI tool code |
| `vmaware.hpp` | Official and original library header, most likely what you're looking for. |

<br>

> [!IMPORTANT]
> The main branch is much more updated with features that haven't been added yet to the latest release. However, they are experimental. 
> If you want something more stable, it's highly recommended to use the ones in the release section instead.
>
> On the other hand, testing the main branch version is advised so that feedback can be given back to make the library better.
```

`src/cli.cpp`:

```cpp
/**
 * â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  
 * â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  
 *  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•
 * 
 *  C++ VM detection library
 * 
 * ===============================================================
 *
 *  This is the main CLI code, which demonstrates the majority 
 *  of the library's capabilities while also providing as a
 *  practical and general VM detection tool for everybody to use
 * 
 * ===============================================================
 * 
 *  - Made by: @kernelwernel (https://github.com/kernelwernel)
 *  - Co-developed by: Requiem (https://github.com/NotRequiem)
 *  - Repository: https://github.com/kernelwernel/VMAware
 *  - License: MIT
 */ 

#include <vector>
#include <chrono>

#if (defined(__GNUC__) || defined(__linux__))
    #define CLI_LINUX 1
#else
    #define CLI_LINUX 0
#endif

#if (defined(__APPLE__) || defined(__APPLE_CPP__) || defined(__MACH__) || defined(__DARWIN))
    #define CLI_APPLE 1
    #include <mach-o/dyld.h>
#else
    #define CLI_APPLE 0
#endif

#if (defined(_MSC_VER) || defined(_WIN32) || defined(_WIN64) || defined(__MINGW32__))
    #define CLI_WINDOWS 1
    #define WIN32_LEAN_AND_MEAN
    #define NOMINMAX
#else
    #define CLI_WINDOWS 0
#endif

#include "vmaware.hpp"

constexpr const char* ver = "2.6.0";
constexpr const char* date = "January 2026";

std::string bold = "\033[1m";
std::string underline = "\033[4m";
std::string ansi_exit = "\x1B[0m";
std::string red = "\x1B[38;2;239;75;75m"; 
std::string orange = "\x1B[38;2;255;180;5m";
std::string green = "\x1B[38;2;94;214;114m";
std::string red_orange = "\x1B[38;2;247;127;40m";
std::string green_orange = "\x1B[38;2;174;197;59m";
std::string grey = "\x1B[38;2;108;108;108m";

using u8  = std::uint8_t;
using u16 = std::uint16_t;
using u32 = std::uint32_t;
using u64 = std::uint64_t;
using i32 = std::int32_t;

enum arg_enum : u8 {
    HELP,
    VERSION,
    ALL,
    DETECT,
    STDOUT,
    BRAND,
    BRAND_LIST,
    PERCENT,
    CONCLUSION,
    NUMBER,
    TYPE,
    OUTPUT,
    NOTES,
    HIGH_THRESHOLD,
    NO_ANSI,
    DYNAMIC,
    VERBOSE,
    ENUMS,
    DETECTED_ONLY,
    JSON,
    NULL_ARG
};

constexpr u8 arg_bits = static_cast<u8>(NULL_ARG) + 1;

std::bitset<arg_bits> arg_bitset;

u8 unsupported_count = 0;
u8 supported_count = 0;
u8 no_perms_count = 0;
u8 disabled_count = 0;

std::string detected = ("[  " + green + "DETECTED" + ansi_exit + "  ]");
std::string not_detected = ("[" + red + "NOT DETECTED" + ansi_exit + "]");
std::string no_support = ("[ " + grey + "NO SUPPORT" + ansi_exit + " ]");
std::string no_perms = ("[" + grey + "  NO PERMS  " + ansi_exit + "]");
std::string note = ("[    NOTE    ]");               
std::string disabled = ("[" + grey + "  DISABLED  " + ansi_exit + "]");

#if (CLI_WINDOWS)
class win_ansi_enabler_t
{
public:
    win_ansi_enabler_t()
        : m_set(FALSE),
        m_old(0),
        m_out(GetStdHandle(STD_OUTPUT_HANDLE))
    {
        if (m_out != nullptr && m_out != INVALID_HANDLE_VALUE)
        {
            if (GetConsoleMode(m_out, &m_old) != FALSE)
            {
                m_set = SetConsoleMode(m_out, m_old | ENABLE_VIRTUAL_TERMINAL_PROCESSING);
            }
        }
    }

    ~win_ansi_enabler_t()
    {
        if (m_set != FALSE)
        {
            SetConsoleMode(m_out, m_old);
        }
    }

private:
    win_ansi_enabler_t(win_ansi_enabler_t const&) = delete;

private:
    bool m_set;
    DWORD m_old;
    HANDLE m_out;
};
#endif

struct SHA256 {
    u8 buf[64] = {};   // message block buffer
    u32 len = 0;       // bytes currently in buf
    u64 bits = 0;      // total bits processed
    u32 s[8] = {};     // from h0 to h7

    // Initialize state to SHA-256 IVs so that compiler doesn't complain
    SHA256() {
        len = 0;
        bits = 0;
        s[0] = 0x6a09e667;
        s[1] = 0xbb67ae85;
        s[2] = 0x3c6ef372;
        s[3] = 0xa54ff53a;
        s[4] = 0x510e527f;
        s[5] = 0x9b05688c;
        s[6] = 0x1f83d9ab;
        s[7] = 0x5be0cd19;
    }

    // bitwise helpers
    static u32 rotr(u32 x, int n) { return (x >> n) | (x << (32 - n)); }
    static u32 ch(u32 x, u32 y, u32 z) { return (x & y) ^ (~x & z); }
    static u32 maj(u32 x, u32 y, u32 z) { return (x & y) ^ (x & z) ^ (y & z); }
    static u32 ep0(u32 x) { return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22); }
    static u32 ep1(u32 x) { return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25); }
    static u32 sig0(u32 x) { return rotr(x, 7) ^ rotr(x, 18) ^ (x >> 3); }
    static u32 sig1(u32 x) { return rotr(x, 17) ^ rotr(x, 19) ^ (x >> 10); }

    // we need to process one 512-bit block from buf
    void transform() {
        static const u32 k[64] = {
          0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
          0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
          0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
          0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
          0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
          0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
          0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
          0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2
        };
        u32 m[64]{};
        for (u32 i = 0, j = 0; i < 16; ++i, j += 4) {
            m[i] = (u32)buf[j] << 24 | (u32)buf[j + 1] << 16 | (u32)buf[j + 2] << 8 | (u32)buf[j + 3];
        }
        for (u32 i = 16; i < 64; ++i) {
            m[i] = sig1(m[i - 2]) + m[i - 7] + sig0(m[i - 15]) + m[i - 16];
        }
        u32 a = s[0];
        u32 b = s[1];
        u32 c = s[2];
        u32 d = s[3];
        u32 e = s[4];
        u32 f = s[5];
        u32 g = s[6];
        u32 h = s[7];
        for (u32 i = 0; i < 64; ++i) {
            u32 t1 = h + ep1(e) + ch(e, f, g) + k[i] + m[i];
            u32 t2 = ep0(a) + maj(a, b, c);
            h = g;
            g = f;
            f = e;
            e = d + t1;
            d = c;
            c = b;
            b = a;
            a = t1 + t2;
        }
        s[0] += a;
        s[1] += b;
        s[2] += c;
        s[3] += d;
        s[4] += e;
        s[5] += f;
        s[6] += g;
        s[7] += h;
    }

    // arbitrary bytes into the digest
    void update(const u8* data, size_t n) {
        for (size_t i = 0; i < n; ++i) {
            buf[len++] = data[i];
            if (len == 64) {
                transform();
                bits += 512;
                len = 0;
            }
        }
    }

    // 32-byte digest IN big-endian
    void final(u8 out[32]) {
        size_t i = len;
        if (len < 56) {
            buf[i++] = 0x80;
            while (i < 56) buf[i++] = 0;
        }
        else {
            buf[i++] = 0x80;
            while (i < 64) buf[i++] = 0;
            transform();
            for (size_t j = 0; j < 56; ++j) buf[j] = 0;
        }
        bits += (u64)len * 8;
        for (int j = 0; j < 8; ++j) {
            buf[63 - j] = (u8)((bits >> (8 * j)) & 0xFF);
        }
        transform();
        for (i = 0; i < 4; ++i) {
            for (size_t j = 0; j < 8; ++j) {
                out[i + j * 4] = (u8)((s[j] >> (24 - i * 8)) & 0xFF);
            }
        }
    }
};

static std::string exe_path() {
#if (CLI_WINDOWS)
    std::vector<char> buf(32768);
    DWORD r = GetModuleFileNameA(NULL, buf.data(), (DWORD)buf.size());
    if (r == 0 || r >= buf.size()) return {};
    return std::string(buf.data(), r);
#elif (CLI_APPLE)
    uint32_t sz = 0;
    _NSGetExecutablePath(nullptr, &sz);
    std::vector<char> b(sz);
    if (_NSGetExecutablePath(b.data(), &sz) != 0) return {};
    std::vector<char> resolved(PATH_MAX);
    if (realpath(b.data(), resolved.data())) {
        return std::string(resolved.data());
    }
    return std::string(b.data());
#else
    std::vector<char> b(PATH_MAX);
    ssize_t l = ::readlink("/proc/self/exe", b.data(), b.size() - 1);
    if (l <= 0) return {};
    b[(size_t)l] = '\0';
    std::vector<char> resolved(PATH_MAX);
    if (realpath(b.data(), resolved.data())) {
        return std::string(resolved.data());
    }
    return std::string(b.data());
#endif
}

static std::string compute_self_sha256() {
    std::string path = exe_path();
    if (path.empty()) return {};

    std::ifstream ifs(path, std::ios::binary);
    if (!ifs) return {};

    SHA256 sha;

    std::vector<char> chunk(64 * 1024);
    while (ifs) {
        ifs.read(chunk.data(), static_cast<std::streamsize>(chunk.size()));
        std::streamsize r = ifs.gcount();
        if (r > 0) {
            sha.update(reinterpret_cast<const u8*>(chunk.data()), static_cast<size_t>(r));
        }
    }

    u8 digest[32];
    sha.final(digest);

    std::string out;
    out.reserve(64);

    static constexpr char hex[] = "0123456789abcdef";

    for (int i = 0; i < 32; ++i) {
        out.push_back(hex[(digest[i] >> 4) & 0xF]);
        out.push_back(hex[digest[i] & 0xF]);
    }
    return out;
}

[[noreturn]] static void help(void) {
    std::cout << 
R"(Usage: 
 vmaware [option] [extra]
 (do not run with any options if you want the full summary)

Options:
 -h | --help        prints this help menu
 -v | --version     print CLI version and other details
 -a | --all         run the result with ALL the techniques enabled (might contain false positives)
 -d | --detect      returns the result as a boolean (1 = VM, 0 = baremetal)
 -s | --stdout      returns either 0 or 1 to STDOUT without any text output (0 = VM, 1 = baremetal)
 -b | --brand       returns the VM brand string
 -l | --brand-list  returns all the possible VM brand string values
 -p | --percent     returns the VM percentage between 0 and 100
 -c | --conclusion  returns the conclusion message string
 -n | --number      returns the number of VM detection techniques it performs
 -t | --type        returns the VM type (if a VM was found)
 -o | --output      set the output path for files, specifically with the --json command

Extra:
 --disable-notes    no notes will be provided
 --high-threshold   a higher threshold bar for a VM detection will be applied
 --no-ansi          removes color and ansi escape codes from the output
 --dynamic          allow the conclusion message to be dynamic (8 possibilities instead of only 2)
 --verbose          add more information to the output
 --enums            display the technique enum name used by the lib
 --detected-only    only display the techniques that were detected 
 --json             output a json-formatted file of the results
)";

    std::exit(0);
}

[[noreturn]] static void version(void) {
    std::cout << "vmaware " << "v" << ver << " (" << date << ")\n\n" <<
    "Derived project of VMAware library at https://github.com/kernelwernel/VMAware\n"
    "License MIT:<https://opensource.org/license/mit>.\n" << 
    "This is free software: you are free to change and redistribute it.\n" <<
    "There is NO WARRANTY, to the extent permitted by law.\n" <<

    "Developed and maintained by kernelwernel and Requiem,\n" << 
    "see https://github.com/kernelwernel and https://github.com/NotRequiem\n" <<
    "For any inquiries, contact us on Discord at shenzken or kr.nl, or email us at jeanruyv@gmail.com\n";
    std::exit(0);
}

static const char* color(const u8 score) {
    if (arg_bitset.test(NO_ANSI)) {
        return "";
    }

    if (VM::is_hardened()) {
        return green.c_str();
    }

    if (arg_bitset.test(DYNAMIC)) {
        if      (score == 0)   { return red.c_str(); }
        else if (score <= 12)  { return red.c_str(); }
        else if (score <= 25)  { return red_orange.c_str(); }
        else if (score < 50)   { return red_orange.c_str(); }
        else if (score <= 62)  { return orange.c_str(); }
        else if (score <= 75)  { return green_orange.c_str(); }
        else if (score < 100)  { return green.c_str(); }
        else if (score == 100) { return green.c_str(); }
    } else {
        if (score == 100) {
            return green.c_str();
        } else {
            return red.c_str();
        }
    }

    return "";
}

[[noreturn]] static void brand_list() {
    std::cout << 
        R"(VirtualBox
        VMware
        VMware Express
        VMware ESX
        VMware GSX
        VMware Workstation
        VMware Fusion
        bhyve
        QEMU
        KVM
        KVM Hyper-V Enlightenment
        QEMU+KVM Hyper-V Enlightenment
        QEMU+KVM
        Virtual PC
        Microsoft Hyper-V
        Microsoft Virtual PC/Hyper-V
        Parallels
        Xen HVM
        ACRN
        QNX hypervisor
        Hybrid Analysis
        Sandboxie
        Docker
        Wine
        Anubis
        JoeBox
        ThreatExpert
        CWSandbox
        Comodo
        Bochs
        Lockheed Martin LMHS
        NVMM
        OpenBSD VMM
        Intel HAXM
        Unisys s-Par
        Cuckoo
        BlueStacks
        Jailhouse
        Apple VZ
        Intel KGT (Trusty)
        Microsoft Azure Hyper-V
        Xbox NanoVisor (Hyper-V)
        SimpleVisor
        Hyper-V artifact (host with Hyper-V enabled)
        User-mode Linux
        IBM PowerVM
        Google Compute Engine (KVM)
        OpenStack (KVM)
        KubeVirt (KVM)
        AWS Nitro System (KVM-based)
        Podman
        WSL
        OpenVZ
        ANY.RUN
        Barevisor
        HyperPlatform
        MiniVisor
        Intel TDX
        LKVM
        AMD SEV
        AMD SEV-ES
        AMD SEV-SNP
        Neko Project II
        NoirVisor
        Qihoo 360 Sandbox
        nsjail
        DBVM
        UTM
        Compaq FX!32
        Insignia RealPC
        Connectix Virtual PC
        )";
    std::exit(0);
}


static bool is_admin() {
#if (CLI_LINUX)
    const uid_t uid  = getuid();
    const uid_t euid = geteuid();

    const bool is_root = (
        (uid != euid) || 
        (euid == 0)
    );

    return is_root;
#elif (WINDOWS)
    bool is_admin = false;
    HANDLE hToken = nullptr;
    if (OpenProcessToken(reinterpret_cast<HANDLE>(-1LL), TOKEN_QUERY, &hToken)) {
        TOKEN_ELEVATION elevation{};
        DWORD dwSize;
        if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize)) {
            if (elevation.TokenIsElevated)
                is_admin = true;
        }
        CloseHandle(hToken);
    }
    return is_admin;
#endif
}

#if (CLI_LINUX)
static bool are_perms_required(const VM::enum_flags flag) {
    if (is_admin()) {
        return false;
    }

    switch (flag) {
    case VM::VMWARE_DMESG:
    case VM::DMIDECODE:
    case VM::DMESG:
    case VM::QEMU_USB:
    case VM::KMSG:
    case VM::SMBIOS_VM_BIT: return true;
    default: return false;
    }
}
#endif

static bool is_disabled(const VM::enum_flags flag) {
    if (arg_bitset.test(ALL)) {
        return false;
    }

    return flag == VM::VMWARE_DMESG;
}

static bool is_unsupported(VM::enum_flags flag) {
    // is cross-platform?
    if (
        (flag >= VM::HYPERVISOR_BIT) &&
        (flag <= VM::KGT_SIGNATURE)
    ) {
        return false;
    }

    #if (CLI_LINUX)
        return (
            (flag >= VM::LINUX_START) &&
            (flag <= VM::LINUX_END)
        );
    #elif (CLI_WINDOWS)
        return (
            (flag >= VM::WINDOWS_START) &&
            (flag <= VM::WINDOWS_END)
        );
    #elif (APPLE)
        return (
            (flag >= VM::MACOS_START) &&
            (flag <= VM::MACOS_END)
        );
    #else
        return true;
    #endif
}

// just a simple string replacer
static void replace(std::string &text, const std::string &original, const std::string &new_brand) {
    size_t start_pos = 0;
    while ((start_pos = text.find(original, start_pos)) != std::string::npos) {
        text.replace(start_pos, original.length(), new_brand);
        start_pos += new_brand.length();
    }
}

static bool is_vm_brand_multiple(const std::string& vm_brand) {
    return (vm_brand.find(" or ") != std::string::npos);
}

static const char* get_vm_description(const std::string& vm_brand) {

    // if there's multiple brands, return null
    if (is_vm_brand_multiple(vm_brand)) {
        return "";
    }

    struct BrandEntry {
        const char* brand;
        const char* description;
    };

    static const BrandEntry table[] = {
        { brands::VBOX, "Oracle VirtualBox (formerly Sun VirtualBox, Sun xVM VirtualBox and InnoTek VirtualBox) is a free and commercial hosted hypervisor for x86 and Apple ARM64 virtualization developed by Oracle Corporation initially released in 2007. It supports Intel's VT-x and AMD's AMD-V hardware-assisted virtualization, while providing an extensive feature set as a staple of its flexibility and wide use cases." },
        { brands::VMWARE, "VMware is a free and commercial type 2 hypervisor initially released in 1999 and acquired by EMC, then Dell, and finally Broadcom Inc in 2023. It was the first commercially successful company to virtualize the x86 architecture, and has since produced many sub-versions of the hypervisor since its inception. It uses binary translation to re-write the code dynamically for a faster performance." },
        { brands::VMWARE_EXPRESS, "VMware Express (formerly VMware GSX Server Express) was a free entry-level version of VMware's hosted hypervisor for small-scale virtualization. Released in 2003, it offered basic VM management capabilities but lacked advanced features like VMotion. Discontinued in 2006 as VMware shifted focus to enterprise solutions like ESX and vSphere." },
        { brands::VMWARE_ESX, "VMware ESX (Elastic Sky X) was a type 1 bare-metal hypervisor released in 2001 for enterprise environments. It introduced VMFS clustered filesystems and direct hardware access through its service console. Deprecated in 2010 in favor of the lighter ESXi architecture, which removed the Linux-based service console for improved security." },
        { brands::VMWARE_GSX, "VMware GSX Server (Ground Storm X) was a commercial type 2 hypervisor (2001-2006) for Windows/Linux hosts, targeting departmental server consolidation. Supported features like VM snapshots and remote management through VI Web Access. Discontinued as VMware transitioned to ESX's bare-metal architecture for better performance in enterprise environments." },
        { brands::VMWARE_WORKSTATION, "VMware Workstation is a commercial type 2 hypervisor for Windows/Linux hosts, first released in 1999. Enables nested virtualization, 4K display support, and DirectX 11/OpenGL 4.1 acceleration. Popular with developers for testing multi-tier configurations and legacy OS compatibility through its Unity view mode." },
        { brands::VMWARE_FUSION, "VMware Fusion was a macOS-hosted hypervisor (2007-2024) that allowed Intel-based Macs to run Windows/Linux VMs with Metal graphics acceleration and Retina display support. Discontinued due to Apple's transition to ARM64 architecture with Apple Silicon chips, which required significant architectural changes incompatible with x86 virtualization." },
        { brands::VMWARE_HARD, "VMWare Hardener Loader is an open-source detection mitigation loader to harden vmware virtual machines against VM detection for Windows (vista~win10) x64 guests." },
        { brands::BHYVE, "bhyve (pronounced \"bee hive\", formerly written as BHyVe for \"BSD hypervisor\") is a free type 2 hosted hypervisor initially written for FreeBSD. It can also be used on a number of illumos based distributions including SmartOS, OpenIndiana, and OmniOS. bhyve has a modern codebase and uses fewer resources compared to its competitors. In the case of FreeBSD, the resource management is more efficient." },
        { brands::KVM, "KVM is a free and open source module of the Linux kernel released in 2007. It uses hardware virtualization extensions, and has had support for hot swappable vCPUs, dynamic memory management, and Live Migration. It also reduces the impact that memory write-intensive workloads have on the migration process. KVM emulates very little hardware components, and it defers to a higher-level client application such as QEMU." },
        { brands::QEMU, "The Quick Emulator (QEMU) is a free and open-source emulator that uses dynamic binary translation to emulate a computer's processor. It translates the emulated binary codes to an equivalent binary format which is executed by the machine. It provides a variety of hardware and device models for the VM, while often being combined with KVM. However, no concrete evidence of KVM was found for this system." },
        { brands::QEMU_KVM, "QEMU (a free and open-source emulator that uses dynamic binary translation to emulate a computer's processor) is being used with Kernel-based Virtual Machine (KVM, a free and open source module of the Linux kernel) to virtualize hardware at near-native speeds." },
        { brands::KVM_HYPERV, "KVM-HyperV integration allows Linux KVM hosts to expose Hyper-V-compatible paravirtualization interfaces to Windows guests. Enables performance optimizations like enlightened VMCS (Virtual Machine Control Structure) and TSC (Time Stamp Counter) synchronization, reducing overhead for Windows VMs running on Linux hypervisors." },
        { brands::QEMU_KVM_HYPERV, "A QEMU/KVM virtual machine with Hyper-V enlightenments. These features make Windows and Hyper-V guests think theyâ€™re running on top of a Hyper-V compatible hypervisor and use Hyper-V specific features." },
        { brands::HYPERV, "Hyper-V is Microsoft's proprietary native hypervisor that can create x86 VMs on Windows. Released in 2008, it supercedes previous virtualization solutions such as Microsoft Virtual Server and Windows VirtualPC. Hyper-V uses partitioning to isolate the guest OSs, and has \"enlightenment\" features for bypassing device emulation layers, allowing for faster execution including when Windows is virtualized on Linux." },
        { brands::HYPERV_VPC, "Either Hyper-V or VirtualPC were detected. Hyper-V is Microsoft's proprietary native hypervisor that can create x86 VMs on Windows. Virtual PC is a discontinued x86 emulator software for Microsoft Windows hosts and PowerPC-based Mac hosts." },
        { brands::PARALLELS, "Parallels is a hypervisor providing hardware virtualization for Mac computers. It was released in 2006 and is developed by Parallels, a subsidiary of Corel. It is a hardware emulation virtualization software, using hypervisor technology that works by mapping the host computer's hardware resources directly to the VM's resources. Each VM thus operates with virtually all the resources of a physical computer." },
        { brands::XEN, "Xen is a free and open-source type 1 hypervisor. Originally developed by the University of Cambridge Computer Laboratory and is now being developed by the Linux Foundation with support from Intel, Arm Ltd, Huawei, AWS, Alibaba Cloud, AMD, and more. It runs in a more privileged CPU state than any other software on the machine, except for firmware. It uses GNU GRUB as its bootloader, and then loads a paravirtualized host OS into the host domain (dom0)." },
        { brands::ACRN, "ACRN is an open source reference type 1 hypervisor stack made by the Linux Foundation Project targeting the IoT, Embedded, Edge segments. Its objective is to cater to the needs of those who require to run Virtual Machines with Real-Time characteristics, or where Functional Safety workloads need to be isolated from other workloads running on the same hardware platform." },
        { brands::QNX, "QNX Hypervisor is a real-time virtualization platform for embedded systems, enabling concurrent execution of QNX Neutrino RTOS and Linux/Android on ARM/x86. Provides time partitioning with <1 microsecond interrupt latency for automotive systems, certified to ISO 26262 ASIL D safety standards. Used in Audi MIB3 and BMW iDrive systems." },
        { brands::HYBRID, "Hybrid Analysis is a sandbox that combines basic and dynamic analysis techniques to detect malicious code that is trying to hide. It extracts indicators of compromise (IOCs) from both runtime data and memory dump analysis, providing a comprehensive approach to malware analysis." },
        { brands::SANDBOXIE, "Sandboxie is an open-source OS-level virtualization solution for Microsoft Windows, an application sandbox for Windows that redirects file/registry writes to virtualized storage. Acquired by Sophos in 2019 and open-sourced in 2020, it uses kernel-mode drivers (SbieDrv.sys) to isolate processes without full VM overhead. Commonly used for testing untrusted software or browsing securely." },
        { brands::DOCKER, "Docker is a set of platform as a service (PaaS) products that use OS-level virtualization to deliver software in packages called containers. The service has both free and premium tiers. The software that hosts the containers is called Docker Engine. It's used to automate the deployment of applications in lightweight containers so that applications can work efficiently in different environments in isolation." },
        { brands::WINE, "Wine is a free and open-source compatibility layer to allow application software and computer games developed for Microsoft Windows to run on Unix-like operating systems. Developers can compile Windows applications against WineLib to help port them to Unix-like systems. Wine is predominantly written using black-box testing reverse-engineering, to avoid copyright issues. No code emulation or virtualization occurs." },
        { brands::VPC, "Microsoft Virtual PC (2004-2011) was a consumer-focused type 2 hypervisor for running Windows XP/Vista guests. Featured \"Undo Disks\" for rollback capability and host-guest integration components. Discontinued after Windows 7's XP Mode due to Hyper-V's emergence, lacking hardware-assisted virtualization support." },
        { brands::ANUBIS, "Anubis is a tool for analyzing the behavior of Windows PE-executables with special focus on the analysis of malware. Execution of Anubis results in the generation of a report file that contains enough information to give a human user a very good impression about the purpose and the actions of the analyzed binary. The generated report includes detailed data about modifications made to the Windows registry or the file system, about interactions with the Windows Service Manager or other processes and of course it logs all generated network traffic." },
        { brands::JOEBOX, "Joe Sandbox (formerly JoeBox) is a cloud-based malware analysis solution with Deep Learning classification. Features multi-OS analysis (Windows/Linux/Android), memory forensics, and MITRE ATT&CK mapping. Offers hybrid analysis combining static/dynamic techniques with 400+ behavioral indicators for enterprise threat hunting." },
        { brands::THREATEXPERT, "ThreatExpert was an automated malware analysis service (2007-2013) that provided behavioral reports via web API. Pioneered mass-scale analysis with heuristic detection of packers/rootkits. Discontinued as competing services like VirusTotal and Hybrid Analysis adopted similar cloud-based approaches with richer feature sets." },
        { brands::CWSANDBOX, "CWSandbox is a tool for malware analysis, developed by Carsten Willems as part of his thesis and Ph.D. studies." },
        { brands::COMODO, "Comodo is a proprietary sandbox running an isolated operating environment. Comodo have integrated sandboxing technology directly into the security architecture of Comodo Internet Security to complement and strengthen the Firewall, Defense+ and Antivirus modules of their product line. It features a hybrid of user mode hooks along with a kernel mode driver, preventing any modification to files or registry on the host machine." },
        { brands::BOCHS, "Bochs (pronounced \"box\") is a free and open-source portable IA-32 and x86-64 IBM PC compatible emulator and debugger mostly written in C++. Bochs is mostly used for OS development and to run other guest OSs inside already running host OSs, while emulating the hardware needed such as hard drives, CD drives, and floppy drives. It doesn't utilize any host CPU virtualization features, therefore is slower than most virtualization software." },
        { brands::NVMM, "NVMM (NetBSD Virtual Machine Monitor) is NetBSD's native hypervisor for NetBSD 9.0. It provides a virtualization API, libnvmm, that can be leveraged by emulators such as QEMU. A unique property of NVMM is that the kernel never accesses guest VM memory, only creating it. Intel's Hardware Accelerated Execution Manager (HAXM) provides an alternative solution for acceleration in QEMU for Intel CPUs only, similar to Linux's KVM." },
        { brands::BSD_VMM, "BSD VMM is FreeBSD's kernel subsystem powering the bhyve hypervisor. Implements Intel VT-x/AMD-V virtualization with direct device assignment (PCI passthrough). Supports UEFI boot and VirtIO paravirtualized devices, optimized for FreeBSD guests with FreeBSD-specific virtio_net(4) and virtio_blk(4) drivers." },
        { brands::INTEL_HAXM, "HAXM was created to bring Intel Virtualization Technology to Windows and macOS users. Today both Microsoft Hyper-V and macOS HVF have added support for Intel Virtual Machine Extensions. The project is discontinued." },
        { brands::UNISYS, "Unisys Secure Partitioning (s-ParÂ®) is firmware made by ClearPath Forward that provides the capability to run multiple operating environments concurrently on the same computer hardware: for example, Linux and Windows operating environments. Unlike virtualization technologies and virtual machines, each s-Par operating environment has dedicated hardware resourcesâ€”instruction processor cores, memory, and input/output components. Each s-Par operating environment is referred to as a secure partition (or just â€œpartition,â€ for short). A secure partition is sometimes referred to as a hard partition." },
        { brands::LMHS, "LMHS is Lockheed Martin's native hypervisor. I assume you got this result because you're an employee in the company and you're doing security testing. But if you're not, how the hell did you get this result? Did you steal a US military fighter jet or something? I'm genuinely curious. I really don't expect anybody to have this result frankly but I'll assume it's just a false positive (please create an issue in the repo if it is)." },
        { brands::CUCKOO, "Cuckoo Sandbox is an open-source automated malware analysis system. Executes files in isolated environments (VirtualBox/QEMU) while monitoring API calls, network traffic, and memory changes. Features YARA rule matching and CAPE (Customized Automated Processing Engine) extensions for advanced threat hunting and IOC extraction." },
        { brands::BLUESTACKS, "BlueStacks is a chain of cloud-based cross-platform products developed by the San Francisco-based company of the same name. The BlueStacks App Player enables the execution of Android applications on computers running Microsoft Windows or macOS. It functions through an Android emulator referred to as App Player. The basic features of the software are available for free, while advanced features require a paid monthly subscription." },
        { brands::JAILHOUSE, "Jailhouse is a free and open source partitioning Hypervisor based on Linux, made by Siemens. It is able to run bare-metal applications or (adapted) operating systems besides Linux. For this purpose, it configures CPU and device virtualization features of the hardware platform in a way that none of these domains, called \"cells\", can interfere with each other in an unacceptable way." },
        { brands::APPLE_VZ, "Apple Virtualization Framework (VZ) is a macOS 12+ API for creating ARM64 VMs on Apple Silicon. Provides para-virtualized devices via VirtIO and Rosetta 2 binary translation for x86_64 Linux guests. Used by Lima and UTM to run Linux distributions natively on M1/M2 Macs without traditional hypervisor overhead." },
        { brands::INTEL_KGT, "Intel Kernel Guard Technology (KGT) is a policy specification and enforcement framework for ensuring runtime integrity of kernel and platform assets. Demonstrated secure enclaves for critical OS components using VT-x/EPT before being superseded by CET (Control-flow Enforcement Technology) and HyperGuard in Windows 10." },
        { brands::AZURE_HYPERV, "Azure Hyper-V is Microsoft's cloud-optimized hypervisor variant powering Azure VMs. Implements Azure-specific virtual devices like NVMe Accelerated Networking and vTPMs. Supports nested virtualization for running Hyper-V/containers within Azure VMs, enabling cloud-based CI/CD pipelines and dev/test environments." },
        { brands::SIMPLEVISOR, "SimpleVisor is a minimalist Intel VT-x hypervisor by Alex Ionescu for Windows/Linux research. Demonstrates EPT-based memory isolation and hypercall handling. Used to study VM escapes and hypervisor rootkits, with hooks for intercepting CR3 changes and MSR accesses." },
        { brands::HYPERV_ARTIFACT, "VMAware detected Hyper-V operating as a type 1 hypervisor, not as a guest virtual machine. Although your hardware/firmware signatures match Microsoft's Hyper-V architecture, we determined that you're running on baremetal. This prevents false positives, as Windows sometimes runs under Hyper-V (type 1) hypervisor." },
        { brands::UML, "User-Mode Linux (UML) allows running Linux kernels as user-space processes using ptrace-based virtualization. Primarily used for kernel debugging and network namespace testing. Offers lightweight isolation without hardware acceleration, but requires host/guest kernel version matching for stable operation." },
        { brands::POWERVM, "IBM PowerVM is a type 1 hypervisor for POWER9/10 systems, supporting Live Partition Mobility and Shared Processor Pools. Implements VIOS (Virtual I/O Server) for storage/networking virtualization, enabling concurrent AIX, IBM i, and Linux workloads with RAS features like predictive failure analysis." },
        { brands::GCE, "Google Compute Engine (GCE) utilizes KVM-based virtualization with custom Titanium security chips for hardware root of trust. Features live migration during host maintenance and shielded VMs with UEFI secure boot. Underpins Google Cloud's Confidential Computing offering using AMD SEV-SNP memory encryption." },
        { brands::OPENSTACK, "OpenStack is an open-source cloud OS managing compute (Nova), networking (Neutron), and storage (Cinder) resources. Supports multiple hypervisors (KVM/Xen/Hyper-V) through driver plugins. Widely used in private clouds with features like Heat orchestration and Octavia load balancing." },
        { brands::KUBEVIRT, "KubeVirt is a VM management add-on for Kubernetes. It provides a common ground for virtualization solutions on top of Kubernetes by extending its core by adding additional virtualization resource types where the Kubernetes API can be used to manage these VM resources alongside all other resources Kubernetes provides. Its functionality is to provide a runtime in order to define and manage VMs." },
        { brands::AWS_NITRO, "AWS Nitro is Amazon's hypervisor for EC2, offloading network/storage to dedicated Nitro Cards. Uses Firecracker microVMs for Lambda/Fargate serverless compute. Provides bare-metal instance types (i3en.metal) with 3x better EBS throughput compared to traditional Xen-based instances." },
        { brands::PODMAN, "Podman is a daemonless container engine by Red Hat using Linux namespaces/cgroups. Supports rootless containers and Docker-compatible CLI syntax. Integrates with systemd for service management and Quadlet for declarative container definitions. Part of the Podman Desktop suite for Kubernetes development." },
        { brands::WSL, "Windows Subsystem for Linux (WSL) is a feature of Microsoft Windows that allows for using a Linux environment without the need for a separate VM or dual booting. WSL requires fewer resources (CPU, memory, and storage) than a full virtual machine (a common alternative for using Linux in Windows), while also allowing the use of both Windows and Linux tools on the same set of files." },
        { brands::OPENVZ, "OpenVZ is a container-based virtualization for Linux using kernel-level isolation. Provides checkpointing and live migration through ploop storage. Requires matching host/guest kernel versions, largely superseded by LXC/LXD due to Docker's popularity and kernel namespace flexibility." },
        { brands::BAREVISOR, "BareVisor is a research-focused type 1 hypervisor emphasizing minimal TCB (Trusted Computing Base). Supports x86/ARM with <10K LoC for secure enclave experiments. Used in academia to study TEEs (Trusted Execution Environments) and hypervisor-based intrusion detection systems." },
        { brands::HYPERPLATFORM, "HyperPlatform is an Intel VT-x research hypervisor for Windows kernel introspection. Provides APIs for EPT hooking and MSR filtering. Used to develop anti-cheat systems and kernel exploit detectors by monitoring CR3 switches and exception handling." },
        { brands::MINIVISOR, "MiniVisor is a research hypervisor written as a UEFI and Windows driver for the educational purpose for Intel processors. This MiniVisor, as a UEFI driver, provides the ability to inspect system activities even before the operating system boots, while as a Windows driver, allows developers to debug it with familiar tools like WinDbg." },
        { brands::INTEL_TDX, "Intel TDX (Trust Domain Extensions) enhances VM confidentiality in cloud environments. Encrypts VM memory and registers using MKTME (Multi-Key Total Memory Encryption), isolating \"trust domains\" from hypervisors. Part of Intel's vPro platform for confidential computing on Xeon Scalable processors." },
        { brands::LKVM, "LKVM (Linux Kernel Virtual Machine) is a minimal KVM frontend for Linux kernel testing. Provides CLI tools like `lkvm run` for quick VM creation with built-in 9pfs support. Used alongside QEMU for rapid boot testing and kernel panic debugging." },
        { brands::AMD_SEV, "AMD Secure Encrypted Virtualization (SEV) encrypts VM memory with EPYC processor-based AES keys. Isolates guests from hypervisors using ASIDs (Address Space Identifiers), protecting against physical attacks and malicious cloud providers. Supported in Linux/KVM via libvirt SEV options." },
        { brands::AMD_SEV_ES, "AMD SEV-Encrypted State (SEV-ES) extends SEV by encrypting CPU register states during VM exits. Prevents hypervisors from inspecting guest register contents, mitigating attacks using VMRUN/VMEXIT timing side channels. Requires guest OS modifications for secure interrupt handling." },
        { brands::AMD_SEV_SNP, "AMD SEV-Secure Nested Paging (SEV-SNP) adds memory integrity protection to SEV-ES. Uses reverse map tables (RMP) to prevent hypervisor-mediated replay/spoofing attacks. Enables attested launch for cloud workloads via guest policy certificates and AMD's Key Distribution Service (KDS)." },
        { brands::NEKO_PROJECT, "Neko Project II is an emulator designed for emulating PC-98 computers. They are a lineup of Japanese 16-bit and 32-bit personal computers manufactured by NEC from 1982 to 2003. While based on Intel processors, it uses an in-house architecture making it incompatible with IBM clones." },
        { brands::NOIRVISOR, "NoirVisor is a hardware-accelerated hypervisor with support to complex functions and purposes. It is designed to support processors based on x86 architecture with hardware-accelerated virtualization feature. For example, Intel processors supporting Intel VT-x or AMD processors supporting AMD-V meet the requirement. It was made by Zero-Tang." },
        { brands::QIHOO, "360 sandbox is a part of 360 Total Security. Similar to other sandbox software, it provides a virtualized environment where potentially malicious or untrusted programs can run without affecting the actual system. Qihoo 360 Sandbox is commonly used for testing unknown applications, analyzing malware behavior, and protecting users from zero-day threats." },
        { brands::NSJAIL, "nsjail is a process isolation tool for Linux. It utilizes Linux namespace subsystem, resource limits, and the seccomp-bpf syscall filters of the Linux kernel. It can be used for isolating networking services, CTF challenges, and containing invasive syscall-level OS fuzzers." },
        { brands::DBVM, "DBVM is a ultra-lightweight virtual machine host that makes Windows run in a virtual machine so that Cheat Engine can operate at a higher level than the OS using a device driver. Instead of virtualizing devices it generally passes on interrupts unaltered meaning it has a very small impact on performance." },
        { brands::UTM, "UTM for macOS is a free, open-source virtualization and emulation app that brings full-featured virtual machines to both Intel and Apple Silicon Macs. It employs Apple's Hypervisor virtualization framework to run ARM64 operating systems on Apple Silicon at near native speeds. On other architectures, it employs software emulation through QEMU." },
        { brands::COMPAQ, "Compaq FX!32 is an emulator that is designed to run Win32 programs for the DEC instruction set architecture. Released in 1996, it was developed by developed by Digital Equipment Corporation (DEC) to support their Alpha microprocessors. It analyzed the way programs worked and, after the program ran, used binary translation to produce dynamic-link library (DLL) files of native Alpha code that the application could execute the next time it ran." },
        { brands::INSIGNIA, "RealPC was an emulator for the Macintosh line of PCs. It emulated a Pentium-based PC to run Windows NT, Windows 95, and Windows 98 programs. It was discontinued in 2003." },
        { brands::CONNECTIX, "Connectix VirtualPC was the predecessor to Microsoft's VirtualPC. Originally developed as a Macintosh application for System 7.5 and released by Connectix in June 1997, it supported various OS's such as Linux and old versions of Windows. It was bought by Microsoft in February 2003." },
        { brands::NULL_BRAND, "Indicates no detectable virtualization brand. This result may occur on bare-metal systems, unsupported/obscure hypervisors, or when anti-detection techniques (e.g., VM escaping) are employed by the guest environment." }
    };

    // Range-based for loop (C++11)
    // std::string operator== checks size first, so this is highly optimized.
    for (const auto& entry : table) {
        if (vm_brand == entry.brand) {
            return entry.description;
        }
    }

    return "";
}


/**
 * @brief Check for any.run driver presence
 * @category Windows
 * @author kkent030315
 * @link https://github.com/kkent030315/detect-anyrun/blob/main/detect.cc
 * @copyright MIT
 */
[[nodiscard]] static bool anyrun_driver() {
#if (!CLI_WINDOWS)
    return false;
#else
    HANDLE hFile;

    hFile = CreateFile(
        /*lpFileName*/TEXT("\\\\?\\\\A3E64E55_fl"),
        /*dwDesiredAccess*/GENERIC_READ,
        /*dwShareMode*/0,
        /*lpSecurityAttributes*/nullptr,
        /*dwCreationDisposition*/OPEN_EXISTING,
        /*dwFlagsAndAttributes*/0,
        /*hTemplateFile*/nullptr
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        return false;
    }

    CloseHandle(hFile);

    return true;
#endif
}


[[nodiscard]] static bool anyrun_directory() {
#if (!CLI_WINDOWS)
    return false;
#else
    NTSTATUS status;

    HMODULE ntdll = GetModuleHandleA("ntdll.dll");
    if (!ntdll) {
        return false;
    }

    using NtCreateFile_t = NTSTATUS(
        __stdcall*)(
            PHANDLE,
            ACCESS_MASK,
            POBJECT_ATTRIBUTES,
            PIO_STATUS_BLOCK,
            PLARGE_INTEGER,
            ULONG,
            ULONG,
            ULONG,
            ULONG,
            PVOID,
            ULONG
            );
    using NtClose_t = NTSTATUS(__stdcall*)(HANDLE);
    using RtlInitUnicodeString_t = VOID(__stdcall*)(PUNICODE_STRING, PCWSTR);

#pragma warning(push)
    #pragma warning(disable:4191)
    auto pRtlInitUnicodeString = reinterpret_cast<RtlInitUnicodeString_t>(
        GetProcAddress(ntdll, "RtlInitUnicodeString"));
    auto pNtCreateFile = reinterpret_cast<NtCreateFile_t>(
        GetProcAddress(ntdll, "NtCreateFile"));
    auto pNtClose = reinterpret_cast<NtClose_t>(
        GetProcAddress(ntdll, "NtClose"));
#pragma warning(pop)

    if (!pRtlInitUnicodeString || !pNtCreateFile || !pNtClose) {
        return false;
    }

    UNICODE_STRING name;
    pRtlInitUnicodeString(&name, L"\\??\\C:\\Program Files\\KernelLogger");

    HANDLE hFile;
    IO_STATUS_BLOCK iosb;
    OBJECT_ATTRIBUTES attrs{};
    InitializeObjectAttributes(&attrs, &name, 0, nullptr, nullptr);

    status = pNtCreateFile(
        /*FileHandle*/&hFile,
        /*DesiredAccess*/GENERIC_READ | SYNCHRONIZE,
        /*ObjectAttributes*/&attrs,
        /*IoStatusBlock*/&iosb,
        /*AllocationSize*/nullptr,
        /*FileAttributes*/FILE_ATTRIBUTE_DIRECTORY,
        /*ShareAccess*/FILE_SHARE_READ,
        /*CreateDisposition*/FILE_OPEN,
        /*CreateOptions*/FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
        /*EaBuffer*/nullptr,
        /*EaLength*/0
    );

    // ANY.RUN minifilter returns non-standard status code, STATUS_NO_SUCH_FILE
    // If this status code is returned, it means that the directory is protected
    // by the ANY.RUN minifilter driver.
    // To patch this detection, I would recommend returning STATUS_OBJECT_NAME_NOT_FOUND
    // that is a standard status code for this situation.
    if (static_cast<ULONG>(status) == 0xC000000F) // STATUS_NOT_SUCH_FILE
        return true;

    // Not actually the case, maybe conflict with other software installation.
    if (NT_SUCCESS(status))
        pNtClose(hFile);

    return false;
#endif
}

static void checker(const VM::enum_flags flag, const char* message) {
    std::string enum_name = "";

    if (arg_bitset.test(ENUMS)) {
        enum_name = grey + " [VM::" + VM::flag_to_string(flag) + "]" + ansi_exit;
    }

    if (is_disabled(flag)) {
        if (!arg_bitset.test(DETECTED_ONLY))
            std::cout << disabled << " Skipped " << message << enum_name << "\n";
        disabled_count++;
        return;
    }

    if (is_unsupported(flag)) {
        unsupported_count++;
    } else {
        supported_count++;
    }

    const bool result = VM::check(flag);

    if (arg_bitset.test(DETECTED_ONLY) && !result) {
        return;
    }

#if (CLI_LINUX)
    if (are_perms_required(flag)) {
        std::cout << no_perms << " Skipped " << message << enum_name << "\n";

        no_perms_count++;

        // memoize it, it's going to be ran later anyway with stuff like VM::detect()
        VM::check(flag);

        return;
    }
#endif

    if (result) {
        std::cout << detected << bold << " Checking " << message << "..." << enum_name << ansi_exit << "\n";
    } else {
        std::cout << not_detected << " Checking " << message << "..." << enum_name << ansi_exit << "\n";
    }
}


// overload for std::function, this is specific for any.run techniques
// that are embedded in the CLI because it was removed in the lib as of 2.0
static void checker(const std::function<bool()>& func, const char* message) {
#if (!CLI_WINDOWS)
    if (arg_bitset.test(VERBOSE)) {
        unsupported_count++;
    } else {
        supported_count++;
    }
#else
    supported_count++;
#endif

    const bool result = func();

    if (arg_bitset.test(DETECTED_ONLY) && !result) {
        return;
    }

    std::cout <<
        (result ? detected : not_detected) <<
        (result ? bold : "") <<
        " Checking " <<
        message <<
        "..." << 
        (result ? ansi_exit : "") << 
        "\n";

}


const bool is_anyrun_directory = anyrun_directory();
const bool is_anyrun_driver = anyrun_driver();
const bool is_anyrun = (is_anyrun_directory || is_anyrun_driver);


static void general(
    const VM::enum_flags high_threshold, 
    const VM::enum_flags all,
    const VM::enum_flags dynamic
) {
    bool notes_enabled = false;
   
    if (arg_bitset.test(NO_ANSI)) {
        detected = ("[  DETECTED  ]");
        not_detected = ("[NOT DETECTED]");
        no_support = ("[ NO SUPPORT ]");
        no_perms = ("[  NO PERMS  ]");
        note = ("[    NOTE    ]");               
        disabled = ("[  DISABLED  ]");
        
        bold = "";
        underline = "";
        ansi_exit = "";
        red = ""; 
        orange = "";
        green = "";
        red_orange = "";
        green_orange = "";
        grey = "";
    }

    if (arg_bitset.test(NOTES)) {
        notes_enabled = false;
    } else {
        notes_enabled = true;
    }

    #if (CLI_LINUX)
        if (notes_enabled && !is_admin()) {
            std::cout << note << " Running under root might give better results\n";
        }
    #elif (CLI_WINDOWS)
        if (!is_admin()) {
            std::cout << note << " Not running as admin - NVRAM detections will be disabled.\n";
        }
    #endif

    const std::string hash = compute_self_sha256();
    if (!hash.empty()) {
        std::cout << "SHA256: " << hash << '\n';
    }

    const auto t1 = std::chrono::high_resolution_clock::now();

    checker(VM::VMID, "VMID");
    checker(VM::CPU_BRAND, "CPU brand");
    checker(VM::HYPERVISOR_BIT, "CPUID hypervisor bit");
    checker(VM::HYPERVISOR_STR, "hypervisor str");
    checker(VM::TIMER, "timing anomalies");
    checker(VM::THREAD_COUNT, "thread count");
    checker(VM::MAC, "MAC addresses");
    checker(VM::TEMPERATURE, "temperature");
    checker(VM::SYSTEMD, "systemd virtualisation");
    checker(VM::CVENDOR, "chassis vendor");
    checker(VM::CTYPE, "chassis type");
    checker(VM::DOCKERENV, "Dockerenv");
    checker(VM::DMIDECODE, "dmidecode output");
    checker(VM::DMESG, "dmesg output");
    checker(VM::HWMON, "hwmon presence");
    checker(VM::DLL, "DLLs");
    checker(VM::WINE, "Wine");
    checker(VM::HWMODEL, "hw.model");
    checker(VM::PROCESSES, "processes");
    checker(VM::LINUX_USER_HOST, "default Linux user/host");
    checker(VM::GAMARUE, "gamarue ransomware technique");
    checker(VM::BOCHS_CPU, "BOCHS CPU techniques");
    checker(VM::MAC_MEMSIZE, "MacOS hw.memsize");
    checker(VM::MAC_IOKIT, "MacOS registry IO-kit");
    checker(VM::IOREG_GREP, "IO registry grep");
    checker(VM::MAC_SIP, "MacOS SIP");
    checker(VM::AUDIO, "audio devices");
    checker(VM::DEVICE_HANDLES, "device handles");
    checker(VM::VPC_INVALID, "VPC invalid instructions");
    checker(VM::SYSTEM_REGISTERS, "Task segment and descriptor tables");
    checker(VM::VMWARE_IOMEM, "/proc/iomem file");
    checker(VM::VMWARE_IOPORTS, "/proc/ioports file");
    checker(VM::VMWARE_SCSI, "/proc/scsi/scsi file");
    checker(VM::VMWARE_DMESG, "VMware dmesg");
    checker(VM::VMWARE_STR, "STR instruction");
    checker(VM::VMWARE_BACKDOOR, "VMware IO port backdoor");
    checker(VM::MUTEX, "mutex strings");
    checker(VM::THREAD_MISMATCH, "thread count mismatch");
    checker(VM::CUCKOO_DIR, "Cuckoo directory");
    checker(VM::CUCKOO_PIPE, "Cuckoo pipe");
    checker(VM::AZURE, "Azure Hyper-V");
    checker(VM::DISPLAY, "display");
    checker(VM::DEVICE_STRING, "bogus device string");
    checker(VM::BLUESTACKS_FOLDERS, "BlueStacks folders");
    checker(VM::CPUID_SIGNATURE, "CPUID signatures");
    checker(VM::KGT_SIGNATURE, "Intel KGT signature");
    checker(VM::QEMU_VIRTUAL_DMI, "QEMU virtual DMI directory");
    checker(VM::QEMU_USB, "QEMU USB");
    checker(VM::HYPERVISOR_DIR, "hypervisor directory (Linux)");
    checker(VM::UML_CPU, "User-mode Linux CPU");
    checker(VM::KMSG, "/dev/kmsg hypervisor message");
    checker(VM::VBOX_MODULE, "VBox kernel module");
    checker(VM::SYSINFO_PROC, "/proc/sysinfo");
    checker(VM::DMI_SCAN, "DMI scan");
    checker(VM::SMBIOS_VM_BIT, "SMBIOS VM bit");
    checker(VM::PODMAN_FILE, "podman file");
    checker(VM::WSL_PROC, "WSL string in /proc");
    checker(anyrun_driver, "ANY.RUN driver");
    checker(anyrun_directory, "ANY.RUN directory");
    checker(VM::DRIVERS, "driver names");
    checker(VM::DISK_SERIAL, "disk serial number");
    checker(VM::IVSHMEM, "IVSHMEM device");
    checker(VM::GPU_CAPABILITIES, "GPU capabilities");
    checker(VM::POWER_CAPABILITIES, "power capabilities");
    checker(VM::QEMU_FW_CFG, "QEMU fw_cfg device");
    checker(VM::VIRTUAL_PROCESSORS, "virtual processors");
    checker(VM::HYPERVISOR_QUERY, "hypervisor query");
    checker(VM::AMD_SEV, "AMD-SEV MSR");
    checker(VM::VIRTUAL_REGISTRY, "registry emulation");
    checker(VM::FIRMWARE, "firmware");
    checker(VM::FILE_ACCESS_HISTORY, "low file access count");
    checker(VM::NSJAIL_PID, "nsjail PID");
    checker(VM::PCI_DEVICES, "PCI vendor/device ID");
    checker(VM::ACPI_SIGNATURE, "ACPI device signatures");
    checker(VM::TRAP, "hypervisor interception");
    checker(VM::UD, "undefined exceptions");
    checker(VM::BLOCKSTEP, "single step with trap flag");
    checker(VM::DBVM, "Dark Byte's hypervisor");
    checker(VM::BOOT_LOGO, "boot logo");
    checker(VM::MAC_SYS, "system profiler");
    checker(VM::KERNEL_OBJECTS, "kernel objects");
    checker(VM::NVRAM, "NVRAM");
    checker(VM::SMBIOS_INTEGRITY, "SMBIOS integrity");
    checker(VM::EDID, "EDID");
    checker(VM::CPU_HEURISTIC, "CPU heuristics");
    checker(VM::CLOCK, "system timers");
    checker(VM::MSR, "model specific registers");

    // ADD NEW TECHNIQUE CHECKER HERE

    const auto t2 = std::chrono::high_resolution_clock::now();

    std::printf("\n");

    // struct containing the whole overview of the VM data
    VM::vmaware vm(VM::MULTIPLE, high_threshold, all, dynamic);

    // brand manager
    {
        std::string brand = vm.brand;

        if (is_anyrun && (brand == brands::NULL_BRAND)) {
            brand = "ANY.RUN";
        }

        const bool is_red = (
            (brand == brands::NULL_BRAND) || 
            (brand == brands::HYPERV_ARTIFACT)
        );

        std::cout << bold << "VM brand: " << ansi_exit << (is_red ? red : green) << brand << ansi_exit << "\n";
    }


    // type manager
    {
        if (is_vm_brand_multiple(vm.brand) == false) {
            std::string current_color = "";
            std::string type = vm.type;

            if (is_anyrun && (type == brands::NULL_BRAND)) {
                type = "Sandbox";
            }

            if (type == brands::NULL_BRAND) {
                current_color = red;
            } else {
                current_color = green;
            }

            std::cout << bold << "VM type: " << ansi_exit << current_color << type << ansi_exit << "\n";
        }
    }


    // percentage manager
    {
        const char* percent_color;

        if (vm.percentage == 0) { percent_color = red.c_str(); }
        else if (vm.percentage < 25) { percent_color = red_orange.c_str(); }
        else if (vm.percentage < 50) { percent_color = orange.c_str(); }
        else if (vm.percentage < 75) { percent_color = green_orange.c_str(); }
        else { percent_color = green.c_str(); }

        std::cout << bold << "VM likeliness: " << ansi_exit << percent_color << static_cast<u32>(vm.percentage) << "%" << ansi_exit << "\n";
    }


    // VM confirmation manager
    {
        std::cout << bold << "VM confirmation: " << ansi_exit << (vm.is_vm ? green : red) << std::boolalpha << vm.is_vm << std::noboolalpha << ansi_exit << "\n";
    }


    // detection count manager
    {
        const char* count_color;

        switch (vm.detected_count) {
        case 0: count_color = red.c_str(); break;
        case 1: count_color = red_orange.c_str(); break;
        case 2: count_color = orange.c_str(); break;
        case 3: count_color = orange.c_str(); break;
        case 4: count_color = green_orange.c_str(); break;
        default:
            count_color = green.c_str();
        }

        std::cout <<
            bold <<
            "VM detections: " <<
            ansi_exit <<
            count_color <<
            static_cast<u32>(vm.detected_count) <<
            "/" <<
            static_cast<u32>(vm.technique_count) <<
            ansi_exit <<
            "\n";
    }


    // hardened environment detection manager 
    {
        std::cout << bold << "VM hardening: " << ansi_exit;

        if (VM::is_hardened()) {
            std::cout << green << "found" << ansi_exit << "\n";
        } else {
            std::cout << grey << "not found" << ansi_exit << "\n";
        }
    }


    // misc manager
    {
        if (arg_bitset.test(VERBOSE)) {
            std::cout << bold << "\nUnsupported detections: " << ansi_exit << static_cast<u32>(unsupported_count) << "\n";
            std::cout << bold << "Supported detections: " << ansi_exit << static_cast<u32>(supported_count) << "\n";
            std::cout << bold << "No permission detections: " << ansi_exit << static_cast<u32>(no_perms_count) << "\n";
            std::cout << bold << "Disabled detections: " << ansi_exit << static_cast<u32>(disabled_count) << "\n";

            const std::chrono::duration<double, std::milli> elapsed = t2 - t1;
            std::cout << bold << "Execution speed: " << ansi_exit << elapsed.count() << "ms\n";
        }

        std::printf("\n");
    }


    // description manager
    {
        if (vm.brand != brands::NULL_BRAND) {
            const std::string description = get_vm_description(vm.brand);

            if (!description.empty()) {
                std::cout << bold << underline << "VM description:" << ansi_exit << "\n";

                // this basically adds a \n for every 50 characters after a space
                // so that the output doesn't wrap around the console while making
                // it harder to read. Kinda like how this comment you're reading is
                // structured by breaking the lines in a clean and organised way. 
                const u8 max_line_length = 60;
                
                std::vector<std::string> divided_description;

                std::istringstream stream(description);
                std::string word_snippet;

                // extract words separated by spaces
                while (stream >> word_snippet) {
                    divided_description.push_back(word_snippet);
                }

                std::size_t char_count = 0;

                for (auto it = divided_description.begin(); it != divided_description.end(); ++it) {
                    char_count += it->length() + 1; // +1 because of the space

                    if (char_count <= 60) {
                        continue;
                    } else {
                        if ((char_count - 1) >= (static_cast<unsigned long long>(max_line_length) + 3)) {
                            it = divided_description.insert(it + 1, "\n");
                            char_count = it->length() + 1;
                        } else {
                            continue;
                        }
                    }
                }

                for (const auto& str : divided_description) {
                    std::cout << str << ((str != "\n") ? " " : "");
                }

                std::printf("\n\n");
            }
        }
    }


    // conclusion manager
    {
        const char* conclusion_color = color(vm.percentage);

        std::string conclusion = vm.conclusion;

        if (is_anyrun && VM::brand() == brands::NULL_BRAND) {
            const std::string original = "unknown";
            const std::string new_brand = "ANY.RUN";

            replace(conclusion, original, new_brand);
        }

        std::cout
            << bold
            << "\n====== CONCLUSION: "
            << ansi_exit
            << conclusion_color << conclusion << " " << ansi_exit
            << bold
            << "======"
            << ansi_exit
            << "\n\n";
    }


    // finishing touches with notes
    if (notes_enabled) {
        if (vm.detected_count != 0) {
            std::cout << 
                note << 
                " If you found a false positive, please make sure to create\n \
              an issue at https://github.com/kernelwernel/VMAware/issues\n\n";
// ^ do not modify the space above
        }
    }

#if (WINDOWS)
    std::cout << "Press Enter to exit...";
    std::cin.get();
#endif
}

static void generate_json(const char* output) {
    std::vector<std::string> json;

    json.push_back("{");
    json.push_back("\n\t\"is_detected\": ");
    json.push_back(VM::detect() ? "true," : "false,");
    json.push_back("\n\t\"brand\": \"");
    json.push_back(VM::brand());
    json.push_back("\",");
    json.push_back("\n\t\"conclusion\": \"");
    json.push_back(VM::conclusion());
    json.push_back("\",");
    json.push_back("\n\t\"percentage\": ");
    json.push_back(std::to_string(static_cast<int>(VM::percentage())));
    json.push_back(",");
    json.push_back("\n\t\"detected_technique_count\": ");
    json.push_back(std::to_string(VM::technique_count));
    json.push_back(",");
    json.push_back("\n\t\"vm_type\": \"");
    json.push_back(VM::type());
    json.push_back("\",");
    json.push_back("\n\t\"is_hardened\": ");
    json.push_back(VM::is_hardened() ? "true," : "false,");
    json.push_back("\n\t\"detected_techniques\": [");

    const auto detected_status = VM::detected_enums();

    if (detected_status.size() == 0) {
        json.push_back("]\n}");
    }
    else {
        for (size_t i = 0; i < detected_status.size(); i++) {
            json.push_back("\n\t\t\"");
            json.push_back(VM::flag_to_string(detected_status[i]));

            if (i == detected_status.size() - 1) {
                json.push_back("\"");
            }
            else {
                json.push_back("\",");
            }
        }

        json.push_back("\n\t]\n}");
    }

    std::ofstream file(output);
    if (!file) {
        std::cerr << "Failed to open/create file\n";
        return;
    }

    for (const auto& line : json) {
        file << line;
    }

    file.close();
}


int main(int argc, char* argv[]) {
#if (CLI_WINDOWS)
    win_ansi_enabler_t ansi_enabler;
#endif

    const std::vector<std::string> args(argv + 1, argv + argc); // easier to handle args this way
    const u32 arg_count = static_cast<u32>(argc - 1);

    // this was removed from the lib due to ethical 
    // concerns, so it's added in the CLI instead
    VM::add_custom(65, anyrun_driver);
    VM::add_custom(35, anyrun_directory);

    if (arg_count == 0) {
        general(VM::NULL_ARG, VM::NULL_ARG, VM::DYNAMIC);
        return 0;
    }

    static constexpr std::array<std::pair<const char*, arg_enum>, 32> table {{
        { "-h", HELP },
        { "-v", VERSION },
        { "-a", ALL },
        { "-d", DETECT },
        { "-s", STDOUT },
        { "-b", BRAND },
        { "-p", PERCENT },
        { "-c", CONCLUSION },
        { "-l", BRAND_LIST },
        { "-n", NUMBER },
        { "-t", TYPE },
        { "-o", OUTPUT },
        { "help", HELP },
        { "--help", HELP },
        { "--version", VERSION },
        { "--all", ALL },
        { "--detect", DETECT },
        { "--stdout", STDOUT },
        { "--brand", BRAND },
        { "--percent", PERCENT },
        { "--conclusion", CONCLUSION },
        { "--brand-list", BRAND_LIST },
        { "--number", NUMBER },
        { "--type", TYPE },
        { "--disable-notes", NOTES },
        { "--high-threshold", HIGH_THRESHOLD },
        { "--dynamic", DYNAMIC },
        { "--verbose", VERBOSE },
        { "--enums", ENUMS },
        { "--no-ansi", NO_ANSI },
        { "--detected-only", DETECTED_ONLY },
        { "--json", JSON }
    }};

    std::string potential_null_arg = "";
    const char* potential_output_arg = "results.json";

    for (i32 i = 1; i < argc; ++i) {
        const char* arg_string = argv[i];

        auto it = std::find_if(table.cbegin(), table.cend(), [&](const std::pair<const char*, i32>& p) {
            return (std::strcmp(p.first, arg_string) == 0);
        });

        if (it == table.end()) {
            if (arg_bitset.test(OUTPUT)) {
                std::ofstream file(arg_string);
                if (file.good()) {
                    potential_output_arg = arg_string;
                }
                arg_bitset.set(OUTPUT, false);
            } else {
                arg_bitset.set(NULL_ARG);
                potential_null_arg = arg_string;
            }
        } else {
            arg_bitset.set(it->second);
        }
    }


    // no critical returners
    if (arg_bitset.test(NULL_ARG)) {
        std::cerr << "Unknown argument \"" << potential_null_arg << "\", aborting\n";
        return 1;
    }

    if (arg_bitset.test(HELP)) {
        help();
    } 

    if (arg_bitset.test(VERSION)) {
        version();
    }

    if (arg_bitset.test(BRAND_LIST)) {
        brand_list();
    }

    if (arg_bitset.test(NUMBER)) {
        std::cout << static_cast<u32>(VM::technique_count) << "\n";
        return 0;
    }

    if (arg_bitset.test(JSON)) {
        generate_json(potential_output_arg);
        return 0;
    }

    // critical returners
    const u32 returners = (
        static_cast<u32>(arg_bitset.test(STDOUT)) +
        static_cast<u32>(arg_bitset.test(PERCENT)) +
        static_cast<u32>(arg_bitset.test(DETECT)) +
        static_cast<u32>(arg_bitset.test(BRAND)) +
        static_cast<u32>(arg_bitset.test(TYPE)) +
        static_cast<u32>(arg_bitset.test(CONCLUSION))
    );

    const VM::enum_flags high_threshold = (arg_bitset.test(HIGH_THRESHOLD) ? VM::HIGH_THRESHOLD : VM::NULL_ARG);
    const VM::enum_flags all = (arg_bitset.test(ALL) ? VM::ALL : VM::NULL_ARG);
    const VM::enum_flags dynamic = (arg_bitset.test(DYNAMIC) ? VM::DYNAMIC : VM::NULL_ARG);

    if (returners > 0) { // at least one of the options are set
        if (returners > 1) { // more than 2 options are set
            std::cerr << "--stdout, --percent, --detect, --brand, --type, and --conclusion must NOT be a combination, choose only a single one\n";
            return 1;
        }

        if (arg_bitset.test(STDOUT)) {
            return (!VM::detect(high_threshold, all, dynamic));
        }

        if (arg_bitset.test(PERCENT)) {
            std::cout << static_cast<u32>(VM::percentage(high_threshold, all, dynamic)) << "\n";
            return 0;
        }

        if (arg_bitset.test(DETECT)) {
            std::cout << VM::detect(high_threshold, all, dynamic) << "\n";
            return 0;
        }

        if (arg_bitset.test(BRAND)) {
            std::string brand = VM::brand(VM::MULTIPLE, high_threshold, all, dynamic);
            
            if (is_anyrun && (brand == brands::NULL_BRAND)) {
                brand = "ANY.RUN";
            }

            std::cout << brand << "\n";

            return 0;
        }

        if (arg_bitset.test(TYPE)) {
            std::string type = VM::type(VM::MULTIPLE, high_threshold, all, dynamic);

            if (is_anyrun && (type == brands::NULL_BRAND)) {
                type = "Sandbox";
            }

            std::cout << type << "\n";

            return 0;
        }

        if (arg_bitset.test(CONCLUSION)) {
            std::string conclusion = VM::conclusion(VM::MULTIPLE, high_threshold, all, dynamic);

            if (is_anyrun) {
                const std::string original = brands::NULL_BRAND;
                const std::string new_brand = "ANY.RUN";

                replace(conclusion, original, new_brand);
            }

            std::cout << conclusion << "\n";
            return 0;
        }
    }

    // at this point, it's assumed that the user's intention is for the general summary to be ran
    general(high_threshold, all, dynamic);
    return 0;
}
```

`src/vmaware.hpp`:

```hpp
/**
 * â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•
 * â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 * â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•
 *  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘ â•šâ•â• â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ•”â–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
 *   â•šâ•â•â•â•  â•šâ•â•     â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•šâ•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â• Experimental post-2.6.0 (February 2026)
 *
 *  C++ VM detection library
 *
 *  - Made by: kernelwernel (https://github.com/kernelwernel)
 *  - Co-developed by: Requiem (https://github.com/NotRequiem)
 *  - Contributed by:
 *      - Alex (https://github.com/greenozon)
 *      - Marek KnÃ¡pek (https://github.com/MarekKnapek)
 *      - Vladyslav Miachkov (https://github.com/fameowner99)
 *      - Alan Tse (https://github.com/alandtse)
 *      - Georgii Gennadev (https://github.com/D00Movenok)
 *      - utoshu (https://github.com/utoshu)
 *      - Jyd (https://github.com/jyd519)
 *      - dmfrpro (https://github.com/dmfrpro)
 *      - Pierre-Ã‰tienne Messier (https://github.com/pemessier)
 *      - Teselka (https://github.com/Teselka)
 *      - Kyun-J (https://github.com/Kyun-J)
 *      - luukjp (https://github.com/luukjp)
 *      - Lorenzo Rizzotti (https://github.com/Dreaming-Codes) 
 *      - virtfunc (https://github.com/virtfunc)
 *  - Repository: https://github.com/kernelwernel/VMAware
 *  - Docs: https://github.com/kernelwernel/VMAware/docs/documentation.md
 *  - Full credits: https://github.com/kernelwernel/VMAware#credits-and-contributors-%EF%B8%8F
 *  - License: MIT
 * 
 *                               MIT License
 *  
 *  Copyright (c) 2026 kernelwernel
 *  
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *  
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *  
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 *
 *
 * ============================== SECTIONS ==================================
 * - enums for publicly accessible techniques  => line 549
 * - struct for internal cpu operations        => line 722
 * - struct for internal memoization           => line 3049
 * - struct for internal utility functions     => line 3231
 * - struct for internal core components       => line 11441
 * - start of VM detection technique list      => line 4286
 * - start of public VM detection functions    => line 11819
 * - start of externally defined variables     => line 12828
 *
 *
 * ============================== EXAMPLE ===================================
 * #include "vmaware.hpp"
 * #include <iostream>
 * 
 * int main() {
 *     if (VM::detect()) {
 *         std::cout << "Virtual machine detected!" << "\n";
 *     } else {
 *         std::cout << "Running on baremetal" << "\n";
 *     }
 * 
 *     std::cout << "VM name: " << VM::brand() << "\n";
 *     std::cout << "VM type: " << VM::type() << "\n";
 *     std::cout << "VM certainty: " << (int)VM::percentage() << "%" << "\n";
 * }
 * 
 *
 * ========================== CODE DOCUMENTATION =============================
 *
 * TL;DR: if you have the patience of an ADHD kid, head over here:
 * https://deepwiki.com/kernelwernel/VMAware
 * 
 *
 * Welcome! This is just a preliminary text to lay the context of how it works, 
 * how it's structured, and to guide anybody who's trying to understand the whole code. 
 * Reading over 12k+ lines of other people's C++ code is obviously not an easy task, 
 * and that's perfectly understandable. We'd struggle as well if we were in your position
 * while not even knowing where to start. So here's a more human-friendly explanation:
 * 
 * 
 * Firstly, the lib is completely static, meaning that there's no need for struct 
 * constructors to be initialized (unless you're using the VM::vmaware struct).
 * The main focus of the lib are the tables:
 *  - the TECHNIQUE table stores all the VM detection technique information in a std::array 
 * 
 *  - the BRAND table stores every VM brand as a std::array as well, but as a scoreboard. 
 *    This means that if a VM detection technique has detected a VM brand, that brand will have an
 *    incremented score. After every technique is run, the brand with the highest score
 *    is chosen as the officially detected brand. 
 * 
 * The techniques are all static functions, which all return a boolean. There are a few 
 * categories of techniques that target vastly different things such as OS queries, CPU
 * values, other hardware values, firmware data, and system files just to name a few. 
 * 
 * 
 * Secondly, there are multiple modules in the lib that are combined to integrate with
 * the functionalities needed:
 *    - core module:
 *        This contains many important components such as the aforementioned tables, 
 *        the standard structure for how VM techniques are organised, functionalities 
 *        to run all the techniques in the technique table, functionalities to run
 *        custom-made techniques by the user, and an argument handler based on the 
 *        argument input by the user.
 *
 *    - cpu module:
 *        As the name suggests, this contains functionalities for the CPU. There are
 *        many techniques that utilise some kind of low-level CPU interaction, so 
 *        this module was added to further standardise it.
 * 
 *    - memo module:
 *        This contains functionalities for memoizing technique results (not to be
 *        confused with "memorization"). More specifically, this allows us to cache 
 *        a technique result in a table where each entry contains a technique and its
 *        result. This allows us to avoid re-running techniques which happens a lot
 *        internally. Some techniques are costlier than others in terms of 
 *        performance, so this is a crucial module that allows us to save a lot of
 *        time. Additionally, it contains other memoization caches for various other
 *        things for convenience. 
 * 
 *    - util module:
 *        This contains many utility functionalities to be used by the techniques.
 *        Examples of functionalities include file I/O, registries, permission 
 *        checks, system commands, HDD sizes, RAM sizes, debugs, process checking, 
 *        OS queries, Hyper-X, and so on. (It should be mentioned that this is 
 *        probably the least enjoyable part of the lib to read, since it's really messy)
 * 
 * 
 * Thirdly, We'll explain in this section how all of these facets of the lib interact with 
 * each other. Let's take an example with VM::detect(), where it returns a boolean true or 
 * false if a VM has been detected or not. The chain of steps it takes goes like this:
 *    1. The function tries to handle the user arguments (if there's 
 *       any), and generates a std::bitset. This bitset has a length of 
 *       every VM detection technique + settings, where each bit 
 *       corresponds to whether this technique will be run or not, 
 *       and which settings were selected. 
 * 
 *    2. After the bitset has been generated, this information is then 
 *       passed to the core module of the lib. It analyses the bitset, 
 *       and runs every VM detection technique that has been selected, 
 *       while ignoring the ones that weren't (by default most of them 
 *       are already selected anyway). The function that does this 
 *       mechanism is core::run_all()
 * 
 *    3. While the core::run_all() function is being run, it checks if 
 *       each technique has already been memoized or not. If it has, 
 *       retrieve the result from the cache and move to the next technique. 
 *       If it hasn't, run the technique and cache the result in the 
 *       cache table. 
 * 
 *    4. After every technique has been executed, this generates a 
 *       uint16_t score. Every technique has a score value between 0 to 
 *       100, and if a VM is detected then this score is accumulated to 
 *       a total. If the total is above 150, that means it's a VM[1]. 
 * 
 * 
 * There are other functions such as VM::brand(), which returns a std::string of the most 
 * likely brand that your system is running on. It has a bit of a different mechanism:
 *    1. Same as step 1 in VM::detect()
 * 
 *    2. Check if the majority of techniques have been run already and stored
 *       in the cache. If not, invoke core::run_all(). The reason why this is
 *       important is because a lot of techniques increment a point for its 
 *       respected brand that was detected. For example, if the VM::QEMU_USB
 *       technique has detected a VM, it'll add a score to the QEMU brand in
 *       the scoreboard. If no technique were run, then there's no way to
 *       populate the scoreboard with any points. After every VM detection 
 *       technique has been invoked/retrieved, the brand scoreboard is now
 *       ready to be analysed.
 * 
 *    3. Create a filter for the scoreboard, where every brand that has a score
 *       of 0 are erased for abstraction purposes. Now the scoreboard is only
 *       populated with relevant brands where they all have at least a single
 *       point. These are the contenders for which brand will be outputted.
 *       Think of it as fetching candidates with potential while discarding
 *       those that don't.
 * 
 *    4. Merge certain brand combinations together. For example, Azure's cloud 
 *       is based on Hyper-V, but Hyper-V may have a higher score due to the 
 *       prevalence of it in a practical setting, which will put Azure to the 
 *       side. In reality, there should be an indication that Azure is involved
 *       since it's a better idea to let the user know that the brand is "Azure 
 *       Hyper-V" instead of just "Hyper-V". So what this step does is "merge" 
 *       the brands together to form a more accurate idea of the brand(s) involved.
 * 
 *    5. After all of this, the scoreboard is sorted in descending order, where
 *       the brands with the highest points are now selected as the official 
 *       output of the VM::brand() function.
 * 
 *    6. The result is then cached in the memo module, so if another function
 *       invokes VM::brand() again, the result is retrieved from the cache 
 *       without needing to run all of the previous steps again.
 *      
 * (NOTE: it's a bit more complicated than this, but that's the gist of how this function works)
 * 
 * Most of the functions provided usually depend on the 2 techniques covered. 
 * And they serve as a functionality base for other components of the lib.
 *      
 *  
 *  [1]: If the user has provided a setting argument called VM::HIGH_THRESHOLD, 
 *       the threshold becomes 300 instead of 150.
 */

#ifndef VMAWARE_HEADER
#define VMAWARE_HEADER

#ifndef __VMAWARE_DEBUG__
    #if defined(_DEBUG)    /* MSVC Debug */       \
    || defined(DEBUG)     /* user or build-system */
        #define __VMAWARE_DEBUG__
    #endif
#endif

#if defined(_WIN32) || defined(_WIN64)
    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    
    #define WINDOWS 1
    #define LINUX 0
    #define APPLE 0
#elif (defined(__linux__))
    #define WINDOWS 0
    #define LINUX 1
    #define APPLE 0
#elif (defined(__APPLE__) || defined(__APPLE_CPP__) || defined(__MACH__) || defined(__DARWIN))
    #define WINDOWS 0
    #define LINUX 0
    #define APPLE 1
#else
    #define WINDOWS 0
    #define LINUX 0
    #define APPLE 0
#endif

#ifdef _MSC_VER
    #define MSVC 1
#endif

#if defined(_MSVC_LANG)
    #define VMA_CPLUSPLUS _MSVC_LANG
#else
    #define VMA_CPLUSPLUS __cplusplus
#endif

#if VMA_CPLUSPLUS >= 202302L
    #define VMA_CPP 23
#elif VMA_CPLUSPLUS >= 202002L
    #define VMA_CPP 20
#elif VMA_CPLUSPLUS >= 201703L
    #define VMA_CPP 17
#elif VMA_CPLUSPLUS >= 201402L
    #define VMA_CPP 14
#elif VMA_CPLUSPLUS >= 201103L
    #define VMA_CPP 11
#elif VMA_CPLUSPLUS >= 199711L
    #define VMA_CPP 98 /* C++98 or C++03 */
#else
    #error "Unsupported C++ standard (pre-C++98 or unknown)."
#endif
    
#if (VMA_CPP < 11 && !WINDOWS)
    #error "VMAware only supports C++11 or above, set your compiler flag to '-std=c++20' for gcc/clang, or '/std:c++20' for MSVC"
#endif
        
#if defined(__x86_64__) || defined(_M_X64)
    #define x86_64 1
#else
    #define x86_64 0
#endif

#if defined(__i386__) || defined(_M_IX86)
    #define x86_32 1
#else
    #define x86_32 0
#endif

#if x86_32 || x86_64
    #define x86 1
#else
    #define x86 0
#endif
    
#if defined(__aarch64__) || defined(_M_ARM64) || defined(__ARM_LINUX_COMPILER__)
    #define ARM64 1
#else
    #define ARM64 0
#endif

#if (defined(__arm__) || defined(_M_ARM)) && !ARM64
    #define ARM32 1
#else
    #define ARM32 0
#endif
    
#if ARM32 || ARM64
    #define ARM 1
#else
    #define ARM 0
#endif

#if (!APPLE && (VMA_CPP >= 20) && (!CLANG || __clang_major__ >= 16))
    #define SOURCE_LOCATION_SUPPORTED 1
#else
    #define SOURCE_LOCATION_SUPPORTED 0
#endif

#if defined(__clang__)
    #define GCC 0
    #define CLANG 1
#elif defined(__GNUC__)
    #define GCC 1
    #define CLANG 0
#else
    #define GCC 0
    #define CLANG 0
#endif

#if !(defined(WINDOWS) || defined(LINUX) || defined(APPLE))
    #warning "Unknown OS detected, tests will be severely limited"
#endif

#if (VMA_CPP >= 23)
    #include <limits>
#endif
#if (VMA_CPP >= 20)
    #include <bit>
    #include <ranges>
    #if (SOURCE_LOCATION_SUPPORTED)
        #include <source_location>
    #endif
#endif
#if (VMA_CPP >= 17)
    #include <filesystem>
    #include <system_error>
#endif
#ifdef __VMAWARE_DEBUG__
    #include <iomanip>
    #include <ios>
    #include <locale>
    #include <codecvt>
#endif

#include <cstdio>
#include <functional>
#include <cstring>
#include <string>
#include <fstream>
#include <thread>
#include <cstdint>
#include <unordered_set>
#include <unordered_map>
#include <array>
#include <algorithm>
#include <iostream>
#include <cassert>
#include <cmath>
#include <sstream>
#include <bitset>
#include <type_traits>
#include <stdexcept>
#include <numeric>
#include <atomic>

#if (WINDOWS)
    #include <windows.h>
    #include <intrin.h>
    #include <winioctl.h>
    #include <winternl.h>
    #include <powerbase.h>
    #include <setupapi.h>
    #include <initguid.h>
    #include <devpkey.h>
    #include <devguid.h>
    #include <winevt.h>

    #pragma comment(lib, "setupapi.lib")
    #pragma comment(lib, "powrprof.lib")
    #pragma comment(lib, "wevtapi.lib")
#elif (LINUX)
    #if (x86)
        #include <cpuid.h>
        #include <x86intrin.h>
        #include <immintrin.h>
    #endif
    #include <sys/stat.h>
    #include <sys/statvfs.h>
    #include <sys/ioctl.h>
    #include <sys/syscall.h>
    #include <sys/sysinfo.h>
    #include <net/if.h> 
    #include <netinet/in.h>
    #include <unistd.h>
    #include <string.h>
    #include <dirent.h>
    #include <memory>
    #include <cctype>
    #include <fcntl.h>
    #include <limits.h>
    #include <csignal>      
    #include <csetjmp>      
    #include <pthread.h>     
    #include <sched.h>      
    #include <cerrno>   
#elif (APPLE)
    #if (x86)
        #include <cpuid.h>
        #include <x86intrin.h>
        #include <immintrin.h>
    #endif
    #include <sys/types.h>
    #include <sys/sysctl.h>
    #include <sys/user.h>
    #include <unistd.h>
    #include <time.h>
    #include <errno.h>
    #include <chrono>
#endif

#ifdef __VMAWARE_DEBUG__
    #define debug(...) VM::util::debug_msg(__VA_ARGS__)
#else
    #define debug(...)
#endif


/**
 * Official aliases for VM brands. This is added to avoid accidental typos
 * which could really mess up the result. Also, no errors/warnings are
 * issued if the string is invalid in case of a typo. For example:
 * scoreboard[VBOX]++;
 * is much better and safer against typos than:
 * scoreboard["VirtualBox"]++;
 * Hopefully this makes sense.
 *
 */
namespace brands {
    static constexpr const char* NULL_BRAND = "Unknown";
    static constexpr const char* VBOX = "VirtualBox";
    static constexpr const char* VMWARE = "VMware";
    static constexpr const char* VMWARE_EXPRESS = "VMware Express";
    static constexpr const char* VMWARE_ESX = "VMware ESX";
    static constexpr const char* VMWARE_GSX = "VMware GSX";
    static constexpr const char* VMWARE_WORKSTATION = "VMware Workstation";
    static constexpr const char* VMWARE_FUSION = "VMware Fusion";
    static constexpr const char* VMWARE_HARD = "VMware (with VmwareHardenedLoader)";
    static constexpr const char* BHYVE = "bhyve";
    static constexpr const char* KVM = "KVM";
    static constexpr const char* QEMU = "QEMU";
    static constexpr const char* QEMU_KVM = "QEMU+KVM";
    static constexpr const char* KVM_HYPERV = "KVM Hyper-V Enlightenment";
    static constexpr const char* QEMU_KVM_HYPERV = "QEMU+KVM Hyper-V Enlightenment";
    static constexpr const char* HYPERV = "Microsoft Hyper-V";
    static constexpr const char* HYPERV_VPC = "Microsoft Virtual PC/Hyper-V";
    static constexpr const char* PARALLELS = "Parallels";
    static constexpr const char* XEN = "Xen HVM";
    static constexpr const char* ACRN = "ACRN";
    static constexpr const char* QNX = "QNX hypervisor";
    static constexpr const char* HYBRID = "Hybrid Analysis";
    static constexpr const char* SANDBOXIE = "Sandboxie";
    static constexpr const char* DOCKER = "Docker";
    static constexpr const char* WINE = "Wine";
    static constexpr const char* VPC = "Virtual PC";
    static constexpr const char* ANUBIS = "Anubis";
    static constexpr const char* JOEBOX = "JoeBox";
    static constexpr const char* THREATEXPERT = "ThreatExpert";
    static constexpr const char* CWSANDBOX = "CWSandbox";
    static constexpr const char* COMODO = "Comodo";
    static constexpr const char* BOCHS = "Bochs";
    static constexpr const char* NVMM = "NetBSD NVMM";
    static constexpr const char* BSD_VMM = "OpenBSD VMM";
    static constexpr const char* INTEL_HAXM = "Intel HAXM";
    static constexpr const char* UNISYS = "Unisys s-Par";
    static constexpr const char* LMHS = "Lockheed Martin LMHS"; // lol
    static constexpr const char* CUCKOO = "Cuckoo";
    static constexpr const char* BLUESTACKS = "BlueStacks";
    static constexpr const char* JAILHOUSE = "Jailhouse";
    static constexpr const char* APPLE_VZ = "Apple VZ";
    static constexpr const char* INTEL_KGT = "Intel KGT (Trusty)";
    static constexpr const char* AZURE_HYPERV = "Microsoft Azure Hyper-V";
    static constexpr const char* SIMPLEVISOR = "SimpleVisor";
    static constexpr const char* HYPERV_ARTIFACT = "Hyper-V artifact (host running Hyper-V)";
    static constexpr const char* UML = "User-mode Linux";
    static constexpr const char* POWERVM = "IBM PowerVM";
    static constexpr const char* GCE = "Google Compute Engine (KVM)";
    static constexpr const char* OPENSTACK = "OpenStack (KVM)";
    static constexpr const char* KUBEVIRT = "KubeVirt (KVM)";
    static constexpr const char* AWS_NITRO = "AWS Nitro System EC2 (KVM-based)";
    static constexpr const char* PODMAN = "Podman";
    static constexpr const char* WSL = "WSL";
    static constexpr const char* OPENVZ = "OpenVZ";
    static constexpr const char* BAREVISOR = "Barevisor";
    static constexpr const char* HYPERPLATFORM = "HyperPlatform";
    static constexpr const char* MINIVISOR = "MiniVisor";
    static constexpr const char* INTEL_TDX = "Intel TDX";
    static constexpr const char* LKVM = "LKVM";
    static constexpr const char* AMD_SEV = "AMD SEV";
    static constexpr const char* AMD_SEV_ES = "AMD SEV-ES";
    static constexpr const char* AMD_SEV_SNP = "AMD SEV-SNP";
    static constexpr const char* NEKO_PROJECT = "Neko Project II";
    static constexpr const char* NOIRVISOR = "NoirVisor";
    static constexpr const char* QIHOO = "Qihoo 360 Sandbox";
    static constexpr const char* NSJAIL = "nsjail";
    static constexpr const char* DBVM = "DBVM";
    static constexpr const char* UTM = "UTM";
    static constexpr const char* COMPAQ = "Compaq FX!32";
    static constexpr const char* INSIGNIA = "Insignia RealPC";
    static constexpr const char* CONNECTIX = "Connectix Virtual PC";
}

#if (VMA_CPP >= 17)
    #define VMAWARE_CONSTEXPR constexpr
#else
    #define VMAWARE_CONSTEXPR
#endif

#if (VMA_CPP >= 14)
    #define VMAWARE_CONSTEXPR_14 constexpr
#else
    #define VMAWARE_CONSTEXPR_14
#endif

struct VM {
private:
    using u8  = std::uint8_t;
    using u16 = std::uint16_t;
    using u32 = std::uint32_t;
    using u64 = std::uint64_t;
    using i8  = std::int8_t;
    using i16 = std::int16_t;
    using i32 = std::int32_t;
    using i64 = std::int64_t;

public:
    enum enum_flags : u8 {
        // Windows
        GPU_CAPABILITIES = 0,
        ACPI_SIGNATURE,
        POWER_CAPABILITIES,
        DISK_SERIAL,
        IVSHMEM,
        DRIVERS,
        DEVICE_HANDLES,
        VIRTUAL_PROCESSORS,
        HYPERVISOR_QUERY,
        AUDIO,
        DISPLAY,
        DLL,
        VMWARE_BACKDOOR,
        WINE,
        VIRTUAL_REGISTRY,
        MUTEX,
        DEVICE_STRING,
        VPC_INVALID,
        VMWARE_STR,
        GAMARUE,
        CUCKOO_DIR,
        CUCKOO_PIPE,
        BOOT_LOGO,
        TRAP,
        UD,
        BLOCKSTEP,
        DBVM,
        KERNEL_OBJECTS,
        NVRAM,
        SMBIOS_INTEGRITY,
        EDID,
        CPU_HEURISTIC,
        CLOCK,
        MSR,

        // Linux and Windows
        SYSTEM_REGISTERS,
        FIRMWARE,
        PCI_DEVICES,
        AZURE,
        
        // Linux
        SMBIOS_VM_BIT,
        KMSG,
        CVENDOR,
        QEMU_FW_CFG,
        SYSTEMD,
        CTYPE,
        DOCKERENV,
        DMIDECODE,
        DMESG,
        HWMON,
        LINUX_USER_HOST,
        VMWARE_IOMEM,
        VMWARE_IOPORTS,
        VMWARE_SCSI,
        VMWARE_DMESG,
        QEMU_VIRTUAL_DMI,
        QEMU_USB,
        HYPERVISOR_DIR,
        UML_CPU,
        VBOX_MODULE,
        SYSINFO_PROC,
        DMI_SCAN,
        PODMAN_FILE,
        WSL_PROC,
        FILE_ACCESS_HISTORY,
        MAC,
        NSJAIL_PID,
        BLUESTACKS_FOLDERS,
        AMD_SEV,
        TEMPERATURE,
        PROCESSES,

        // Linux and MacOS
        THREAD_COUNT,

        // MacOS
        MAC_MEMSIZE,
        MAC_IOKIT,
        MAC_SIP,
        IOREG_GREP,
        HWMODEL,
        MAC_SYS,

        // cross-platform
        HYPERVISOR_BIT,
        VMID,
        THREAD_MISMATCH,
        TIMER,
        CPU_BRAND,
        HYPERVISOR_STR,
        CPUID_SIGNATURE,
        BOCHS_CPU,
        KGT_SIGNATURE,
        // ADD NEW TECHNIQUE ENUM NAME HERE

        // special flags, different to settings
        DEFAULT,
        ALL,
        NULL_ARG, // does nothing, just a placeholder flag mainly for the CLI

        // start of settings technique flags (THE ORDERING IS VERY SPECIFIC HERE AND MIGHT BREAK SOMETHING IF RE-ORDERED)
        HIGH_THRESHOLD,
        DYNAMIC,
        MULTIPLE
    };

private:
    static constexpr u8 enum_size = MULTIPLE; // get enum size through value of last element
    static constexpr u8 settings_count = MULTIPLE - HIGH_THRESHOLD + 1; // get number of settings technique flags
    static constexpr u8 INVALID = 255; // explicit invalid technique macro
    static constexpr u16 base_technique_count = HIGH_THRESHOLD; // original technique count, constant on purpose (can also be used as a base count value if custom techniques are added)
    static constexpr u16 threshold_score = 150; // standard threshold score
    static constexpr u16 high_threshold_score = 300; // new threshold score from 150 to 300 if VM::HIGH_THRESHOLD flag is enabled
    static constexpr bool SHORTCUT = true; // macro for whether VM::core::run_all() should take a shortcut by skipping the rest of the techniques if the threshold score is already met
       
    // intended for loop indexes
    static constexpr u8 enum_begin = 0;
    static constexpr u8 enum_end = enum_size + 1;
    static constexpr u8 technique_begin = enum_begin;
    static constexpr u8 technique_end = DEFAULT;
    static constexpr u8 settings_begin = DEFAULT;
    static constexpr u8 settings_end = enum_end;
    
public:
    // for platform compatibility ranges
    static constexpr u8 WINDOWS_START = VM::GPU_CAPABILITIES;
    static constexpr u8 WINDOWS_END = VM::AZURE;
    static constexpr u8 LINUX_START = VM::SYSTEM_REGISTERS;
    static constexpr u8 LINUX_END = VM::THREAD_COUNT;
    static constexpr u8 MACOS_START = VM::THREAD_COUNT;
    static constexpr u8 MACOS_END = VM::MAC_SYS;
    
    // this is specifically meant for VM::detected_count() to 
    // get the total number of techniques that detected a VM
    static u8 detected_count_num; 
    static u16 technique_count; // get total number of techniques

    static std::vector<enum_flags> disabled_techniques;

private:

#if (WINDOWS)
    using brand_score_t = i32;
#else
    using brand_score_t = u8;
#endif

    // for the flag bitset structure
    using flagset = std::bitset<enum_size + 1>;

public:
    // constructor stuff
    VM() = delete;
    VM(const VM&) = delete;
    VM(VM&&) = delete;

private:
    // macro for bypassing unused parameter/variable warnings
    #define VMAWARE_UNUSED(x) ((void)(x))

    // specifically for util::hyper_x() and memo::hyperv
    enum hyperx_state : u8 {
        HYPERV_UNKNOWN = 0,
        HYPERV_REAL_VM,
        HYPERV_ARTIFACT_VM,
        HYPERV_ENLIGHTENMENT
    };

    // various cpu operation stuff
    struct cpu {
        // cpuid leaf values
        struct leaf {
            static constexpr u32
                func_ext = 0x80000000,
                proc_ext = 0x80000001,
                brand1 = 0x80000002,
                brand2 = 0x80000003,
                brand3 = 0x80000004,
                hypervisor = 0x40000000,
                amd_easter_egg = 0x8fffffff;
        };

        #if (MSVC)
            #define CPUID_COUNT(leaf, subleaf, a_ptr, b_ptr, c_ptr, d_ptr) \
                    do { \
                        int __cpuid_regs[4]; \
                        __cpuidex(__cpuid_regs, static_cast<int>(leaf), static_cast<int>(subleaf)); \
                        *(a_ptr) = static_cast<unsigned int>(__cpuid_regs[0]); \
                        *(b_ptr) = static_cast<unsigned int>(__cpuid_regs[1]); \
                        *(c_ptr) = static_cast<unsigned int>(__cpuid_regs[2]); \
                        *(d_ptr) = static_cast<unsigned int>(__cpuid_regs[3]); \
                    } while (0)
        #else
            #define CPUID_COUNT(leaf, subleaf, a_ptr, b_ptr, c_ptr, d_ptr) \
                    do { \
                        __get_cpuid_count((unsigned)(leaf), (unsigned)(subleaf), (a_ptr), (b_ptr), (c_ptr), (d_ptr)); \
                    } while (0)
        #endif

        // cross-platform wrapper for linux and MSVC cpuid
        static void cpuid
        (
            u32& a, u32& b, u32& c, u32& d,
            const u32 a_leaf,
            const u32 c_leaf = 0xFF  // dummy value if not set manually
        ) {
        #if (x86)
            // may be unmodified for older 32-bit processors, clearing just in case
            a = 0;
            b = 0;
            c = 0;
            d = 0;

            unsigned int aa = 0u, bb = 0u, cc = 0u, dd = 0u;
            CPUID_COUNT(a_leaf, c_leaf, &aa, &bb, &cc, &dd);

            a = static_cast<u32>(aa);
            b = static_cast<u32>(bb);
            c = static_cast<u32>(cc);
            d = static_cast<u32>(dd);
        #endif
            return;
        };

        // same as above but for array type parameters (MSVC specific)
        static void cpuid
        (
            i32 x[4],
            const u32 a_leaf,
            const u32 c_leaf = 0xFF
        ) {
        #if (x86)
            // may be unmodified for older 32-bit processors, clearing just in case
            x[0] = 0;
            x[1] = 0;
            x[2] = 0;
            x[3] = 0;

            unsigned int aa = 0u, bb = 0u, cc = 0u, dd = 0u;
            CPUID_COUNT(a_leaf, c_leaf, &aa, &bb, &cc, &dd);

            x[0] = static_cast<i32>(aa);
            x[1] = static_cast<i32>(bb);
            x[2] = static_cast<i32>(cc);
            x[3] = static_cast<i32>(dd);
        #endif
            return;
        };

        static bool is_leaf_supported(const u32 p_leaf) {
        #if (APPLE) 
            return false;
        #endif
            bool cached;

            if (memo::leaf_cache::fetch(p_leaf, cached)) {
                return cached;
            }

            u32 eax = 0, unused = 0;
            bool supported = false;

            if (p_leaf < 0x40000000) {
                // Standard range: 0x00000000 - 0x3FFFFFFF
                cpu::cpuid(eax, unused, unused, unused, 0x00000000);
                debug("CPUID: max standard leaf = ", eax);
                supported = (p_leaf <= eax);
            }
            else if (p_leaf < 0x80000000) {
                // Hypervisor range: 0x40000000 - 0x7FFFFFFF
                cpu::cpuid(eax, unused, unused, unused, cpu::leaf::hypervisor);
                debug("CPUID: max hypervisor leaf = ", eax);
                supported = (p_leaf <= eax);
            }
            else if (p_leaf < 0xC0000000) {
                // Extended range: 0x80000000 - 0xBFFFFFFF
                cpu::cpuid(eax, unused, unused, unused, cpu::leaf::func_ext);
                debug("CPUID: max extended leaf = ", eax);
                supported = (p_leaf <= eax);
            }
            else {
                supported = false;
            }

            memo::leaf_cache::store(p_leaf, supported);
            return supported;
        }

        [[nodiscard]] static bool is_amd() {
            constexpr u32 amd_ecx = 0x444d4163; // "cAMD"

            u32 unused, ecx = 0;
            cpuid(unused, unused, ecx, unused, 0);

            return (ecx == amd_ecx);
        }

        [[nodiscard]] static bool is_intel() {
            constexpr u32 intel_ecx1 = 0x6c65746e; // "ntel"
            constexpr u32 intel_ecx2 = 0x6c65746f; // "otel", this is because some Intel CPUs have a rare manufacturer string of "GenuineIotel"

            u32 unused, ecx = 0;
            cpuid(unused, unused, ecx, unused, 0);

            return ((ecx == intel_ecx1) || (ecx == intel_ecx2));
        }

        [[nodiscard]] static const char* get_brand() {
            if (memo::cpu_brand::is_cached()) {
                return memo::cpu_brand::fetch();
            }

        #if (!x86 || APPLE)
            return "Unknown";
        #else
            if (!cpu::is_leaf_supported(cpu::leaf::brand3)) {
                return "Unknown";
            }

            alignas(16) char buffer[49]{};
            u32* regs = reinterpret_cast<u32*>(buffer);

            // unrolled calls to fill buffer directly
            cpu::cpuid(regs[0], regs[1], regs[2], regs[3], cpu::leaf::brand1);
            cpu::cpuid(regs[4], regs[5], regs[6], regs[7], cpu::leaf::brand2);
            cpu::cpuid(regs[8], regs[9], regs[10], regs[11], cpu::leaf::brand3);

            buffer[48] = '\0';

            // do NOT touch trailing spaces for the AMD_THREAD_MISMATCH technique

            // left-trim only to handle stupid whitespaces before the brand string in ARM CPUs (Virtual CPUs)
            const char* start_ptr = buffer;
            while (*start_ptr && std::isspace(static_cast<u8>(*start_ptr))) {
                ++start_ptr;
            }

            memo::cpu_brand::store(start_ptr);
            debug("CPU: ", start_ptr);

            // Return pointer to the static cache, not the local stack buffer
            return memo::cpu_brand::fetch();
        #endif
        }


        [[nodiscard]] static std::string cpu_manufacturer(const u32 leaf_id) {
            alignas(16) char buffer[13]{};
            u32* regs = reinterpret_cast<u32*>(buffer);

            u32 eax, ebx, ecx, edx;
            cpu::cpuid(eax, ebx, ecx, edx, leaf_id);

            if (ebx == 0 && ecx == 0 && edx == 0) {
                return "";
            }

            if (leaf_id >= 0x40000000) {
                regs[0] = ebx;
                regs[1] = ecx;
                regs[2] = edx;
            }
            else {
                regs[0] = ebx;
                regs[1] = edx;
                regs[2] = ecx;
            }

            buffer[12] = '\0';
            return std::string(buffer);
        }

        struct stepping_struct {
            u8 model;
            u8 family;
            u8 extmodel;
        };

        static stepping_struct fetch_steppings() {
            struct stepping_struct steps {};

            u32 unused, eax = 0;
            cpu::cpuid(eax, unused, unused, unused, 1);
            VMAWARE_UNUSED(unused);

            steps.model = ((eax >> 4) & 0b1111);
            steps.family = ((eax >> 8) & 0b1111);
            steps.extmodel = ((eax >> 16) & 0b1111);

            return steps;
        }

        // check if the CPU is an intel celeron
        static bool is_celeron(const stepping_struct steps) {
            if (!cpu::is_intel()) {
                return false;
            }

            constexpr u8 celeron_model = 0xA;
            constexpr u8 celeron_family = 0x6;
            constexpr u8 celeron_extmodel = 0x2;

            return (
                steps.model == celeron_model &&
                steps.family == celeron_family &&
                steps.extmodel == celeron_extmodel
            );
        }

        static bool is_amd_A_series() {
            if (!cpu::is_amd()) {
                return false;
            }

            const model_struct model = get_model();
            const char* s = model.string.c_str();

            for (; *s; ++s) {
                if ((*s | 0x20) != 'a') continue;

                // check for "MD A" (case-insensitive match for "AMD A")
                // We need 5 specific characters following the 'A': 'm', 'd', ' ', 'a', and a digit
                if (!s[1] || !s[2] || !s[3] || !s[4] || !s[5]) break;

                if ((s[1] | 0x20) == 'm' &&
                    (s[2] | 0x20) == 'd' &&
                    s[3] == ' ' &&
                    (s[4] | 0x20) == 'a') {

                    // we found "AMD A" so now verify pattern [0-9]+-[0-9]+
                    const char* num = s + 5;

                    // must have at least one digit immediately after "AMD A"
                    if (*num < '0' || *num > '9') continue;
                    do { num++; } while (*num >= '0' && *num <= '9');
                    if (*num != '-') continue;
                    num++;

                    // Must have at least one digit after the hyphen
                    if (*num >= '0' && *num <= '9') {
                        return true;
                    }
                }
            }

            return false;
        }

        struct model_struct {
            bool found;
            bool is_xeon;
            bool is_i_series;
            bool is_ryzen;
            std::string string;
        };

        [[nodiscard]] static model_struct get_model() {
            const std::string brand = get_brand();

            model_struct result { false, false, false, false, {} };

            if (cpu::is_intel()) {
                // Ultra
                if (brand.find("Ultra") != std::string::npos &&
                    brand.find_first_of("0123456789") != std::string::npos) {
                    result.found = true;
                    result.string = brand;
                    return result;
                }

                // i-series
                if (brand.find("i") != std::string::npos && brand.find("-") != std::string::npos &&
                    brand.find_first_of("0123456789") != std::string::npos) {
                    result.found = true;
                    result.is_i_series = true;
                    result.string = brand;
                    return result;
                }

                // Xeon
                if (brand.find_first_of("DEW") != std::string::npos && brand.find("-") != std::string::npos &&
                    brand.find_first_of("0123456789") != std::string::npos) {
                    result.found = true;
                    result.is_xeon = true;
                    result.string = brand;
                    return result;
                }
            }
            else if (cpu::is_amd()) {
                if (brand.find("AMD Ryzen") != std::string::npos) {
                    result.found = true;
                    result.is_ryzen = true;
                    result.string = brand;
                    return result;
                }
            }

            return result;
        }

        [[nodiscard]] static bool vmid_template(const u32 p_leaf) {
            const std::string brand_str = cpu_manufacturer(p_leaf);

            if (brand_str == "Microsoft Hv") {
                if (util::hyper_x() == HYPERV_ARTIFACT_VM) {
                    return false;
                }
                return core::add(brands::HYPERV, brands::VPC);
            }

            if (util::find(brand_str, "KVM")) {
                return core::add(brands::KVM);
            }

            static const std::unordered_map<std::string, const char*> brand_map = {
                {"VMwareVMware", brands::VMWARE},
                {"VBoxVBoxVBox", brands::VBOX},
                {"TCGTCGTCGTCG", brands::QEMU},
                {"XenVMMXenVMM", brands::XEN},
                {"Linux KVM Hv", brands::KVM_HYPERV},
                {" prl hyperv ", brands::PARALLELS},
                {" lrpepyh  vr", brands::PARALLELS},
                {"bhyve bhyve ", brands::BHYVE},
                {"BHyVE BHyVE ", brands::BHYVE},
                {"ACRNACRNACRN", brands::ACRN},
                {" QNXQVMBSQG ", brands::QNX},
                {"___ NVMM ___", brands::NVMM},
                {"OpenBSDVMM58", brands::BSD_VMM},
                {"HAXMHAXMHAXM", brands::INTEL_HAXM},
                {"UnisysSpar64", brands::UNISYS},
                {"SRESRESRESRE", brands::LMHS},
                {"Jailhouse\0\0\0", brands::JAILHOUSE},
                {"EVMMEVMMEVMM", brands::INTEL_KGT},
                {"Barevisor!\0\0", brands::BAREVISOR},
                {"MiniVisor\0\0\0", brands::MINIVISOR},
                {"IntelTDX    ", brands::INTEL_TDX},
                {"LKVMLKVMLKVM", brands::LKVM},
                {"Neko Project", brands::NEKO_PROJECT},
                {"NoirVisor ZT", brands::NOIRVISOR},
                {"Compaq FX!32", brands::COMPAQ},
                {"Insignia 586", brands::INSIGNIA},
                {"ConnectixCPU", brands::CONNECTIX}
            };

            const auto it = brand_map.find(brand_str);
            if (it != brand_map.end()) {
                return core::add(it->second);
            }

            if (util::find(brand_str, "QXNQSBMV")) {
                return core::add(brands::QNX);
            }

            if (util::find(brand_str, "Apple VZ")) {
                return core::add(brands::APPLE_VZ);
            }

            if (util::find(brand_str, "PpyH")) {
                return core::add(brands::HYPERPLATFORM);
            }

            return false;
        }
  
        // to search in our databases, we want to precompute hashes at compile time for C++11 and later
        // so we need to match the hardware _mm_crc32_u8, it is based on CRC32-C (Castagnoli) polynomial
        struct constexpr_hash {
            // it does 8 rounds of CRC32-C bit reflection recursively
            static constexpr u32 crc32_bits(u32 crc, int bits) {
                return (bits == 0) ? crc :
                    crc32_bits((crc >> 1) ^ ((crc & 1) ? 0x82F63B78u : 0), bits - 1);
            }

            // over string
            static constexpr u32 crc32_str(const char* s, u32 crc) {
                return (*s == '\0') ? crc :
                    crc32_str(s + 1, crc32_bits(crc ^ static_cast<u8>(*s), 8));
            }

            static constexpr u32 get(const char* s) {
                return crc32_str(s, 0);
            }
        };

        // this forces the compiler to calculate the hash when initializing the array while staying C++11 compatible
        struct cpu_entry {
            u32 hash;
            u32 threads;
            double base_clock;

            constexpr cpu_entry(const char* m, u32 t, double c)
                : hash(constexpr_hash::get(m)), threads(t), base_clock(c) {
            }
        };

        struct cpu_cache {
            u32 expected_threads;
            u32 base_clock_mhz;
            bool found;
            const char* debug_tag;
            std::string model_name;
        };

        enum class cpu_type {
            INTEL_I,
            INTEL_XEON,
            INTEL_ULTRA,
            AMD
        };

        static const cpu_cache& analyze_cpu() {
            static cpu_cache result = { 0, 0, false, "", "" };
            static bool initialized = false;

            if (initialized) return result;

            // to save a few cycles
            struct hasher {
                static u32 crc32_sw(u32 crc, char data) {
                    crc ^= static_cast<u8>(data);
                    for (int i = 0; i < 8; ++i)
                        crc = (crc >> 1) ^ ((crc & 1) ? 0x82F63B78u : 0);
                    return crc;
                }

                using hashfc = u32(*)(u32, char);

                static hashfc get() {
                    i32 regs[4];
                    cpu::cpuid(regs, 1);
                    const bool has_sse42 = (regs[2] & (1 << 20)) != 0;
                    return has_sse42 ? util::crc32 : crc32_sw;
                }
            };

            const cpu_entry* db = nullptr;
            size_t db_size = 0;
            size_t max_model_len = 32;
            cpu_type type;

            // Detection logic
            if (is_amd()) {
                type = cpu_type::AMD;
                result.model_name = get_brand();
                result.debug_tag = "AMD_THREAD_MISMATCH";
                get_amd_ryzen_db(db, db_size);
            }
            else if (is_intel()) {
                const model_struct model = get_model();
                if (!model.found) { initialized = true; return result; }

                result.model_name = model.string;

                if (result.model_name.find("Ultra") != std::string::npos) {
                    type = cpu_type::INTEL_ULTRA;
                    result.debug_tag = "ULTRA_THREAD_MISMATCH";
                    get_intel_ultra_db(db, db_size);
                }
                else if (model.is_i_series) {
                    type = cpu_type::INTEL_I;
                    result.debug_tag = "INTEL_THREAD_MISMATCH";
                    get_intel_core_db(db, db_size);
                }
                else if (model.is_xeon) {
                    type = cpu_type::INTEL_XEON;
                    result.debug_tag = "XEON_THREAD_MISMATCH";
                    get_intel_xeon_db(db, db_size);
                }
                else { 
                    initialized = true; 
                    return result; 
                }
                result.model_name = model.string;
            }
            else { 
                initialized = true; 
                return result; 
            }

            if (result.model_name.empty() || db == nullptr) { 
                initialized = true; 
                return result; 
            }

            const char* str = result.model_name.c_str();
            size_t best_len = 0;
            u32 z_series_threads = 0;
            double found_clock = 0.0;

            const auto hash_func = hasher::get();

            for (size_t i = 0; str[i] != '\0'; ) {
                char c = str[i];
                if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))) {
                    i++;
                    continue;
                }

                u32 current_hash = 0;
                size_t current_len = 0;
                size_t j = i;

                while (true) {
                    char k = str[j];
                    const bool is_valid = (k >= '0' && k <= '9') ||
                        (k >= 'A' && k <= 'Z') ||
                        (k >= 'a' && k <= 'z') ||
                        (k == '-');
                    if (!is_valid) break;

                    if (current_len >= max_model_len) {
                        while (str[j] != '\0' && str[j] != ' ') j++;
                        break;
                    }

                    // convert to lowercase on-the-fly to match compile-time keys
                    if (type == cpu_type::AMD && (k >= 'A' && k <= 'Z')) k += 32;

                    current_hash = hash_func(current_hash, k);
                    current_len++;
                    j++;

                    const char next = str[j];
                    const bool next_is_alnum = (next >= '0' && next <= '9') ||
                        (next >= 'A' && next <= 'Z') ||
                        (next >= 'a' && next <= 'z');

                    if (!next_is_alnum) {
                        // Check specific Z1 Extreme token
                        if (type == cpu_type::AMD && current_hash == 0x3D09D5B4) { 
                            z_series_threads = 16; 
                        }

                        for (size_t idx = 0; idx < db_size; ++idx) {
                            if (db[idx].hash == current_hash) {
                                if (current_len > best_len) {
                                    best_len = current_len;
                                    result.expected_threads = db[idx].threads;
                                    found_clock = db[idx].base_clock;
                                    result.found = true;
                                }
                            }
                        }
                    }
                }
                i = j;
            }

            // Z1 Extreme fix
            if (type == cpu_type::AMD && z_series_threads != 0 && result.expected_threads == 12) {
                result.expected_threads = z_series_threads;
            }

            if (result.found) {
                result.base_clock_mhz = static_cast<u32>(found_clock * 1000.0);
            }

            initialized = true;
            return result;
        }

        // In C++11, you can define static const arrays inside a function
        // without specifying the size explicitly. The compiler deduces it
        // The data is stored in read-only data just like a global constexpr array
        // We can't also put it outside the VM struct because the compiler complains about "too many initializers"

        // we cannot use constexpr on a static array if we do not want to provide the size explicitly inside the class
        // we cant also use another source file or use the C++ 17 inline variable feature because we want to stay C++11 compatible
		// using other structs or std::array would not solve anything, so the ONLY solution to this c++ 11 limitation is to define the function that returns the array
		// just like we had before (intel_thread_mismatch, xeon_thread_mismatch, amd_thread_mismatch) but now inside the cpu struct
        inline static void get_intel_core_db(const cpu_entry*& out_ptr, size_t& out_size) {
            static const cpu_entry db[] = {
                // i3 series
                { "i3-1000G1", 4, 1.10 },
                { "i3-1000G4", 4, 1.10 },
                { "i3-1000NG4", 4, 1.10 },
                { "i3-1005G1", 4, 1.20 },
                { "i3-10100", 8, 3.60 },
                { "i3-10100E", 8, 3.20 },
                { "i3-10100F", 8, 3.60 },
                { "i3-10100T", 8, 3.00 },
                { "i3-10100TE", 8, 2.30 },
                { "i3-10100Y", 4, 1.30 },
                { "i3-10105", 8, 3.70 },
                { "i3-10105F", 8, 3.70 },
                { "i3-10105T", 8, 3.00 },
                { "i3-10110U", 4, 2.10 },
                { "i3-10110Y", 4, 1.00 },
                { "i3-10300", 8, 3.70 },
                { "i3-10300T", 8, 3.00 },
                { "i3-10305", 8, 3.80 },
                { "i3-10305T", 8, 3.00 },
                { "i3-10320", 8, 3.80 },
                { "i3-10325", 8, 3.90 },
                { "i3-11100B", 8, 3.60 },
                { "i3-11100HE", 8, 2.40 },
                { "i3-1110G4", 4, 2.50 },
                { "i3-1115G4E", 4, 3.00 },
                { "i3-1115GRE", 4, 3.00 },
                { "i3-1120G4", 8, 1.10 },
                { "i3-12100", 8, 3.30 },
                { "i3-12100F", 8, 3.30 },
                { "i3-12100T", 8, 2.20 },
                { "i3-1210U", 8, 1.00 },
                { "i3-1215U", 8, 1.20 },
                { "i3-1215UE", 8, 1.20 },
                { "i3-1215UL", 8, 1.20 },
                { "i3-12300", 8, 3.50 },
                { "i3-12300T", 8, 2.30 },
                { "i3-13100", 8, 3.40 },
                { "i3-13100F", 8, 3.40 },
                { "i3-13100T", 8, 2.50 },
                { "i3-1315U", 8, 1.20 },
                { "i3-1315UE", 8, 1.20 },
                { "i3-14100", 8, 3.50 },
                { "i3-14100F", 8, 3.50 },
                { "i3-14100T", 8, 2.70 },
                { "i3-2100", 4, 3.10 },
                { "i3-2100T", 4, 2.50 },
                { "i3-2102", 4, 3.10 },
                { "i3-2105", 4, 3.10 },
                { "i3-2120", 4, 3.30 },
                { "i3-2120T", 4, 2.60 },
                { "i3-2125", 4, 3.30 },
                { "i3-2130", 4, 3.40 },
                { "i3-2308M", 4, 2.10 },
                { "i3-2310E", 4, 2.10 },
                { "i3-2310M", 4, 2.10 },
                { "i3-2312M", 4, 2.10 },
                { "i3-2328M", 4, 2.20 },
                { "i3-2330E", 4, 2.20 },
                { "i3-2330M", 4, 2.20 },
                { "i3-2332M", 4, 2.20 },
                { "i3-2340UE", 4, 1.30 },
                { "i3-2348M", 4, 2.30 },
                { "i3-2350LM", 4, 1.30 },
                { "i3-2350M", 4, 2.30 },
                { "i3-2355M", 4, 1.40 },
                { "i3-2357M", 4, 1.30 },
                { "i3-2365M", 4, 1.40 },
                { "i3-2367M", 4, 1.40 },
                { "i3-2370LM", 4, 1.40 },
                { "i3-2370M", 4, 2.40 },
                { "i3-2375M", 4, 1.50 },
                { "i3-2377M", 4, 1.50 },
                { "i3-2390M", 4, 2.40 },
                { "i3-2393M", 4, 2.50 },
                { "i3-2394M", 4, 2.60 },
                { "i3-2395M", 4, 2.70 },
                { "i3-2397M", 4, 2.80 },
                { "i3-3110M", 4, 2.40 },
                { "i3-3115C", 4, 2.50 },
                { "i3-3120M", 4, 2.50 },
                { "i3-3120ME", 4, 2.40 },
                { "i3-3130M", 4, 2.60 },
                { "i3-3210", 4, 3.20 },
                { "i3-3217U", 4, 1.80 },
                { "i3-3217UE", 4, 1.60 },
                { "i3-3220", 4, 3.30 },
                { "i3-3220T", 4, 2.80 },
                { "i3-3225", 4, 3.30 },
                { "i3-3227U", 4, 1.90 },
                { "i3-3229Y", 4, 1.40 },
                { "i3-3240", 4, 3.40 },
                { "i3-3240T", 4, 2.90 },
                { "i3-3245", 4, 3.40 },
                { "i3-3250", 4, 3.50 },
                { "i3-3250T", 4, 3.00 },
                { "i3-330E", 4, 2.13 },
                { "i3-330M", 4, 2.13 },
                { "i3-330UM", 4, 1.20 },
                { "i3-350M", 4, 2.26 },
                { "i3-370M", 4, 2.40 },
                { "i3-380M", 4, 2.53 },
                { "i3-380UM", 4, 1.33 },
                { "i3-390M", 4, 2.66 },
                { "i3-4000M", 4, 2.40 },
                { "i3-4005U", 4, 1.70 },
                { "i3-4010M", 4, 1.70 },
                { "i3-4010U", 4, 1.70 },
                { "i3-4010Y", 4, 1.30 },
                { "i3-4012Y", 4, 1.50 },
                { "i3-4020Y", 4, 1.50 },
                { "i3-4025U", 4, 1.90 },
                { "i3-4030U", 4, 1.90 },
                { "i3-4030Y", 4, 1.60 },
                { "i3-4100E", 4, 2.40 },
                { "i3-4100M", 4, 2.50 },
                { "i3-4100U", 4, 1.80 },
                { "i3-4102E", 4, 1.60 },
                { "i3-4110E", 4, 2.60 },
                { "i3-4110M", 4, 2.60 },
                { "i3-4112E", 4, 1.80 },
                { "i3-4120U", 4, 2.00 },
                { "i3-4130", 4, 3.40 },
                { "i3-4130T", 4, 2.90 },
                { "i3-4150", 4, 3.50 },
                { "i3-4150T", 4, 3.00 },
                { "i3-4158U", 4, 2.00 },
                { "i3-4160", 4, 3.60 },
                { "i3-4160T", 4, 3.10 },
                { "i3-4170", 4, 3.70 },
                { "i3-4170T", 4, 3.20 },
                { "i3-4330", 4, 3.50 },
                { "i3-4330T", 4, 3.00 },
                { "i3-4330TE", 4, 2.40 },
                { "i3-4340", 4, 3.60 },
                { "i3-4340TE", 4, 2.60 },
                { "i3-4350", 4, 3.60 },
                { "i3-4350T", 4, 3.10 },
                { "i3-4360", 4, 3.70 },
                { "i3-4360T", 4, 3.20 },
                { "i3-4370", 4, 3.80 },
                { "i3-4370T", 4, 3.30 },
                { "i3-5005U", 4, 2.00 },
                { "i3-5010U", 4, 2.10 },
                { "i3-5015U", 4, 2.10 },
                { "i3-5020U", 4, 2.20 },
                { "i3-5157U", 4, 2.50 },
                { "i3-530", 4, 2.93 },
                { "i3-540", 4, 3.06 },
                { "i3-550", 4, 3.20 },
                { "i3-560", 4, 3.33 },
                { "i3-6006U", 4, 2.00 },
                { "i3-6098P", 4, 3.60 },
                { "i3-6100", 4, 3.70 },
                { "i3-6100E", 4, 2.70 },
                { "i3-6100H", 4, 2.70 },
                { "i3-6100T", 4, 3.20 },
                { "i3-6100TE", 4, 2.70 },
                { "i3-6100U", 4, 2.30 },
                { "i3-6102E", 4, 1.90 },
                { "i3-6120T", 4, 3.20 },
                { "i3-6157U", 4, 2.40 },
                { "i3-6167U", 4, 2.70 },
                { "i3-6300", 4, 3.80 },
                { "i3-6300T", 4, 3.30 },
                { "i3-6320", 4, 3.90 },
                { "i3-6320T", 4, 3.40 },
                { "i3-7007U", 4, 2.10 },
                { "i3-7020U", 4, 2.30 },
                { "i3-7100", 4, 3.90 },
                { "i3-7100E", 4, 2.90 },
                { "i3-7100H", 4, 3.00 },
                { "i3-7100T", 4, 3.40 },
                { "i3-7100U", 4, 2.40 },
                { "i3-7101E", 4, 3.90 },
                { "i3-7101TE", 4, 3.40 },
                { "i3-7102E", 4, 2.10 },
                { "i3-7110U", 4, 2.60 },
                { "i3-7120", 4, 4.00 },
                { "i3-7120T", 4, 3.50 },
                { "i3-7130U", 4, 2.70 },
                { "i3-7167U", 4, 2.80 },
                { "i3-7300", 4, 4.00 },
                { "i3-7300T", 4, 3.50 },
                { "i3-7310T", 4, 3.40 },
                { "i3-7310U", 4, 2.40 },
                { "i3-7320", 4, 4.10 },
                { "i3-7320T", 4, 3.50 },
                { "i3-7340", 4, 4.20 },
                { "i3-7350K", 4, 4.20 },
                { "i3-8000", 4, 3.60 },
                { "i3-8000T", 4, 3.10 },
                { "i3-8020", 4, 3.60 },
                { "i3-8020T", 4, 3.10 },
                { "i3-8100", 4, 3.60 },
                { "i3-8100B", 4, 3.60 },
                { "i3-8100F", 4, 3.60 },
                { "i3-8100H", 4, 3.00 },
                { "i3-8100T", 4, 3.10 },
                { "i3-8109U", 4, 3.00 },
                { "i3-8120", 4, 3.60 },
                { "i3-8120T", 4, 3.10 },
                { "i3-8121U", 4, 2.20 },
                { "i3-8130U", 4, 2.20 },
                { "i3-8140U", 4, 2.10 },
                { "i3-8145U", 4, 2.10 },
                { "i3-8145UE", 4, 2.20 },
                { "i3-8300", 4, 3.70 },
                { "i3-8300T", 4, 3.20 },
                { "i3-8320", 4, 3.70 },
                { "i3-8320T", 4, 3.20 },
                { "i3-8350K", 4, 4.00 },
                { "i3-9100", 4, 3.60 },
                { "i3-9100E", 4, 3.10 },
                { "i3-9100F", 4, 3.60 },
                { "i3-9100HL", 4, 1.60 },
                { "i3-9100T", 4, 3.10 },
                { "i3-9100TE", 4, 2.20 },
                { "i3-9300", 4, 3.70 },
                { "i3-9300T", 4, 3.20 },
                { "i3-9320", 4, 3.70 },
                { "i3-9350K", 4, 4.00 },
                { "i3-9350KF", 4, 4.00 },
                { "i3-N300", 8, 0.80 },
                { "i3-N305", 8, 1.80 },

                // i5 series
                { "i5-10200H", 8, 2.40 },
                { "i5-10210U", 8, 1.60 },
                { "i5-10210Y", 8, 1.00 },
                { "i5-10300H", 8, 2.50 },
                { "i5-1030G4", 8, 0.70 },
                { "i5-1030G7", 8, 0.80 },
                { "i5-1030NG7", 8, 1.10 },
                { "i5-10310U", 8, 1.70 },
                { "i5-10310Y", 8, 1.10 },
                { "i5-1035G1", 8, 1.00 },
                { "i5-1035G4", 8, 1.10 },
                { "i5-1035G7", 8, 1.20 },
                { "i5-1038NG7", 8, 2.00 },
                { "i5-10400", 12, 2.90 },
                { "i5-10400F", 12, 2.90 },
                { "i5-10400H", 8, 2.60 },
                { "i5-10400T", 12, 2.00 },
                { "i5-10500", 12, 3.10 },
                { "i5-10500E", 12, 3.10 },
                { "i5-10500H", 12, 2.50 },
                { "i5-10500T", 12, 2.30 },
                { "i5-10500TE", 12, 2.30 },
                { "i5-10505", 12, 3.20 },
                { "i5-10600", 12, 3.30 },
                { "i5-10600K", 12, 4.10 },
                { "i5-10600KF", 12, 4.10 },
                { "i5-10600T", 12, 2.40 },
                { "i5-1115G4", 4, 3.00 },
                { "i5-1125G4", 8, 2.00 },
                { "i5-11260H", 12, 2.60 },
                { "i5-11300H", 8, 3.10 },
                { "i5-1130G7", 8, 1.10 },
                { "i5-11320H", 8, 3.20 },
                { "i5-1135G7", 8, 2.40 },
                { "i5-11400", 12, 2.60 },
                { "i5-11400F", 12, 2.60 },
                { "i5-11400H", 12, 2.70 },
                { "i5-11400T", 12, 1.30 },
                { "i5-1140G7", 8, 1.10 },
                { "i5-1145G7", 8, 2.60 },
                { "i5-1145G7E", 8, 1.50 },
                { "i5-1145GRE", 8, 1.50 },
                { "i5-11500", 12, 2.70 },
                { "i5-11500B", 12, 3.30 },
                { "i5-11500H", 12, 2.90 },
                { "i5-11500HE", 12, 2.60 },
                { "i5-11500T", 12, 1.50 },
                { "i5-1155G7", 8, 2.50 },
                { "i5-11600", 12, 2.80 },
                { "i5-11600K", 12, 3.90 },
                { "i5-11600KF", 12, 3.90 },
                { "i5-11600T", 12, 1.70 },
                { "i5-1230U", 12, 1.00 },
                { "i5-1235U", 12, 1.30 },
                { "i5-12400", 12, 2.50 },
                { "i5-12400F", 12, 2.50 },
                { "i5-12400T", 12, 1.80 },
                { "i5-1240P", 16, 1.70 },
                { "i5-1240U", 12, 1.10 },
                { "i5-1245U", 12, 1.60 },
                { "i5-12490F", 12, 3.00 },
                { "i5-12500", 12, 3.00 },
                { "i5-12500H", 16, 2.50 },
                { "i5-12500HL", 16, 2.50 },
                { "i5-12500T", 12, 2.00 },
                { "i5-1250P", 16, 1.70 },
                { "i5-1250PE", 16, 1.70 },
                { "i5-12600", 12, 3.30 },
                { "i5-12600H", 16, 2.70 },
                { "i5-12600HE", 16, 2.50 },
                { "i5-12600HL", 16, 2.70 },
                { "i5-12600HX", 16, 2.50 },
                { "i5-12600K", 16, 3.70 },
                { "i5-12600KF", 16, 3.70 },
                { "i5-12600T", 12, 2.10 },
                { "i5-13400", 16, 2.50 },
                { "i5-13400F", 16, 2.50 },
                { "i5-13400T", 16, 1.30 },
                { "i5-1340P", 16, 1.90 },
                { "i5-1340PE", 16, 1.80 },
                { "i5-13490F", 16, 2.50 },
                { "i5-13500", 20, 2.50 },
                { "i5-13500H", 16, 2.60 },
                { "i5-13500T", 20, 1.60 },
                { "i5-13505H", 16, 2.60 },
                { "i5-1350P", 16, 1.90 },
                { "i5-1350PE", 16, 1.80 },
                { "i5-13600", 20, 2.70 },
                { "i5-13600H", 16, 2.80 },
                { "i5-13600HE", 16, 2.70 },
                { "i5-13600K", 20, 3.50 },
                { "i5-13600KF", 20, 3.50 },
                { "i5-13600T", 20, 1.80 },
                { "i5-2300", 4, 2.80 },
                { "i5-2310", 4, 2.90 },
                { "i5-2320", 4, 3.00 },
                { "i5-2380P", 4, 3.10 },
                { "i5-2390T", 4, 2.70 },
                { "i5-2400", 4, 3.10 },
                { "i5-2400S", 4, 2.50 },
                { "i5-2405S", 4, 2.50 },
                { "i5-2410M", 4, 2.30 },
                { "i5-2415M", 4, 2.30 },
                { "i5-2430M", 4, 2.40 },
                { "i5-2435M", 4, 2.40 },
                { "i5-2450M", 4, 2.50 },
                { "i5-2450P", 4, 3.20 },
                { "i5-2467M", 4, 1.60 },
                { "i5-2475M", 4, 2.40 },
                { "i5-2477M", 4, 1.80 },
                { "i5-2487M", 4, 1.90 },
                { "i5-2490M", 4, 2.50 },
                { "i5-2497M", 4, 2.30 },
                { "i5-2500", 4, 3.30 },
                { "i5-2500K", 4, 3.30 },
                { "i5-2500S", 4, 2.70 },
                { "i5-2500T", 4, 2.30 },
                { "i5-2510E", 4, 2.50 },
                { "i5-2515E", 4, 2.50 },
                { "i5-2520M", 4, 2.50 },
                { "i5-2537M", 4, 1.40 },
                { "i5-2540LM", 4, 2.60 },
                { "i5-2540M", 4, 2.60 },
                { "i5-2547M", 4, 1.60 },
                { "i5-2550K", 4, 3.40 },
                { "i5-2557M", 4, 1.70 },
                { "i5-2560LM", 4, 2.70 },
                { "i5-2560M", 4, 2.70 },
                { "i5-2580M", 4, 2.90 },
                { "i5-3210M", 4, 2.50 },
                { "i5-3230M", 4, 2.60 },
                { "i5-3317U", 4, 1.70 },
                { "i5-3320M", 4, 2.60 },
                { "i5-3330", 4, 3.00 },
                { "i5-3330S", 4, 2.70 },
                { "i5-3335S", 4, 2.70 },
                { "i5-3337U", 4, 1.80 },
                { "i5-3339Y", 4, 1.50 },
                { "i5-3340", 4, 3.10 },
                { "i5-3340M", 4, 2.70 },
                { "i5-3340S", 4, 2.80 },
                { "i5-3350P", 4, 3.10 },
                { "i5-3360M", 4, 2.80 },
                { "i5-3380M", 4, 2.90 },
                { "i5-3427U", 4, 1.80 },
                { "i5-3437U", 4, 1.90 },
                { "i5-3439Y", 4, 1.50 },
                { "i5-3450", 4, 3.10 },
                { "i5-3450S", 4, 2.80 },
                { "i5-3470", 4, 3.20 },
                { "i5-3470S", 4, 2.90 },
                { "i5-3470T", 4, 2.90 },
                { "i5-3475S", 4, 2.90 },
                { "i5-3550", 4, 3.30 },
                { "i5-3550S", 4, 3.00 },
                { "i5-3570", 4, 3.40 },
                { "i5-3570K", 4, 3.40 },
                { "i5-3570S", 4, 3.10 },
                { "i5-3570T", 4, 2.30 },
                { "i5-3610ME", 4, 2.70 },
                { "i5-4200H", 4, 2.80 },
                { "i5-4200M", 4, 2.50 },
                { "i5-4200U", 4, 1.60 },
                { "i5-4200Y", 4, 1.40 },
                { "i5-4202Y", 4, 1.60 },
                { "i5-4210H", 4, 2.90 },
                { "i5-4210M", 4, 2.60 },
                { "i5-4210U", 4, 1.70 },
                { "i5-4210Y", 4, 1.50 },
                { "i5-4220Y", 4, 1.60 },
                { "i5-4250U", 4, 1.30 },
                { "i5-4258U", 4, 2.40 },
                { "i5-4260U", 4, 1.40 },
                { "i5-4278U", 4, 2.60 },
                { "i5-4288U", 4, 2.60 },
                { "i5-4300M", 4, 2.60 },
                { "i5-4300U", 4, 1.90 },
                { "i5-4300Y", 4, 1.60 },
                { "i5-4302Y", 4, 1.60 },
                { "i5-4308U", 4, 2.80 },
                { "i5-430M", 4, 2.26 },
                { "i5-430UM", 4, 1.20 },
                { "i5-4310M", 4, 2.70 },
                { "i5-4310U", 4, 2.00 },
                { "i5-4330M", 4, 2.80 },
                { "i5-4340M", 4, 2.90 },
                { "i5-4350U", 4, 1.40 },
                { "i5-4360U", 4, 1.50 },
                { "i5-4400E", 4, 2.70 },
                { "i5-4402E", 4, 1.60 },
                { "i5-4402EC", 4, 2.50 },
                { "i5-4410E", 4, 2.90 },
                { "i5-4422E", 4, 1.80 },
                { "i5-4430", 4, 3.00 },
                { "i5-4430S", 4, 2.70 },
                { "i5-4440", 4, 3.10 },
                { "i5-4440S", 4, 2.80 },
                { "i5-4460", 4, 3.20 },
                { "i5-4460S", 4, 2.90 },
                { "i5-4460T", 4, 1.90 },
                { "i5-4470", 4, 3.40 },
                { "i5-450M", 4, 2.40 },
                { "i5-4570", 4, 3.20 },
                { "i5-4570R", 4, 2.70 },
                { "i5-4570S", 4, 2.90 },
                { "i5-4570T", 4, 2.90 },
                { "i5-4570TE", 4, 2.70 },
                { "i5-4590", 4, 3.30 },
                { "i5-4590S", 4, 3.00 },
                { "i5-4590T", 4, 2.00 },
                { "i5-460M", 4, 2.53 },
                { "i5-4670", 4, 3.40 },
                { "i5-4670K", 4, 3.40 },
                { "i5-4670R", 4, 3.00 },
                { "i5-4670S", 4, 3.10 },
                { "i5-4670T", 4, 2.30 },
                { "i5-4690", 4, 3.50 },
                { "i5-4690K", 4, 3.50 },
                { "i5-4690S", 4, 3.20 },
                { "i5-4690T", 4, 2.50 },
                { "i5-470UM", 4, 1.33 },
                { "i5-480M", 4, 2.66 },
                { "i5-5200U", 4, 2.20 },
                { "i5-520E", 4, 2.40 },
                { "i5-520M", 4, 2.40 },
                { "i5-520UM", 4, 1.06 },
                { "i5-5250U", 4, 1.60 },
                { "i5-5257U", 4, 2.70 },
                { "i5-5287U", 4, 2.90 },
                { "i5-5300U", 4, 2.30 },
                { "i5-5350H", 4, 3.00 },
                { "i5-5350U", 4, 1.80 },
                { "i5-540M", 4, 2.53 },
                { "i5-540UM", 4, 1.20 },
                { "i5-5575R", 4, 2.80 },
                { "i5-560M", 4, 2.66 },
                { "i5-560UM", 4, 1.33 },
                { "i5-5675C", 4, 3.10 },
                { "i5-5675R", 4, 3.10 },
                { "i5-580M", 4, 2.66 },
                { "i5-6198DU", 4, 2.30 },
                { "i5-6200U", 4, 2.30 },
                { "i5-6260U", 4, 1.80 },
                { "i5-6267U", 4, 2.90 },
                { "i5-6287U", 4, 3.10 },
                { "i5-6300HQ", 4, 2.30 },
                { "i5-6300U", 4, 2.40 },
                { "i5-6350HQ", 4, 2.30 },
                { "i5-6360U", 4, 2.00 },
                { "i5-6400", 4, 2.70 },
                { "i5-6400T", 4, 2.20 },
                { "i5-6402P", 4, 2.80 },
                { "i5-6440EQ", 4, 2.70 },
                { "i5-6440HQ", 4, 2.60 },
                { "i5-6442EQ", 4, 1.90 },
                { "i5-650", 4, 3.20 },
                { "i5-6500", 4, 3.20 },
                { "i5-6500T", 4, 2.50 },
                { "i5-6500TE", 4, 2.30 },
                { "i5-655K", 4, 3.20 },
                { "i5-6585R", 4, 2.80 },
                { "i5-660", 4, 3.33 },
                { "i5-6600", 4, 3.30 },
                { "i5-6600K", 4, 3.50 },
                { "i5-6600T", 4, 2.70 },
                { "i5-661", 4, 3.33 },
                { "i5-6685R", 4, 3.00 },
                { "i5-670", 4, 3.46 },
                { "i5-680", 4, 3.60 },
                { "i5-7200U", 4, 2.50 },
                { "i5-7210U", 4, 2.50 },
                { "i5-7260U", 4, 2.20 },
                { "i5-7267U", 4, 3.10 },
                { "i5-7287U", 4, 3.30 },
                { "i5-7300HQ", 4, 2.50 },
                { "i5-7300U", 4, 2.60 },
                { "i5-7360U", 4, 2.30 },
                { "i5-7400", 4, 3.00 },
                { "i5-7400T", 4, 2.40 },
                { "i5-7440EQ", 4, 2.90 },
                { "i5-7440HQ", 4, 2.80 },
                { "i5-7442EQ", 4, 2.10 },
                { "i5-750", 4, 2.66 },
                { "i5-7500", 4, 3.40 },
                { "i5-7500T", 4, 2.70 },
                { "i5-750S", 4, 2.40 },
                { "i5-760", 4, 2.80 },
                { "i5-7600", 4, 3.50 },
                { "i5-7600K", 4, 3.80 },
                { "i5-7600T", 4, 2.80 },
                { "i5-7640X", 4, 4.00 },
                { "i5-7Y54", 4, 1.20 },
                { "i5-7Y57", 4, 1.20 },
                { "i5-8200Y", 4, 1.30 },
                { "i5-8210Y", 4, 1.60 },
                { "i5-8250U", 8, 1.60 },
                { "i5-8257U", 8, 1.40 },
                { "i5-8259U", 8, 2.30 },
                { "i5-8260U", 8, 1.60 },
                { "i5-8265U", 8, 1.60 },
                { "i5-8269U", 8, 2.60 },
                { "i5-8279U", 8, 2.40 },
                { "i5-8300H", 8, 2.30 },
                { "i5-8305G", 8, 2.80 },
                { "i5-8310Y", 4, 1.60 },
                { "i5-8350U", 8, 1.70 },
                { "i5-8365U", 8, 1.60 },
                { "i5-8365UE", 8, 1.60 },
                { "i5-8400", 6, 2.80 },
                { "i5-8400B", 6, 2.80 },
                { "i5-8400H", 8, 2.50 },
                { "i5-8400T", 6, 1.70 },
                { "i5-8420", 6, 2.80 },
                { "i5-8420T", 6, 1.70 },
                { "i5-8500", 6, 3.00 },
                { "i5-8500B", 6, 3.00 },
                { "i5-8500T", 6, 2.10 },
                { "i5-8550", 6, 2.50 },
                { "i5-8600", 6, 3.10 },
                { "i5-8600K", 6, 3.60 },
                { "i5-8600T", 6, 2.30 },
                { "i5-8650", 6, 2.90 },
                { "i5-9300H", 8, 2.40 },
                { "i5-9300HF", 8, 2.40 },
                { "i5-9400", 6, 2.90 },
                { "i5-9400F", 6, 2.90 },
                { "i5-9400H", 8, 2.50 },
                { "i5-9400T", 6, 1.80 },
                { "i5-9500", 6, 3.00 },
                { "i5-9500E", 6, 3.00 },
                { "i5-9500F", 6, 3.00 },
                { "i5-9500T", 6, 2.20 },
                { "i5-9500TE", 6, 2.20 },
                { "i5-9600", 6, 3.10 },
                { "i5-9600K", 6, 3.70 },
                { "i5-9600KF", 6, 3.70 },
                { "i5-9600T", 6, 2.30 },
                { "i5-12450H", 12, 2.00 },
                { "i5-12450HX", 12, 2.40 },
                { "i5-12650H", 16, 2.30 },
                { "i5-13420H", 12, 2.10 },
                { "i5-13450HX", 16, 2.40 },
                { "i5-13500HX", 20, 2.50 },
                { "i5-13600HX", 20, 2.60 },
                { "i5-14400", 16, 2.50 },
                { "i5-14400F", 16, 2.50 },
                { "i5-14400T", 16, 1.50 },
                { "i5-14450HX", 16, 2.40 },
                { "i5-14490F", 16, 2.80 },
                { "i5-14500", 20, 2.60 },
                { "i5-14500GX", 20, 2.60 },
                { "i5-14500HX", 20, 2.60 },
                { "i5-14500T", 20, 1.70 },
                { "i5-14500TE", 20, 1.20 },
                { "i5-14600", 20, 2.70 },
                { "i5-14600K", 20, 3.50 },
                { "i5-14600KF", 20, 3.50 },
                { "i5-14600T", 20, 1.80 },

                // i7 series
                { "i7-10510U", 8, 1.80 },
                { "i7-10510Y", 8, 1.20 },
                { "i7-1060G7", 8, 1.00 },
                { "i7-10610U", 8, 1.80 },
                { "i7-1065G7", 8, 1.30 },
                { "i7-1068G7", 8, 2.30 },
                { "i7-1068NG7", 8, 2.30 },
                { "i7-10700", 16, 2.90 },
                { "i7-10700E", 16, 2.90 },
                { "i7-10700F", 16, 2.90 },
                { "i7-10700K", 16, 3.80 },
                { "i7-10700KF", 16, 3.80 },
                { "i7-10700T", 16, 2.00 },
                { "i7-10700TE", 16, 2.00 },
                { "i7-10710U", 12, 1.10 },
                { "i7-10750H", 12, 2.60 },
                { "i7-10810U", 12, 1.10 },
                { "i7-10850H", 12, 2.70 },
                { "i7-10870H", 16, 2.20 },
                { "i7-10875H", 16, 2.30 },
                { "i7-11370H", 8, 3.30 },
                { "i7-11375H", 8, 3.30 },
                { "i7-11390H", 8, 3.40 },
                { "i7-11600H", 12, 2.90 },
                { "i7-1160G7", 8, 1.20 },
                { "i7-1165G7", 8, 2.80 },
                { "i7-11700", 16, 2.50 },
                { "i7-11700B", 16, 3.20 },
                { "i7-11700F", 16, 2.50 },
                { "i7-11700K", 16, 3.60 },
                { "i7-11700KF", 16, 3.60 },
                { "i7-11700T", 16, 1.40 },
                { "i7-11800H", 16, 2.30 },
                { "i7-1180G7", 8, 1.30 },
                { "i7-11850H", 16, 2.50 },
                { "i7-11850HE", 16, 2.60 },
                { "i7-1185G7", 8, 3.00 },
                { "i7-1185G7E", 8, 1.80 },
                { "i7-1185GRE", 8, 1.80 },
                { "i7-1195G7", 8, 2.90 },
                { "i7-1250U", 12, 1.10 },
                { "i7-1255U", 12, 1.70 },
                { "i7-1260P", 16, 2.10 },
                { "i7-1260U", 12, 1.10 },
                { "i7-1265U", 12, 1.80 },
                { "i7-12700", 20, 2.10 },
                { "i7-12700F", 20, 2.10 },
                { "i7-12700K", 20, 3.60 },
                { "i7-12700KF", 20, 3.60 },
                { "i7-12700T", 20, 1.40 },
                { "i7-12700H", 20, 2.30 },
                { "i7-1270P", 16, 2.20 },
                { "i7-1270PE", 16, 2.20 },
                { "i7-1360P", 16, 2.20 },
                { "i7-13700", 24, 2.10 },
                { "i7-13700F", 24, 2.10 },
                { "i7-13700K", 24, 3.40 },
                { "i7-13700KF", 24, 3.40 },
                { "i7-13700T", 24, 1.40 },
                { "i7-13790F", 24, 2.10 },
                { "i7-2535QM", 8, 2.40 },
                { "i7-2570QM", 8, 2.70 },
                { "i7-2600", 8, 3.40 },
                { "i7-2600K", 8, 3.40 },
                { "i7-2600S", 8, 2.80 },
                { "i7-2610UE", 4, 1.50 },
                { "i7-2617M", 4, 1.50 },
                { "i7-2620M", 4, 2.70 },
                { "i7-2627M", 4, 1.50 },
                { "i7-2629M", 4, 2.10 },
                { "i7-2630QM", 8, 2.00 },
                { "i7-2635QM", 8, 2.00 },
                { "i7-2637M", 4, 1.70 },
                { "i7-2640M", 4, 2.80 },
                { "i7-2649M", 4, 2.30 },
                { "i7-2655LE", 4, 2.20 },
                { "i7-2655QM", 8, 2.40 },
                { "i7-2657M", 4, 1.60 },
                { "i7-2660M", 4, 2.20 },
                { "i7-2667M", 4, 1.80 },
                { "i7-2669M", 4, 2.10 },
                { "i7-2670QM", 8, 2.20 },
                { "i7-2675QM", 8, 2.20 },
                { "i7-2677M", 4, 1.80 },
                { "i7-2685QM", 8, 2.50 },
                { "i7-2689M", 4, 2.00 },
                { "i7-2700K", 8, 3.50 },
                { "i7-2710QE", 8, 2.10 },
                { "i7-2715QE", 8, 2.10 },
                { "i7-2720QM", 8, 2.20 },
                { "i7-2740QM", 8, 2.40 },
                { "i7-2760QM", 8, 2.40 },
                { "i7-2820QM", 8, 2.30 },
                { "i7-2840QM", 8, 2.40 },
                { "i7-2860QM", 8, 2.50 },
                { "i7-2920XM", 8, 2.50 },
                { "i7-2960XM", 8, 2.70 },
                { "i7-3517U", 4, 1.90 },
                { "i7-3517UE", 4, 1.70 },
                { "i7-3520M", 4, 2.90 },
                { "i7-3537U", 4, 2.00 },
                { "i7-3540M", 4, 3.00 },
                { "i7-3555LE", 4, 2.50 },
                { "i7-3610QE", 8, 2.30 },
                { "i7-3610QM", 8, 2.30 },
                { "i7-3612QE", 8, 2.10 },
                { "i7-3612QM", 8, 2.10 },
                { "i7-3615QE", 8, 2.30 },
                { "i7-3615QM", 8, 2.30 },
                { "i7-3630QM", 8, 2.40 },
                { "i7-3632QM", 8, 2.20 },
                { "i7-3635QM", 8, 2.40 },
                { "i7-3667U", 4, 2.00 },
                { "i7-3687U", 4, 2.10 },
                { "i7-3689Y", 4, 1.50 },
                { "i7-3720QM", 8, 2.60 },
                { "i7-3740QM", 8, 2.70 },
                { "i7-3770", 8, 3.40 },
                { "i7-3770K", 8, 3.50 },
                { "i7-3770S", 8, 3.10 },
                { "i7-3770T", 8, 2.50 },
                { "i7-3820", 8, 3.60 },
                { "i7-3820QM", 8, 2.70 },
                { "i7-3840QM", 8, 2.80 },
                { "i7-3920XM", 8, 2.90 },
                { "i7-3930K", 12, 3.20 },
                { "i7-3940XM", 8, 3.00 },
                { "i7-3960X", 12, 3.30 },
                { "i7-3970X", 12, 3.50 },
                { "i7-4500U", 4, 1.80 },
                { "i7-4510U", 4, 2.00 },
                { "i7-4550U", 4, 1.50 },
                { "i7-4558U", 4, 2.80 },
                { "i7-4578U", 4, 3.00 },
                { "i7-4600M", 4, 2.90 },
                { "i7-4600U", 4, 2.10 },
                { "i7-4610M", 4, 3.00 },
                { "i7-4610Y", 4, 1.70 },
                { "i7-4650U", 4, 1.70 },
                { "i7-4700EC", 8, 2.70 },
                { "i7-4700EQ", 8, 2.40 },
                { "i7-4700HQ", 8, 2.40 },
                { "i7-4700MQ", 8, 2.40 },
                { "i7-4701EQ", 8, 2.40 },
                { "i7-4702EC", 8, 2.00 },
                { "i7-4702HQ", 8, 2.20 },
                { "i7-4702MQ", 8, 2.20 },
                { "i7-4710HQ", 8, 2.50 },
                { "i7-4710MQ", 8, 2.50 },
                { "i7-4712HQ", 8, 2.30 },
                { "i7-4712MQ", 8, 2.30 },
                { "i7-4720HQ", 8, 2.60 },
                { "i7-4722HQ", 8, 2.40 },
                { "i7-4750HQ", 8, 2.00 },
                { "i7-4760HQ", 8, 2.10 },
                { "i7-4765T", 8, 2.00 },
                { "i7-4770", 8, 3.40 },
                { "i7-4770HQ", 8, 2.20 },
                { "i7-4770K", 8, 3.50 },
                { "i7-4770R", 8, 3.20 },
                { "i7-4770S", 8, 3.10 },
                { "i7-4770T", 8, 2.50 },
                { "i7-4770TE", 8, 2.30 },
                { "i7-4771", 8, 3.50 },
                { "i7-4785T", 8, 2.20 },
                { "i7-4790", 8, 3.60 },
                { "i7-4790K", 8, 4.00 },
                { "i7-4790S", 8, 3.20 },
                { "i7-4790T", 8, 2.70 },
                { "i7-4800MQ", 8, 2.70 },
                { "i7-4810MQ", 8, 2.80 },
                { "i7-4820K", 8, 3.70 },
                { "i7-4850EQ", 8, 1.60 },
                { "i7-4850HQ", 8, 2.30 },
                { "i7-4860EQ", 8, 1.80 },
                { "i7-4860HQ", 8, 2.40 },
                { "i7-4870HQ", 8, 2.50 },
                { "i7-4900MQ", 8, 2.80 },
                { "i7-4910MQ", 8, 2.90 },
                { "i7-4930K", 12, 3.40 },
                { "i7-4930MX", 8, 3.00 },
                { "i7-4940MX", 8, 3.10 },
                { "i7-4950HQ", 8, 2.40 },
                { "i7-4960HQ", 8, 2.60 },
                { "i7-4960X", 12, 3.60 },
                { "i7-4980HQ", 8, 2.80 },
                { "i7-5500U", 4, 2.40 },
                { "i7-5550U", 4, 2.00 },
                { "i7-5557U", 4, 3.10 },
                { "i7-5600U", 4, 2.60 },
                { "i7-5650U", 4, 2.20 },
                { "i7-5700EQ", 8, 2.60 },
                { "i7-5700HQ", 8, 2.70 },
                { "i7-5750HQ", 8, 2.50 },
                { "i7-5775C", 8, 3.30 },
                { "i7-5775R", 8, 3.30 },
                { "i7-5820K", 12, 3.30 },
                { "i7-5850EQ", 8, 2.70 },
                { "i7-5850HQ", 8, 2.70 },
                { "i7-5930K", 12, 3.50 },
                { "i7-5950HQ", 8, 2.90 },
                { "i7-5960X", 16, 3.00 },
                { "i7-610E", 4, 2.53 },
                { "i7-620LE", 4, 2.00 },
                { "i7-620LM", 4, 2.00 },
                { "i7-620M", 4, 2.66 },
                { "i7-620UE", 4, 1.06 },
                { "i7-620UM", 4, 1.20 },
                { "i7-640LM", 4, 2.13 },
                { "i7-640M", 4, 2.80 },
                { "i7-640UM", 4, 1.20 },
                { "i7-6498DU", 4, 2.50 },
                { "i7-6500U", 4, 2.50 },
                { "i7-6560U", 4, 2.20 },
                { "i7-6567U", 4, 3.30 },
                { "i7-6600U", 4, 2.60 },
                { "i7-660LM", 4, 2.26 },
                { "i7-660UE", 4, 1.33 },
                { "i7-660UM", 4, 1.33 },
                { "i7-6650U", 4, 2.20 },
                { "i7-6660U", 4, 2.40 },
                { "i7-6700", 8, 3.40 },
                { "i7-6700HQ", 8, 2.60 },
                { "i7-6700K", 8, 4.00 },
                { "i7-6700T", 8, 2.80 },
                { "i7-6700TE", 8, 2.40 },
                { "i7-6770HQ", 8, 2.60 },
                { "i7-6785R", 8, 3.30 },
                { "i7-6800K", 12, 3.40 },
                { "i7-680UM", 4, 1.46 },
                { "i7-6820EQ", 8, 2.80 },
                { "i7-6820HK", 8, 2.70 },
                { "i7-6820HQ", 8, 2.70 },
                { "i7-6822EQ", 8, 2.00 },
                { "i7-6850K", 12, 3.60 },
                { "i7-6870HQ", 8, 2.70 },
                { "i7-6900K", 16, 3.20 },
                { "i7-6920HQ", 8, 2.90 },
                { "i7-6950X", 20, 3.00 },
                { "i7-6970HQ", 8, 2.80 },
                { "i7-720QM", 8, 1.60 },
                { "i7-740QM", 8, 1.73 },
                { "i7-7500U", 4, 2.70 },
                { "i7-7510U", 4, 1.80 },
                { "i7-7560U", 4, 2.40 },
                { "i7-7567U", 4, 3.50 },
                { "i7-7600U", 4, 2.80 },
                { "i7-7660U", 4, 2.50 },
                { "i7-7700", 8, 3.60 },
                { "i7-7700HQ", 8, 2.80 },
                { "i7-7700K", 8, 4.20 },
                { "i7-7700T", 8, 2.90 },
                { "i7-7740X", 8, 4.30 },
                { "i7-7800X", 12, 3.50 },
                { "i7-7820EQ", 8, 3.00 },
                { "i7-7820HK", 8, 2.90 },
                { "i7-7820HQ", 8, 2.90 },
                { "i7-7820X", 16, 3.60 },
                { "i7-7920HQ", 8, 3.10 },
                { "i7-7Y75", 4, 1.30 },
                { "i7-8086K", 12, 4.00 },
                { "i7-820QM", 8, 1.73 },
                { "i7-840QM", 8, 1.86 },
                { "i7-8500Y", 4, 1.50 },
                { "i7-8550U", 8, 1.80 },
                { "i7-8557U", 8, 1.70 },
                { "i7-8559U", 8, 2.70 },
                { "i7-8565U", 8, 1.80 },
                { "i7-8569U", 8, 2.80 },
                { "i7-860", 8, 2.80 },
                { "i7-860S", 8, 2.53 },
                { "i7-8650U", 8, 1.90 },
                { "i7-8665U", 8, 1.90 },
                { "i7-8665UE", 8, 1.70 },
                { "i7-8670", 12, 2.90 },
                { "i7-8670T", 12, 2.20 },
                { "i7-870", 8, 2.93 },
                { "i7-8700", 12, 3.20 },
                { "i7-8700B", 12, 3.20 },
                { "i7-8700K", 12, 3.70 },
                { "i7-8700T", 12, 2.40 },
                { "i7-8705G", 8, 3.10 },
                { "i7-8706G", 8, 3.10 },
                { "i7-8709G", 8, 3.10 },
                { "i7-870S", 8, 2.66 },
                { "i7-8750H", 12, 2.20 },
                { "i7-875K", 8, 2.93 },
                { "i7-880", 8, 3.06 },
                { "i7-8809G", 8, 3.10 },
                { "i7-8850H", 12, 2.60 },
                { "i7-920", 8, 2.66 },
                { "i7-920XM", 8, 2.00 },
                { "i7-930", 8, 2.80 },
                { "i7-940", 8, 2.93 },
                { "i7-940XM", 8, 2.13 },
                { "i7-950", 8, 3.06 },
                { "i7-960", 8, 3.20 },
                { "i7-965", 8, 3.20 },
                { "i7-970", 12, 3.20 },
                { "i7-9700", 8, 3.00 },
                { "i7-9700E", 8, 2.60 },
                { "i7-9700F", 8, 3.00 },
                { "i7-9700K", 8, 3.60 },
                { "i7-9700KF", 8, 3.60 },
                { "i7-9700T", 8, 2.00 },
                { "i7-9700TE", 8, 1.80 },
                { "i7-975", 8, 3.33 },
                { "i7-9750H", 12, 2.60 },
                { "i7-9750HF", 12, 2.60 },
                { "i7-980", 12, 3.33 },
                { "i7-9800X", 16, 3.80 },
                { "i7-980X", 12, 3.33 },
                { "i7-9850H", 12, 2.60 },
                { "i7-9850HE", 12, 2.70 },
                { "i7-9850HL", 12, 1.90 },
                { "i7-990X", 12, 3.46 },
                { "i7-12650H", 16, 2.30 },
                { "i7-12800H", 20, 2.40 },
                { "i7-12800HE", 20, 2.40 },
                { "i7-12800HX", 24, 2.00 },
                { "i7-12850HX", 24, 2.10 },
                { "i7-13620H", 16, 2.40 },
                { "i7-13650HX", 20, 2.60 },
                { "i7-13700H", 20, 2.40 },
                { "i7-13700HX", 24, 2.10 },
                { "i7-13705H", 20, 2.40 },
                { "i7-13800H", 20, 2.50 },
                { "i7-13850HX", 28, 2.10 },
                { "i7-14650HX", 24, 2.20 },
                { "i7-14700", 28, 2.10 },
                { "i7-14700F", 28, 2.10 },
                { "i7-14700H", 28, 2.30 },
                { "i7-14700HX", 28, 2.10 },
                { "i7-14700K", 28, 3.40 },
                { "i7-14700KF", 28, 3.40 },
                { "i7-14700T", 28, 1.30 },
                { "i7-14790F", 24, 2.10 },
                { "i7-14950HX", 24, 2.20 },

                // i9 series
                { "i9-10850K", 20, 3.60 },
                { "i9-10885H", 16, 2.40 },
                { "i9-10900", 20, 2.80 },
                { "i9-10900E", 20, 2.80 },
                { "i9-10900F", 20, 2.80 },
                { "i9-10900K", 20, 3.70 },
                { "i9-10900KF", 20, 3.70 },
                { "i9-10900T", 20, 1.90 },
                { "i9-10900TE", 20, 1.80 },
                { "i9-10900X", 20, 3.70 },
                { "i9-10910", 20, 3.60 },
                { "i9-10920X", 24, 3.50 },
                { "i9-10940X", 28, 3.30 },
                { "i9-10980HK", 16, 2.40 },
                { "i9-10980XE", 36, 3.00 },
                { "i9-11900", 16, 2.50 },
                { "i9-11900F", 16, 2.50 },
                { "i9-11900H", 16, 2.50 },
                { "i9-11900K", 16, 3.50 },
                { "i9-11900KB", 16, 3.30 },
                { "i9-11900KF", 16, 3.50 },
                { "i9-11900T", 16, 1.50 },
                { "i9-11950H", 16, 2.60 },
                { "i9-11980HK", 16, 2.60 },
                { "i9-12900", 24, 2.40 },
                { "i9-12900F", 24, 2.40 },
                { "i9-12900H", 20, 2.50 },
                { "i9-12900K", 24, 3.20 },
                { "i9-12900KF", 24, 3.20 },
                { "i9-12900KS", 24, 3.40 },
                { "i9-12900T", 24, 1.40 },
                { "i9-13900", 32, 2.00 },
                { "i9-13900E", 32, 1.80 },
                { "i9-13900F", 32, 2.00 },
                { "i9-13900HX", 32, 2.20 },
                { "i9-13900K", 32, 3.00 },
                { "i9-13900KF", 32, 3.00 },
                { "i9-13900KS", 32, 3.20 },
                { "i9-13900T", 32, 1.10 },
                { "i9-13900TE", 32, 1.00 },
                { "i9-13950HX", 32, 2.20 },
                { "i9-13980HX", 32, 2.20 },
                { "i9-14900", 32, 2.00 },
                { "i9-14900F", 32, 2.00 },
                { "i9-14900HX", 32, 2.20 },
                { "i9-14900K", 32, 3.20 },
                { "i9-14900KF", 32, 3.20 },
                { "i9-14900KS", 32, 3.20 },
                { "i9-14900T", 32, 1.10 },
                { "i9-7900X", 20, 3.30 },
                { "i9-7920X", 24, 2.90 },
                { "i9-7940X", 28, 3.10 },
                { "i9-7960X", 32, 2.80 },
                { "i9-7980XE", 36, 2.60 },
                { "i9-8950HK", 12, 2.90 },
                { "i9-9820X", 20, 3.30 },
                { "i9-9880H", 16, 2.30 },
                { "i9-9900", 16, 3.10 },
                { "i9-9900K", 16, 3.60 },
                { "i9-9900KF", 16, 3.60 },
                { "i9-9900KS", 16, 4.00 },
                { "i9-9900T", 16, 2.10 },
                { "i9-9900X", 20, 3.50 },
                { "i9-9920X", 24, 3.50 },
                { "i9-9940X", 28, 3.30 },
                { "i9-9960X", 32, 3.10 },
                { "i9-9980HK", 16, 2.40 },
                { "i9-9980XE", 36, 3.00 },
                { "i9-9990XE", 28, 4.00 },
                { "i9-12900E", 24, 2.30 },
                { "i9-12900HK", 20, 2.50 },
                { "i9-12900HX", 24, 2.30 },
                { "i9-12900TE", 24, 1.10 },
                { "i9-12950HX", 24, 2.30 },
                { "i9-13900H", 20, 2.60 },
                { "i9-13900HK", 20, 2.60 },
                { "i9-13905H", 20, 2.60 },
                { "i9-14900H", 32, 2.20 },
                { "i9-14901KE", 16, 3.80 }
            };
            out_ptr = db;
            out_size = sizeof(db) / sizeof(cpu_entry);
        }

        inline static void get_intel_xeon_db(const cpu_entry*& out_ptr, size_t& out_size) {
            static const cpu_entry db[] = {
                { "D-1518", 8, 2.20 },
                { "D-1520", 8, 2.20 },
                { "D-1521", 8, 2.40 },
                { "D-1527", 8, 2.20 },
                { "D-1528", 12, 1.90 },
                { "D-1529", 8, 1.30 },
                { "D-1531", 12, 2.20 },
                { "D-1537", 16, 1.70 },
                { "D-1539", 16, 1.60 },
                { "D-1540", 16, 2.00 },
                { "D-1541", 16, 2.10 },
                { "D-1548", 16, 2.00 },
                { "D-1557", 24, 1.50 },
                { "D-1559", 24, 1.50 },
                { "D-1567", 24, 2.10 },
                { "D-1571", 32, 1.30 },
                { "D-1577", 32, 1.30 },
                { "D-1581", 32, 1.80 },
                { "D-1587", 32, 1.70 },
                { "D-1513N", 8, 1.60 },
                { "D-1523N", 8, 2.00 },
                { "D-1533N", 12, 2.10 },
                { "D-1543N", 16, 1.90 },
                { "D-1553N", 16, 2.30 },
                { "D-1602", 4, 2.50 },
                { "D-1612", 8, 1.50 },
                { "D-1622", 8, 2.60 },
                { "D-1627", 8, 2.90 },
                { "D-1632", 16, 1.50 },
                { "D-1637", 12, 2.90 },
                { "D-1623N", 8, 2.40 },
                { "D-1633N", 12, 2.50 },
                { "D-1649N", 16, 2.30 },
                { "D-1653N", 16, 2.80 },
                { "D-2141I", 16, 2.20 },
                { "D-2161I", 24, 2.20 },
                { "D-2191", 36, 1.60 },
                { "D-2123IT", 8, 2.20 },
                { "D-2142IT", 16, 1.90 },
                { "D-2143IT", 16, 2.20 },
                { "D-2163IT", 24, 2.10 },
                { "D-2173IT", 28, 1.70 },
                { "D-2183IT", 32, 2.20 },
                { "D-2145NT", 16, 1.90 },
                { "D-2146NT", 16, 2.30 },
                { "D-2166NT", 24, 2.00 },
                { "D-2177NT", 28, 1.90 },
                { "D-2187NT", 32, 2.00 },

                // Xeon E
                { "E-2104G", 4, 3.20 },
                { "E-2124", 4, 3.30 },
                { "E-2124G", 4, 3.40 },
                { "E-2126G", 6, 3.30 },
                { "E-2134", 8, 3.50 },
                { "E-2136", 12, 3.30 },
                { "E-2144G", 8, 3.60 },
                { "E-2146G", 12, 3.50 },
                { "E-2174G", 8, 3.80 },
                { "E-2176G", 12, 3.70 },
                { "E-2186G", 12, 3.80 },
                { "E-2176M", 12, 2.70 },
                { "E-2186M", 12, 2.90 },
                { "E-2224", 4, 3.40 },
                { "E-2224G", 4, 3.50 },
                { "E-2226G", 6, 3.40 },
                { "E-2234", 8, 3.60 },
                { "E-2236", 12, 3.40 },
                { "E-2244G", 8, 3.80 },
                { "E-2246G", 12, 3.60 },
                { "E-2274G", 8, 4.00 },
                { "E-2276G", 12, 3.80 },
                { "E-2278G", 16, 3.40 },
                { "E-2286G", 12, 4.00 },
                { "E-2288G", 16, 3.70 },
                { "E-2276M", 12, 2.80 },
                { "E-2286M", 16, 2.40 },

                // Xeon W
                { "W-2102", 4, 2.90 },
                { "W-2104", 4, 3.20 },
                { "W-2123", 8, 3.60 },
                { "W-2125", 8, 4.00 },
                { "W-2133", 12, 3.60 },
                { "W-2135", 12, 3.70 },
                { "W-2140B", 16, 3.20 },
                { "W-2145", 16, 3.70 },
                { "W-2150B", 20, 3.00 },
                { "W-2155", 20, 3.30 },
                { "W-2170B", 28, 2.50 },
                { "W-2175", 28, 2.50 },
                { "W-2191B", 36, 2.30 },
                { "W-2195", 36, 2.30 },
                { "W-3175X", 56, 3.10 },
                { "W-3223", 16, 3.50 },
                { "W-3225", 16, 3.70 },
                { "W-3235", 24, 3.30 },
                { "W-3245", 32, 3.20 },
                { "W-3245M", 32, 3.20 },
                { "W-3265", 48, 2.70 },
                { "W-3265M", 48, 2.70 },
                { "W-3275", 56, 2.50 },
                { "W-3275M", 56, 2.50 },
                { "w3-2423", 12, 2.10 },
                { "w3-2425", 12, 3.00 },
                { "w3-2435", 16, 3.10 },
                { "w5-2445", 20, 3.10 },
                { "w5-2455X", 24, 3.20 },
                { "w5-2465X", 32, 3.10 },
                { "w7-2475X", 40, 2.60 },
                { "w7-2495X", 48, 2.50 },
                { "w5-3425", 24, 3.20 },
                { "w5-3435X", 32, 3.10 },
                { "w7-3445", 40, 2.60 },
                { "w7-3455", 48, 2.50 },
                { "w7-3465X", 56, 2.50 },
                { "w9-3475X", 72, 2.20 },
                { "w9-3495X", 112, 1.90 },
                { "w3-2525", 16, 3.50 },
                { "w3-2535", 20, 3.50 },
                { "w5-2545", 24, 3.50 },
                { "w5-2555X", 28, 3.30 },
                { "w5-2565X", 36, 3.20 },
                { "w7-2575X", 44, 3.00 },
                { "w7-2595X", 52, 2.80 },
                { "w5-3525", 32, 3.20 },
                { "w5-3535X", 40, 3.20 },
                { "w7-3545", 48, 2.70 },
                { "w7-3555", 56, 2.70 },
                { "w7-3565X", 64, 2.60 },
                { "w9-3575X", 88, 2.20 },
                { "w9-3595X", 120, 2.00 }
            };
            out_ptr = db;
            out_size = sizeof(db) / sizeof(cpu_entry);
        }

        inline static void get_intel_ultra_db(const cpu_entry*& db, size_t& size) {
            static const cpu_entry intel_ultra[] = {
                // Series 2 (Arrow Lake - Desktop/Mobile) - No HT on P-Cores
                { "285K", 24, 3.70 },
                { "265K", 20, 3.90 },
                { "265KF", 20, 3.90 },
                { "245K", 14, 4.20 },
                { "245KF", 14, 4.20 },

                // Series 2 (Lunar Lake - Mobile)
                { "288V", 8, 3.30 },
                { "268V", 8, 3.30 },
                { "258V", 8, 2.20 },

                // Series 1 (Meteor Lake - Mobile) - P-Cores have HT
                // 6P + 8E + 2LP = 16 Cores. Threads = (6*2) + 8 + 2 = 22 Threads
                { "185H", 22, 2.30 },
                { "165H", 22, 1.40 },
                { "155H", 22, 1.40 },

                // 4P + 8E + 2LP = 14 Cores. Threads = (4*2) + 8 + 2 = 18 Threads
                { "135H", 18, 1.70 },
                { "125H", 18, 1.20 },

                // 2P + 8E + 2LP = 12 Cores. Threads = (2*2) + 8 + 2 = 14 Threads
                { "165U", 14, 1.70 },
                { "155U", 14, 1.70 },
                { "135U", 14, 1.60 },
                { "125U", 14, 1.30 },
            };
            db = intel_ultra;
            size = sizeof(intel_ultra) / sizeof(cpu_entry);
        }

        inline static void get_amd_ryzen_db(const cpu_entry*& out_ptr, size_t& out_size) {
            static const cpu_entry db[] = {
                // 3015/3020
                { "3015ce", 4, 1.20 },
                { "3015e", 4, 1.20 },
                { "3020e", 2, 1.20 },

                // Athlon/Ax suffixes
                { "860k", 4, 3.70 },
                { "870k", 4, 3.90 },
                { "pro-7350b", 4, 3.10 },
                { "pro-7800b", 4, 3.50 },
                { "pro-7850b", 4, 3.70 },
                { "a10-6700", 4, 3.70 },
                { "a10-6700t", 4, 2.50 },
                { "a10-6790b", 4, 4.00 },
                { "a10-6790k", 4, 4.00 },
                { "a10-6800b", 4, 4.10 },
                { "a10-6800k", 4, 4.10 },
                { "a10-7300", 4, 1.90 },
                { "a10-7400p", 4, 2.50 },
                { "a10-7700k", 4, 3.40 },
                { "a10-7800", 4, 3.50 },
                { "a10-7850k", 4, 3.70 },
                { "a10-7860k", 4, 3.60 },
                { "a10-7870k", 4, 3.90 },
                { "a10-8700b", 4, 1.80 },
                { "a10-8700p", 4, 1.80 },
                { "a10-8750b", 4, 3.60 },
                { "a10-8850b", 4, 3.90 },
                { "a12-8800b", 4, 2.10 },
                { "micro-6400t", 4, 1.00 },
                { "pro-3340b", 4, 2.20 },
                { "pro-3350b", 4, 2.20 },
                { "pro-7300b", 2, 1.90 },
                { "a4-5000", 4, 1.50 },
                { "a4-5100", 4, 1.55 },
                { "a4-6210", 4, 1.80 },
                { "a4-6300", 2, 3.70 },
                { "a4-6320", 2, 3.80 },
                { "a4-7210", 4, 1.80 },
                { "a4-7300", 2, 3.80 },
                { "a4-8350b", 2, 3.50 },
                { "a4-9120c", 2, 1.60 },
                { "pro-7050b", 2, 2.20 },
                { "pro-7400b", 2, 3.50 },
                { "a6-5200", 4, 2.00 },
                { "a6-5200m", 4, 2.00 },
                { "a6-5350m", 2, 2.90 },
                { "a6-6310", 4, 1.80 },
                { "a6-6400b", 2, 3.90 },
                { "a6-6400k", 2, 3.90 },
                { "a6-6420b", 2, 4.00 },
                { "a6-6420k", 2, 4.00 },
                { "a6-7000", 2, 2.20 },
                { "a6-7310", 4, 2.00 },
                { "a6-7400k", 2, 3.50 },
                { "a6-8500b", 2, 1.60 },
                { "a6-8500p", 2, 1.60 },
                { "a6-8550b", 2, 3.70 },
                { "a6-9220c", 2, 1.80 },
                { "pro-7150b", 4, 1.90 },
                { "pro-7600b", 4, 3.10 },
                { "a8-6410", 4, 2.00 },
                { "a8-6500", 4, 3.50 },
                { "a8-6500b", 4, 3.50 },
                { "a8-6500t", 4, 2.10 },
                { "a8-6600k", 4, 3.90 },
                { "a8-7100", 4, 1.80 },
                { "a8-7200p", 4, 2.40 },
                { "a8-7410", 4, 2.20 },
                { "a8-7600", 4, 3.10 },
                { "a8-7650k", 4, 3.30 },
                { "a8-7670k", 4, 3.60 },
                { "a8-8600b", 4, 1.60 },
                { "a8-8600p", 4, 1.60 },
                { "a8-8650b", 4, 3.20 },

                // AI Series (Strix Point)
                { "365", 20, 2.00 }, // Ryzen AI 7 365
                { "370", 24, 2.00 }, // Ryzen AI 9 HX 370
                { "375", 24, 2.00 }, // Ryzen AI 9 HX 375

                // Athlon
                { "3050c", 2, 2.30 },
                { "200ge", 4, 3.20 },
                { "220ge", 4, 3.40 },
                { "240ge", 4, 3.50 },
                { "255e", 2, 3.10 },
                { "3000g", 4, 3.50 },
                { "300ge", 4, 3.40 },
                { "300u", 4, 2.40 },
                { "320ge", 4, 3.50 },
                { "425e", 3, 2.70 },
                { "460", 3, 3.40 },
                { "5150", 4, 1.60 },
                { "5350", 4, 2.05 },
                { "5370", 4, 2.20 },
                { "620e", 4, 2.70 },
                { "631", 4, 2.60 },
                { "638", 4, 2.70 },
                { "641", 4, 2.80 },
                { "740", 4, 3.20 },
                { "750k", 4, 3.40 },
                { "760k", 4, 3.80 },
                { "3150c", 4, 2.40 },
                { "3150g", 4, 3.50 },
                { "3150ge", 4, 3.30 },
                { "3150u", 4, 2.40 },
                { "7220c", 4, 2.40 },
                { "7220u", 4, 2.40 },
                { "3045b", 2, 2.30 },
                { "3145b", 4, 2.40 },
                { "3050e", 4, 1.40 },
                { "3050ge", 4, 3.40 },
                { "3050u", 2, 2.30 },
                { "7120c", 2, 2.40 },
                { "7120u", 2, 2.40 },
                { "3125ge", 4, 3.40 },
                { "940", 4, 3.00 },
                { "950", 4, 3.50 },
                { "970", 4, 3.80 },

                // Business Class
                { "b57", 2, 3.20 },
                { "b59", 2, 3.40 },
                { "b60", 2, 3.50 },
                { "b75", 3, 3.00 },
                { "b77", 3, 3.20 },
                { "b97", 4, 3.20 },
                { "b99", 4, 3.30 },

                // E-Series
                { "micro-6200t", 2, 1.00 },
                { "e1-2100", 2, 1.00 },
                { "e1-2200", 2, 1.05 },
                { "e1-2500", 2, 1.40 },
                { "e1-6010", 2, 1.35 },
                { "e1-7010", 2, 1.50 },
                { "e2-3000", 2, 1.65 },
                { "e2-3800", 4, 1.30 },
                { "e2-6110", 4, 1.50 },
                { "e2-7110", 4, 1.80 },

                // FX
                { "fx-4100", 4, 3.60 },
                { "fx-4130", 4, 3.80 },
                { "fx-4170", 4, 4.20 },
                { "fx-4300", 4, 3.80 },
                { "fx-4320", 4, 4.00 },
                { "fx-4350", 4, 4.20 },
                { "fx-6200", 6, 3.80 },
                { "fx-6300", 6, 3.50 },
                { "fx-6350", 6, 3.90 },
                { "fx-7500", 4, 2.10 },
                { "fx-7600p", 4, 2.70 },
                { "fx-8120", 8, 3.10 },
                { "fx-8150", 8, 3.60 },
                { "fx-8300", 8, 3.30 },
                { "fx-8310", 8, 3.40 },
                { "fx-8320", 8, 3.50 },
                { "fx-8320e", 8, 3.20 },
                { "fx-8350", 8, 4.00 },
                { "fx-8370", 8, 4.00 },
                { "fx-8370e", 8, 3.30 },
                { "fx-8800p", 4, 2.10 },
                { "fx-9370", 8, 4.40 },
                { "fx-9590", 8, 4.70 },

                // Misc
                { "micro-6700t", 4, 1.20 },
                { "n640", 2, 2.90 },
                { "n660", 2, 3.00 },
                { "n870", 3, 2.30 },
                { "n960", 4, 1.80 },
                { "n970", 4, 2.20 },
                { "p650", 2, 2.60 },
                { "p860", 3, 2.00 },

                // Phenom II
                { "1075t", 6, 3.00 },
                { "555", 2, 3.20 },
                { "565", 2, 3.40 },
                { "570", 2, 3.50 },
                { "840", 4, 3.20 },
                { "850", 4, 3.30 },
                { "960t", 4, 3.00 },
                { "965", 4, 3.40 },
                { "975", 4, 3.60 },
                { "980", 4, 3.70 },

                // Ryzen Suffixes (3/5/7/9/Threadripper consolidated)
                { "1200", 4, 3.10 },
                { "1300x", 4, 3.50 },
                // "210" mapped to Ryzen 5 1400 (First Gen 4c/8t)
                { "210", 8, 3.20 },
                { "2200g", 4, 3.50 },
                { "2200ge", 4, 3.20 },
                { "2200u", 4, 2.50 },
                { "2300u", 4, 2.00 },
                { "2300x", 4, 3.50 },
                { "3100", 8, 3.60 },
                { "3200g", 4, 3.60 },
                { "3200ge", 4, 3.30 },
                { "3200u", 4, 2.60 },
                { "3250c", 4, 2.60 },
                { "3250u", 4, 2.60 },
                { "3300u", 4, 2.10 },
                { "3300x", 8, 3.80 },
                { "3350u", 4, 2.10 },
                { "4100", 8, 3.80 },
                { "4300g", 8, 3.80 },
                { "4300ge", 8, 3.50 },
                { "4300u", 4, 2.70 },
                { "5125c", 4, 3.00 },
                { "5300g", 8, 4.00 },
                { "5300ge", 8, 3.60 },
                { "5300u", 8, 2.60 },
                { "5305g", 8, 4.00 },
                { "5305ge", 8, 3.60 },
                { "5400u", 8, 2.60 },
                { "5425c", 8, 2.70 },
                { "5425u", 8, 2.70 },
                { "7320c", 8, 2.40 },
                { "7320u", 8, 2.40 },
                { "7330u", 8, 2.30 },
                { "7335u", 8, 3.00 },
                { "7440u", 8, 3.00 },
                { "8300g", 8, 3.40 },
                { "8300ge", 8, 3.40 },
                { "8440u", 8, 3.00 },
                { "1300", 4, 3.50 },
                { "4350g", 8, 3.80 },
                { "4350ge", 8, 3.50 },
                { "4355g", 8, 3.80 },
                { "4355ge", 8, 3.50 },
                { "4450u", 8, 2.50 },
                { "5350g", 8, 4.00 },
                { "5350ge", 8, 3.60 },
                { "5355g", 8, 4.00 },
                { "5355ge", 8, 3.60 },
                { "5450u", 8, 2.60 },
                { "5475u", 8, 2.70 },
                { "1400", 8, 3.20 },
                { "1500x", 8, 3.50 },
                { "1600", 12, 3.20 },
                { "1600x", 12, 3.60 },
                // "220" mapped to Ryzen 5 1600 (First Gen 6c/12t)
                { "220", 12, 3.20 },
                // "230" mapped to Ryzen 5 2600 (Second Gen 6c/12t)
                { "230", 12, 3.40 },
                // "240" mapped to Ryzen 5 3600 (Third Gen 6c/12t)
                { "240", 12, 3.60 },
                { "2400g", 8, 3.60 },
                { "2400ge", 8, 3.20 },
                { "2500u", 8, 2.00 },
                { "2500x", 8, 3.60 },
                { "2600", 12, 3.40 },
                { "2600e", 12, 3.10 },
                { "2600h", 8, 3.20 },
                { "2600x", 12, 3.60 },
                { "3400g", 8, 3.70 },
                { "3400ge", 8, 3.30 },
                { "3450u", 8, 2.10 },
                { "3500", 6, 3.60 },
                { "3500c", 8, 2.10 },
                { "3500u", 8, 2.10 },
                { "3550h", 8, 2.10 },
                { "3580u", 8, 2.10 },
                { "3600", 12, 3.60 },
                { "3600x", 12, 3.80 },
                { "3600xt", 12, 3.80 },
                { "4500", 12, 3.60 },
                { "4500u", 6, 2.30 },
                { "4600g", 12, 3.70 },
                { "4600ge", 12, 3.30 },
                { "4600h", 12, 3.00 },
                { "4600u", 12, 2.10 },
                { "4680u", 12, 2.10 },
                { "5500", 12, 3.60 },
                { "5500gt", 12, 3.60 },
                { "5500h", 8, 3.30 },
                { "5500u", 12, 2.10 },
                { "5560u", 12, 2.30 },
                { "5600", 12, 3.50 },
                { "5600g", 12, 3.90 },
                { "5600ge", 12, 3.40 },
                { "5600gt", 12, 3.60 },
                { "5600h", 12, 3.30 },
                { "5600hs", 12, 3.00 },
                { "5600t", 12, 3.50 },
                { "5600u", 12, 2.30 },
                { "5600x", 12, 3.70 },
                { "5600x3d", 12, 3.30 },
                { "5600xt", 12, 3.80 },
                { "5605g", 12, 3.90 },
                { "5605ge", 12, 3.40 },
                { "5625c", 12, 2.30 },
                { "5625u", 12, 2.30 },
                { "6600h", 12, 3.30 },
                { "6600hs", 12, 3.30 },
                { "6600u", 12, 2.90 },
                { "7235hs", 8, 3.20 },
                { "7400f", 12, 3.70 },
                { "7430u", 12, 2.30 },
                { "7500f", 12, 3.70 },
                { "7520c", 8, 2.80 },
                { "7520u", 8, 2.80 },
                { "7530u", 12, 2.00 },
                { "7535hs", 12, 3.30 },
                { "7535u", 12, 2.90 },
                { "7540u", 12, 3.20 },
                { "7545u", 12, 3.20 },
                { "7600", 12, 3.80 },
                { "7600x", 12, 4.70 },
                { "7600x3d", 12, 4.10 },
                { "7640hs", 12, 4.30 },
                { "7640u", 12, 3.50 },
                { "7645hx", 12, 4.00 },
                { "8400f", 12, 4.20 },
                { "8500g", 12, 4.10 }, // Zen 4 base
                { "8500ge", 12, 3.40 },
                { "8540u", 12, 3.20 },
                { "8600g", 12, 4.30 },
                { "8640hs", 12, 3.50 },
                { "8640u", 12, 3.50 },
                { "8645hs", 12, 4.30 },
                { "9600", 12, 3.90 },
                { "9600x", 12, 3.90 },
                { "1500", 8, 3.00 },
                { "3350g", 8, 3.60 },
                { "3350ge", 4, 3.30 },
                { "4650g", 12, 3.70 },
                { "4650ge", 12, 3.30 },
                { "4650u", 12, 2.10 },
                { "4655g", 12, 3.70 },
                { "4655ge", 12, 3.30 },
                { "5645", 12, 3.70 },
                { "5650g", 12, 3.90 },
                { "5650ge", 12, 3.40 },
                { "5650u", 12, 2.30 },
                { "5655g", 12, 3.90 },
                { "5655ge", 12, 3.40 },
                { "5675u", 12, 2.30 },
                { "6650h", 12, 3.30 },
                { "6650hs", 12, 3.30 },
                { "6650u", 12, 2.90 },
                { "1700", 16, 3.00 },
                { "1700x", 16, 3.40 },
                { "1800x", 16, 3.60 },
                // "250" mapped to Ryzen 7 1700 (First Gen 8c/16t)
                { "250", 16, 3.00 },
                // "260" mapped to Ryzen 7 2700 (Second Gen 8c/16t)
                { "260", 16, 3.20 },
                { "2700", 16, 3.20 },
                { "2700e", 16, 2.80 },
                { "2700u", 8, 2.20 },
                { "2700x", 16, 3.70 },
                { "2800h", 8, 3.30 },
                { "3700c", 8, 2.30 },
                { "3700u", 8, 2.30 },
                { "3700x", 16, 3.60 },
                { "3750h", 8, 2.30 },
                { "3780u", 8, 2.30 },
                { "3800x", 16, 3.90 },
                { "3800xt", 16, 3.90 },
                { "4700g", 16, 3.60 },
                { "4700ge", 16, 3.10 },
                { "4700u", 8, 2.00 },
                { "4800h", 16, 2.90 },
                { "4800hs", 16, 2.90 },
                { "4800u", 16, 1.80 },
                { "4980u", 16, 2.00 },
                { "5700", 16, 3.70 },
                { "5700g", 16, 3.80 },
                { "5700ge", 16, 3.20 },
                { "5700u", 16, 1.80 },
                { "5700x", 16, 3.40 },
                { "5700x3d", 16, 3.00 },
                { "5705g", 16, 3.80 },
                { "5705ge", 16, 3.20 },
                { "5800", 16, 3.40 },
                { "5800h", 16, 3.20 },
                { "5800hs", 16, 2.80 },
                { "5800u", 16, 1.90 },
                { "5800x", 16, 3.80 },
                { "5800x3d", 16, 3.40 },
                { "5800xt", 16, 3.80 },
                { "5825c", 16, 2.00 },
                { "5825u", 16, 2.00 },
                { "6800h", 16, 3.20 },
                { "6800hs", 16, 3.20 },
                { "6800u", 16, 2.70 },
                { "7435hs", 16, 3.10 },
                { "7700", 16, 3.80 },
                { "7700x", 16, 4.50 },
                { "7730u", 16, 2.00 },
                { "7735hs", 16, 3.20 },
                { "7735u", 16, 2.70 },
                { "7736u", 16, 2.70 },
                { "7745hx", 16, 3.60 },
                { "7800x3d", 16, 4.20 },
                { "7840hs", 16, 3.80 },
                { "7840hx", 24, 3.00 },
                { "7840u", 16, 3.30 },
                { "8700f", 16, 4.10 },
                { "8700g", 16, 4.20 },
                { "8840hs", 16, 3.30 },
                { "8840u", 16, 3.30 },
                { "8845hs", 16, 3.80 },
                { "9700x", 16, 3.80 },
                { "9800x3d", 16, 4.70 },
                { "4750g", 16, 3.60 },
                { "4750ge", 16, 3.10 },
                { "4750u", 16, 1.70 },
                { "5750g", 16, 3.80 },
                { "5750ge", 16, 3.20 },
                { "5755g", 16, 3.80 },
                { "5755ge", 16, 3.20 },
                { "5845", 16, 3.40 },
                { "5850u", 16, 1.90 },
                { "5875u", 16, 2.00 },
                { "6850h", 16, 3.20 },
                { "6850hs", 16, 3.20 },
                { "6850u", 16, 2.70 },
                { "6860z", 16, 2.70 },
                { "7745", 16, 3.60 },
                // "270" mapped to Ryzen 7 3700X (Third Gen 8c/16t)
                { "270", 16, 3.60 },
                { "3900", 24, 3.10 },
                { "3900x", 24, 3.80 },
                { "3900xt", 24, 3.80 },
                { "3950x", 32, 3.50 },
                { "4900h", 16, 3.30 },
                { "4900hs", 16, 3.00 },
                { "5900", 24, 3.00 },
                { "5900hs", 16, 3.00 },
                { "5900hx", 16, 3.30 },
                { "5900x", 24, 3.70 },
                { "5900xt", 32, 3.30 },
                { "5950x", 32, 3.40 },
                { "5980hs", 16, 3.00 },
                { "5980hx", 16, 3.30 },
                { "6900hs", 16, 3.30 },
                { "6900hx", 16, 3.30 },
                { "6980hs", 16, 3.30 },
                { "6980hx", 16, 3.30 },
                { "7845hx", 24, 3.00 },
                { "7900", 24, 3.70 },
                { "7900x", 24, 4.70 },
                { "7900x3d", 24, 4.40 },
                { "7940hs", 16, 4.00 },
                { "7940hx", 32, 2.40 },
                { "7945hx", 32, 2.50 },
                { "7945hx3d", 32, 2.30 },
                { "7950x", 32, 4.50 },
                { "7950x3d", 32, 4.20 },
                { "8945hs", 16, 4.00 },
                { "9850hx", 24, 2.40 },
                { "9900x", 24, 4.40 },
                { "9900x3d", 24, 4.40 },
                { "9950x", 32, 4.30 },
                { "9950x3d", 32, 4.30 },
                { "9955hx", 32, 2.40 },
                { "5945", 24, 4.10 },
                { "6950h", 16, 3.30 },
                { "6950hs", 16, 3.30 },
                { "7945", 24, 4.70 },
                { "1900x", 16, 3.80 },
                { "1920x", 24, 3.50 },
                { "1950x", 32, 3.40 },
                { "2920x", 24, 3.50 },
                { "2950x", 32, 3.50 },
                { "2970wx", 48, 3.00 },
                { "2990wx", 64, 3.00 },
                { "3960x", 48, 3.80 },
                { "3970x", 64, 3.70 },
                { "3990x", 128, 2.90 },
                { "7960x", 48, 4.20 },
                { "7970x", 64, 4.00 },
                { "7980x", 128, 3.20 },
                { "3945wx", 24, 4.00 },
                { "3955wx", 32, 3.90 },
                { "3975wx", 64, 3.50 },
                { "3995wx", 128, 2.70 },
                { "5945wx", 24, 4.10 },
                { "5955wx", 32, 4.00 },
                { "5965wx", 48, 3.80 },
                { "5975wx", 64, 3.60 },
                { "5995wx", 128, 2.70 },
                { "7945wx", 24, 4.70 },
                { "7955wx", 32, 4.50 },
                { "7965wx", 48, 4.20 },
                { "7975wx", 64, 4.00 },
                { "7985wx", 128, 3.20 },
                { "7995wx", 192, 2.50 },

                // Sempron
                { "2650", 2, 1.45 },
                { "3850", 4, 1.30 },

                // Z-Series
                { "z1", 12, 3.20 }
            };
            out_ptr = db;
            out_size = sizeof(db) / sizeof(cpu_entry);
        }
    };


    static void str_copy(char* dest, const char* src, size_t max_len) {
        size_t i = 0;
        while (src[i] != '\0' && i < max_len - 1) {
            dest[i] = src[i];
            i++;
        }
        dest[i] = '\0';
    }

    static void str_cat(char* dest, const char* src, size_t max_len) {
        size_t i = 0;
        while (dest[i] != '\0') i++;
        size_t j = 0;
        while (src[j] != '\0' && i < max_len - 1) {
            dest[i++] = src[j++];
        }
        dest[i] = '\0';
    }

    static bool str_eq(const char* a, const char* b) {
        if (a == b) return true;
        if (!a || !b) return false;
        while (*a && *b) {
            if (*a != *b) return false;
            a++; b++;
        }
        return *a == *b;
    }

    // memoization
    struct memo {
        struct data_t {
            bool result;
            u8 points;
            bool cached;
            const char* brand_name; 
        };
        struct cache_entry {
            bool result;
            u8 points;
            bool has_value;
            const char* brand_name; 
        };

        static std::array<cache_entry, enum_size + 1> cache_table;

        static void cache_store(u16 flag, bool result, u8 points, const char* brand = nullptr) {
            if (flag <= enum_size) {
                cache_table[flag] = { result, points, true, brand };
            }
        }

        static bool is_cached(u16 flag) {
            if (flag <= enum_size) {
                return cache_table[flag].has_value;
            }
            return false;
        }

        static data_t cache_fetch(u16 flag) {
            if (flag <= enum_size && cache_table[flag].has_value) {
                return { cache_table[flag].result, cache_table[flag].points, true, cache_table[flag].brand_name };
            }
            return { false, 0, false, nullptr };
        }

        static void uncache(u16 flag) {
            if (flag <= enum_size) {
                cache_table[flag].has_value = false;
                cache_table[flag].brand_name = nullptr;
            }
        }

        struct brand {
            static char brand_cache[512];
            static bool cached;

            static void store(const char* s) {
                str_copy(brand_cache, s, sizeof(brand_cache));
                cached = true;
            }

            static bool is_cached() { return cached; }
            static const char* fetch() { return brand_cache; }
        };

        struct multi_brand {
            static char brand_cache[1024];
            static bool cached;

            static void store(const char* s) {
                str_copy(brand_cache, s, sizeof(brand_cache));
                cached = true;
            }

            static bool is_cached() { return cached; }
            static const char* fetch() { return brand_cache; }
        };

        // helper specifically for conclusion strings
        struct conclusion {
            static char cache[512];
            static bool cached;
            static void store(const char* s) {
                str_copy(cache, s, sizeof(cache));
                cached = true;
            }
            static const char* fetch() { return cache; }
        };

        struct cpu_brand {
            static char brand_cache[128];
            static bool cached;
            static void store(const char* s) {
                str_copy(brand_cache, s, sizeof(brand_cache));
                cached = true;
            }
            static bool is_cached() { return cached; }
            static const char* fetch() { return brand_cache; }
        };

        struct threadcount {
            static u32 threadcount_cache;
            static u32 fetch() {
                if (threadcount_cache != 0) {
                    return threadcount_cache;
                }
                threadcount_cache = std::thread::hardware_concurrency();
                return threadcount_cache;
            }
        };

        struct hyperx {
            static hyperx_state state;
            static bool cached;
            static hyperx_state fetch() { return state; }
            static void store(const hyperx_state p_state) {
                state = p_state;
                cached = true;
            }
            static bool is_cached() { return cached; }
        };

        struct leaf_entry { 
            u32 leaf; 
            bool value;
            bool has_value; 
        };

        struct leaf_cache {
            static constexpr std::size_t CAPACITY = 128;
            static std::array<leaf_entry, CAPACITY> table;
            static std::size_t count;      
            static std::size_t next_index; 

            static bool fetch(u32 leaf, bool& out) {
                for (std::size_t i = 0; i < count; ++i) {
                    if (table[i].has_value && table[i].leaf == leaf) { out = table[i].value; return true; }
                }
                return false;
            }

            static void store(u32 leaf, bool val) {
                for (std::size_t i = 0; i < count; ++i) {
                    if (table[i].leaf == leaf) { table[i].value = val; table[i].has_value = true; return; }
                }
                if (count < CAPACITY) {
                    table[count++] = { leaf, val, true };
                    return;
                }
                // otherwise evict in round-robin fashion
                table[next_index] = { leaf, val, true };
                next_index = (next_index + 1) % CAPACITY;
            }
        };

        struct bios_info {
            static char manufacturer[256];
            static char model[128];
            static bool cached;

            static void store_manufacturer(const char* s) noexcept {
                if (!s) { manufacturer[0] = '\0'; return; }
                const size_t n = strlen(s);
                const size_t cap = sizeof(manufacturer) - 1;
                const size_t tocopy = (n > cap) ? cap : n;
                memcpy(manufacturer, s, tocopy);
                manufacturer[tocopy] = '\0';
                cached = true;
            }
            static void store_model(const char* s) noexcept {
                if (!s) { model[0] = '\0'; return; }
                const size_t n = strlen(s);
                const size_t cap = sizeof(model) - 1;
                const size_t tocopy = (n > cap) ? cap : n;
                memcpy(model, s, tocopy);
                model[tocopy] = '\0';
                cached = true;
            }

            static bool is_cached() noexcept { return cached; }
            static const char* fetch_manufacturer() noexcept { return manufacturer; }
            static const char* fetch_model() noexcept { return model; }
        };

        struct hardened {
            static bool result;
            static bool cached;
        };
    };

    // miscellaneous functionalities
    struct util {
        static bool is_unsupported(const VM::enum_flags flag) {
            // cross platform?
            if (
                (flag >= VM::HYPERVISOR_BIT) &&
                (flag <= VM::KGT_SIGNATURE)
            ) {
                return false;
            }

            #if (LINUX)
                return (!(
                    (flag >= LINUX_START) &&
                    (flag <= LINUX_END)
                ));
            #elif (WINDOWS)
                return (!(
                    (flag >= WINDOWS_START) &&
                    (flag <= WINDOWS_END)
                ));
            #elif (APPLE) 
                return (!(
                    (flag >= MACOS_START) &&
                    (flag <= MACOS_END)
                ));
            #else
                return false;
            #endif
        }

    #if (LINUX)
        // fetch file data
        [[nodiscard]] static std::string read_file(const char* raw_path) {
            std::string path = "";
            const std::string raw_path_str = raw_path;

            // replace the "~" part with the home directory
            if (raw_path[0] == '~') {
                const char* home = std::getenv("HOME");
                if (home) {
                    path = std::string(home) + raw_path_str.substr(1);
                }
            } else {
                path = raw_path;
            }

            if (!exists(path.c_str())) {
                return "";
            }

            std::ifstream file{};
            std::string data{};
            std::string line{};

            file.open(path);

            if (file.is_open()) {
                while (std::getline(file, line)) {
                    data += line + "\n";
                }
            }

            file.close();
            return data;
        }

        [[nodiscard]] static bool exists(const char* path) {
        #if (VMA_CPP >= 17)
            return std::filesystem::exists(path);
        #elif (VMA_CPP >= 11)
            struct stat buffer;
            return (stat(path, &buffer) == 0);
        #endif
        }

        static bool is_directory(const char* path) {
            struct stat info;
            if (stat(path, &info) != 0) {
                return false;
            }
            return (info.st_mode & S_IFDIR); // check if directory
        };
    #endif

        // fetch the file but in binary form
        [[nodiscard]] static std::vector<u8> read_file_binary(const char* file_path) {
            std::ifstream file(file_path, std::ios::binary);

            if (!file) {
                return {};
            }

            std::vector<u8> buffer;
            std::istreambuf_iterator<char> it(file);
            std::istreambuf_iterator<char> end;

            while (it != end) {
                buffer.push_back(static_cast<u8>(*it));
                ++it;
            }

            file.close();

            return buffer;
        }


        // wrapper for std::make_unique because it's not available for C++11
        template<typename T, typename... Args>
        [[nodiscard]] static std::unique_ptr<T> make_unique(Args&&... args) {
        #if (VMA_CPP < 14)
            return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
        #else
            return std::make_unique<T>(std::forward<Args>(args)...);
        #endif
        }


        [[nodiscard]] static bool is_admin() noexcept {
        #if (LINUX || APPLE)
            const uid_t uid = getuid();
            const uid_t euid = geteuid();

            return (
                (uid != euid) ||
                (euid == 0)
            );
        #elif (WINDOWS)
            bool is_admin = false;
            HANDLE hToken = nullptr;
            const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);
            if (OpenProcessToken(current_process, TOKEN_QUERY, &hToken)) {
                TOKEN_ELEVATION elevation{};
                DWORD dwSize;
                if (GetTokenInformation(hToken, TokenElevation, &elevation, sizeof(elevation), &dwSize)) {
                    if (elevation.TokenIsElevated)
                        is_admin = true;
                }
                CloseHandle(hToken);
            }
            return is_admin;
        #else
            return true;
        #endif
        }


        [[nodiscard]] static bool find(const std::string& base_str, const char* keyword) noexcept {
            return (base_str.find(keyword) != std::string::npos);
        };

        static std::string narrow_wide(const wchar_t* wstr) {
            if (!wstr) return std::string{};
            std::wstring ws(wstr);
            std::string result;
            result.reserve(ws.size());
            for (wchar_t wc : ws) {
                result.push_back((wc >= 0 && wc < 128)
                    ? static_cast<char>(wc)
                    : '?');
            }
            return result;
        }

        // choose correct << or narrow for each type
        static void write_arg_impl(std::ostream& os, const wchar_t* arg) {
            os << narrow_wide(arg);
        }
        static void write_arg_impl(std::ostream& os, wchar_t* arg) {
            os << narrow_wide(arg);
        }

        static void write_arg_impl(std::ostream& os, const std::wstring& ws) {
            os << narrow_wide(ws.c_str());
        }

        // everything else that is not std::string or wchar_t
        template <typename T>
        static typename std::enable_if<!std::is_convertible<T, std::wstring>::value
            && !std::is_same<typename std::decay<T>::type, wchar_t*>::value,
            void>::type
            write_arg_impl(std::ostream& os, T&& arg) {
            os << std::forward<T>(arg);
        }

        // variadic pack printer for C++11
        static inline void print_to_stream(std::ostream& /*unused*/) noexcept {}

        // forward the first, then expand the rest in an initializer list
        template <typename T, typename... Args>
        static void print_to_stream(std::ostream& os,
            T&& first,
            Args&&... args) noexcept
        {
            write_arg_impl(os, std::forward<T>(first));
            // trick to expand the pack
            using expander = int[];
            (void)expander {
                0, ((void)write_arg_impl(os, std::forward<Args>(args)), 0)...
            };
        }

        template <typename... Args>
        static inline void debug_msg(Args&&... message) noexcept {
            static std::unordered_set<std::string> printed_messages;

            std::stringstream ss;
            print_to_stream(ss, std::forward<Args>(message)...);
            std::string msg_content = ss.str();

            if (printed_messages.find(msg_content) == printed_messages.end()) {
        #if (LINUX || APPLE)
                constexpr const char* black_bg = "\x1B[48;2;0;0;0m";
                constexpr const char* bold = "\033[1m";
                constexpr const char* blue = "\x1B[38;2;00;59;193m";
                constexpr const char* ansiexit = "\x1B[0m";

                std::cout.setf(std::ios::fixed, std::ios::floatfield);
                std::cout.setf(std::ios::showpoint);

                std::cout << black_bg
                    << bold << "["
                    << blue << "DEBUG"
                    << ansiexit << bold << black_bg << "]"
                    << ansiexit << " ";
        #else
                std::cout << "[DEBUG] ";
        #endif
                std::cout << msg_content;
                std::cout << std::dec << "\n";

                printed_messages.insert(std::move(msg_content));
            }
        }


        [[nodiscard]] static std::unique_ptr<std::string> sys_result(const char* cmd) {
        #if (VMA_CPP < 14)
            VMAWARE_UNUSED(cmd);
            return util::make_unique<std::string>();
        #else
            #if (LINUX || APPLE)
                struct file_deleter {
                    void operator()(FILE* f) const noexcept {
                        if (f) {
                            pclose(f);
                        };
                    }
                };

                std::unique_ptr<FILE, file_deleter> pipe(popen(cmd, "r"), file_deleter());
                if (!pipe) {
                    return util::make_unique<std::string>();
                }

                std::string result;
                char* line = nullptr;

                // to ensure line is freed even if string::append throws std::bad_alloc
                struct line_guard {
                    char*& ptr;
                    ~line_guard() { if (ptr) free(ptr); }
                } guard{ line };

                size_t len = 0;
                ssize_t nread;

                while ((nread = getline(&line, &len, pipe.get())) != -1) {
                    result.append(line, static_cast<size_t>(nread));
                }

                if (!result.empty() && result.back() == '\n') {
                    result.pop_back();
                }

                return util::make_unique<std::string>(std::move(result));
            #else
                VMAWARE_UNUSED(cmd);
                return std::make_unique<std::string>();
            #endif
        #endif
        }


        [[nodiscard]] static bool is_proc_running(const char* executable) {
        #if (LINUX)
            #if (VMA_CPP >= 17)
                for (const auto& entry : std::filesystem::directory_iterator("/proc")) {
                    if (!entry.is_directory()) {
                        continue;
                    }

                    const std::string filename = entry.path().filename().string();
            #else
                std::unique_ptr<DIR, decltype(&closedir)> dir(opendir("/proc"), closedir);
                if (!dir) {
                    debug("util::is_proc_running: ", "failed to open /proc directory");
                    return false;
                }

                struct dirent* entry;
                while ((entry = readdir(dir.get())) != nullptr) {
                    std::string filename(entry->d_name);
                    if (filename == "." || filename == "..") {
                        continue;
                    }
            #endif
                if (!std::all_of(filename.begin(), filename.end(), [](u8 c) { return std::isdigit(c); })) {
                    continue;
                }

                const std::string cmdline_file = "/proc/" + filename + "/cmdline";

                // read raw bytes (binary) to preserve embedded NULs
                std::ifstream ifs(cmdline_file, std::ios::in | std::ios::binary);
                if (!ifs.is_open()) {
                    continue;
                }

                // read entire file into vector<char>
                std::vector<char> buf((std::istreambuf_iterator<char>(ifs)), std::istreambuf_iterator<char>());
                ifs.close();

                if (buf.empty()) {
                    continue;
                }

                // cmdline is argv0\0argv1\0..., so argv0 is bytes up to first NUL
                const auto it_nul = std::find(buf.begin(), buf.end(), '\0');
                if (it_nul == buf.begin()) {
                    continue;
                }

                std::string argv0(buf.begin(), it_nul);
                if (argv0.empty()) {
                    continue;
                }

                // extract basename of argv0
                const std::size_t slash_index = argv0.find_last_of('/');
                std::string basename = (slash_index == std::string::npos) ? argv0 : argv0.substr(slash_index + 1);

                if (basename != executable) {
                    continue;
                }

                return true;
            }

            return false;
        #else
            VMAWARE_UNUSED(executable);
            return false;
        #endif
        }


        [[nodiscard]] static bool is_running_under_translator() {
        #if (WINDOWS && _WIN32_WINNT >= _WIN32_WINNT_WIN10)
            const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);
            USHORT procMachine = 0, nativeMachine = 0;
            const auto pIsWow64Process2 = &IsWow64Process2;

            if (pIsWow64Process2(current_process, &procMachine, &nativeMachine)) {
                if (nativeMachine == IMAGE_FILE_MACHINE_ARM64 &&
                    (procMachine == IMAGE_FILE_MACHINE_AMD64 || procMachine == IMAGE_FILE_MACHINE_I386)) {
                    debug("Translator detected x64/x86 process on ARM64");
                    return true;
                }
            }

            // only if we got MACHINE_UNKNOWN on process but native is ARM64
            if (nativeMachine == IMAGE_FILE_MACHINE_ARM64) {
                using get_process_information = BOOL(__stdcall*)(HANDLE, PROCESS_INFORMATION_CLASS, PVOID, DWORD);
                const HMODULE ntdll = util::get_ntdll();
                if (ntdll == nullptr) {
                    return false;
                }

                const char* names[] = { "GetProcessInformation" };
                void* funcs[1] = { nullptr };
                util::get_function_address(ntdll, names, funcs, 1);

                get_process_information get_proc_info = reinterpret_cast<get_process_information>(funcs[0]);
                if (get_proc_info) {
                    struct PROCESS_MACHINE_INFORMATION {
                        USHORT ProcessMachine;
                        USHORT Res0;
                        DWORD  MachineAttributes;
                    } pmInfo = {};
                    // ProcessMachineTypeInfo == 9 per MS Q&A
                    if (get_proc_info(current_process, (PROCESS_INFORMATION_CLASS)9, &pmInfo, sizeof(pmInfo))) {
                        if (pmInfo.ProcessMachine == IMAGE_FILE_MACHINE_AMD64 || pmInfo.ProcessMachine == IMAGE_FILE_MACHINE_I386) {
                            debug("Translator detected x64/x86 process on ARM64 by fallback");
                            return true;
                        }
                    }
                }
            }
        #endif

            if (cpu::is_leaf_supported(cpu::leaf::hypervisor)) {
                const std::string vendor = cpu::cpu_manufacturer(cpu::leaf::hypervisor);
                
                if (vendor == "VirtualApple" ||   // Apple Rosetta
                    vendor == "PowerVM Lx86")     // IBM PowerVM Lx86
                {
                    return true;
                }
            }

        #if (WINDOWS)
            const std::string& brand = cpu::get_brand();
            if (brand.find("Virtual CPU") != std::string::npos) {
                return true;
            }
        #endif

            return false;
        }


        /**
         * @brief Check whether the system is running in a Hyper-V virtual machine or if the host system has Hyper-V enabled
         * @note Hyper-V's presence on a host system can set certain hypervisor-related CPU flags that may appear similar to those in a virtualized environment, which can make it challenging to differentiate between an actual Hyper-V virtual machine (VM) and a host system with Hyper-V enabled.
         *       This can lead to false conclusions, where the system might mistakenly be identified as running in a Hyper-V VM, when in reality, it's simply the host system with Hyper-V features active.
         *       This check aims to distinguish between these two cases by identifying specific CPU flags and hypervisor-related artifacts that are indicative of a Hyper-V VM rather than a host system with Hyper-V enabled.
         * @returns hyperx_state enum indicating the detected state:
         *          - HYPERV_ARTIFACT_VM for host with Hyper-V enabled
         *          - HYPERV_REAL_VM for real Hyper-V VM
         *          - HYPERV_ENLIGHTENMENT for QEMU with Hyper-V enlightenments
         *          - HYPERV_UNKNOWN for unknown/undetected state
         */
        [[nodiscard]] static hyperx_state hyper_x() {
        #if (!WINDOWS)
            return HYPERV_UNKNOWN;
        #else
            if (memo::hyperx::is_cached()) {
                debug("HYPER_X: returned from cache");
                return memo::hyperx::fetch();
            }

            // Check if hypervisor feature bit in CPUID Leaf 1, ECX bit 31 is enabled
            auto is_hyperv_present = []() noexcept -> bool {
                u32 unused, ecx = 0;
                cpu::cpuid(unused, unused, ecx, unused, 1);

                return (ecx >> 31) & 1;
            };

            // 0x40000003 on EBX indicates the flags that a parent partition specified to create a child partition (https://learn.microsoft.com/en-us/virtualization/hyper-v-on-windows/tlfs/datatypes/hv_partition_privilege_mask)
            // some CPU models like N-models (N4200, etc) expose 0x40000003 leaves without exposing the hypervisor bit
            auto is_root_partition = []() noexcept -> bool {
                u32 ebx, unused = 0;
                cpu::cpuid(unused, ebx, unused, unused, 0x40000003);

                return (ebx & 1);
            };

            /**
              * On Hyper-V virtual machines, the cpuid function reports an EAX value of 11
              * This value is tied to the Hyper-V partition model, where each virtual machine runs as a child partition
              * These child partitions have limited privileges and access to hypervisor resources, 
              * which is reflected in the maximum input value for hypervisor CPUID information as 11
              * Essentially, it indicates that the hypervisor is managing the VM and that the VM is not running directly on hardware but rather in a virtualized environment
            */
            auto eax = []() noexcept -> u32 {
                u32 eax_reg, unused = 0;
                cpu::cpuid(eax_reg, unused, unused, unused, cpu::leaf::hypervisor);

                // truncation is intentional
                return eax_reg & 0xFF;
            };

            hyperx_state state = HYPERV_UNKNOWN;

            if (!is_root_partition()) {
                if (eax() == 11 && is_hyperv_present()) {
                    // Windows machine running under Hyper-V type 2
                    debug("HYPER_X: Detected Hyper-V guest VM");
                    core::add(brands::HYPERV);
                    state = HYPERV_REAL_VM;
                }
                else {
                    debug("HYPER_X: Hyper-V is not active");
                    state = HYPERV_UNKNOWN;
                }
            }
            else {
                const std::string brand_str = cpu::cpu_manufacturer(0x40000100);
                
                if (util::find(brand_str, "KVM")) {
                    debug("HYPER_X: Detected Hyper-V enlightenments");
                    core::add(brands::QEMU_KVM_HYPERV);
                    state = HYPERV_ENLIGHTENMENT;
                }
                else {
                    // Windows machine running under Hyper-V type 1
                    debug("HYPER_X: Detected Hyper-V host machine");
                    core::add(brands::HYPERV_ARTIFACT);
                    state = HYPERV_ARTIFACT_VM;
                } 
            }

            memo::hyperx::store(state);

            return state;
        #endif
        }

        // For strings shorter than 16-32 bytes, the overhead of setting up the _mm_crc32_u64 (or 32) loop, then checking length, handling the tail bytes, and finally handling alignment, 
        // will always make it slower or equal to a simple unrolled u8 loop, and not every cpu model fits in u32/u64
        #if (x86 && (CLANG || GCC))
            __attribute__((__target__("crc32")))
        #endif
        static u32 crc32(u32 crc, char data) {
        #if (x86)
            return _mm_crc32_u8(crc, static_cast<u8>(data));
        #else
            // Fallback for non-x86: use software CRC32-C
            crc ^= static_cast<u8>(data);
            for (int i = 0; i < 8; ++i)
                crc = (crc >> 1) ^ ((crc & 1) ? 0x82F63B78u : 0);
            return crc;
        #endif
        }

        // to search in our databases, we want to precompute hashes at compile time for C++11 and later
        // so we need to match the hardware _mm_crc32_u8, it is based on CRC32-C (Castagnoli) polynomial
        struct constexpr_hash {
            // it does 8 rounds of CRC32-C bit reflection recursively
            static constexpr u32 crc32_bits(u32 crc, int bits) {
                return (bits == 0) ? crc :
                    crc32_bits((crc >> 1) ^ ((crc & 1) ? 0x82F63B78u : 0), bits - 1);
            }

            // over string
            static constexpr u32 crc32_str(const char* s, u32 crc) {
                return (*s == '\0') ? crc :
                    crc32_str(s + 1, crc32_bits(crc ^ static_cast<u8>(*s), 8));
            }

            static constexpr u32 get(const char* s) {
                return crc32_str(s, 0);
            }
        };

        // this forces the compiler to calculate the hash when initializing the array while staying C++11 compatible
        struct thread_entry {
            u32 hash;
            u32 threads;
            constexpr thread_entry(const char* m, u32 t) : hash(constexpr_hash::get(m)), threads(t) {}
        };

        enum class cpu_type {
            INTEL_I,
            INTEL_XEON,
            AMD
        };

        // 4 arguments to stay compliant with x64 __fastcall (just in case)
        [[nodiscard]] static bool verify_thread_count(const thread_entry* db, size_t db_size, size_t max_model_len, cpu_type type) {
            // to save a few cycles
            struct hasher {
                static u32 crc32_sw(u32 crc, char data) {
                    crc ^= static_cast<u8>(data);
                    for (int i = 0; i < 8; ++i)
                        crc = (crc >> 1) ^ ((crc & 1) ? 0x82F63B78u : 0);
                    return crc;
                }

                using hashfc = u32(*)(u32, char);

                static hashfc get() {
                    // yes, vmaware runs on dinosaur cpus without sse4.2 pretty often
                    i32 regs[4];
                    cpu::cpuid(regs, 1);
                    const bool has_sse42 = (regs[2] & (1 << 20)) != 0;

                    return has_sse42 ? util::crc32 : crc32_sw;
                }
            };

            std::string model_string;
            const char* debug_tag = "";

            if (type == cpu_type::AMD) {
                if (!cpu::is_amd()) {
                    return false;
                }
                model_string = cpu::get_brand();
                debug_tag = "AMD_THREAD_MISMATCH";
            }
            else {
                if (!cpu::is_intel()) {
                    return false;
                }

                const cpu::model_struct model = cpu::get_model();

                if (!model.found) {
                    return false;
                }

                if (type == cpu_type::INTEL_I) {
                    if (!model.is_i_series) {
                        return false;
                    }
                    debug_tag = "INTEL_THREAD_MISMATCH";
                }
                else {
                    if (!model.is_xeon) {
                        return false;
                    }
                    debug_tag = "XEON_THREAD_MISMATCH";
                }
                model_string = model.string;
            }

            if (model_string.empty()) return false;

            debug(debug_tag, ": CPU model = ", model_string);

            const char* str = model_string.c_str();
            u32 expected_threads = 0;
            bool found = false;
            size_t best_len = 0;

            // manual collision fix for Z1 Extreme (16) vs Z1 (12)
            // this is a special runtime check because "z1" is a substring of "z1 extreme" tokens
            // and both might be hashed. VMAware should prioritize 'extreme' if found
            u32 z_series_threads = 0;

            const auto hash_func = hasher::get();

            for (size_t i = 0; str[i] != '\0'; ) {
                char c = str[i];
                if (!((c >= '0' && c <= '9') || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))) {
                    i++;
                    continue;
                }

                u32 current_hash = 0;
                size_t current_len = 0;
                size_t j = i;

                while (true) {
                    char k = str[j];
                    const bool is_valid = (k >= '0' && k <= '9') ||
                        (k >= 'A' && k <= 'Z') ||
                        (k >= 'a' && k <= 'z') ||
                        (k == '-'); // models have hyphen
                    if (!is_valid) break;

                    if (current_len >= max_model_len) {
                        while (str[j] != '\0' && str[j] != ' ') j++; // fast forward to space/null
                        break;
                    }

                    /*
                       models are usually 8 or more bytes long, i.e. i9-10900K
                       so imagine we want to use u64, you hash the first 8 bytes i9-10900
                       but then you are left with K. You have to handle the tail
                       fetching 8 bytes would include the characters after the token, corrupting the hash
                       so a byte-by-byte loop is the most optimal choice here
                    */

                    // convert to lowercase on-the-fly to match compile-time keys
                    if (type == cpu_type::AMD && (k >= 'A' && k <= 'Z')) k += 32;

                    // since this technique is cross-platform, we cannot use a standard C++ try-catch block to catch a missing CPU instruction
                    // we could use preprocessor directives and add an exception handler (VEH/SEH or SIGHANDLER) but nah
                    current_hash = hash_func(current_hash, k);
                    current_len++;
                    j++;

                    // only verify match if the token has ended (next char is not alphanumeric)
                    const char next = str[j];
                    const bool next_is_alnum = (next >= '0' && next <= '9') ||
                        (next >= 'A' && next <= 'Z') ||
                        (next >= 'a' && next <= 'z');

                    if (!next_is_alnum) {
                        // Check specific Z1 Extreme token
                        // Hash for "extreme" (CRC32-C) is 0x3D09D5B4
                        if (type == cpu_type::AMD && current_hash == 0x3D09D5B4) { z_series_threads = 16; }

                        // since it's a contiguous block of integers in .rodata/.rdata, this is extremely fast
                        for (size_t idx = 0; idx < db_size; ++idx) {
                            if (db[idx].hash == current_hash) {
                                if (current_len > best_len) {
                                    best_len = current_len;
                                    expected_threads = db[idx].threads;
                                    found = true;
                                }
                                // since hashing implies uniqueness in this dataset, you might say we could break here,
                                // but we continue to ensure we find the longest substring match if overlaps exist,
                                // so like it finds both "i9-11900" and "i9-11900K" i.e.
                            }
                        }
                    }
                }
                i = j;
            }

            // Z1 Extreme fix
            if (type == cpu_type::AMD && z_series_threads != 0 && expected_threads == 12) {
                expected_threads = z_series_threads;
            }

            if (found) {
                const u32 actual = memo::threadcount::fetch();
                if (actual != expected_threads) {
                    debug(debug_tag, ": Expected threads -> ", expected_threads);
                    VMAWARE_UNUSED(debug_tag); // if compiled in release mode, silence the unused variable warning
                    return true;
                }
            }

            return false;
        }

    #if (WINDOWS)
        // retrieves the addresses of specified functions from a loaded module using the export directory, manual implementation of GetProcAddress
        static void get_function_address(const HMODULE hModule, const char* names[], void** functions, size_t count) {
            using func_map = std::unordered_map<std::string, void*>;
            static std::unordered_map<HMODULE, func_map> function_cache;

            for (size_t i = 0; i < count; ++i) functions[i] = nullptr;
            if (!hModule) return;

            BYTE* base = reinterpret_cast<BYTE*>(hModule);

            size_t module_size = 0;
            {
                MEMORY_BASIC_INFORMATION mbi = {};
                if (VirtualQuery(base, &mbi, sizeof(mbi))) {
                    module_size = static_cast<size_t>(mbi.RegionSize);
                }
                else {
                    return;
                }
            }

            auto valid_range = [&](size_t offset, size_t sz) noexcept -> bool {
                return (sz > 0) && (offset < module_size) && (sz <= module_size - offset);
            };

            auto cstr_from_rva = [&](DWORD rva) noexcept -> const char* {
                if (!valid_range(static_cast<size_t>(rva), 1)) return nullptr;

                const char* start = reinterpret_cast<const char*>(base + rva);
                const size_t remaining = module_size - static_cast<size_t>(rva);

                if (std::memchr(start, '\0', remaining)) {
                    return start;
                }

                return nullptr;
            };

            // Validate DOS header 
            if (!valid_range(0, sizeof(IMAGE_DOS_HEADER))) return;
            const auto* dosHeader = reinterpret_cast<const IMAGE_DOS_HEADER*>(base);
            if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE) return;

            // e_lfanew -> NT headers
            if (dosHeader->e_lfanew < 0) return;
            const size_t e_lfanew = static_cast<size_t>(dosHeader->e_lfanew);
            if (!valid_range(e_lfanew, sizeof(IMAGE_NT_HEADERS))) return;
            const auto* ntHeaders = reinterpret_cast<const IMAGE_NT_HEADERS*>(base + e_lfanew);
            if (ntHeaders->Signature != IMAGE_NT_SIGNATURE) return;

            const size_t sizeOfImage = static_cast<size_t>(ntHeaders->OptionalHeader.SizeOfImage);
            if (sizeOfImage != 0 && sizeOfImage > module_size) {
                module_size = sizeOfImage;
            }

            // Check export data directory exists
            if (ntHeaders->OptionalHeader.NumberOfRvaAndSizes <= IMAGE_DIRECTORY_ENTRY_EXPORT) {
                return; // no export directory
            }

            const auto& dd = ntHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
            if (dd.VirtualAddress == 0 || dd.Size == 0) {
                return; // no exports
            }

            // Validate export directory fits
            if (!valid_range(static_cast<size_t>(dd.VirtualAddress), sizeof(IMAGE_EXPORT_DIRECTORY))) {
                return;
            }

            const auto* exportDir = reinterpret_cast<const IMAGE_EXPORT_DIRECTORY*>(base + dd.VirtualAddress);

            const DWORD nameCount = exportDir->NumberOfNames;
            const DWORD funcCount = exportDir->NumberOfFunctions;

            constexpr DWORD MAX_NAMES = 1u << 20; // 1M names is absurd but protective
            if (nameCount == 0 || nameCount > MAX_NAMES) return;
            if (funcCount == 0 || funcCount > MAX_NAMES) return;

            const DWORD addr_names = exportDir->AddressOfNames;
            const DWORD addr_funcs = exportDir->AddressOfFunctions;
            const DWORD addr_ord = exportDir->AddressOfNameOrdinals;

            if (!valid_range(static_cast<size_t>(addr_names), static_cast<size_t>(nameCount) * sizeof(DWORD))) return;
            if (!valid_range(static_cast<size_t>(addr_funcs), static_cast<size_t>(funcCount) * sizeof(DWORD))) return;
            if (!valid_range(static_cast<size_t>(addr_ord), static_cast<size_t>(nameCount) * sizeof(WORD))) return;

            const DWORD* nameRvas = reinterpret_cast<const DWORD*>(base + addr_names);
            const DWORD* funcRvas = reinterpret_cast<const DWORD*>(base + addr_funcs);
            const WORD* ordinals = reinterpret_cast<const WORD*>(base + addr_ord);

            func_map& module_cache = function_cache[hModule];

            for (size_t i = 0; i < count; ++i) {
                const char* current_name = names[i];
                if (!current_name) continue;
                const std::string s_name(current_name);

                // check cache first
                const auto cache_it = module_cache.find(s_name);
                if (cache_it != module_cache.end()) {
                    functions[i] = cache_it->second;
                    continue;
                }

                // binary search over names (names array is typically sorted)
                DWORD lo = 0, hi = nameCount;
                while (lo < hi) {
                    const DWORD mid = lo + (hi - lo) / 2;
                    const DWORD midNameRva = nameRvas[mid];
                    const char* midName = cstr_from_rva(midNameRva);
                    if (!midName) { // corrupted string table or something
                        lo = hi;
                        break;
                    }

                    const int cmp = strcmp(current_name, midName);
                    if (cmp > 0) {
                        lo = mid + 1;
                    }
                    else {
                        hi = mid;
                    }
                }

                if (lo < nameCount) {
                    const char* candidateName = cstr_from_rva(nameRvas[lo]);
                    if (candidateName && strcmp(current_name, candidateName) == 0) {
                        const WORD nameOrdinal = ordinals[lo];
                        if (static_cast<DWORD>(nameOrdinal) >= funcCount) continue;
                        const DWORD funcRva = funcRvas[nameOrdinal];
                        if (!valid_range(static_cast<size_t>(funcRva), 1)) continue;
                        void* addr = reinterpret_cast<void*>(base + funcRva);
                        functions[i] = addr;
                        module_cache[s_name] = addr;
                        continue;
                    }
                }
            }
        }


        [[nodiscard]] static HMODULE get_ntdll() {
            static HMODULE cached_ntdll = nullptr;
            if (cached_ntdll != nullptr) {
                return cached_ntdll;
            }

        #ifndef _WINTERNL_
            typedef struct _UNICODE_STRING {
                USHORT Length;
                USHORT MaximumLength;
                PWSTR  Buffer;
            } UNICODE_STRING, * PUNICODE_STRING;

            typedef struct _PEB_LDR_DATA {
                BYTE Reserved1[8];
                PVOID Reserved2[3];
                LIST_ENTRY InMemoryOrderModuleList;
            } PEB_LDR_DATA, * PPEB_LDR_DATA;

            typedef struct _LDR_DATA_TABLE_ENTRY {
                PVOID Reserved1[2];
                LIST_ENTRY InMemoryOrderLinks;
                PVOID Reserved2[2];
                PVOID DllBase;
                PVOID Reserved3[2];
                UNICODE_STRING FullDllName;
                BYTE Reserved4[8];
                PVOID Reserved5[3];
            #pragma warning(push)
            #pragma warning(disable: 4201)
                union {
                    ULONG CheckSum;
                    PVOID Reserved6;
                } DUMMYUNIONNAME;
            #pragma warning(pop)
                ULONG TimeDateStamp;
            } LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

            typedef struct _PEB {
                BYTE Reserved1[2];
                BYTE BeingDebugged;
                BYTE Reserved2[1];
                PVOID Reserved3[2];
                PPEB_LDR_DATA Ldr;
            } PEB, * PPEB;
        #endif

            PPEB peb = nullptr;

        #if (x86_64)
            #if (MSVC && !CLANG)
                peb = reinterpret_cast<PPEB>(__readgsqword(0x60));
            #else
                asm("movq %%gs:0x60, %0" : "=r"(peb));
            #endif
        #elif (x86_32)
            #if (MSVC&& !CLANG)
                peb = reinterpret_cast<PPEB>(__readfsdword(0x30));
            #else
                asm("movl %%fs:0x30, %0" : "=r"(peb));
            #endif
        #endif

            if (!peb) { // not x86 or tampered with
                const HMODULE ntdll = GetModuleHandleW(L"ntdll.dll");
                if (ntdll) cached_ntdll = ntdll;
                return ntdll;
            }

            PPEB_LDR_DATA ldr = peb->Ldr;
            if (!ldr) {
                const HMODULE h = GetModuleHandleW(L"ntdll.dll");
                if (h) cached_ntdll = h;
                return h;
            }

            #ifndef CONTAINING_RECORD
                #define CONTAINING_RECORD(address, type, field) ((type *)((char*)(address) - (size_t)(&((type *)0)->field)))
            #endif

            constexpr WCHAR target_name[] = L"ntdll.dll";
            constexpr size_t target_length = (std::size(target_name) - 1);

            LIST_ENTRY* head = &ldr->InMemoryOrderModuleList;
            // static analyzers don't know that InMemoryOrderModuleList is a circular list managed by the loader
            // so they conservatively assume head->Flink or some cur->Flink might be nullptr
            for (LIST_ENTRY* cur = head->Flink; cur != nullptr && cur != head; cur = cur->Flink) {
                auto* ent = CONTAINING_RECORD(cur, LDR_DATA_TABLE_ENTRY, InMemoryOrderLinks);
                if (!ent) continue;

                auto* fullname = &ent->FullDllName;
                if (!fullname->Buffer || fullname->Length == 0) continue;

                const auto total_chars = static_cast<USHORT>(fullname->Length / sizeof(WCHAR));

                size_t start = total_chars;
                while (start > 0) {
                    const WCHAR c = fullname->Buffer[start - 1];
                    if (c == L'\\' || c == L'/') break;
                    --start;
                }

                const size_t file_length = total_chars - start;
                if (file_length != target_length) continue;

                bool match = true;
                for (size_t i = 0; i < file_length; ++i) {
                    WCHAR a = fullname->Buffer[start + i];
                    WCHAR b = target_name[i];
                    if (a >= L'A' && a <= L'Z') a = static_cast<WCHAR>(a + 32);
                    if (b >= L'A' && b <= L'Z') b = static_cast<WCHAR>(b + 32);
                    if (a != b) { match = false; break; }
                }

                if (match) {
                    cached_ntdll = reinterpret_cast<HMODULE>(ent->DllBase);
                    return cached_ntdll;
                }
            }

            const HMODULE h = GetModuleHandleW(L"ntdll.dll");
            if (h) cached_ntdll = h;
            return h;
        } 


        static bool get_manufacturer_model(const char** out_manufacturer, const char** out_model) {
            if (out_manufacturer) *out_manufacturer = "";
            if (out_model) *out_model = "";

            if (memo::bios_info::is_cached()) {
                if (out_manufacturer) *out_manufacturer = memo::bios_info::fetch_manufacturer();
                if (out_model) *out_model = memo::bios_info::fetch_model();
                return memo::bios_info::fetch_manufacturer()[0] != '\0' || memo::bios_info::fetch_model()[0] != '\0';
            }

            WCHAR wbuf[256]{};
            DWORD cb = sizeof(wbuf);

            char man_tmp[sizeof(memo::bios_info::manufacturer)]{};
            char model_tmp[sizeof(memo::bios_info::model)]{};
            man_tmp[0] = '\0';
            model_tmp[0] = '\0';

            bool got_any = false;

            cb = sizeof(wbuf);
            if (RegGetValueW(HKEY_LOCAL_MACHINE,
                L"HARDWARE\\DESCRIPTION\\System\\BIOS",
                L"SystemManufacturer",
                RRF_RT_REG_SZ,
                nullptr,
                wbuf,
                &cb) == ERROR_SUCCESS && wbuf[0] != L'\0') {
                const int conv = WideCharToMultiByte(CP_UTF8, 0, wbuf, -1, man_tmp, static_cast<int>(sizeof(man_tmp)), nullptr, nullptr);
                if (conv > 0) {
                    man_tmp[sizeof(man_tmp) - 1] = '\0';
                    memo::bios_info::store_manufacturer(man_tmp);
                    got_any = true;
                }
            }

            cb = sizeof(wbuf);
            if (RegGetValueW(HKEY_LOCAL_MACHINE,
                L"HARDWARE\\DESCRIPTION\\System\\BIOS",
                L"SystemProductName",
                RRF_RT_REG_SZ,
                nullptr,
                wbuf,
                &cb) == ERROR_SUCCESS && wbuf[0] != L'\0') {
                const int conv = WideCharToMultiByte(CP_UTF8, 0, wbuf, -1, model_tmp, static_cast<int>(sizeof(model_tmp)), nullptr, nullptr);
                if (conv > 0) {
                    model_tmp[sizeof(model_tmp) - 1] = '\0';
                    memo::bios_info::store_model(model_tmp);
                    got_any = true;
                }
            }

            if (!memo::bios_info::is_cached()) {
                memo::bios_info::cached = true;
            }

            if (out_manufacturer) *out_manufacturer = memo::bios_info::fetch_manufacturer();
            if (out_model) *out_model = memo::bios_info::fetch_model();

            return got_any;
        }
    #endif
    };

private: // START OF PRIVATE VM DETECTION TECHNIQUE DEFINITIONS
    /**
     * @brief Check CPUID output of manufacturer ID for known VMs/hypervisors at leaf 0 and 0x40000000-0x40000100
     * @category x86
     * @implements VM::VMID
     */
     [[nodiscard]] static bool vmid() {
    #if (!x86)
        return false;
    #else
        return (
            cpu::vmid_template(0) ||
            cpu::vmid_template(cpu::leaf::hypervisor) || // 0x40000000
            cpu::vmid_template(cpu::leaf::hypervisor + 0x100) // 0x40000100
        );
    #endif
    }


    /**
     * @brief Check if CPU brand model contains any VM-specific string snippets
     * @category x86
     * @implements VM::CPU_BRAND
     */
    [[nodiscard]] static bool cpu_brand() {
    #if (!x86)
        return false;
    #else
        const std::string& brand = cpu::get_brand();

        // easy shortcut for QEMU
        if (brand.rfind("QEMU Virtual CPU version", 0) == 0) {
            return core::add(brands::QEMU);
        }

        struct cstrview {
            const char* data;
            std::size_t size;
            constexpr cstrview(const char* d, std::size_t s) noexcept
                : data(d), size(s) {
            }
        };

        static constexpr std::array<cstrview, 10> checks{ {
            { "qemu",       4 },
            { "kvm",        3 },
            { "vbox",       4 },
            { "virtualbox", 10},
            { "monitor",    7 },
            { "bhyve",      5 },
            { "hypervisor", 10},
            { "hvisor",     6 },
            { "parallels",  9 },
            { "vmware",     6 }
        } };

        for (auto& v : checks) {
            if (brand.size() < v.size)
                continue;  // too short to match

            if (brand.find(v.data) != std::string::npos) {
                debug("CPU_BRAND: match = ", v.data);

                // For these, we only care that it's virtualized:
                if (v.size == 7  // "monitor"
                    || ((v.size == 6) && (v.data[0] == 'h'))  // "hvisor"
                    || ((v.size == 10) && (v.data[0] == 'h')) // "hypervisor" 
                    ) {
                    return true;
                }

                // Otherwise map to our enums:
                switch (v.size) {
                case 4:  // "qemu" or "vbox"
                    return core::add(v.data[0] == 'q'
                        ? brands::QEMU
                        : brands::VBOX);
                case 3:  // "kvm"
                    return core::add(brands::KVM);
                case 5:  // "bhyve"
                    return core::add(brands::BHYVE);
                case 9:  // "parallels"
                    return core::add(brands::PARALLELS);
                case 10: // "virtualbox"
                    return core::add(brands::VBOX);
                case 6:  // "vmware"
                    return core::add(brands::VMWARE);
                default:
                    return false;
                }
            }
        }

        return false;
    #endif
    }


    /**
     * @brief Check if hypervisor feature bit in CPUID ECX bit 31 is enabled (always false for physical CPUs)
     * @category x86
     * @implements VM::HYPERVISOR_BIT
     */
    [[nodiscard]] static bool hypervisor_bit() {
    #if (!x86)
        return false;
    #else
        u32 eax = 0, ebx = 0, ecx = 0, edx = 0;
        cpu::cpuid(eax, ebx, ecx, edx, 1); 
        constexpr u32 HYPERVISOR_MASK = (1u << 31);

        if (ecx & HYPERVISOR_MASK) {
            if (util::hyper_x() == HYPERV_ARTIFACT_VM) {
                return false;
            }

            return true;
        }

        return false;
    #endif
    }


    /**
     * @brief Check for hypervisor brand string length (would be around 2 characters in a host machine)
     * @category x86
     * @implements VM::HYPERVISOR_STR
     */
    [[nodiscard]] static bool hypervisor_str() {
    #if (!x86)
        return false;
    #else
        if (util::hyper_x() == HYPERV_ARTIFACT_VM) {
            return false;
        }

        char out[sizeof(i32) * 4 + 1] = { 0 }; // e*x size + number of e*x registers + null terminator
        cpu::cpuid(reinterpret_cast<int*>(out), cpu::leaf::hypervisor);

        debug("HYPERVISOR_STR: \neax: ", static_cast<u32>(out[0]),
            "\nebx: ", static_cast<u32>(out[1]),
            "\necx: ", static_cast<u32>(out[2]),
            "\nedx: ", static_cast<u32>(out[3])
        );

        return (std::strlen(out + 4) >= 4);
    #endif  
    }
    

    /**
     * @brief Check for various Bochs-related emulation oversights through CPU checks
     * @category x86
     * @author Discovered by Peter Ferrie, Senior Principal Researcher, Symantec Advanced Threat Research peter_ferrie@symantec.com
     * @implements VM::BOCHS_CPU
     */
    [[nodiscard]] static bool bochs_cpu() {
    #if (!x86)
        return false;
    #else
        const bool intel = cpu::is_intel();
        const bool amd = cpu::is_amd();

        // if neither amd or intel, return false
        if (!(intel || amd)) {
            debug("BOCHS_CPU: neither AMD or Intel detected, returned false");
            return false;
        }

        const std::string brand = cpu::get_brand();

        if (intel) {
            // technique 1: not a valid brand 
            if (brand == "              Intel(R) Pentium(R) 4 CPU        ") {
                debug("BOCHS_CPU: technique 1 found");
                return core::add(brands::BOCHS);
            }
        } else if (amd) {
            // technique 2: "processor" should have a capital P
            if (brand == "AMD Athlon(tm) processor") {
                debug("BOCHS_CPU: technique 2 found");
                return core::add(brands::BOCHS);
            }

            // technique 3: Check for absence of AMD easter egg for K7 and K8 CPUs
            constexpr u32 AMD_EASTER_EGG = 0x8fffffff; // this is the CPUID leaf of the AMD easter egg

            if (!cpu::is_leaf_supported(AMD_EASTER_EGG)) {
                return false;
            }

            u32 unused, eax = 0;
            cpu::cpuid(eax, unused, unused, unused, 1);

            auto is_k7 = [](const u32 eax) noexcept -> bool {
                if ((eax & 0x0FF00F00) != 0x00000600) {
                    return false;
                }

                const u32 model = (eax >> 4) & 0xF;

                return (model - 1) < 4;
            };

            auto is_k8 = [](const u32 eax) noexcept -> bool {
                if (((eax >> 8) & 0xF) != 0xF) {
                    return false;
                }

                const u32 extended_family = (eax >> 20) & 0xFF;

                return extended_family <= 1;
            };

            if (!(is_k7(eax) || is_k8(eax))) {
                return false;
            }

            u32 ecx_bochs = 0;
            cpu::cpuid(unused, unused, ecx_bochs, unused, AMD_EASTER_EGG);

            if (ecx_bochs == 0) {
                return true;
            }
        }

        return false;
    #endif
    }
       
    
    /**
	 * @brief Check if the system's thread count matches the expected thread count for the detected CPU model
     * @category x86
     * @implements VM::THREAD_MISMATCH
     */
    [[nodiscard]] static bool thread_mismatch() {
    #if (!x86)
        return false;
    #else
        const auto& info = cpu::analyze_cpu();

        if (info.found) {
            debug(info.debug_tag, ": CPU model = ", info.model_name);

            const u32 actual = memo::threadcount::fetch();
            if (actual != info.expected_threads) {
                debug(info.debug_tag, ": Current threads -> ", actual);
                debug(info.debug_tag, ": Expected threads -> ", info.expected_threads);
                return true;
            }
        }
        return false;
    #endif
    }


    /**
     * @brief Check for signatures in leaf 0x40000001 in CPUID
     * @link https://www.geoffchappell.com/studies/windows/km/ntoskrnl/inc/shared/hvgdk_mini/hv_hypervisor_interface.htm
     * @link https://github.com/ionescu007/SimpleVisor/blob/master/shvvp.c
     * @category x86
     * @implements VM::CPUID_SIGNATURE
     */
    [[nodiscard]] static bool cpuid_signature() {
    #if (!x86)
        return false;
    #else
        u32 eax, unused = 0;
        cpu::cpuid(eax, unused, unused, unused, 0x40000001);
        VMAWARE_UNUSED(unused);

        constexpr u32 simplevisor = 0x00766853; // " vhS"

        debug("CPUID_SIGNATURE: eax = ", eax);

        if (eax == simplevisor)
            return core::add(brands::SIMPLEVISOR);

        return false;
    #endif
    }
                
                
    /**
     * @brief Check for Intel KGT (Trusty branch) hypervisor signature in CPUID
     * @link https://github.com/intel/ikgt-core/blob/7dfd4d1614d788ec43b02602cce7a272ef8d5931/vmm/vmexit/vmexit_cpuid.c
     * @category x86
     * @implements VM::KGT_SIGNATURE
     */
    [[nodiscard]] static bool intel_kgt_signature() {
    #if (!x86)
        return false;
    #else
        u32 unused, ecx, edx = 0;
        cpu::cpuid(unused, unused, ecx, edx, 0x40000003);

        constexpr u32 ECX_SIG = 0x4D4D5645u; // 'EVMM' -> 0x4D4D5645
        constexpr u32 EDX_SIG = 0x43544E49u;  // 'INTC' -> 0x43544E49

        if (ecx == ECX_SIG && edx == EDX_SIG) {
            return core::add(brands::INTEL_KGT);
        }

        return false;
    #endif
    }


    /**
     * @brief Check for timing anomalies in the system
     * @category x86
     * @implements VM::TIMER
     */
    [[nodiscard]] static bool timer() {
    #if (x86)
        #if (MSVC)
            #define COMPILER_BARRIER() _ReadWriteBarrier()
        #else
            #define COMPILER_BARRIER() asm volatile("" ::: "memory")
        #endif

        // ================ INITIALIZATION STUFF ================

        if (util::is_running_under_translator()) {
            debug("TIMER: Running inside a binary translation layer");
            return false;
        }
        // will be used in cpuid measurements
        u16 cycle_threshold = 800; // average latency of a VMX/SVM VMEXIT alone
        if (util::hyper_x() == HYPERV_ARTIFACT_VM) {
            cycle_threshold = 3250; // if we're running under Hyper-V, make VMAware detect nested virtualization
        }

        // check for RDTSCP support, we will use it later
        int regs[4] = { 0 };
        cpu::cpuid(regs, 0x80000001);
        const bool have_rdtscp = (regs[3] & (1u << 27)) != 0;
        if (!have_rdtscp) {
            debug("TIMER: RDTSCP instruction not supported"); // __rdtscp should be supported nowadays
            return true;
        }

        constexpr u64 ITER_XOR = 100000000ULL;
        constexpr size_t CPUID_ITER = 100; // per leaf
        static constexpr unsigned int leaves[] = {
             0xB, 0xD, 0x4, 0x1, 0x7, 0xA, 0x12, 0x5, 0x40000000u, 0x80000008u, 0x0
        };
        constexpr size_t n_leaves = sizeof(leaves) / sizeof(leaves[0]);

        unsigned hw = std::thread::hardware_concurrency();
        if (hw == 0) hw = 1;

        std::atomic<int> ready_count(0);
        std::atomic<int> state(0);

        std::atomic<u64> t1_start(0), t1_end(0);
        std::atomic<u64> t2_start(0);
        std::atomic<u64> t2_end(0);

        std::vector<u64> samples(100000, 0);

        auto rdtsc = []() noexcept -> u64 {
        #if (MSVC)
            return static_cast<u64>(__rdtsc());
        #else
            return static_cast<u64>(__rdtsc());
        #endif
        };

        struct affinity_cookie {
            bool valid{ false };
        #if (WINDOWS)
            HANDLE thread_handle{ nullptr };
            DWORD_PTR prev_mask{ 0 };
        #elif (LINUX)
            pthread_t thread{ 0 };
            cpu_set_t prev_mask{};
        #endif
        };

        auto set_affinity = [](std::thread& t, unsigned core) -> affinity_cookie {
            affinity_cookie cookie;
        #if (WINDOWS)
            const HANDLE h = static_cast<HANDLE>(t.native_handle());
            const DWORD_PTR mask = static_cast<DWORD_PTR>(1ULL) << core;
            const DWORD_PTR prev = SetThreadAffinityMask(h, mask);
            if (prev != 0) {
                cookie.valid = true;
                cookie.thread_handle = h;
                cookie.prev_mask = prev;
            }
        #elif (LINUX)
            pthread_t ph = t.native_handle();
            cpu_set_t prev;
            if (pthread_getaffinity_np(ph, sizeof(prev), &prev) == 0) {
                cpu_set_t cp;
                CPU_ZERO(&cp);
                CPU_SET(core, &cp);
                (void)pthread_setaffinity_np(ph, sizeof(cp), &cp);
                cookie.valid = true;
                cookie.thread = ph;
                cookie.prev_mask = prev;
            }
        #else
            (void)t; (void)core;
        #endif
            return cookie;
        };

        auto restore_affinity = [](const affinity_cookie& cookie) {
            if (!cookie.valid) return;
        #if (WINDOWS)
            (void)SetThreadAffinityMask(cookie.thread_handle, cookie.prev_mask);
        #elif (LINUX)
            (void)pthread_setaffinity_np(cookie.thread, sizeof(cookie.prev_mask), &cookie.prev_mask);
        #else
            (void)cookie;
        #endif
        };

        thread_local u32 aux = 0;
        auto cpuid = [](unsigned int leaf) noexcept -> u64 {
        #if (MSVC)
            // make regs volatile so writes cannot be optimized out, if this isn't added and the code is compiled in release mode, cycles would be around 40 even under Hyper-V
            volatile int regs[4]{};

            // ensure the CPU pipeline is drained of previous loads before we start the clock
            _mm_lfence();

            // read start time
            const u64 t1 = __rdtsc();

            // prevent the compiler from moving the __cpuid call before the t1 read
            COMPILER_BARRIER();

            __cpuid((int*)regs, static_cast<int>(leaf)); // not using cpu::cpuid to get a chance of inlining

            COMPILER_BARRIER();

            // the idea is to let rdtscp internally wait until cpuid is executed rather than using another memory barrier
            const u64 t2 = __rdtscp(&aux);

            // ensure the read of t2 doesn't bleed into future instructions
            _mm_lfence();

            // Create a dependency on regs so the cast above isn't ignored
            (void)regs[0];

            return t2 - t1;
        #else
            // same logic of above
            unsigned int lo1, hi1, lo2, hi2;

            asm volatile("lfence" ::: "memory");
            asm volatile("rdtsc" : "=a"(lo1), "=d"(hi1) :: "memory");
            COMPILER_BARRIER();

            volatile unsigned int a, b, c, d;

            // this differs from the code above because a, b, c and d are effectively used
            // the compiler must honor the write to a volatile variable
            asm volatile("cpuid"
                : "=a"(a), "=b"(b), "=c"(c), "=d"(d)
                : "a"(leaf)
                : "memory");

            COMPILER_BARRIER();

            asm volatile("rdtscp" : "=a"(lo2), "=d"(hi2) :: "rcx", "memory");
            asm volatile("lfence" ::: "memory");

            const u64 t1 = (u64(hi1) << 32) | lo1;
            const u64 t2 = (u64(hi2) << 32) | lo2;

            return t2 - t1;
        #endif
        };

        auto calculate_latency = [&](const std::vector<u64>& samples_in) -> u64 {
            if (samples_in.empty()) return 0;
            const size_t N = samples_in.size();
            if (N == 1) return samples_in[0];

            // local sorted copy
            std::vector<u64> s = samples_in;
            std::sort(s.begin(), s.end()); // ascending

            // tiny-sample short-circuits
            if (N <= 4) return s.front();

            // median (and works for sorted input)
            auto median_of_sorted = [](const std::vector<u64>& v, size_t lo, size_t hi) -> u64 {
                // this is the median of v[lo..hi-1], requires 0 <= lo < hi
                const size_t len = hi - lo;
                if (len == 0) return 0;
                const size_t mid = lo + (len / 2);
                if (len & 1) return v[mid];
                return (v[mid - 1] + v[mid]) / 2;
            };

            // the robust center: median M and MAD -> approximate sigma
            const u64 M = median_of_sorted(s, 0, s.size());
            std::vector<u64> absdev;
            absdev.reserve(N);
            for (size_t i = 0; i < N; ++i) {
                const u64 d = (s[i] > M) ? (s[i] - M) : (M - s[i]);
                absdev.push_back(d);
            }
            std::sort(absdev.begin(), absdev.end());
            const u64 MAD = median_of_sorted(absdev, 0, absdev.size());
            // convert MAD to an approximate standard-deviation-like measure
            const long double kmad_to_sigma = 1.4826L; // consistent for normal approx
            const long double sigma = (MAD == 0) ? 1.0L : (static_cast<long double>(MAD) * kmad_to_sigma);

            // find the densest small-valued cluster by sliding a fixed-count window
            // this locates the most concentrated group of samples (likely it would be the true VMEXIT cluster)
            // const size_t frac_win = (N * 8 + 99) / 100; // ceil(N * 0.08)
            // const size_t win = std::min(N, std::max(MIN_WIN, frac_win));
            const size_t MIN_WIN = 10;
            const size_t win = std::min(
                N,
                std::max(
                    MIN_WIN,
                    static_cast<size_t>(std::ceil(static_cast<double>(N) * 0.08))
                )
            );
            size_t best_i = 0;
            u64 best_span = (s.back() - s.front()) + 1; // large initial
            for (size_t i = 0; i + win <= N; ++i) {
                const u64 span = s[i + win - 1] - s[i];
                if (span < best_span) {
                    best_span = span;
                    best_i = i;
                }
            }

            // expand the initial window greedily while staying "tight"
            // allow expansion while adding samples does not more than multiply the span by EXPAND_FACTOR
            constexpr long double EXPAND_FACTOR = 1.5L;
            size_t cluster_lo = best_i;
            size_t cluster_hi = best_i + win; // exclusive
            // expand left
            while (cluster_lo > 0) {
                const u64 new_span = s[cluster_hi - 1] - s[cluster_lo - 1];
                if (static_cast<long double>(new_span) <= EXPAND_FACTOR * static_cast<long double>(best_span) ||
                    (s[cluster_hi - 1] <= (s[cluster_lo - 1] + static_cast<u64>(std::ceil(3.0L * sigma))))) {
                    --cluster_lo;
                    best_span = std::min(best_span, new_span);
                }
                else break;
            }
            // expand right
            while (cluster_hi < N) {
                const u64 new_span = s[cluster_hi] - s[cluster_lo];
                if (static_cast<long double>(new_span) <= EXPAND_FACTOR * static_cast<long double>(best_span) ||
                    (s[cluster_hi] <= (s[cluster_lo] + static_cast<u64>(std::ceil(3.0L * sigma))))) {
                    ++cluster_hi;
                    best_span = std::min(best_span, new_span);
                }
                else break;
            }

            const size_t cluster_size = (cluster_hi > cluster_lo) ? (cluster_hi - cluster_lo) : 0;

            // cluster must be reasonably dense and cover a non-negligible portion of samples, so this is pure sanity checks
            const double fraction_in_cluster = static_cast<double>(cluster_size) / static_cast<double>(N);
            const size_t MIN_CLUSTER = std::min(static_cast<size_t>(std::max<int>(5, static_cast<int>(N / 50))), N); // at least 2% or 5 elements
            if (cluster_size < MIN_CLUSTER || fraction_in_cluster < 0.02) {
                // low-percentile (10th) trimmed median
                const size_t fallback_count = std::max<size_t>(1, static_cast<size_t>(std::floor(static_cast<double>(N) * 0.10)));
                // median of lowest fallback_count elements (if fallback_count==1 that's smallest)
                if (fallback_count == 1) return s.front();
                const size_t mid = fallback_count / 2;
                if (fallback_count & 1) return s[mid];
                return (s[mid - 1] + s[mid]) / 2;
            }

            // now we try to get a robust estimate inside the cluster, trimmed mean (10% trim) centered on cluster
            const size_t trim_count = static_cast<size_t>(std::floor(static_cast<double>(cluster_size) * 0.10));
            const size_t lo = cluster_lo + trim_count;
            const size_t hi = cluster_hi - trim_count; // exclusive
            if (hi <= lo) {
                // degenerate -> median of cluster
                return median_of_sorted(s, cluster_lo, cluster_hi);
            }

            // sum with long double to avoid overflow and better rounding
            long double sum = 0.0L;
            for (size_t i = lo; i < hi; ++i) sum += static_cast<long double>(s[i]);
            const long double avg = sum / static_cast<long double>(hi - lo);
            u64 result = static_cast<u64>(std::llround(avg));

            // final sanity adjustments:
            // if the computed result is suspiciously far from the global median (e.g., > +6*sigma)
            // clamp toward the median to avoid choosing a high noisy cluster by mistake
            const long double diff_from_med = static_cast<long double>(result) - static_cast<long double>(M);
            if (diff_from_med > 0 && diff_from_med > (6.0L * sigma)) {
                // clamp to median + 4*sigma (conservative)
                result = static_cast<u64>(std::llround(static_cast<long double>(M) + 4.0L * sigma));
            }

            // also, if result is zero (shouldn't be) or extremely small, return a smallest observed sample
            if (result == 0) result = s.front();

            return result;
        };

        // to touch pages and exercise cpuid paths
        for (int w = 0; w < 128; ++w) {
            volatile u64 tmp = cpuid(leaves[w % n_leaves]);
            VMAWARE_UNUSED(tmp);
        }

        // if hypervisor downscales TSC globally, this will catch it
        const u64 calib_start = rdtsc();
        {
            volatile u64 x = 0xDEADBEEFCAFEBABEULL;
            for (u64 i = 0; i < ITER_XOR; ++i) {
                x ^= i;
                x = (x << 1) ^ (x >> 3);
            }
            VMAWARE_UNUSED(x);
        }
        const u64 calib_end = rdtsc();
        const u64 calib_delta = (calib_end > calib_start) ? (calib_end - calib_start) : 0;

        ready_count.store(0, std::memory_order_release);
        state.store(0, std::memory_order_release);

        // Thread 1: start near same cycle, do XOR work, set end
        std::thread th1([&]() {
            ready_count.fetch_add(1, std::memory_order_acq_rel);
            while (ready_count.load(std::memory_order_acquire) < 2)
                _mm_pause();

            const u64 s = rdtsc();
            t1_start.store(s, std::memory_order_release);
            state.store(1, std::memory_order_release);

            volatile u64 x = 0xDEADBEEFCAFEBABEULL;
            for (u64 i = 0; i < ITER_XOR; ++i) {
                x ^= i;
                x = (x << 1) ^ (x >> 3);
            }
            VMAWARE_UNUSED(x);

            const u64 e = rdtsc();
            t1_end.store(e, std::memory_order_release);
            state.store(2, std::memory_order_release);
        });

        // Thread 2: rdtsc and cpuid spammer, forces hypervisor to downscale TSC if patch is present; if interception disabled, caught by cpuid latency 
        std::thread th2([&]() {
            ready_count.fetch_add(1, std::memory_order_acq_rel);
            while (ready_count.load(std::memory_order_acquire) < 2)
                _mm_pause();

            u64 last = rdtsc();
            t2_start.store(last, std::memory_order_release);

            // local accumulator and local index into samples
            u64 acc = 0;
            size_t idx = 0;

            // for each leaf do CPUID_ITER samples, then repeat
            while (state.load(std::memory_order_acquire) != 2) {
                for (size_t li = 0; li < n_leaves; ++li) {
                    const unsigned int leaf = leaves[li];

                    for (unsigned i = 0; i < CPUID_ITER; ++i) {
                        // read rdtsc and accumulate delta
                        const u64 now = rdtsc();

                        // If now < last, the hypervisor rewound the TSC or it's a very rare 64-bit overflow
                        // we do not increment acc to ensure ratio t2_delta / t1_delta drops below 0.95
                        if (now >= last) {
                            acc += (now - last);
                        }

                        last = now;

                        // store latency if buffer has space
                        if (idx < samples.size()) samples[idx] = cpuid(leaf);
                        ++idx;

                        // if thread1 finished
                        if (state.load(std::memory_order_acquire) == 2) break;
                    }

                    if (state.load(std::memory_order_acquire) == 2) break;
                }
            }

            // final rdtsc after detecting finish
            const u64 final_now = rdtsc();

            if (final_now >= last) {
                acc += (final_now - last);
            }

            last = final_now;

            // publish results
            t2_end.store(acc, std::memory_order_release);
        });

        // try to pin to different cores
        affinity_cookie cookie1{};
        affinity_cookie cookie2{};
        if (hw >= 2) {
            if (hw >= 2) {
                cookie1 = set_affinity(th1, 0);
                cookie2 = set_affinity(th2, 1);
            }
        }

        th1.join();
        th2.join();

        restore_affinity(cookie1);
        restore_affinity(cookie2);

        // collect results
        const u64 a = t1_start.load(std::memory_order_acquire);
        const u64 b = t1_end.load(std::memory_order_acquire);
    #ifdef __VMAWARE_DEBUG__
        const u64 c = t2_start.load(std::memory_order_acquire);
    #endif
        const u64 d = t2_end.load(std::memory_order_acquire);

        const u64 t1_delta = (b > a) ? (b - a) : 0;
        const u64 t2_delta = d;

        std::vector<u64> used;
        for (size_t i = 0; i < samples.size(); ++i)
            if (samples[i] != 0)
                used.push_back(samples[i]);
        const u64 cpuid_latency = calculate_latency(used);

        debug("TIMER: calibration cycles: start=", calib_start, " delta=", calib_delta);
        debug("TIMER: thread1 cycles: start=", a, " delta=", t1_delta);
        debug("TIMER: thread2 cycles: start=", c, " delta=", t2_delta);
        debug("TIMER: vmexit latency: ", cpuid_latency);

        if (cpuid_latency >= cycle_threshold) {
            debug("TIMER: Detected a vmexit on CPUID");
            return core::add(brands::NULL_BRAND, 100); // to prevent FPs due to kernel noise
        }
        else if (cpuid_latency <= 25) {
            debug("TIMER: Detected a hypervisor downscaling CPUID latency");
            // cpuid is fully serializing, no CPU have this low average cycles in real-world scenarios
            // however, in patches, zero or even negative deltas can be seen oftenly
            return true;
        }

        if (t1_delta == 0 || calib_delta == 0) {
            return true;
        }

        const double ratio = double(t2_delta) / double(t1_delta);
        const double calibration_ratio = static_cast<double>(t1_delta) / static_cast<double>(calib_delta);

        // if thread 1 was faster than thread 2, hypervisor downscaled TSC per-vCPU in either cpuid or rdtsc
        if (ratio < 0.95 || ratio > 1.05) {
            debug("TIMER: Detected a hypervisor intercepting TSC");
            return true;
        }
        // if calibration was much faster than thread 1, hypervisor downscaled TSC globally while thread 2 was spamming
        if (calibration_ratio < 0.95) {
            debug("TIMER: Detected a hypervisor intercepting TSC globally");
            return true;
        }

    #if (WINDOWS)
        typedef struct _PROCESSOR_POWER_INFORMATION {
            u32 Number;
            u32 MaxMhz;
            u32 CurrentMhz;
            u32 MhzLimit;
            u32 MaxIdleState;
            u32 CurrentIdleState;
        } PROCESSOR_POWER_INFORMATION, * PPROCESSOR_POWER_INFORMATION;

        enum POWER_INFORMATION_LEVEL_MIN {
            ProcessorInformation = 11
        };

        const HMODULE hPowr = LoadLibraryA("powrprof.dll");
        if (!hPowr) return 0;

        const char* names[] = { "CallNtPowerInformation" };
        void* funcs[1] = { nullptr };
        util::get_function_address(hPowr, names, funcs, 1);
        if (!funcs[0]) return 0;

        using CallNtPowerInformation_t = NTSTATUS(__stdcall*)(int, PVOID, ULONG, PVOID, ULONG);
        CallNtPowerInformation_t CallNtPowerInformation =
            reinterpret_cast<CallNtPowerInformation_t>(funcs[0]);

        SYSTEM_INFO si;
        GetSystemInfo(&si);
        const DWORD procCount = si.dwNumberOfProcessors;
        if (procCount == 0) return 0;

        const SIZE_T bufSize = static_cast<SIZE_T>(procCount) * sizeof(PROCESSOR_POWER_INFORMATION);
        void* raw = _malloca(bufSize);
        if (!raw) return 0;
        memset(raw, 0, bufSize);

        const NTSTATUS status = CallNtPowerInformation(
            ProcessorInformation,
            nullptr, 0,
            raw, static_cast<ULONG>(bufSize)
        );

        unsigned speed = 0;
        if ((LONG)status >= 0) {
            PROCESSOR_POWER_INFORMATION* info = reinterpret_cast<PROCESSOR_POWER_INFORMATION*>(raw);
            speed = static_cast<unsigned>(info[0].CurrentMhz);
        }

        _freea(raw);

        if (speed < 800) {
            debug("TIMER: detected a hook in rdtsc, frequency was: ", speed);
            return true;
        }
    #endif
#endif
        return false;
    }

#if (LINUX)
    /**
     * @brief Check result from systemd-detect-virt tool
     * @category Linux
     * @implements VM::SYSTEMD
     */
    [[nodiscard]] static bool systemd_virt() {
        if (!(util::exists("/usr/bin/systemd-detect-virt") || util::exists("/bin/systemd-detect-virt"))) {
            debug("SYSTEMD: ", "binary doesn't exist");
            return false;
        }

        const std::unique_ptr<std::string> result = util::sys_result("systemd-detect-virt");

        if (result == nullptr) {
            debug("SYSTEMD: ", "invalid stdout output from systemd-detect-virt");
            return false;
        }

        debug("SYSTEMD: ", "output = ", *result);

        return (*result != "none");
    }


    /**
     * @brief Check if the chassis vendor is a VM vendor
     * @category Linux
     * @implements VM::CVENDOR
     */
    [[nodiscard]] static bool chassis_vendor() {
        const char* vendor_file = "/sys/devices/virtual/dmi/id/chassis_vendor";

        if (!util::exists(vendor_file)) {
            debug("CVENDOR: ", "file doesn't exist");
            return false;
        }

        const std::string vendor = util::read_file(vendor_file);

        // TODO: More can definitely be added, only QEMU and VBox were tested so far
        if (util::find(vendor, "QEMU")) { return core::add(brands::QEMU); }
        if (util::find(vendor, "Oracle Corporation")) { return core::add(brands::VBOX); }

        debug("CVENDOR: vendor = ", vendor);

        return false;
    }


    /**
     * @brief Check if the chassis type is valid (it's very often invalid in VMs)
     * @category Linux
     * @implements VM::CTYPE
     */
    [[nodiscard]] static bool chassis_type() {
        const char* chassis = "/sys/devices/virtual/dmi/id/chassis_type";

        if (util::exists(chassis)) {
            return (stoi(util::read_file(chassis)) == 1);
        } else {
            debug("CTYPE: ", "file doesn't exist");
        }

        return false;
    }


    /**
     * @brief Check if /.dockerenv or /.dockerinit file is present
     * @category Linux
     * @implements VM::DOCKERENV
     */
    [[nodiscard]] static bool dockerenv() {
        if (util::exists("/.dockerenv") || util::exists("/.dockerinit")) {
            return core::add(brands::DOCKER);
        }

        return false;
    }


    /**
     * @brief Check if dmidecode output matches a VM brand
     * @category Linux
     * @warning Permissions required
     * @implements VM::DMIDECODE
     */
    [[nodiscard]] static bool dmidecode() {
        if (!util::is_admin()) {
            debug("DMIDECODE: ", "precondition return called (root = ", util::is_admin(), ")");
            return false;
        }

        if (!(util::exists("/bin/dmidecode") || util::exists("/usr/bin/dmidecode"))) {
            debug("DMIDECODE: ", "binary doesn't exist");
            return false;
        }

        const std::unique_ptr<std::string> result = util::sys_result("dmidecode -t system | grep 'Manufacturer|Product' | grep -c \"QEMU|VirtualBox|KVM\"");

        if (!result || result->empty()) {
            debug("DMIDECODE: ", "invalid output");
            return false;
        } else if (*result == "QEMU") {
            return core::add(brands::QEMU);
        } else if (*result == "VirtualBox") {
            return core::add(brands::VBOX);
        } else if (*result == "KVM") {
            return core::add(brands::KVM);
        } else if (std::atoi(result->c_str()) >= 1) {
            return true;
        } else {
            debug("DMIDECODE: ", "output = ", *result);
        }

        return false;
    }


    /**
     * @brief Check if mac address starts with certain VM designated values
     * @category Linux
     * @implements VM::MAC
     */
    [[nodiscard]] static bool mac_address_check() {
        struct fdguard {
            int fd;
            explicit fdguard(int fd = -1) : fd(fd) {}
            ~fdguard() { if (fd != -1) ::close(fd); }
            int get() const { return fd; }
            int release() { int tmp = fd; fd = -1; return tmp; }
        };

        u8 mac[6] = { 0 };
        struct ifreq ifr;
        struct ifconf ifc;
        char buf[1024];
        int success = 0;

        int sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_IP);
        if (sock == -1) {
            return false;
        }
        fdguard sockGuard(sock); // will close on function exit

        ifc.ifc_len = sizeof(buf);
        ifc.ifc_buf = buf;

        if (ioctl(sockGuard.get(), SIOCGIFCONF, &ifc) == -1) {
            return false;
        }

        struct ifreq* it = ifc.ifc_req;
        const struct ifreq* end = it + (ifc.ifc_len / sizeof(struct ifreq));

        for (; it != end; ++it) {
            std::size_t name_len = std::min<std::size_t>(sizeof(ifr.ifr_name) - 1, strlen(it->ifr_name));
            std::memcpy(ifr.ifr_name, it->ifr_name, name_len);
            ifr.ifr_name[name_len] = '\0';

            if (ioctl(sockGuard.get(), SIOCGIFFLAGS, &ifr) != 0) {
                return false;
            }

            if (!(ifr.ifr_flags & IFF_LOOPBACK)) {
                if (ioctl(sockGuard.get(), SIOCGIFHWADDR, &ifr) == 0) {
                    success = 1;
                    break;
                }
            }
        }

        if (success) {
            std::memcpy(mac, ifr.ifr_hwaddr.sa_data, 6);
        }
        else {
            debug("MAC: ", "not successful");
        }

    #ifdef __VMAWARE_DEBUG__
        {
            std::stringstream ss;
            ss << std::hex << std::setw(2) << std::setfill('0')
                << static_cast<int>(mac[0]) << ":"
                << static_cast<int>(mac[1]) << ":"
                << static_cast<int>(mac[2]) << ":XX:XX:XX";
            debug("MAC: ", ss.str());
        }
    #endif

        if ((mac[0] | mac[1] | mac[2]) == 0) {
            return false;
        }

        const u32 prefix = (u32)mac[0]
            | ((u32)mac[1] << 8)
            | ((u32)mac[2] << 16);

        constexpr u32 VBOX = 0x270008;  // 08:00:27
        constexpr u32 VMW1 = 0x29000C;  // 00:0C:29
        constexpr u32 VMW2 = 0x141C00;  // 00:1C:14
        constexpr u32 VMW3 = 0x565000;  // 00:50:56
        constexpr u32 VMW4 = 0x690500;  // 00:05:69
        constexpr u32 XEN = 0xE31600;   // 00:16:E3
        constexpr u32 PAR = 0x421C00;   // 00:1C:42

        if (prefix == VBOX) {
            return core::add(brands::VBOX);
        }
        else if (prefix == VMW1 || prefix == VMW2
            || prefix == VMW3 || prefix == VMW4) {
            return core::add(brands::VMWARE);
        }
        else if (prefix == XEN) {
            return core::add(brands::XEN);
        }
        else if (prefix == PAR) {
            return core::add(brands::PARALLELS);
        }

        return false;
    }


    /**
     * @brief Check if dmesg output matches a VM brand
     * @category Linux
     * @warning Permissions required
     * @implements VM::DMESG
     */
    [[nodiscard]] static bool dmesg() {
    #if (VMA_CPP <= 11)
        return false;
    #else
        if (!util::is_admin()) {
            return false;
        }

        if (!util::exists("/bin/dmesg") && !util::exists("/usr/bin/dmesg")) {
            debug("DMESG: ", "binary doesn't exist");
            return false;
        }

        const std::unique_ptr<std::string> result = util::sys_result("dmesg | grep -i hypervisor | grep -c \"KVM|QEMU\"");

        if (!result || result->empty()) {
            return false;
        }
        else if (*result == "KVM") {
            return core::add(brands::KVM);
        }
        else if (*result == "QEMU") {
            return core::add(brands::QEMU);
        }
        else if (std::atoi(result->c_str())) {
            return true;
        }
        else {
            debug("DMESG: ", "output = ", *result);
        }

        return false;
    #endif
    }


    /**
     * @brief Check if /sys/class/hwmon/ directory is present. If not, likely a VM
     * @category Linux
     * @implements VM::HWMON
     */
    [[nodiscard]] static bool hwmon() {
        return (!util::exists("/sys/class/hwmon/"));
    }


    /**
     * @brief Check for default VM username and hostname for linux
     * @category Linux
     * @implements VM::LINUX_USER_HOST
     */
    [[nodiscard]] static bool linux_user_host() {
        if (util::is_admin()) {
            return false;
        }

        const char* username = std::getenv("USER");
        const char* hostname = std::getenv("HOSTNAME");

        if (!username || !hostname) {
            debug("VM::LINUX_USER_HOST: environment variables not found");
            return false;
        }

        debug("LINUX_USER_HOST: user = ", username);
        debug("LINUX_USER_HOST: host = ", hostname);

        return (
            (strcmp(username, "liveuser") == 0) &&
            (strcmp(hostname, "localhost-live") == 0)
        );
    }


    /**
     * @brief Check for VMware string in /proc/iomem
     * @category Linux
     * @author idea from ScoopyNG by Tobias Klein
     * @implements VM::VMWARE_IOMEM
     */
    [[nodiscard]] static bool vmware_iomem() {
        const std::string iomem_file = util::read_file("/proc/iomem");

        if (util::find(iomem_file, "VMware")) {
            return core::add(brands::VMWARE);
        }

        return false;
    }


    /**
     * @brief Check for the presence of BlueStacks-specific folders
     * @category ARM, Linux
     * @implements VM::BLUESTACKS_FOLDERS
     */
    [[nodiscard]] static bool bluestacks() {
    #if (!ARM)
        return false;
    #else
        if (
            util::exists("/mnt/windows/BstSharedFolder") ||
            util::exists("/sdcard/windows/BstSharedFolder")
            ) {
            return core::add(brands::BLUESTACKS);
        }

        return false;
    #endif
    }


    /**
	 * @brief Check for AMD-SEV MSR running on the system
	 * @category x86, Linux, MacOS
	 * @author idea from virt-what
     * @warning Permissions required
     * @implements VM::AMD_SEV
	 */
	[[nodiscard]] static bool amd_sev() {
    #if (x86 && (LINUX || APPLE))
        if (!cpu::is_amd()) {
            return false;
        }

        if (!util::is_admin()) {
            return false;
        }

        constexpr u32 encrypted_memory_capability = 0x8000001f;
        constexpr u32 msr_index = 0xc0010131;

        if (!cpu::is_leaf_supported(encrypted_memory_capability)) {
            return false;
        }

        u32 eax, unused = 0;
        cpu::cpuid(eax, unused, unused, unused, encrypted_memory_capability);

        if (!(eax & (1 << 1))) {
            return false;
        }

        u64 result = 0;

        const std::string msr_device = "/dev/cpu/0/msr";
        std::ifstream msr_file(msr_device, std::ios::binary);

        if (!msr_file.is_open()) {
            debug("AMD_SEV: unable to open MSR file");
            return false;
        }

        msr_file.seekg(msr_index);
        msr_file.read(reinterpret_cast<char*>(&result), sizeof(result));

        if (!msr_file) {
            debug("AMD_SEV: unable to open MSR file");
            return false;
        }

        if (result & (static_cast<u64>(1) << 2)) { return core::add(brands::AMD_SEV_SNP); }
        else if (result & (static_cast<u64>(1) << 1)) { return core::add(brands::AMD_SEV_ES); }
        else if (result & 1) { return core::add(brands::AMD_SEV); }

        return false;
    #else
        return false;
    #endif
    }


    /**
     * @brief Check for presence of QEMU in the /sys/devices/virtual/dmi/id directory
     * @category Linux
     * @implements VM::QEMU_VIRTUAL_DMI
     */
    [[nodiscard]] static bool qemu_virtual_dmi() {
        const char* sys_vendor = "/sys/devices/virtual/dmi/id/sys_vendor";
        const char* modalias = "/sys/devices/virtual/dmi/id/modalias";

        if (
            util::exists(sys_vendor) &&
            util::exists(modalias)
        ) {
            const std::string sys_vendor_str = util::read_file(sys_vendor);
            const std::string modalias_str = util::read_file(modalias);

            if (
                util::find(sys_vendor_str, "QEMU") &&
                util::find(modalias_str, "QEMU")
            ) {
                return core::add(brands::QEMU);
            }
        }

        return false;
    }


    /**
     * @brief Check for presence of QEMU in the /sys/kernel/debug/usb/devices directory
     * @category Linux
     * @warning Permissions required
     * @implements VM::QEMU_USB
     */
    [[nodiscard]] static bool qemu_USB() {
        if (!util::is_admin()) {
            return false;
        }

        constexpr const char* usb_path = "/sys/kernel/debug/usb/devices";

        std::ifstream file(usb_path);
        if (!file) {
            return false;
        }

        std::string line;
        while (std::getline(file, line)) {
            if (line.find("QEMU") != std::string::npos) {
                return true;
            }
        }

        return false;
    }


    /**
     * @brief Check for presence of any files in /sys/hypervisor directory
     * @category Linux
     * @implements VM::HYPERVISOR_DIR
     */
    [[nodiscard]] static bool hypervisor_dir() {
        DIR* dir = opendir("/sys/hypervisor");

        if (dir == nullptr) {
            return false;
        }

        struct dirent* entry;
        int count = 0;

        while ((entry = readdir(dir)) != nullptr) {
            if (
                (entry->d_name[0] == '.' && entry->d_name[1] == '\0') || 
                (entry->d_name[1] == '.' && entry->d_name[2] == '\0')
            ) {
                continue;
            }

            count++;
            break;
        }

        closedir(dir);

        bool type = false;

        if (util::exists("/sys/hypervisor/type")) {
            type = true;
        }

        if (type) {
            const std::string content = util::read_file("/sys/hypervisor/type");
            if (util::find(content, "xen")) {
                return core::add(brands::XEN);
            }
        }

        // check if there's a few files in that directory
        return ((count != 0) && type);
    } 


    /**
     * @brief Check for the "UML" string in the CPU brand
     * @author idea from https://github.com/ShellCode33/VM-Detection/blob/master/vmdetect/linux.go
     * @category Linux
     * @implements VM::UML_CPU
     */
    [[nodiscard]] static bool uml_cpu() {
        // method 1, get the CPU brand model
        const std::string brand = cpu::get_brand();

        if (brand == "UML") {
            return core::add(brands::UML);
        }

        // method 2, match for the "User Mode Linux" string in /proc/cpuinfo
        const char* file = "/proc/cpuinfo";

        if (util::exists(file)) {
            const std::string file_content = util::read_file(file);

            if (util::find(file_content, "User Mode Linux")) {
                return core::add(brands::UML);
            }
        }

        return false;
    } 


    /**
     * @brief Check for any indications of hypervisors in the kernel message logs
     * @author idea from https://github.com/ShellCode33/VM-Detection/blob/master/vmdetect/linux.go
     * @category Linux
     * @warning Permissions required
     * @implements VM::KMSG
     */
    [[nodiscard]] static bool kmsg() {
        if (!util::is_admin()) {
            return false;
        }

        int fd = open("/dev/kmsg", O_RDONLY | O_NONBLOCK);
        if (fd < 0) {
            debug("KMSG: Failed to open /dev/kmsg");
            return false;
        }

        char buffer[1024];
        std::stringstream ss;

        while (true) {
            ssize_t bytes_read = read(fd, buffer, sizeof(buffer) - 1);

            if (bytes_read > 0) {
                buffer[bytes_read] = '\0';
                ss << buffer;
            } else if (bytes_read == 0) {
                usleep(100000); // Sleep for 100 milliseconds
            } else {
                if (errno == EAGAIN) {
                    usleep(100000);
                } else {
                    debug("KMSG: Error reading /dev/kmsg");
                    break;
                }
            }

            if (bytes_read < 0) {
                break;
            }
        }

        close(fd);

        const std::string content = ss.str();

        if (content.empty()) {
            return false;
        }

        return (util::find(content, "Hypervisor detected"));
    } 


    /**
     * @brief Check for a VBox kernel module
     * @author idea from https://github.com/ShellCode33/VM-Detection/blob/master/vmdetect/linux.go
     * @category Linux
     * @implements VM::VBOX_MODULE
     */
    [[nodiscard]] static bool vbox_module() {
        const char* file = "/proc/modules";

        if (!util::exists(file)) {
            return false;
        }

        const std::string content = util::read_file(file);

        if (util::find(content, "vboxguest")) {
            return core::add(brands::VBOX);
        }

        return false;
    }


    /**
     * @brief Check for VMware string in /proc/scsi/scsi
     * @category Linux
     * @author idea from ScoopyNG by Tobias Klein
     * @implements VM::VMWARE_SCSI
     */
    [[nodiscard]] static bool vmware_scsi() {
        const std::string scsi_file = util::read_file("/proc/scsi/scsi");

        if (util::find(scsi_file, "VMware")) {
            return core::add(brands::VMWARE);
        }

        return false;
    }

        
    /**
     * @brief Check for VMware-specific device name in dmesg output
     * @category Linux
     * @author idea from ScoopyNG by Tobias Klein
     * @note Disabled by default
     * @warning Permissions required
     * @implements VM::VMWARE_DMESG
     */
    [[nodiscard]] static bool vmware_dmesg() {
        if (!util::is_admin()) {
            return false;
        }

        if (!util::exists("/usr/bin/dmesg")) {
            return false;
        }

        auto dmesg_output = util::sys_result("dmesg");
        const std::string dmesg_o = *dmesg_output;

        if (dmesg_o.empty()) {
            return false;
        }

        if (util::find(dmesg_o, "BusLogic BT-958")) {
            return core::add(brands::VMWARE);
        }

        if (util::find(dmesg_o, "pcnet32")) {
            return core::add(brands::VMWARE);
        }

        return false;
    }


    /**
     * @brief Check for potential VM info in /proc/sysinfo
     * @author idea from https://github.com/ShellCode33/VM-Detection/blob/master/vmdetect/linux.go
     * @category Linux
     * @implements VM::SYSINFO_PROC
     */
    [[nodiscard]] static bool sysinfo_proc() {
        const char* file = "/proc/sysinfo";

        if (!util::exists(file)) {
            return false;
        }

        const std::string content = util::read_file(file);

        if (util::find(content, "VM00")) {
            return true;
        }

        return false;
    } 


    /**
     * @brief Check for string matches of VM brands in the linux DMI
     * @category Linux
     * @implements VM::DMI_SCAN
     */
    [[nodiscard]] static bool dmi_scan() {
        /*
        cat: /sys/class/dmi/id/board_serial: Permission denied
        cat: /sys/class/dmi/id/chassis_serial: Permission denied
        cat: /sys/class/dmi/id/product_serial: Permission denied
        cat: /sys/class/dmi/id/product_uuid: Permission denied
        */

        constexpr std::array<const char*, 7> dmi_array{
            "/sys/class/dmi/id/bios_vendor",
            "/sys/class/dmi/id/board_name",
            "/sys/class/dmi/id/board_vendor",
            "/sys/class/dmi/id/chassis_asset_tag",
            "/sys/class/dmi/id/product_family",
            "/sys/class/dmi/id/product_sku",
            "/sys/class/dmi/id/sys_vendor"
        };

        constexpr std::array<std::pair<const char*, const char*>, 15> vm_table{ {
            { "kvm", brands::KVM },
            { "openstack", brands::OPENSTACK },
            { "kubevirt", brands::KUBEVIRT },
            { "amazon ec2", brands::AWS_NITRO },
            { "qemu", brands::QEMU },
            { "vmware", brands::VMWARE },
            { "innotek gmbh", brands::VBOX },
            { "virtualbox", brands::VBOX },
            { "oracle corporation", brands::VBOX },
            //{ "xen", XEN },
            { "bochs", brands::BOCHS },
            { "parallels", brands::PARALLELS },
            { "bhyve", brands::BHYVE },
            { "hyper-v", brands::HYPERV },
            { "apple virtualization", brands::APPLE_VZ },
            { "google compute engine", brands::GCE }
        } };


        for (const auto file : dmi_array) {
            if (!util::exists(file)) {
                continue;
            }

            std::string content = util::read_file(file);
            if (content.empty()) {
                continue;
            }
            char* data = &content[0];
            const size_t len = content.size();
            for (size_t i = 0; i < len; ++i) {
                if (data[i] >= 'A' && data[i] <= 'Z') {
                    data[i] |= 0x20;
                }
            }

            for (const auto& vm_string : vm_table) {
                if (content.find(vm_string.first) != std::string::npos) {

                    debug("DMI_SCAN: content = ", content);

                    if (strcmp(vm_string.second, brands::AWS_NITRO) == 0) {
                        if (smbios_vm_bit()) {
                            return core::add(brands::AWS_NITRO);
                        }
                    }
                    else {
                        return core::add(vm_string.second);
                    }
                }
            }
        }

        return false;
    }


    /**
     * @brief Check for the VM bit in the SMBIOS data
     * @author idea from https://github.com/systemd/systemd/blob/main/src/basic/virt.c
     * @category Linux
     * @warning Permissions required
     * @implements VM::SMBIOS_VM_BIT
     */
    [[nodiscard]] static bool smbios_vm_bit() {
        if (!util::is_admin()) {
            return false;
        }

        const char* file = "/sys/firmware/dmi/entries/0-0/raw";

        if (!util::exists(file)) {
            return false;
        }

        const std::vector<u8> content = util::read_file_binary(file);

        if (content.size() < 20 || content.at(1) < 20) {
            debug("SMBIOS_VM_BIT: ", "only read ", content.size(), " bytes, expected 20");
            return false;
        }

        debug("SMBIOS_VM_BIT: ", "content.at(19) = ", static_cast<int>(content.at(19)));

        return (content.at(19) & (1 << 4));
    } 


    /**
     * @brief Check for podman file in /run/
     * @author idea from https://github.com/systemd/systemd/blob/main/src/basic/virt.c
     * @category Linux
     * @implements VM::PODMAN_FILE
     */
    [[nodiscard]] static bool podman_file() {
        if (util::exists("/run/.containerenv")) {
            return core::add(brands::PODMAN);
        }

        return false;
    }


    /**
     * @brief Check for VMware string in /proc/ioports
     * @category Linux
     * @author idea from ScoopyNG by Tobias Klein
     * @implements VM::VMWARE_IOPORTS
     */
    [[nodiscard]] static bool vmware_ioports() {
        const std::string ioports_file = util::read_file("/proc/ioports");
    
        if (util::find(ioports_file, "VMware")) {
            return core::add(brands::VMWARE);
        }
    
        return false;
    }


    /**
     * @brief Check for WSL or microsoft indications in /proc/ subdirectories
     * @author idea from https://github.com/systemd/systemd/blob/main/src/basic/virt.c
     * @category Linux
     * @implements VM::WSL_PROC
     */
    [[nodiscard]] static bool wsl_proc_subdir() {
        const char* osrelease = "/proc/sys/kernel/osrelease";
        const char* version = "/proc/version";

        if (
            util::exists(osrelease) &&
            util::exists(version)
        ) {
            const std::string osrelease_content = util::read_file(osrelease);
            const std::string version_content = util::read_file(version);

            if (
                (util::find(osrelease_content, "WSL") || util::find(osrelease_content, "Microsoft")) &&
                (util::find(version_content, "WSL") || util::find(version_content, "Microsoft"))
            ) {
                return core::add(brands::WSL);
            }
        }

        return false;
    }


    /**
     * @brief Detect QEMU fw_cfg interface. This first checks the Device Tree for a fw-cfg node or hypervisor tag, then verifies the presence of the qemu_fw_cfg module and firmware directories in sysfs.
     * @category Linux
     * @implements VM::QEMU_FW_CFG
     */
     [[nodiscard]] static bool qemu_fw_cfg() {
        // Linux DT method: inspired by https://github.com/ShellCode33/VM-Detection
        // Linux sysfs method: looks for /sys/module/qemu_fw_cfg/ & /sys/firmware/qemu_fw_cfg/

        // 1) Device Tree-based detection
        if (util::exists("/proc/device-tree/fw-cfg")) {
            return core::add(brands::QEMU);
        }
        if (util::exists("/proc/device-tree/hypervisor/compatible")) {
            return core::add(brands::QEMU);
        }

        // 2) sysfs-based detection
        const char* module_path = "/sys/module/qemu_fw_cfg/";
        const char* firmware_path = "/sys/firmware/qemu_fw_cfg/";
        if (util::is_directory(module_path) && util::exists(module_path) &&
            util::is_directory(firmware_path) && util::exists(firmware_path)) {
            return core::add(brands::QEMU);
        }

        return false;
    }


    /**
     * @brief Check if the number of accessed files are too low for a human-managed environment
     * @category Linux
     * @author idea from https://unprotect.it/technique/xbel-recently-opened-files-check/
     * @implements VM::FILE_ACCESS_HISTORY
     */
    [[nodiscard]] static bool file_access_history() {
        const std::string xbel_file = util::read_file("~/.local/share/recently-used.xbel");
        
        if (xbel_file.empty()) {
            debug("FILE_ACCESS_HISTORY: file content is empty");
            return false;
        }

        const std::string key = "href";

        u32 count = 0;
        std::size_t pos = 0;

        while ((pos = xbel_file.find(key, pos)) != std::string::npos) {
            count++;
            pos += key.length();
        }

        return (count <= 10); 
    }


    /**
     * @brief Check if process status matches with nsjail patterns with PID anomalies
     * @category Linux
     * @implements VM::NSJAIL_PID
     */
    [[nodiscard]] static bool nsjail_proc_id() {
        std::ifstream status_file("/proc/self/status");
        if (!status_file.is_open()) {
            return false;
        }

        std::string line;
        bool pid_match = false;
        bool ppid_match = false;

        auto parse_number = [&](const std::string& prefix) -> int {
            if (line.compare(0, prefix.size(), prefix) != 0) {
                return -1;
            }
            int num = 0;
            for (size_t i = prefix.size(); i < line.size(); ++i) {
                u8 ch = static_cast<u8>(line[i]);
                if (std::isdigit(ch)) {
                    num = num * 10 + (ch - '0');
                }
                else if (num > 0) {
                    break;
                }
            }
            return num;
        };

        while (std::getline(status_file, line)) {
            int pid = parse_number("Pid:");
            if (pid == 1) {
                pid_match = true;
            }

            int ppid = parse_number("PPid:");
            if (ppid == 0) {
                ppid_match = true;
            }

            if (pid_match && ppid_match) {
                return core::add(brands::NSJAIL);
            }
        }

        return false;
    }


    /**
     * @brief Check for device's temperature
     * @category Linux
     * @implements VM::TEMPERATURE
     */
    [[nodiscard]] static bool temperature() {
        if (util::exists("/sys/class/thermal/cooling_device0")) return false;
        return (!util::exists("/sys/class/thermal/thermal_zone0/"));
    }


    /**
     * @brief Check for any VM processes that are active
     * @category Linux
     * @implements VM::PROCESSES
     */
    [[nodiscard]] static bool processes() {
        if (util::is_proc_running("qemu_ga")) {
            debug("PROCESSES: Detected QEMU guest agent process.");
            return core::add(brands::QEMU);
        }

        if (util::exists("/proc/xen")) {
            return core::add(brands::XEN);
        }

        if (util::exists("/proc/vz")) {
            return core::add(brands::OPENVZ);
        }

        return false;
    }
#endif

#if (LINUX || WINDOWS)
    /**
     * @brief Check for Task Segment and Descriptor Table instructions (SGDT, SLDT, SMSW, SIDT)
     * @category Windows, Linux, x86, x86_32
     * @implements VM::DESCRIPTOR_TABLES
     * 
     * --- SGDT ---
     * @note code documentation paper in /papers/www.offensivecomputing.net_vm.pdf (top-most byte signature)
     *
     * --- SLDT ---
     * @author Danny Quist (chamuco@gmail.com), ldtr_buf signature
     * @author Val Smith (mvalsmith@metasploit.com), ldtr_buf signature
     * @author code documentation paper in /papers/www.offensivecomputing.net_vm.pdf for ldtr_buf signature and in https://www.aldeid.com/wiki/X86-assembly/Instructions/sldt for ldt signature
     *
     * --- SMSW ---
     * @author Danny Quist from Offensive Computing
     *
     * --- SIDT ---
     * @author Matteo Malvica
     * @author Idea to check VPC's range from Tom Liston and Ed Skoudis' paper "On the Cutting Edge: Thwarting Virtual Machine Detection" (Windows)
     * @link https://www.matteomalvica.com/blog/2018/12/05/detecting-vmware-on-64-bit-systems/ (Linux)
     * 
     */
    [[nodiscard]] static bool system_registers() {
        // Even though SMSW queries a status register (CR0), it is historically grouped with descriptor table checks in virtualization detection 
        // (often called "Red Pill" techniques)
        bool found = false;

        // Linux Implementation (SIDT only)
    #if (LINUX && (GCC || CLANG) && x86)
        u8 values[10] = { 0 };

        fflush(stdout);

        #if (x86_64)
            // 64-bit Linux: IDT descriptor is 10 bytes (2-byte limit + 8-byte base)
            __asm__ __volatile__("sidt %0" : "=m"(values));

        #ifdef __VMAWARE_DEBUG__
            debug("SIDT: values = ");
            for (u8 i = 0; i < 10; ++i) {
                debug(std::hex, std::setw(2), std::setfill('0'), static_cast<u32>(values[i]));
                if (i < 9) debug(" ");
            }
        #endif

            if (values[9] == 0x00) found = true; // 10th byte in x64 mode
        #elif (x86_32)
            // 32-bit Linux: IDT descriptor is 6 bytes (2-byte limit + 4-byte base)
            __asm__ __volatile__("sidt %0" : "=m"(values));

        #ifdef __VMAWARE_DEBUG__
            debug("SIDT: values = ");
            for (u8 i = 0; i < 6; ++i) {
                debug(std::hex, std::setw(2), std::setfill('0'), static_cast<u32>(values[i]));
                if (i < 5) debug(" ");
            }
        #endif

            if (values[5] == 0x00) found = true; // 6th byte in x86 mode
        #endif

        // Windows Implementation (SGDT, SLDT, SIDT, SMSW)
    #elif (WINDOWS && x86)
        SYSTEM_INFO si;
        GetNativeSystemInfo(&si);
        DWORD_PTR original_mask = 0;
        const HANDLE current_thread = reinterpret_cast<HANDLE>(-2LL);

        // Iterating processors for SGDT, SLDT, and SIDT
        for (DWORD i = 0; i < si.dwNumberOfProcessors; ++i) {
            const DWORD_PTR mask = (DWORD_PTR)1 << i;
            const DWORD_PTR previous_mask = SetThreadAffinityMask(current_thread, mask);

            if (previous_mask == 0) {
                continue;
            }

            if (original_mask == 0) {
                original_mask = previous_mask;
            }

            // Technique 1: SGDT (x86 & x64)
            {
            #if (x86_64)
                u8 gdtr[10] = { 0 };
            #else
                u8 gdtr[6] = { 0 };
            #endif

                __try {
                #if (CLANG || GCC)
                    __asm__ volatile("sgdt %0" : "=m"(gdtr));
                #elif (MSVC && x86_32)
                    __asm { sgdt gdtr }
                #else
                    #pragma pack(push,1)
                    struct {
                        u16 limit;
                        u64 base;
                    } _gdtr = {};
                    #pragma pack(pop)
                    _sgdt(&_gdtr);
                    memcpy(gdtr, &_gdtr, sizeof(_gdtr));
                #endif
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {} // CR4.UMIP

                ULONG_PTR gdt_base = 0;
                memcpy(&gdt_base, &gdtr[2], sizeof(gdt_base));

                if ((gdt_base >> 24) == 0xFF) {
                    debug("SGDT: 0xFF signature detected on core %u", i);
                    found = true;
                }
            }

            // Technique 2: SLDT (x86_32 only)
            #if (x86_32)
                if (!found) {
                    u8 ldtr_buf[4] = { 0xEF, 0xBE, 0xAD, 0xDE };
                    u32 ldt_val = 0;

                    __try {
                    #if (CLANG || GCC)
                        __asm__ volatile("sldt %0" : "=m"(*(u16*)ldtr_buf));
                    #else  // MSVC
                        __asm {
                            sldt ax
                            mov  word ptr[ldtr_buf], ax
                        }
                    #endif
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {} // CR4.UMIP

                    memcpy(&ldt_val, ldtr_buf, sizeof(ldt_val));
                    if (ldtr_buf[0] != 0x00 && ldtr_buf[1] != 0x00) {
                        debug("SLDT: ldtr_buf signature detected");
                        found = true;
                    }
                    if (ldt_val != 0xDEAD0000) {
                        debug("SLDT: 0xDEAD0000 signature detected");
                        found = true;
                    }
                }
            #endif

                // Technique 3: SIDT (x86 & x64)
                if (!found) {
                #if (x86_64)
                    u8 idtr_buffer[10] = { 0 };
                #else
                    u8 idtr_buffer[6] = { 0 };
                #endif

                    __try {
                    #if (CLANG || GCC)
                        __asm__ volatile("sidt %0" : "=m"(idtr_buffer));
                    #elif (MSVC) && (x86_32)
                        __asm { sidt idtr_buffer }
                    #elif (MSVC) && (x86_64)
                        #pragma pack(push, 1)
                        struct {
                            USHORT Limit;
                            ULONG_PTR Base;
                        } idtr;
                        #pragma pack(pop)
                        __sidt(&idtr);
                        memcpy(idtr_buffer, &idtr, sizeof(idtr));
                    #endif
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER) {} // CR4.UMIP

                    ULONG_PTR idt_base = 0;
                    memcpy(&idt_base, &idtr_buffer[2], sizeof(idt_base));

                    // Check for the 0xE8 signature (VPC/Hyper-V) in the high byte
                    if ((idt_base >> 24) == 0xE8) {
                        debug("SIDT: VPC/Hyper-V signature detected on core %u", i);
                        found = true;
                    }
                }

            if (found) break;
        }

        if (original_mask != 0) {
            SetThreadAffinityMask(current_thread, original_mask);
        }

        // Technique 4: SMSW (x86_32 only), no affinity pinning needed
        #if (x86_32)
            if (!found) {
                u32 reax = 0;
                __asm
                {
                    mov eax, 0xCCCCCCCC;
                    smsw eax;
                    mov DWORD PTR[reax], eax;
                }

                if ((((reax >> 24) & 0xFF) == 0xCC) && (((reax >> 16) & 0xFF) == 0xCC)) {
                    debug("SMSW: Signature detected");
                    found = true;
                }
            }
        #endif

    #endif

        return found;
    }


    /**
     * @brief Check for default Azure hostname format (Azure uses Hyper-V as their base VM brand)
     * @category Windows, Linux
     * @implements VM::AZURE
     */
    [[nodiscard]] static bool azure() {
        std::string hostname;

    #if (WINDOWS)
        char buf[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD len = sizeof(buf);

        if (GetComputerNameA(buf, &len)) {
            hostname.assign(buf, len);
        }
        else {
            return false;
        }
    #elif (LINUX)
        char buf[HOST_NAME_MAX];

        if (gethostname(buf, sizeof(buf)) == 0) {
            hostname = buf;
        }
        else {
            return false;
        }
    #endif

        const char* prefix = "runnervm";
        const std::size_t prefix_len = std::strlen(prefix);
        const std::size_t extra_chars = 5;
        const std::size_t expected_len = prefix_len + extra_chars;

        if (hostname.size() != expected_len) {
            return false;
        }

        if (hostname.compare(0, prefix_len, prefix) != 0) {
            return false;
        }

        for (std::size_t i = prefix_len; i < hostname.size(); ++i) {
            if (!std::isalnum(static_cast<unsigned char>(hostname[i]))) {
                return false;
            }
        }

        return core::add(brands::AZURE_HYPERV);
    }
    template <typename T, size_t N>
    constexpr bool check_no_nulls(const std::array<T, N>& arr, size_t i = 0) {
        return (i == N)
            ? true
            : (arr[i] != nullptr && check_no_nulls(arr, i + 1));
    }


    /**
     * @brief Check for VM signatures on all firmware tables
     * @category Windows, Linux
     * @authors Requiem, dmfrpro, MegaMax
     * @warning Permissions required
     * @implements VM::FIRMWARE
     */
    [[nodiscard]] static bool firmware() {
    #if (WINDOWS)
        struct acpi_header {
            char signature[4];
            u32 length;
            u8 revision;
        };

        struct fadt_table {
            u32 signature;
            u32 length;
            u8 revision;
            u8 checksum;
            char oem_id[6];
            char oem_table_id[8];
            u32 oem_revision;
            char asl_compiler_id[4];
            u32 asl_compiler_revision;

            u32 firmware_ctrl;
            u32 dsdt;
            u8 reserved1;
            u8 preferred_pm_profile;
            u16 sci_interrupt;
            u32 smi_command_port;
            u8 acpi_enable;
            u8 acpi_disable;
            u8 s4_bios_req;
            u8 reserved2;
            u32 pstate_control;
            u32 pm1a_event_block;
            u32 pm1b_event_block;
            u32 pm1a_control_block;
            u32 pm1b_control_block;
            u32 pm2_control_block;
            u32 pm_timer_block;
            u32 gpe0_block;
            u32 gpe1_block;
            u8 pm1_event_length;
            u8 pm1_control_length;
            u8 pm2_control_length;
            u8 pm_timer_length;

            u16 p_lvl2_lat;
            u16 p_lvl3_lat;
        };

        // "WAET" is also present as a string inside the WAET table, so there's no need to check for its table signature
        constexpr std::array<const char*, 22> targets = { {
            "Parallels Software", "Parallels(R)",
            "innotek",            "Oracle",   "VirtualBox", "vbox", "VBOX",
            "VMware, Inc.",       "VMware",   "VMWARE",     "VMW0003",
            "QEMU",               "pc-q35",   "Q35 +",      "FWCF",     "BOCHS",
            "ovmf",               "edk ii unknown", "WAET", "S3 Corp.", "VS2005R2",
            "Xen"
        } };

        constexpr std::array<const char*, 22> brands_map = { {
            brands::PARALLELS, brands::PARALLELS,
            brands::VBOX,      brands::VBOX,      brands::VBOX,     brands::VBOX,     brands::VBOX,
            brands::VMWARE,    brands::VMWARE,    brands::VMWARE,   brands::VMWARE,
            brands::QEMU,      brands::QEMU,      brands::QEMU,     brands::QEMU,     brands::BOCHS,
            nullptr, nullptr, nullptr, nullptr, nullptr,
            brands::XEN
        } };

        // inside struct to not have to move out of function, constexpr this way because of c++ 11 compatibility
        struct array_validator {
            static constexpr bool verify_no_nulls(const std::array<const char*, 22>& arr, size_t i) {
                return (i == arr.size())
                    ? true
                    : (arr[i] != nullptr && verify_no_nulls(arr, i + 1));
            }
        };

        // ensure sizes match
        static_assert(targets.size() == brands_map.size(),
            "FIRMWARE: 'targets' and 'brands_map' must have the same size.");

        // detects if you increased size but forgot strings
        static_assert(array_validator::verify_no_nulls(targets, 0),
            "FIRMWARE: 'targets' array contains NULLs. Array size declared is larger than the number of strings provided.");

        auto scan_buffer = [&](const u8* buffer, const size_t buffer_len) noexcept -> bool {
            // faster than std::search because of a manual byte-by-byte loop, could be optimized further with Boyer-Moore-Horspool for large tables like DSDT
            auto find_pattern = [&](const char* pattern, size_t pattern_len) noexcept -> bool {
                if (pattern_len == 0 || pattern_len > buffer_len) return false;
                const u8 first_byte = static_cast<u8>(pattern[0]);
                const u8* base_ptr = buffer;
                const u8* search_ptr = base_ptr;
                size_t remaining_bytes = buffer_len;

                while (remaining_bytes >= pattern_len) {
                    const void* match = memchr(search_ptr, first_byte, remaining_bytes);
                    if (!match) return false;
                    const u8* match_ptr = static_cast<const u8*>(match);
                    const size_t index = static_cast<size_t>(match_ptr - base_ptr);
                    // ensure pattern fits
                    if (index + pattern_len > buffer_len) return false;
                    if (memcmp(match_ptr, pattern, pattern_len) == 0) return true;
                    // advance one past this found first-byte and continue
                    search_ptr = match_ptr + 1;
                    remaining_bytes = buffer_len - static_cast<size_t>(search_ptr - base_ptr);
                }
                return false;
            };

            // 1) VM-specific firmware signatures. It is important that vm-specific checks run first because of the hardened detection logic
            for (size_t i = 0; i < targets.size(); ++i) {
                const char* pattern = targets[i];
                const size_t pattern_len = strlen(pattern);
                if (pattern_len > buffer_len) continue;

                if (find_pattern(pattern, pattern_len)) {
                    // special handling for Xen: must not have PXEN to prevent false flagging some baremetal systems
                    if (strcmp(pattern, "Xen") == 0) {
                        constexpr char pxen[] = "PXEN";
                        constexpr size_t pxen_len = sizeof(pxen) - 1;
                        const bool has_pxen = find_pattern(pxen, pxen_len);
                        if (!has_pxen)
                            return core::add(brands::XEN);
                        else
                            continue;
                    }

                    // special handling for BOCHS: if BXPC is detected, check if "BOCHS" is present too
                    if (strcmp(pattern, "BXPC") == 0) {
                        constexpr char bochs[] = "BOCHS";
                        constexpr size_t bochs_len = sizeof(bochs) - 1;
                        const bool has_bochs = find_pattern(bochs, bochs_len);
                        if (!has_bochs)
                            return core::add(brands::BOCHS);
                        else
                            continue;
                    }

                    debug("FIRMWARE: Detected ", pattern);
                    const char* detected_brand = brands_map[i];
                    return (detected_brand ? core::add(detected_brand) : true);
                }
            }

            // 2) known patches used by popular hardeners 
            {
                constexpr char marker[] = "777777";

                if (buffer_len >= 36) {
                    // OEMID (6)
                    char oem_id[7] = { 0 };
                    memcpy(oem_id, buffer + 10, 6);
                    // OEM Table ID (8)
                    char oem_table_id[9] = { 0 };
                    memcpy(oem_table_id, buffer + 16, 8);

                    // Creator / ASL Compiler ID (4) won't contain 6-char marker because its length is 4
                    if (strstr(oem_id, marker) != nullptr) {
                        debug("FIRMWARE: VMWareHardenedLoader found in OEMID -> '", oem_id, "'");
                        return core::add(brands::VMWARE_HARD);
                    }
                    if (strstr(oem_table_id, marker) != nullptr) {
                        debug("FIRMWARE: VMWareHardenedLoader found in OEM Table ID -> '", oem_table_id, "'");
                        return core::add(brands::VMWARE_HARD);
                    }
                }
            }

            if (!buffer || buffer_len < sizeof(acpi_header)) {
                return false;
            }

            acpi_header header;
            memcpy(&header, buffer, sizeof(header));

            // 3) FADT specific checks
            if (memcmp(header.signature, "FACP", 4) == 0) {
                if (header.length > buffer_len) {
                    debug("FIRMWARE: declared header length larger than fetched length (declared ", header.length, ", fetched ", buffer_len, ")");
                    return true;
                }
                if (buffer_len < sizeof(fadt_table)) {
                    debug("FIRMWARE: FACP buffer too small (len ", buffer_len, ")");
                    return true;
                }

                fadt_table fadt;
                memcpy(&fadt, buffer, sizeof(fadt_table));

                if (fadt.p_lvl2_lat == 0x0FFF || fadt.p_lvl3_lat == 0x0FFF) { // A value > 100 indicates the system does not support a C2/C3 state
                    debug("FIRMWARE: C2 and C3 latencies indicate VM");
                    return true;
                }
            }

            return false;
        };

        // to minimize heap allocations
        std::vector<u8> work_buffer;
        work_buffer.reserve(65536);

        // Enumerate ACPI tables
        constexpr DWORD acpi_signature = 'ACPI';
        const DWORD acpi_enum_size = EnumSystemFirmwareTables(acpi_signature, nullptr, 0);
        if (acpi_enum_size == 0) 
            return false;
        if (acpi_enum_size % sizeof(DWORD) != 0) 
            return false;
       
        const size_t table_count = acpi_enum_size / sizeof(DWORD);
        std::vector<DWORD> tables(table_count);
        if (EnumSystemFirmwareTables(acpi_signature, tables.data(), acpi_enum_size) != acpi_enum_size)
            return false;

        // DSDT special fetch
        {
            constexpr DWORD dsdt_sig = 'DSDT';
            constexpr DWORD dsdt_swapped =
                ((dsdt_sig >> 24) & 0x000000FFu)
                | ((dsdt_sig >> 8) & 0x0000FF00u)
                | ((dsdt_sig << 8) & 0x00FF0000u)
                | ((dsdt_sig << 24) & 0xFF000000u);

            const UINT sz = GetSystemFirmwareTable(acpi_signature, dsdt_swapped, nullptr, 0);
            if (sz > 0) {
                if (sz > work_buffer.capacity()) work_buffer.reserve(sz);
                work_buffer.resize(sz);
                if (GetSystemFirmwareTable(acpi_signature, dsdt_swapped, work_buffer.data(), sz) == sz) {
                    if (scan_buffer(work_buffer.data(), work_buffer.size())) {
                        return true;
                    }
                }
            }
        }

        // helper to fetch one table into a malloc'd buffer
        auto fetch_and_scan = [&](DWORD provider, DWORD table_id) noexcept -> bool {
            const DWORD sz = GetSystemFirmwareTable(provider, table_id, nullptr, 0);
            if (sz == 0) return false;

            if (sz > work_buffer.capacity()) work_buffer.reserve(sz);
            work_buffer.resize(sz);

            if (GetSystemFirmwareTable(provider, table_id, work_buffer.data(), sz) != sz) {
                return false;
            }

            return scan_buffer(work_buffer.data(), sz);
        };

        // Scan every ACPI table, dont make explicit whitelisting/blacklisting because of possible bypasses
        for (const auto table_id : tables) {
            if (fetch_and_scan(acpi_signature, table_id)) {
                return true;
            }
        }

        // Scan SMBIOS (RSMB) / FIRM tables
        constexpr DWORD smb_providers[] = { 'FIRM', 'RSMB' };

        for (DWORD prov : smb_providers) {
            const UINT e = EnumSystemFirmwareTables(prov, nullptr, 0);
            if (!e) continue;

            // even if alignment is supported on x86 its good to check if size is a multiple of DWORD
            if (e % sizeof(DWORD) != 0) continue;

            const size_t cnt = e / sizeof(DWORD);
            std::vector<DWORD> provider_tables(cnt);

            if (EnumSystemFirmwareTables(prov, provider_tables.data(), e) != e) continue;

            for (const auto table_id : provider_tables) {
                if (fetch_and_scan(prov, table_id)) {
                    return true;
                }
            }
        }

        return false;
    #elif (LINUX)
        // Author: dmfrpro
        DIR* raw_dir = opendir("/sys/firmware/acpi/tables/");
        if (!raw_dir) {
            debug("FIRMWARE: could not open ACPI tables directory");
            return false;
        }

        struct dir_closer {
            DIR* d;
            explicit dir_closer(DIR* dir) : d(dir) {}
            ~dir_closer() { if (d) closedir(d); }
        } dir(raw_dir);

        constexpr const char* targets[] = {
            "Parallels Software", "Parallels(R)",
            "innotek",            "Oracle",   "VirtualBox", "vbox", "VBOX",
            "VMware, Inc.",       "VMware",   "VMWARE",     "VMW0003",
            "QEMU",               "pc-q35",   "Q35 +",      "FWCF",     "BOCHS",
            "ovmf",               "edk ii unknown", "S3 Corp.", "Virtual Machine", "VS2005R2",
            "Xen"
        };

        struct dirent* entry;
        constexpr long MAX_TABLE_SIZE = 8 * 1024 * 1024;

        while ((entry = readdir(raw_dir)) != nullptr) {
            // Skip "." and ".."
            if (strcmp(entry->d_name, ".") == 0 ||
                strcmp(entry->d_name, "..") == 0)
                continue;

            char path[PATH_MAX];
            snprintf(path, sizeof(path),
                "/sys/firmware/acpi/tables/%s",
                entry->d_name);

            int fd = open(path, O_RDONLY);
            if (fd == -1) {
                debug("FIRMWARE: could not open ACPI table ", entry->d_name);
                continue;
            }

            struct fd_closer {
                int fd;
                explicit fd_closer(int f) : fd(f) {}
                ~fd_closer() { if (fd != -1) close(fd); }
            } fdguard(fd);

            struct stat statbuf;
            if (fstat(fd, &statbuf) != 0 || S_ISDIR(statbuf.st_mode)) {
                debug("FIRMWARE: skipped ", entry->d_name);
                continue;
            }
            long file_size = statbuf.st_size;
            if (file_size <= 0) {
                debug("FIRMWARE: file empty or error ", entry->d_name);
                continue;
            }

            if (file_size > MAX_TABLE_SIZE) {
                debug("FIRMWARE: table too large, skipping ", entry->d_name);
                continue;
            }

            const size_t file_size_u = static_cast<size_t>(file_size);

            std::vector<u8> buffer;
            try {
                buffer.resize(file_size_u);
            }
            catch (...) {
                debug("FIRMWARE: failed to allocate memory for buffer");
                continue;
            }

            size_t total = 0;
            while (total < file_size_u) {
                ssize_t n = read(fdguard.fd, buffer.data() + total, file_size_u - total);
                if (n <= 0) break; // error or EOF
                total += static_cast<size_t>(n);
            }
            if (total != file_size_u) {
                debug("FIRMWARE: could not read full table ", entry->d_name);
                continue;
            }

            for (const char* target : targets) {
                size_t target_length = strlen(target);
                if (target_length > file_size_u)
                    continue;
                for (size_t j = 0; j <= file_size_u - target_length; ++j) {
                    if (memcmp(buffer.data() + j, target, target_length) == 0) {
                        const char* brand = nullptr;
                        if (strcmp(target, "Parallels Software International") == 0 ||
                            strcmp(target, "Parallels(R)") == 0) {
                            brand = brands::PARALLELS;
                        }
                        else if (strcmp(target, "innotek") == 0 ||
                            strcmp(target, "Oracle") == 0 ||
                            strcmp(target, "VirtualBox") == 0 ||
                            strcmp(target, "vbox") == 0 ||
                            strcmp(target, "VBOX") == 0) {
                            brand = brands::VBOX;
                        }
                        else if (strcmp(target, "VMware, Inc.") == 0 ||
                            strcmp(target, "VMware") == 0 ||
                            strcmp(target, "VMWARE") == 0) {
                            brand = brands::VMWARE;
                        }
                        else if (strcmp(target, "QEMU") == 0) {
                            brand = brands::QEMU;
                        }
                        else if (strcmp(target, "BOCHS") == 0 ||
                            strcmp(target, "BXPC") == 0) {
                            brand = brands::BOCHS;
                        }

                        if (brand)
                            return core::add(brand);
                        else
                            return true;
                    }
                }
            }
        }

        return false;
    #endif
    }


    /**
     * @brief Check for PCI vendor and device IDs that are VM-specific
     * @link https://www.pcilookup.com/?ven=&dev=&action=submit
     * @category Linux, Windows
     * @implements VM::PCI_DEVICES
     */
    [[nodiscard]] static bool pci_devices() {
        struct pci_device { u16 vendor_id; u32 device_id; };
        std::vector<pci_device> devices;

        #if (LINUX)
         const std::string pci_path = "/sys/bus/pci/devices";
         #if (VMA_CPP >= 17)
            // std::filesystem throws exceptions when directories don't exist (SIGSEGV)
            std::error_code ec;
            auto dir_iter = std::filesystem::directory_iterator(pci_path, ec);

            if (!ec) {
                for (const auto& entry : dir_iter) {
                    std::ifstream vf(entry.path() / "vendor"), df(entry.path() / "device");
                    if (!vf || !df) continue;
                    u16 vid = 0; u32 did = 0;
                    vf >> std::hex >> vid;
                    df >> std::hex >> did;
                    devices.push_back({ vid, did });
                }
            }
         #else
            DIR* dir = opendir(pci_path.c_str());
            if (dir) {
                while (struct dirent* ent = readdir(dir)) {
                    std::string name = ent->d_name;
                    if (name == "." || name == "..") continue;
                    std::string base = pci_path + "/" + name;
                    std::ifstream vf(base + "/vendor"), df(base + "/device");
                    if (!vf || !df) continue;
                    u16 vid = 0; u32 did = 0;
                    vf >> std::hex >> vid;
                    df >> std::hex >> did;
                    devices.push_back({ vid, did });
                }
                closedir(dir);
            }
        #endif
        #elif (WINDOWS)
        static constexpr const wchar_t* kroots[] = {
            L"SYSTEM\\CurrentControlSet\\Enum\\PCI",
            L"SYSTEM\\CurrentControlSet\\Enum\\USB",
            L"SYSTEM\\CurrentControlSet\\Enum\\HDAUDIO"
        };

        enum root_type { RT_PCI, RT_USB, RT_HDAUDIO };
        constexpr DWORD MAX_MULTI_SZ = 64 * 1024;

        auto hex_val = [](wchar_t c) noexcept -> int {
            if (c >= L'0' && c <= L'9') return c - L'0';

            const wchar_t lower = static_cast<wchar_t>((static_cast<int>(c) | 0x20));
            if (lower >= L'a' && lower <= L'f') return lower - L'a' + 10;

            return -1;
        };

        auto parse_hex = [&](const wchar_t* ptr, size_t maxDigits, size_t stopLen, unsigned long& out, size_t& consumed) noexcept -> bool {
            out = 0;
            consumed = 0;

            const size_t limit = (stopLen < maxDigits) ? stopLen : maxDigits;

            for (; consumed < limit; ++consumed) {
                const int v = hex_val(ptr[consumed]);
                if (v < 0) break;

                // caller must ensure maxDigits doesn't exceed 8, because on Windows unsigned long is 32-bit
                out = (out << 4) | static_cast<unsigned long>(v);
            }

            return consumed > 0;
        };

        std::unordered_set<unsigned long long> seen;

        auto add_device = [&](u16 vid, u32 did) noexcept {
            const unsigned long long key = (static_cast<unsigned long long>(vid) << 32) | static_cast<unsigned long long>(did);
            if (seen.insert(key).second) {
                devices.push_back({ vid, did });
            }
        };

        auto scan_text_ids = [&](const wchar_t* text) noexcept {
            if (!text) return;

            // USB: VID_ and then PID_
            const wchar_t* p = text;
            while ((p = wcsstr(p, L"VID_"))) {
                const wchar_t* v = p;
                p += 4;
                const wchar_t* d = wcsstr(v + 4, L"PID_");
                if (d && (d - v) < 64) {
                    unsigned long parsed_v = 0, parsed_d = 0;
                    size_t c_v = 0, c_d = 0;
                    if (parse_hex(v + 4, 4, SIZE_MAX, parsed_v, c_v) &&
                        parse_hex(d + 4, 8, SIZE_MAX, parsed_d, c_d)) {
                        add_device(static_cast<u16>(parsed_v & 0xFFFFu), static_cast<u32>(parsed_d));
                    }
                }
            }

            // PCI or HDAUDIO = VEN_ and then DEV_ after it
            p = text;
            while ((p = wcsstr(p, L"VEN_"))) {
                const wchar_t* v = p;
                p += 4;
                const wchar_t* d = wcsstr(v + 4, L"DEV_");
                if (d && (d - v) < 64) {
                    unsigned long parsed_v = 0;
                    size_t c_v = 0;
                    if (parse_hex(v + 4, 4, SIZE_MAX, parsed_v, c_v)) {
                        const wchar_t* dev_start = const_cast<wchar_t*>(d + 4);
                        const wchar_t* amp_after_dev = wcschr(dev_start, L'&');
                        const size_t dev_len = amp_after_dev ? static_cast<size_t>(amp_after_dev - dev_start) : wcslen(dev_start);

                        // for HDAUDIO expect 4 digits and for PCI allow up to 8
                        if (dev_len > 0 && dev_len <= 8) {
                            unsigned long parsed_d = 0;
                            size_t c_d = 0;
                            // parse exactly devLen digits (fail if any char is non-hex)
                            if (parse_hex(dev_start, 8, dev_len, parsed_d, c_d) && c_d == dev_len) {
                                add_device(static_cast<u16>(parsed_v & 0xFFFFu), static_cast<u32>(parsed_d));
                            }
                        }
                    }
                }
            }
        };

        // process the hardware ID on an instance key
        auto process_hardware_id_reg = [&](HKEY h_inst) noexcept {
            // most HardwareIDs fit within 512 bytes
            static thread_local std::vector<wchar_t> buf;
            if (buf.empty()) buf.resize(512);

            DWORD type = 0;
            DWORD cb_data = static_cast<DWORD>(buf.size() * sizeof(wchar_t));

            LONG rv = RegGetValueW(
                h_inst,
                nullptr,
                L"HardwareID",
                RRF_RT_REG_MULTI_SZ,
                &type,
                buf.data(),
                &cb_data
            );

            if (rv == ERROR_MORE_DATA) {
                if (cb_data > MAX_MULTI_SZ) {
                    return;
                }

                // allocate a buffer large enough to hold the entire MULTI_SZ
                // (+1 for safety null terminator logic below)
                buf.resize((cb_data / sizeof(wchar_t)) + 2);

                rv = RegGetValueW(
                    h_inst,
                    nullptr,
                    L"HardwareID",
                    RRF_RT_REG_MULTI_SZ,
                    &type,
                    buf.data(),
                    &cb_data
                );
            }

            if (rv != ERROR_SUCCESS || type != REG_MULTI_SZ || cb_data <= sizeof(wchar_t)) {
                return;
            }

            // guarantee terminating NUL
            // RegGetValueW with RRF_RT_REG_MULTI_SZ usually handles this but for safety
            const size_t wchar_count = cb_data / sizeof(wchar_t);
            if (wchar_count < buf.size()) buf[wchar_count] = L'\0';
            else buf.back() = L'\0';

            for (wchar_t* p = buf.data(); *p; p += wcslen(p) + 1) {
                scan_text_ids(p);
            }
        };

        // all instance subkeys under a given device key
        auto enum_instances = [&](HKEY h_dev) noexcept {
            wchar_t inst_name[256];

            for (DWORD j = 0;; ++j) {
                // reset size for each iteration as RegEnumKeyExW modifies it
                DWORD cb_inst = _countof(inst_name);

                const LONG st2 = RegEnumKeyExW(
                    h_dev,
                    j,
                    inst_name,
                    &cb_inst,
                    nullptr,
                    nullptr,
                    nullptr,
                    nullptr
                );
                if (st2 == ERROR_NO_MORE_ITEMS) break;
                if (st2 != ERROR_SUCCESS) continue;

                HKEY h_inst = nullptr;
                if (RegOpenKeyExW(h_dev, inst_name, 0, KEY_READ, &h_inst) != ERROR_SUCCESS) continue;

                process_hardware_id_reg(h_inst);
                RegCloseKey(h_inst);
            }
        };

        // all device subkeys under a given root key
        auto enum_devices = [&](HKEY h_root) noexcept {
            wchar_t device_name[256];

            for (DWORD i = 0;; ++i) {
                DWORD cb_name = _countof(device_name);

                const LONG status = RegEnumKeyExW(
                    h_root,
                    i,
                    device_name,
                    &cb_name,
                    nullptr,
                    nullptr,
                    nullptr,
                    nullptr
                );
                if (status == ERROR_NO_MORE_ITEMS) break;
                if (status != ERROR_SUCCESS) continue;

                HKEY h_dev = nullptr;
                if (RegOpenKeyExW(h_root, device_name, 0, KEY_READ, &h_dev) != ERROR_SUCCESS) continue;

                enum_instances(h_dev);
                RegCloseKey(h_dev);
            }
        };

        // for each rootPath we open the root key once
        for (size_t root_idx = 0; root_idx < _countof(kroots); ++root_idx) {
            const wchar_t* root_path = kroots[root_idx];
            HKEY root = nullptr;
            if (RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                root_path,
                0,
                KEY_READ,
                &root
            ) != ERROR_SUCCESS) {
                continue;
            }

            enum_devices(root);
            RegCloseKey(root);
        }
        #endif

        for (auto& d : devices) {
            const u64 id64 = (static_cast<u64>(d.vendor_id) << 32) | d.device_id;
            const u32 id32 = (static_cast<u32>(d.vendor_id) << 16) | static_cast<u32>(d.device_id);
            switch (id32) {
                // Red Hat + Virtio
                case 0x1af40022: case 0x1af41000: case 0x1af41001: case 0x1af41002:
                case 0x1af41003: case 0x1af41004: case 0x1af41005: case 0x1af41009:
                case 0x1af41041: case 0x1af41042: case 0x1af41043: case 0x1af41044:
                case 0x1af41045: case 0x1af41048: case 0x1af41049: case 0x1af41050:
                case 0x1af41052: case 0x1af41053: case 0x1af4105a: case 0x1af41100:
                case 0x1af41110: case 0x1af41b36:
                    debug("PCI_DEVICES: Detected Red Hat + Virtio device -> ", std::hex, id32);
                    return true;

                // VMware
                case 0x15ad0710: case 0x15ad0720: case 0x15ad0770: case 0x15ad0774: 
                case 0x15ad0778: case 0x15ad0779: case 0x15ad0790: case 0x15ad07a0: 
                case 0x15ad07b0: case 0x15ad07c0: case 0x15ad07e0: case 0x15ad07f0: 
                case 0x15ad0801: case 0x15ad0820: case 0x15ad1977: case 0xfffe0710: 
                case 0x0e0f0001: case 0x0e0f0002: case 0x0e0f0003: case 0x0e0f0004: 
                case 0x0e0f0005: case 0x0e0f0006: case 0x0e0f000a: case 0x0e0f8001: 
                case 0x0e0f8002: case 0x0e0f8003: case 0x0e0ff80a:
                    debug("PCI_DEVICES: Detected VMWARE device -> ", std::hex, id32);
                    return core::add(brands::VMWARE);

                // Red Hat + QEMU
                case 0x1b360001: case 0x1b360002: case 0x1b360003: case 0x1b360004:
                case 0x1b360005: case 0x1b360008: case 0x1b360009: case 0x1b36000b:
                case 0x1b36000c: case 0x1b36000d: case 0x1b360010: case 0x1b360011:
                case 0x1b360013: case 0x1b360100:
                    debug("PCI_DEVICES: Detected Red Hat + QEMU device -> ", std::hex, id32);
                    return core::add(brands::QEMU);

                // QEMU
                case 0x06270001: case 0x1d1d1f1f: case 0x80865845: case 0x1d6b0200:
                    debug("PCI_DEVICES: Detected QEMU device -> ", std::hex, id32);
                    return core::add(brands::QEMU);

                // vGPUs (NVIDIA + others)
                case 0x10de0fe7: case 0x10de0ff7: case 0x10de118d: case 0x10de11b0:
                case 0x1ec6020f:
                    debug("PCI_DEVICES: Detected virtual gpu device -> ", std::hex, id32);
                    return true;

                // VirtualBox
                case 0x80ee0021: case 0x80ee0022: case 0x80eebeef: case 0x80eecafe:
                    debug("PCI_DEVICES: Detected VirtualBox device -> ", std::hex, id32);
                    return core::add(brands::VBOX);

                // Parallels
                case 0x1ab84000: case 0x1ab84005: case 0x1ab84006:
                    debug("PCI_DEVICES: Detected Parallels device -> ", std::hex, id32);
                    return core::add(brands::PARALLELS);

                // Xen
                case 0x5853c000: case 0xfffd0101: case 0x5853c147:
                case 0x5853c110: case 0x5853c200: case 0x58530001:
                    debug("PCI_DEVICES: Detected Xen device -> ", std::hex, id32);
                    return core::add(brands::XEN);

                // Connectix (VirtualPC)
                case 0x29556e61:
                    debug("PCI_DEVICES: Detected VirtualPC device -> ", std::hex, id32);
                    return core::add(brands::VPC);
            }

            // Devices with 32 bit device ids
            switch (id64) {
                case 0x0000000011061100ULL:
                case 0x000000001af41100ULL:
                case 0x000000001b361100ULL:
                case 0x0000000010ec1100ULL:
                case 0x0000000010331100ULL:
                case 0x0000000080861100ULL:
                case 0x0000000010131100ULL:
                case 0x00000000106b1100ULL:
                case 0x0000000010221100ULL:
                    debug("PCI_DEVICES: Detected QEMU device -> ", std::hex, id64);
                    return core::add(brands::QEMU);
    
                case 0x0000000015ad0800ULL:  // Hypervisor ROM Interface
                    debug("PCI_DEVICES: Detected Hypervisor ROM interface -> ", std::hex, id64);
                    return core::add(brands::VMWARE);
            }
        }
        
        return false;
    }
#endif

#if (LINUX || APPLE)
    /**
     * @brief Check if there are only 1 or 2 threads, which is a common pattern in VMs with default settings, nowadays physical CPUs should have at least 4 threads for modern CPUs
     * @category x86 (ARM might have very low thread counts, which is why it should be only for x86)
     * @implements VM::THREAD_COUNT
     */
    [[nodiscard]] static bool thread_count() {
    #if (x86 && !APPLE)
        debug("THREADCOUNT: ", "threads = ", memo::threadcount::fetch());

        struct cpu::stepping_struct steps = cpu::fetch_steppings();

        if (cpu::is_celeron(steps)) {
            return false;
        }

        return (memo::threadcount::fetch() <= 2);
    #else 
        return false;
    #endif
    }
#endif

#if (APPLE) 
    /**
     * @brief Check if the sysctl for the hwmodel does not contain the "Mac" string
     * @author MacRansom ransomware
     * @category MacOS
     * @implements VM::HWMODEL
     */
    [[nodiscard]] static bool hwmodel() {
        
        //hw.model strings are short (like for example MacBookPro16,1), 128 bytes is plenty
        char buffer[128] = { 0 };
        size_t size = sizeof(buffer);

        // sysctlbyname queries the kernel directly, bypassing the overhead of 
        // fork(), exec(), and pipe() found in util::sys_result (popen)
        if (sysctlbyname("hw.model", buffer, &size, nullptr, 0) != 0) {
            debug("HWMODEL: ", "failed to read hw.model");
            return false;
        }

        // sysctlbyname returns the raw value (usually without a trailing newline),
        // so no trimming is required
        debug("HWMODEL: ", "output = ", buffer);

        if (strstr(buffer, "Mac") != nullptr) {
            return false;
        }

        if (strstr(buffer, "VMware") != nullptr) {
            return core::add(brands::VMWARE);
        }

        // assumed true since it doesn't contain "Mac" string
        return true;
    }


    /**
     * @brief Check if memory is too low for MacOS system
     * @category MacOS
     * @link https://evasions.checkpoint.com/src/MacOS/macos.html
     * @implements VM::MAC_MEMSIZE
     */
    [[nodiscard]] static bool hw_memsize() {
        std::unique_ptr<std::string> result = util::sys_result("sysctl -n hw.memsize");
        const std::string ram = *result;

        if (ram == "0") {
            return false;
        }

        debug("MAC_MEMSIZE: ", "ram size = ", ram);

        for (const char c : ram) {
            if (!std::isdigit(c)) {
                debug("MAC_MEMSIZE: ", "found non-digit character, returned false");
                return false;
            }
        }

        const u64 ram_u64 = std::stoull(ram);

        debug("MAC_MEMSIZE: ", "ram size in u64 = ", ram_u64);

        constexpr u64 limit = 4000000000; // 4GB 

        return (ram_u64 <= limit);
    }


    /**
     * @brief Check MacOS' IO kit registry for VM-specific strings
     * @category MacOS
     * @link https://evasions.checkpoint.com/src/MacOS/macos.html
     * @implements VM::MAC_IOKIT
     */
    [[nodiscard]] static bool io_kit() {
        // board_ptr and manufacturer_ptr empty
        std::unique_ptr<std::string> platform_ptr = util::sys_result("ioreg -rd1 -c IOPlatformExpertDevice");
        std::unique_ptr<std::string> board_ptr = util::sys_result("ioreg -rd1 -c board-id");
        std::unique_ptr<std::string> manufacturer_ptr = util::sys_result("ioreg -rd1 -c manufacturer");
        std::unique_ptr<std::string> keyboard_ptr = util::sys_result("ioreg -lw0 -p IODeviceTree");

        const std::string platform = *platform_ptr;
        const std::string board = *board_ptr;
        const std::string manufacturer = *manufacturer_ptr;
        const std::string keyboard = *keyboard_ptr;

        auto check_platform = [&]() -> bool {
            debug("IO_KIT: ", "platform = ", platform);

            if (platform.empty()) {
                return false;
            }

            for (const char c : platform) {
                if (!std::isdigit(c)) {
                    return false;
                }
            }

            return (platform == "0");
        };

        auto check_board = [&]() -> bool {
            debug("IO_KIT: ", "board = ", board);

            if (board.empty()) {
                return false;
            }

            if (util::find(board, "Mac")) {
                return false;
            }

            if (util::find(board, "VirtualBox")) {
                return core::add(brands::VBOX);
            }

            if (util::find(board, "VMware")) {
                return core::add(brands::VMWARE);
            }

            return false;
        };

        auto check_manufacturer = [&]() -> bool {
            debug("IO_KIT: ", "manufacturer = ", manufacturer);

            if (manufacturer.empty()) {
                return false;
            }

            if (util::find(manufacturer, "Apple")) {
                return false;
            }

            if (util::find(manufacturer, "innotek")) {
                return core::add(brands::VBOX);
            }

            return false;
        };

        auto check_keyboard = [&]() -> bool {
            debug("IO_KIT: ", "keyboard = ", keyboard);

            if (keyboard.empty()) {
                return false;
            }

            if (util::find(keyboard, "Virtual Machine")) {
                return true;
            }

            return false;
        };

        return (
            check_platform() ||
            check_board() ||
            check_manufacturer() ||
            check_keyboard()
       );
    }


    /**
     * @brief Check for VM-strings in ioreg commands for MacOS
     * @category MacOS
     * @link https://evasions.checkpoint.com/src/MacOS/macos.html
     * @implements VM::IOREG_GREP
     */
    [[nodiscard]] static bool ioreg_grep() {
        auto check_usb = []() -> bool {
            std::unique_ptr<std::string> result = util::sys_result("ioreg -rd1 -c IOUSBHostDevice | grep \"USB Vendor Name\"");
            const std::string usb = *result;

            if (util::find(usb, "Apple")) {
                return false;
            }

            if (util::find(usb, "VirtualBox")) {
                return core::add(brands::VBOX);
            }

            return false;
        };

        auto check_rom = []() -> bool {
            std::unique_ptr<std::string> sys_rom = util::sys_result("system_profiler SPHardwareDataType | grep \"Boot ROM Version\"");
            const std::string rom = *sys_rom;

            if (util::find(rom, "VirtualBox")) {
                return core::add(brands::VBOX);
            }

            return false;
        };

        return (
            check_usb() ||
            check_general() ||
            check_rom()
        );
    }


    /**
     * @brief Check for the status of System Integrity Protection and hv_mm_present
     * @category MacOS
     * @link https://evasions.checkpoint.com/src/MacOS/macos.html
     * @implements VM::MAC_SIP
     */
    [[nodiscard]] static bool mac_sip() {
        int hv_present = 0;
        std::size_t size = sizeof(hv_present);
        if (sysctlbyname("kern.hv_vmm_present",
            &hv_present,
            &size,
            nullptr,
            0) != 0) {
            return false;
        }

        if (hv_present != 0) {
            return true;
        }

        std::unique_ptr<std::string> result = util::sys_result("csrutil status");

        if (!result) {
            return false;
        }

        std::string tmp = *result;

        auto pos = tmp.find('\n');

        if (pos != std::string::npos) {
            tmp.resize(pos);
        }

        debug("MAC_SIP: ", "result = ", tmp);

        if (util::find(tmp, "unknown")) {
            return false;
        }

        return (util::find(tmp, "disabled"));
    }


    /**
     * @brief Check for VM-strings in system profiler commands for MacOS
     * @category MacOS
     * @implements VM::MAC_SYS
     */
    [[nodiscard]] static bool mac_sys() {
        const char* keyword = "virtual machine";

        if (std::unique_ptr<std::string> profiler_res_ptr = util::sys_result("system_profiler SPHardwareDataType")) {
            std::string& output = *profiler_res_ptr;

            std::transform(output.begin(), output.end(), output.begin(),
                [](u8 c) { return std::tolower(c); });

            if (util::find(output, keyword)) {
                return true;
            }
        }

        return false;
    }
#endif


#if (WINDOWS)
    /**
     * @brief Check for VM-specific DLLs
     * @category Windows
     * @implements VM::DLL
     */
    [[nodiscard]] static bool dll() {
        static constexpr struct {
            const char* dll_name;
            const char* brand;
        } dlls[] = {
            {"sbiedll.dll",   brands::SANDBOXIE},
            {"pstorec.dll",   brands::CWSANDBOX},
            {"vmcheck.dll",   brands::VPC},
            {"cmdvrt32.dll",  brands::COMODO},
            {"cmdvrt64.dll",  brands::COMODO},
            {"cuckoomon.dll", brands::CUCKOO},
            {"SxIn.dll",      brands::QIHOO},
            {"wpespy.dll",    brands::NULL_BRAND}
        };

        for (const auto& x : dlls) {
            if (GetModuleHandleA(x.dll_name) != nullptr) {
                debug("DLL: Found ", x.dll_name, " (", x.brand, ")");
                return core::add(x.brand);
            }
        }

        return false;
    }

             
    /**
     * @brief Check if the function "wine_get_unix_file_name" is present and if the OS booted from a VHD container
     * @category Windows
     * @implements VM::WINE
     */
    [[nodiscard]] static bool wine() {
        #if (_WIN32_WINNT < _WIN32_WINNT_WIN8)
            return false;
        #else
            __try {
                BOOL isNativeVhdBoot = 0;
                // we dont call NtQuerySystemInformation with SystemPrefetchPathInformation | SystemHandleInformation
                // the point is to check if this kernel32.dll function throws an exception
                IsNativeVhdBoot(&isNativeVhdBoot);
                VMAWARE_UNUSED(isNativeVhdBoot);
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                debug("WINE: SEH invoked");
                return true;
            }
        #endif

        // ARM CPUs trigger this check
        if (util::is_running_under_translator()) 
            return false;

        const HMODULE kernel32 = GetModuleHandleA("kernel32.dll");
        const HMODULE ntdll = util::get_ntdll();
        if (!kernel32 || !ntdll) {
            return false;
        }

        const char* kernel32_names[] = { "wine_get_unix_file_name" };
        void* kernel32_functions[ARRAYSIZE(kernel32_names)] = {};
        util::get_function_address(kernel32, kernel32_names, kernel32_functions, _countof(kernel32_names));

        if (kernel32_functions[0] != nullptr) {
            return core::add(brands::WINE);
        }

        const char* ntdll_names[] = { "NtAllocateVirtualMemory", "NtFreeVirtualMemory", "NtProtectVirtualMemory" };
        void* ntdll_functions[ARRAYSIZE(ntdll_names)] = {};
        util::get_function_address(ntdll, ntdll_names, ntdll_functions, _countof(ntdll_names));

        // https://www.unknowncheats.me/forum/anti-cheat-bypass/729130-article-wine-detection.html
        const UINT old_mode = SetErrorMode(SEM_NOALIGNMENTFAULTEXCEPT);

        static constexpr unsigned char movaps_stub[] = {
            0x0F, 0x28, 0x01, // movaps xmm0, XMMWORD PTR [rcx]   (Windows x64: arg in RCX)
            0xC3              // ret
        };

        typedef void (*movaps_fn)(void*);

        using NtAllocateVirtualMemoryFn = NTSTATUS(__stdcall*)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);
        using NtFreeVirtualMemoryFn = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG);
        using NtProtectVirtualMemoryFn = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG);

        const auto nt_allocate_virtual_memory = reinterpret_cast<NtAllocateVirtualMemoryFn>(ntdll_functions[0]);
        const auto nt_free_virtual_memory = reinterpret_cast<NtFreeVirtualMemoryFn>(ntdll_functions[1]);
        const auto nt_protect_virtual_memory = reinterpret_cast<NtProtectVirtualMemoryFn>(ntdll_functions[2]);

        if (nt_allocate_virtual_memory == nullptr || nt_free_virtual_memory == nullptr || nt_protect_virtual_memory == nullptr) {
            SetErrorMode(old_mode);
            return false;
        }

        PVOID exec_mem = NULL;
        const HANDLE current_process = reinterpret_cast<HANDLE>(-1);
        SIZE_T region_size = sizeof movaps_stub;
        NTSTATUS st = nt_allocate_virtual_memory(current_process, &exec_mem, 0, &region_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!NT_SUCCESS(st) || exec_mem == NULL) {
            SetErrorMode(old_mode);
            return false;
        }

        memcpy(exec_mem, movaps_stub, sizeof movaps_stub);
     
        PVOID tmp_base = exec_mem;
        SIZE_T tmp_sz = region_size;
        ULONG old_protection = 0;
        st = nt_protect_virtual_memory(current_process, &tmp_base, &tmp_sz, PAGE_EXECUTE_READ, &old_protection);
        if (!NT_SUCCESS(st)) {
            PVOID free_base = exec_mem;
            SIZE_T free_size = 0;
            nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
            SetErrorMode(old_mode);
            return false;
        }
        
        __declspec(align(16)) unsigned char buffer[32] = { 0 };
        void* misaligned = buffer + 1;

        __try {
            ((movaps_fn)exec_mem)(misaligned);
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            PVOID free_base = exec_mem;
            SIZE_T free_size = 0;
            nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);

            SetErrorMode(old_mode);
            return core::add(brands::WINE);
        }
      
        PVOID free_base = exec_mem;
        SIZE_T free_size = 0;
        nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);

        SetErrorMode(old_mode);
        return false;
    }
                
                
    /**
     * @brief Check what power states are enabled
     * @category Windows
     * @implements VM::POWER_CAPABILITIES
     */
    [[nodiscard]] static bool power_capabilities() {
        const HMODULE ntdll = util::get_ntdll();

        const char* names[] = { "NtPowerInformation" }; // Win8
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        if (!funcs[0]) return false;

        using NtPI_t = NTSTATUS(__stdcall*)(POWER_INFORMATION_LEVEL,
            PVOID, ULONG,
            PVOID, ULONG);
        const auto nt_power_information = reinterpret_cast<NtPI_t>(funcs[0]);

        SYSTEM_POWER_CAPABILITIES caps = { 0 };
        const NTSTATUS status = nt_power_information(
            SystemPowerCapabilities,
            nullptr, 0,
            &caps, sizeof(caps)
        );
        if (status != 0) return false;

        const bool s0_supported = caps.AoAc;
        const bool s1_supported = caps.SystemS1;
        const bool s2_supported = caps.SystemS2;
        const bool s3_supported = caps.SystemS3;
        const bool s4_supported = caps.SystemS4;
        const bool hiber_file_present = caps.HiberFilePresent;

        const bool is_physical_pattern = (s0_supported || s3_supported) &&
            (s4_supported || hiber_file_present);

        if (is_physical_pattern) {
            return false;
        }

        const bool is_vm_pattern = !(s0_supported || s3_supported || s4_supported || hiber_file_present) &&
            (s1_supported || s2_supported);

        if (is_vm_pattern) {
            debug("POWER_CAPABILITIES: Detected !(S0||S3||S4||HiberFilePresent) + S1|S2 pattern");
            return true;
        }

        // could check for HKLM\\SYSTEM\\CurrentControlSet\\Control\\Power\\PlatformAoAcOverride
        const bool no_sleep_states = !s0_supported && !s1_supported && !s2_supported && !s3_supported;
        if (no_sleep_states) {
            debug("POWER_CAPABILITIES: Detected !(S0||S1||S2||S3) pattern"); // can sometimes false flag baremetal devices
            return true;
        }

        return (caps.ThermalControl == 0);
    }


    /**
     * @brief Check for Gamarue ransomware technique which compares VM-specific Window product IDs
     * @category Windows
     * @implements VM::GAMARUE
     */
    [[nodiscard]] static bool gamarue() {
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtOpenKey", "NtQueryValueKey", "RtlInitUnicodeString", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_open_key = reinterpret_cast<NTSTATUS(__stdcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES)>(funcs[0]);
        const auto nt_query_value_key = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PUNICODE_STRING, ULONG, PVOID, ULONG, PULONG)>(funcs[1]);
        const auto rtl_init_unicode_string = reinterpret_cast<void(__stdcall*)(PUNICODE_STRING, PCWSTR)>(funcs[2]);
        const auto nt_close = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE)>(funcs[3]);

        if (!nt_open_key || !nt_query_value_key || !rtl_init_unicode_string || !nt_close) 
            return false;

        // We use native unicode strings and object attributes to interface directly with the kernel
        UNICODE_STRING key_name;
        rtl_init_unicode_string(&key_name, L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

        OBJECT_ATTRIBUTES object_attributes;
        ZeroMemory(&object_attributes, sizeof(object_attributes));
        object_attributes.Length = sizeof(object_attributes);
        object_attributes.ObjectName = &key_name;
        object_attributes.Attributes = OBJ_CASE_INSENSITIVE;

        // Open the registry key with minimal permissions (query only)
        HANDLE key = nullptr;
        constexpr ACCESS_MASK KEY_QUERY_ONLY = 0x0001; // KEY_QUERY_VALUE
        NTSTATUS st = nt_open_key(&key, KEY_QUERY_ONLY, &object_attributes);
        if (!NT_SUCCESS(st) || !key) {
            return false;
        }

        // We specifically want the "ProductId". Automated malware analysis sandboxes often
        // neglect to randomize this value, thats why we flag it
        UNICODE_STRING value_name;
        rtl_init_unicode_string(&value_name, L"ProductId");

        // Buffer for KEY_VALUE_PARTIAL_INFORMATION
        BYTE buffer[128]{};
        ULONG result_length = 0;
        constexpr ULONG key_value_partial_information = 2;

        st = nt_query_value_key(key, &value_name, key_value_partial_information, buffer, sizeof(buffer), &result_length);

        nt_close(key);

        if (!NT_SUCCESS(st)) {
            return false;
        }

        // raw structure returned by the native API to manually parse the binary data
        struct KEY_VALUE_PARTIAL_INFORMATION_LOCAL {
            ULONG TitleIndex;
            ULONG Type;
            ULONG DataLength;
            BYTE Data[1];
        };

        if (result_length < offsetof(KEY_VALUE_PARTIAL_INFORMATION_LOCAL, Data) + 1) {
            return false;
        }

        // Safely extract the ProductId string from the raw byte buffer, ensuring we don't 
        // buffer overflow if the registry returns garbage data
        const auto* kv = reinterpret_cast<KEY_VALUE_PARTIAL_INFORMATION_LOCAL*>(buffer);
        const ULONG data_length = kv->DataLength;
        if (data_length == 0 || data_length >= sizeof(buffer)) return false;

        char product_id[64] = { 0 };
        const size_t copyLen = (data_length < (sizeof(product_id) - 1)) ? data_length : (sizeof(product_id) - 1);
        memcpy(product_id, kv->Data, copyLen);
        product_id[copyLen] = '\0';

        // A list of known "dirty" Product IDs associated with public malware analysis sandboxes
        struct target_pattern {
            const char* product_id;
            const char* brand;
        };

        constexpr target_pattern targets[] = {
            {"55274-640-2673064-23950", brands::JOEBOX},   
            {"76487-644-3177037-23510", brands::CWSANDBOX}, 
            {"76487-337-8429955-22614", brands::ANUBIS}     
        };

        constexpr size_t target_length = 21;

        if (strlen(product_id) != target_length) return false;

        // compare the current system's ProductId against the blacklist
        // if a match is found, we identify the specific sandbox environment and flag it
        for (const auto& target : targets) {
            if (memcmp(product_id, target.product_id, target_length) == 0) {
                debug("GAMARUE: Detected ", target.product_id);
                return core::add(target.brand);
            }
        }

        return false;
    }
 

    /**
     * @brief Check for official VPC method
     * @category Windows, x86_32
     * @implements VM::VPC_INVALID
     */
    [[nodiscard]] static bool vpc_invalid() {
        bool rc = false;
    #if (x86_32 && !CLANG)

        auto is_inside_vpc = [](PEXCEPTION_POINTERS ep) noexcept -> DWORD {
            PCONTEXT ctx = ep->ContextRecord;

            ctx->Ebx = static_cast<DWORD>(-1); // Not running VPC
            ctx->Eip += 4; // skip past the "call VPC" opcodes
            return static_cast<DWORD>(EXCEPTION_CONTINUE_EXECUTION);
            // we can safely resume execution since we skipped faulty instruction
        };

        __try {
            __asm {
                push eax
                push ebx
                push ecx
                push edx

                mov ebx, 0h
                mov eax, 01h

                __emit 0Fh
                __emit 3Fh
                __emit 07h
                __emit 0Bh

                test ebx, ebx
                setz[rc]

                pop edx
                pop ecx
                pop ebx
                pop eax
            }
        }
        __except (is_inside_vpc(GetExceptionInformation())) {
            rc = false;
        }
    #endif
        return rc;
    }


    /**
     * @brief Check str assembly instruction method for VMware
     * @author Alfredo Omella's (S21sec) STR technique, paper describing this technique is located in /papers/
     * @category Windows, x86_32
     * @implements VM::VMWARE_STR
     */
    [[nodiscard]] static bool vmware_str() {
    #if (x86_32)
        u16 tr = 0;
        __asm {
            str ax
            mov tr, ax
        }
        if ((tr & 0xFF) == 0x00 && ((tr >> 8) & 0xFF) == 0x40) {
            return core::add(brands::VMWARE);
        }

        return false;
    #else
        return false;
    #endif
    }


    /**
     * @brief Check for official VMware io port backdoor technique
     * @category Windows, x86_32
     * @author Code from ScoopyNG by Tobias Klein, technique founded by Ken Kato
     * @copyright BSD clause 2
     * @implements VM::VMWARE_BACKDOOR
     */
    [[nodiscard]] static bool vmware_backdoor() {
        bool is_vm = false;
    #if (x86_32 && !CLANG)
        u32 a = 0;
        u32 b = 0;

        constexpr std::array<i16, 2> ioports = { { 'VX' , 'VY' } };
        i16 ioport;

        for (u8 i = 0; i < ioports.size(); ++i) {
            ioport = ioports[i];
            for (u8 cmd = 0; cmd < 0x2c; ++cmd) {
                __try {
                    __asm {
                        push eax
                        push ebx
                        push ecx
                        push edx

                        mov eax, 'VMXh'
                        movzx ecx, cmd
                        mov dx, ioport
                        in eax, dx      // <- key point is here

                        mov a, ebx
                        mov b, ecx

                        pop edx
                        pop ecx
                        pop ebx
                        pop eax
                    }

                    is_vm = true;
                    break;
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {}
            }
        }

        if (is_vm) {
            switch (b) {
                case 1:  return core::add(brands::VMWARE_EXPRESS);
                case 2:  return core::add(brands::VMWARE_ESX);
                case 3:  return core::add(brands::VMWARE_GSX);
                case 4:  return core::add(brands::VMWARE_WORKSTATION);
                default: return core::add(brands::VMWARE);
            }
        }
    #endif
        return is_vm;
    }


    /**
     * @brief Check for mutex strings of VM brands
     * @category Windows
     * @author from VMDE project
     * @author hfiref0x
     * @implements VM::MUTEX
     */
    [[nodiscard]] static bool mutex() {
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        using RtlInitUnicodeString_t = void(__stdcall*)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
        using NtClose_t = NTSTATUS(__stdcall*)(HANDLE Handle);
        using NtOpenMutant_t = NTSTATUS(__stdcall*)(PHANDLE MutantHandle, ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes);

        const char* names[] = { "NtOpenMutant", "RtlInitUnicodeString", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_open_mutant = reinterpret_cast<NtOpenMutant_t>(funcs[0]);
        const auto rtl_init_unicode_string = reinterpret_cast<RtlInitUnicodeString_t>(funcs[1]);
        const auto nt_close = reinterpret_cast<NtClose_t>(funcs[2]);

        if (!nt_open_mutant || !rtl_init_unicode_string || !nt_close) {
            return false;
        }

        auto try_mutex_name = [&](const wchar_t* base_name) noexcept -> bool {
            constexpr wchar_t prefix[] = L"\\BaseNamedObjects\\";
            constexpr size_t prefix_len = (sizeof(prefix) / sizeof(wchar_t)) - 1;

            wchar_t full_path[260];

            // memcpy as it is faster than wcscpy/wcscat
            memcpy(full_path, prefix, sizeof(prefix)); 

            const size_t name_len = wcslen(base_name);
            if (prefix_len + name_len < 260) {
                memcpy(full_path + prefix_len, base_name, (name_len + 1) * sizeof(wchar_t));
            }
            else {
                // should not happen for standard VM artifacts
                full_path[0] = L'\0';
            }

            const wchar_t* attempts[] = { full_path, base_name };

            for (const wchar_t* path : attempts) {
                if (*path == L'\0') continue;

                UNICODE_STRING u_name;
                rtl_init_unicode_string(&u_name, path);

                OBJECT_ATTRIBUTES obj_attr;
                memset(&obj_attr, 0, sizeof(obj_attr));
                obj_attr.Length = sizeof(obj_attr);
                obj_attr.ObjectName = &u_name;
                obj_attr.Attributes = OBJ_CASE_INSENSITIVE;

                HANDLE h_mutant = nullptr;
                const NTSTATUS st = nt_open_mutant(&h_mutant, MUTANT_QUERY_STATE, &obj_attr);

                if (NT_SUCCESS(st)) {
                    if (h_mutant) nt_close(h_mutant);
                    return true;
                }
            }

            return false;
        };

        if (try_mutex_name(L"Sandboxie_SingleInstanceMutex_Control") ||
            try_mutex_name(L"SBIE_BOXED_ServiceInitComplete_Mutex1")) {
            debug("MUTEX: Detected Sandboxie");
            return core::add(brands::SANDBOXIE);
        }

        if (try_mutex_name(L"MicrosoftVirtualPC7UserServiceMakeSureWe'reTheOnlyOneMutex")) {
            debug("MUTEX: Detected VPC");
            return core::add(brands::VPC);
        }

        return false;
    }


    /**
     * @brief Check for cuckoo directory using crt and WIN API directory functions
     * @category Windows
     * @author ä¸€åŠäººç”Ÿ
     * @link https://unprotect.it/snippet/checking-specific-folder-name/196/
     * @implements VM::CUCKOO_DIR
     */
    [[nodiscard]] static bool cuckoo_dir() {
        using NtOpenFile_t = NTSTATUS(__stdcall*)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
            POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
            ULONG ShareAccess, ULONG OpenOptions);
        using RtlInitUnicodeString_t = void(__stdcall*)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
        using NtClose_t = NTSTATUS(__stdcall*)(HANDLE Handle);

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtOpenFile", "RtlInitUnicodeString", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_open_file = reinterpret_cast<NtOpenFile_t>(funcs[0]);
        const auto rtl_init_unicode_string = reinterpret_cast<RtlInitUnicodeString_t>(funcs[1]);
        const auto nt_close = reinterpret_cast<NtClose_t>(funcs[2]);

        if (!nt_open_file || !rtl_init_unicode_string || !nt_close) {
            return false;
        }

        const wchar_t* native_path = L"\\??\\C:\\Cuckoo";
        UNICODE_STRING path;
        rtl_init_unicode_string(&path, native_path);

        OBJECT_ATTRIBUTES object_attributes;
        ZeroMemory(&object_attributes, sizeof(object_attributes));
        object_attributes.Length = sizeof(object_attributes);
        object_attributes.ObjectName = &path;
        object_attributes.Attributes = OBJ_CASE_INSENSITIVE;

        IO_STATUS_BLOCK iosb;
        HANDLE hFile = nullptr;

        constexpr ACCESS_MASK desired_access = FILE_READ_ATTRIBUTES; 
        constexpr ULONG share_access = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
        constexpr ULONG open_options = FILE_OPEN | FILE_SYNCHRONOUS_IO_NONALERT | FILE_DIRECTORY_FILE;

        const NTSTATUS st = nt_open_file(&hFile, desired_access, &object_attributes, &iosb, share_access, open_options);
        if (NT_SUCCESS(st)) {
            if (hFile) nt_close(hFile);
            return core::add(brands::CUCKOO);
        }

        return false;
    }
                
                
    /**
     * @brief Check for Cuckoo specific piping mechanism
     * @category Windows
     * @author Thomas Roccia (fr0gger)
     * @link https://unprotect.it/snippet/checking-specific-folder-name/196/
     * @implements VM::CUCKOO_PIPE
     */
    [[nodiscard]] static bool cuckoo_pipe() {
        using NtOpenFile_t = NTSTATUS(__stdcall*)(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
            POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
            ULONG ShareAccess, ULONG OpenOptions);
        using RtlInitUnicodeString_t = void(__stdcall*)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
        using NtClose_t = NTSTATUS(__stdcall*)(HANDLE Handle);

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtOpenFile", "RtlInitUnicodeString", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_open_file = reinterpret_cast<NtOpenFile_t>(funcs[0]);
        const auto rtl_init_unicode_string = reinterpret_cast<RtlInitUnicodeString_t>(funcs[1]);
        const auto nt_close = reinterpret_cast<NtClose_t>(funcs[2]);

        if (!nt_open_file || !rtl_init_unicode_string || !nt_close) {
            return false;
        }

        const wchar_t* pipe_path = L"\\??\\pipe\\cuckoo";
        UNICODE_STRING pipe;
        rtl_init_unicode_string(&pipe, pipe_path);

        OBJECT_ATTRIBUTES object_attributes;
        ZeroMemory(&object_attributes, sizeof(object_attributes));
        object_attributes.Length = sizeof(object_attributes);
        object_attributes.ObjectName = &pipe;
        object_attributes.Attributes = OBJ_CASE_INSENSITIVE;

        IO_STATUS_BLOCK iosb;
        HANDLE h_pipe = nullptr;

        constexpr ACCESS_MASK desired_access = FILE_READ_DATA | FILE_READ_ATTRIBUTES;
        constexpr ULONG share_access = 0;
        constexpr ULONG open_options = FILE_OPEN | FILE_SYNCHRONOUS_IO_NONALERT;

        const NTSTATUS st = nt_open_file(&h_pipe, desired_access, &object_attributes, &iosb, share_access, open_options);
        if (NT_SUCCESS(st)) {
            if (h_pipe) nt_close(h_pipe);
            return core::add(brands::CUCKOO);
        }

        return false;
    }


    /**
     * @brief Check for display configurations commonly found in VMs
     * @category Windows
     * @implements VM::DISPLAY
     */
    [[nodiscard]] static bool display() {
        const HDC hdc = GetDC(nullptr);
        const int bpp = GetDeviceCaps(hdc, BITSPIXEL) *
            GetDeviceCaps(hdc, PLANES);
        const int logpix = GetDeviceCaps(hdc, LOGPIXELSX);
        ReleaseDC(nullptr, hdc);

        // physical monitors are almost always 32bpp and 96â€“144 DPI
        if (bpp != 32 || logpix < 90)
            return true;

        return false;
    }


    /**
     * @brief Check if bogus device string would be accepted
     * @category Windows
     * @author Huntress Research Team
     * @link https://unprotect.it/technique/buildcommdcbandtimeouta/
     * @implements VM::DEVICE_STRING
     */
    [[nodiscard]] static bool device_string() {
        DCB dcb = { 0 };
        COMMTIMEOUTS timeouts = { 0 };

        if (BuildCommDCBAndTimeoutsA("jhl46745fghb", &dcb, &timeouts)) {
            return true;
        } else {
            return false;
        }
    }


    /**
     * @brief Check for VM-specific names for drivers
     * @category Windows
     * @implements VM::DRIVERS
     */
    [[nodiscard]] static bool drivers() {
        struct _SYSTEM_MODULE_INFORMATION {
            PVOID  Reserved[2];
            PVOID  ImageBaseAddress;
            ULONG  ImageSize;
            ULONG  Flags;
            USHORT Index;
            USHORT NameLength;
            USHORT LoadCount;
            USHORT PathLength;
            CHAR   ImageName[256];
        };

        struct _SYSTEM_MODULE_INFORMATION_EX {
            ULONG  NumberOfModules;
            _SYSTEM_MODULE_INFORMATION Module[1];
        };

        using SYSTEM_MODULE_INFORMATION = _SYSTEM_MODULE_INFORMATION;
        using PSYSTEM_MODULE_INFORMATION = _SYSTEM_MODULE_INFORMATION*;
        using SYSTEM_MODULE_INFORMATION_EX = _SYSTEM_MODULE_INFORMATION_EX;
        using PSYSTEM_MODULE_INFORMATION_EX = _SYSTEM_MODULE_INFORMATION_EX*;

        using NtQuerySystemInformationFn = NTSTATUS(__stdcall*)(ULONG SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
        using NtAllocateVirtualMemoryFn = NTSTATUS(__stdcall*)(
            HANDLE ProcessHandle,
            PVOID* BaseAddress,
            ULONG_PTR ZeroBits,
            PSIZE_T RegionSize,
            ULONG AllocationType,
            ULONG Protect
        );
        using NtFreeVirtualMemoryFn = NTSTATUS(__stdcall*)(HANDLE ProcessHandle, PVOID* BaseAddress, PSIZE_T RegionSize, ULONG FreeType);

        constexpr ULONG system_module_information = 11;
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtQuerySystemInformation", "NtAllocateVirtualMemory", "NtFreeVirtualMemory" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_query_system_information = reinterpret_cast<NtQuerySystemInformationFn>(funcs[0]);
        const auto nt_allocate_virtual_memory = reinterpret_cast<NtAllocateVirtualMemoryFn>(funcs[1]);
        const auto nt_free_virtual_memory = reinterpret_cast<NtFreeVirtualMemoryFn>(funcs[2]);

        if (nt_query_system_information == nullptr || nt_allocate_virtual_memory == nullptr || nt_free_virtual_memory == nullptr)
            return false;
        
        ULONG ul_size = 0;
        NTSTATUS status = nt_query_system_information(system_module_information, nullptr, 0, &ul_size);
        if (status != ((NTSTATUS)0xC0000004L)) return false;

        const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);
        PVOID allocated_memory = nullptr;
        SIZE_T region_size = ul_size;
        nt_allocate_virtual_memory(current_process, &allocated_memory, 0, &region_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

        const auto system_module_info_ex = reinterpret_cast<PSYSTEM_MODULE_INFORMATION_EX>(allocated_memory);
        status = nt_query_system_information(system_module_information, system_module_info_ex, ul_size, &ul_size);
        if (!(((NTSTATUS)(status)) >= 0)) {
            nt_free_virtual_memory(current_process, &allocated_memory, &region_size, MEM_RELEASE);
            return false;
        }

        for (ULONG i = 0; i < system_module_info_ex->NumberOfModules; ++i) {
            const char* driverPath = reinterpret_cast<const char*>(system_module_info_ex->Module[i].ImageName);
            if (
                strstr(driverPath, "VBoxGuest") || // only installed after vbox guest additions
                strstr(driverPath, "VBoxMouse") ||
                strstr(driverPath, "VBoxSF")
            ) {
                debug("DRIVERS: Detected VBox driver: ", driverPath);
                nt_free_virtual_memory(current_process, &allocated_memory, &region_size, MEM_RELEASE);
                return core::add(brands::VBOX);
            }

            if (
                strstr(driverPath, "vmusbmouse") ||
                strstr(driverPath, "vmmouse") ||
                strstr(driverPath, "vmmemctl")
            ) {
                debug("DRIVERS: Detected VMware driver: ", driverPath);
                nt_free_virtual_memory(current_process, &allocated_memory, &region_size, MEM_RELEASE);
                return core::add(brands::VMWARE);
            }
        }

        nt_free_virtual_memory(current_process, &allocated_memory, &region_size, MEM_RELEASE);
        return false;
    }


    /**
     * @brief Check for serial numbers of virtual disks
     * @category Windows
     * @implements VM::DISK_SERIAL
     */
    [[nodiscard]] static bool disk_serial_number() {
        using NtOpenFile_t = NTSTATUS(__stdcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG);
        using NtDeviceIoControlFile_t = NTSTATUS(__stdcall*)(HANDLE, HANDLE, PVOID, PVOID, PIO_STATUS_BLOCK, ULONG, PVOID, ULONG, PVOID, ULONG);
        using NtAllocateVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);
        using NtFreeVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG);
        using NtClose_t = NTSTATUS(__stdcall*)(HANDLE);
        using RtlInitUnicodeString_t = void(__stdcall*)(PUNICODE_STRING, PCWSTR);

        bool result = false;
        constexpr u8 MAX_PHYSICAL_DRIVES = 4;
        constexpr SIZE_T MAX_DESCRIPTOR_SIZE = 64 * 1024;
        u8 successful_opens = 0;

        // Helper to detect QEMU instances based on default hard drive serial patterns
        // QEMU drives often start with "QM000" followed by digits
        auto is_qemu_serial = [](const char* str) noexcept -> bool {
            if ((str[0] & 0xDF) != 'Q') return false;
            if ((str[1] & 0xDF) != 'M') return false;

            // we check byte-by-byte to be safe regarding alignment,
            // though a 32-bit integer check (0x30303030) could be used if alignment is guaranteed
            // we also essentially check for null termination safety here because '\0' != '0'
            return str[2] == '0' && str[3] == '0' && str[4] == '0' && str[5] == '0';
        };

        // Helper to detect VirtualBox instances
        // VirtualBox uses a specific serial format "VB" followed by hex segments
        auto is_vbox_serial = [](const char* str, size_t len) noexcept -> bool {
            // format: VB12345678-12345678 (19 chars)
            if (len != 19) return false;

            if ((str[0] & 0xDF) != 'V' || (str[1] & 0xDF) != 'B') {
                return false;
            }
            if (str[10] != '-') return false;

            auto is_hex = [](char c) noexcept -> bool {
                const char lower = c | 0x20;
                return (c >= '0' && c <= '9') 
                    || (lower >= 'a' && lower <= 'f');
            };

            for (size_t i = 2; i < 10; ++i) {
                if (!is_hex(str[i])) return false;
            }

            for (size_t i = 11; i < 19; ++i) {
                if (!is_hex(str[i])) return false;
            }

            return true;
        };

        auto strnlen = [](const char* s, size_t max) noexcept -> size_t {
            const void* p = memchr(s, 0, max);
            if (!p) return max;
            return static_cast<size_t>(static_cast<const char*>(p) - s);
        };

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return result;

        const char* names[] = {
            "RtlInitUnicodeString",
            "NtOpenFile",
            "NtDeviceIoControlFile",
            "NtAllocateVirtualMemory",
            "NtFreeVirtualMemory",
            "NtFlushInstructionCache",
            "NtClose"
        };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto rtl_init_unicode_string = reinterpret_cast<RtlInitUnicodeString_t>(funcs[0]);
        const auto nt_open_file = reinterpret_cast<NtOpenFile_t>(funcs[1]);
        const auto nt_device_io_control_file = reinterpret_cast<NtDeviceIoControlFile_t>(funcs[2]);
        const auto nt_allocate_virtual_memory = reinterpret_cast<NtAllocateVirtualMemory_t>(funcs[3]);
        const auto nt_free_virtual_memory = reinterpret_cast<NtFreeVirtualMemory_t>(funcs[4]);
        const auto nt_close = reinterpret_cast<NtClose_t>(funcs[6]);

        if (!rtl_init_unicode_string || !nt_open_file || !nt_device_io_control_file ||
            !nt_allocate_virtual_memory || !nt_free_virtual_memory || !nt_close) {
            return result;
        }

        // Iterate through the first few physical drives (PhysicalDrive0 to PhysicalDrive3)
        // Most systems boot from 0, and VMs rarely emulate more than 1 or 2 drives by default
        for (u8 drive = 0; drive < MAX_PHYSICAL_DRIVES; ++drive) {
            wchar_t path[32];
            swprintf_s(path, L"\\??\\PhysicalDrive%u", drive);

            UNICODE_STRING unicode_path;
            rtl_init_unicode_string(&unicode_path, path);

            OBJECT_ATTRIBUTES object_attributes;
            RtlZeroMemory(&object_attributes, sizeof(object_attributes));
            object_attributes.Length = sizeof(object_attributes);
            object_attributes.ObjectName = &unicode_path;
            object_attributes.Attributes = OBJ_CASE_INSENSITIVE;
            object_attributes.RootDirectory = nullptr;

            IO_STATUS_BLOCK iosb;
            HANDLE device = nullptr;

            constexpr ACCESS_MASK desired_access = SYNCHRONIZE | FILE_READ_ATTRIBUTES;
            constexpr ULONG share_access = FILE_SHARE_READ | FILE_SHARE_WRITE;
            constexpr ULONG open_options = FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT;

            // Attempt to open the physical drive directly using Native API
            NTSTATUS st = nt_open_file(&device, desired_access, &object_attributes, &iosb, share_access, open_options);
            if (!NT_SUCCESS(st) || device == nullptr) {
                continue;
            }
            ++successful_opens;

            // stack buffer attempt
            // We first try to read the storage properties into a small stack buffer to avoid heap
            BYTE stackBuf[512] = { 0 };
            const STORAGE_DEVICE_DESCRIPTOR* descriptor = reinterpret_cast<STORAGE_DEVICE_DESCRIPTOR*>(stackBuf);

            STORAGE_PROPERTY_QUERY query{};
            query.PropertyId = StorageDeviceProperty;
            query.QueryType = PropertyStandardQuery;

            const ULONG ioctl = IOCTL_STORAGE_QUERY_PROPERTY;

            st = nt_device_io_control_file(device, nullptr, nullptr, nullptr, &iosb,
                ioctl,
                &query, sizeof(query),
                stackBuf, sizeof(stackBuf));

            BYTE* allocated_buffer = nullptr;
            SIZE_T allocated_size = 0;
            const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);

            // If the stack buffer was too small (NtDeviceIoControlFile failed), we fall back 
            // to allocating memory dynamically using NtAllocateVirtualMemory
            if (!NT_SUCCESS(st)) {
                DWORD reported_size = 0;
                if (descriptor && descriptor->Size > 0) {
                    reported_size = descriptor->Size;
                }

                // This branch just ensures the requested size is reasonable before allocating
                if (reported_size > 0 && reported_size < static_cast<DWORD>(MAX_DESCRIPTOR_SIZE) && reported_size >= sizeof(STORAGE_DEVICE_DESCRIPTOR)) {
                    allocated_size = static_cast<SIZE_T>(reported_size);
                    PVOID allocation_base = nullptr;
                    SIZE_T region_size = allocated_size;
                    st = nt_allocate_virtual_memory(current_process, &allocation_base, 0, &region_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
                    if (!NT_SUCCESS(st) || allocation_base == nullptr) {
                        nt_close(device);
                        continue;
                    }
                    allocated_buffer = reinterpret_cast<BYTE*>(allocation_base);

                    // Retry the query with the larger allocated buffer
                    st = nt_device_io_control_file(device, nullptr, nullptr, nullptr, &iosb,
                        ioctl,
                        &query, sizeof(query),
                        allocated_buffer, static_cast<ULONG>(allocated_size));
                    if (!NT_SUCCESS(st)) {
                        PVOID free_base = reinterpret_cast<PVOID>(allocated_buffer);
                        SIZE_T free_size = allocated_size;
                        nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
                        nt_close(device);
                        continue;
                    }
                    descriptor = reinterpret_cast<STORAGE_DEVICE_DESCRIPTOR*>(allocated_buffer);
                }
                else {
                    nt_close(device);
                    continue;
                }
            }

            // This part is just to validate the structure size returned by the driver to prevent out-of-bounds reads
            {
                const DWORD reported_size = descriptor->Size;
                if (reported_size < sizeof(STORAGE_DEVICE_DESCRIPTOR) || static_cast<SIZE_T>(reported_size) > MAX_DESCRIPTOR_SIZE) {
                    if (allocated_buffer) {
                        PVOID free_base = reinterpret_cast<PVOID>(allocated_buffer);
                        SIZE_T free_size = allocated_size;
                        nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
                        allocated_buffer = nullptr;
                    }
                    nt_close(device);
                    continue;
                }
            }

            // Serial number string within the descriptor structure
            const u32 serial_offset = descriptor->SerialNumberOffset;
            if (serial_offset > 0 && serial_offset < descriptor->Size) {
                const char* serial = reinterpret_cast<const char*>(descriptor) + serial_offset;
                const size_t max_avail = static_cast<size_t>(descriptor->Size) - static_cast<size_t>(serial_offset);
                const size_t serialLen = strnlen(serial, max_avail);

                debug("DISK_SERIAL: ", serial);

                // Check the retrieved serial number against known VM artifacts
                if (is_qemu_serial(serial) || is_vbox_serial(serial, serialLen)) {
                    if (allocated_buffer) {
                        PVOID free_base = reinterpret_cast<PVOID>(allocated_buffer);
                        SIZE_T free_size = allocated_size;
                        nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
                        allocated_buffer = nullptr;
                    }
                    nt_close(device);
                    return true;
                }
            }

            // Cleanup for the current iteration if no VM was detected on this drive
            if (allocated_buffer) {
                PVOID free_base = reinterpret_cast<PVOID>(allocated_buffer);
                SIZE_T free_size = allocated_size;
                nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
                allocated_buffer = nullptr;
            }
            nt_close(device);
        }

		// If we couldn't open any physical drives (not even read permissions) it's weird so we flag it.
        if (successful_opens == 0) {
            debug("DISK_SERIAL: No physical drives detected");
            return true;
        }

        return result;
    }


    /**
     * @brief Check for IVSHMEM device presence
     * @category Windows
     * @author dmfrpro (https://github.com/dmfrpro)
     * @implements VM::IVSHMEM
     */
    [[nodiscard]] static bool ivshmem() {
        typedef struct _KEY_FULL_INFORMATION {
            LARGE_INTEGER LastWriteTime;
            ULONG         TitleIndex;
            ULONG         ClassOffset;
            ULONG         ClassLength;
            ULONG         SubKeys;
            ULONG         MaxNameLen;
            ULONG         MaxClassLen;
            ULONG         Values;
            ULONG         MaxValueNameLen;
            ULONG         MaxValueDataLen;
            WCHAR         Class[1];
        } KEY_FULL_INFORMATION, * PKEY_FULL_INFORMATION;

        typedef enum _KEY_INFORMATION_CLASS {
            KeyBasicInformation,
            KeyNodeInformation,
            KeyFullInformation,
            KeyNameInformation,
            KeyCachedInformation,
            KeyFlagsInformation,
            KeyVirtualizationInformation,
            KeyHandleTagsInformation,
            KeyTrustInformation,
            KeyLayerInformation,
            MaxKeyInfoClass
        } KEY_INFORMATION_CLASS;

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "RtlInitUnicodeString", "NtOpenKey", "NtQueryKey", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto rtl_init_unicode_string = reinterpret_cast<void(__stdcall*)(PUNICODE_STRING, PCWSTR)>(funcs[0]);
        const auto nt_open_key = reinterpret_cast<NTSTATUS(__stdcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES)>(funcs[1]);
        const auto nt_query_key = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, KEY_INFORMATION_CLASS, PVOID, ULONG, PULONG)>(funcs[2]);
        const auto nt_close = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE)>(funcs[3]);

        if (!rtl_init_unicode_string || !nt_open_key || !nt_query_key || !nt_close) {
            return false;
        }

        // Targeted GUID for IVSHMEM (Inter-VM Shared Memory).
        // This device is typically used in KVM/QEMU environments (like Looking Glass) to pass memory between host and guest
        constexpr GUID GUID_IVSHMEM_IFACE =
        { 0xdf576976, 0x569d, 0x4672, { 0x95, 0xa0, 0xf5, 0x7e, 0x4e, 0xa0, 0xb2, 0x10 } };

        // Construct the registry path for the DeviceClasses key
        // We access the "DeviceClasses" registry hive directly to find hardware interfaces
        wchar_t interface_class_path[256];
        swprintf_s(
            interface_class_path,
            ARRAYSIZE(interface_class_path),
            L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Control\\DeviceClasses\\{%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}",
            GUID_IVSHMEM_IFACE.Data1, GUID_IVSHMEM_IFACE.Data2, GUID_IVSHMEM_IFACE.Data3,
            GUID_IVSHMEM_IFACE.Data4[0], GUID_IVSHMEM_IFACE.Data4[1], GUID_IVSHMEM_IFACE.Data4[2],
            GUID_IVSHMEM_IFACE.Data4[3], GUID_IVSHMEM_IFACE.Data4[4], GUID_IVSHMEM_IFACE.Data4[5],
            GUID_IVSHMEM_IFACE.Data4[6], GUID_IVSHMEM_IFACE.Data4[7]
        );

        UNICODE_STRING unicode_path;
        rtl_init_unicode_string(&unicode_path, interface_class_path);

        OBJECT_ATTRIBUTES object_attributes;
        RtlZeroMemory(&object_attributes, sizeof(object_attributes));
        object_attributes.Length = sizeof(object_attributes);
        object_attributes.ObjectName = &unicode_path;
        object_attributes.Attributes = OBJ_CASE_INSENSITIVE;

        HANDLE key = nullptr;
        NTSTATUS st = nt_open_key(&key, KEY_READ, &object_attributes);
        if (!NT_SUCCESS(st) || key == nullptr) {
            return false;
        }

        // We query the "Full Information" of the key to get the count of subkeys
        // The existence of the class key alone isn't enough cuz Windows might register the class but have no devices
        // If SubKeys > 0, it means actual device instances (for ex. PCI devices) are registered under this interface
        BYTE info_buffer[512] = {};
        ULONG returned_len = 0;
        st = nt_query_key(key, KeyFullInformation, info_buffer, sizeof(info_buffer), &returned_len);

        DWORD number_of_subkeys = 0;
        if (NT_SUCCESS(st) && returned_len >= sizeof(KEY_FULL_INFORMATION)) {
            auto* kfi = reinterpret_cast<KEY_FULL_INFORMATION*>(info_buffer);
            number_of_subkeys = static_cast<DWORD>(kfi->SubKeys);
        }
        else {
            nt_close(key);
            return false;
        }

        nt_close(key);

        return number_of_subkeys > 0;
    }


    /**
     * @brief Check for GPU capabilities related to VMs
     * @category Windows
     * @implements VM::GPU_CAPABILITIES
     */
    [[nodiscard]] static bool gpu_capabilities() {
        /*
            Microsoft::WRL::ComPtr<IDirect3D9> d3d9 {
                Direct3DCreate9(D3D_SDK_VERSION)
            };

            if (!d3d9) {
                debug("GPU_CAPABILITIES: Direct3DCreate9 failed");
                return true;
            }

            D3DCAPS9 caps;
            if (FAILED(d3d9->GetDeviceCaps(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, &caps))) {
                debug("GPU_CAPABILITIES: GetDeviceCaps failed");
                return false;
            }

            // if the driver cannot adjust the display gamma ramp dynamically but only in full-screen modeâ€”via the IDirect3DDevice9::SetGammaRamp API
            return !(caps.Caps2 & D3DCAPS2_FULLSCREENGAMMA);
        */

        const HDC hdc = GetDC(nullptr);
        if (!hdc) {
            return true;
        }

        const int color_caps = GetDeviceCaps(hdc, COLORMGMTCAPS);
        ReleaseDC(nullptr, hdc);

        return !(color_caps & CM_GAMMA_RAMP) || color_caps == 0;
    }


    /**
     * @brief Check for vm-specific devices
     * @category Windows
     * @implements VM::DEVICE_HANDLES
     */
    [[nodiscard]] static bool device_handles() {
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "RtlInitUnicodeString", "NtOpenFile", "NtClose" };
        void* funcs[sizeof(names) / sizeof(names[0])] = {};
        util::get_function_address(ntdll, names, funcs, (ULONG)(sizeof(names) / sizeof(names[0])));

        const auto rtl_init_unicode_string = reinterpret_cast<void(__stdcall*)(PUNICODE_STRING, PCWSTR)>(funcs[0]);
        const auto nt_open_file = reinterpret_cast<NTSTATUS(__stdcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK, ULONG, ULONG)>(funcs[1]);
        const auto nt_close = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE)>(funcs[2]);

        if (!rtl_init_unicode_string || !nt_open_file || !nt_close) {
            return false;
        }

        auto try_open_mutex = [&](const wchar_t* native_path) noexcept -> HANDLE {
            UNICODE_STRING u_path{};
            u_path.Buffer = const_cast<wchar_t*>(native_path);
            const size_t len_bytes = wcslen(native_path) * sizeof(wchar_t);
            u_path.Length = static_cast<USHORT>(len_bytes);
            u_path.MaximumLength = static_cast<USHORT>(len_bytes + sizeof(wchar_t));

            OBJECT_ATTRIBUTES obj_attr = {
                sizeof(OBJECT_ATTRIBUTES),
                nullptr,
                &u_path,
                OBJ_CASE_INSENSITIVE,
                nullptr,
                nullptr
            };

            IO_STATUS_BLOCK iosb;
            HANDLE h_file = nullptr;

            constexpr ACCESS_MASK desired_access = FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE;
            constexpr ULONG share_access = FILE_SHARE_READ;
            constexpr ULONG open_options = FILE_OPEN | FILE_SYNCHRONOUS_IO_NONALERT;

            const NTSTATUS st = nt_open_file(&h_file, desired_access, &obj_attr, &iosb, share_access, open_options);

            if (NT_SUCCESS(st)) {
                return h_file;
            }
            return INVALID_HANDLE_VALUE;
        };

        constexpr const wchar_t* paths[] = {
            L"\\??\\VBoxMiniRdrDN",    // \\.\VBoxMiniRdrDN
            L"\\??\\pipe\\VBoxMiniRdDN",// \\.\pipe\VBoxMiniRdDN
            L"\\??\\VBoxTrayIPC",      // \\.\VBoxTrayIPC
            L"\\??\\pipe\\VBoxTrayIPC",// \\.\pipe\VBoxTrayIPC
            L"\\??\\HGFS",             // \\.\HGFS (VMware)
            L"\\??\\pipe\\cuckoo"      // \\.\pipe\cuckoo (Cuckoo)
        };

        const size_t path_count = sizeof(paths) / sizeof(paths[0]);
        HANDLE handles[sizeof(paths) / sizeof(paths[0])] = {};

        for (size_t i = 0; i < path_count; ++i) {
            handles[i] = try_open_mutex(paths[i]);
        }

        const bool vbox = (handles[0] != INVALID_HANDLE_VALUE) ||
            (handles[1] != INVALID_HANDLE_VALUE) ||
            (handles[2] != INVALID_HANDLE_VALUE) ||
            (handles[3] != INVALID_HANDLE_VALUE);

        const bool vmware = (handles[4] != INVALID_HANDLE_VALUE);
        const bool cuckoo = (handles[5] != INVALID_HANDLE_VALUE);

        for (size_t i = 0; i < path_count; ++i) {
            if (handles[i] != INVALID_HANDLE_VALUE) {
                (void)nt_close(handles[i]);
                handles[i] = INVALID_HANDLE_VALUE;
            }
        }

        if (vbox) {
            debug("DEVICE_HANDLES: Detected VBox related device handles");
            return core::add(brands::VBOX);
        }

        if (vmware) {
            debug("DEVICE_HANDLES: Detected VMware related device (HGFS)");
            return core::add(brands::VMWARE);
        }

        if (cuckoo) {
            debug("DEVICE_HANDLES: Detected Cuckoo related device (pipe)");
            return core::add(brands::CUCKOO);
        }

        return false;
    }


    /**
     * @brief Check if the number of virtual and logical processors are reported correctly by the system
     * @category Windows, x86
     * @implements VM::VIRTUAL_PROCESSORS
     */
    [[nodiscard]] static bool virtual_processors() {
    #if (x86)
        int regs[4];
        __cpuid(regs, 0x40000000);

        const u32 max_leaf = static_cast<u32>(regs[0]);
        if (max_leaf < 0x40000005) {
            return false;
        }

        __cpuid(regs, 0x40000005);
        const u32 max_virtual_processors = static_cast<u32>(regs[0]);
        const u32 max_logical_processors = static_cast<u32>(regs[1]);

        debug("VIRTUAL_PROCESSORS: MaxVirtualProcessors -> ", max_virtual_processors,
            ", MaxLogicalProcessors -> ", max_logical_processors);

        if (max_virtual_processors == 0xFFFFFFFF || max_logical_processors == 0) {
            return true;
        }
    #endif
        return false;
    }


    /**
     * @brief Check if a call to NtQuerySystemInformation with the 0x9f leaf fills a _SYSTEM_HYPERVISOR_DETAIL_INFORMATION structure
     * @category Windows, x86_64
     * @implements VM::HYPERVISOR_QUERY
     */
    [[nodiscard]] static bool hypervisor_query() {
    #if (x86_32)
        return false;
    #else
        if (util::hyper_x() == HYPERV_ARTIFACT_VM) {
            return false;
        }

        struct HV_DETAILS {
            ULONG Data[4];
        };
        struct SYSTEM_HYPERVISOR_DETAIL_INFORMATION {
            HV_DETAILS HvVendorAndMaxFunction;
            HV_DETAILS HypervisorInterface;
            HV_DETAILS HypervisorVersion;
            HV_DETAILS HvFeatures;
            HV_DETAILS HwFeatures;
            HV_DETAILS EnlightenmentInfo;
            HV_DETAILS ImplementationLimits;
        };

        using PHV_DETAILS = HV_DETAILS*;
        using PSYSTEM_HYPERVISOR_DETAIL_INFORMATION = SYSTEM_HYPERVISOR_DETAIL_INFORMATION*;

        using FN_NtQuerySystemInformation = NTSTATUS(__stdcall*)(
            SYSTEM_INFORMATION_CLASS SystemInformationClass,
            PVOID SystemInformation,
            ULONG SystemInformationLength,
            PULONG ReturnLength
        );

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;        

        const char* names[] = { "NtQuerySystemInformation" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const FN_NtQuerySystemInformation nt_query_system_information = reinterpret_cast<FN_NtQuerySystemInformation>(funcs[0]);
        if (nt_query_system_information) {
            SYSTEM_HYPERVISOR_DETAIL_INFORMATION hypervisor_information = { {} };

            // Request class 0x9F (SystemHypervisorDetailInformation)
            // This asks the OS kernel to fill the structure with information about the 
            // hypervisor layer it is running on top of
            const NTSTATUS status = nt_query_system_information(static_cast<SYSTEM_INFORMATION_CLASS>(0x9F), &hypervisor_information, sizeof(hypervisor_information), nullptr);

            if (status != 0) {
                return false;
            }

            // If Data[0] is non-zero, it means the kernel has successfully communicated 
            // with a hypervisor and retrieved a vendor signature like "Micr" for Microsoft
            if (hypervisor_information.HvVendorAndMaxFunction.Data[0] != 0) {
                return true;
            }
        }
    #endif
        return false;
    }

    
    /**
     * @brief Check for particular object directory which is present in Sandboxie virtual environment but not in usual host systems
     * @category Windows
     * @link https://evasions.checkpoint.com/src/Evasions/techniques/global-os-objects.html
     * @implements VM::VIRTUAL_REGISTRY
     */
    [[nodiscard]] static bool virtual_registry() {
        struct UNICODE_STRING {
            USHORT Length;
            USHORT MaximumLength;
            PWSTR  Buffer;
        };
        struct OBJECT_ATTRIBUTES {
            ULONG Length;
            HANDLE RootDirectory;
            UNICODE_STRING* ObjectName;
            ULONG Attributes;
            PVOID SecurityDescriptor;
            PVOID SecurityQualityOfService;
        };
        enum OBJECT_INFORMATION_CLASS {
            ObjectBasicInformation = 0,
            ObjectNameInformation = 1,
            ObjectTypeInformation = 2
        };
        struct OBJECT_NAME_INFORMATION {
            UNICODE_STRING Name;
        };

        using POBJECT_NAME_INFORMATION = OBJECT_NAME_INFORMATION*;
        using PNtOpenKey = NTSTATUS(__stdcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES );
        using PNtQueryObject = NTSTATUS(__stdcall*)(HANDLE, OBJECT_INFORMATION_CLASS, PVOID, ULONG, PULONG);
    
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;
    
        const char* names[] = { "NtOpenKey", "NtQueryObject", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));
    
        const auto nt_open_key = reinterpret_cast<PNtOpenKey>(funcs[0]);
        const auto nt_query_object = reinterpret_cast<PNtQueryObject>(funcs[1]);
        const auto nt_close = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE)>(funcs[2]);

        if (!nt_open_key || !nt_query_object || !nt_close)
            return false;
    
        // Prepare to open the root USER registry hive
        UNICODE_STRING key_path{};
        key_path.Buffer = const_cast<PWSTR>(L"\\REGISTRY\\USER");
        key_path.Length = static_cast<USHORT>(wcslen(key_path.Buffer) * sizeof(WCHAR));
        key_path.MaximumLength = key_path.Length + sizeof(WCHAR);

        OBJECT_ATTRIBUTES object_attributes = {
            sizeof(OBJECT_ATTRIBUTES),
            nullptr,
            &key_path,
            0x00000040L,  // OBJ_CASE_INSENSITIVE
            nullptr,
            nullptr
        };

        // Attempt to open the key. If we are sandboxed, this open call often succeeds,
        // but the underlying handle will point to a virtualized container, not the real OS path
        HANDLE key = nullptr;
        NTSTATUS status = nt_open_key(&key, KEY_READ, reinterpret_cast<POBJECT_ATTRIBUTES>(&object_attributes));
        if (!(((NTSTATUS)(status)) >= 0))
            return false;

        // Ask the kernel: "What is the actual name of the object this handle points to?"
        // Sandboxie implements file system and registry virtualization by redirecting access
        // While the API pretends we opened "\REGISTRY\USER", the handle might actually point to 
        // something like "\Device\HarddiskVolume2\Sandbox\User\DefaultBox\RegHive"
        alignas(16) BYTE buffer[1024]{};
        ULONG returned_length = 0;
        status = nt_query_object(key, ObjectNameInformation, buffer, sizeof(buffer), &returned_length);
        nt_close(key);
        if (!(((NTSTATUS)(status)) >= 0))
            return false;

        const auto object_name = reinterpret_cast<POBJECT_NAME_INFORMATION>(buffer);

        UNICODE_STRING expected_name{};
        expected_name.Buffer = const_cast<PWSTR>(L"\\REGISTRY\\USER");
        expected_name.Length = static_cast<USHORT>(wcslen(expected_name.Buffer) * sizeof(WCHAR));

        // Compare the requested name vs the actual kernel object name
        // If they don't match, we have been redirected, confirming the presence of Sandboxie
        const bool mismatch = (object_name->Name.Length != expected_name.Length) ||
            (memcmp(object_name->Name.Buffer, expected_name.Buffer, expected_name.Length) != 0);

        return mismatch ? core::add(brands::SANDBOXIE) : false;
    }
    
    
    /**
     * @brief Check if no waveform-audio output devices are present in the system
     * @category Windows
     * @implements VM::AUDIO
     */
    [[nodiscard]] static bool audio() {
        struct KEY_FULL_INFORMATION {
            LARGE_INTEGER LastWriteTime;
            ULONG         TitleIndex;
            ULONG         ClassOffset;
            ULONG         ClassLength;
            ULONG         SubKeys;
            ULONG         MaxNameLen;
            ULONG         MaxClassLen;
            ULONG         Values;             
            ULONG         MaxValueNameLen;
            ULONG         MaxValueDataLen;
            WCHAR         Class[1];
        };
        using PKEY_FULL_INFORMATION = KEY_FULL_INFORMATION*;

        enum KEY_INFORMATION_CLASS {
            KeyBasicInformation,
            KeyNodeInformation,
            KeyFullInformation,
            KeyNameInformation,
            KeyCachedInformation,
            KeyFlagsInformation,
            KeyVirtualizationInformation,
            KeyHandleTagsInformation,
            KeyTrustInformation,
            KeyLayerInformation,
            MaxKeyInfoClass
        };

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "RtlInitUnicodeString", "NtOpenKey", "NtQueryKey", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto rtl_init_unicode_string = reinterpret_cast<void(__stdcall*)(PUNICODE_STRING, PCWSTR)>(funcs[0]);
        const auto nt_open_key = reinterpret_cast<NTSTATUS(__stdcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES)>(funcs[1]);
        const auto nt_query_key = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, KEY_INFORMATION_CLASS, PVOID, ULONG, PULONG)>(funcs[2]);
        const auto nt_close = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE)>(funcs[3]);

        if (!rtl_init_unicode_string || !nt_open_key || !nt_query_key || !nt_close) {
            return false;
        }

        // We are checking for the presence of Audio Render devices
        // Most legitimate user PCs have speakers or headphones (audio endpoints)
        // Automated sandboxes and headless servers often have no audio devices configured
        // We target the MMDevices\Audio\Render key where these endpoints are registered
        const wchar_t* native_path = L"\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\MMDevices\\Audio\\Render";

        UNICODE_STRING unicode_path;
        rtl_init_unicode_string(&unicode_path, native_path);

        OBJECT_ATTRIBUTES object_attributes;
        RtlZeroMemory(&object_attributes, sizeof(object_attributes));
        object_attributes.Length = sizeof(object_attributes);
        object_attributes.ObjectName = &unicode_path;
        object_attributes.Attributes = OBJ_CASE_INSENSITIVE;

        HANDLE key = nullptr;
        const ACCESS_MASK desired_access = KEY_READ;

        NTSTATUS st = nt_open_key(&key, desired_access, &object_attributes);
        if (!NT_SUCCESS(st) || key == nullptr) {
            return false;
        }

        constexpr KEY_INFORMATION_CLASS InfoClass = KeyFullInformation;
        std::vector<BYTE> info_buffer(512);
        ULONG returned_len = 0;

        // Query the key information. If the buffer is too small (STATUS_BUFFER_TOO_SMALL),
        // resize it to the exact length required by the kernel and try again
        st = nt_query_key(key, InfoClass, info_buffer.data(), static_cast<ULONG>(info_buffer.size()), &returned_len);

        if (!NT_SUCCESS(st) && returned_len > info_buffer.size()) {
            info_buffer.resize(returned_len);
            st = nt_query_key(key, InfoClass, info_buffer.data(), static_cast<ULONG>(info_buffer.size()), &returned_len);
        }

        bool has_values = false;
        if (NT_SUCCESS(st) && returned_len >= sizeof(KEY_FULL_INFORMATION)) {
            const auto* kfi = reinterpret_cast<PKEY_FULL_INFORMATION>(info_buffer.data());

            // Check if the registry key has any values associated with it
            // If 'Values' is 0, the audio system is likely uninitialized or barren,
            // which strongly suggests a virtualized/sandbox environment
            const DWORD value_count = static_cast<DWORD>(kfi->Values); // values, not subkeys
            has_values = (value_count > 0);
        }
        else {
            nt_close(key);
            return false;
        }

        nt_close(key);

        return has_values;
    }
    
    
    /**
     * @brief Check for VM-specific ACPI device signatures
     * @category Windows
     * @implements VM::ACPI_SIGNATURE
     */
    [[nodiscard]] static bool acpi_signature() {
        auto is_hex = [](wchar_t c) noexcept -> bool {
            return (c >= L'0' && c <= L'9') || (c >= L'A' && c <= L'F');
        };

        // enumerate all DISPLAY devices
        const HDEVINFO handle_dev_info = SetupDiGetClassDevsW(&GUID_DEVCLASS_DISPLAY, nullptr, nullptr, DIGCF_PRESENT);
        if (handle_dev_info == INVALID_HANDLE_VALUE) {
            debug("ACPI_SIGNATURE: No display device detected");
            return true;
        }

        SP_DEVINFO_DATA dev_info;
        ZeroMemory(&dev_info, sizeof(dev_info));
        dev_info.cbSize = sizeof(dev_info);
        const DEVPROPKEY key = DEVPKEY_Device_LocationPaths;

        // baremetal tokens (case-sensitive to preserve handling against edge-cases)
        static constexpr const wchar_t* excluded_tokens[] = {
            L"GFX",
            L"IGD", L"IGFX", L"IGPU",
            L"VGA", L"VIDEO", L"DISPLAY", L"GPU",
            L"PCIROOT", L"PNP0A03", L"PNP0A08",
            L"PCH", L"PXS", L"PEG", L"PEGP"
        };

        auto has_excluded_token = [&](const wchar_t* s) noexcept -> bool {
            if (!s || !*s) return false;
            for (const wchar_t* tok : excluded_tokens) {
                if (wcsstr(s, tok) != nullptr) return true;
            }
            return false;
        };

        for (DWORD idx = 0; SetupDiEnumDeviceInfo(handle_dev_info, idx, &dev_info); ++idx) {
            DEVPROPTYPE prop_type = 0;
            DWORD required_size = 0;

            // query required size (bytes)
            SetupDiGetDevicePropertyW(handle_dev_info, &dev_info, &key, &prop_type, nullptr, 0, &required_size, 0);
            if (GetLastError() != ERROR_INSUFFICIENT_BUFFER || required_size == 0) {
                if (GetLastError() == ERROR_NOT_FOUND) {
                    debug("ACPI_SIGNATURE: No dedicated display/GPU detected");
                    SetupDiDestroyDeviceInfoList(handle_dev_info);
                    return false;
                }
                else {
                    continue;
                }
            }

            // fetch buffer (multi-sz)
            std::vector<BYTE> buffer(required_size);
            if (!SetupDiGetDevicePropertyW(handle_dev_info, &dev_info, &key, &prop_type,
                buffer.data(), required_size, &required_size, 0))
            {
                continue;
            }

            const wchar_t* ptr = reinterpret_cast<const wchar_t*>(buffer.data());
            // number of wchar_t slots in buffer
            const size_t total_wchars = required_size / sizeof(wchar_t);
            const wchar_t* buf_end = ptr + (total_wchars ? total_wchars : 0);

        #ifdef __VMAWARE_DEBUG__
            for (const wchar_t* p = ptr; p < buf_end && *p; p += (wcslen(p) + 1)) {
                debug("ACPI_SIGNATURE: ", p);
            }
        #endif

            static const wchar_t acpi_prefix[] = L"#ACPI(S";
            static const wchar_t acpi_paren[] = L"ACPI(";

            // First pass: QEMU-style "#ACPI(Sxx...)" and generic "ACPI(Sxx)"
            for (const wchar_t* p = ptr; p < buf_end && *p; p += (wcslen(p) + 1)) {
                if (has_excluded_token(p)) {
                    debug("ACPI_SIGNATURE: Valid signature -> ", p);
                    continue;
                }

                // search for "#ACPI(S"
                const wchar_t* search = p;
                while (true) {
                    const wchar_t* found = wcsstr(search, acpi_prefix);
                    if (!found) break;

                    // after "#ACPI(S" we expect two hex chars
                    const wchar_t* hexpos = found + wcslen(acpi_prefix); // first hex char
                    if (hexpos && hexpos[0] && hexpos[1]) {
                        wchar_t b = hexpos[0];
                        wchar_t s = hexpos[1];
                        if (is_hex(b) && is_hex(s)) {
                            const wchar_t after = hexpos[2]; // may be '_' or ')'
                            if (after == L'_' || after == L')') {
                                SetupDiDestroyDeviceInfoList(handle_dev_info);
                                return core::add(brands::QEMU);
                            }
                        }
                    }
                    search = found + 1;
                }

                // search for "ACPI(" then check for "S" + two hex digits
                search = p;
                while (true) {
                    const wchar_t* found = wcsstr(search, acpi_paren);
                    if (!found) break;
                    const wchar_t* start = found + wcslen(acpi_paren); // char after '('
                    if (start && start[0] && start[1] && start[2]) {
                        if (start[0] == L'S' && is_hex(start[1]) && is_hex(start[2])) {
                            SetupDiDestroyDeviceInfoList(handle_dev_info);
                            return core::add(brands::QEMU);
                        }
                    }
                    search = found + 1;
                }
            }

            // Important to run Hyper-V checks later because of is_hardened() logic
            static constexpr const wchar_t* vm_signatures[] = {
                L"#ACPI(VMOD)", L"#ACPI(VMBS)", L"#VMBUS(", L"#VPCI("
            };

            for (const wchar_t* p = ptr; p < buf_end && *p; p += (wcslen(p) + 1)) {
                if (has_excluded_token(p)) continue;

                for (const wchar_t* sig : vm_signatures) {
                    if (wcsstr(p, sig) != nullptr) {
                        SetupDiDestroyDeviceInfoList(handle_dev_info);
                        return core::add(brands::HYPERV);
                    }
                }
            }
        }

        SetupDiDestroyDeviceInfoList(handle_dev_info);
        return false;
    }


    /**
     * @brief Check if after raising two traps at the same RIP, a hypervisor interferes with the instruction pointer delivery
     * @category Windows, x86_64
     * @implements VM::TRAP
     */
    [[nodiscard]] static bool trap() {
        bool hypervisor_caught = false;
    #if (x86_64)
        // when a single - step(TF) and hardware breakpoint(DR0) collide, Intel CPUs set both DR6.BS and DR6.B0 to report both events, which help make this detection trick
        // AMD CPUs prioritize the breakpoint, setting only its corresponding bit in DR6 and clearing the single-step bit, which is why this technique is not compatible with AMD
        if (!cpu::is_intel()) {
            return false;
        }

        // mobile SKUs can "false flag" this check
        const char* brand = cpu::get_brand();
        for (const char* c = brand; *c; ++c) {
            if (*c == 'U') {
                if (c > brand && (c[-1] >= '0' && c[-1] <= '9')) {
                    if (c[1] == ' ' || c[1] == '\0') {
                        return false;
                    }
                }
            }
        }

        // We must preserve RBX because CPUID clobbers it, and RBX is a non-volatile 
        // register in x64. If we don't restore it, the calling function (VM::check) crashes
        // we use MOV R8, RBX instead of PUSH RBX. Pushing to the stack without 
        // unwind metadata breaks SEH in x64 (OS cannot find the handler), causing a crash
        constexpr u8 trampoline[] = {
            0x49, 0x89, 0xD8,                     // mov r8, rbx      (save rbx to volatile register r8)
            0x9C,                                 // pushfq
            0x81, 0x04, 0x24,                     // OR DWORD PTR [RSP], 0x10100 (Set TF)
            0x00, 0x01, 0x01, 0x00,
            0x9D,                                 // popfq
            0x0F, 0xA2,                           // cpuid 
            0x4C, 0x89, 0xC3,                     // mov rbx, r8      (restore rbx from r8) - trap happens here
            0xC3                                  // ret
        };
        SIZE_T trampoline_size = sizeof(trampoline);

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = {
            "NtAllocateVirtualMemory",
            "NtProtectVirtualMemory",
            "NtFreeVirtualMemory",
            "NtFlushInstructionCache",
            "NtClose",
            "NtGetContextThread",
            "NtSetContextThread"
        };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        using NtAllocateVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);
        using NtProtectVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG);
        using NtFreeVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG);
        using NtFlushInstructionCache_t = NTSTATUS(__stdcall*)(HANDLE, PVOID, SIZE_T);
        using NtClose_t = NTSTATUS(__stdcall*)(HANDLE);
        using NtGetContextThread_t = NTSTATUS(__stdcall*)(HANDLE, PCONTEXT);
        using NtSetContextThread_t = NTSTATUS(__stdcall*)(HANDLE, PCONTEXT);

        // volatile ensures these are loaded from stack after SEH unwind when compiled with aggresive optimizations
        NtAllocateVirtualMemory_t volatile nt_allocate_virtual_memory = reinterpret_cast<NtAllocateVirtualMemory_t>(funcs[0]);
        NtProtectVirtualMemory_t volatile nt_protect_virtual_memory = reinterpret_cast<NtProtectVirtualMemory_t>(funcs[1]);
        NtFreeVirtualMemory_t volatile nt_free_virtual_memory = reinterpret_cast<NtFreeVirtualMemory_t>(funcs[2]);
        NtFlushInstructionCache_t volatile nt_flush_instruction_cache = reinterpret_cast<NtFlushInstructionCache_t>(funcs[3]);
        NtClose_t volatile nt_close = reinterpret_cast<NtClose_t>(funcs[4]);
        NtGetContextThread_t volatile nt_get_context_thread = reinterpret_cast<NtGetContextThread_t>(funcs[5]);
        NtSetContextThread_t volatile nt_set_context_thread = reinterpret_cast<NtSetContextThread_t>(funcs[6]);

        if (!nt_allocate_virtual_memory || !nt_protect_virtual_memory || !nt_flush_instruction_cache ||
            !nt_free_virtual_memory || !nt_get_context_thread || !nt_set_context_thread || !nt_close) {
            return false;
        }

        PVOID exec_mem = nullptr;
        SIZE_T region_size = trampoline_size;
        const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);
        NTSTATUS st = nt_allocate_virtual_memory(current_process, &exec_mem, 0, &region_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!NT_SUCCESS(st) || !exec_mem) {
            return false;
        }
        memcpy(exec_mem, trampoline, trampoline_size);

        {
            PVOID tmp_base = exec_mem;
            SIZE_T tmp_sz = trampoline_size;
            ULONG oldProt = 0;
            st = nt_protect_virtual_memory(current_process, &tmp_base, &tmp_sz, PAGE_EXECUTE_READ, &oldProt);
            if (!NT_SUCCESS(st)) {
                PVOID free_base = exec_mem;
                SIZE_T free_size = trampoline_size;
                nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
                return false;
            }
        }

        nt_flush_instruction_cache(current_process, exec_mem, trampoline_size);

        u8 hitCount = 0;

        CONTEXT original_context{};
        original_context.ContextFlags = CONTEXT_DEBUG_REGISTERS;
        const HANDLE current_thread = reinterpret_cast<HANDLE>(-2LL);

        if (!NT_SUCCESS(nt_get_context_thread(current_thread, &original_context))) {
            PVOID free_base = exec_mem;
            SIZE_T free_size = trampoline_size;
            nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
            return false;
        }

        // Set DR0 to trampoline + 14 (Instruction: mov rbx, r8)
        // Offset calculation: mov_r8_rbx(3) + pushfq(1) + or(7) + popfq(1) + cpuid(2) = 14
        // This is where single step traps after CPUID, and where we want the collision
        const uintptr_t expected_trap_address = reinterpret_cast<uintptr_t>(exec_mem) + 14;

        // set Dr0 to trampoline+offset
        CONTEXT debug_context = original_context;
        debug_context.Dr0 = expected_trap_address; // single step breakpoint address
        debug_context.Dr7 = 1; // enable Local Breakpoint 0

        if (!NT_SUCCESS(nt_set_context_thread(current_thread, &debug_context))) {
            nt_set_context_thread(current_thread, &original_context);
            PVOID free_base = exec_mem;
            SIZE_T free_size = trampoline_size;
            nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
            return false;
        }

        // Context structure to pass data to the static SEH handler
        struct trap_context {
            uintptr_t expectedTrapAddr;
            u8* hitCount;
            bool* hypervisor_caught;
        };

        // Static class for SEH filtering to avoid Release mode Lambda corruption
        struct SEH_Trap {
            static LONG Vet(u32 code, EXCEPTION_POINTERS* info, trap_context* ctx) noexcept {
                // Lambda returns LONG to support EXCEPTION_CONTINUE_EXECUTION
                if (code != static_cast<DWORD>(0x80000004L)) {
                    return EXCEPTION_CONTINUE_SEARCH;
                }

                // Verify exception happened at our calculated offset
                if (reinterpret_cast<uintptr_t>(info->ExceptionRecord->ExceptionAddress) != ctx->expectedTrapAddr) {
                    info->ContextRecord->EFlags &= ~0x100; // Clear TF
                    info->ContextRecord->Dr7 &= ~1;        // Clear DR0 Enable
                    *ctx->hypervisor_caught = true;
                    return EXCEPTION_CONTINUE_EXECUTION;
                }

                (*ctx->hitCount)++;

                // check if Trap Flag and DR0 contributed
                constexpr u64 required_bits = (1ULL << 14) | 1ULL; // BS | B0
                const u64 status = info->ContextRecord->Dr6;

                if ((status & required_bits) != required_bits) {
                    if (util::hyper_x() != HYPERV_ARTIFACT_VM) // detects type 1 Hyper-V too, which we consider legitimate
                        *ctx->hypervisor_caught = true;
                }

                // Clear Trap Flag to stop single stepping
                info->ContextRecord->EFlags &= ~0x100;

                // Clear DR7 Local Enable 0 to disable the hardware breakpoint
                // If we don't do this, the next instruction will trigger the breakpoint again immediately
                info->ContextRecord->Dr7 &= ~1;

                // executes mov rbx, r8 (restore), and returns
                return EXCEPTION_CONTINUE_EXECUTION;
            }
        };

        trap_context ctx = { expected_trap_address, &hitCount, &hypervisor_caught };

        __try {
            reinterpret_cast<void(*)()>(exec_mem)();
        }
        __except (SEH_Trap::Vet(_exception_code(), reinterpret_cast<EXCEPTION_POINTERS*>(_exception_info()), &ctx)) {
            // This block is effectively unreachable because vetExceptions returns CONTINUE_EXECUTION or CONTINUE_SEARCH
        }

        // If the hypervisor swallowed the exception entirely, hitCount will be 0
        if (hitCount != 1) {
            hypervisor_caught = true;
        }

        nt_set_context_thread(current_thread, &original_context);

        PVOID free_base = exec_mem;
        SIZE_T free_size = trampoline_size;
        nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
    #endif
        return hypervisor_caught;
    }


    /**
     * @brief Check if after executing an undefined instruction, a hypervisor misinterpret it as a system call
     * @category Windows
     * @implements VM::UD
     */
    [[nodiscard]] static bool ud() {
    #if (x86)
        // ud2; ret
        constexpr u8 ud_opcodes[] = { 0x0F, 0x0B, 0xC3 };
    #elif (ARM32)
        // udf #0; bx lr
        // (Little-endian for 0xE7F000F0 and 0xE12FFF1E)
        constexpr u8 ud_opcodes[] = { 0xF0, 0x00, 0xF0, 0xE7, 0x1E, 0xFF, 0x2F, 0xE1 };
    #elif (ARM64)
        // hlt #0; ret
        // (Little-endian for 0xD4400000 and 0xD65F03C0)
        constexpr u8 ud_opcodes[] = { 0x00, 0x00, 0x40, 0xD4, 0xC0, 0x03, 0x5F, 0xD6 };
    #else
        // architecture not supported by this check
        return false;
    #endif
        
        bool saw_ud = false;
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtAllocateVirtualMemory", "NtProtectVirtualMemory", "NtFlushInstructionCache", "NtFreeVirtualMemory" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_allocate_virtual_memory = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG)>(funcs[0]);
        const auto nt_protect_virtual_memory = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG)>(funcs[1]);
        const auto nt_flush_instruction_cache = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID, SIZE_T)>(funcs[2]);
        const auto nt_free_virtual_memory = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG)>(funcs[3]);

        if (!nt_allocate_virtual_memory || !nt_protect_virtual_memory || !nt_flush_instruction_cache || !nt_free_virtual_memory) {
            return false;
        }

        const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);
        PVOID base = nullptr;
        SIZE_T region_size = sizeof(ud_opcodes);
        NTSTATUS st = nt_allocate_virtual_memory(current_process, &base, 0, &region_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!NT_SUCCESS(st) || !base) {
            return false;
        }

        memcpy(base, ud_opcodes, sizeof(ud_opcodes));

        ULONG old_protection = 0;
        st = nt_protect_virtual_memory(current_process, &base, &region_size, PAGE_EXECUTE_READ, &old_protection);
        if (!NT_SUCCESS(st)) {
            nt_free_virtual_memory(current_process, &base, &region_size, MEM_RELEASE);
            return false;
        }

        nt_flush_instruction_cache(current_process, base, region_size);

        __try {
            reinterpret_cast<void(*)()>(base)();
        }
        __except (GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            saw_ud = true;
        }

        nt_free_virtual_memory(current_process, &base, &region_size, MEM_RELEASE);

        return !saw_ud;
    }


    /**
     * @brief Check if a hypervisor does not properly restore the interruptibility state after a VM-exit in compatibility mode
     * @category Windows
     * @implements VM::BLOCKSTEP
     */
    [[nodiscard]] static bool blockstep() {  
    #if (x86_32 && MSVC && !CLANG)
        volatile int saw_single_step = 0;

        __try
        {
            __asm
            {
                // set TF in EFLAGS
                pushfd
                or dword ptr[esp], 0x100
                popfd

                // execute MOV SS,AX (reload SS with itself) to force the interruptible state block
                mov ax, ss
                mov ss, ax // this blocks any debug exception for exactly one instruction

                // because TF was set, CPUID would normally cause a #DB on the next instruction.
                xor eax, eax
                cpuid

                // one extra instruction: on bare metal, TF's single-step now fires here
                nop

                pushfd
                and dword ptr[esp], 0xFFFFFEFF
                popfd
            }
        }
        __except (GetExceptionCode() == EXCEPTION_SINGLE_STEP
            ? EXCEPTION_EXECUTE_HANDLER
            : EXCEPTION_CONTINUE_SEARCH)
        {
            saw_single_step = 1;
        }
        return (saw_single_step == 0) ? true : false;
    #else
        return false;
    #endif
    }


    /**
     * @brief Check if Dark Byte's VM is present
     * @category Windows
     * @implements VM::DBVM
     */
    [[nodiscard]] static bool dbvm() {
    #if (!x86_64)
        return false;
    #else
        constexpr u64 PW1 = 0x0000000076543210ULL;
        constexpr u64 PW3 = 0x0000000090909090ULL;
        constexpr u32 PW2 = 0xFEDCBA98U;

        struct vmcall_info {
            u32 structsize;
            u32 level2pass;
            u32 command;
        };

        vmcall_info vmcall_info = {};
        u64 vmcall_result = 0;

        constexpr u8 intel_template[44] = {
            0x48,0xBA,0,0,0,0,0,0,0,0,                     // mov rdx, imm64   ; PW1
            0x48,0xB9,0,0,0,0,0,0,0,0,                     // mov rcx, imm64   ; PW3
            0x48,0xB8,0,0,0,0,0,0,0,0,                     // mov rax, imm64   ; &vmcallInfo
            0x0F,0x01,0xC1,                                // vmcall
            0x48,0xA3,0,0,0,0,0,0,0,0,                     // mov [imm64], rax ; &vmcallResult
            0xC3                                           // ret
        };

        constexpr u8 amd_template[44] = {
            0x48,0xBA,0,0,0,0,0,0,0,0,                     // mov rdx, imm64   ; PW1
            0x48,0xB9,0,0,0,0,0,0,0,0,                     // mov rcx, imm64   ; PW3
            0x48,0xB8,0,0,0,0,0,0,0,0,                     // mov rax, imm64   ; &vmcallInfo
            0x0F,0x01,0xD9,                                // vmmcall (AMD)
            0x48,0xA3,0,0,0,0,0,0,0,0,                     // mov [imm64], rax ; &vmcallResult
            0xC3                                           // ret
        };

        const SIZE_T stub_size = sizeof(intel_template);
        const bool is_amd = cpu::is_amd();

        const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtAllocateVirtualMemory", "NtProtectVirtualMemory", "NtFlushInstructionCache", "NtFreeVirtualMemory" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_allocate_virtual_memory = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG)>(funcs[0]);
        const auto nt_protect_virtual_memory = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG)>(funcs[1]);
        const auto nt_flush_instruction_cache = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID, SIZE_T)>(funcs[2]);
        const auto nt_free_virtual_memory = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG)>(funcs[3]);

        if (!nt_allocate_virtual_memory || !nt_protect_virtual_memory || !nt_flush_instruction_cache || !nt_free_virtual_memory) {
            return false;
        }

        PVOID stub = nullptr;
        SIZE_T region_size = stub_size;
        NTSTATUS st = nt_allocate_virtual_memory(current_process, &stub, 0, &region_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        if (!NT_SUCCESS(st) || !stub) return false;

        if (is_amd) {
            memcpy(stub, amd_template, stub_size);
        }
        else {
            memcpy(stub, intel_template, stub_size);
        }

        // rdx imm64
        // rcx imm64
        // rax imm64
        // mov [imm64], rax immediate
        *reinterpret_cast<u64*>(reinterpret_cast<u8*>(stub) + 2) = PW1;
        *reinterpret_cast<u64*>(reinterpret_cast<u8*>(stub) + 12) = PW3;
        *reinterpret_cast<u64*>(reinterpret_cast<u8*>(stub) + 22) = reinterpret_cast<u64>(static_cast<void*>(&vmcall_info));
        *reinterpret_cast<u64*>(reinterpret_cast<u8*>(stub) + 35) = reinterpret_cast<u64>(static_cast<void*>(&vmcall_result));

        ULONG old_protection = 0;
        st = nt_protect_virtual_memory(current_process, &stub, &region_size, PAGE_EXECUTE_READ, &old_protection);
        if (!NT_SUCCESS(st)) {
            nt_free_virtual_memory(current_process, &stub, &region_size, MEM_RELEASE);
            return false;
        }

        nt_flush_instruction_cache(current_process, stub, region_size);

        auto tryPass = [&]() noexcept -> bool {
            // store forwarding in modern CPUs
            vmcall_info.structsize = static_cast<u32>(sizeof(vmcall_info));
            vmcall_info.level2pass = PW2;
            vmcall_info.command = 0;
            vmcall_result = 0;

            __try {
                reinterpret_cast<void(*)()>(stub)();
            }
            __except (EXCEPTION_EXECUTE_HANDLER) { // EXCEPTION_ILLEGAL_INSTRUCTION normally, EXCEPTION_ACCESS_VIOLATION_READ on edge-cases
                vmcall_result = 0;
            }

            return (((vmcall_result >> 24) & 0xFF) == 0xCE); // the VM returns status in bits 24â€“31; Cheat Engine uses 0xCE here
        };

        const bool found = tryPass();

        nt_free_virtual_memory(current_process, &stub, &region_size, MEM_RELEASE);

        if (found) return core::add(brands::DBVM);

        return false;
    #endif
    }


    /**
     * @brief Check boot logo for known VM images
     * @category Windows, x86_64
     * @author Teselka (https://github.com/Teselka)
     * @implements VM::BOOT_LOGO
     */
    [[nodiscard]] static bool boot_logo()
    #if (x86 && (CLANG || GCC))
        __attribute__((__target__("crc32")))
    #endif
    {
    #if (x86_64)
        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll)
            return false;

        const char* function_names[] = { "NtQuerySystemInformation" };
        void* functions[1] = { nullptr };
        util::get_function_address(ntdll, function_names, functions, 1);

        using NtQuerySysInfo_t = NTSTATUS(__stdcall*)(SYSTEM_INFORMATION_CLASS, PVOID, ULONG, PULONG);
        NtQuerySysInfo_t nt_query = reinterpret_cast<NtQuerySysInfo_t>(functions[0]);
        if (!nt_query)
            return false;

        // determine required buffer size
        const SYSTEM_INFORMATION_CLASS sys_boot_info = static_cast<SYSTEM_INFORMATION_CLASS>(140);
        ULONG needed = 0;
        NTSTATUS st = nt_query(sys_boot_info, nullptr, 0, &needed);
        if (st != static_cast<NTSTATUS>(0xC0000023) && st != static_cast<NTSTATUS>(0x80000005) && st != static_cast<NTSTATUS>(0xC0000004))
            return false;

        std::vector<u8> buffer(needed);

        // fetch the boot-logo data
        st = nt_query(sys_boot_info, buffer.data(), needed, &needed);
        if (!NT_SUCCESS(st))
            return false;

        // parse header to locate the bitmap
        struct boot_logo_info { ULONG flags, bitmap_offset; };
        const auto* info = reinterpret_cast<boot_logo_info*>(buffer.data());
        if (info->bitmap_offset >= needed) return false;
        const u8* bmp = buffer.data() + info->bitmap_offset;
        const size_t size = static_cast<size_t>(needed) - info->bitmap_offset;

        // struct + function to isolate SEH from the stack frame containing std::vector and use __target__
        struct crc {
            #if (GCC || CLANG)
                __attribute__((__target__("sse4.2")))
            #endif
                static u32 compute(const u8* data, size_t len) {
                // 8 byte chunks
                u64 crcReg = 0xFFFFFFFFull;
                const size_t qwords = len >> 3;
                const auto* ptr = reinterpret_cast<const u64*>(data);

                size_t i = 0;

                __try {
                    // Unrolled loop
                    for (; i + 3 < qwords; i += 4) {
                        crcReg = _mm_crc32_u64(crcReg, ptr[i]);
                        crcReg = _mm_crc32_u64(crcReg, ptr[i + 1]);
                        crcReg = _mm_crc32_u64(crcReg, ptr[i + 2]);
                        crcReg = _mm_crc32_u64(crcReg, ptr[i + 3]);
                    }

                    for (; i < qwords; ++i) {
                        crcReg = _mm_crc32_u64(crcReg, ptr[i]);
                    }

                    u32 crc = static_cast<u32>(crcReg);
                    const auto* tail = reinterpret_cast<const u8*>(ptr + qwords);

                    for (size_t j = 0, r = len & 7; j < r; ++j) {
                        crc = _mm_crc32_u8(crc, tail[j]);
                    }
                    crc ^= 0xFFFFFFFFu;
                    return crc;
                }
                __except (EXCEPTION_EXECUTE_HANDLER) {
                    return 0;
                }
            }
        };

        const u32 hash = crc::compute(bmp, size);

        debug("BOOT_LOGO: size=", needed, ", flags=", info->flags, ", offset=", info->bitmap_offset, ", crc=0x", std::hex, hash);

        switch (hash) {
            case 0x110350C5: return core::add(brands::QEMU); // TianoCore EDK2
            case 0x87c39681: return core::add(brands::HYPERV);
            case 0xf6829262: return core::add(brands::VBOX);
            default:         return false;
        }
    #else
        return false;
    #endif
    }


    /**
     * @brief Check for any signs of VMs in Windows kernel object entities 
     * @category Windows
     * @implements VM::KERNEL_OBJECTS
     */
    [[nodiscard]] static bool kernel_objects() {
        struct OBJECT_DIRECTORY_INFORMATION {
            UNICODE_STRING Name;
            UNICODE_STRING TypeName;
        };

        using POBJECT_DIRECTORY_INFORMATION = OBJECT_DIRECTORY_INFORMATION*;
        constexpr auto DIRECTORY_QUERY = 0x0001;
        constexpr NTSTATUS STATUS_NO_MORE_ENTRIES = 0x8000001A;

        HANDLE dir = nullptr;
        OBJECT_ATTRIBUTES object_attributes{};
        UNICODE_STRING dir_name{};
        NTSTATUS status;

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtOpenDirectoryObject", "NtQueryDirectoryObject", "NtClose" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        const auto nt_open_directory_object = reinterpret_cast<NTSTATUS(__stdcall*)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES)>(funcs[0]);
        const auto nt_query_directory_object = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE, PVOID, ULONG, BOOLEAN, BOOLEAN, PULONG, PULONG)>(funcs[1]);
        const auto nt_close = reinterpret_cast<NTSTATUS(__stdcall*)(HANDLE)>(funcs[2]);

        if (!nt_open_directory_object || !nt_query_directory_object || !nt_close) return false;

        // Prepare to open the root "\Device" directory in the Object Manager namespace
        // This is different from the file system and we are looking for kernel objects created by drivers
        const wchar_t* device_dir_path = L"\\Device";
        dir_name.Buffer = (PWSTR)device_dir_path;
        dir_name.Length = (USHORT)(wcslen(device_dir_path) * sizeof(wchar_t));
        dir_name.MaximumLength = dir_name.Length + sizeof(wchar_t);

        InitializeObjectAttributes(&object_attributes, &dir_name, OBJ_CASE_INSENSITIVE, nullptr, nullptr);

        // Open the directory object so we can enumerate its contents
        status = nt_open_directory_object(&dir, DIRECTORY_QUERY, &object_attributes);

        if (!NT_SUCCESS(status)) {
            return false;
        }

        // Set up a buffer for querying directory entries
        // We process entries one by one using a context index
        std::vector<BYTE> buffer(4096);
        constexpr size_t MAX_DIR_BUFFER = 64 * 1024;
        ULONG context = 0;
        ULONG returned_length = 0;

        while (true) {
            // Query the next single object in the directory
            // 'ReturnSingleEntry' is TRUE to simplify buffer parsing logic
            status = nt_query_directory_object(
                dir,
                buffer.data(),
                static_cast<ULONG>(buffer.size()),
                TRUE,
                FALSE,
                &context,
                &returned_length
            );

            // Stop if we have iterated through all objects
            if (status == STATUS_NO_MORE_ENTRIES) {
                break;
            }

            // Handle buffer sizing. If the buffer is too small, the kernel tells us how much it needs
            // We resize and retry, but impose a sanity cap to prevent memory issues
            if (!NT_SUCCESS(status)) {
                if (returned_length > buffer.size()) {
                    size_t new_size = static_cast<size_t>(returned_length);
                    if (new_size > MAX_DIR_BUFFER) new_size = MAX_DIR_BUFFER;
                    if (new_size <= buffer.size()) {
                        nt_close(dir);
                        return false;
                    }
                    try {
                        buffer.resize(new_size);
                    }
                    catch (...) {
                        nt_close(dir);
                        return false;
                    }
                    continue;
                }
                nt_close(dir);
                return false;
            }

            // Validate the returned data length to ensure we don't read out of bounds
            const size_t used_len = (returned_length == 0) ? buffer.size() : static_cast<size_t>(returned_length);
            if (used_len < sizeof(OBJECT_DIRECTORY_INFORMATION) || used_len > buffer.size()) {
                nt_close(dir);
                return false;
            }

            const POBJECT_DIRECTORY_INFORMATION object_directory_information = reinterpret_cast<POBJECT_DIRECTORY_INFORMATION>(buffer.data());

            // memory boundaries just for safe pointer arithmetic
            const uintptr_t buf_base = reinterpret_cast<uintptr_t>(buffer.data());
            const uintptr_t buf_end = buf_base + used_len;

            std::wstring object_name;
            bool found_name = false;

            // Extract the name using the explicit Name pointer in the structure
            // We strictly validate that the pointer falls within our allocated buffer to prevent crashes
            const size_t nameBytes = static_cast<size_t>(object_directory_information->Name.Length);
            const uintptr_t name_ptr = reinterpret_cast<uintptr_t>(object_directory_information->Name.Buffer);

            if (nameBytes > 0 && (nameBytes % sizeof(wchar_t) == 0)) {
                const uintptr_t min_valid_ptr = buf_base + sizeof(OBJECT_DIRECTORY_INFORMATION);
                if (name_ptr >= min_valid_ptr && (name_ptr + nameBytes) <= buf_end && (name_ptr % sizeof(wchar_t) == 0)) {
                    const wchar_t* wname = reinterpret_cast<const wchar_t*>(name_ptr);
                    const size_t wlen = nameBytes / sizeof(wchar_t);
                    bool found_term = false;
                    // scan for null terminator just in case
                    for (size_t i = 0; i < wlen; ++i) {
                        if (wname[i] == L'\0') { 
                            object_name.assign(wname, i); 
                            found_term = true;
                            break; 
                        }
                    }
                    if (!found_term) {
                        object_name.assign(wname, wlen);
                    }
                    found_name = true;
                }
            }

            // If the explicit pointer was invalid, assume the string data immediately follows the structure
            if (!found_name) {
                const uintptr_t altStart = buf_base + sizeof(OBJECT_DIRECTORY_INFORMATION);
                if (altStart >= buf_end) {
                    nt_close(dir);
                    return false;
                }
                const size_t maxBytes = buf_end - altStart;
                if (maxBytes < sizeof(wchar_t)) {
                    nt_close(dir);
                    return false;
                }
                const wchar_t* alt_ptr = reinterpret_cast<const wchar_t*>(buffer.data() + (altStart - buf_base));
                const size_t max_chars = maxBytes / sizeof(wchar_t);

                size_t realChars = 0;
                for (; realChars < max_chars; ++realChars) {
                    if (alt_ptr[realChars] == L'\0') break;
                }
                if (realChars == max_chars) {
                    nt_close(dir);
                    return false;
                }
                object_name.assign(alt_ptr, realChars);
                found_name = true;
            }

            if (!found_name) {
                nt_close(dir);
                return false;
            }

            // "VmGenerationCounter" and "VmGid" are created by the Hyper-V VM Bus provider
            if (object_name == L"VmGenerationCounter") {
                nt_close(dir);
                debug("KERNEL_OBJECTS: Detected VmGenerationCounter");
                return core::add(brands::HYPERV);
            }
            if (object_name == L"VmGid") {
                nt_close(dir);
                debug("KERNEL_OBJECTS: Detected VmGid");
                return core::add(brands::HYPERV);
            }
        }

        nt_close(dir);
        return false;
    }


    /**
     * @brief Check for known NVRAM signatures that are present on virtual firmware
     * @category Windows
     * @warning Permissions required
     * @implements VM::NVRAM
     */
    static bool nvram() {
        struct VARIABLE_NAME { ULONG NextEntryOffset; GUID VendorGuid; WCHAR Name[1]; };
        using variable_name_ptr = VARIABLE_NAME*;
        using nt_enumerate_system_environment_values_ex_t = NTSTATUS(__stdcall*)(ULONG, PVOID, PULONG);
        using nt_query_system_environment_value_ex_t = NTSTATUS(__stdcall*)(PUNICODE_STRING VariableName, LPGUID VendorGuid, PVOID Value, PULONG ValueLength, PULONG Attributes);
        using nt_allocate_virtual_memory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);
        using nt_free_virtual_memory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG);

        // Secure Boot stuff
        bool found_dbx_default = false;
        bool found_kek_default = false;
        bool found_pk_default = false;

        /*
            MemoryOverwriteRequestControlLock is part of a state machine defined in the TCG Platform Reset Attack Mitigation Specification
            the SMM driver expects to initialize and manage this variable itself during the DXE phase of booting
            Secure Boot, TPM and SMM must be enabled to set it
        */
        bool found_morcl = false;
        bool detection_result = false;

        // Handles and Buffers
        HANDLE token_handle = nullptr;
        PVOID enum_base_buffer = nullptr;
        BYTE* pk_default_buf = nullptr;
        BYTE* pk_buf = nullptr;
        BYTE* kek_default_buf = nullptr;
        BYTE* kek_buf = nullptr;
        bool privileges_enabled = false;
        LUID luid_struct{};

        // Function Pointers
        nt_enumerate_system_environment_values_ex_t nt_enumerate_values = nullptr;
        nt_allocate_virtual_memory_t nt_allocate_memory = nullptr;
        nt_free_virtual_memory_t nt_free_memory = nullptr;
        nt_query_system_environment_value_ex_t nt_query_value = nullptr;

        const HANDLE current_process_handle = reinterpret_cast<HANDLE>(-1LL);

        const char* manufacturer_str = "";
        const char* model_str = "";
        util::get_manufacturer_model(&manufacturer_str, &model_str);

        // -------------------------------------------------------------------------
        // Helper Lambdas
        // -------------------------------------------------------------------------

        auto buffer_contains_ascii_ci = [](const BYTE* data, size_t len, const char* pat) noexcept -> bool {
            if (!data || len == 0 || !pat) return false;
            const size_t plen = strlen(pat); if (len < plen) return false;
            const BYTE p0 = static_cast<BYTE>((pat[0] >= 'A' && pat[0] <= 'Z') ? (pat[0] + 32) : pat[0]);
            const BYTE* end = data + (len - plen);
            for (const BYTE* p = data; p <= end; ++p) {
                BYTE c0 = *p; c0 = static_cast<BYTE>((c0 >= 'A' && c0 <= 'Z') ? (c0 + 32) : c0);
                if (c0 != p0) continue;
                bool ok = true;
                for (size_t j = 1; j < plen; ++j) {
                    BYTE dj = p[j]; dj = static_cast<BYTE>((dj >= 'A' && dj <= 'Z') ? (dj + 32) : dj);
                    BYTE pj = static_cast<BYTE>((pat[j] >= 'A' && pat[j] <= 'Z') ? (pat[j] + 32) : pat[j]);
                    if (dj != pj) { ok = false; break; }
                }
                if (ok) return true;
            }
            return false;
        };

        auto buffer_contains_utf16le_ci = [](const WCHAR* data, size_t wlen, const wchar_t* pat) noexcept -> bool {
            if (!data || wlen == 0 || !pat) return false;
            const size_t plen = wcslen(pat); if (wlen < plen) return false;
            const WCHAR p0 = static_cast<WCHAR>((pat[0] >= L'A' && pat[0] <= L'Z') ? (pat[0] + 32) : pat[0]);
            const WCHAR* end = data + (wlen - plen);
            for (const WCHAR* p = data; p <= end; ++p) {
                WCHAR c0 = *p; c0 = static_cast<WCHAR>((c0 >= L'A' && c0 <= L'Z') ? (c0 + 32) : c0);
                if (c0 != p0) continue;
                bool ok = true;
                for (size_t j = 1; j < plen; ++j) {
                    WCHAR dj = p[j]; dj = static_cast<WCHAR>((dj >= L'A' && dj <= L'Z') ? (dj + 32) : dj);
                    WCHAR pj = static_cast<WCHAR>((pat[j] >= L'A' && pat[j] <= L'Z') ? (pat[j] + 32) : pat[j]);
                    if (dj != pj) { ok = false; break; }
                }
                if (ok) return true;
            }
            return false;
        };

        // -------------------------------------------------------------------------
        // Main Logic Block
        // -------------------------------------------------------------------------

        do {
            if (!util::is_admin()) break;

            if (!OpenProcessToken(current_process_handle, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token_handle)) break;

            if (!LookupPrivilegeValue(nullptr, SE_SYSTEM_ENVIRONMENT_NAME, &luid_struct)) break;

            TOKEN_PRIVILEGES tp_enable{};
            tp_enable.PrivilegeCount = 1;
            tp_enable.Privileges[0].Luid = luid_struct;
            tp_enable.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
            AdjustTokenPrivileges(token_handle, FALSE, &tp_enable, sizeof(TOKEN_PRIVILEGES), nullptr, nullptr);
            if (GetLastError() != ERROR_SUCCESS) break;
            privileges_enabled = true;

            const HMODULE ntdll_module = util::get_ntdll();
            if (!ntdll_module) break;

            const char* func_names[] = { "NtEnumerateSystemEnvironmentValuesEx", "NtAllocateVirtualMemory", "NtFreeVirtualMemory", "NtQuerySystemEnvironmentValueEx" };
            void* resolved_funcs[sizeof(func_names) / sizeof(func_names[0])] = {};
            util::get_function_address(ntdll_module, func_names, resolved_funcs, sizeof(func_names) / sizeof(func_names[0]));

            nt_enumerate_values = reinterpret_cast<nt_enumerate_system_environment_values_ex_t>(resolved_funcs[0]);
            nt_allocate_memory = reinterpret_cast<nt_allocate_virtual_memory_t>(resolved_funcs[1]);
            nt_free_memory = reinterpret_cast<nt_free_virtual_memory_t>(resolved_funcs[2]);
            nt_query_value = reinterpret_cast<nt_query_system_environment_value_ex_t>(resolved_funcs[3]);

            if (!nt_enumerate_values || !nt_allocate_memory || !nt_free_memory || !nt_query_value) break;

            bool has_function = false;
            bool call_success = false;
            SIZE_T enum_alloc_size = 0;
            ULONG buffer_required_length = 0;

            // ask for size
            if (nt_enumerate_values) {
                has_function = true;
                nt_enumerate_values(static_cast<ULONG>(1), nullptr, &buffer_required_length);

                if (buffer_required_length != 0) {
                    enum_alloc_size = static_cast<SIZE_T>(buffer_required_length);
                    NTSTATUS alloc_status = nt_allocate_memory(current_process_handle, &enum_base_buffer, 0, &enum_alloc_size, static_cast<ULONG>(MEM_COMMIT | MEM_RESERVE), static_cast<ULONG>(PAGE_READWRITE));

                    if (alloc_status == 0 && enum_base_buffer) {
                        alloc_status = nt_enumerate_values(static_cast<ULONG>(1), enum_base_buffer, &buffer_required_length);
                        if (alloc_status == 0) {
                            call_success = true;
                        }
                        else {
                            SIZE_T zero_size = 0;
                            nt_free_memory(current_process_handle, &enum_base_buffer, &zero_size, 0x8000);
                            enum_base_buffer = nullptr;
                            enum_alloc_size = 0;
                        }
                    }
                }
            }

            if (!has_function) {
                debug("NVRAM: NtEnumerateSystemEnvironmentValuesEx could not be resolved");
                detection_result = false;
                break;
            }
            if (!call_success) {
                debug("NVRAM: System is not UEFI");
                detection_result = false;
                break;
            }

            // ---------------------------------------------------------------------
            // Constants & Data
            // ---------------------------------------------------------------------
            constexpr const char* vendor_list_ascii[] = { "msi","asrock","asus","asustek","gigabyte","giga-byte","micro-star","microstar" };
            constexpr const wchar_t* vendor_list_wide[] = { L"msi",L"asrock",L"asus",L"asustek",L"gigabyte",L"giga-byte",L"micro-star",L"microstar" };
            constexpr const char redhat_sig_ascii[] = "red hat";
            constexpr const wchar_t redhat_sig_wide[] = L"red hat";

            SIZE_T pk_default_len = 0;
            SIZE_T pk_len = 0;
            SIZE_T kek_default_len = 0;
            SIZE_T kek_len = 0;

            const GUID EFI_GLOBAL_VARIABLE = { 0x8BE4DF61, 0x93CA, 0x11D2, {0xAA,0x0D,0x00,0xE0,0x98,0x03,0x2B,0x8C} };

            // Helper to read 1-byte UEFI variables like SecureBoot or SetupMode
            auto read_uint8_var = [&](const std::wstring& name, const GUID& g, u8& out) noexcept -> bool {
                if (!nt_query_value || !nt_allocate_memory || !nt_free_memory) return false;
                UNICODE_STRING uni_str{};
                uni_str.Buffer = const_cast<PWSTR>(name.c_str());
                uni_str.Length = static_cast<USHORT>(name.length() * sizeof(wchar_t));
                uni_str.MaximumLength = uni_str.Length + sizeof(wchar_t);

                ULONG required_size = 0;
                NTSTATUS status = nt_query_value(&uni_str, const_cast<LPGUID>(&g), nullptr, &required_size, nullptr);
                if (required_size == 0) return false;

                PVOID allocation_base = nullptr;
                SIZE_T alloc_size = required_size;
                if (alloc_size < 0x1000) alloc_size = 0x1000;

                status = nt_allocate_memory(current_process_handle, &allocation_base, 0, &alloc_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
                if (status != 0 || !allocation_base) { return false; }

                status = nt_query_value(&uni_str, const_cast<LPGUID>(&g), allocation_base, &required_size, nullptr);
                if (status == 0 && required_size >= 1) {
                    out = *reinterpret_cast<u8*>(allocation_base);
                    SIZE_T z = 0;
                    nt_free_memory(current_process_handle, &allocation_base, &z, 0x8000);
                    return true;
                }

                SIZE_T zero_s = 0;
                nt_free_memory(current_process_handle, &allocation_base, &zero_s, 0x8000);
                return false;
            };

            bool have_secureboot = false;
            u8 secureboot_val = 0;
            if (read_uint8_var(L"SecureBoot", EFI_GLOBAL_VARIABLE, secureboot_val)) {
                have_secureboot = true;
                debug("NVRAM: SecureBoot variable detected");
            }

            bool have_setupmode = false;
            u8 setupmode_val = 0;
            if (read_uint8_var(L"SetupMode", EFI_GLOBAL_VARIABLE, setupmode_val)) {
                have_setupmode = true;
                debug("NVRAM: SetupMode variable detected");
            }

            // Determine whether it's safe to run Secure Boot dependent checks
            const bool sb_active = (have_secureboot && (secureboot_val == 1) && have_setupmode && (setupmode_val == 0));
            if (!sb_active) {
                debug("NVRAM: Secure Boot not confirmed active, disabling MOCRL and raw buffer mismatch checks...");
            }

            auto read_variable_to_buffer = [&](const std::wstring& name, GUID& guid, BYTE*& out_buf, SIZE_T& out_len) noexcept -> bool {
                UNICODE_STRING uni_str{};
                uni_str.Buffer = const_cast<PWSTR>(name.c_str());
                uni_str.Length = static_cast<USHORT>(name.length() * sizeof(wchar_t));
                uni_str.MaximumLength = uni_str.Length + sizeof(wchar_t);

                ULONG required_size = 0;
                NTSTATUS status = nt_query_value(&uni_str, &guid, nullptr, &required_size, nullptr);

                if (required_size == 0) return false;

                PVOID allocation_base = nullptr;
                SIZE_T alloc_size = required_size;
                if (alloc_size < 0x1000) alloc_size = 0x1000;

                status = nt_allocate_memory(current_process_handle, &allocation_base, 0, &alloc_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
                if (status != 0 || !allocation_base) { 
                    out_buf = nullptr;
                    out_len = 0; 
                    return false; 
                }

                status = nt_query_value(&uni_str, &guid, allocation_base, &required_size, nullptr);
                if (status == 0) {
                    out_buf = reinterpret_cast<BYTE*>(allocation_base);
                    out_len = required_size;
                    return true;
                }

                SIZE_T zero_s = 0;
                nt_free_memory(current_process_handle, &allocation_base, &zero_s, 0x8000);
                out_buf = nullptr;
                out_len = 0;
                return false;
            };

            variable_name_ptr current_var = reinterpret_cast<variable_name_ptr>(enum_base_buffer);
            const size_t buffer_total_size = static_cast<size_t>(buffer_required_length);
            constexpr size_t MAX_NAME_BYTE_LIMIT = 4096;

            bool should_break_loop = false;

            // ---------------------------------------------------------------------
            // Iteration Loop
            // ---------------------------------------------------------------------
            while (true) {
                const uintptr_t base_address = reinterpret_cast<uintptr_t>(enum_base_buffer);
                const uintptr_t current_address = reinterpret_cast<uintptr_t>(current_var);

                if (current_address < base_address) break;

                const size_t current_offset = static_cast<size_t>(current_address - base_address);
                if (current_offset >= buffer_total_size) break;

                const size_t name_struct_offset = offsetof(VARIABLE_NAME, Name);
                if (buffer_total_size - current_offset < name_struct_offset) break;

                size_t name_max_bytes = 0;
                if (current_var->NextEntryOffset != 0) {
                    const SIZE_T next_entry = static_cast<SIZE_T>(current_var->NextEntryOffset);
                    if (next_entry <= name_struct_offset) { 
                        detection_result = false; 
                        should_break_loop = true; 
                        break;
                    }
                    if (next_entry > buffer_total_size - current_offset) break;
                    name_max_bytes = next_entry - name_struct_offset;
                }
                else {
                    if (current_offset + name_struct_offset >= buffer_total_size) {
                        detection_result = false; 
                        should_break_loop = true;
                        break; 
                    }
                    name_max_bytes = buffer_total_size - (current_offset + name_struct_offset);
                }

                if (name_max_bytes > MAX_NAME_BYTE_LIMIT) name_max_bytes = MAX_NAME_BYTE_LIMIT;

                std::wstring var_name_view;
                if (name_max_bytes >= sizeof(WCHAR)) {
                    const WCHAR* name_ptr = reinterpret_cast<const WCHAR*>(reinterpret_cast<const BYTE*>(current_var) + name_struct_offset);
                    const size_t max_chars = name_max_bytes / sizeof(WCHAR);
                    size_t real_chars = 0;
                    while (real_chars < max_chars && name_ptr[real_chars] != L'\0') 
                        ++real_chars;
                    if (real_chars == max_chars) { 
                        detection_result = false; 
                        should_break_loop = true;
                        break; 
                    }
                    var_name_view = std::wstring(name_ptr, real_chars);
                }

                // Presence checks
                if (!var_name_view.empty() && var_name_view.rfind(L"VMM", 0) == 0) {
                    debug("NVRAM: Detected hypervisor signature");
                    detection_result = true;
                    should_break_loop = true;
                    break;
                }
                else if (var_name_view == L"KEKDefault") found_kek_default = true;
                else if (var_name_view == L"PKDefault") found_pk_default = true;
                else if (var_name_view == L"dbxDefault") found_dbx_default = true;
                else if (var_name_view == L"MemoryOverwriteRequestControlLock") found_morcl = true;

                // Read specific variables (later checks that act on them will only be performed if Secure Boot was explicitly confirmed active)
                if (var_name_view == L"PKDefault") (void)read_variable_to_buffer(std::wstring(var_name_view), current_var->VendorGuid, pk_default_buf, pk_default_len);
                else if (var_name_view == L"PK") (void)read_variable_to_buffer(std::wstring(var_name_view), current_var->VendorGuid, pk_buf, pk_len);
                else if (var_name_view == L"KEKDefault") (void)read_variable_to_buffer(std::wstring(var_name_view), current_var->VendorGuid, kek_default_buf, kek_default_len);
                else if (var_name_view == L"KEK") (void)read_variable_to_buffer(std::wstring(var_name_view), current_var->VendorGuid, kek_buf, kek_len);

                if (current_var->NextEntryOffset == 0) break;
                const SIZE_T next_entry_off = static_cast<SIZE_T>(current_var->NextEntryOffset);
                if (next_entry_off == 0) break;
                const size_t next_var_offset = current_offset + next_entry_off;
                if (next_var_offset <= current_offset || next_var_offset > buffer_total_size) break;
                current_var = reinterpret_cast<variable_name_ptr>(reinterpret_cast<PBYTE>(enum_base_buffer) + next_var_offset);
            }

            if (should_break_loop) break;

            // free enumeration buffer
            { 
                SIZE_T z = 0; 
                nt_free_memory(current_process_handle, &enum_base_buffer, &z, 0x8000); 
                enum_base_buffer = nullptr; 
                enum_alloc_size = 0; 
            }

            // ---------------------------------------------------------------------
            // EFI variable analysis
            // ---------------------------------------------------------------------
            if (sb_active) {
                if (!found_morcl) {
                    debug("NVRAM: Missing MemoryOverwriteRequestControlLock"); detection_result = true;
                    break;
                }
            }
            if (!found_dbx_default) {
                debug("NVRAM: Missing dbxDefault"); detection_result = true;
                break;
            }
            if (!found_kek_default) {
                debug("NVRAM: Missing KEKDefault"); detection_result = true;
                break;
            }
            if (!found_pk_default) {
                debug("NVRAM: Missing PKDefault"); detection_result = true;
                break;
            }

            // check for official red hat certs (QEMU/OVMF)
            bool found_redhat = false;
            if (pk_default_buf && pk_default_len) {
                if ((pk_default_len >= 2) && ((pk_default_len % 2) == 0)) {
                    const WCHAR* wptr = reinterpret_cast<const WCHAR*>(pk_default_buf);
                    const size_t wlen = pk_default_len / sizeof(WCHAR);
                    if (buffer_contains_utf16le_ci(wptr, wlen, redhat_sig_wide))
                        found_redhat = true;
                }
                if (!found_redhat)
                    if (buffer_contains_ascii_ci(pk_default_buf, pk_default_len, redhat_sig_ascii))
                        found_redhat = true;
            }
            if (found_redhat) {
                debug("NVRAM: QEMU/OVMF detected");
                detection_result = core::add(brands::QEMU);
                break;
            }

            // vendor string checks and PK/KEK mismatch checks
            auto buffer_has_any_vendor = [&](BYTE* buf, SIZE_T len) noexcept -> bool {
                if (!buf || len == 0) return false;
                if ((len >= 2) && ((len % 2) == 0)) {
                    const WCHAR* wptr = reinterpret_cast<const WCHAR*>(buf); const size_t wlen = len / sizeof(WCHAR);
                    for (const wchar_t* p : vendor_list_wide)
                        if (buffer_contains_utf16le_ci(wptr, wlen, p))
                            return true;
                }
                for (const char* p : vendor_list_ascii)
                    if (buffer_contains_ascii_ci(buf, len, p))
                        return true;
                return false;
            };
            auto buffer_has_specific_vendor = [&](BYTE* buf, SIZE_T len, const char* a, const wchar_t* w) noexcept -> bool {
                if (!buf || len == 0) return false;
                if ((len >= 2) && ((len % 2) == 0) && w) {
                    const WCHAR* wp = reinterpret_cast<const WCHAR*>(buf);
                    if (buffer_contains_utf16le_ci(wp, len / sizeof(WCHAR), w))
                        return true;
                }
                if (a)
                    if (buffer_contains_ascii_ci(buf, len, a))
                        return true;
                return false;
            };

            if (sb_active) {
                const bool pk_def_has_vendor = buffer_has_any_vendor(pk_default_buf, pk_default_len);
                const bool kek_def_has_vendor = buffer_has_any_vendor(kek_default_buf, kek_default_len);

                if (pk_def_has_vendor || kek_def_has_vendor) {
                    bool vendor_mismatch = false;
                    for (size_t i = 0; i < sizeof(vendor_list_ascii) / sizeof(*vendor_list_ascii); ++i) {
                        const char* vendor_asc = vendor_list_ascii[i];
                        const wchar_t* vendor_w = vendor_list_wide[i];

                        const bool in_pk_def = buffer_has_specific_vendor(pk_default_buf, pk_default_len, vendor_asc, vendor_w);
                        const bool in_kek_def = buffer_has_specific_vendor(kek_default_buf, kek_default_len, vendor_asc, vendor_w);

                        if (!in_pk_def && !in_kek_def) continue;

                        const bool in_pk_active = buffer_has_specific_vendor(pk_buf, pk_len, vendor_asc, vendor_w);
                        const bool in_kek_active = buffer_has_specific_vendor(kek_buf, kek_len, vendor_asc, vendor_w);

                        // If the Default contains the vendor but the active variable is missing entirely
                        if (in_pk_def && pk_len == 0) {
                            std::string msg = "NVRAM: PKDefault contains vendor '";
                            msg += vendor_asc;
                            msg += "' but active PK variable is missing";
                            debug(msg.c_str());
                            detection_result = true;
                            vendor_mismatch = true;
                            break;
                        }
                        if (in_kek_def && kek_len == 0) {
                            std::string msg = "NVRAM: KEKDefault contains vendor '";
                            msg += vendor_asc;
                            msg += "' but active KEK variable is missing";
                            debug(msg.c_str());
                            detection_result = true;
                            vendor_mismatch = true;
                            break;
                        }

                        // If the active variable exists but does not contain the same vendor string
                        if (in_pk_def && pk_len != 0 && !in_pk_active) {
                            std::string msg = "NVRAM: Vendor string '";
                            msg += vendor_asc;
                            msg += "' found in PKDefault but missing from active PK";
                            debug(msg.c_str());
                            detection_result = true;
                            vendor_mismatch = true;
                            break;
                        }
                        if (in_kek_def && kek_len != 0 && !in_kek_active) {
                            std::string msg = "NVRAM: Vendor string '";
                            msg += vendor_asc;
                            msg += "' found in KEKDefault but missing from active KEK";
                            debug(msg.c_str());
                            detection_result = true;
                            vendor_mismatch = true;
                            break;
                        }
                    }
                    if (vendor_mismatch) break;
                }

                if (pk_default_buf && pk_buf && (pk_default_len != pk_len || memcmp(pk_default_buf, pk_buf, static_cast<size_t>(pk_default_len < pk_len ? pk_default_len : pk_len)) != 0)) {
                    debug("NVRAM: PK vs PKDefault raw mismatch detected");
                    detection_result = true;
                    break;
                }
                if (kek_default_buf && kek_buf && (kek_default_len != kek_len || memcmp(kek_default_buf, kek_buf, static_cast<size_t>(kek_default_len < kek_len ? kek_default_len : kek_len)) != 0)) {
                    debug("NVRAM: KEK vs KEKDefault raw mismatch detected");
                    detection_result = true;
                    break;
                }
            }

            detection_result = false;

        } while (false);

        // cleanup
        auto cleanup = [&](auto& ptr) {
            if (ptr) {
                PVOID base = ptr;
                SIZE_T size = 0;
                nt_free_memory(current_process_handle, &base, &size, 0x8000);
                ptr = nullptr;
            }
        };

        cleanup(pk_buf);
        cleanup(kek_buf);
        cleanup(pk_default_buf);
        cleanup(kek_default_buf);
        cleanup(enum_base_buffer);

        if (privileges_enabled && token_handle) {
            TOKEN_PRIVILEGES tp_disable{};
            tp_disable.PrivilegeCount = 1;
            tp_disable.Privileges[0].Luid = luid_struct;
            tp_disable.Privileges[0].Attributes = 0;
            AdjustTokenPrivileges(token_handle, FALSE, &tp_disable, sizeof(TOKEN_PRIVILEGES), nullptr, nullptr);
        }
        if (token_handle) {
            CloseHandle(token_handle);
            token_handle = nullptr;
        }

        return detection_result;
    }


    /**
	 * @brief Check if SMBIOS is malformed/corrupted in a way that is typical for VMs
     * @category Windows
     * @implements VM::SMBIOS_INTEGRITY
     */
    [[nodiscard]] static bool smbios_integrity() {
        ULONGLONG total_memory_in_kilobytes;
        return !GetPhysicallyInstalledSystemMemory(&total_memory_in_kilobytes);
    }


    /**
     * @brief Check for non-standard EDID configurations
     * @category Windows
     * @implements VM::EDID
     */
    [[nodiscard]] static bool edid() {
        auto decode_manufacturer = [](const BYTE* edid, char out[4]) noexcept {
            const u16 word = static_cast<u16>((edid[8] << 8) | edid[9]);

            // 5 bits per character. 0x01='A', 0x1A='Z'
            const u8 c1 = static_cast<u8>((word >> 10) & 0x1F);
            const u8 c2 = static_cast<u8>((word >> 5) & 0x1F);
            const u8 c3 = static_cast<u8>(word & 0x1F);

            // '?' is fallback for valid EDID range 1-26
            out[0] = (c1 >= 1 && c1 <= 26) ? static_cast<char>('A' + c1 - 1) : '?';
            out[1] = (c2 >= 1 && c2 <= 26) ? static_cast<char>('A' + c2 - 1) : '?';
            out[2] = (c3 >= 1 && c3 <= 26) ? static_cast<char>('A' + c3 - 1) : '?';
            out[3] = '\0';
        };

        auto is_three_upper_alpha = [](const char m[4]) noexcept -> bool {
            return (m[0] >= 'A' && m[0] <= 'Z') &&
                (m[1] >= 'A' && m[1] <= 'Z') &&
                (m[2] >= 'A' && m[2] <= 'Z');
        };

        auto edid_checksum_valid = [](const BYTE* edid, size_t len) noexcept -> bool {
            if (len < 128) return false;

            u8 sum = 0;
            const BYTE* end = edid + 128;

            while (edid < end) {
                sum += *edid++;
            }

            return sum == 0;
        };

        auto extract_monitor_name = [](const BYTE* edid, size_t len, char out[32]) noexcept -> bool {
            out[0] = '\0';
            if (len < 128) return false;

            // Standard EDID 1.3/1.4 Descriptor offsets
            const BYTE* block = edid + 54;
            const BYTE* end = edid + 126; // block area

            const BYTE* best_block = nullptr;

            for (; block <= end - 18; block += 18) {
                // bytes 0-2 must be 0 to indicate a Display Descriptor
                if (block[0] != 0 || block[1] != 0 || block[2] != 0) continue;

                const u8 tag = block[3];

                // 0xFC = Monitor Name
                if (tag == 0xFC) {
                    best_block = block;
                    break;
                }

                // 0xFF = Monitor Serial (this is only a fallback)
                if (tag == 0xFF && !best_block) {
                    best_block = block;
                }
            }

            if (best_block) {
                int outi = 0;
                for (int j = 5; j < 18 && outi < 31; ++j) {
                    const char c = static_cast<char>(best_block[j]);
                    // Terminate on newline (0x0A) or carriage return (0x0D) or null
                    if (c == 0x0A || c == 0x0D || c == '\0') break;
                    out[outi++] = c;
                }

                // right-trim spaces
                while (outi > 0 && (out[outi - 1] == ' ' || out[outi - 1] == '\t')) {
                    --outi;
                }

                out[outi] = '\0';
                return outi > 0;
            }

            return false;
        };

        // Helper lambda to retrieve device properties from the registry
        auto get_device_property = [](HDEVINFO dev_info, SP_DEVINFO_DATA& dev_data, DWORD prop_id,
            char* out_buf, DWORD out_buf_size) noexcept -> bool {
                DWORD needed = 0;

                // Try to get the property with the provided buffer
                if (SetupDiGetDeviceRegistryPropertyA(dev_info, &dev_data, prop_id, nullptr,
                    reinterpret_cast<PBYTE>(out_buf), out_buf_size, &needed)) {
                    if (out_buf_size > 0) out_buf[out_buf_size - 1] = '\0';
                    return true;
                }

                const DWORD err = GetLastError();

                // If the buffer was too small, allocate exactly what is needed and try again
                // This ensures we don't fail just because a property string is unusually long
                if (err == ERROR_INSUFFICIENT_BUFFER && needed > 0 && needed < 65536) {

                    void* h = malloc(static_cast<size_t>(needed) + 1);
                    if (!h) return false;

                    if (SetupDiGetDeviceRegistryPropertyA(dev_info, &dev_data, prop_id, nullptr,
                        reinterpret_cast<PBYTE>(h), needed, &needed)) {

                        const DWORD to_copy = (needed < out_buf_size - 1) ? needed : (out_buf_size - 1);

                        if (out_buf_size > 0) {
                            memcpy(out_buf, h, to_copy);
                            out_buf[to_copy] = '\0';
                        }

                        free(h);
                        return true;
                    }
                    free(h);
                }

                if (out_buf_size > 0) out_buf[0] = '\0';
                return false;
        };

        // Initiate a query for all "Monitor" class devices present in the system.
        // We target monitors because VMs often emulate generic displays (e.g., "Generic Non-PnP Monitor")
        // or specific virtual hardware signatures in their EDID data.
        const HDEVINFO dev_info = SetupDiGetClassDevs(&GUID_DEVCLASS_MONITOR, nullptr, nullptr, DIGCF_PRESENT);
        if (dev_info == INVALID_HANDLE_VALUE) return false;

        SP_DEVINFO_DATA dev_data{};
        dev_data.cbSize = sizeof(dev_data);

        const int threshold = 3;

        // Iterate through every enumerated monitor to inspect its hardware details
        for (DWORD index = 0; SetupDiEnumDeviceInfo(dev_info, index, &dev_data); ++index) {
            // Open the "Hardware" registry key for the specific device instance
            // This is where the driver stores low-level configuration, including the EDID
            const HKEY handle_dev_key = SetupDiOpenDevRegKey(dev_info, &dev_data, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);
            if (handle_dev_key == INVALID_HANDLE_VALUE) {
                dev_data = {};
                dev_data.cbSize = sizeof(dev_data);
                continue;
            }

            // Prepare to read the EDID (Extended Display Identification Data)
            // EDID is a standard data structure containing the display's manufacturer ID, 
            // serial number, and capabilities
            BYTE edid_stack[256];
            DWORD buffer_size = static_cast<DWORD>(sizeof(edid_stack));
            const LONG rc = RegQueryValueExA(handle_dev_key, "EDID", nullptr, nullptr, edid_stack, &buffer_size);
            RegCloseKey(handle_dev_key);

            BYTE* edid = nullptr;
            bool used_heap = false;
            BYTE* heap_buf = nullptr;

            // standard EDID is 128 bytes so it should fit in stack
            if (rc == ERROR_SUCCESS && buffer_size >= 128) {
                edid = edid_stack;
            }
            // If for some reason the EDID contains extension blocks (making it larger than our stack buffer)
            // allocate a heap buffer dynamically to capture the full data
            else if (rc == ERROR_MORE_DATA) {
                if (buffer_size > 0 && buffer_size < 65536) {
                    heap_buf = static_cast<BYTE*>(LocalAlloc(LMEM_FIXED, buffer_size));
                    if (heap_buf) {
                        DWORD extra_buffer_size = buffer_size;
                        // Re-open the key to read the full data into the new buffer
                        const HKEY extra_dev_key = SetupDiOpenDevRegKey(dev_info, &dev_data, DICS_FLAG_GLOBAL, 0, DIREG_DEV, KEY_READ);
                        if (extra_dev_key != INVALID_HANDLE_VALUE) {
                            if (RegQueryValueExA(extra_dev_key, "EDID", nullptr, nullptr, heap_buf, &extra_buffer_size) == ERROR_SUCCESS && extra_buffer_size >= 128) {
                                edid = heap_buf;
                                used_heap = true;
                                buffer_size = extra_buffer_size;
                            }
                            RegCloseKey(extra_dev_key);
                        }
                        if (!edid) {
                            LocalFree(heap_buf);
                            heap_buf = nullptr;
                        }
                    }
                }
            }

            if (!edid) {
                dev_data = {};
                dev_data.cbSize = sizeof(dev_data);
                continue;
            }

            // header check
            if (!(edid[0] == 0x00 && edid[1] == 0xFF && edid[2] == 0xFF && edid[3] == 0xFF
                && edid[4] == 0xFF && edid[5] == 0xFF && edid[6] == 0xFF && edid[7] == 0x00)) {
                if (used_heap) LocalFree(heap_buf);
                dev_data = {};
                dev_data.cbSize = sizeof(dev_data);
                continue;
            }

            const bool checksum_ok = edid_checksum_valid(edid, buffer_size);

            char manu[4];
            decode_manufacturer(edid, manu);
            const bool manu_ok = is_three_upper_alpha(manu);

            const u16 product = static_cast<u16>(edid[10] | (edid[11] << 8)); // because its little-endian
            const u32 serial = static_cast<u32>(edid[12] | (edid[13] << 8) | (edid[14] << 16) | (edid[15] << 24));

            char monname[32];
            const bool has_name = extract_monitor_name(edid, buffer_size, monname);

            char prop_buf[512];
            const bool have_friendly = get_device_property(dev_info, dev_data, SPDRP_FRIENDLYNAME, prop_buf, sizeof(prop_buf)); // friendly_name is often empty, like in Digital-Flachbildschirm monitors
            const bool have_dev_desc = get_device_property(dev_info, dev_data, SPDRP_DEVICEDESC, prop_buf, sizeof(prop_buf));

            int score = 0;

            if (!checksum_ok) score += 1;
            if (!manu_ok) score += 1;

            if (product == 0 && serial == 0) {
                score += 1;
            }
            else if (product == 0 || serial == 0) {
                if (score > 0) score += 1;
            }

            if (!has_name && score > 0) score += 1;

            if (!have_friendly && !have_dev_desc) score += 1;

            if (used_heap) LocalFree(heap_buf);

            if (score >= threshold) {
                SetupDiDestroyDeviceInfoList(dev_info);
                return true;
            }

            dev_data = {};
            dev_data.cbSize = sizeof(dev_data);
        }

        SetupDiDestroyDeviceInfoList(dev_info);
        return false;
    }


    /**
     * @brief Check whether the CPU is genuine and its reported instruction capabilities are not masked
     * @category Windows
     * @implements VM::CPU_HEURISTIC
     */
    [[nodiscard]] static bool cpu_heuristic() {
        bool spoofed = false;
    #if (x86)
        if (util::is_running_under_translator()) {
            debug("CPU_HEURISTIC: Running inside a binary translation layer");
            return false;
        }

        // 1) Check for commonly disabled instructions on patches and VMs    
        u32 a = 0, b = 0, c = 0, d = 0;
        cpu::cpuid(a, b, c, d, 1u);

        constexpr u32 AES_NI_BIT = 1u << 25;
        const bool aes_support = (c & AES_NI_BIT) != 0;

        alignas(16) unsigned char plaintext[16] = {
            0x00,0x11,0x22,0x33, 0x44,0x55,0x66,0x77,
            0x88,0x99,0xAA,0xBB, 0xCC,0xDD,0xEE,0xFF
        };
        alignas(16) unsigned char key[16] = {
            0x0F,0x0E,0x0D,0x0C, 0x0B,0x0A,0x09,0x08,
            0x07,0x06,0x05,0x04, 0x03,0x02,0x01,0x00
        };
        alignas(16) unsigned char out[16] = { 0 };

        // need to do a lambda wrapper to isolate SEH from the parent function's stack unwinding
        // target aes is required for clang/gcc while in MSVC not, and this target can only be applied to functions, meaning we need a struct
        struct aes_executor {
                #if (CLANG || GCC)
                    __attribute__((__target__("aes")))
                #endif
                static bool check_aes_integrity(const unsigned char* pt, const unsigned char* k, unsigned char* o, bool support) {
                __try {
                    __m128i block = _mm_loadu_si128(reinterpret_cast<const __m128i*>(pt));
                    __m128i key_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(k));

                    __m128i tmp = _mm_xor_si128(block, key_vec);
                    tmp = _mm_aesenc_si128(tmp, key_vec);

                    _mm_storeu_si128(reinterpret_cast<__m128i*>(o), tmp);

                    if (!support) {
                        debug("CPU_HEURISTIC: Hypervisor detected hiding AES capabilities");
                        return true;
                    }
                }
                __except (GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION
                    ? EXCEPTION_EXECUTE_HANDLER
                    : EXCEPTION_CONTINUE_SEARCH) {
                    if (support) {
                        debug("CPU_HEURISTIC: Hypervisor reports AES, but it is not handled correctly");
                        return true;
                    }
                }
                return false;
            }
        };

        if (aes_executor::check_aes_integrity(plaintext, key, out, aes_support)) return true;

        const bool avx_support = ((c >> 28) & 1u) != 0;
        const bool xsave_support = ((c >> 26) & 1u) != 0;

        if (avx_support && !xsave_support) {
            debug("CPU_HEURISTIC: YMM state not correct for a baremetal machine");
            return true;
        }

        const bool rdrand_support = ((c >> 30) & 1u) != 0;

        auto check_rdrand_integrity = [&]() -> bool {
            __try {
                unsigned int v = 0;
            #if (MSVC && !CLANG)
                if (_rdrand32_step(&v) && !rdrand_support) {
                    debug("CPU_HEURISTIC: Hypervisor detected hiding RDRAND capabilities");
                    return true;
                }
            #else 
                unsigned char ok = 0;
                asm volatile("rdrand %0\n\tsetc %1" : "=r"(v), "=qm"(ok) : : "cc");
                if (ok && !rdrand_support) {
                    debug("CPU_HEURISTIC: Hypervisor detected hiding RDRAND capabilities");
                    return true;
                }
            #endif      
            }
            __except (GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION
                ? EXCEPTION_EXECUTE_HANDLER
                : EXCEPTION_CONTINUE_SEARCH) {
                if (rdrand_support) {
                    debug("CPU_HEURISTIC: Hypervisor reports RDRAND, but it is not handled correctly");
                    return true;
                }
            }
            return false;
        };

        if (check_rdrand_integrity()) return true;

        // 2. Test if the CPU vendor is spoofed (for example, a CPU reports being AMD in CPUID, but it is Intel)
        /*
            For this task, we want a instruction that:
            1. It is vendor-only, meaning that other CPU vendors never implemented the same instruction on their microcode
                -> Note: Even if an instruction is vendor-only, it may be treated as a NOP by other CPU vendors, we don't want this
            2. Is compatible enough, meaning both old and new CPUs of this vendor have it
            3. Is enabled by default, without needing BIOS/OS changes
            4. Never switches to kernel-mode, so that is harder to intercept
            5. Is not deprecated today
            6. Its side-effects can be measured from CPL3 (user-mode)

            On Intel, most options are unreliable:
            SGX are deprecated and disabled by default, MPX is deprecated and treated as NOP even in AMD CPUs, AVX-512 is not found in all processors (and AMD integrated part of this set), etc
            On AMD, 3dNow! could be an option, but since its being deprecated, CLZERO fits this criteria better

            So for example, if the CPU reports being Intel, and succesfully runs CLZERO without a NOP, then it's not an Intel CPU.
        */

        // AMD stub template (mov rax, imm64 + clzero + ret)
        // 8-byte immediate at runtime at offsets [2..9]
        u8 amd_bytes[] = {
            0x48, 0xB8,                 // mov rax, imm64
            0x00, 0x00, 0x00, 0x00,     // imm64 low bytes (placeholder)
            0x00, 0x00, 0x00, 0x00,     // imm64 high bytes (placeholder)
            0x0F, 0x01, 0xFC,           // clzero
            0xC3                        // ret
        };
        constexpr SIZE_T amd_stub_size = sizeof(amd_bytes); // 14

        const u8* bytes = nullptr;
        SIZE_T codeSize = 0;

        LPVOID amd_target_mem = nullptr;
        LPVOID exec_mem = nullptr;
        PVOID free_base = nullptr;
        SIZE_T free_size = 0;

        const bool claimed_amd = cpu::is_amd();
        const bool claimed_intel = cpu::is_intel();

        if (!claimed_amd && !claimed_intel) {
            debug("CPU_HEURISTIC: x86 CPU vendor was not recognized as either Intel or AMD");
            return false; // Zhaoxin? VIA/Centaur?
        }

        bool proceed = true;
        bool exception = false;

        // A case where this check could false flag is when analyzing the AMD PRO A8-9600B CPU
        // is based on the "Bristol Ridge" platform, which uses the Excavator microarchitecture (the 4th and final generation of the Bulldozer family)
        // Excavator CPUs do not possess the CLZERO instruction
        if (claimed_amd) {
            cpu::model_struct model = cpu::get_model();
            if (!model.is_ryzen) {
                debug("CPU_HEURISTIC: CPU is AMD but not Ryzen (Pre-Zen). Skipping CLZERO check");
                proceed = false;
            }
        }

        if (claimed_intel || !claimed_amd) exception = true; // should generate an exception rather than be treated as a NOP, but we will check its side effects anyways

        // one cache line = 64 bytes
        const SIZE_T target_size = 64;

        const HMODULE ntdll = util::get_ntdll();
        if (!ntdll) return false;

        const char* names[] = { "NtAllocateVirtualMemory", "NtProtectVirtualMemory", "NtFlushInstructionCache", "NtFreeVirtualMemory" };
        void* funcs[ARRAYSIZE(names)] = {};
        util::get_function_address(ntdll, names, funcs, ARRAYSIZE(names));

        using NtAllocateVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, ULONG_PTR, PSIZE_T, ULONG, ULONG);
        using NtProtectVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG, PULONG);
        using NtFreeVirtualMemory_t = NTSTATUS(__stdcall*)(HANDLE, PVOID*, PSIZE_T, ULONG);
        using NtFlushInstructionCache_t = NTSTATUS(__stdcall*)(HANDLE, PVOID, SIZE_T);
        const auto nt_allocate_virtual_memory = reinterpret_cast<NtAllocateVirtualMemory_t>(funcs[0]);
        const auto nt_protect_virtual_memory = reinterpret_cast<NtProtectVirtualMemory_t>(funcs[1]);
        const auto nt_flush_instruction_cache = reinterpret_cast<NtFlushInstructionCache_t>(funcs[2]);
        const auto nt_free_virtual_memory = reinterpret_cast<NtFreeVirtualMemory_t>(funcs[3]);

        if (!nt_allocate_virtual_memory || !nt_protect_virtual_memory || !nt_flush_instruction_cache || !nt_free_virtual_memory) {
            return false;
        }

        const HANDLE current_process = reinterpret_cast<HANDLE>(-1LL);

        {
            PVOID base = nullptr;
            SIZE_T sz = target_size;
            NTSTATUS st2 = nt_allocate_virtual_memory(current_process, &base, 0, &sz, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            if (!NT_SUCCESS(st2) || base == nullptr) {
                proceed = false;
            }
            else {
                amd_target_mem = base;
                // fill target with a recognizable non-zero pattern so we can detect CLZERO's effect (in case some obscure Intel CPU treat our instruction as a NOP)
                memset(amd_target_mem, 0xA5, target_size);

                const std::uintptr_t paddr = reinterpret_cast<std::uintptr_t>(amd_target_mem); // to avoid sign-extension, 32-bit compatible
                const u64 addr = static_cast<u64>(paddr);
                for (u8 i = 0; i < 8; ++i) {
                    amd_bytes[2 + i] = static_cast<u8>((addr >> (i * 8)) & 0xFF);
                }
                bytes = amd_bytes;
                codeSize = amd_stub_size;
            }
        }

        if (proceed) {
            PVOID base = nullptr;
            SIZE_T sz = codeSize;
            NTSTATUS st2 = nt_allocate_virtual_memory(current_process, &base, 0, &sz, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
            if (NT_SUCCESS(st2) && base != nullptr) {
                exec_mem = base;
                memcpy(exec_mem, bytes, codeSize);

                // change to RX
                ULONG oldProt = 0;
                PVOID tmp_base = exec_mem;
                SIZE_T tmp_sz = codeSize;
                st2 = nt_protect_virtual_memory(current_process, &tmp_base, &tmp_sz, PAGE_EXECUTE_READ, &oldProt);
                if (NT_SUCCESS(st2)) {
                    nt_flush_instruction_cache(current_process, exec_mem, codeSize);

                    using code_func = void(*)();
                    using runner_func = u8(*)(code_func);
                    runner_func runner = +[](code_func func) -> u8 {
                        __try {
                            func();
                            return 0;
                        }
                        __except (GetExceptionCode() == EXCEPTION_ILLEGAL_INSTRUCTION ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
                            return 1;
                        }
                    };

                    const u8 runner_rc = runner(reinterpret_cast<code_func>(exec_mem));

                    // check if the target buffer was written to zero by CLZERO
                    bool memory_all_zero = false;
                    if (amd_target_mem) {
                        volatile u8* p = reinterpret_cast<volatile u8*>(amd_target_mem);
                        memory_all_zero = true;
                        for (SIZE_T i = 0; i < target_size; ++i) {
                            if (p[i] != 0) { memory_all_zero = false; break; }
                        }
                    }

                    if (runner_rc == 0 && exception) {
                        // only treat as spoofed if the CLZERO execution actually zeroed the target memory
                        if (memory_all_zero) {
                            debug("CPU_HEURISTIC: CPU reports being Intel, but VMAware detected a hypervisor running an AMD CPU in the host"); // or another CPU vendor
                            spoofed = true;
                        }
                        else {
                            debug("CPU_HEURISTIC: CLZERO returned without exception but target memory was NOT zeroed (NOP/emulated)");
                        }
                    }
                    else if (runner_rc == 1 && !exception) {
                        debug("CPU_HEURISTIC: CPU reports being AMD, but VMAware detected a hypervisor running an Intel CPU in the host"); // or another CPU vendor
                        spoofed = true;
                    }
                    else if (runner_rc == 0 && !exception) {
                        if (!memory_all_zero) {
                            debug("CPU_HEURISTIC: CPU reports being AMD, CLZERO executed but did NOT zero the target memory");
                            spoofed = true;
                        }
                    }
                }
            }
        }

        if (exec_mem) {
            free_base = exec_mem; free_size = codeSize;
            nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
            exec_mem = nullptr;
        }
        if (amd_target_mem) {
            free_base = amd_target_mem; free_size = target_size;
            nt_free_virtual_memory(current_process, &free_base, &free_size, MEM_RELEASE);
            amd_target_mem = nullptr;
        }

        if (spoofed) return spoofed;

        // ok so if the CPU is intel, the motherboard should be intel aswell (and same with AMD)
        // this doesnt happen in most public hardened configs out there so lets abuse it
        constexpr unsigned int VID_INTEL = 0x8086;
        constexpr unsigned int VID_AMD_ATI = 0x1002;
        constexpr unsigned int VID_AMD_MICRO = 0x1022;

        enum class MBVendor { Unknown = 0, Intel = 1, AMD = 2 };

        auto detect_motherboard = []() noexcept -> MBVendor {
            static constexpr const wchar_t* TOKENS[] = {
                L"host bridge", L"northbridge", L"southbridge", L"pci bridge", L"chipset", L"pch", L"fch",
                L"platform controller", L"lpc", L"sata controller", L"ahci", L"ide controller", L"usb controller",
                L"xhci", L"usb3", L"usb 3.0", L"usb 3", L"pcie root", L"pci express", L" sata", nullptr
            };

            auto contains_token = [](const wchar_t* haystack) noexcept -> bool {
                if (!haystack) return false;
                for (const wchar_t* const* t = TOKENS; *t; ++t) {
                    const wchar_t* needle = *t;
                    const wchar_t* h = haystack;

                    // naive scan is faster than BM/KMP for very short needles/haystacks
                    while (*h) {
                        const wchar_t* h_iter = h;
                        const wchar_t* n_iter = needle;

                        while (*n_iter) {
                            wchar_t hc = *h_iter;
                            if (hc >= L'A' && hc <= L'Z') hc += 32;

                            if (hc != *n_iter) break;
                            h_iter++;
                            n_iter++;
                        }

                        if (!*n_iter) return true; 
                        h++;
                    }
                }
                return false;
            };

            auto find_vendor_hex = [](const wchar_t* wptr) noexcept -> u32 {
                if (!wptr) return 0;
                const wchar_t* p = wptr;
                while (*p) {
                    // Check for "VEN_" (case-insensitive)
                    if (((p[0] | 0x20) == L'v') &&
                        ((p[1] | 0x20) == L'e') &&
                        ((p[2] | 0x20) == L'n') &&
                        (p[3] == L'_')) {

                        const wchar_t* q = p + 4;
                        u32 val = 0;
                        int got = 0;
                        while (got < 4 && *q) {
                            const wchar_t c = *q;
                            u32 nib = 0;
                            if (c >= L'0' && c <= L'9') 
                                nib = static_cast<u32>(c - L'0');
                            else if ((c | 0x20) >= L'a' && (c | 0x20) <= L'f') 
                                nib = static_cast<u32>((c | 0x20) - L'a' + 10);
                            else
                                break;

                            val = (val << 4) | nib;
                            ++got; ++q;
                        }
                        if (got == 4) return val;
                    }
                    ++p;
                }
                return 0;
            };

            // setupapi stuff
            int intel_hits = 0;
            int amd_hits = 0;

            wchar_t stack_buf[1024]{};
            std::vector<BYTE> heap_buf; // fallback for rare huge strings

            auto scan_devices = [&](const GUID* classGuid, DWORD flags) noexcept {
                HDEVINFO handle_dev_info = SetupDiGetClassDevsW(classGuid, nullptr, nullptr, flags);
                if (handle_dev_info == INVALID_HANDLE_VALUE) return;

                SP_DEVINFO_DATA dev_info_data{};
                dev_info_data.cbSize = sizeof(SP_DEVINFO_DATA);

                for (DWORD i = 0; SetupDiEnumDeviceInfo(handle_dev_info, i, &dev_info_data); ++i) {

                    const wchar_t* w_desc = nullptr;
                    DWORD req_size = 0;
                    DWORD prop_type = 0;

                    if (SetupDiGetDeviceRegistryPropertyW(handle_dev_info, &dev_info_data, SPDRP_DEVICEDESC, &prop_type, reinterpret_cast<PBYTE>(stack_buf), sizeof(stack_buf), &req_size)) {
                        w_desc = stack_buf;
                    }
                    else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                        if (heap_buf.size() < req_size) heap_buf.resize(req_size);
                        if (SetupDiGetDeviceRegistryPropertyW(handle_dev_info, &dev_info_data, SPDRP_DEVICEDESC, &prop_type, heap_buf.data(), req_size, nullptr)) {
                            w_desc = reinterpret_cast<const wchar_t*>(heap_buf.data());
                        }
                    }

                    // check if the description contains any interesting stuff
                    if (w_desc && contains_token(w_desc)) {

                        // if interesting get hwid to get vendor
                        const wchar_t* w_hardware_id = nullptr;

                        if (SetupDiGetDeviceRegistryPropertyW(handle_dev_info, &dev_info_data, SPDRP_HARDWAREID, &prop_type, reinterpret_cast<PBYTE>(stack_buf), sizeof(stack_buf), &req_size)) {
                            w_hardware_id = stack_buf;
                        }
                        else if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                            if (heap_buf.size() < req_size) heap_buf.resize(req_size);
                            if (SetupDiGetDeviceRegistryPropertyW(handle_dev_info, &dev_info_data, SPDRP_HARDWAREID, &prop_type, heap_buf.data(), req_size, nullptr)) {
                                w_hardware_id = reinterpret_cast<const wchar_t*>(heap_buf.data());
                            }
                        }

                        if (w_hardware_id) {
                            const u32 vid = find_vendor_hex(w_hardware_id);
                            if (vid == VID_INTEL) intel_hits++;
                            else if (vid == VID_AMD_ATI || vid == VID_AMD_MICRO) amd_hits++;
                        }
                    }
                }
                SetupDiDestroyDeviceInfoList(handle_dev_info);
            };

            // GUID_DEVCLASS_SYSTEM covers Host Bridges, LPC, PCI bridges Chipset/CPU etc
            // GUID_DEVCLASS_USB covers USB controller stuff
            // GUID_DEVCLASS_HDC covers SATA/IDE
            const GUID* interesting_classes[] = {
                &GUID_DEVCLASS_SYSTEM,
                &GUID_DEVCLASS_USB,
                &GUID_DEVCLASS_HDC
            };

            for (const GUID* guid : interesting_classes) {
                scan_devices(guid, DIGCF_PRESENT);
            }

            // if no stuff then mybe query all devices in the system?
            if (intel_hits == 0 && amd_hits == 0) {
                scan_devices(nullptr, DIGCF_ALLCLASSES | DIGCF_PRESENT);
            }

            if (intel_hits > amd_hits) return MBVendor::Intel;
            if (amd_hits > intel_hits) return MBVendor::AMD;
            return MBVendor::Unknown;
        };

        const MBVendor vendor = detect_motherboard();

        switch (vendor) {
        case MBVendor::Intel:
            if (claimed_amd && !claimed_intel) {
                debug("CPU_HEURISTIC: CPU reports AMD but chipset looks Intel");
                spoofed = true;
            }
            break;
        case MBVendor::AMD:
            if (claimed_intel && !claimed_amd) {
                debug("CPU_HEURISTIC: CPU reports Intel but chipset looks AMD");
                spoofed = true;
            }
            break;
        case MBVendor::Unknown:
            debug("CPU_HEURISTIC: Could not determine chipset vendor");
            break;
        }
    #endif
        return spoofed;
    }


    /**
     * @brief Check the presence of system timers
     * @category x86, Windows
     * @implements VM::CLOCK
     */
    [[nodiscard]] static bool clock() {
    #if (ARM)
		return false; // ARM systems do not have the classic x86 timers
    #endif
		if (util::is_running_under_translator()) {
            debug("CLOCK: Running inside an ARM CPU");
            return false;
        }

        // Surface Pro models typically do not have PIT, some devices might have it but not expose it due to firmware bugs (i.e. Lenovo 83AG)
        {
            const char* manufacturer = nullptr;
            const char* model = nullptr;
            if (util::get_manufacturer_model(&manufacturer, &model)) {
                auto ci_contains = [](const char* hay, const char* needle) noexcept -> bool {
                    if (!hay || !needle || !*hay || !*needle) return false;

                    const unsigned char* h =
                        reinterpret_cast<const unsigned char*>(hay);
                    const unsigned char* n =
                        reinterpret_cast<const unsigned char*>(needle);

                    for (; *h; ++h) {
                        size_t i = 0;
                        for (;; ++i) {
                            unsigned char hc = h[i];
                            unsigned char nc = n[i];

                            if (!nc) return true; 
                            if (!hc) break;

                            if (hc >= 'A' && hc <= 'Z') hc += 32;
                            if (nc >= 'A' && nc <= 'Z') nc += 32;

                            if (hc != nc) break;
                        }
                    }
                    return false;
                };

                const bool model_has_surface = ci_contains(model, "surface");
                const bool model_has_pro = ci_contains(model, "pro");
                const bool man_is_microsoft = ci_contains(manufacturer, "microsoft");

                if (model_has_surface && (model_has_pro || man_is_microsoft)) {
                    return false;
                }
            }
        }

        // The RTC (ACPI/CMOS RTC) timer can't be always detected via SetupAPI, it needs AML decode of the DSDT firmware table
        // The HPET (PNP0103) timer presence check was removed, more info at: https://github.com/kernelwernel/VMAware/pull/616
        // Here, we check for the PIT/AT timer (PC-class System Timer)
        constexpr wchar_t pattern[] = L"pnp0100"; 
        constexpr size_t patLen = (sizeof(pattern) / sizeof(wchar_t)) - 1;

        auto wcsstr_ci_ascii = [&](const wchar_t* hay) noexcept -> const wchar_t* {
            if (!hay) return nullptr;

            for (; *hay; ++hay) {
                wchar_t h = *hay;
                if (h >= L'A' && h <= L'Z') h += 32;

                if (h != pattern[0]) continue;

                size_t i = 1;
                for (; i < patLen; ++i) {
                    wchar_t next_h = hay[i];

                    if (next_h == L'\0') return nullptr;

                    if (next_h >= L'A' && next_h <= L'Z') next_h += 32;

                    if (next_h != pattern[i]) break;
                }

                if (i == patLen) return hay; 
            }
            return nullptr;
        };

        const HDEVINFO devs = SetupDiGetClassDevsW(nullptr, nullptr, nullptr, DIGCF_PRESENT | DIGCF_ALLCLASSES);
        if (devs == INVALID_HANDLE_VALUE) return false;

        SP_DEVINFO_DATA dev_info{};
        dev_info.cbSize = sizeof(SP_DEVINFO_DATA);

        DWORD buf_bytes = 4096;
        BYTE* buffer = static_cast<BYTE*>(malloc(buf_bytes));
        if (!buffer) {
            SetupDiDestroyDeviceInfoList(devs);
            return false;
        }

        bool found = false;
        for (DWORD idx = 0; SetupDiEnumDeviceInfo(devs, idx, &dev_info); ++idx) {
            DWORD property_type = 0;
            if (!SetupDiGetDeviceRegistryPropertyW(devs, &dev_info, SPDRP_HARDWAREID,
                &property_type, buffer, buf_bytes, nullptr))
            {
                const DWORD err = GetLastError();
                if (err == ERROR_INSUFFICIENT_BUFFER) {
                    DWORD required = 0;
                    SetupDiGetDeviceRegistryPropertyW(devs, &dev_info, SPDRP_HARDWAREID,
                        &property_type, nullptr, 0, &required);
                    if (required > buf_bytes) {
                        BYTE* new_buffer = static_cast<BYTE*>(realloc(buffer, required));
                        if (!new_buffer) { 
                            found = false; 
                            break; 
                        } 
                        buffer = new_buffer;
                        buf_bytes = required;
                    }
                    if (!SetupDiGetDeviceRegistryPropertyW(devs, &dev_info, SPDRP_HARDWAREID,
                        &property_type, buffer, buf_bytes, nullptr)) {
                        continue;
                    }
                }
                else {
                    continue;
                }
            }

            if (property_type != REG_MULTI_SZ) continue;

            wchar_t* cur = reinterpret_cast<wchar_t*>(buffer);
            while (*cur) {
                if (wcsstr_ci_ascii(cur)) {
                    found = true;
                    break;
                }
                cur += wcslen(cur) + 1;
            }
            if (found) break;
        }

		free(buffer);
		SetupDiDestroyDeviceInfoList(devs);
		
		return !found;
    }


    /**
     * @brief Check whether the hypervisor correctly handles MSR behavior
     * @category Windows
     * @implements VM::MSR
     */
    [[nodiscard]] static bool msr() {
    #if (!x86)
        return false;
    #endif  
        constexpr u32 random_msr = 0xDEADBEEFu;

        struct range {
            u32 start;
            u32 end;
        };
        static constexpr range ranges[] = {
            { 0x40000000u, 0x400000FFu },
            { 0x4B564D00u, 0x4B564DFFu }
        };

        auto try_read = [](u32 msr_index) -> bool {
        #if (MSVC)
            unsigned __int64 value = 0;
            __try {
                value = __readmsr(static_cast<unsigned long>(msr_index));
                (void)value;
                return true;
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                return false;
            }
        #elif (GCC || CLANG)
            static thread_local bool g_msr_faulted = false;

            auto veh_handler = [](PEXCEPTION_POINTERS info) -> LONG {
                if (info->ExceptionRecord->ExceptionCode == EXCEPTION_PRIV_INSTRUCTION) {
                    g_msr_faulted = true;
                    // skip the 'rdmsr' instruction (2 bytes: 0F 32)
                #if (x86_64)
                    info->ContextRecord->Rip += 2;
                #else
                    info->ContextRecord->Eip += 2;
                #endif
                    return EXCEPTION_CONTINUE_EXECUTION;
                }
                return EXCEPTION_CONTINUE_SEARCH;
            };

            const PVOID handle = AddVectoredExceptionHandler(1, veh_handler);

            u32 low, high;
            asm volatile (
                "rdmsr"
                : "=a"(low), "=d"(high)
                : "c"(msr_index)
            );

            RemoveVectoredExceptionHandler(handle);

            return !g_msr_faulted;
        #endif
        };

        if (try_read(random_msr)) {
            debug("MSR: Detected hypervisor not correctly handling #GP");
            return true;
        }
        for (size_t r = 0; r < (sizeof(ranges) / sizeof(ranges[0])); ++r) {
            const u32 s = ranges[r].start;
            const u32 e = ranges[r].end;
            for (u32 i = s; i != e + 1u; ++i) {
                if (try_read(i)) {
                    if (s == 0x40000000u && e == 0x400000FFu) {
                        debug("MSR: Detected Hyper-V VM");
                        return core::add(brands::HYPERV);
                    }
                    else if (s == 0x4B564D00u && e == 0x4B564DFFu) {
                        debug("MSR: Detected KVM");
                        return core::add(brands::KVM);
                    }
                    else {
                        debug("MSR: Detected readable MSR index: 0x", std::hex, i, std::dec, '\n');
                        return true;
                    }
                }
            }
        }

        return false;
    }
    // ADD NEW TECHNIQUE FUNCTION HERE
#endif
 

    /* ============================================================================================== *
     *                                                                                                *                                                                                               *
     *                                        CORE SECTION                                            *
     *                                                                                                *
     * ============================================================================================== */
public:
    struct core {
        struct technique {
            u8 points = 0;                // this is the certainty score between 0 and 100
            bool(*run)();                 // this is the technique function itself

            constexpr technique() : points(0), run(nullptr) {}
            constexpr technique(u8 points, bool(*run)()) : points(points), run(run) {}
        };

        struct custom_technique {
            u8 points;
            u16 id;
            bool(*run)();
        };

        // entry for the initialization list
        struct technique_entry {
            enum_flags id;
            technique tech;
        };

        // entry for brand scoreboard
        struct brand_entry {
            const char* name;
            brand_score_t score;
        };

        // the actual table, which is derived from the list above and will be 
        // used for most functionalities related to technique interactions
        static std::array<technique, enum_size + 1> technique_table;

        // specific to VM::add_custom(), where custom techniques will be stored here
        static constexpr size_t MAX_CUSTOM_TECHNIQUES = 256;
        static std::vector<VM::core::custom_technique> custom_table; // users should not have a limit of how many functions they should add, this is the only exception of a heap-allocated object in our core
        static size_t custom_table_size;

        // VM scoreboard table specifically for VM::brand()
        static constexpr size_t MAX_BRANDS = 128;
        static std::array<brand_entry, MAX_BRANDS> brand_scoreboard;
        static size_t brand_count;

        // Temporary storage to capture which brand was detected by the currently running technique
        static const char* last_detected_brand;
        static u8 last_detected_score;

        // 1. one brand, custom score
        static inline bool add(const char* p_brand, u8 score) noexcept {
            return add_score(p_brand, "", score);
        }

        // 2. one brand, default score
        static inline bool add(const char* p_brand) noexcept {
            return add_score(p_brand, "", 0);
        }

        // 3. two brands, default score
        static inline bool add(const char* p_brand, const char* extra_brand) noexcept {
            return add_score(p_brand, extra_brand, 0);
        }

        static inline bool add_score(const char* p_brand, const char* extra_brand, u8 score) noexcept {
            last_detected_brand = p_brand;
            last_detected_score = score; // Store for the engine to read

            for (size_t i = 0; i < brand_count; ++i) {
                // pointer comparison is sufficient as we use the static constants from brands:: namespace
                if (brand_scoreboard[i].name == p_brand) {
                    brand_scoreboard[i].score++;
                    break;
                }
            }

            if (extra_brand && extra_brand[0] != '\0') {
                for (size_t i = 0; i < brand_count; ++i) {
                    if (brand_scoreboard[i].name == extra_brand) {
                        brand_scoreboard[i].score++;
                        break;
                    }
                }
            }
            return true;
        }

        // assert if the flag is enabled, far better expression than typing std::bitset member functions
        [[nodiscard]] static inline bool is_disabled(const flagset& flags, const u8 flag_bit) noexcept {
            if (flag_bit >= flags.size()) return true;
            return !flags.test(flag_bit);
        }

        // same as above but for checking enabled flags
        [[nodiscard]] static inline bool is_enabled(const flagset& flags, const u8 flag_bit) noexcept {
            if (flag_bit >= flags.size()) return false;
            return flags.test(flag_bit);
        }

        [[nodiscard]] static bool are_techniques_empty(const flagset& flags) {
            for (std::size_t i = technique_begin; i < technique_end; i++) {
                if (flags.test(i)) {
                    return false;
                }
            }

            return true;
        }

        [[nodiscard]] static bool is_setting_flag_set(const flagset& flags) {
            for (std::size_t i = settings_begin; i < settings_end; i++) {
                if (flags.test(i)) {
                    return true;
                }
            }

            return false;
        }

        // run every VM detection mechanism in the technique table
        static u16 run_all(const flagset& flags, const bool shortcut = false) {
            u16 points = 0;

            u16 threshold_points = threshold_score;

            // set it to 300 if high threshold is enabled
            if (core::is_enabled(flags, HIGH_THRESHOLD)) {
                threshold_points = high_threshold_score;
            }

            for (size_t i = technique_begin; i < technique_end; ++i) {
                const enum_flags technique_macro = static_cast<enum_flags>(i);
                const technique& technique_data = technique_table[i];

                // skip empty entries
                if (!technique_data.run) continue;

                // check if the technique is disabled
                if (core::is_disabled(flags, technique_macro)) {
                    continue;
                }

                // check if the technique is cached already
                if (memo::is_cached(technique_macro)) {
                    const memo::data_t data = memo::cache_fetch(technique_macro);

                    if (data.result) {
                        points += data.points;
                    }

                    continue;
                }

                // reset the last detected brand before running
                last_detected_brand = nullptr;
                last_detected_score = 0;

                // run the technique
                const bool result = technique_data.run();

                if (result) {
                    // determine which points to use: Override or Default
                    const u8 points_to_add = (last_detected_score > 0) ? last_detected_score : technique_data.points;

                    points += points_to_add;
                    // this is specific to VM::detected_count() which 
                    // returns the number of techniques that found a VM.
                    detected_count_num++;

                    // retrieve the brand that was set during execution (if any)
                    const char* detected_brand = (last_detected_brand) ? last_detected_brand : brands::NULL_BRAND;
                    // store the current technique result to the cache
                    memo::cache_store(technique_macro, result, points_to_add, detected_brand);
                }
                else {
                    memo::cache_store(technique_macro, false, 0, brands::NULL_BRAND);
                }

                // for things like VM::detect() and VM::percentage(),
                // a score of 150+ is guaranteed to be a VM, so
                // there's no point in running the rest of the techniques
                // (unless the threshold is set to be higher, but it's the 
                // same story here nonetheless, except the threshold is 300)
                if (
                    (shortcut) &&
                    (points >= threshold_points)
                ) {
                    return points;
                }
            }

            // for custom VM techniques, won't be used most of the time
            if (!core::custom_table.empty()) {
                for (const auto& technique : core::custom_table) {

                    // if cached, return that result
                    if (memo::is_cached(technique.id)) {
                        const memo::data_t data = memo::cache_fetch(technique.id);

                        if (data.result) {
                            points += data.points;
                        }
                        continue;
                    }

                    // run the custom technique
                    const bool result = technique.run();

                    // accumulate a few important values
                    if (result) {
                        points += technique.points;
                        detected_count_num++;
                    }

                    // cache the result
                    memo::cache_store(
                        technique.id,
                        result,
                        technique.points
                    );
                }
            }

            return points;
        }


        /* ============================================================================================== *
         *                                                                                                *
         *                                     ARGUMENT HANDLER SECTION                                   *
         *                                                                                                *
         * ============================================================================================== */

         /**
          * basically what this entire section does is handle the arguments in a way
          * where it can coordinate between enabled and disabled flags. The flags in
          * the argument handling strategy are std::bitset variables (right below 
          * this comment), and it's used as a semi-global variable so that each 
          * component can share this variable together. The core of this section is
          * the arg_handler and disabled_arg_handler functions. They both take a 
          * variadic argument of enum_flags. The former decides which bits should be 
          * enabled, while the latter will toggle those bits (if there's any) after 
          * the arg_handler processing is done.
          */
    
    // this is public but only for advanced use cases. It's intentionally undocumented.
    public: 
        static flagset flag_collector;
        static flagset disabled_flag_collector;
    
        static void generate_default(flagset& flags) {
            // set all bits to 1
            flags.set();

            // disable all non-default techniques
            for (const auto id : disabled_techniques) {
                flags.flip(id);
            }

            // disable all the settings flags except for VM::DEFAULT
            flags.flip(HIGH_THRESHOLD);
            flags.flip(NULL_ARG);
            flags.flip(DYNAMIC);
            flags.flip(MULTIPLE);
            flags.flip(ALL);
        }

        // this overload is mainly for default argument purposes
        static flagset generate_default() {
            flagset flags;
            generate_default(flags);
            return flags;
        }

        static void generate_all(flagset& flags) {
            generate_default(flags);

            for (const enum_flags technique : disabled_techniques) {
                flags.set((enum_flags)technique, true);
            }
        }

        static void reset_disabled_flagset() {
            disabled_flag_collector.reset();
            for (const auto technique : disabled_techniques) {
                disabled_flag_collector.set(static_cast<u32>(technique), true);
            }
        }

        // base handle implementation
        static inline bool all_enum_flags() {
            return true;
        }

        template <typename T, typename... Rest>
        static bool all_enum_flags(T&& /*first*/, Rest&&... rest) {
            using Decayed = typename std::decay<T>::type;

            if (!std::is_same<Decayed, enum_flags>::value) {
                return false;
            }

            return all_enum_flags(std::forward<Rest>(rest)...);
        }

        template <typename... Args>
        static bool is_type_valid(Args&&... args) {
            return all_enum_flags(std::forward<Args>(args)...);
        }

        template <typename... Args>
        static constexpr bool is_empty() {
            return (sizeof...(Args) == 0);
        }

        // this will generate a std::bitset based on the arguments provided
        template <typename... Args>
        static VMAWARE_CONSTEXPR flagset arg_handler(Args&&... args) {
            if (is_type_valid(args...) == false) {
                throw std::invalid_argument("argument handler only accepts enum_flags variables");
            }

            // reset all relevant flags
            flag_collector.reset();

            if VMAWARE_CONSTEXPR(is_empty<Args...>()) {
                generate_default(flag_collector);
                return flag_collector;
            }

            // C++ trick to loop over the variadic arguments one by one
            int dummy[] = {
                (flag_collector.set(static_cast<u32>(args), true), 0)...
            };
            VMAWARE_UNUSED(dummy);

            if (flag_collector.test(DEFAULT)) {
                generate_default(flag_collector);
            }

            if (are_techniques_empty(flag_collector)) {
                flag_collector |= generate_default();
            }

            if (flag_collector.test(ALL)) {
                generate_all(flag_collector);
            }

            // if flag is disabled, remove it from the flag_collector
            for (u8 i = 0; i < enum_size + 1; i++) {
                if (disabled_flag_collector.test(i)) {
                    flag_collector.set(i, false);
                }
            }

            return flag_collector;
        }

        // same as above but for VM::disable which only accepts technique flags
        template <typename... Args>
        static void disabled_arg_handler(Args&&... args) {
            if (is_type_valid(args...) == false) {
                throw std::invalid_argument("disabled argument handler only accepts enum_flags variables");
            }

            if VMAWARE_CONSTEXPR(is_empty<Args...>()) {
                throw std::invalid_argument("VM::DISABLE() must contain a flag");
            }

            // C++ trick to loop over the variadic arguments one by one
            int dummy[] = { 
                (disabled_flag_collector.set(args, true), 0)...
            };
            VMAWARE_UNUSED(dummy);

            // check if a settings flag is set, which is not valid
            if (core::is_setting_flag_set(disabled_flag_collector)) {
                throw std::invalid_argument("VM::DISABLE() must not contain a settings flag, they are disabled by default anyway");
            }
        }
    };

public: // START OF PUBLIC FUNCTIONS

    /**
     * @brief Check for a specific technique based on flag argument
     * @param u8 (flags from VM wrapper)
     * @return bool
     * @link https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#vmcheck
     */
    static bool check(
        const enum_flags flag_bit
    #if (SOURCE_LOCATION_SUPPORTED)
        , [[maybe_unused]] const std::source_location& loc = std::source_location::current()
    #endif
    ) {
        if (util::is_unsupported(flag_bit)) {
            memo::cache_store(flag_bit, false, 0, brands::NULL_BRAND);
            return false;
        }

        auto throw_error = [&](const char* text) -> void {
            std::stringstream ss;
        #if (VMA_CPP >= 20 && !CLANG)
            ss << ", error in " << loc.function_name() << " at " << loc.file_name() << ":" << loc.line() << ")";
        #endif
            ss << ". Consult the documentation's flag handler for VM::check()";
            throw std::invalid_argument(std::string(text) + ss.str());
        };

        if (flag_bit > enum_size) {
            throw_error("Flag argument must be a valid");
        }

        // check if the bit is a settings flag, which shouldn't be allowed
        if (
            (flag_bit == HIGH_THRESHOLD) ||
            (flag_bit == DYNAMIC) ||
            (flag_bit == MULTIPLE)
        ) {
            throw_error("Flag argument must be a technique flag and not a settings flag");
        }

        #if (VMA_CPP >= 23)
            [[assume(flag_bit < technique_end)]];
        #endif

        // if the technique is already cached, return the cached value instead
        if (memo::is_cached(flag_bit)) {
            const memo::data_t data = memo::cache_fetch(flag_bit);
            return data.result;
        }

        if (flag_bit < technique_end) {
            const core::technique& pair = core::technique_table[flag_bit];

            if (auto run_fn = pair.run) {
                core::last_detected_brand = nullptr;
                core::last_detected_score = 0;

                const bool result = run_fn();

                const u8 points_to_add = (core::last_detected_score > 0) ? core::last_detected_score : pair.points;
                const char* detected_brand = (core::last_detected_brand) ? core::last_detected_brand : brands::NULL_BRAND;

                if (result) {
                    detected_count_num++;
                }

                memo::cache_store(flag_bit, result, result ? points_to_add : 0, detected_brand);
                return result;
            }
            else {
                throw_error("Flag is not known or not implemented");
            }
        }

        return false;
    }


    /**
     * @brief Fetch the VM brand
     * @param any flag combination in VM structure or nothing (VM::MULTIPLE can be added)
     * @return const char*
     * @link https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#vmbrand
     */
    template <typename ...Args>
    static std::string brand(Args ...args) {
        const flagset flags = core::arg_handler(args...);
        return brand(flags);
    }

    static std::string brand(const flagset& flags = core::generate_default()) {
        // is the multiple setting flag enabled?
        const bool is_multiple = core::is_enabled(flags, MULTIPLE);

        // check if the result is already cached and return that instead
        if (is_multiple) {
            if (memo::multi_brand::is_cached()) {
                debug("VM::brand(): returned multi brand from cache");
                return memo::multi_brand::fetch();
            }
        }
        else {
            if (memo::brand::is_cached()) {
                debug("VM::brand(): returned brand from cache");
                return memo::brand::fetch();
            }
        }

        // run all the techniques
        const u16 score = core::run_all(flags);

    #if (VMA_CPP <= 14)
        constexpr const char* TMP_QEMU = "QEMU";
        constexpr const char* TMP_KVM = "KVM";
        constexpr const char* TMP_QEMU_KVM = "QEMU+KVM";
        constexpr const char* TMP_KVM_HYPERV = "KVM Hyper-V Enlightenment";
        constexpr const char* TMP_QEMU_KVM_HYPERV = "QEMU+KVM Hyper-V Enlightenment";

        constexpr const char* TMP_VMWARE = "VMware";
        constexpr const char* TMP_VMWARE_HARD = "VMware (with VmwareHardenedLoader)";
        constexpr const char* TMP_EXPRESS = "VMware Express";
        constexpr const char* TMP_ESX = "VMware ESX";
        constexpr const char* TMP_GSX = "VMware GSX";
        constexpr const char* TMP_WORKSTATION = "VMware Workstation";
        constexpr const char* TMP_FUSION = "VMware Fusion";

        constexpr const char* TMP_VPC = "Virtual PC";
        constexpr const char* TMP_HYPERV = "Microsoft Hyper-V";
        constexpr const char* TMP_HYPERV_VPC = "Microsoft Virtual PC/Hyper-V";
        constexpr const char* TMP_AZURE = "Microsoft Azure Hyper-V";
        constexpr const char* TMP_HYPERV_ARTIFACT = "Hyper-V artifact (host running Hyper-V)";
    #else
        constexpr const char* TMP_QEMU = brands::QEMU;
        constexpr const char* TMP_KVM = brands::KVM;
        constexpr const char* TMP_QEMU_KVM = brands::QEMU_KVM;
        constexpr const char* TMP_KVM_HYPERV = brands::KVM_HYPERV;
        constexpr const char* TMP_QEMU_KVM_HYPERV = brands::QEMU_KVM_HYPERV;

        constexpr const char* TMP_VMWARE = brands::VMWARE;
        constexpr const char* TMP_VMWARE_HARD = brands::VMWARE_HARD;
        constexpr const char* TMP_EXPRESS = brands::VMWARE_EXPRESS;
        constexpr const char* TMP_ESX = brands::VMWARE_ESX;
        constexpr const char* TMP_GSX = brands::VMWARE_GSX;
        constexpr const char* TMP_WORKSTATION = brands::VMWARE_WORKSTATION;
        constexpr const char* TMP_FUSION = brands::VMWARE_FUSION;

        constexpr const char* TMP_VPC = brands::VPC;
        constexpr const char* TMP_HYPERV = brands::HYPERV;
        constexpr const char* TMP_HYPERV_VPC = brands::HYPERV_VPC;
        constexpr const char* TMP_AZURE = brands::AZURE_HYPERV;
        constexpr const char* TMP_HYPERV_ARTIFACT = brands::HYPERV_ARTIFACT;
    #endif

        using brand_element_t = std::pair<const char*, brand_score_t>;
        std::array<brand_element_t, core::MAX_BRANDS> active_brands;
        size_t active_count = 0;

        for (size_t i = 0; i < core::brand_count; ++i) {
            if (core::brand_scoreboard[i].score > 0) {
                active_brands[active_count++] = std::make_pair(core::brand_scoreboard[i].name, core::brand_scoreboard[i].score);
            }
        }

        // if all brands have a point of 0, return "Unknown"
        if (active_count == 0) {
            return brands::NULL_BRAND;
        }

        // if there's only a single brand, return it immediately
        // We skip this early return if the single brand is HYPERV_ARTIFACT,
        // so that the removal logic at the end of the function can process it
        if (active_count == 1 && active_brands[0].first != TMP_HYPERV_ARTIFACT) {
            return active_brands[0].first;
        }

        // helper lambdas for array manipulation
        auto find_index = [&](const char* name) noexcept -> int {
            for (size_t i = 0; i < active_count; ++i) {
                // pointer comparison is sufficient for static brands
                if (active_brands[i].first == name) return static_cast<int>(i);
            }
            return -1;
        };

        auto remove_at = [&](int index) noexcept {
            if (index >= 0 && index < static_cast<int>(active_count)) {
                if (index != static_cast<int>(active_count - 1)) {
                    active_brands[static_cast<size_t>(index)] = active_brands[active_count - 1];
                }
                active_count--;
            }
        };

        // remove Hyper-V artifacts if found with other brands
        if (active_count > 1) {
            const int idx = find_index(TMP_HYPERV_ARTIFACT);
            if (idx != -1) {
                remove_at(idx);
            }
        }

        // merge 2 brands
        auto merge = [&](const char* a, const char* b, const char* result) noexcept -> void {
            int idx_a = find_index(a);
            if (idx_a == -1) return;

            int idx_b = find_index(b);
            if (idx_b == -1) return;

            remove_at(idx_a);
            idx_b = find_index(b); // re-find
            remove_at(idx_b);

            active_brands[active_count++] = std::make_pair(result, 2);
        };

        // same as above, but for 3
        auto triple_merge = [&](const char* a, const char* b, const char* c, const char* result) noexcept -> void {
            int idx_a = find_index(a);
            if (idx_a == -1) return;
            int idx_b = find_index(b);
            if (idx_b == -1) return;
            int idx_c = find_index(c);
            if (idx_c == -1) return;

            remove_at(idx_a);
            remove_at(find_index(b));
            remove_at(find_index(c));

            active_brands[active_count++] = std::make_pair(result, 2);
        };

        // some edgecase handling for Hyper-V and VirtualPC
        int idx_hv = find_index(TMP_HYPERV);
        int idx_vpc = find_index(TMP_VPC);

        if (idx_hv != -1 && idx_vpc != -1) {
            // existence is confirmed by index != -1
            merge(TMP_VPC, TMP_HYPERV, TMP_HYPERV_VPC);
        }
        else if (idx_hv != -1 && idx_vpc == -1) {
            // logic handled by merge check essentially
        }

        // Brand post-processing / merging
        merge(TMP_AZURE, TMP_HYPERV, TMP_AZURE);
        merge(TMP_AZURE, TMP_VPC, TMP_AZURE);
        merge(TMP_AZURE, TMP_HYPERV_VPC, TMP_AZURE);

        merge(TMP_QEMU, TMP_KVM, TMP_QEMU_KVM);
        merge(TMP_KVM, TMP_HYPERV, TMP_KVM_HYPERV);
        merge(TMP_QEMU, TMP_HYPERV, TMP_QEMU_KVM_HYPERV);
        merge(TMP_QEMU_KVM, TMP_HYPERV, TMP_QEMU_KVM_HYPERV);
        merge(TMP_KVM, TMP_KVM_HYPERV, TMP_KVM_HYPERV);
        merge(TMP_QEMU, TMP_KVM_HYPERV, TMP_QEMU_KVM_HYPERV);
        merge(TMP_QEMU_KVM, TMP_KVM_HYPERV, TMP_QEMU_KVM_HYPERV);

        triple_merge(TMP_QEMU, TMP_KVM, TMP_KVM_HYPERV, TMP_QEMU_KVM_HYPERV);

        merge(TMP_VMWARE, TMP_FUSION, TMP_FUSION);
        merge(TMP_VMWARE, TMP_EXPRESS, TMP_EXPRESS);
        merge(TMP_VMWARE, TMP_ESX, TMP_ESX);
        merge(TMP_VMWARE, TMP_GSX, TMP_GSX);
        merge(TMP_VMWARE, TMP_WORKSTATION, TMP_WORKSTATION);

        merge(TMP_VMWARE_HARD, TMP_VMWARE, TMP_VMWARE_HARD);
        merge(TMP_VMWARE_HARD, TMP_FUSION, TMP_VMWARE_HARD);
        merge(TMP_VMWARE_HARD, TMP_EXPRESS, TMP_VMWARE_HARD);
        merge(TMP_VMWARE_HARD, TMP_ESX, TMP_VMWARE_HARD);
        merge(TMP_VMWARE_HARD, TMP_GSX, TMP_VMWARE_HARD);
        merge(TMP_VMWARE_HARD, TMP_WORKSTATION, TMP_VMWARE_HARD);

        // determine threshold (150 or 300)
        u16 confirmed_vm_threshold = threshold_score;
        if (core::is_enabled(flags, HIGH_THRESHOLD)) {
            confirmed_vm_threshold = high_threshold_score;
        }

        // check if Hyper-V artifact is present
        const int idx_art = find_index(TMP_HYPERV_ARTIFACT);
        if (idx_art != -1) {
            // If score confirms it is a VM, remove the "Artifact" label (because we're in a VM, not in a host machine)
            // so it falls back to "Unknown" if no other brands exist
            if (score >= confirmed_vm_threshold) {
                remove_at(idx_art);
            }
        }

        if (active_count > 1) {
            std::sort(active_brands.begin(), active_brands.begin() + static_cast<std::ptrdiff_t>(active_count), [](
                const brand_element_t& a,
                const brand_element_t& b
                ) {
                return a.second > b.second;
            });
        }

    #ifdef __VMAWARE_DEBUG__
        for (size_t i = 0; i < active_count; ++i) {
            debug("scoreboard: ", (int)active_brands[i].second, " : ", active_brands[i].first);
        }
    #endif

        if (active_count > 0) {
            if (!is_multiple) {
                memo::brand::store(active_brands[0].first);
                debug("VM::brand(): cached brand string");
                return memo::brand::fetch();
            }
            else {
                char* buffer = memo::multi_brand::brand_cache;
                buffer[0] = '\0';
                const size_t buf_size = sizeof(memo::multi_brand::brand_cache);

                str_copy(buffer, active_brands[0].first, buf_size);
                for (size_t i = 1; i < active_count; i++) {
                    str_cat(buffer, " or ", buf_size);
                    str_cat(buffer, active_brands[i].first, buf_size);
                }

                memo::multi_brand::cached = true;
                debug("VM::brand(): cached multiple brand string");
                return memo::multi_brand::fetch();
            }
        }

        return brands::NULL_BRAND;
    }


    /**
     * @brief Detect if running inside a VM
     * @param any flag combination in VM structure or nothing
     * @return bool
     * @link https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#vmdetect
     */
    template <typename ...Args>
    static bool detect(Args ...args) {
        // fetch all the flags in a std::bitset
        const flagset flags = core::arg_handler(args...);
        return detect(flags);
    }

    static bool detect(const flagset &flags = core::generate_default()) {
        // run all the techniques based on the 
        // flags above, and get a total score 
        const u16 points = core::run_all(flags, SHORTCUT);

        u16 threshold = threshold_score;

        // if high threshold is set, the bar
        // will be 300. If not, leave it as 150
        if (core::is_enabled(flags, HIGH_THRESHOLD)) {
            threshold = high_threshold_score;
        }

        if (points >= threshold) {
            return true;
        }

        // this is added as a last ditch attempt to detect a VM, 
        // because if there are indications of hardening then logically 
        // it should in fact be a VM.
        return (is_hardened());
    }


    /**
     * @brief Get the percentage of how likely it's a VM
     * @param any flag combination in VM structure or nothing
     * @return std::uint8_t
     * @link https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#vmpercentage
     */
    template <typename ...Args>
    static u8 percentage(Args ...args) {
        // fetch all the flags in a std::bitset
        const flagset flags = core::arg_handler(args...);
        return percentage(flags);
    }


    static u8 percentage(const flagset &flags = core::generate_default()) {
        // run all the techniques based on the 
        // flags above, and get a total score
        const u16 points = core::run_all(flags, SHORTCUT);

        u8 percent = 0;
        u16 threshold = threshold_score;

        // set to 300 if high threshold is enabled
        if (core::is_enabled(flags, HIGH_THRESHOLD)) {
            threshold = high_threshold_score;
        }

        // the percentage will be set to 99%, because a score 
        // of 100 is not entirely robust. 150 is more robust
        // in my opinion, which is why you need a score of
        // above 150 to get to 100% 
        if (points >= threshold) {
            percent = 100;
        } else if (points >= 100) {
            percent = 99;
        } else {
            percent = static_cast<u8>(std::min<u16>(points, 99));
        }

        return percent;
    }


    /**
     * @brief Add a custom technique to the VM detection technique collection
     * @param either a function pointer, lambda function, or std::function<bool()>
     * @link https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#vmaddcustom
     * @return void
     */
    static void add_custom(
        const u8 percent,
        bool(*detection_func)()
        #if (SOURCE_LOCATION_SUPPORTED)
        , const std::source_location& loc = std::source_location::current()
        #endif
    ) {
        // lambda to throw the error
        auto throw_error = [&](const char* text) -> void {
            std::stringstream ss;
    #if (VMA_CPP >= 20 && !CLANG)
            ss << ", error in " << loc.function_name() << " at " << loc.file_name() << ":" << loc.line() << ")";
    #endif
            ss << ". Consult the documentation's parameters for VM::add_custom()";
            throw std::invalid_argument(std::string(text) + ss.str());
        };

        if (percent > 100) {
            throw_error("Percentage parameter must be between 0 and 100");
        }

    #if (VMA_CPP >= 23)
        [[assume(percent > 0 && percent <= 100)]];
    #endif

        size_t current_index = core::custom_table.size();

        core::custom_technique query{
            percent,
            static_cast<u16>(static_cast<int>(base_technique_count) + static_cast<int>(current_index) + 1),
            detection_func
        };

        technique_count++;

        core::custom_table.push_back(query);
    }


    /**
     * @brief disable the provided technique flags so they are not counted to the overall result
     * @param technique flag(s) only
     * @link https://github.com/kernelwernel/VMAware/blob/main/docs/documentation.md#vmdetect
     * @return flagset
     */
    template <typename ...Args>
    static enum_flags DISABLE(Args ...args) {
        // basically core::arg_handler but in reverse,
        // it'll clear the bits of the provided flags
        core::disabled_arg_handler(args...);
        return VM::NULL_ARG;
    }

    /**
     * @brief This will convert the technique flag into a string, which will correspond to the technique name
     * @param single technique flag in VM structure
     */
    [[nodiscard]] static std::string flag_to_string(const enum_flags flag) {
        switch (flag) {
            // START OF TECHNIQUE LIST
            case VMID: return "VMID";
            case CPU_BRAND: return "CPU_BRAND";
            case HYPERVISOR_BIT: return "HYPERVISOR_BIT";
            case HYPERVISOR_STR: return "HYPERVISOR_STR";
            case TIMER: return "TIMER";
            case THREAD_COUNT: return "THREAD_COUNT";
            case MAC: return "MAC";
            case TEMPERATURE: return "TEMPERATURE";
            case SYSTEMD: return "SYSTEMD";
            case CVENDOR: return "CVENDOR";
            case CTYPE: return "CTYPE";
            case DOCKERENV: return "DOCKERENV";
            case DMIDECODE: return "DMIDECODE";
            case DMESG: return "DMESG";
            case HWMON: return "HWMON";
            case DLL: return "DLL";
            case HWMODEL: return "HWMODEL";
            case WINE: return "WINE";
            case POWER_CAPABILITIES: return "POWER_CAPABILITIES";
            case PROCESSES: return "PROCESSES";
            case LINUX_USER_HOST: return "LINUX_USER_HOST";
            case GAMARUE: return "GAMARUE";
            case BOCHS_CPU: return "BOCHS_CPU";
            case MAC_MEMSIZE: return "MAC_MEMSIZE";
            case MAC_IOKIT: return "MAC_IOKIT";
            case IOREG_GREP: return "IOREG_GREP";
            case MAC_SIP: return "MAC_SIP";
            case VPC_INVALID: return "VPC_INVALID";
            case SYSTEM_REGISTERS: return "TASK_SEGMENT";
            case VMWARE_IOMEM: return "VMWARE_IOMEM";
            case VMWARE_IOPORTS: return "VMWARE_IOPORTS";
            case VMWARE_SCSI: return "VMWARE_SCSI";
            case VMWARE_DMESG: return "VMWARE_DMESG";
            case VMWARE_STR: return "VMWARE_STR";
            case VMWARE_BACKDOOR: return "VMWARE_BACKDOOR";
            case MUTEX: return "MUTEX";
            case THREAD_MISMATCH: return "THREAD_MISMATCH";
            case CUCKOO_DIR: return "CUCKOO_DIR";
            case CUCKOO_PIPE: return "CUCKOO_PIPE";
            case AZURE: return "AZURE";
            case DISPLAY: return "DISPLAY";
            case DEVICE_STRING: return "DEVICE_STRING";
            case BLUESTACKS_FOLDERS: return "BLUESTACKS_FOLDERS";
            case CPUID_SIGNATURE: return "CPUID_SIGNATURE";
            case KGT_SIGNATURE: return "KGT_SIGNATURE";
            case QEMU_VIRTUAL_DMI: return "QEMU_VIRTUAL_DMI";
            case QEMU_USB: return "QEMU_USB";
            case HYPERVISOR_DIR: return "HYPERVISOR_DIR";
            case UML_CPU: return "UML_CPU";
            case KMSG: return "KMSG";
            case VBOX_MODULE: return "VBOX_MODULE";
            case SYSINFO_PROC: return "SYSINFO_PROC";
            case DMI_SCAN: return "DMI_SCAN";
            case SMBIOS_VM_BIT: return "SMBIOS_VM_BIT";
            case PODMAN_FILE: return "PODMAN_FILE";
            case WSL_PROC: return "WSL_PROC";
            case DRIVERS: return "DRIVERS";
            case DISK_SERIAL: return "DISK_SERIAL";
            case IVSHMEM: return "IVSHMEM";
            case GPU_CAPABILITIES: return "GPU_CAPABILITIES";
            case DEVICE_HANDLES: return "DEVICE_HANDLES";
            case QEMU_FW_CFG: return "QEMU_FW_CFG";
            case VIRTUAL_PROCESSORS: return "VIRTUAL_PROCESSORS";
            case HYPERVISOR_QUERY: return "HYPERVISOR_QUERY";
            case AMD_SEV: return "AMD_SEV";
            case VIRTUAL_REGISTRY: return "VIRTUAL_REGISTRY";
            case FIRMWARE: return "FIRMWARE";
            case FILE_ACCESS_HISTORY: return "FILE_ACCESS_HISTORY";
            case AUDIO: return "AUDIO";
            case NSJAIL_PID: return "NSJAIL_PID";
            case PCI_DEVICES: return "PCI_DEVICES";
            case ACPI_SIGNATURE: return "ACPI_SIGNATURE";
            case TRAP: return "TRAP";
            case UD: return "UNDEFINED_INSTRUCTION";
            case BLOCKSTEP: return "BLOCKSTEP";
            case DBVM: return "DBVM";
            case BOOT_LOGO: return "BOOT_LOGO";
            case MAC_SYS: return "MAC_SYS";
            case KERNEL_OBJECTS: return "KERNEL_OBJECTS";
            case NVRAM: return "NVRAM";
            case SMBIOS_INTEGRITY: return "SMBIOS_INTEGRITY";
            case EDID: return "EDID";
            case CPU_HEURISTIC: return "CPU_HEURISTIC";
            case CLOCK: return "CLOCK";
            case MSR: return "MSR";
            // END OF TECHNIQUE LIST
            case DEFAULT: return "DEFAULT"; 
            case ALL: return "ALL"; 
            case NULL_ARG: return "NULL_ARG"; 
            case HIGH_THRESHOLD: return "HIGH_THRESHOLD"; 
            case DYNAMIC: return "DYNAMIC"; 
            case MULTIPLE: return "MULTIPLE"; 
            default: return "Unknown flag";
        }
    }


    /**
     * @brief Fetch all the brands that were detected in a vector
     * @param any flag combination in VM structure or nothing
     * @return VM::enum_vector
     */
    template <typename ...Args>
    static std::vector<enum_flags> detected_enums(Args ...args) {
        const flagset flags = core::arg_handler(args...);
        return detected_enums(flags);
    }


    static std::vector<enum_flags> detected_enums(const flagset &flags = core::generate_default()) {
        std::vector<enum_flags> tmp;

        // this will loop through all the enums in the technique_vector variable,
        // and then checks each of them and outputs the enum that was detected
        for (u8 i = technique_begin; i < technique_end; ++i) {
            const enum_flags technique_enum = static_cast<enum_flags>(i);

            if (
                (flags.test(technique_enum)) &&
                (check(technique_enum))
            ) {
                tmp.push_back(technique_enum);
            }
        }

        return tmp;
    }

    /**
     * @brief Change the certainty score of a technique
     * @param technique flag, then the new percentage score to overwite
     * @return void
     * @warning âš ï¸ FOR DEVELOPMENT USAGE ONLY, NOT MEANT FOR PUBLIC USE FOR NOW âš ï¸
     */
    static void modify_score(
        const enum_flags flag,
        const u8 percent
    #if (SOURCE_LOCATION_SUPPORTED)
        , const std::source_location& loc = std::source_location::current()
    #endif
    ) {
        // lambda to throw the error
        auto throw_error = [&](const char* text) -> void {
            std::stringstream ss;
    #if (VMA_CPP >= 20 && !CLANG)
            ss << ", error in " << loc.function_name() << " at " << loc.file_name() << ":" << loc.line() << ")";
    #endif
            ss << ". Consult the documentation's parameters for VM::modify_score()";
            throw std::invalid_argument(std::string(text) + ss.str());
        };

        if (percent > 100) {
            throw_error("Percentage parameter must be between 0 and 100");
        }

    #if (VMA_CPP >= 23)
        [[assume(percent <= 100)]];
    #endif  

        // check if the flag provided is a setting flag, which isn't valid
        if (static_cast<u8>(flag) >= technique_end) {
            throw_error("The flag is not a technique flag");
        }

        core::technique_table[flag].points = percent;
    }

    /**
     * @brief Fetch the total number of detected techniques
     * @param any flag combination in VM structure or nothing
     * @return std::uint8_t
     */
    template <typename ...Args>
    static u8 detected_count(Args ...args) {
        const flagset flags = core::arg_handler(args...);
        return detected_count(flags);
    }


    static u8 detected_count(const flagset &flags = core::generate_default()) {
        // run all the techniques, which will set the detected_count variable 
        core::run_all(flags);

        return detected_count_num;
    }


    /**
     * @brief Fetch the total number of detected techniques
     * @param any flag combination in VM structure or nothing
     * @return const char*
     */
    template <typename ...Args>
    static std::string type(Args ...args) {
        const flagset flags = core::arg_handler(args...);
        return type(flags);
    }


    static std::string type(const flagset &flags = core::generate_default()) {
        const std::string brand_str = brand(flags);

        // if multiple brands were found, return unknown
        if (util::find(brand_str, " or ")) {
            return "Unknown";
        }

        struct map_entry {
            const char* name;
            const char* type;
        };

        // Static table for O(1) scanning
        static constexpr map_entry type_table[] = {
            // type 1
            { brands::XEN, "Hypervisor (type 1)" },
            { brands::VMWARE_ESX, "Hypervisor (type 1)" },
            { brands::ACRN, "Hypervisor (type 1)" },
            { brands::QNX, "Hypervisor (type 1)" },
            { brands::HYPERV, "Hypervisor (type 2)" }, // to clarify you're running under a Hyper-V guest VM
            { brands::AZURE_HYPERV, "Hypervisor (type 1)" },
            { brands::KVM, "Hypervisor (type 1)" },
            { brands::KVM_HYPERV, "Hypervisor (type 1)" },
            { brands::QEMU_KVM_HYPERV, "Hypervisor (type 1)" },
            { brands::QEMU_KVM, "Hypervisor (type 1)" },
            { brands::INTEL_KGT, "Hypervisor (type 1)" },
            { brands::SIMPLEVISOR, "Hypervisor (type 1)" },
            { brands::OPENSTACK, "Hypervisor (type 1)" },
            { brands::KUBEVIRT, "Hypervisor (type 1)" },
            { brands::POWERVM, "Hypervisor (type 1)" },
            { brands::AWS_NITRO, "Hypervisor (type 1)" },
            { brands::LKVM, "Hypervisor (type 1)" },
            { brands::NOIRVISOR, "Hypervisor (type 1)" },
            { brands::WSL, "Hypervisor (Type 1)" }, // Type 1-derived lightweight VM system
            { brands::DBVM, "Hypervisor (Type 1)" }, 

            // type 2
            { brands::BHYVE, "Hypervisor (type 2)" },
            { brands::VBOX, "Hypervisor (type 2)" },
            { brands::VMWARE, "Hypervisor (type 2)" },
            { brands::VMWARE_EXPRESS, "Hypervisor (type 2)" },
            { brands::VMWARE_GSX, "Hypervisor (type 2)" },
            { brands::VMWARE_WORKSTATION, "Hypervisor (type 2)" },
            { brands::VMWARE_FUSION, "Hypervisor (type 2)" },
            { brands::PARALLELS, "Hypervisor (type 2)" },
            { brands::VPC, "Hypervisor (type 2)" },
            { brands::NVMM, "Hypervisor (type 2)" },
            { brands::BSD_VMM, "Hypervisor (type 2)" },
            { brands::HYPERV_VPC, "Hypervisor (type 2)" },
            { brands::VMWARE_HARD, "Hypervisor (type 2)" },
            { brands::UTM, "Hypervisor (type 2)" },
            { brands::INTEL_HAXM, "Hosted hypervisor / accelerator (type 2)" },

            // sandbox
            { brands::CUCKOO, "Sandbox" },
            { brands::SANDBOXIE, "Sandbox" },
            { brands::HYBRID, "Sandbox" },
            { brands::CWSANDBOX, "Sandbox" },
            { brands::JOEBOX, "Sandbox" },
            { brands::ANUBIS, "Sandbox" },
            { brands::COMODO, "Sandbox" },
            { brands::THREATEXPERT, "Sandbox" },
            { brands::QIHOO, "Sandbox" },

            // misc
            { brands::BOCHS, "Emulator" },
            { brands::BLUESTACKS, "Emulator" },
            { brands::NEKO_PROJECT, "Emulator" },
            { brands::COMPAQ, "Emulator" },
            { brands::INSIGNIA, "Emulator" },
            { brands::CONNECTIX, "Emulator" },
            { brands::QEMU, "Emulator/Hypervisor (type 2)" },
            { brands::JAILHOUSE, "Partitioning Hypervisor" },
            { brands::UNISYS, "Partitioning Hypervisor" },
            { brands::DOCKER, "Container" },
            { brands::PODMAN, "Container" },
            { brands::OPENVZ, "Container" },
            { brands::LMHS, "Hypervisor (unknown type)" },
            { brands::WINE, "Compatibility layer" },
            { brands::INTEL_TDX, "Trusted Domain" },
            { brands::APPLE_VZ, "Unknown" },
            { brands::UML, "Paravirtualised/Hypervisor (type 2)" },
            { brands::AMD_SEV, "VM encryptor" },
            { brands::AMD_SEV_ES, "VM encryptor" },
            { brands::AMD_SEV_SNP, "VM encryptor" },
            { brands::GCE, "Cloud VM service" },
            { brands::NSJAIL, "Process isolator" },
            { brands::HYPERV_ARTIFACT, "Unknown" }, // This refers to the type 1 hypervisor where Windows normally runs under, we put "Unknown" to clarify you're not running under a VM if this is detected
            { brands::NULL_BRAND, "Unknown" }
        };

        for (const auto& entry : type_table) {
            // pointer comparison first , because is the fastest/O(1) relative to string length
            if (brand_str == entry.name) {
                return entry.type;
            }
        }

        // theres a chance of brand() returning a cache pointer but same content
        for (const auto& entry : type_table) {
            if (brand_str == entry.name) {
                return entry.type;
            }
        }

        debug("VM::type(): No known brand found, something went terribly wrong here...");

        return "Unknown";
    }


    /**
      * @brief Fetch the conclusion message based on the brand and percentage
      * @param any flag combination in VM structure or nothing
      * @return const char*
      */
    template <typename ...Args>
    static std::string conclusion(Args ...args) {
        const flagset flags = core::arg_handler(args...);
        return conclusion(flags);
    }


    static std::string conclusion(const flagset &flags = core::generate_default()) {
        std::string brand_tmp = brand(flags);
        const u8 percent_tmp = percentage(flags);
        const bool has_hardener = is_hardened();

        constexpr const char* very_unlikely = "Very unlikely";
        constexpr const char* unlikely = "Unlikely";
        constexpr const char* potentially = "Potentially";
        constexpr const char* might = "Might be";
        constexpr const char* likely = "Likely";
        constexpr const char* very_likely = "Very likely";
        constexpr const char* inside_vm = "Running inside";

        auto make_conclusion = [&](const char* category) -> std::string {
            if (memo::conclusion::cached) {
                return memo::conclusion::fetch();
            }

            const char* hardener = "";
            
            if (has_hardener) {
                hardener = "hardened ";
            }
            
            const char* addition = " a ";

            // this basically just fixes the grammatical syntax
            // by either having "a" or "an" before the VM brand
            // name. It would look weird if the conclusion 
            // message was "an VirtualBox" or "a Anubis", so this
            // condition fixes that issue.
            if (
                !has_hardener && (
                    (brand_tmp == brands::ACRN) ||
                    (brand_tmp == brands::ANUBIS) ||
                    (brand_tmp == brands::BSD_VMM) ||
                    (brand_tmp == brands::INTEL_HAXM) ||
                    (brand_tmp == brands::APPLE_VZ) ||
                    (brand_tmp == brands::INTEL_KGT) ||
                    (brand_tmp == brands::POWERVM) ||
                    (brand_tmp == brands::OPENSTACK) ||
                    (brand_tmp == brands::AWS_NITRO) ||
                    (brand_tmp == brands::OPENVZ) ||
                    (brand_tmp == brands::INTEL_TDX) ||
                    (brand_tmp == brands::AMD_SEV) ||
                    (brand_tmp == brands::AMD_SEV_ES) ||
                    (brand_tmp == brands::AMD_SEV_SNP) ||
                    (brand_tmp == brands::NSJAIL) ||
                    (brand_tmp == brands::NULL_BRAND)
                )
            ) {
                addition = " an ";
            }

            // this is basically just to remove the capital "U", 
            // since it doesn't make sense to see "an Unknown"
            if (brand_tmp == brands::NULL_BRAND) {
                brand_tmp = "unknown";
            }

            // Hyper-V artifacts are an exception due to how unique the circumstance is
            const std::string result = 
                std::string(category) + 
                addition + 
                hardener + 
                brand_tmp + 
                (brand_tmp == brands::HYPERV_ARTIFACT ? "" : " VM");

            memo::conclusion::store(result.c_str());

            return result;
        };

        if (has_hardener) {
            return make_conclusion(inside_vm);
        }

        if (core::is_enabled(flags, DYNAMIC)) {
            if (percent_tmp == 0) { return "Running on baremetal"; }
            else if (percent_tmp <= 20) { return make_conclusion(very_unlikely); }
            else if (percent_tmp <= 35) { return make_conclusion(unlikely); }
            else if (percent_tmp < 50) { return make_conclusion(potentially); }
            else if (percent_tmp <= 62) { return make_conclusion(might); }
            else if (percent_tmp <= 75) { return make_conclusion(likely); }
            else if (percent_tmp < 100) { return make_conclusion(very_likely); }
        }

        if (percent_tmp == 100) {
            return make_conclusion(inside_vm);
        }

        return "Running on baremetal";
    }


    /**
     * @brief Returns whether it suspects the environment has anti-VM hardening
     * @return bool
     */
    static bool is_hardened() {
        if (memo::hardened::cached) {
            return memo::hardened::result;
        }

        auto hardened_logic = []() -> bool {
            // Helper to get the specific brand associated with a technique using the cache.
            auto detected_brand = [](const enum_flags flag) -> const char* {
                if (!check(flag)) {
                    return brands::NULL_BRAND;
                }
                if (memo::cache_table[flag].has_value) {
                    const char* b = memo::cache_table[flag].brand_name;
                    return (b != nullptr) ? b : brands::NULL_BRAND;
                }
                return brands::NULL_BRAND;
            };

            const bool hv_present = (check(VM::HYPERVISOR_BIT) || check(VM::HYPERVISOR_STR));

            // rule 1: if VM::FIRMWARE is detected, so should VM::HYPERVISOR_BIT or VM::HYPERVISOR_STR
            const char* firmware_brand = detected_brand(VM::FIRMWARE);
            if (firmware_brand != brands::NULL_BRAND && !hv_present) {
                return true;
            }

        #if (LINUX)
            // rule 2: if VM::FIRMWARE is detected, so should VM::CVENDOR (QEMU or VBOX)
            if (firmware_brand == brands::QEMU || firmware_brand == brands::VBOX) {
                const char* cvendor_brand = detected_brand(VM::CVENDOR);
                if (firmware_brand != cvendor_brand) {
                    return true;
                }
            }
        #endif

        #if (WINDOWS)        
            // rule 3: if VM::ACPI_SIGNATURE (QEMU) is detected, so should VM::FIRMWARE (QEMU)
            const char* acpi_brand = detected_brand(VM::ACPI_SIGNATURE);
            if (acpi_brand == brands::QEMU && firmware_brand != brands::QEMU) {
                return true;
            }

            // rule 4: if VM::TRAP or VM::NVRAM is detected, so should VM::HYPERVISOR_BIT or VM::HYPERVISOR_STR
            if ((check(VM::TRAP) || check(VM::NVRAM)) && !hv_present) {
                return true;
            }
        #endif

            return false;
        };

        const bool result = hardened_logic();

        memo::hardened::result = result;
        memo::hardened::cached = true;

        return result;
    }


    #pragma pack(push, 1)
    struct vmaware {
        std::string brand;
        std::string type;
        std::string conclusion;
        bool is_vm;
        u8 percentage;
        u8 detected_count;
        u16 technique_count;
        std::vector<enum_flags> detected_techniques;
        std::vector<std::string> detected_technique_strings;
        std::vector<enum_flags> disabled_techniques;

        template <typename ...Args>
        vmaware(Args&& ...args) {
            const flagset flags = core::arg_handler(args...);
            initialise(flags);
        }

        vmaware(const flagset &flags) {
            initialise(flags);
        }

        // having this design avoids some niche errors
        void initialise(const flagset &flags) {
            brand = VM::brand(flags);
            type = VM::type(flags);
            conclusion = VM::conclusion(flags);
            is_vm = VM::detect(flags);
            percentage = VM::percentage(flags);
            detected_count = VM::detected_count(flags);
            technique_count = VM::technique_count;
            detected_techniques = VM::detected_enums(flags);
            detected_technique_strings = [&]() -> std::vector<std::string> {
                std::vector<std::string> tmp{};

                for (const auto technique : detected_techniques) {
                    tmp.push_back(VM::flag_to_string(technique));
                }

                return tmp;
            }();
            disabled_techniques = VM::disabled_techniques;
        }

    };
    #pragma pack(pop)
};

// ============= EXTERNAL DEFINITIONS =============
// These are added here due to warnings related to C++17 inline variables for C++ standards that are under 17
// It's easier to just group them together rather than having C++17<= preprocessors with inline stuff
char VM::memo::conclusion::cache[512] = { 0 };
bool VM::memo::conclusion::cached = false;

// scoreboard list of brands, if a VM detection technique detects a brand, that will be incremented here as a single point
std::array<VM::core::brand_entry, VM::core::MAX_BRANDS> VM::core::brand_scoreboard = []() {
    std::array<VM::core::brand_entry, VM::core::MAX_BRANDS> arr{};
    size_t i = 0;

    auto insert = [&](const char* n) noexcept {
        if (i < VM::core::MAX_BRANDS) {
            arr[i] = { n, 0 };
            i++;
        }
    };

    insert(brands::VBOX);
    insert(brands::VMWARE);
    insert(brands::VMWARE_EXPRESS);
    insert(brands::VMWARE_ESX);
    insert(brands::VMWARE_GSX);
    insert(brands::VMWARE_WORKSTATION);
    insert(brands::VMWARE_FUSION);
    insert(brands::VMWARE_HARD);
    insert(brands::BHYVE);
    insert(brands::KVM);
    insert(brands::QEMU);
    insert(brands::QEMU_KVM);
    insert(brands::KVM_HYPERV);
    insert(brands::QEMU_KVM_HYPERV);
    insert(brands::HYPERV);
    insert(brands::HYPERV_VPC);
    insert(brands::PARALLELS);
    insert(brands::XEN);
    insert(brands::ACRN);
    insert(brands::QNX);
    insert(brands::HYBRID);
    insert(brands::SANDBOXIE);
    insert(brands::DOCKER);
    insert(brands::WINE);
    insert(brands::VPC);
    insert(brands::ANUBIS);
    insert(brands::JOEBOX);
    insert(brands::THREATEXPERT);
    insert(brands::CWSANDBOX);
    insert(brands::COMODO);
    insert(brands::BOCHS);
    insert(brands::NVMM);
    insert(brands::BSD_VMM);
    insert(brands::INTEL_HAXM);
    insert(brands::UNISYS);
    insert(brands::LMHS);
    insert(brands::CUCKOO);
    insert(brands::BLUESTACKS);
    insert(brands::JAILHOUSE);
    insert(brands::APPLE_VZ);
    insert(brands::INTEL_KGT);
    insert(brands::AZURE_HYPERV);
    insert(brands::SIMPLEVISOR);
    insert(brands::HYPERV_ARTIFACT);
    insert(brands::UML);
    insert(brands::POWERVM);
    insert(brands::GCE);
    insert(brands::OPENSTACK);
    insert(brands::KUBEVIRT);
    insert(brands::AWS_NITRO);
    insert(brands::PODMAN);
    insert(brands::WSL);
    insert(brands::OPENVZ);
    insert(brands::BAREVISOR);
    insert(brands::HYPERPLATFORM);
    insert(brands::MINIVISOR);
    insert(brands::INTEL_TDX);
    insert(brands::LKVM);
    insert(brands::AMD_SEV);
    insert(brands::AMD_SEV_ES);
    insert(brands::AMD_SEV_SNP);
    insert(brands::NEKO_PROJECT);
    insert(brands::QIHOO);
    insert(brands::NOIRVISOR);
    insert(brands::NSJAIL);
    insert(brands::DBVM);
    insert(brands::UTM);
    insert(brands::COMPAQ);
    insert(brands::INSIGNIA);
    insert(brands::CONNECTIX);
    insert(brands::NULL_BRAND);

    return arr;
}();

// Dynamically count the brands initialized above
size_t VM::core::brand_count = []() -> size_t {
    size_t c = 0;
    for (const auto& b : VM::core::brand_scoreboard) {
        if (b.name != nullptr) c++;
    }
    return c;
}();

// initial definitions for cache items because C++ forbids in-class initializations
std::array<VM::memo::cache_entry, VM::enum_size + 1> VM::memo::cache_table{};
char VM::memo::brand::brand_cache[512] = { 0 };
char VM::memo::multi_brand::brand_cache[1024] = { 0 };
char VM::memo::cpu_brand::brand_cache[128] = { 0 };
char VM::memo::bios_info::manufacturer[256] = { 0 };
char VM::memo::bios_info::model[128] = { 0 };
bool VM::memo::brand::cached = false;
bool VM::memo::multi_brand::cached = false;
bool VM::memo::cpu_brand::cached = false;
bool VM::memo::bios_info::cached = false;
bool VM::memo::hyperx::cached = false;
bool VM::memo::hardened::result = false;
bool VM::memo::hardened::cached = false;
VM::u32 VM::memo::threadcount::threadcount_cache = 0;
VM::hyperx_state VM::memo::hyperx::state = VM::HYPERV_UNKNOWN;
std::array<VM::memo::leaf_entry, VM::memo::leaf_cache::CAPACITY> VM::memo::leaf_cache::table{};
std::size_t VM::memo::leaf_cache::count = 0;
std::size_t VM::memo::leaf_cache::next_index = 0;
const char* VM::core::last_detected_brand = nullptr;
VM::u8 VM::core::last_detected_score = 0;

// these are basically the base values for the core::arg_handler function.
// It's like a bucket that will collect all the bits enabled. If for example 
// VM::detect(VM::HIGH_THRESHOLD) is passed, the HIGH_THRESHOLD bit will be 
// collected to this flagset (std::bitset) variable, and eventually be provided
// as the return value for actual end-user functions like VM::detect() to operate on.
VM::flagset VM::core::flag_collector;
VM::flagset VM::core::disabled_flag_collector;


VM::u8 VM::detected_count_num = 0;

std::vector<VM::enum_flags> VM::disabled_techniques = []() {
    std::vector<VM::enum_flags> c;
    c.push_back(VM::VMWARE_DMESG);
    return c;
}();

// this value is incremented each time VM::add_custom is called
VM::u16 VM::technique_count = base_technique_count;

// this is initialised as empty, because this is where custom techniques can be added at runtime 
std::vector<VM::core::custom_technique> VM::core::custom_table = {

}; 
size_t VM::core::custom_table_size = 0;

// the 0~100 points are debatable, but we think it's fine how it is. Feel free to disagree
std::array<VM::core::technique, VM::enum_size + 1> VM::core::technique_table = []() {
    std::array<VM::core::technique, VM::enum_size + 1> table{};
    // FORMAT: { VM::<ID>, { certainty%, function pointer } },
    const VM::core::technique_entry entries[] = {
        // START OF TECHNIQUE TABLE
        #if (WINDOWS)
            {VM::TRAP, {100, VM::trap}},
            {VM::ACPI_SIGNATURE, {100, VM::acpi_signature}},
            {VM::NVRAM, {100, VM::nvram}},
            {VM::CLOCK, {45, VM::clock}},
            {VM::POWER_CAPABILITIES, {45, VM::power_capabilities}},
            {VM::CPU_HEURISTIC, {90, VM::cpu_heuristic}},
            {VM::BOOT_LOGO, {100, VM::boot_logo}},
            {VM::MSR, {100, VM::msr}},
            {VM::GPU_CAPABILITIES, {45, VM::gpu_capabilities}},
            {VM::SMBIOS_INTEGRITY, {50, VM::smbios_integrity}},
            {VM::DISK_SERIAL, {100, VM::disk_serial_number}},
            {VM::EDID, {100, VM::edid}},
            {VM::IVSHMEM, {100, VM::ivshmem}},
            {VM::DRIVERS, {100, VM::drivers}},
            {VM::DEVICE_HANDLES, {100, VM::device_handles}},
            {VM::VIRTUAL_PROCESSORS, {100, VM::virtual_processors}},
            {VM::KERNEL_OBJECTS, {100, VM::kernel_objects}},
            {VM::HYPERVISOR_QUERY, {100, VM::hypervisor_query}},
            {VM::AUDIO, {25, VM::audio}},
            {VM::DISPLAY, {25, VM::display}},
            {VM::WINE, {100, VM::wine}},
            {VM::DLL, {50, VM::dll}},
            {VM::DBVM, {150, VM::dbvm}},
            {VM::UD, {100, VM::ud}},
            {VM::BLOCKSTEP, {100, VM::blockstep}},
            {VM::VMWARE_BACKDOOR, {100, VM::vmware_backdoor}},
            {VM::VIRTUAL_REGISTRY, {90, VM::virtual_registry}},
            {VM::MUTEX, {100, VM::mutex}},
            {VM::DEVICE_STRING, {25, VM::device_string}},
            {VM::VPC_INVALID, {75, VM::vpc_invalid}},
            {VM::VMWARE_STR, {35, VM::vmware_str}},
            {VM::GAMARUE, {10, VM::gamarue}},
            {VM::CUCKOO_DIR, {30, VM::cuckoo_dir}},
            {VM::CUCKOO_PIPE, {30, VM::cuckoo_pipe}},
        #endif

        #if (LINUX || WINDOWS)
            {VM::FIRMWARE, {100, VM::firmware}},
            {VM::PCI_DEVICES, {95, VM::pci_devices}},
            {VM::SYSTEM_REGISTERS, {50, VM::system_registers}},
            {VM::AZURE, {30, VM::azure}},
        #endif

        #if (LINUX)
            {VM::SMBIOS_VM_BIT, {50, VM::smbios_vm_bit}},
            {VM::KMSG, {5, VM::kmsg}},
            {VM::CVENDOR, {65, VM::chassis_vendor}},
            {VM::QEMU_FW_CFG, {70, VM::qemu_fw_cfg}},
            {VM::SYSTEMD, {35, VM::systemd_virt}},
            {VM::CTYPE, {20, VM::chassis_type}},
            {VM::DOCKERENV, {30, VM::dockerenv}},
            {VM::DMIDECODE, {55, VM::dmidecode}},
            {VM::DMESG, {55, VM::dmesg}},
            {VM::HWMON, {35, VM::hwmon}},
            {VM::LINUX_USER_HOST, {10, VM::linux_user_host}},
            {VM::VMWARE_IOMEM, {65, VM::vmware_iomem}},
            {VM::VMWARE_IOPORTS, {70, VM::vmware_ioports}},
            {VM::VMWARE_SCSI, {40, VM::vmware_scsi}},
            {VM::VMWARE_DMESG, {65, VM::vmware_dmesg}},
            {VM::QEMU_VIRTUAL_DMI, {40, VM::qemu_virtual_dmi}},
            {VM::QEMU_USB, {20, VM::qemu_USB}},
            {VM::HYPERVISOR_DIR, {20, VM::hypervisor_dir}},
            {VM::UML_CPU, {80, VM::uml_cpu}},
            {VM::VBOX_MODULE, {15, VM::vbox_module}},
            {VM::SYSINFO_PROC, {15, VM::sysinfo_proc}},
            {VM::DMI_SCAN, {50, VM::dmi_scan}},
            {VM::PODMAN_FILE, {5, VM::podman_file}},
            {VM::WSL_PROC, {30, VM::wsl_proc_subdir}},
            {VM::FILE_ACCESS_HISTORY, {15, VM::file_access_history}},
            {VM::MAC, {20, VM::mac_address_check}},
            {VM::NSJAIL_PID, {75, VM::nsjail_proc_id}},
            {VM::BLUESTACKS_FOLDERS, {5, VM::bluestacks}},
            {VM::AMD_SEV, {50, VM::amd_sev}},
            {VM::TEMPERATURE, {80, VM::temperature}},
            {VM::PROCESSES, {40, VM::processes}},
        #endif    

        #if (LINUX || APPLE)
            {VM::THREAD_COUNT, {35, VM::thread_count}},
        #endif

        #if (APPLE)
            {VM::MAC_MEMSIZE, {15, VM::hw_memsize}},
            {VM::MAC_IOKIT, {100, VM::io_kit}},
            {VM::MAC_SIP, {100, VM::mac_sip}},
            {VM::IOREG_GREP, {100, VM::ioreg_grep}},
            {VM::HWMODEL, {100, VM::hwmodel}},
            {VM::MAC_SYS, {100, VM::mac_sys}},
        #endif

        {VM::TIMER, {150, VM::timer}},
        {VM::THREAD_MISMATCH, {50, VM::thread_mismatch}},
        {VM::VMID, {100, VM::vmid}},
        {VM::CPU_BRAND, {95, VM::cpu_brand}},
        {VM::CPUID_SIGNATURE, {95, VM::cpuid_signature}},
        {VM::HYPERVISOR_STR, {100, VM::hypervisor_str}},
        {VM::HYPERVISOR_BIT, {100, VM::hypervisor_bit}},
        {VM::BOCHS_CPU, {100, VM::bochs_cpu}},
        {VM::KGT_SIGNATURE, {80, VM::intel_kgt_signature}}
        // END OF TECHNIQUE TABLE
    };

    // fill the table based on ID
    for (const auto& entry : entries) {
        if (entry.id < table.size()) {
            table[entry.id] = entry.tech;
        }
    }
    return table;
}();

#endif // include guard end
```